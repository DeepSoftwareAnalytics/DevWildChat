[
    {
        "link": "https://nuclino.com/articles/functional-requirements",
        "document": "Learn how to define requirements and keep all stakeholders aligned.\n\nGetting the requirements right is the key to the success of any project. Failure to accurately define and document them inevitably results in miscommunication between stakeholders, constant revisions, and unnecessary delays. Studies show that unclear or poorly documented requirements can increase the project timeline and budget by up to 60%.\n\nWith the growing popularity of the Agile approach to documentation, some teams have started to neglect documenting requirements – after all, it's \"working software over comprehensive documentation\", right?\n\nAlas, it's a common misconception, and foregoing proper internal documentation can be particularly damaging when it comes to requirements. In this article, we'll dive deeper into what functional requirements are and why it's vital to document them.\n• Why functional requirements need to be documented\n\nFunctional requirements are product features that developers must implement to enable the users to achieve their goals. They define the basic system behavior under specific conditions.\n\nFunctional requirements should not be confused with other types of requirements in product management:\n• None Business requirements describe the high-level business needs, such as carving a market share, reducing customer churn, or improving the customers' lifetime value.\n• None User requirements cover the different goals your users can achieve using the product and are commonly documented in the form of user stories, use cases, and scenarios.\n• None Product requirements describe how the system needs to operate to meet the business and user requirements. They include functional requirements and non-functional requirements.\n\nFunctional requirements may be captured as part of a product requirements document (PRD) or in the form of a separate functional requirements document (FRD). Here's an example of what such a document may look like in Nuclino, a unified workspace for all your team's knowledge, docs, and projects – create an account and start documenting your requirements in one central place:\n\nWhy functional requirements need to be documented\n\nDocumenting and aligning on functional requirements has numerous benefits:\n• None The stakeholders have a single source of truth. Clearly documented requirements keep all developers, designers, and QA testers on the same page and working towards the same goal, avoiding misunderstandings.\n• None Less time is spent in meetings. When the team has a shared understanding and a written record, there is no need for regular meetings. Instead, stakeholders can rely more on asynchronous communication to stay aligned.\n• None Projects become more predictable. Detailed, high-quality requirements allow the team to estimate the development time and cost more accurately and develop a product that meets the expectations.\n• None Problems can be identified sooner. Thoroughly capturing functional requirements during the discovery phase helps identify errors early on and correct them, saving time and resources.\n\nIf your company specializes in developing custom software solutions, such as third-party API integrations or complex data management systems, the meticulous documentation of functional requirements becomes even more critical. Clear documentation ensures that the tailored solutions you deliver align precisely with your clients' unique needs.\n\nFunctional requirements need to be clear, simple, and unambiguous. Here are some examples of well-written functional requirements:\n• None The system must send a confirmation email whenever an order is placed.\n• None The system must allow blog visitors to sign up for the newsletter by leaving their email.\n• None The system must allow users to verify their accounts using their phone number.\n\nContrary to a popular misconception, functional requirements are not analogous to user stories, but stories can be a useful tool for deriving requirements with the user in mind. For example:\n• None User story: As an existing user, I want to be able to log into my account.\n• None The system must allow users to log into their account by entering their email and password.\n• None The system must allow users to log in with their Google accounts.\n• None The system must allow users to reset their password by clicking on \"I forgot my password\" and receiving a link to their verified email address.\n\nWhen capturing product requirements, it's important to distinguish between functional and non-functional requirements.\n\nTo put it simply, functional requirements describe what the product should do, while non-functional requirements place constraints on how the product should do it. They can be expressed in the following form:\n• None Functional requirement: \"The system must do [requirement].\"\n• None Non-functional requirement: \"The system shall be [requirement].\"\n\nFunctional requirements – as the name implies – refer to specific product functionality. Defining, measuring, and testing them is usually a straightforward task.\n\nOn the other hand, non-functional requirements (also known as \"quality requirements\" or \"quality attributes\") are more abstract. They impose constraints on the implementation of the functional requirements in terms of performance, security, reliability, scalability, portability, and so on.\n\nNFRs are not themselves backlog items, but they are just as important since they ensure the usability and effectiveness of the entire software system. A transaction that takes 20 seconds to successfully complete may be functional – but it's certainly not usable.\n\nEvery functional requirement typically has a set of related non-functional requirements, for example:\n• None Functional requirement: \"The system must allow the user to submit feedback through a contact form in the app.\"\n• None Non-functional requirement: \"When the submit button is pressed, the confirmation screen must load within 2 seconds.\"\n\nThere is no universally accepted functional requirements document template, and it's up to you and your team which style and format to follow. However, there are several best practices that apply in most cases.\n\nIn the past, most teams used Microsoft Word to create and manage functional requirements. This inevitably led to out-of-date, inaccurate FRDs bouncing around the team's inboxes.\n\nFortunately, now you have more options to choose from. Select a tool that facilitates collaboration and ensures that everyone always has the latest version to avoid confusion. For example, you could store your requirements in a Google Doc, or better, in your team's documentation tool or internal wiki, which can be easily set up in Nuclino.\n\nWhile Nuclino can be used exclusively as a documentation tool, it's highly versatile and capable of much more. It offers a variety of ways to structure and visualize your content, including a nested list, a Kanban board, a table, and a mindmap-style graph. This makes Nuclino a great solution for many additional use cases, including project collaboration, sprint planning, asynchronous communication, and more. Nuclino works like a collective brain, allowing you to bring all your team's work together and collaborate without the chaos of files and folders, context switching, or silos.\n\nVisual collaboration is also seamlessly built into Nuclino. You can add an infinite collaborative canvas anywhere and use it to create diagrams and whiteboards without having to switch tools.\n\nYour FRD needs to be a living document, evolving as your project progresses. To ensure that everyone stays on the same page, every stakeholder needs to continuously contribute. Involve your team early on and collaboratively keep the requirements up-to-date.\n\nBe as clear as possible\n\nWell-written functional requirements typically have the following characteristics:\n• None Necessary. Although functional requirements may have different priority, every one of them needs to relate to a particular business goal or user requirement.\n• None Concise. Use simple and easy-to-understand language without any unnecessary jargon to prevent confusion or misinterpretations.\n• None Attainable. All requirements you include need to be realistic within the time and budget constraints set in the business requirements document.\n• None Granular. Do not try to combine many requirements within one. The more precise and granular your requirements are, the easier it is to manage them.\n• None Consistent. Make sure the requirements do not contradict each other and use consistent terminology.\n• None Verifiable. It should be possible to determine whether the requirement has been met at the end of the project.\n\nUnclear or confusing requirements can create as many problems as undocumented ones. The scope of the project becomes fuzzy, leading to missed deadlines, unforeseen costs, and wasted effort. Making sure the requirements are documented in a way that leaves no room for interpretation can help you avoid these and many other issues down the road.\n\nNuclino brings all your team's knowledge, docs, and projects together in one place. It's a modern, simple, and blazingly fast way to collaborate, without the chaos of files and folders, context switching, or silos.\n• None Create a central knowledge base and give your team a single source of truth.\n• None Collaborate in real time or asynchronously and spend less time in meetings.\n• None Manage and document your projects in one place without losing context.\n• None Organize, sort, and filter all kinds of data with ease.\n• None Integrate the tools you love, like Slack, Google Drive, Figma, Lucidchart, and more.\n\nTry it now"
    },
    {
        "link": "https://qat.com/guide-functional-requirements",
        "document": "The Essential Guide to Functional Requirements: Definition, Examples, and Best Practices Functional requirements are the backbone of any software development project, outlining the specific features, capabilities, and behaviors a software system must exhibit. They define the “what” of the system, focusing on its functionality and user interactions. Understanding functional requirements is crucial for software development teams to deliver a solution that meets the needs and expectations of stakeholders. This guide will explore the definition of functional requirements, provide real-world examples, and discuss best practices for effectively documenting and managing them throughout the software development lifecycle. Whether you are a business analyst, project manager, or developer, this guide will equip you with the knowledge and tools to create robust and successful software solutions that align with user requirements and business goals. Functional requirements in software development refer to the specific behaviors, features, and capabilities a software system must possess. They define what the software should do, how it should perform certain tasks, and how it should respond to user interactions. Functional requirements are derived from the needs and expectations of stakeholders and serve as the foundation for designing, implementing, and testing the software. They provide a clear roadmap for development teams to build a solution that meets the intended purpose and functionality. Functional requirements play a vital role in software development as they directly address the desired functionality of the system. They ensure the software meets user needs, aligns with business objectives, and provides the expected capabilities. By clearly defining functional requirements, development teams can effectively plan, design, and implement the software solution, reducing the risk of miscommunication and misunderstandings. Functional requirements serve as a refe\n\n rence point for developers, testers, and other stakeholders throughout the software development lifecycle, guiding their efforts to deliver a high-quality product. Functional requirements possess several key characteristics that distinguish them from other types of requirements:\n• Behavior-Oriented: Functional requirements focus on the behavior and actions of the software system. They describe what the system should do in response to specific inputs or user interactions. For example, a functional requirement may specify that the system display a user registration form when clicking the “Sign Up” button.\n• Measurable and Testable: Functional requirements are defined to enable objective measurement and testing. They can be validated through various techniques, such as functional testing, to ensure that the software behaves as expected. For instance, a functional requirement might be tested by verifying that the system calculates and displays accurate order totals.\n• Specific and Concrete: Functional requirements are precise and unambiguous, providing clear instructions on the expected behavior of the software. They avoid subjective language and vague descriptions, allowing developers to understand and implement them accurately. Well-defined functional requirements leave no room for misinterpretation. Functional requirements can be categorized into different types, depending on their focus and scope:\n• User Requirements: These requirements capture the desired functionality from the end user’s perspective. They outline the features, interactions, and user interface elements that enable users to accomplish their tasks effectively. User requirements consider the user experience, usability, and accessibility aspects of the software system.\n• System Requirements: System requirements encompass the behavior and functionality required at the system level. They address how different system components interact with each other and with external systems. System requirements also include performance criteria, such as response times or throughput, to ensure the software system meets desired performance levels.\n• Business Requirements: Business requirements align the software system with the organization’s objectives, processes, and workflows. They consider the business rules, policies, and constraints that need to be implemented. Business requirements focus on delivering value and achieving business goals through the software solution. Understanding these types of functional requirements allows development teams to capture and address the specific needs and expectations of users, system components, and the overall business context. By categorizing functional requirements, teams can prioritize and organize their efforts effectively, ensuring the development of a software solution that meets all relevant criteria.\n\nUser interface requirements focus on the user’s interaction with the software system. Examples of user interface functional requirements include:\n• Navigation: The system shall provide a clear and intuitive navigation menu, allowing users to easily move between different application sections.\n• Forms: The system shall validate user inputs in forms, displaying error messages for invalid entries and ensuring data integrity.\n• Interactions: The system shall provide interactive elements, such as buttons, checkboxes, and dropdowns, that allow users to perform specific actions, such as submitting a form or selecting preferences. Data processing requirements specify how the software system handles and processes data. Examples of data processing functional requirements include:\n• Data Validation: The system shall validate user inputs for accuracy and completeness, ensuring that the data entered meets predefined criteria or constraints.\n• Calculations: The system shall perform mathematical calculations accurately, such as computing totals, averages, or complex formulas based on user inputs.\n• Storage: The system shall securely store and retrieve data, ensuring data integrity and accessibility for authorized users. Integration requirements focus on the seamless integration of the software system with external systems, services, or APIs. Examples of integration functional requirements include:\n• API Integration: The system shall integrate with external APIs to retrieve data from third-party services, such as payment gateways or mapping services.\n• Data Exchange: The system shall support the import and export of data in various formats, allowing seamless data exchange with other systems or software applications.\n• Real-Time Updates: The system shall synchronize data in real time with external systems to ensure up-to-date information and prevent data inconsistencies. Security requirements address the protection of data, access control, and authentication within the software system. Examples of security functional requirements include:\n• Access Control: The system shall enforce role-based access control, allowing different levels of access based on user roles and permissions.\n• Authentication: The system shall support secure authentication mechanisms, such as username/password, two-factor authentication, or single sign-on, to ensure authorized access.\n• Data Encryption: The system shall encrypt sensitive data, such as passwords or personal information, both during transmission and storage to protect against unauthorized access. These examples highlight how functional requirements can be defined in various aspects of a software system, ensuring that it delivers the intended functionality, usability, data integrity, integration capabilities, and security. By capturing these real-world examples, development teams can effectively document and address the specific requirements of each functional area, resulting in a comprehensive and robust software solution. Effective requirements elicitation techniques are essential for capturing accurate and comprehensive functional requirements. Consider the following techniques:\n• Interviews: Conduct interviews with stakeholders, users, and subject matter experts to gain insights into their needs, expectations, and workflows.\n• Prototyping: Create interactive prototypes or mockups to elicit feedback and validate requirements early in the development process. Documenting functional requirements using clear, concise, and unambiguous language is crucial to avoid misunderstandings. Follow these practices:\n• Use clear terminology and avoid technical jargon that may confuse stakeholders.\n• Ensure each requirement is expressed as a single, specific statement, avoiding vague or ambiguous language.\n• Define any acronyms or abbreviations used to maintain clarity throughout the document. Prioritizing requirements and establishing traceability are key practices to ensure alignment with project goals and facilitate effective project management. Consider these strategies:\n• Prioritize requirements based on their criticality,\n\n business value, or user needs. This helps focus efforts on the most important functionalities.\n• Establish traceability by assigning unique identifiers to each requirement and linking them to related business objectives, user stories, or system components. This enables tracking of requirements throughout the development lifecycle. Involving stakeholders in the requirement validation and refinement process fosters collaboration, reduces rework, and improves the overall quality of the functional requirements. Consider these best practices:\n• Conduct regular reviews and feedback sessions with stakeholders to ensure their needs and expectations are adequately addressed.\n• Encourage open communication channels to allow stakeholders to provide timely input and suggestions.\n• Embrace an iterative approach, refining requirements based on ongoing feedback and evolving project needs. By adopting these best practices, development teams can ensure the accurate documentation of functional requirements. This promotes effective communication, minimizes misunderstandings, and enhances the chances of delivering a successful software solution that meets stakeholders’ needs and aligns with project goals.\n\nWhen writing functional requirements, it is important to follow certain best practices to ensure clarity, completeness, and effectiveness. Here are some best practices for writing functional requirements:\n• Use Clear and Concise Language:\n• Express requirements using clear, unambiguous language to avoid any misunderstandings.\n• Keep sentences concise and to the point, focusing on the specific functionality being described.\n• Start with Action Verbs:\n• Begin each requirement with an action verb to clearly indicate the desired action or behavior.\n• Use verbs such as “create,” “display,” “calculate,” “validate,” etc., to describe the intended system actions.\n• Be Specific and Unambiguous:\n• Clearly define what needs to be achieved or what behavior is expected from the software system.\n• Avoid vague terms or ambiguous phrases that can lead to multiple interpretations.\n• Include Preconditions and Postconditions:\n• Specify any necessary preconditions or prerequisites for the requirement to be executed successfully.\n• Include postconditions that describe the expected system state or outcome after the requirement is fulfilled.\n• Use Functional Decomposition:\n• Break down complex requirements into smaller, manageable components using functional decomposition.\n• Decompose high-level requirements into sub-requirements or sub-functions to ensure clarity and ease of implementation.\n• Include Inputs, Outputs, and Constraints:\n• Clearly state the inputs required for the functionality, including data, user interactions, or external system interactions.\n• Specify the expected outputs or results of the functionality.\n• Identify any constraints or limitations that may impact the functionality, such as performance constraints or compatibility requirements.\n• Use Examples and Scenarios:\n• Include relevant examples or scenarios to illustrate the desired behavior or use cases of the functionality.\n• Examples help in understanding the requirement and provide context to the development team.\n• Avoid Implementation Details:\n• Focus on describing the desired behavior or outcome rather than specifying how it should be implemented.\n• Avoid prescribing specific technical solutions, algorithms, or design details in the functional requirements.\n• Incorporate Validation and Acceptance Criteria:\n• Define specific criteria or conditions that will be used to validate and verify the successful implementation of the requirement.\n• Include acceptance criteria that can be used to determine if the functionality meets the desired expectations.\n• Review and Validate:\n• Regularly review and validate the functional requirements with stakeholders, including clients, users, and the development team.\n• Ensure the requirements accurately reflect the desired functionality and align with the project goals.\n• Maintain Traceability:\n• Establish traceability between functional requirements and other project artifacts, such as design documents, test cases, and user stories.\n• Maintain a traceability matrix or traceability links to track the relationship between requirements and other project elements. Following these best practices for writing functional requirements can help ensure that the requirements are clear, unambiguous, and actionable. Effective communication and collaboration with stakeholders throughout the requirement gathering and documentation process is essential for capturing the desired functionality accurately. Effective documentation of functional requirements is crucial for clear communication and shared understanding among stakeholders. Consider the following practices:\n• Structure and logically organize the requirements document, using sections, headings, and subheadings to create a clear hierarchy.\n• Utilize visual aids, such as diagrams, flowcharts, or wireframes, to illustrate complex interactions or system behavior.\n• Employ use cases or user stories to capture requirements from the user’s perspective, providing a narrative of how the system should function. Verification and validation of functional requirements ensure they are complete, consistent, and aligned with stakeholders’ expectations. Employ the following techniques:\n• Inspections: Conduct thorough inspections of the requirements document, involving relevant stakeholders and subject matter experts to identify any inconsistencies, ambiguities, or gaps.\n• Reviews: Organize formal reviews of the functional requirements, soliciting feedback from project team members and stakeholders to validate their accuracy and completeness.\n• Testing: Develop test cases and scenarios based on the functional requirements to verify that the software system behaves as intended. Testers can ensure that all requirements are adequately addressed and that the system functions as expected. Managing changes to functional requirements is essential as project needs and priorities evolve. Consider these strategies for effective change management:\n• Establish a change control process that defines how changes to requirements are identified, evaluated, approved, and implemented.\n• Maintain proper documentation and version control of functional requirements to track changes and ensure traceability throughout the development process.\n• Evaluate the impact of proposed changes on other requirements, project timelines, and resources, and make informed decisions regarding their implementation. A requirement traceability matrix provides a systematic approach to ensuring that functional requirements are properly implemented, tested, and validated. Consider the following steps:\n• Assign unique identifiers to each requirement and include them in the traceability matrix.\n• Establish links between requirements and other artifacts, such as design documents, test cases, and source code, to demonstrate the traceability of requirements throughout the development lifecycle.\n• Regularly update the traceability matrix as requirements evolve, providing a comprehensive view of the relationships between requirements and project deliverables. By effectively managing functional requirements throughout the software development lifecycle, develo\n\n pment teams can maintain clarity, control, and alignment with stakeholders’ expectations. These practices help ensure that the software solution accurately reflects the desired functionality, enhances collaboration among team members, and increases the project’s overall success. Functional requirements are the building blocks of successful software development, defining the functionality and behavior of software systems. Software development teams can create solutions that align with user needs and business objectives by understanding the definition of functional requirements, exploring real-world examples, and following best practices for documenting and managing them. Adopting a systematic and collaborative approach to functional requirements ensures effective communication, reduces risks, and enhances the overall quality of the software solution. By leveraging the insights and practices outlined in this comprehensive guide, you will be well-equipped to navigate the complexities of functional requirements and drive the success of your software development projects."
    },
    {
        "link": "https://jamasoftware.com/requirements-management-guide/writing-requirements/functional-requirements-examples-and-templates",
        "document": "When we buy a new cell phone or TV or computer, do we buy-in for what it is? Of course not. We buy it for what it will do for us. Likewise, when companies or governments buy new systems or new enterprise software products, they couldn’t care less about the products themselves. What they care about is how those products will help them accomplish their goals, make them more efficient, and positively impact their bottom line or use of budget. It’s what the product does that’s important. In general, the first step in determining what a product does—what its functions are—is to determine its functional requirements. What are functional requirements? And what is their role in product development? In this article, we’ll answer those questions, provide examples of typical functional requirements and types of requirements, and offer tips for crafting good functional requirements and good functional requirement specifications.\n\nAs mentioned, functional requirements state what the product must do. In other words, they define the operation of the product. As such, they should normally be stated in terms of what the product’s outputs do in response to its inputs. In product development, functional requirements are typically decomposed into more detailed requirements at progressive levels of the design process. Their fulfillment is verified and validated through functional testing (software testing, integration testing, etc.). Functional requirements are always mandatory; they must be met by the product unless the requirement is changed. Non-functional requirements state constraints on the design and construction of the product. They are often dictated by contractual or regulatory requirements, which may include, among others: Non-functional requirements are not often decomposed into more detailed requirements. They are typically verified by inspection of the product and its documentation. Non-functional requirements will be mandatory if dictated by contractual or regulatory requirements. They may not be mandatory, however, if dictated by marketing goals or other internal objectives, as often occurs in consumer product development.\n\nThe first of these archetypes is the ubiquitous requirement. Ubiquitous functional requirements are always active. They are not invoked by an event or input, nor are they limited to a subset of the system’s operating states. Example: The control system shall prevent engine overspeed. State-driven functional requirements are active throughout the time a defined state remains true. In Mavin’s EARS method, state-driven requirements are identified with the keyword WHILE. Example: While the aircraft is in-flight and the engine is running, the control system shall maintain engine fuel flow above ?? lbs/sec. Event-driven functional requirements require a response only when an event is detected at the system boundary. In other words, they are triggered by a specific event. The EARS method identifies event-driven requirements with the keyword WHEN. Example: When continuous ignition is commanded by the aircraft, the control system shall switch on continuous ignition. Optional feature functional requirements apply only when an optional feature is present as a part of the system. These requirements are identified by the EARS method with the keyword WHERE. Example: Where the control system includes an overspeed protection function, the control system shall test the availability of the overspeed protection function before aircraft dispatch. Unwanted behavior functional requirements cover all undesirable situations. Good systems engineering (SE) practice anticipates undesirable situations and imposes requirements to mitigate them. Unwanted behavior requirements are often imposed when the system must respond to a trigger under less than optimum conditions. The EARS method uses the keyword combination IF/THEN to identify requirements aimed at mitigating unwanted behavior. Example: If the computed airspeed is unavailable, then the control system shall use modeled airspeed. Often, a specific set of one or more preconditions (states or optional features) must be present before the occurrence a specific event for that event to trigger a required system response. In such cases, the EARS templates may be combined, using a combination of the keywords. Complex requirements can be composed for desired behavior or for unwanted behavior. The EARS method provides a template for each. Example: While the aircraft is on the ground, when reverse thrust is commanded, the control system shall enable deployment of the thrust reverser.\n\n1. Be consistent in the use of modal verbs A modal verb, modal or modal auxiliary is a word such as “shall,” “must,” “will,” or “should” which is used with a main verb to express ideas such as necessity, intention, expectation, recommendation, or possibility. In engineering specifications, modal verbs are used to distinguish between binding requirements, non-binding recommendations, and the expected behavior of the system’s operational environment. As such, it is important that requirements authors be consistent in their use of modal verbs and that they convey to developers, testers, quality assurance engineers, and regulatory authorities exactly how each modal verb is intended to be interpreted within their specification. The use of modal verbs in specifications has long been a subject of debate in the SE/RE community. The consensus, however, is that “shall” and “must” are the best modal verb choices for expressing requirements, while “will” should be used to express expected external behavior or declarations of purpose. Non-binding recommendations or provisions can be expressed with “should” or “may.” Also, many organizations use the word “must” to express constraints and certain quality and performance requirements (non-functional require­ments). The use of “must” allows them to express constraints without resorting to passive voice and to easily distinguish between functional requirements (expressed with “shall”) and non-func­tional requirements (expressed with “must”). It is good SE/RE practice to define exactly how certain terms will be used within the document itself, and how they should be interpreted when found in non-requirements documents refer­enced by the document. This is usually done in a dedicated section toward the beginning of the specification. Another SE/RE best practice is to tag each requirement with a unique ID number or code. In fact, requirement identifiers are often a requirement them­selves. Systems purchased under a contract between a customer and a supplier—as in the case of most government-purchased systems, for example—are normally developed following an accepted industry standard like IEEE/EIA 12207 as a stipula­tion of the contract. Such standards typically require that each requirement in every requirements document be tagged with a project unique identifier (PUI). Assigning unique identifiers to requirements conveys a big benefit to the system developer. Tagging each requirement with a PUI facilitates and simplifies traceability between requirements at successive design levels and the tests that verify them. Brief identifiers make it easy to build traceability tables that clearly link each requirement to its ancestors in higher-level documents, and to the specific tests intended to verify it. Traceability tables simplify the process of demonstrating to the customer and internal stakeholders that the system has been developed to, and proven to comply with, the agreed top-level requirements. Automated requirements management tools typically include an automatic method of assigning unique identifiers, which streamlines this process. 3. Write only one requirement in each requirement statement Beware of long, complex requirement statements that include the word “and” and more than one modal verb. When trying to define a complicated functionality, it’s easy to fall into the trap of describing it all in a single paragraph or, worse yet, in a single sentence. Take the time to analyze long requirement statements. If they contain the word and or multiple “shalls” or other modals, they likely contain more than one requirement. Re-write them to obtain two or more simple requirement statements, each with its own shall. Then, give each its own unique identifier. 4. Write requirements statements as concisely as possible Another reason to analyze and re-write long requirements, even those with a single shall, is that long requirements are more likely to be misinterpreted than short, concise requirements. It is good SE/RE practice to write requirements that are as concise as possible. Requirements templates, like the EARS patterns described earlier, can be of great assistance in meeting this objective. 5. Make sure each requirement is testable. Each time you write a new functional requirement, you should ask yourself the following question: How will the successful implementation of this requirement be verified? Writing requirements with a specific test scenario in mind helps ensure both design and test engineers will understand what they have to do. The specific test case will influence how detailed the requirement will need to be. High-level requirements are often tested by inspection or through user testing and thus may be broad in scope. Lower-level requirements that will be verified through software testing or system integration testing will necessarily be specified to a finer degree of detail. For example, a best practice for ensuring testability is to specify a maximum reaction time for any output the software must produce in response to a specific input condition, as in this example: 3.8.5.3.1: The Engine Monitor shall set to TRUE within 0.5 seconds when 6. Clearly segregate requirement statements from rationale and other explanations. In requirement specifications, it’s useful to include the rationale for the requirement, its relationship to other requirements, and other explanation to provide context for developers and testers. Context can help prevent misinterpretation by clearing away possible ambiguities. It can help others fully understand the intent of the requirement and provide feedback that can help refine the requirement and make it even more unambiguous. But contextual information should not be included in the requirement statement itself. It’s important to segregate the two to keep the requirement itself clear and concise, and to avoid making the additional information subject to implementation and test. It’s a best practice to put contextual implementation in a separate paragraph that does not contain a unique identifier. A good Functional Requirements Document template or Requirements Management tool can make this goal easier to achieve.\n\nPutting together a cohesive, usable and easily navigable and FRD can be a challenge. Here are a few guidelines that can be helpful. To make your FRD easy to understand and use, organize it using a hierarchical structure. Suitable hierarchies can include (among others):\n• Helps contributors focus on each specific domain that needs to be addressed\n• Helps contributors easily find areas they need to modify when adding functionality to an existing system\n• Helps users (developers, testers) quickly drill down to the exact functional area they are looking for Spoken languages are full of words that have multiple definitions and which evoke subtle shades of meaning, depending on context. While great for self-expression, such broad flexibility can lead to confusion and disagreement when it comes to specifying and interpreting requirements. A good way to reduce ill-definition and misinterpretation of requirements is to standardize some of the language used to express them. Create a glossary of standardized terms toward the beginning of your requirements document. In this glossary, define exactly how certain terms will be used within the document itself, and how they should be interpreted when found in non-requirements documents referenced by the document. Strictly defining terms and adhering strictly to your definitions will not only reduce confusion among those tasked with interpreting your requirements; with practice, using standardized language will also save you time in writing requirements. When building any type of structure, it’s wise to start from a solid foundation or a proven model. When building a functional requirements document, it’s best to start from a good template. A good template will include standardized sections such as:\n• Guidelines for the use of modal verbs\n• Other guidelines your organization follows Standardized sections—or “boilerplate”—promote and facilitate consistency across projects, which is a major benefit of templates. These sections tend to remain little changed from project to project, and from team to team within a company. They evolve only slowly over time with changes in methodology and lessons learned. Thus, they provide a stable platform for consistent requirements development, employee education, and communication with customers. There are many general FRD templates available on the web. If you develop commercial products you may find one of the following can be tailored to your company’s practices and procedures: If your company develops systems or software for the U.S. Department of Defense, on the other hand, you might prefer a system specification template built to MIL-STD-961E (Department of Defense Standard Practice: Defense and Program-Unique Specifications Format and Content). QRA Corp offers one on their website: https://qracorp.com/requirements-document-templates/. One caveat to the last tip: using a template in a general documentation platform has a couple of drawbacks. First, documenting requirements in Word, Excel or Google Docs tends to make collaboration cumbersome. Second, those platforms are not built to support clear and systematic requirements traceability. Gartner says that one of the main reasons companies struggle to achieve adequate visibility and traceability in their requirement specifications is reliance on general document software rather than a collaborative requirements management platform. “The most widely adopted tools for requirements continue to be general document software such as Microsoft Office or Google Docs (40% to 50% of the market) due to cost, availability, and familiarity. Yet these often lead to poorly managed requirements, thus eliminating and exceeding any cost benefit the tools themselves have. Requirements end up captured in a variety of documents and spreadsheets supplemented by post-it notes in unmanaged versions with no traceability or reuse. This creates a more costly user acceptance testing cycle, both in the time to execute as well as remediation of issues found late in the process, where they are far more costly to address.” – Gartner Research Successful development, verification, and validation of good functional requirements are critical to product success. To achieve these goals system, software, hardware, test, and integration teams all must work closely together to assure the project’s functional requirements, non-functional requirements, test cases, and verification/validation procedures are all adequately defined. Visibility and traceability are critical to this process. A good requirements management (RM) platform will provide fields, formatting, and structural relationships to facilitate:\n• Portability of boilerplate sections from project to project Beyond those basic facilities, a state-of-the-art RM platform will also facilitate team collaboration by allowing all users access to your latest requirements baseline and all pending changes to it. This makes requirements tracking, traceability, and test coverage assurance far easier to accomplish than can be done using a document or spreadsheet. Learn more about how Jama Connect streamlines tracking and tracing requirements. See the solution."
    },
    {
        "link": "https://archives.obm.ohio.gov/Files/Major_Project_Governance/Resources/Resources_and_Templates/04_Plan/37_Requirements_10_Best_Practices.pdf",
        "document": ""
    },
    {
        "link": "https://requiment.com/functional-requirements-vs-business-requirements-explained",
        "document": ""
    },
    {
        "link": "https://geeksforgeeks.org/how-to-design-a-relational-database-for-e-commerce-website",
        "document": "How to Design a Relational Database for E-commerce Website\n\nIn the world of e-commerce, timely handling of extensive data is essential to help customers in shopping with convenience and pleasure. Each e-commerce platform has a robust relational database at its center, efficient enough to store, fetch, and change information about products, customers, orders, and so on.\n\nHere, we will explore the most important elements and principles related to developing a relationship database that will meet the e-commerce website requirements.\n\nE-Commerce Website allows easy management of products, orders, customers, categories, payments information as well as cart management. Products are categorized in a user-friendly manner, as well as users can register and create multiple addresses in one account. Orders are placed by customers.\n\nPayment methods are diversified which is aimed at enhancing security and flexibility in transactions. The shopping cart management system enables users to add, and check out products thereby helping with a smooth shopping process.\n• None Allow users to register and create accounts.\n• None Store user information such as name, email, and password securely.\n• None Display a catalog of products with details such as name, price, description, and images.\n• None Allow users to browse products by category.\n• None Allow users to add products to their shopping cart.\n• None Provide features for updating quantities and removing items from the cart.\n• None Calculate and display the total price of items in the cart.\n• None Collect order details such as order ID, date, and total amount.\n• None Provide order tracking functionality for users to monitor the status of their orders.\n• None Support multiple payment methods such as credit card, debit card, UPI, etc.\n• None Allow administrators to create, update, and delete product categories.\n• None Associate products with appropriate categories to facilitate navigation.\n• None Implement SSL encryption to secure data transmission between the client and server.\n• None Use authentication and authorization mechanisms to control access to sensitive information.\n• None Regularly audit and update security measures to protect against potential threats.\n• None Design the database schema for scalability to accommodate growth in data volume and user traffic.\n\nEntities and Attributes for the E-commerce Website\n\nEntities and Attributes are defined below:\n\n1. Product: Contains details about the product.\n• Name: Name of the product. \n\n\n\n2. Order: Contains details about the orders.\n• Order - Date: Date on which the order is placed.\n• User - ID(Primary Key): Unique identifier for each user or customer.\n• Name: Name of the user. \n\n\n\n4. Payment: Contains details about the payment.\n• Type: Payment methods like UPI or Credit Card etc. \n\n\n\n5. Cart: Contains details about the cart.\n\n6. Category: Contains details about the category options.\n• Name: Name of the category.\n• None Each order is placed by exactly one user.\n• one-to-many relationship, showing that a user can place multiple orders, but each order is placed by exactly one user.\n• None One product can be added to multiple carts.\n• None Each cart can contain multiple products.\n• None Each payment is made by exactly one user.\n• one-to-many relationship because each user can make multiple payments, and each payment is made by a single user.\n• None One order can contain multiple products.\n• None Many products are ordered in each order.\n• None So this is the one-to-many relationship we can order multiple products on each order.\n• None One order has only one payment.\n• None So this is a one-to-one relationship because one order has one payment and each payment is for an order.\n• None One product can belong to only one category.\n• None One category can have multiple products.\n• None So this is a Many-to-one relationship, showing that many products can belong to a single category.\n• Normalization: Normalize the database to a reasonable level so that redundant data can be minimized and the high quality of data is guaranteed.\n• Indexing: Proper index usage is critical, especially the use of indexes on columns which are frequently used for search or in the process of joining tables, as a way of boosting the performance of queries.\n• Data Types: Choose the right data type for each column to reduce memory usage and execute data manipulation operations quickly.\n• Foreign Keys: Establish foreign keys between the tables and enforce referential integrity by using them.\n• Optimized Queries: queries, for example, using the right joins without involving subqueries or overloading the data retrieval function.\n• Partitioning: Via the partitioning of large tables, it may be possible to make them more manageable and improve their query performance.\n• Backup and Recovery: Design strong backup and disaster recovery procedures to protect data against loss or damage.\n• Security Measures: Provide necessary security solutions, among others encryption and access control, which protect data from unauthorized access.\n\nThe creation of an entity-relationship model for an e-commerce site entail a lot of processes that involve evaluating the different sides like entity identification, relationship definition, normalization, indexing, data integrity, scalability, and performance. A database designed with precision must underpin the efficacy, reliability and scalability of a convenient e-commerce platform in order to attract more customers and satisfy their experience of shopping."
    },
    {
        "link": "https://fabric.inc/blog/commerce/ecommerce-database-design-example",
        "document": "Databases are vital tools for storing, managing, and retrieving information. They are also critical for building an e-commerce system. A well-structured database powers e-commerce and manages all the interactions within the system.\n• Simple, functional database structure: The database table structure is simple but covers all the required functionality without compromising the user experience.\n• High performance: Database queries execute quickly to facilitate live customer interactions and support a frictionless shopping experience. Therefore, the selected database should have good indexing and performance optimization options.\n• High availability and scalability: A good database design is highly available with automatic snapshots and enables automatic scaling to support future platform growth as well as sudden traffic spikes.\n\nBased on these characteristics, a good e-commerce database design involves three key parts:\n• Database scope: The scope refers to the planned functionality of the database. The underlying table structure of the database, its relationships, and indexes all depend on the functionality of the e-commerce platform.\n• The type can vary from a relational database to a NoSQL database or a hybrid approach depending on the requirements and the underlying data structure.\n• Database infrastructure: Your database can be either unmanaged or managed. The former means spinning up your own database service; the latter means using something like Amazon RDS or Amazon DynamoDB.\n\nIn this article, we will review examples of e-commerce databases as they relate to these three areas. We will also explore database design alternatives that simplifying data management for e-commerce, specifically a product information manager.\n\n\n\nThe main consideration when designing the database is identifying the functionalities offered by the e-commerce platform. These functionalities can be further divided into core functions and additional functions.\n\nCore functions are the functions necessary for facilitating the day-to-day operations of the e-commerce platform, including user management, product and inventory management, shopping cart function, payment management, and shipping/logistics management.\n\nAdditional functions are the nice-to-have functions for the e-commerce platform that enhance the user experience for both end-users (customers) and administrators (the business). Additional functions include marketing functions, help desk and support, advanced analytics, and third-party integrations.\n\nIn this section, let’s see how to structure the database to facilitate the core functions. The following table structure is an example of a database design that covers the core functionality of an e-commerce platform.\n\nThis example covers all the basics of an e-commerce platform. Here, the table fields and indexes depending on the design of the overall platform. It contains three separate sections for user management, product management, and shopping process. Let’s have a closer look at each section.\n\nWe have created a user table that contains all the user details along with and tables to store multiple addresses and payment details of users. This structure offers more granular control over data while eliminating duplicate records.\n\nAnother way to manage users is by creating two separate user tables for end-users and administrators and assigning relationships according to their requirements, as shown below.\n\nManaging products is not simply about maintaining a list of products. You also have to manage the inventory, discounts, categories, and other attributes of the products. So always focus on simplifying the data structure while reducing duplicates. In the following table structure, the main product table contains information about the products.\n\nThere are two other separate tables called , , and that are connected to it through database relationships. This approach provides the greatest level of flexibility to the database.\n\nFor instance, we can simply query the table to check for inventory without going through all the data associated with other related tables. This is also a good place to utilize indexes to increase the performance of the database.\n\nThis is the most critical and complex part when it comes to designing the database. The shopping process will guide a user to search the products, add the desired products to the shopping cart, and finally complete the transaction using a payment provider.\n\nThe heart of the e-commerce process connects users with products. A good chunk of design effort should be exhausted to streamline the shopping process.\n\nIn the example above, there are and as temporary data stores that only store the shopping session information of the current user until the order is confirmed and the data is moved to permanent storage tables with the payment details ( , , and ).\n\nCheck out this article for a detailed explanation of how to design a shopping cart database.\n\nAs shown in this section, the scope of the database structure is determined by the overall functionality of the platform. Therefore, it is paramount that you properly define the required functionality before diving into designing the database. This way, you can create a clearly defined data structure with enough flexibility to support future expansions.\n\n\n\nThe next consideration is to determine the type of database. To have the best e-commerce DB design, you must first consider two main database types: RDBMS or NoSQL databases.\n\nThis is similar to spreadsheets and uses tables, columns, and rows to organize and retrieve data. It is built using the standard query language (SQL) and all the data is related to each other. Examples include MySQL, PostgreSQL, MariaDB, Microsoft SQL, Amazon RDS, and Azure SQL Database.\n\nMany e-commerce sellers use a relational database design centered around the following tables: products table, customers table, and orders table. Additional tables can be added as required to support shipping, categories, product reviews, and more.\n\nWe have covered the database structure in the previous section where the scope of the database was defined. Below, you can see a diagram of a simple e-commerce database design built using MySQL.\n\n\n\nWhile a standard relational database design will work for many e-commerce stores, there are situations where it is advantageous for retailers to follow another approach.\n\nA non-relational database is a nontabular database with a flexible schema that works well for storing unstructured data. Contrary to its name, a non-relational database can store related data. It does so by nesting related data within a single data structure instead of splitting them between tables.\n\nThere are various NoSQL databases, and the most popular ones are document stores and key stores. Examples include MongoDB, Apache Cassandra, Amazon DynamoDB, Azure CosmosDB, and Couchbase.\n\nMost of the world’s largest online retailers, including Walmart and eBay, use NoSQL databases to power their e-commerce systems. This is because NoSQL databases providing the required performance and scalability to effectively manage large catalogs and unstructured data like user data and images.\n\nA good example of an e-commerce database built using NoSQL technology is CouchBase, which uses a document store as its database type. With a document database, data is simpler and easier to access as an entire product can be stored in a single document instead of storing across multiple tables.\n\nBelow, you can see an example of data modeling for different products with CouchBase’s NoSQL database.\n\nBoth of these database types are solid options for any e-commerce platform, and the choice is up to the designer and depends on the requirements of the platform. A relational database will provide a simple and robust platform to create the database while NoSQL offers better data flexibility, scalability, and slightly better performance. However, there is a way to combine the two.\n\nAnother exciting option is to use a combined solution utilizing an RDBMS for structured data such as user details, order details, payment details, and a NoSQL database for unstructured data such as product details or marketing information. This is referred to as a hybrid e-commerce data model.\n\nCreating a hybrid database structure is relatively more complex than using traditional database types (RDBMS or NoSQL) since a hybrid approach will utilize the application to combine data from both sources. This allows the developer to combine the strengths of both database types.\n\nHowever, this kind of approach is only suitable for truly complex application architectures that offer users many different functions. For instance, if your purpose is to speed up an RDBMS, it’s easier to configure a caching server such as Memcached rather than going for a hybrid approach.\n\n\n\nAfter selecting a database type and designing the data structure, we need infrastructure to run the database. The infrastructure type will depend on the deployment of the e-commerce platform.\n\nOne option is to provision a server, install the database software, and manage all the aspects from security to maintenance. The other option is to use a managed database service like Amazon RDS or Azure SQL for RDBMS, or Amazon DynamoDB or Azure CosmosDB for NoSQL.\n\nAmong these two options, the managed approach saves time and does not require any maintenance as these are SaaS offerings.\n\nA managed database will offer peace of mind for any developer as it is backed by a reputed cloud provider with a service level agreement to provide maximum uptime. It will also enable the developer and administrators to focus more on creating and optimizing the database without dealing with server or database maintenance.\n\nA slight downside of a managed platform would be the higher cost associated with it when compared to managing your own servers. However, when considering the total cost of ownership (TCO) and operational expenditure (OpEx), a SaaS solution is the ideal option for scaling an e-commerce database.\n\n\n\nProduct information management (PIM) is a critical component of the core functionality of any good e-commerce platform. It provides a flexible solution for managing all your product data inside a single database in the cloud.\n\nMoreover, PIM is an excellent option for retailers looking to sell on multiple channels. Having a centralized database in the cloud, PIM allows easy management and delivery of product information to any place.\n\nAnother main advantage of PIM is the ability to collect and organize data in a variety of formats. Different platforms have their own catalog structure and PIM software automatically sends data to these channels in the proper format.\n\nfabric PIM is one of the best examples of e-commerce DB design using PIM software. It serves as a single source for centralizing all your data in the cloud, allowing businesses to benefit from increased productivity while ensuring all information is accurate and up to date across various channels."
    },
    {
        "link": "https://bgiri-gcloud.medium.com/designing-the-database-schema-for-a-new-e-commerce-platform-and-considering-factors-like-ec28d4fb81db",
        "document": "Designing the database schema for a new e-commerce platform involves careful consideration of various factors to ensure efficient storage and retrieval of data. Here’s a structured approach\n\nCreate an ER diagram to identify entities and relationships. Common entities include:\n\nNormalize the database to eliminate redundancy and ensure data integrity. Typically, aim for at least Third Normal Form (3NF).\n\nConsider denormalization for read-heavy operations. For example, storing the total amount in the table instead of calculating it from every time.\n• Columns frequently used in WHERE clauses or JOIN conditions\n\nPartitioning: Consider table partitioning for large tables to improve query performance. Materialized Views: Use materialized views for complex queries that do not change frequently. Caching: Implement caching for frequently accessed data to reduce database load.\n\nEnsure transactions are properly managed to maintain data integrity, especially for critical operations like order processing. Use appropriate isolation levels to handle concurrency.\n\nSet up monitoring for database performance and regularly maintain the database (e.g., reindexing, vacuuming).\n\nBy following these steps and considering various optimization techniques, you can design an e-commerce database schema that balances data integrity, efficient storage, and fast retrieval of information for a smooth user experience. Remember, the optimal schema will depend on the specific needs and functionalities of your e-commerce platform."
    },
    {
        "link": "https://medium.com/@usmananwaar_de/designing-the-relational-database-for-ecommerce-website-the-complete-guide-cbf905ee0cf0",
        "document": "Database modeling is something everyone who works with data should know about. As Daniel Moran said, \"You can have data without information, but you cannot have information without data.\" Data is the new oil, and as a valuable resource, it is crucial to know data modeling.\n\nDatabase modeling is the process of defining a database's logical design and physical structure. It decides how the data will be gathered, altered, stored, and retrieved from the database.\n\nData exists in the pre-defined relationships in the Relational Database Management System (RDBMS). An RDB is made up of rows and columns. Each column has a unique attribute, and rows have keys.\n\nRows and columns exist in a pre-defined relationship in an entity. Entities also have a relationship, which is defined by field keys. RDB makes it easier to analyze and visualize data by creating connections between data points based on the query.\n\nToday, we will be concentrating on relational database systems. However, before we move on to the next step, we need to become comfortable with the vernacular of database design so that we don't get confused later.\n\nAn entity is a single person, place, or thing about which data can be stored and needed to keep track of in our database. For example, employees, departments, and projects can be the entities of a company database. Entities are of two main types:\n\nA domain entity can be described in two ways: by its attributes and relationships with other domain entities. For example, the employee entity can have a name, an address, an age, and a salary as attributes. It can also connect to other entities, such as an employee working in the IT department.\n\nA weak entity relies on a domain entity for its continued existence. Unlike a domain entity, a weak entity doesn't have a primary key. For example, the entity called an \"employee passport\" doesn't mean anything without the employee entity.\n\nAttributes are the characteristics or traits of an entity type. emp_id, name, age, address, and salary all are attributes of the employee entity\n\nKeys are used to identifying the rows in an entity uniquely. They are also used to define relationships between entities.\n\nKeys are usually used as indexes to speed up the response to user queries. However, the index is out of context for today's topic, so we'll cover it later in another article.\n\nRDBMS keys are of different types.\n\nIt is a column or a group of columns uniquely identifying every row in the table.\n\na. Two rows can't have the same primary key, which means they can't be duplicated in a row.\n\nb. It can't be null.\n\nc. The value of the primary key can't be modified or updated if any foreign key refers to that primary key.\n\nemp_id is the primary key here.\n\nIt is a primary key, but we don't need to make that up to identify the row uniquely. If \"email\" or \"passport_num\" are used as the primary keys, as they can uniquely identify the rows, they'll be natural keys.\n\nIt is a primary key, but we need to make that up to identify the row uniquely. They don't lend any meaning to the data and are usually an integer. We create a surrogate key when:\n\n a. No attribute fulfills the parameter of the primary key\n\n b. Primary key is too big or complicated\n\nThe surrogate key is emp_id because email_id is complicated, and passport_number is big.\n\nA set of attributes, like the primary key, can be used to identify each row in a table. The primary key is selected from the candidate keys. \"emp_id,\" \"email,\" and \"passport_num\" are candidate keys for the employee entity.\n\nCandidate keys that aren't selected as the primary key are known as alternate keys in the entity. \"email\" or \"passport_num\" can be used as primary keys to identify the rows uniquely; they are alternate keys.\n\nWhen more than one attribute is combined to uniquely identify a row in a table, that attribute is called a composite key. \"dept_id\" and \"emp_id\" uniquely identify the row in the project entity.\n\nAs we discussed earlier, the key defines relationships between entities. One entity's primary key becomes another's foreign key when we need to show the relationship between entities. In addition, it has properties opposite to the primary key. \"emp_id\" is the primary key of the employee entity, acting as a foreign key in the project entity.\n\nDesigning a fast, efficient, and scalable database is no walk in the park. There are a lot of factors to consider before starting the design. However, since we are all familiar with the basics of e-commerce platforms, let’s build a database for one as an exercise.\n\nBefore we create the database, we must know the following:\n• Why is it necessary to maintain a database? What kind of database is going to be needed for the system? Are we building it for applications, business intelligence, data storage, etc.?\n• What are the primary functional requirements of the company? How does the company operate? Understanding the business model will help in designing the database and defining entities.\n• List down entities and their attributes.\n• Build relationships between rows and columns and between entities\n\nSince we’re designing the database for application use, we must structure the database accordingly. For example, when you shop online, you have to give your personal information, put items in a virtual shopping cart, and then pay for them. This clarifies the “data” that the application must gather or store. Let’s make a list of the entities. But what noun exactly qualifies as an entity?\n• Must have a unique name\n• Attribute value must be atomic (not multivalued, not composite)\n• Every row must be unique\n• Order of columns must be irrelevant\n• Order of rows must be irrelevant\n\nBefore we get started, there is one last thing I want to cover: the idea of Cardinality.\n\nCardinality is the degree to which two entities are related, i.e., one-to-many, one-to-one, many-to-many, etc. Business rules determine Cardinality. If business rules do not allow it, use your best judgment.\n\nLet’s discuss the Cardinality between entities. If this image is blurry, you can access the pdf format on Github. Click on view\n\nCustomer — Order: One customer may place several orders, but each order will only be traced back to a single customer, even if that customer places multiple orders. So the degree of Cardinality is one-to-many.\n\nCustomer — Product: One customer can purchase many products, and many customers can buy one product. So the degree is many-to-many.\n\nCustomer—Transaction: One customer may process multiple transactions, but each transaction will only be traced back to a single customer, even if that customer processes various transactions. So the degree of Cardinality is one-to-many.\n\nI hope you can figure out the level of Cardinality between entities based on the layout and predict the degree of Cardinality between entities. Likewise, each entity has its attributes, symbolized by the design's spheres.\n\nLet’s make the transition from a logical design to a physical structure.\n\nThe first step in making a database is to turn the logical design into a physical format.\n\nWe make relations from ER (logical design) by following the mapping strategies.\n\nusername and email address are candidate keys, but due to their complexity, I introduce a surrogate key in the table, i.e., cust_id\n\nAs a practice exercise, try doing the same thing with different entities. I’ll share the complete structure later.\n\nEntity becomes a separate relation with a foreign key taken from a superior entity. In logical design, the transaction is the weak entity as it relies on order for existence.\n\nWhen mapping weak entities, that’s exactly what happened, right? So the customer_id primary key of the customer (one) side becomes a foreign key on order (many) sides.\n\nSimilarly, a transaction entity also has a one-to-many relationship with the customer.\n\nWhen two entities have a many-to-many relationship, it means there’s a hidden entity between them that creates a new relation with the primary keys of the two entities as its primary key.\n\nThere is a many-to-many relationship between the Customer and Product entities. There is a many-to-many relationship between the product and the transaction. In addition, there is a many-to-many relationship between the Order and the Product.\n\nDate is the attribute that can unite Customer, Product, and Transaction identity and serve as the connecting factor between them. In addition, because an order date cannot exist without order, this makes the cust_prod_trans entity weak. So we need to position the order_num as well.\n\nWe can connect the Order and Product entities via order_qty.\n\nIt’s possible to look at it from another angle as well. If you think your approach is more logical, please feel free to comment or pull a request on GitHub, and I will adjust the article accordingly.\n\nWe have already resolved this issue while working on the weak entity's problem. The order entity and the transaction entity both have a one-to-one relationship with one another.\n\nIt isn’t a common occurrence in databases. As we’re designing the customer database, I can’t imagine any examples of this relationship. It may come later in normalization. However, I can undoubtedly demonstrate this example via the seller database.\n\nSuppose a seller sells a cell charger, a cable, and an adapter. A cell charger consists of a data cable and an adapter, right?\n\nComponent_num is nothing but an item_num. The charger is made of two components that can also be sold separately. The associative relationship, which has two primary keys taken from the primary key of the parent entity, is an example of an Urany relationship.\n\ncust_prod_trans entity can be the perfect example.\n\nLet me explain further via a diagram.\n\nAll three entities have many-to-many relationships between them. But via trans_date, the relationships break into one-to-many or one-to-one between them. This is an example of a ternary relationship.\n\nAs promised, you can find the structure on my GitHub profile. Click to view.\n\nWe’ve converted the logical design to a physical database. I hope you’ve understood the strategies now.\n\nGood news! It’s not over yet :P.\n\nWe now need to normalize our database. Let’s start normalizing our data by understanding data normalization.\n\nIt deconstructs relations containing anomalies into more minor, well-structured relations. The objective is to eliminate redundancy, avoid unnecessary data duplication, and prevent anomalies.\n• No multivalued attribute in the table\n• Every Attribute value is atomic and of a single data type.\n\nIn map regular entities, phone numbers violated 1st NF, which automatically gets solved in the multivalued attribute step.\n\nFunctional dependencies are the group of attributes in a relation that depend on each other rather than the field key.\n\nA customer address is an example of functional dependency in customer relation, so we’ll strip the address and write it in a new relation.\n• Transitive Dependencies: A field depends more on another column than the primary key. In the 3rd NF, we remove transitive dependencies.\n• Data redundancy is the existence of data in two separate entities. Repetition of data in more than one entity is 3rd NF violation.\n\nCountry and province are in 3rd NF in the cust_address table, so we created their separate tables and linked them with cust_address.\n\nThis is how the customer record looks after the 3rd NF has been performed.\n\nYou can see the final structure of the physical database in my GitHub repository. Click on view.\n\nI hope you’ve learned how to design the database from RDBMS. I know this gets quite long, but I hope it is worth your time.\n\nThank you for reading, and happy learning."
    },
    {
        "link": "https://integrate.io/blog/complete-guide-to-database-schema-design-guide",
        "document": "Experts predict that the global enterprise data management market will grow at a compound annual growth rate of 12.1% until 2030. Your organization’s database management system (DBMS) stores all the enterprise data you need for software applications, systems, and IT environments, helping you make smarter data-driven business decisions.\n\nHere are the key things to know about database schema design:\n• None Database schema design refers to the strategies and practices for constructing a database schema.\n• None A database schema is a description of how data is structured or organized in a database.\n• None There are six types of database schemas: flat model, hierarchical model, network model, relational model, star schema, and snowflake schema.\n• None The right database schema design helps you make better use of your enterprise data.\n\nNot all databases are equal. The design of a database schema influences how efficiently your database runs and how quickly you can retrieve information. However, designing a database schema is easier said than done. This article offers an overview of how database schema design works, as well as examples and best practices to help you optimize database schema design.\n\nSimply put, a database schema is a formal description of the structure or organization of a particular database (DB). The term database schema is most commonly used for relational databases, which organize information in tables and use the SQL query language. Non-relational (or “NoSQL”) databases come in several different formats and don't have a “schema” in the same way that relational databases do (although they do have an underlying structure).\n\nThere are two fundamental components of any database schema:\n• The physical database schema describes how you physically store data in a storage system and the form of storage used (files, key-value pairs, indices, etc.).\n• The logical database schema describes the logical constraints applied to data and defines fields, tables, relations, views, integrity constraints, etc. These requirements provide useful information for programmers to apply to the physical design of a database. The rules or constraints defined in this logical model determine how data in different tables relate to one another.\n\nThe definition of physical tables in the schema comes from the logical data model. Entities become tables, entity attributes become table fields, etc.\n\nLearn more about the six most common database schema types below:\n• A flat model database schema organizes data in a single, two-dimensional display—think of a Microsoft Excel spreadsheet or a . This schema is best for simple tables and databases without complex relationships between different entities.\n• Database schemas in a hierarchical model have a “tree-like” structure, with child nodes branching out from a root data node. This schema is ideal for storing nested data—for example, family trees or biological taxonomies.\n• The network model, like the hierarchical model, treats data as nodes connected to one other; however, it allows for more complex connections, such as and cycles. This schema can model the movement of goods and materials between locations or the workflows required to accomplish a particular task.\n• As discussed above, this model organizes data in a series of tables, rows, and columns, creating relationships between different entities. The next section and the rest of this guide will focus on the relational model.\n• The star schema is an evolution of the relational model that organizes data into facts and dimensions. Fact data is numerical (for example, the number of sales of a product), while dimensional data is descriptive (for example, a product’s price, color, weight, etc.).\n• is a further abstraction on top of the star schema. It contains a fact table that connects to a dimensional table , expanding the descriptiveness possible within a database. As you might have guessed, the snowflake schema gets its name from the intricate patterns of a snowflake, where smaller structures radiate off of the central arms of the flake.\n\nRelated Reading: 6 Database Schema Designs and How to Use Them\n\nDatabase schema design — sometimes called SQL schema design — refers to the practices and strategies for constructing a database schema. You can think of database schema design as a blueprint for storing massive amounts of information in a database. The schema is an abstract structure or outline representing the logical view of the database as a whole. Defining data types and the relationships between them, database schema design makes data much easier to retrieve, consume, manipulate, and interpret.\n\nDB schema design organizes data into separate entities, determines how to create relationships between organized entities, and influences the applications of constraints on data. Designers create database schemas to give other database users, such as programmers and analysts, a logical understanding of data.\n\nInefficiently organized databases suck up tons of energy and resources and are difficult to maintain and administer. That’s where database schema design comes into play. You’ll struggle to get value from enterprise data without a clean, efficient, consistent database schema. The right schema design removes duplicated and inconsistent data in different locations.\n\nRelational database systems depend on a solid database schema. The goals of good schema design include:\n• None Keeping sensitive and confidential data secure and accessible to those who need it.\n\nDatabase schemas outline the architecture of a database and ensure database fundamentals such as the following:\n\nA DB schema design can exist both as a visual representation and as a set of formulas or use constraints that govern a database. Developers then express these formulas in different data definition languages, depending on the database system you use. The leading database systems define schemas slightly differently. However, MySQL, Oracle Database, and Microsoft SQL Server each support the CREATE SCHEMA statement.\n\nSuppose you want to create a database to hold information for your accounting department. A specific schema for this database might outline the structure of two simple tables:\n\nThis single schema contains valuable information such as:\n• None The title of each table\n• None The fields each table contains\n• None The relationships between tables (for example, linking an employee’s overtime pay to their identity via their ID number)\n\nDevelopers and database administrators can then convert these schema tables into SQL code.\n\nTo make the most of database schema design, it’s important to follow best practices. That ensures developers have a clear reference point for tables and fields in a project. Here are some of those best practices:\n• None Define and use appropriate naming conventions to make your database schema designs more effective. While you may decide on a particular style or adhere to an ISO standard, the most important thing is to be consistent in your name fields.\n• None Try not to use reserved words in table names, column names, fields, etc. that will likely deliver a syntax error.\n• None Don’t use hyphens, quotes, spaces, or special characters. They will either require additional work or not be valid.\n• None Use singular nouns, not plural nouns, for table names (for example, use StudentName instead of StudentNames). A table represents a collection, so there’s no need to make the title plural.\n• None Omit unnecessary verbiage for table names (for example, use Department instead of DepartmentList or TableDepartments)\n• starts with a good database schema design. Use encryption for sensitive data such as personally identifiable information (PII) and passwords. Don’t give administrator roles to each user; instead, request user authentication for database access.\n• None Database schemas are useful long after you've created them and will be viewed by many other people. So good documentation is essential. Document your database schema design with explicit instructions and write comment lines for scripts, triggers, and other commands.\n• None Normalization ensures independent entities and relationships are not grouped in the same table, reducing redundancy and improving integrity. Use normalization as necessary to optimize database performance. Both over-normalization and under-normalization can lead to problems.\n• None Understanding your data and the attributes of each element helps you build out the most effective schema design. A well-designed schema can enable your data to grow exponentially. As you keep expanding your data, analyze each field in relation to the others you are collecting in your schema.\n\nDesigning your database schema is just the first step in good data management. Well-designed schemas ensure that you can efficiently retrieve and analyze your data. However, you need a tool like Integrate.io to actually perform this retrieval and analysis.\n\nIntegrate.io is a powerful, feature-rich no-code data pipeline platform that builds data pipelines from databases and other sources to a centralized target repository in the cloud. With more than 100 pre-built connectors and integrations and a user-friendly drag-and-drop interface, it’s never been easier to integrate enterprise data.\n\nAre you in the market for a cutting-edge data pipeline tool? Give Integrate.io a try. Schedule a demo now!\n\nA database schema is a formal description of the structure or organization of a database. It includes the definition of how data is organized in the database, with relational databases organizing information in tables and using SQL for queries. Non-relational databases, or \"NoSQL\" databases, also have structures but differ from relational databases in their organization.\n\nDatabase schema design is crucial for the efficient organization of databases. It helps in reducing or eliminating data redundancy, preventing data inconsistencies, ensuring data integrity, facilitating rapid data lookup and retrieval, and keeping sensitive data secure. A well-designed schema is vital for making the most of enterprise data and supporting data-driven business decisions.\n\nWhat are the Types of Database Schemas?\n\nThere are six common types of database schemas: flat model, hierarchical model, network model, relational model, star schema, and snowflake schema. Each type has its unique structure and is suited for different kinds of data organization and retrieval needs.\n\nDesigning a database schema involves organizing data into entities, creating relationships between these entities, and applying constraints. The process can be both a visual and a formulaic exercise, using data definition languages appropriate to the database system. Key considerations include ensuring consistent data formatting, unique primary keys for record entries, and the inclusion of essential data.\n\nWhat are Best Practices for Database Schema Design?\n\nBest practices for database schema design include using appropriate naming conventions, ensuring data security, thorough documentation, applying normalization judiciously, and having a deep understanding of the data and its attributes. Following these practices helps in creating a schema that is efficient, secure, and scalable, facilitating easier data management and retrieval."
    }
]