[
    {
        "link": "https://reddit.com/r/gamedev/comments/r6suhm/what_are_good_programming_practices_in_gamedev",
        "document": "I'm making a game in C++ and SFML, and it is getting big with classes.\n\nI've noticed that I have to spend a lot of time thinking how should I design some things because of what I think, lack of experience in the field.\n\nIn this path, I've collected some questions.\n\nIf I want to check a collision between a bullet and an enemy, should I do it in the enemy class? In which I should have every bullet and it probably will become harder to read, or do I do it in the game state class, where I have everything I need, but I have to iterate between every enemy and bullet again to just check the collision and do what I want\n\nIf I want to add a function like a silly getter into a class which is child from an abstract class, and I don't have the variable in the base class, what do I do, should I add that variable in the base class even though I will not use it in any other child than that?\n\nWhat cool way exist to run a chunk of code only once without making aux variables? Like starting an animation that executes based in a clock, but I want to restart the clock only once. I've found a method which works of creating an aux int, which is set at 0, so when it checks 0, the code runs and then it gets added, then it comes back to 0 when I want, but I feel that it's too hardcoded, and I have to spend time making the variables in the class, then in the constructor setting up to 0, etc, etc...\n\nWhat are the ways that normally stuff gets done?"
    },
    {
        "link": "https://reddit.com/r/gamedev/comments/fc4ne8/how_do_i_handle_classes_in_game_development",
        "document": "Hi, i am learning SDL (C++), it is going pretty well but i have a problem. i have no idea how to structure my classes and how not to make a complete fucking mess of my code.\n\ni can make some cool small projects if i just have my main file and then i have for example a player class and a enemy class. and then in the main file just do\n\nand then that for all my objects... so that isn't working.\n\nmy question is how do i handle my classes? do i need to make a entity handler to update and draw all my entities or i have no idea how, how do i structure my classed so that my game looks good and i can easily make changes to functions and classes.\n\nthanks ik advance, im going to sleep now because it is almost 3 am, adios amigos"
    },
    {
        "link": "https://stackoverflow.com/questions/33349992/best-practise-creating-objects-within-class",
        "document": "Definitely the former (ie yes, keep using pointers), just make sure you define a flexible abstract class with all the methods / attributes that your player will need to interact with; you want to avoid resolving the derived type as much as possible (this makes the code messy and a bit slower).\n\nIf you are not familiar with design patterns, I would encourage you to read about Factories and how they can be used to handle allocation in such cases. This will make your code easy to maintain/understand, should someone want to add another weapon to your game later on. You will want to use named tags to clarify your code and select the object to build in your factory; this can be done using s, but I tend to prefer namespaces or structures if you can't use strongly-typed s (c++11), eg:\n\nYou can easily see how such tags could be used in a switch and output a shared pointer to an abstract class (you can even define alias tags if needed).\n\nIf you suspect you might need to resolve derived types often, then consider storing the previous tag as a member of the abstract class, this will make it much easier and cleaner than using for instance.\n\nIf you are concerned about performance (which, at 120 fps I imagine you are), consider using memory pools of objects (weapons, players, etc), although in the context of a game, I would expect the quantity of objects to be (almost) constant by the time the game begins?"
    },
    {
        "link": "https://linkedin.com/pulse/c-quest-mastering-oop-through-game-development-luiz-henrique-bueno-0ykme",
        "document": "Dive into this adventure and unlock the secrets of C++ in a fun and interactive way! Learn to craft game characters, explore inheritance and polymorphism, and master encapsulation and abstraction. Perfect for those ready to level their coding skills with a dash of game development magic!\n\nChapter 2: Constructors and Methods - Giving Life to Our Characters\n\nChapter 6: Virtual Functions, Pure Virtual Functions, and Abstract Classes - The Core of Our Game\n\nImagine virtual functions as an essential game move that can be changed into advanced characters. Pure virtual functions are like moves that every character has to fill in their way. An abstract class is like a basic character design that can't be used directly in the game but can be the basis for other characters.\n\nChapter 7: Abstraction - The Magic Behind the Scenes\n\nAnd there you have it – a complete adventure through the basics of C++ Object-Oriented Programming, all within the context of game development. Each chapter brought a new concept to life, like different game levels. From creating and customizing characters to cleaning up the game world, you've seen how OOP principles are integral to building a game in C++. Keep practicing these concepts, try adding new features, and, most importantly, have fun coding your game world!"
    },
    {
        "link": "https://gamedev.stackexchange.com/questions/155468/planning-class-inheritance-for-game-objects",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://cplusplus.com/reference/random",
        "document": ""
    },
    {
        "link": "https://isocpp.org/files/papers/n3551.pdf",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/19665818/generate-random-numbers-using-c11-random-library",
        "document": "I red all the stuff above, about 40 other pages with c++ in it like this and watched the video from Stephan T. Lavavej \"STL\" and still wasn't sure how random numbers works in praxis so I took a full Sunday to figure out what its all about and how it works and can be used.\n\nIn my opinion STL is right about \"not using srand anymore\" and he explained it well in the video 2. He also recommend to use:\n\na) -- for encrypted generation but slower (from my example)\n\nb) the examples with -- faster, ability to create seeds, not encrypted\n\nI pulled out all claimed c++11 books I have access to and found f.e. that german Authors like Breymann (2015) still use a clone of\n\njust with instead of #includings - so be careful to learn just from one book :).\n\nMeaning - that shouldn't be used since c++11 because:\n\nPrograms often need a source of random numbers. Prior to the new standard, both C and C++ relied on a simple C library function named rand. That function produces pseudorandom integers that are uniformly distributed in the range from 0 to a system- dependent maximum value that is at least 32767. The rand function has several problems: Many, if not most, programs need random numbers in a different range from the one produced by rand. Some applications require random floating-point numbers. Some programs need numbers that reflect a nonuniform distribution. Programmers often introduce nonrandomness when they try to transform the range, type, or distribution of the numbers generated by rand. (quote from Lippmans C++ primer fifth edition 2012)\n\nI finally found a the best explaination out of 20 books in Bjarne Stroustrups newer ones - and he should know his stuff - in \"A tour of C++ 2019\", \"Programming Principles and Practice Using C++ 2016\" and \"The C++ Programming Language 4th edition 2014\" and also some examples in \"Lippmans C++ primer fifth edition 2012\":\n\nAnd it is really simple because a random number generator consists of two parts: (1) an engine that produces a sequence of random or pseudo-random values. (2) a distribution that maps those values into a mathematical distribution in a range.\n\nDespite the opinion of Microsofts STL guy, Bjarne Stroustrups writes:\n\nThe Example is from Bjarne Stroustrups - good idea generating engine and distribution with (more bout that here).\n\nTo be able to make practical use of the random number generators provided by the standard library in here some executable code with different examples reduced to the least necessary that hopefully safe time and money for you guys:\n\nI think that adds it all up and like I said, it took me a bunch of reading and time to destill it to that examples - if you have further stuff about number generation I am happy to hear about that via pm or in the comment section and will add it if necessary or edit this post. Bool"
    },
    {
        "link": "https://cplusplus.com/reference/cstdlib/rand",
        "document": ""
    },
    {
        "link": "https://en.cppreference.com/w/cpp/numeric/random/rand",
        "document": "Returns a pseudo-random integral value from the range ​0​ RAND_MAX .\n\nstd::srand() seeds the pseudo-random number generator used by . If is used before any calls to std::srand(), behaves as if it was seeded with std::srand(1).\n\nEach time is seeded with std::srand(), it must produce the same sequence of values on successive calls.\n\nOther functions in the standard library may call . It is implementation-defined which functions do so.\n\nIt is implementation-defined whether is thread-safe.\n\nPseudo-random integral value between ​0​ and RAND_MAX.\n\nThere are no guarantees as to the quality of the random sequence produced. In the past, some implementations of have had serious shortcomings in the randomness, distribution and period of the sequence produced (in one well-known example, the low-order bit simply alternated between 1 and ​0​ between calls).\n\nis not recommended for serious random-number generation needs. It is recommended to use C++11's random number generation facilities to replace .(since C++11)"
    }
]