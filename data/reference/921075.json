[
    {
        "link": "https://docs.oracle.com/javase/tutorial/java/nutsandbolts/arrays.html",
        "document": "The Java Tutorials have been written for JDK 8. Examples and practices described in this page don't take advantage of improvements introduced in later releases and might use technology no longer available. See Dev.java for updated tutorials taking advantage of the latest releases. See Java Language Changes for a summary of updated language features in Java SE 9 and subsequent releases. See JDK Release Notes for information about new features, enhancements, and removed or deprecated options for all JDK releases.\n\nAn array is a container object that holds a fixed number of values of a single type. The length of an array is established when the array is created. After creation, its length is fixed. You have seen an example of arrays already, in the method of the \"Hello World!\" application. This section discusses arrays in greater detail.\n\nEach item in an array is called an element, and each element is accessed by its numerical index. As shown in the preceding illustration, numbering begins with 0. The 9th element, for example, would therefore be accessed at index 8.\n\nThe following program, , creates an array of integers, puts some values in the array, and prints each value to standard output.\n\nThe output from this program is:\n\nIn a real-world programming situation, you would probably use one of the supported looping constructs to iterate through each element of the array, rather than write each line individually as in the preceding example. However, the example clearly illustrates the array syntax. You will learn about the various looping constructs ( , , and ) in the Control Flow section.\n\nDeclaring a Variable to Refer to an Array\n\nThe preceding program declares an array (named ) with the following line of code:\n\nLike declarations for variables of other types, an array declaration has two components: the array's type and the array's name. An array's type is written as , where is the data type of the contained elements; the brackets are special symbols indicating that this variable holds an array. The size of the array is not part of its type (which is why the brackets are empty). An array's name can be anything you want, provided that it follows the rules and conventions as previously discussed in the naming section. As with variables of other types, the declaration does not actually create an array; it simply tells the compiler that this variable will hold an array of the specified type.\n\nSimilarly, you can declare arrays of other types:\n\nYou can also place the brackets after the array's name:\n\nHowever, convention discourages this form; the brackets identify the array type and should appear with the type designation.\n\nOne way to create an array is with the operator. The next statement in the program allocates an array with enough memory for 10 integer elements and assigns the array to the variable.\n\nIf this statement is missing, then the compiler prints an error like the following, and compilation fails:\n\nThe next few lines assign values to each element of the array:\n\nEach array element is accessed by its numerical index:\n\nAlternatively, you can use the shortcut syntax to create and initialize an array:\n\nHere the length of the array is determined by the number of values provided between braces and separated by commas.\n\nYou can also declare an array of arrays (also known as a multidimensional array) by using two or more sets of brackets, such as . Each element, therefore, must be accessed by a corresponding number of index values.\n\nIn the Java programming language, a multidimensional array is an array whose components are themselves arrays. This is unlike arrays in C or Fortran. A consequence of this is that the rows are allowed to vary in length, as shown in the following program:\n\nThe output from this program is:\n\nFinally, you can use the built-in property to determine the size of any array. The following code prints the array's size to standard output:\n\nThe class has an method that you can use to efficiently copy data from one array into another:\n\nThe two arguments specify the array to copy from and the array to copy to. The three arguments specify the starting position in the source array, the starting position in the destination array, and the number of array elements to copy.\n\nThe following program, , declares an array of elements. It uses the method to copy a subsequence of array components into a second array:\n\nThe output from this program is:\n\nArrays are a powerful and useful concept used in programming. Java SE provides methods to perform some of the most common manipulations related to arrays. For instance, the example uses the method of the class instead of manually iterating through the elements of the source array and placing each one into the destination array. This is performed behind the scenes, enabling the developer to use just one line of code to call the method.\n\nFor your convenience, Java SE provides several methods for performing array manipulations (common tasks, such as copying, sorting and searching arrays) in the class. For instance, the previous example can be modified to use the method of the class, as you can see in the example. The difference is that using the method does not require you to create the destination array before calling the method, because the destination array is returned by the method:\n\nAs you can see, the output from this program is the same, although it requires fewer lines of code. Note that the second parameter of the method is the initial index of the range to be copied, inclusively, while the third parameter is the final index of the range to be copied, exclusively. In this example, the range to be copied does not include the array element at index 9 (which contains the string ).\n\nSome other useful operations provided by methods in the class are:\n• None Searching an array for a specific value to get the index at which it is placed (the method).\n• None Comparing two arrays to determine if they are equal or not (the method).\n• None Filling an array to place a specific value at each index (the method).\n• None Sorting an array into ascending order. This can be done either sequentially, using the method, or concurrently, using the method introduced in Java SE 8. Parallel sorting of large arrays on multiprocessor systems is faster than sequential array sorting.\n• None Creating a stream that uses an array as its source (the method). For example, the following statement prints the contents of the array in the same way as in the previous example: See Aggregate Operations for more information about streams.\n• None Converting an array to a string. The method converts each element of the array to a string, separates them with commas, then surrounds them with brackets. For example, the following statement converts the array to a string and prints it: This statement prints the following:"
    },
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html",
        "document": "\n• Sorts the specified array into ascending numerical order. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted\n• , inclusive, to the index , exclusive. If , the range to be sorted is empty. Sorts the specified range of the array into ascending order. The range to be sorted extends from the index, inclusive, to the index, exclusive. If, the range to be sorted is empty. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted\n• , inclusive, to the index , exclusive. If , the range to be sorted is empty. Sorts the specified range of the array into ascending order. The range to be sorted extends from the index, inclusive, to the index, exclusive. If, the range to be sorted is empty. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted\n• , inclusive, to the index , exclusive. If , the range to be sorted is empty. Sorts the specified range of the array into ascending order. The range to be sorted extends from the index, inclusive, to the index, exclusive. If, the range to be sorted is empty. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted\n• , inclusive, to the index , exclusive. If , the range to be sorted is empty. Sorts the specified range of the array into ascending order. The range to be sorted extends from the index, inclusive, to the index, exclusive. If, the range to be sorted is empty. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted\n• , inclusive, to the index , exclusive. If , the range to be sorted is empty. Sorts the specified range of the array into ascending order. The range to be sorted extends from the index, inclusive, to the index, exclusive. If, the range to be sorted is empty. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. The relation does not provide a total order on all float values: is and a value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method : is treated as less than value and is considered greater than any other value and all values are considered equal. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted\n• , inclusive, to the index , exclusive. If , the range to be sorted is empty. Sorts the specified range of the array into ascending order. The range to be sorted extends from the index, inclusive, to the index, exclusive. If, the range to be sorted is empty. The relation does not provide a total order on all float values: is and a value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method : is treated as less than value and is considered greater than any other value and all values are considered equal. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. The relation does not provide a total order on all double values: is and a value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method : is treated as less than value and is considered greater than any other value and all values are considered equal. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted\n• , inclusive, to the index , exclusive. If , the range to be sorted is empty. Sorts the specified range of the array into ascending order. The range to be sorted extends from the index, inclusive, to the index, exclusive. If, the range to be sorted is empty. The relation does not provide a total order on all double values: is and a value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method : is treated as less than value and is considered greater than any other value and all values are considered equal. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the original array. The is used to execute any parallel tasks. - the array to be sorted\n• Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index , inclusive, to the index , exclusive. If , the range to be sorted is empty. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the specified range of the original array. The is used to execute any parallel tasks. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the original array. The is used to execute any parallel tasks. - the array to be sorted\n• Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index , inclusive, to the index , exclusive. If , the range to be sorted is empty. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the specified range of the original array. The is used to execute any parallel tasks. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the original array. The is used to execute any parallel tasks. - the array to be sorted\n• Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index , inclusive, to the index , exclusive. If , the range to be sorted is empty. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the specified range of the original array. The is used to execute any parallel tasks. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the original array. The is used to execute any parallel tasks. - the array to be sorted\n• Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index , inclusive, to the index , exclusive. If , the range to be sorted is empty. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the specified range of the original array. The is used to execute any parallel tasks. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the original array. The is used to execute any parallel tasks. - the array to be sorted\n• Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index , inclusive, to the index , exclusive. If , the range to be sorted is empty. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the specified range of the original array. The is used to execute any parallel tasks. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. The relation does not provide a total order on all float values: is and a value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method : is treated as less than value and is considered greater than any other value and all values are considered equal. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the original array. The is used to execute any parallel tasks. - the array to be sorted\n• , inclusive, to the index , exclusive. If , the range to be sorted is empty. Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index, inclusive, to the index, exclusive. If, the range to be sorted is empty. The relation does not provide a total order on all float values: is and a value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method : is treated as less than value and is considered greater than any other value and all values are considered equal. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the specified range of the original array. The is used to execute any parallel tasks. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• Sorts the specified array into ascending numerical order. The relation does not provide a total order on all double values: is and a value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method : is treated as less than value and is considered greater than any other value and all values are considered equal. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the original array. The is used to execute any parallel tasks. - the array to be sorted\n• , inclusive, to the index , exclusive. If , the range to be sorted is empty. Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index, inclusive, to the index, exclusive. If, the range to be sorted is empty. The relation does not provide a total order on all double values: is and a value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method : is treated as less than value and is considered greater than any other value and all values are considered equal. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the specified range of the original array. The is used to execute any parallel tasks. - the array to be sorted - the index of the first element, inclusive, to be sorted - the index of the last element, exclusive, to be sorted\n• mutually comparable (that is, must not throw a for any elements and in the array). Sorts the specified array of objects into ascending order, according to the natural ordering of its elements. All elements in the array must implement the interface. Furthermore, all elements in the array must be(that is,must not throw afor any elementsandin the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the original array. The is used to execute any parallel tasks. - the class of the objects to be sorted - the array to be sorted - if the array contains elements that are not mutually comparable (for example, strings and integers) - (optional) if the natural ordering of the array elements is found to violate the contract\n• , inclusive, to index , exclusive. (If , the range to be sorted is empty.) All elements in this range must implement the mutually comparable (that is, must not throw a for any elements and in the array). Sorts the specified range of the specified array of objects into ascending order, according to the natural ordering of its elements. The range to be sorted extends from index, inclusive, to index, exclusive. (If, the range to be sorted is empty.) All elements in this range must implement the interface. Furthermore, all elements in this range must be(that is,must not throw afor any elementsandin the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the specified range of the original array. The is used to execute any parallel tasks. - the class of the objects to be sorted - the array to be sorted - the index of the first element (inclusive) to be sorted - the index of the last element (exclusive) to be sorted - if or (optional) if the natural ordering of the array elements is found to violate the contract - if the array contains elements that are not mutually comparable (for example, strings and integers).\n• mutually comparable by the specified comparator (that is, must not throw a for any elements and in the array). Sorts the specified array of objects according to the order induced by the specified comparator. All elements in the array must beby the specified comparator (that is,must not throw afor any elementsandin the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the original array. The is used to execute any parallel tasks. - the class of the objects to be sorted - the array to be sorted - the comparator to determine the order of the array. A value indicates that the elements' natural ordering should be used. - if the array contains elements that are not mutually comparable using the specified comparator - (optional) if the comparator is found to violate the contract\n• , inclusive, to index , exclusive. (If , the range to be sorted is empty.) All elements in the range must be mutually comparable by the specified comparator (that is, must not throw a for any elements and in the range). Sorts the specified range of the specified array of objects according to the order induced by the specified comparator. The range to be sorted extends from index, inclusive, to index, exclusive. (If, the range to be sorted is empty.) All elements in the range must beby the specified comparator (that is,must not throw afor any elementsandin the range). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. The sorting algorithm is a parallel sort-merge that breaks the array into sub-arrays that are themselves sorted and then merged. When the sub-array length reaches a minimum granularity, the sub-array is sorted using the appropriate method. If the length of the specified array is less than the minimum granularity, then it is sorted using the appropriate method. The algorithm requires a working space no greater than the size of the specified range of the original array. The is used to execute any parallel tasks. - the class of the objects to be sorted - the array to be sorted - the index of the first element (inclusive) to be sorted - the index of the last element (exclusive) to be sorted - the comparator to determine the order of the array. A value indicates that the elements' natural ordering should be used. - if or (optional) if the natural ordering of the array elements is found to violate the contract - if the array contains elements that are not mutually comparable (for example, strings and integers).\n• mutually comparable (that is, must not throw a for any elements and in the array). Sorts the specified array of objects into ascending order, according to the natural ordering of its elements. All elements in the array must implement the interface. Furthermore, all elements in the array must be(that is,must not throw afor any elementsandin the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. Implementation note: This implementation is a stable, adaptive, iterative mergesort that requires far fewer than n lg(n) comparisons when the input array is partially sorted, while offering the performance of a traditional mergesort when the input array is randomly ordered. If the input array is nearly sorted, the implementation requires approximately n comparisons. Temporary storage requirements vary from a small constant for nearly sorted input arrays to n/2 object references for randomly ordered input arrays. The implementation takes equal advantage of ascending and descending order in its input array, and can take advantage of ascending and descending order in different parts of the the same input array. It is well-suited to merging two or more sorted arrays: simply concatenate the arrays and sort the resulting array. The implementation was adapted from Tim Peters's list sort for Python ( TimSort). It uses techniques from Peter McIlroy's \"Optimistic Sorting and Information Theoretic Complexity\", in Proceedings of the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474, January 1993. - the array to be sorted - if the array contains elements that are not mutually comparable (for example, strings and integers) - (optional) if the natural ordering of the array elements is found to violate the contract\n• , inclusive, to index , exclusive. (If , the range to be sorted is empty.) All elements in this range must implement the mutually comparable (that is, must not throw a for any elements and in the array). Sorts the specified range of the specified array of objects into ascending order, according to the natural ordering of its elements. The range to be sorted extends from index, inclusive, to index, exclusive. (If, the range to be sorted is empty.) All elements in this range must implement the interface. Furthermore, all elements in this range must be(that is,must not throw afor any elementsandin the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. Implementation note: This implementation is a stable, adaptive, iterative mergesort that requires far fewer than n lg(n) comparisons when the input array is partially sorted, while offering the performance of a traditional mergesort when the input array is randomly ordered. If the input array is nearly sorted, the implementation requires approximately n comparisons. Temporary storage requirements vary from a small constant for nearly sorted input arrays to n/2 object references for randomly ordered input arrays. The implementation takes equal advantage of ascending and descending order in its input array, and can take advantage of ascending and descending order in different parts of the the same input array. It is well-suited to merging two or more sorted arrays: simply concatenate the arrays and sort the resulting array. The implementation was adapted from Tim Peters's list sort for Python ( TimSort). It uses techniques from Peter McIlroy's \"Optimistic Sorting and Information Theoretic Complexity\", in Proceedings of the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474, January 1993. - the array to be sorted - the index of the first element (inclusive) to be sorted - the index of the last element (exclusive) to be sorted - if or (optional) if the natural ordering of the array elements is found to violate the contract - if the array contains elements that are not mutually comparable (for example, strings and integers).\n• mutually comparable by the specified comparator (that is, must not throw a for any elements and in the array). Sorts the specified array of objects according to the order induced by the specified comparator. All elements in the array must beby the specified comparator (that is,must not throw afor any elementsandin the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. Implementation note: This implementation is a stable, adaptive, iterative mergesort that requires far fewer than n lg(n) comparisons when the input array is partially sorted, while offering the performance of a traditional mergesort when the input array is randomly ordered. If the input array is nearly sorted, the implementation requires approximately n comparisons. Temporary storage requirements vary from a small constant for nearly sorted input arrays to n/2 object references for randomly ordered input arrays. The implementation takes equal advantage of ascending and descending order in its input array, and can take advantage of ascending and descending order in different parts of the the same input array. It is well-suited to merging two or more sorted arrays: simply concatenate the arrays and sort the resulting array. The implementation was adapted from Tim Peters's list sort for Python ( TimSort). It uses techniques from Peter McIlroy's \"Optimistic Sorting and Information Theoretic Complexity\", in Proceedings of the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474, January 1993. - the class of the objects to be sorted - the array to be sorted - the comparator to determine the order of the array. A value indicates that the elements' natural ordering should be used. - if the array contains elements that are not mutually comparable using the specified comparator - (optional) if the comparator is found to violate the contract\n• , inclusive, to index , exclusive. (If , the range to be sorted is empty.) All elements in the range must be mutually comparable by the specified comparator (that is, must not throw a for any elements and in the range). Sorts the specified range of the specified array of objects according to the order induced by the specified comparator. The range to be sorted extends from index, inclusive, to index, exclusive. (If, the range to be sorted is empty.) All elements in the range must beby the specified comparator (that is,must not throw afor any elementsandin the range). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. Implementation note: This implementation is a stable, adaptive, iterative mergesort that requires far fewer than n lg(n) comparisons when the input array is partially sorted, while offering the performance of a traditional mergesort when the input array is randomly ordered. If the input array is nearly sorted, the implementation requires approximately n comparisons. Temporary storage requirements vary from a small constant for nearly sorted input arrays to n/2 object references for randomly ordered input arrays. The implementation takes equal advantage of ascending and descending order in its input array, and can take advantage of ascending and descending order in different parts of the the same input array. It is well-suited to merging two or more sorted arrays: simply concatenate the arrays and sort the resulting array. The implementation was adapted from Tim Peters's list sort for Python ( TimSort). It uses techniques from Peter McIlroy's \"Optimistic Sorting and Information Theoretic Complexity\", in Proceedings of the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474, January 1993. - the class of the objects to be sorted - the array to be sorted - the index of the first element (inclusive) to be sorted - the index of the last element (exclusive) to be sorted - the comparator to determine the order of the array. A value indicates that the elements' natural ordering should be used. - if the array contains elements that are not mutually comparable using the specified comparator. - if or (optional) if the comparator is found to violate the contract\n• Cumulates, in parallel, each element of the given array in place, using the supplied function. For example if the array initially holds and the operation performs addition, then upon return the array holds . Parallel prefix computation is usually more efficient than sequential loops for large arrays. - the class of the objects in the array - the array, which is modified in-place by this method - if the specified array or function is null\n• Performs for the given subrange of the array. - the class of the objects in the array - the index of the first element, inclusive - the index of the last element, exclusive - if the specified array or function is null\n• Cumulates, in parallel, each element of the given array in place, using the supplied function. For example if the array initially holds and the operation performs addition, then upon return the array holds . Parallel prefix computation is usually more efficient than sequential loops for large arrays. - the array, which is modified in-place by this method - if the specified array or function is null\n• Performs for the given subrange of the array. - the index of the first element, inclusive - the index of the last element, exclusive - if the specified array or function is null\n• and the operation performs addition, then upon return the array holds . Parallel prefix computation is usually more efficient than sequential loops for large arrays. Cumulates, in parallel, each element of the given array in place, using the supplied function. For example if the array initially holdsand the operation performs addition, then upon return the array holds. Parallel prefix computation is usually more efficient than sequential loops for large arrays. Because floating-point operations may not be strictly associative, the returned result may not be identical to the value that would be obtained if the operation was performed sequentially. - the array, which is modified in-place by this method - if the specified array or function is null\n• Performs for the given subrange of the array. - the index of the first element, inclusive - the index of the last element, exclusive - if the specified array or function is null\n• Cumulates, in parallel, each element of the given array in place, using the supplied function. For example if the array initially holds and the operation performs addition, then upon return the array holds . Parallel prefix computation is usually more efficient than sequential loops for large arrays. - the array, which is modified in-place by this method - if the specified array or function is null\n• Performs for the given subrange of the array. - the index of the first element, inclusive - the index of the last element, exclusive - if the specified array or function is null\n• Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. - the array to be searched - the value to be searched for index of the search key, if it is contained in the array; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches a range of the specified array of longs for the specified value using the binary search algorithm. The range must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found. - the array to be searched - the index of the first element (inclusive) to be searched - the index of the last element (exclusive) to be searched - the value to be searched for index of the search key, if it is contained in the array within the specified range; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or if all elements in the range are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. - the array to be searched - the value to be searched for index of the search key, if it is contained in the array; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches a range of the specified array of ints for the specified value using the binary search algorithm. The range must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found. - the array to be searched - the index of the first element (inclusive) to be searched - the index of the last element (exclusive) to be searched - the value to be searched for index of the search key, if it is contained in the array within the specified range; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or if all elements in the range are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. - the array to be searched - the value to be searched for index of the search key, if it is contained in the array; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches a range of the specified array of shorts for the specified value using the binary search algorithm. The range must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found. - the array to be searched - the index of the first element (inclusive) to be searched - the index of the last element (exclusive) to be searched - the value to be searched for index of the search key, if it is contained in the array within the specified range; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or if all elements in the range are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. - the array to be searched - the value to be searched for index of the search key, if it is contained in the array; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches a range of the specified array of chars for the specified value using the binary search algorithm. The range must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found. - the array to be searched - the index of the first element (inclusive) to be searched - the index of the last element (exclusive) to be searched - the value to be searched for index of the search key, if it is contained in the array within the specified range; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or if all elements in the range are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. - the array to be searched - the value to be searched for index of the search key, if it is contained in the array; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches a range of the specified array of bytes for the specified value using the binary search algorithm. The range must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found. - the array to be searched - the index of the first element (inclusive) to be searched - the index of the last element (exclusive) to be searched - the value to be searched for index of the search key, if it is contained in the array within the specified range; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or if all elements in the range are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal. - the array to be searched - the value to be searched for index of the search key, if it is contained in the array; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches a range of the specified array of doubles for the specified value using the binary search algorithm. The range must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal. - the array to be searched - the index of the first element (inclusive) to be searched - the index of the last element (exclusive) to be searched - the value to be searched for index of the search key, if it is contained in the array within the specified range; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or if all elements in the range are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal. - the array to be searched - the value to be searched for index of the search key, if it is contained in the array; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• Searches a range of the specified array of floats for the specified value using the binary search algorithm. The range must be sorted (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal. - the array to be searched - the index of the first element (inclusive) to be searched - the index of the last element (exclusive) to be searched - the value to be searched for index of the search key, if it is contained in the array within the specified range; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or if all elements in the range are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.\n• cannot be sorted according to the natural ordering of its elements, hence results are undefined.) If the array contains multiple elements equal to the specified object, there is no guarantee which one will be found. Searches the specified array for the specified object using the binary search algorithm. The array must be sorted into ascending order according to the natural ordering of its elements (as by the method) prior to making this call. If it is not sorted, the results are undefined. (If the array contains elements that are not mutually comparable (for example, strings and integers), itbe sorted according to the natural ordering of its elements, hence results are undefined.) If the array contains multiple elements equal to the specified object, there is no guarantee which one will be found. - the array to be searched - the value to be searched for index of the search key, if it is contained in the array; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found. - if the search key is not comparable to the elements of the array.\n• cannot be sorted according to the natural ordering of its elements, hence results are undefined.) If the range contains multiple elements equal to the specified object, there is no guarantee which one will be found. Searches a range of the specified array for the specified object using the binary search algorithm. The range must be sorted into ascending order according to the natural ordering of its elements (as by the method) prior to making this call. If it is not sorted, the results are undefined. (If the range contains elements that are not mutually comparable (for example, strings and integers), itbe sorted according to the natural ordering of its elements, hence results are undefined.) If the range contains multiple elements equal to the specified object, there is no guarantee which one will be found. - the array to be searched - the index of the first element (inclusive) to be searched - the index of the last element (exclusive) to be searched - the value to be searched for index of the search key, if it is contained in the array within the specified range; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or if all elements in the range are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found. - if the search key is not comparable to the elements of the array within the specified range.\n• Searches the specified array for the specified object using the binary search algorithm. The array must be sorted into ascending order according to the specified comparator (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements equal to the specified object, there is no guarantee which one will be found. - the class of the objects in the array - the array to be searched - the value to be searched for - the comparator by which the array is ordered. A value indicates that the elements' natural ordering should be used. index of the search key, if it is contained in the array; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element greater than the key, or if all elements in the array are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found. - if the array contains elements that are not mutually comparable using the specified comparator, or the search key is not comparable to the elements of the array using this comparator.\n• Searches a range of the specified array for the specified object using the binary search algorithm. The range must be sorted into ascending order according to the specified comparator (as by the method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements equal to the specified object, there is no guarantee which one will be found. - the class of the objects in the array - the array to be searched - the index of the first element (inclusive) to be searched - the index of the last element (exclusive) to be searched - the value to be searched for - the comparator by which the array is ordered. A value indicates that the elements' natural ordering should be used. index of the search key, if it is contained in the array within the specified range; otherwise, . The insertion point is defined as the point at which the key would be inserted into the array: the index of the first element in the range greater than the key, or if all elements in the range are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found. - if the range contains elements that are not mutually comparable using the specified comparator, or the search key is not comparable to the elements in the range using this comparator.\n• if the two specified arrays of longs are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are . Returnsif the two specified arrays of longs areto one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are - one array to be tested for equality - the other array to be tested for equality if the two arrays are equal\n• if the two specified arrays of ints are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are . Returnsif the two specified arrays of ints areto one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are - one array to be tested for equality - the other array to be tested for equality if the two arrays are equal\n• if the two specified arrays of shorts are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are . Returnsif the two specified arrays of shorts areto one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are - one array to be tested for equality - the other array to be tested for equality if the two arrays are equal\n• if the two specified arrays of chars are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are . Returnsif the two specified arrays of chars areto one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are - one array to be tested for equality - the other array to be tested for equality if the two arrays are equal\n• if the two specified arrays of bytes are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are . Returnsif the two specified arrays of bytes areto one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are - one array to be tested for equality - the other array to be tested for equality if the two arrays are equal\n• if the two specified arrays of booleans are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are . Returnsif the two specified arrays of booleans areto one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are - one array to be tested for equality - the other array to be tested for equality if the two arrays are equal\n• if the two specified arrays of doubles are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are . Returnsif the two specified arrays of doubles areto one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are Two doubles and are considered equal if: (Unlike the operator, this method considers equals to itself, and 0.0d unequal to -0.0d.) - one array to be tested for equality - the other array to be tested for equality if the two arrays are equal\n• if the two specified arrays of floats are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are . Returnsif the two specified arrays of floats areto one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are Two floats and are considered equal if: (Unlike the operator, this method considers equals to itself, and 0.0f unequal to -0.0f.) - one array to be tested for equality - the other array to be tested for equality if the two arrays are equal\n• if the two specified arrays of Objects are equal to one another. The two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. Two objects and are considered equal if . In other words, the two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are . Returnsif the two specified arrays of Objects areto one another. The two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. Two objectsandare consideredif. In other words, the two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are - one array to be tested for equality - the other array to be tested for equality if the two arrays are equal\n• Assigns the specified long value to each element of the specified array of longs. - the array to be filled - the value to be stored in all elements of the array\n• Assigns the specified long value to each element of the specified range of the specified array of longs. The range to be filled extends from index , inclusive, to index , exclusive. (If , the range to be filled is empty.) - the array to be filled - the index of the first element (inclusive) to be filled with the specified value - the index of the last element (exclusive) to be filled with the specified value - the value to be stored in all elements of the array\n• Assigns the specified int value to each element of the specified array of ints. - the array to be filled - the value to be stored in all elements of the array\n• Assigns the specified int value to each element of the specified range of the specified array of ints. The range to be filled extends from index , inclusive, to index , exclusive. (If , the range to be filled is empty.) - the array to be filled - the index of the first element (inclusive) to be filled with the specified value - the index of the last element (exclusive) to be filled with the specified value - the value to be stored in all elements of the array\n• Assigns the specified short value to each element of the specified array of shorts. - the array to be filled - the value to be stored in all elements of the array\n• Assigns the specified short value to each element of the specified range of the specified array of shorts. The range to be filled extends from index , inclusive, to index , exclusive. (If , the range to be filled is empty.) - the array to be filled - the index of the first element (inclusive) to be filled with the specified value - the index of the last element (exclusive) to be filled with the specified value - the value to be stored in all elements of the array\n• Assigns the specified char value to each element of the specified array of chars. - the array to be filled - the value to be stored in all elements of the array\n• Assigns the specified char value to each element of the specified range of the specified array of chars. The range to be filled extends from index , inclusive, to index , exclusive. (If , the range to be filled is empty.) - the array to be filled - the index of the first element (inclusive) to be filled with the specified value - the index of the last element (exclusive) to be filled with the specified value - the value to be stored in all elements of the array\n• Assigns the specified byte value to each element of the specified array of bytes. - the array to be filled - the value to be stored in all elements of the array\n• Assigns the specified byte value to each element of the specified range of the specified array of bytes. The range to be filled extends from index , inclusive, to index , exclusive. (If , the range to be filled is empty.) - the array to be filled - the index of the first element (inclusive) to be filled with the specified value - the index of the last element (exclusive) to be filled with the specified value - the value to be stored in all elements of the array\n• Assigns the specified boolean value to each element of the specified array of booleans. - the array to be filled - the value to be stored in all elements of the array\n• Assigns the specified boolean value to each element of the specified range of the specified array of booleans. The range to be filled extends from index , inclusive, to index , exclusive. (If , the range to be filled is empty.) - the array to be filled - the index of the first element (inclusive) to be filled with the specified value - the index of the last element (exclusive) to be filled with the specified value - the value to be stored in all elements of the array\n• Assigns the specified double value to each element of the specified array of doubles. - the array to be filled - the value to be stored in all elements of the array\n• Assigns the specified double value to each element of the specified range of the specified array of doubles. The range to be filled extends from index , inclusive, to index , exclusive. (If , the range to be filled is empty.) - the array to be filled - the index of the first element (inclusive) to be filled with the specified value - the index of the last element (exclusive) to be filled with the specified value - the value to be stored in all elements of the array\n• Assigns the specified float value to each element of the specified array of floats. - the array to be filled - the value to be stored in all elements of the array\n• Assigns the specified float value to each element of the specified range of the specified array of floats. The range to be filled extends from index , inclusive, to index , exclusive. (If , the range to be filled is empty.) - the array to be filled - the index of the first element (inclusive) to be filled with the specified value - the index of the last element (exclusive) to be filled with the specified value - the value to be stored in all elements of the array\n• Assigns the specified Object reference to each element of the specified array of Objects. - the array to be filled - the value to be stored in all elements of the array - if the specified value is not of a runtime type that can be stored in the specified array\n• Assigns the specified Object reference to each element of the specified range of the specified array of Objects. The range to be filled extends from index , inclusive, to index , exclusive. (If , the range to be filled is empty.) - the array to be filled - the index of the first element (inclusive) to be filled with the specified value - the index of the last element (exclusive) to be filled with the specified value - the value to be stored in all elements of the array - if the specified value is not of a runtime type that can be stored in the specified array\n• Copies the specified array, truncating or padding with nulls (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain . Such indices will exist if and only if the specified length is greater than that of the original array. The resulting array is of exactly the same class as the original array. - the class of the objects in the array - the array to be copied - the length of the copy to be returned a copy of the original array, truncated or padded with nulls to obtain the specified length\n• Copies the specified array, truncating or padding with nulls (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain . Such indices will exist if and only if the specified length is greater than that of the original array. The resulting array is of the class . - the class of the objects in the original array - the class of the objects in the returned array - the array to be copied - the length of the copy to be returned - the class of the copy to be returned a copy of the original array, truncated or padded with nulls to obtain the specified length - if an element copied from is not of a runtime type that can be stored in an array of class\n• Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain . Such indices will exist if and only if the specified length is greater than that of the original array. - the array to be copied - the length of the copy to be returned a copy of the original array, truncated or padded with zeros to obtain the specified length\n• Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain . Such indices will exist if and only if the specified length is greater than that of the original array. - the array to be copied - the length of the copy to be returned a copy of the original array, truncated or padded with zeros to obtain the specified length\n• Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain . Such indices will exist if and only if the specified length is greater than that of the original array. - the array to be copied - the length of the copy to be returned a copy of the original array, truncated or padded with zeros to obtain the specified length\n• Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain . Such indices will exist if and only if the specified length is greater than that of the original array. - the array to be copied - the length of the copy to be returned a copy of the original array, truncated or padded with zeros to obtain the specified length\n• Copies the specified array, truncating or padding with null characters (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain . Such indices will exist if and only if the specified length is greater than that of the original array. - the array to be copied - the length of the copy to be returned a copy of the original array, truncated or padded with null characters to obtain the specified length\n• Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain . Such indices will exist if and only if the specified length is greater than that of the original array. - the array to be copied - the length of the copy to be returned a copy of the original array, truncated or padded with zeros to obtain the specified length\n• Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain . Such indices will exist if and only if the specified length is greater than that of the original array. - the array to be copied - the length of the copy to be returned a copy of the original array, truncated or padded with zeros to obtain the specified length\n• Copies the specified array, truncating or padding with (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain . Such indices will exist if and only if the specified length is greater than that of the original array. - the array to be copied - the length of the copy to be returned a copy of the original array, truncated or padded with false elements to obtain the specified length\n• ) must lie between zero and , inclusive. The value at is placed into the initial element of the copy (unless or ). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range ( ), which must be greater than or equal to , may be greater than , in which case is placed in all elements of the copy whose index is greater than or equal to . The length of the returned array will be . Copies the specified range of the specified array into a new array. The initial index of the range () must lie between zero and, inclusive. The value atis placed into the initial element of the copy (unlessor). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (), which must be greater than or equal to, may be greater than, in which caseis placed in all elements of the copy whose index is greater than or equal to. The length of the returned array will be The resulting array is of exactly the same class as the original array. - the class of the objects in the array - the array from which a range is to be copied - the initial index of the range to be copied, inclusive - the final index of the range to be copied, exclusive. (This index may lie outside the array.) a new array containing the specified range from the original array, truncated or padded with nulls to obtain the required length\n• Copies the specified range of the specified array into a new array. The initial index of the range ( ) must lie between zero and , inclusive. The value at is placed into the initial element of the copy (unless or ). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range ( ), which must be greater than or equal to , may be greater than , in which case is placed in all elements of the copy whose index is greater than or equal to . The length of the returned array will be . The resulting array is of the class . - the class of the objects in the original array - the class of the objects in the returned array - the array from which a range is to be copied - the initial index of the range to be copied, inclusive - the final index of the range to be copied, exclusive. (This index may lie outside the array.) - the class of the copy to be returned a new array containing the specified range from the original array, truncated or padded with nulls to obtain the required length - if an element copied from is not of a runtime type that can be stored in an array of class .\n• Copies the specified range of the specified array into a new array. The initial index of the range ( ) must lie between zero and , inclusive. The value at is placed into the initial element of the copy (unless or ). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range ( ), which must be greater than or equal to , may be greater than , in which case is placed in all elements of the copy whose index is greater than or equal to . The length of the returned array will be . - the array from which a range is to be copied - the initial index of the range to be copied, inclusive - the final index of the range to be copied, exclusive. (This index may lie outside the array.) a new array containing the specified range from the original array, truncated or padded with zeros to obtain the required length\n• Copies the specified range of the specified array into a new array. The initial index of the range ( ) must lie between zero and , inclusive. The value at is placed into the initial element of the copy (unless or ). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range ( ), which must be greater than or equal to , may be greater than , in which case is placed in all elements of the copy whose index is greater than or equal to . The length of the returned array will be . - the array from which a range is to be copied - the initial index of the range to be copied, inclusive - the final index of the range to be copied, exclusive. (This index may lie outside the array.) a new array containing the specified range from the original array, truncated or padded with zeros to obtain the required length\n• Copies the specified range of the specified array into a new array. The initial index of the range ( ) must lie between zero and , inclusive. The value at is placed into the initial element of the copy (unless or ). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range ( ), which must be greater than or equal to , may be greater than , in which case is placed in all elements of the copy whose index is greater than or equal to . The length of the returned array will be . - the array from which a range is to be copied - the initial index of the range to be copied, inclusive - the final index of the range to be copied, exclusive. (This index may lie outside the array.) a new array containing the specified range from the original array, truncated or padded with zeros to obtain the required length\n• Copies the specified range of the specified array into a new array. The initial index of the range ( ) must lie between zero and , inclusive. The value at is placed into the initial element of the copy (unless or ). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range ( ), which must be greater than or equal to , may be greater than , in which case is placed in all elements of the copy whose index is greater than or equal to . The length of the returned array will be . - the array from which a range is to be copied - the initial index of the range to be copied, inclusive - the final index of the range to be copied, exclusive. (This index may lie outside the array.) a new array containing the specified range from the original array, truncated or padded with zeros to obtain the required length\n• Copies the specified range of the specified array into a new array. The initial index of the range ( ) must lie between zero and , inclusive. The value at is placed into the initial element of the copy (unless or ). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range ( ), which must be greater than or equal to , may be greater than , in which case is placed in all elements of the copy whose index is greater than or equal to . The length of the returned array will be . - the array from which a range is to be copied - the initial index of the range to be copied, inclusive - the final index of the range to be copied, exclusive. (This index may lie outside the array.) a new array containing the specified range from the original array, truncated or padded with null characters to obtain the required length\n• Copies the specified range of the specified array into a new array. The initial index of the range ( ) must lie between zero and , inclusive. The value at is placed into the initial element of the copy (unless or ). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range ( ), which must be greater than or equal to , may be greater than , in which case is placed in all elements of the copy whose index is greater than or equal to . The length of the returned array will be . - the array from which a range is to be copied - the initial index of the range to be copied, inclusive - the final index of the range to be copied, exclusive. (This index may lie outside the array.) a new array containing the specified range from the original array, truncated or padded with zeros to obtain the required length\n• Copies the specified range of the specified array into a new array. The initial index of the range ( ) must lie between zero and , inclusive. The value at is placed into the initial element of the copy (unless or ). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range ( ), which must be greater than or equal to , may be greater than , in which case is placed in all elements of the copy whose index is greater than or equal to . The length of the returned array will be . - the array from which a range is to be copied - the initial index of the range to be copied, inclusive - the final index of the range to be copied, exclusive. (This index may lie outside the array.) a new array containing the specified range from the original array, truncated or padded with zeros to obtain the required length\n• Copies the specified range of the specified array into a new array. The initial index of the range ( ) must lie between zero and , inclusive. The value at is placed into the initial element of the copy (unless or ). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range ( ), which must be greater than or equal to , may be greater than , in which case is placed in all elements of the copy whose index is greater than or equal to . The length of the returned array will be . - the array from which a range is to be copied - the initial index of the range to be copied, inclusive - the final index of the range to be copied, exclusive. (This index may lie outside the array.) a new array containing the specified range from the original array, truncated or padded with false elements to obtain the required length\n• Returns a fixed-size list backed by the specified array. (Changes to the returned list \"write through\" to the array.) This method acts as bridge between array-based and collection-based APIs, in combination with . The returned list is serializable and implements This method also provides a convenient way to create a fixed-size list initialized to contain several elements: - the class of the objects in the array - the array by which the list will be backed a list view of the specified array\n• arrays and such that , it is also the case that . Returns a hash code based on the contents of the specified array. For any twoarraysandsuch that, it is also the case that The value returned by this method is the same value that would be obtained by invoking the method on a containing a sequence of instances representing the elements of in the same order. If is , this method returns 0. - the array whose hash value to compute\n• arrays and such that , it is also the case that . Returns a hash code based on the contents of the specified array. For any two non-nullarraysandsuch that, it is also the case that The value returned by this method is the same value that would be obtained by invoking the method on a containing a sequence of instances representing the elements of in the same order. If is , this method returns 0. - the array whose hash value to compute\n• arrays and such that , it is also the case that . Returns a hash code based on the contents of the specified array. For any twoarraysandsuch that, it is also the case that The value returned by this method is the same value that would be obtained by invoking the method on a containing a sequence of instances representing the elements of in the same order. If is , this method returns 0. - the array whose hash value to compute\n• arrays and such that , it is also the case that . Returns a hash code based on the contents of the specified array. For any twoarraysandsuch that, it is also the case that The value returned by this method is the same value that would be obtained by invoking the method on a containing a sequence of instances representing the elements of in the same order. If is , this method returns 0. - the array whose hash value to compute\n• arrays and such that , it is also the case that . Returns a hash code based on the contents of the specified array. For any twoarraysandsuch that, it is also the case that The value returned by this method is the same value that would be obtained by invoking the method on a containing a sequence of instances representing the elements of in the same order. If is , this method returns 0. - the array whose hash value to compute\n• arrays and such that , it is also the case that . Returns a hash code based on the contents of the specified array. For any twoarraysandsuch that, it is also the case that The value returned by this method is the same value that would be obtained by invoking the method on a containing a sequence of instances representing the elements of in the same order. If is , this method returns 0. - the array whose hash value to compute\n• arrays and such that , it is also the case that . Returns a hash code based on the contents of the specified array. For any twoarraysandsuch that, it is also the case that The value returned by this method is the same value that would be obtained by invoking the method on a containing a sequence of instances representing the elements of in the same order. If is , this method returns 0. - the array whose hash value to compute\n• arrays and such that , it is also the case that . Returns a hash code based on the contents of the specified array. For any twoarraysandsuch that, it is also the case that The value returned by this method is the same value that would be obtained by invoking the method on a containing a sequence of instances representing the elements of in the same order. If is , this method returns 0. - the array whose hash value to compute\n• Returns a hash code based on the contents of the specified array. If the array contains other arrays as elements, the hash code is based on their identities rather than their contents. It is therefore acceptable to invoke this method on an array that contains itself as an element, either directly or indirectly through one or more levels of arrays. For any two arrays and such that , it is also the case that . The value returned by this method is equal to the value that would be returned by , unless is , in which case is returned. - the array whose content-based hash code to compute\n• Returns a hash code based on the \"deep contents\" of the specified array. If the array contains other arrays as elements, the hash code is based on their contents and so on, ad infinitum. It is therefore unacceptable to invoke this method on an array that contains itself as an element, either directly or indirectly through one or more levels of arrays. The behavior of such an invocation is undefined. For any two arrays and such that , it is also the case that . The computation of the value returned by this method is similar to that of the value returned by on a list containing the same elements as in the same order, with one difference: If an element of is itself an array, its hash code is computed not by calling , but as by calling the appropriate overloading of if is an array of a primitive type, or as by calling recursively if is an array of a reference type. If is , this method returns 0. - the array whose deep-content-based hash code to compute\n• if the two specified arrays are deeply equal to one another. Unlike the Returnsif the two specified arrays areto one another. Unlike the method, this method is appropriate for use with nested arrays of arbitrary depth. Two array references are considered deeply equal if both are , or if they refer to arrays that contain the same number of elements and all corresponding pairs of elements in the two arrays are deeply equal. Two possibly elements and are deeply equal if any of the following conditions hold:\n• and are both arrays of object reference types, and\n• and are arrays of the same primitive type, and the appropriate overloading of would return true. Note that this definition permits elements at any depth. Note that this definition permitselements at any depth. If either of the specified arrays contain themselves as elements either directly or indirectly through one or more levels of arrays, the behavior of this method is undefined. - one array to be tested for equality - the other array to be tested for equality if the two arrays are equal\n• Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ( ). Adjacent elements are separated by the characters (a comma followed by a space). Elements are converted to strings as by . Returns if is . - the array whose string representation to return\n• Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ( ). Adjacent elements are separated by the characters (a comma followed by a space). Elements are converted to strings as by . Returns if is . - the array whose string representation to return\n• Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ( ). Adjacent elements are separated by the characters (a comma followed by a space). Elements are converted to strings as by . Returns if is . - the array whose string representation to return\n• Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ( ). Adjacent elements are separated by the characters (a comma followed by a space). Elements are converted to strings as by . Returns if is . - the array whose string representation to return\n• Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ( ). Adjacent elements are separated by the characters (a comma followed by a space). Elements are converted to strings as by . Returns if is . - the array whose string representation to return\n• Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ( ). Adjacent elements are separated by the characters (a comma followed by a space). Elements are converted to strings as by . Returns if is . - the array whose string representation to return\n• Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ( ). Adjacent elements are separated by the characters (a comma followed by a space). Elements are converted to strings as by . Returns if is . - the array whose string representation to return\n• Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ( ). Adjacent elements are separated by the characters (a comma followed by a space). Elements are converted to strings as by . Returns if is . - the array whose string representation to return\n• , which describes their identities rather than their contents. Returns a string representation of the contents of the specified array. If the array contains other arrays as elements, they are converted to strings by the method inherited from, which describes theirrather than their contents. The value returned by this method is equal to the value that would be returned by , unless is , in which case is returned. - the array whose string representation to return\n• Returns a string representation of the \"deep contents\" of the specified array. If the array contains other arrays as elements, the string representation contains their contents and so on. This method is designed for converting multidimensional arrays to strings. The string representation consists of a list of the array's elements, enclosed in square brackets ( ). Adjacent elements are separated by the characters (a comma followed by a space). Elements are converted to strings as by , unless they are themselves arrays. If an element is an array of a primitive type, it is converted to a string as by invoking the appropriate overloading of . If an element is an array of a reference type, it is converted to a string as by invoking this method recursively. To avoid infinite recursion, if the specified array contains itself as an element, or contains an indirect reference to itself through one or more levels of arrays, the self-reference is converted to the string . For example, an array containing only a reference to itself would be rendered as . This method returns if the specified array is . - the array whose string representation to return\n• Set all elements of the specified array, using the provided generator function to compute each element. If the generator function throws an exception, it is relayed to the caller and the array is left in an indeterminate state. - type of elements of the array - a function accepting an index and producing the desired value for that position - if the generator is null\n• Set all elements of the specified array, in parallel, using the provided generator function to compute each element. If the generator function throws an exception, an unchecked exception is thrown from and the array is left in an indeterminate state. - type of elements of the array - a function accepting an index and producing the desired value for that position - if the generator is null\n• Set all elements of the specified array, using the provided generator function to compute each element. If the generator function throws an exception, it is relayed to the caller and the array is left in an indeterminate state. - a function accepting an index and producing the desired value for that position - if the generator is null\n• Set all elements of the specified array, in parallel, using the provided generator function to compute each element. If the generator function throws an exception, an unchecked exception is thrown from and the array is left in an indeterminate state. - a function accepting an index and producing the desired value for that position - if the generator is null\n• Set all elements of the specified array, using the provided generator function to compute each element. If the generator function throws an exception, it is relayed to the caller and the array is left in an indeterminate state. - a function accepting an index and producing the desired value for that position - if the generator is null\n• Set all elements of the specified array, in parallel, using the provided generator function to compute each element. If the generator function throws an exception, an unchecked exception is thrown from and the array is left in an indeterminate state. - a function accepting an index and producing the desired value for that position - if the generator is null\n• Set all elements of the specified array, using the provided generator function to compute each element. If the generator function throws an exception, it is relayed to the caller and the array is left in an indeterminate state. - a function accepting an index and producing the desired value for that position - if the generator is null\n• Set all elements of the specified array, in parallel, using the provided generator function to compute each element. If the generator function throws an exception, an unchecked exception is thrown from and the array is left in an indeterminate state. - a function accepting an index and producing the desired value for that position - if the generator is null\n• Returns a covering all of the specified array. - the array, assumed to be unmodified during use\n• Returns a covering the specified range of the specified array. - the array, assumed to be unmodified during use - the first index to cover, inclusive - index immediately past the last index to cover - if is negative, is less than , or is greater than the array size\n• Returns a covering all of the specified array. - the array, assumed to be unmodified during use\n• Returns a covering the specified range of the specified array. - the array, assumed to be unmodified during use - the first index to cover, inclusive - index immediately past the last index to cover - if is negative, is less than , or is greater than the array size\n• Returns a covering all of the specified array. - the array, assumed to be unmodified during use the spliterator for the array elements\n• Returns a covering the specified range of the specified array. - the array, assumed to be unmodified during use - the first index to cover, inclusive - index immediately past the last index to cover - if is negative, is less than , or is greater than the array size\n• Returns a covering all of the specified array. - the array, assumed to be unmodified during use\n• Returns a covering the specified range of the specified array. - the array, assumed to be unmodified during use - the first index to cover, inclusive - index immediately past the last index to cover - if is negative, is less than , or is greater than the array size\n• Returns a sequential with the specified array as its source. - The type of the array elements - The array, assumed to be unmodified during use\n• Returns a sequential with the specified range of the specified array as its source. - the type of the array elements - the array, assumed to be unmodified during use - the first index to cover, inclusive - index immediately past the last index to cover - if is negative, is less than , or is greater than the array size\n• Returns a sequential with the specified array as its source. - the array, assumed to be unmodified during use an for the array\n• Returns a sequential with the specified range of the specified array as its source. - the array, assumed to be unmodified during use - the first index to cover, inclusive - index immediately past the last index to cover an for the array range - if is negative, is less than , or is greater than the array size\n• Returns a sequential with the specified array as its source. - the array, assumed to be unmodified during use\n• Returns a sequential with the specified range of the specified array as its source. - the array, assumed to be unmodified during use - the first index to cover, inclusive - index immediately past the last index to cover - if is negative, is less than , or is greater than the array size\n• Returns a sequential with the specified array as its source. - the array, assumed to be unmodified during use\n• Returns a sequential with the specified range of the specified array as its source. - the array, assumed to be unmodified during use - the first index to cover, inclusive - index immediately past the last index to cover - if is negative, is less than , or is greater than the array size"
    },
    {
        "link": "https://stackoverflow.com/questions/19131336/default-values-and-initialization-in-java",
        "document": "I wrote following function to return a default representation 0 or false of a primitive or Number:\n\nI use it in hibernate ORM projection queries when the underlying SQL query returns null instead of 0.\n\nOne of the many unnecessary complex things about Java making it unintuitive to use. Why instance variables are initialized with default 0 but local are not is not logical. Similar why enums dont have built in flag support and many more options. Java lambda is a nightmare compared to C# and not allowing class extension methods is also a big problem.\n\nJava ecosystem comes up with excuses why its not possible but me as the user / developer i dont care about their excuses. I want easy approach and if they dont fix those things they will loose big in the future since C# and other languages are not waiting to make life of developers more simple. Its just sad to see the decline in the last 10 years since i work daily with Java."
    },
    {
        "link": "https://geeksforgeeks.org/how-to-initialize-an-array-in-java",
        "document": "An array in Java is a data structure used to store multiple values of the same data type. Each element in an array has a unique index value. It makes it easy to access individual elements. In an array, we have to declare its size first because the size of the array is fixed. In an array, we can store elements of different data types like integer, string, date, etc. In this article, we will discuss different ways to declare and initialize an array in Java.\n\nIn Java, an array is declared by specifying its data type, and identifier, and adding brackets to indicate it is an array.\n• None : The type of elements the array will hold (e.g.,\n• None : The name of an array.\n\nHere, size of the array is not mentioned because a reference of an array is created in the memory. It can be also known as a memory address of an array.\n\nAfter declaring an array we have to initialize it with values as we have to do it with other variables. In an array, we have to assign multiple values, so the initializing process is not as simple as variables. We will cover the different ways to initialize arrays below.\n\n1. Initialize an Array with a Fixed Size and Default Values\n\nIn Java, an array can be initialized by default values when the size of the array is declared with rectangular brackets [ ].\n\nWe can specify the size of an array at the time of initialization. When we created this way, each element gets a default value (0 for integers, for boolean, and for objects).\n\nWhen we know the values and we want to store it, we can initialize the array with specific values directly.\n\nAn array can also be initialized by using curly braces where we don’t have to declare the size of the array. All the non-default values are initialized in the curly braces which are separated by a comma.\n\nIn the above example, a string-type array is initialized with non-default values using curly braces.\n\nIn Java, we can also initialize an array with particular values. For that, we need to initialize each value one by one. But this method is only useful for small sizes of arrays not for arrays having large sizes. For large-size arrays, we have to use a loop to initialize non-default values.\n\nIn the above example, an integer type array of size 4 is declared and then 4 non-default values are initialized in it.\n\nWe can also use loops to initialize array elements with specific values. This method is specially useful for larger arrays.\n\nIf the size of the array is unknown but we want to fill it dynamically, we can initialize it first with a fixed size and add values later or use a data structure like . Some common operations are mentioned below:\n\nWe can access and manipulate array elements by referring to their index.\n\nWe can use the property to return the number of elements in an array.\n\nAn array can be initialized by using a stream interface. The interface in Java offers additional ways to initialize arrays with sequential or predefined values. Below are three instream interfaces that are used to initialize an integer type array.\n\nIt is used to initialize an array of integers within a given range.\n• None The first parameter is the starting element.\n• None And the second parameter defines the upper limit (exclusive).\n• None It means the array will include elements greater than or equal to the first parameter but less than the second one.\n\nIt creates an array within a range (inclusive of the end).\n\nIt directly initializes an array with specified values.\n\nBelow is a simple program demonstrating different ways of initializing an array."
    },
    {
        "link": "https://studyeasy.org/course-articles/java-en-en/s08l03-initialization-of-array-in-java-continues",
        "document": "\n• Understanding Arrays in Java – Page 2\n• What is an Array?\n• Initializing Arrays – Page 5\n• Using the new Keyword\n\nWelcome to this comprehensive guide on initializing arrays in Java. Arrays are fundamental data structures that allow developers to store and manage collections of data efficiently. Understanding how to properly initialize and manipulate arrays is crucial for both beginners and seasoned developers alike.\n\nIn this eBook, we will explore the intricacies of array initialization, delve into working with different primitive data types, and discuss best practices to avoid common pitfalls. By the end of this guide, you’ll have a solid understanding of how to effectively use arrays in your Java applications.\n\nWhat is an Array?\n\nAn array is a container that holds a fixed number of values of a single type. In Java, arrays are objects that store multiple variables of the same type in a contiguous memory location. Each element in the array can be accessed by its index, which starts from zero.\n\nJava supports several types of arrays based on the data they hold:\n• Multi-Dimensional Arrays: Arrays of arrays, such as 2D or 3D arrays.\n• Jagged Arrays: Arrays where each sub-array can have different lengths.\n\nInitialization is the process of assigning initial values to array elements. In Java, there are multiple ways to initialize arrays, each suited for different scenarios.\n\nUsing the new Keyword\n\nThe new keyword is commonly used to allocate memory for an array. Here’s how you can initialize an array using the new keyword:\n\nIn this example, an integer array named values is created with a length of 10. All elements are initialized to their default value.\n\nWhen an array is initialized without specifying values, Java assigns default values based on the data type:\n\nUnderstanding how arrays interact with various primitive data types is essential for effective programming in Java.\n\nCreating and initializing integer arrays is straightforward. Here’s an example:\n\nIn this example, the array intValues is initialized with a length of 5. Accessing intValues[1] returns the default value 0.\n\nWhen working with floating-point numbers, it’s important to understand how Java handles literals and typecasting.\n\nTypecasting plays a vital role when assigning values to arrays, especially when dealing with different data types.\n\nJava automatically converts smaller data types to larger ones. For example, assigning an int to a double does not require explicit casting:\n\nIn this case, the integer 60 is implicitly typecasted to 60.0d.\n\nWhen dealing with float arrays, floating-point literals must be explicitly marked with an F to indicate that they are floats, not doubles:\n\nWithout the F suffix, the compiler will throw an error since 10.0 and 25.0 are treated as doubles by default.\n\nWhen assigning values with more decimal places than the data type can handle, Java truncates the excess digits:\n\nHowever, due to precision limitations, some decimal digits may be lost:\n• Specify Array Size Carefully: Allocate sufficient memory based on expected data but avoid excessive sizes to optimize memory usage.\n• Use Meaningful Variable Names: Enhance code readability by using descriptive names for arrays.\n• Initialize with Values When Possible: Assign values during initialization to prevent unintended default values.\n• Validate Array Indices: Always ensure that indices used to access array elements are within bounds to avoid ArrayIndexOutOfBoundsException.\n• Forgetting to Specify the Data Type: Ensure that the array type matches the data being stored.\n• Incorrect Typecasting: Mismanaging typecasting can lead to data loss or compilation errors.\n• Assuming Default Values: Relying solely on default values without initializing can cause logical errors in applications.\n• Overlooking Precision Limits: Be mindful of the precision limits of float and double to avoid unexpected results.\n\nInitializing arrays in Java is a fundamental skill that underpins many programming tasks. By understanding the different methods of array initialization, the behavior of various data types, and the nuances of typecasting, you can write more efficient and error-free code.\n\nRemember to follow best practices such as meaningful naming conventions, careful allocation of array sizes, and thorough validation of array indices. Avoid common pitfalls by being aware of default values and the precision limitations of floating-point numbers.\n\nArrays are powerful tools in Java, and mastering their initialization and manipulation will significantly enhance your programming capabilities.\n\nSEO Optimized Keywords: Java arrays, array initialization, Java programming, primitive data types, typecasting in Java, float vs double, Java best practices, array default values, Java for beginners, programming tutorials"
    },
    {
        "link": "https://geeksforgeeks.org/array-index-out-of-bounds-exception-in-java",
        "document": "In Java, ArrayIndexOutOfBoundsException is a Runtime Exception thrown only at runtime. The Java Compiler does not check for this error during the compilation of a program. It occurs when we try to access the element out of the index we are allowed to, i.e. index >= size of the array.\n\nJava supports the creation and manipulation of arrays as a data structure. The index of an array is an integer value that has a value in the interval [0, n-1], where n is the size of the array. If a request for a negative or an index greater than or equal to the size of the array is made, then Java throws an ArrayIndexOutOfBounds Exception. This is unlike C/C++, where no index of the bound check is done.\n\nExample 1: Here, we are trying to access the index which is greater than or equal to the array length.\n\nHere if you carefully see, the array is of size 5. Therefore while accessing its element using for loop, the maximum index value can be 4, but in our program, it is going till 5 and thus the exception.\n\nExample 2: Here, we are trying to access the index of array which is negative.\n\nTo handle ArrayIndexOutOfBoundsException, make sure that index of array is within the valid range. You can also use the enhanced for-loop to automatically handle this exception.\n\nExample 1: Here, we are checking whether the index is valid or not by taking array length with in the index range i.e. [0, n-1]\n\nExample 2: Here, we are using enhanced for loop that automatically handles the accessing of array’s index\n\nExample 3: Consider enclosing your code inside a try-catch statement and manipulate the exception accordingly. As mentioned, Java won’t let you access an invalid index and will definitely throw an ArrayIndexOutOfBoundsException. However, we should be careful inside the block of the catch statement because if we don’t handle the exception appropriately, we may conceal it and thus, create a bug in your application.\n\nHere in the above example, you can see that till index 4 (value 5), the loop printed all the values, but as soon as we tried to access the a[5], the program threw an exception which is caught by the catch block, and it printed the “Exception Caught” statement."
    },
    {
        "link": "https://fusion-reactor.com/blog/how-to-fix-an-array-index-out-of-bounds-exception-in-java",
        "document": "How to fix an Array Index Out Of Bounds Exception in Java\n\nIn this article, we will look at An Array Index Out Of Bounds Exception in Java, which is the common exception you might come across in a stack trace. An array Index Out Of Bounds Exception is thrown when a program attempts to access an element at an index that is outside the bounds of the array. This typically occurs when a program tries to access an element at an index that is less than 0 or greater than or equal to the length of the array.\n\nWhat causes an ArrayIndexOutOfBoundsException\n\nThis can happen if the index is negative or greater than or equal to the size of the array. It indicates that the program is trying to access an element at an index that does not exist. This can be caused by a bug in the code, such as a off-by-one error, or by user input that is not properly validated.\n\nHere is an example in Java\n\nIn this example, the array numbers has a length of 5, but the program is trying to access the element at index 5, which does not exist. The try block contains the code that may throw the exception and the catch block contains the code that will handle the exception if it is thrown. In this case, it will print the message “Error: Index is out of bounds.”\n\nIn this example, the variable index is assigned -1 and when we use it to access the element of the array, it will throw an exception because the index is negative and not valid.\n\nIt’s important to note that, this kind of exception can also be thrown when working with other Java collection classes like ArrayList, Vector, etc.\n\nHow to fix an ArrayIndexOutOfBoundsException\n\nThere are several ways to fix an ArrayIndexOutOfBoundsException:\n• Validate user input: If the exception is caused by user input, make sure to validate the input to ensure that it is within the valid range of indices for the array. For example, in the second example I provided above, you can check if the index is greater than or equal to 0 and less than the size of the array before trying to access the element.\n• Use a for loop with the size of the array: Instead of using a traditional for loop with a fixed number of iterations, you can use a for loop that iterates over the array based on its size. This way, the loop will not try to access an element that does not exist.\n• 3: Use a try-catch block: If you are unable to validate the input or change the loop, you can use a try-catch block to catch the exception and handle it in your code. For example, you can display an error message, or set a default value for the variable.try {\n\nIt’s also important to note that you should always check if the array is null before trying to access its elements. If you reference an array element that is out of bounds, it can cause a NullPointerException. Additionally, it’s good practice to always validate the user input and the index of the array before trying to access the elements to avoid this kind of exception."
    },
    {
        "link": "https://stackoverflow.com/questions/5554734/what-causes-a-java-lang-arrayindexoutofboundsexception-and-how-do-i-prevent-it",
        "document": "Here is a code sample that triggers the exception:\n\nWhat does ArrayIndexOutOfBoundsException mean and how do I get rid of it?\n\nYour first port of call should be the documentation which explains it reasonably clearly: Thrown to indicate that an array has been accessed with an illegal index. The index is either negative or greater than or equal to the size of the array. As for how to avoid it... um, don't do that. Be careful with your array indexes. One problem people sometimes run into is thinking that arrays are 1-indexed, e.g. int[] array = new int[5]; // ... populate the array here ... for (int index = 1; index <= array.length; index++) { System.out.println(array[index]); } That will miss out the first element (index 0) and throw an exception when index is 5. The valid indexes here are 0-4 inclusive. The correct, idiomatic statement here would be:\n\nIf you think of a variable as a \"box\" where you can place a value, then an array is a series of boxes placed next to each other, where the number of boxes is a finite and explicit integer. Creating an array like this: creates a row of 5 boxes, each holding an . Each of the boxes has an index, a position in the series of boxes. This index starts at 0 and ends at N-1, where N is the size of the array (the number of boxes). To retrieve one of the values from this series of boxes, you can refer to it through its index, like this: Which will give you the value of the 4th box in the series (since the first box has an index of 0). An is caused by trying to retrieve a \"box\" that does not exist, by passing an index that is higher than the index of the last \"box\", or negative. With my running example, these code snippets would produce such an exception: myArray[5] //tries to retrieve the 6th \"box\" when there is only 5 myArray[-1] //just makes no sense myArray[1337] //way to high In order to prevent , there are some key points to consider: When looping through an array, always make sure that the index you are retrieving is strictly smaller than the length of the array (the number of boxes). For instance: Notice the , never mix a in there.. You might want to be tempted to do something like this: Just don't. Stick to the one above (if you need to use the index) and it will save you a lot of pain. Where possible, use foreach: This way you won't have to think about indexes at all. When looping, whatever you do, NEVER change the value of the loop iterator (here: ). The only place this should change value is to keep the loop going. Changing it otherwise is just risking an exception, and is in most cases not necessary. When retrieving an arbitrary element of the array, always check that it is a valid index against the length of the array: public Integer getArrayElement(final int index) { if (index < 0 || index >= myArray.length) { return null; //although I would much prefer an actual exception being thrown when this happens. } return myArray[index]; }"
    },
    {
        "link": "https://nkamphoa.com/how-to-fix-arrayindexoutofboundsexception-in-java",
        "document": "When dealing with arrays in Java, ArrayIndexOutOfBoundsException is an exception you’ll most probably encounter. In this article, you’ll learn how to fix this exception. You’ll also learn some best practices for avoiding the ArrayIndexOutOfBoundsException.\n\n2. What Java Says about ArrayIndexOutOfBoundsException\n\nAccording to the Javadoc, an ArrayIndexOutOfBoundsException is thrown to indicate that an array has been accessed with an illegal index. The index is either negative or greater than or equal to the size of the array.\n\nLet’s consider the following code which creates an integers array of size 5:\n\nArrays in Java are zero-indexed, meaning that the first element is at index 0 and the last element is at index . Any attempt to access an index out of this range will result in an ArrayIndexOutOfBoundsException.\n\nRunning the above code snippet will print the following to the console:\n\nTo fix the exception, you should make sure that the index is between 0 and 4 (which is 5 – 1).\n\nAlways ensure that the index of the element you are trying to access is within the range [0, yourArray.length – 1].\n\nWhen iterating an array using a loop, make sure that the start and end conditions of your loop are within the range of the array’s indexes.\n\nWhenever possible, prefer using the enhanced for-loop. This way, you don’t have to worry about index boundaries.\n\nIn this brief tutorial, you learned about the ArrayIndexOutOfBoundsException and how to fix it.\n\nYou can find the complete code of this article here in GitHub"
    },
    {
        "link": "https://stackoverflow.com/questions/16467325/how-to-handle-arrayindexoutofboundsexception",
        "document": "I am getting from my . I get this exception, how to handle this exception so that i can avoid any integer which does not match my .\n\nFor instance if my Array Holds four items.\n\nIf my getting either -1 or any value greater than 3, how can i handle them."
    }
]