[
    {
        "link": "https://ww1.microchip.com/downloads/aemDocuments/documents/MCU08/ApplicationNotes/ApplicationNotes/AVR1000b-Getting-Started-Writing-C-Code-for-AVR-DS90003262B.pdf",
        "document": ""
    },
    {
        "link": "https://linkedin.com/pulse/port-manipulation-atmel-avr-mcus-practical-guide-yamil-garcia-00xte",
        "document": "Microcontroller applications often require direct interaction with the physical world through input and output (I/O) operations. This is typically achieved by reading from or writing to the microcontroller’s I/O ports. Atmel AVR microcontrollers, widely recognized for their simplicity and efficiency in embedded systems, provide a flexible interface for port manipulation. This article dives into the nuances of port manipulation in AVR microcontrollers, focusing on the AVR128DA32 model, and covers essential operations like setting pin levels, configuring pin directions, and reading pin inputs.\n\nAt the heart of port manipulation in AVR microcontrollers is the PORT_t structure. This structure encapsulates all the registers necessary for port configuration and operation, including direction control, output settings, and input readings. A detailed look at the PORT_t structure reveals multiple members, each serving a specific function:\n• Direction Registers (DIR, DIRSET, DIRCLR, DIRTGL): These control whether a pin is an input or an output.\n• Output Registers (OUT, OUTSET, OUTCLR, OUTTGL): These control the state of output pins.\n• Input Register (IN): Reflects the current state of input pins.\n• Control Registers (PORTCTRL, PINCONFIG, etc.): Provide advanced configuration options for pins, such as pull-up resistor settings and interrupt configuration.\n\nSetting the direction of a pin (input or output) is another fundamental operation in port manipulation. The direction of a pin determines whether it can sense external signals or drive external loads. The following function configures the direction of a pin:\n\nTo control the state of a pin (high or low), the output registers within the PORT_t structure is utilized. The following function demonstrates how to set a pin to either high or low:\n\nTo facilitate the management of the pull-up resistor feature for each pin on a port, we can write a function that abstracts the operation of enabling or disabling this feature. This function will directly manipulate the PINnCTRL register of the specified pin within the PORT_t structure, using the bit position 3 to control the pull-up resistor setting. Here is how such a function can be implemented, including comprehensive documentation for its usage:\n\nThis function, setPinPullUp, provides an intuitive interface for managing the pull-up resistor settings of AVR microcontroller pins. By accepting a port structure pointer, a pin number, and a boolean indicating whether to enable or disable the pull-up resistor, it offers a flexible tool for embedded system developers to control their hardware's electrical characteristics precisely.\n\nTo modify the Input/Sense Configuration for a specific pin on an AVR microcontroller port, we can create a function that writes to the first three bits ([2:0]) of the PINnCTRL register. This configuration is crucial for setting up how port interrupts are triggered based on the electrical state of the pin, offering various modes such as edge detection, level sensing, or even disabling the pin's input buffer.\n\nThis function, setPinISC, offers a versatile tool for configuring the sensitivity of AVR microcontroller pins to different input conditions, enabling precise control over how and when interrupts are triggered based on pin states. By manipulating the PINnCTRL register for the specified pin, it allows developers to tailor the behavior of their applications to specific needs, enhancing both the responsiveness and efficiency of embedded systems.\n\nDirect port manipulation in AVR microcontrollers provides a powerful and efficient way to control and interact with the external world. By understanding and using the PORT_t structure, developers can write clearer, more efficient C code for their embedded projects. This guide has introduced key concepts and operations necessary for effective port manipulation, including setting pin levels, configuring pin directions, and reading pin inputs. Whether you are developing simple devices or complex systems, these foundational techniques are indispensable in the world of embedded programming with Atmel AVR microcontrollers."
    },
    {
        "link": "https://extremeelectronics.co.in/avr-tutorials/using-adc-of-avr-microcontroller",
        "document": "Most of the physical quantities around us are continuous. By continuous we mean that the quantity can take any value between two extreme. For example the atmospheric temperature can take any value (within certain range). If an electrical quantity is made to vary directly in proportion to this value (temperature etc) then what we have is Analogue signal. Now we have we have brought a physical quantity into electrical domain. The electrical quantity in most case is voltage.To bring this quantity into digital domain we have to convert this into digital form. For this a ADC or analog to digital converter is needed. Most modern MCU including AVRs has an ADC on chip. An ADC converts an input voltage into a number. An ADC has a resolution. A 10 Bit ADC has a range of 0-1023. (2^10=1024) The ADC also has a Reference voltage(ARef). When input voltage is GND the output is 0 and when input voltage is equal to ARef the output is 1023. So the input range is 0-ARef and digital output is 0-1023.\n\nNow you know the basics of ADC let us see how we can use the inbuilt ADC of AVR MCU. The ADC is multiplexed with PORTA that means the ADC channels are shared with PORTA. The ADC can be operated in single conversion and free running more. In single conversion mode the ADC does the conversion and then stop. While in free it is continuously converting. It does a conversion and then start next conversion immediately after that.\n\nThe ADC needs a clock pulse to do its conversion. This clock generated by system clock by dividing it to get smaller frequency. The ADC requires a frequency between 50KHz to 200KHz. At higher frequency the conversion is fast while a lower frequency the conversion is more accurate. As the system frequency can be set to any value by the user (using internal or externals oscillators)( In xBoard™ a 16MHz crystal is used). So the Prescaler is provided to produces acceptable frequency for ADC from any system clock frequency. System clock can be divided by 2,4,16,32,64,128 by setting the Prescaler.\n\nThe ADC in ATmega32 has 8 channels that means you can take samples from eight different terminal. You can connect up to 8 different sensors and get their values separately.\n\nAs you know the registers related to any particular peripheral module(like ADC, Timer, USART etc.) provides the communication link between the CPU and that peripheral. You configure the ADC according to need using these registers and you also get the conversion result also using appropriate registers. The ADC has only four registers.\n• ADC Multiplexer Selection Register – ADMUX : For selecting the reference voltage and the input channel.\n• ADC Control and Status Register A – ADCSRA : As the name says it has the status of ADC and is also use for controlling it.\n• The ADC Data Register – ADCL and ADCH : The final result of conversion is here.\n\nIn this sample we will setup and use the ADC in single conversion mode. We will connect a LDR( light dependent resistor) which is a light sensor to input. The result will be shown in LCD.\n\nWe have to configure the ADC by setting up ADMUX and ADCSRA registers. The ADMUX has following bits.\n\nREFS1 REFS0 selects the reference voltage. See table below –\n\nWe will go for 2nd option, i.e. Our reference voltage will be Vcc(5v). So we set\n• ADEN – Set this to 1 to enable ADC\n• ADSC – We need to set this to one whenever we need adc to do a conversion.\n• ADIF – This is the interrupt bit this is set to 1 by the hardware when conversion is complete. So we can wait till conversion is complete by polling this bit like The loop does nothing while ADIF is set to 0, it exits as soon as ADIF is set to one, i.e. conversion is complete.\n• ADPS2-ADPS0 – These selects the Prescaler for ADC. As I said the ADC frequency must be between 50KHz to 200KHz.\n\nWe need to select division factor so as to get a acceptable frequency from our 16Mhz clock. We select division factor as 128.So ADC clock frequency = 16000000/128 = 125000 = 125KHz (which is in range of 50KHz to 200KHz). So we set ADCSRA as\n• I used the xBoard for testing the application but you can use your own development board. See Home Made AVR Devboard.\n• You can also get a low cost ATmega8 based board and “USB AVR Programmer” for quick start.\n• Please Read the Tutorial “Internal Peripherals of AVR” before using ADC of AVRs.\n\nNow every thing is set up. We now write a routine that will ReadADC.We can call this function from any where from our code and simply need to pass 0-7 as for which channel we need to read.The following is complete code to Read Channel 0 and display its value on LCD.You have to connect a LDR (light dependant resistor) as shown above. After burning the code on chip use a light source to throw some light on LDR, the ADC will show a value between 0-1024 depending on light. For dark the value should be close to 0 while for bright condition the value will become close to 1000."
    },
    {
        "link": "http://exploreembedded.com/wiki/AVR_C_Library",
        "document": "This manual is designed to help embedded programmers and students, rapidly exploit the Avr(Atmega)-Controller for embedded applications. This manual has been targeted at embedded systems programmers and Students who have basic knowledge of Avr(Atmega32/Avr) architecture and C-Language.\n\nThis manual provides the reference to all the library functions which are grouped under respective.c file. The .c files convention is as per the peripherals. The peripherals (lcd, keypad..) are connected to default PORTs which can be connect to required PORTs by changing the #defines .\n\nIt is recommended to go through the below reference documents and datasheets before interfacing any peripherals.\n• The Avr Microcontroller and Embedded Systems by Muhammad Ali Mazidi.\n• Any of the 16x2 lcd datasheet.\n\nSuggestions for additions and improvements in code and documentation are always welcome. Please send your feedback via e-mail to feedback@xplorelabz.com\n\nThe libraries have been tested for Atmega16 on different development boards. We strongly believe that the library works on any Atmega boards. However, Xplore Labz disclaims any kind of hardware failure resulting out of usage of libraries, directly or indirectly. Documentation may be subject to change without prior notice.\n\nThe usage of tools and software demonstrated in the document are for educational purpose only, all rights pertaining to these belong to the respective owners. Users must ensure license terms are adhered to, for any use of the demonstrated software.\n\nGNU GENERAL PUBLIC LICENSE: The library code in this document is licensed under GNU General Public License (GPL) Copyright (C) 2012. Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed. Since the library is licensed free of charge, there is no warranty for the libraries and the entire risk of the quality and performance is with the user.\n\nErrors and omissions should be reported to feedback@xplorelabz.com\n• Description :This function does the ADC conversioin for the Selected Channel and returns the converted 10bit result\n• Pin connection for LCD display in 8-bit mode is as shown below.By default the LCD is connected to PORTB(databus) and PORTD(controlbus).\n• The code can be modified to connect the LCD to any of the PORTs by changing the \"#define\".\n• io.h contains the defnition of all ports and SFRs delay.h contains the in built delay routines(us and ms routines).\n• Description :This function is used to initialize the lcd in 8-bit mode\n• Description :This function clears the LCD and moves the cursor to first Position\n• Description :This function moves the Cursor to First line First Position\n• Description :This function moves the Cursor to Second line First Position\n• Description :This function moves the Cursor to specified position\n• I/P Arguments: char row,char col\n• row -> line number(line1=0, line2=1),For 2line LCD the I/P argument should be either 0 or 1.\n• col -> char number.For 16-char LCD the I/P argument should be betwen 0-15.\n• Description :This function sends a command to LCD in the following steps.\n• step4: Send a High-to-Low pulse on Enable PIN with some delay_us.\n• Description:This function sends a character to be displayed on LCD in the following steps.\n• step4: Send a High-to-Low pulse on Enable PIN with some delay_us.\n• I/P Arguments: ASCII value of the char to be displayed.\n• Description :This function is used to display the ASCII string on the lcd.\n• The string_ptr points to the first char of the string and traverses till the end(NULL CHAR).\n• Each time a char is sent to LCD_DataWrite funtion to display.\n• I/P Arguments: String(Address of the string) to be displayed.\n• Description :This function is used to display a 5-digit integer(0-65535).\n• if the number is 12345 then 12345 is displayed.\n• if the number is 123 then 00123 is displayed.\n• Description :This function scrolls the given message on the first line.\"\"\n• Pointer is incremented to skip a char each time to give the illusion of moving chars.\n• If the chars are less than 16, then the BlankSpaces are displayed.\n• I/P Arguments: char *msg_ptr (msg_ptr -> pointer to the string to be scrolled)\n• I/P Arguments: char hour,char min,char sec(hour,min,sec should be packed BCD format,as read from DS1307)\n• I/P Arguments: char day,char month,char year(day,month,year should be packed BCD format,as read from DS1307)\n• By default the LCD is connected to PORTB.\n• The code can be modified to connect the LCD to any of the PORTs by changing the \"#define databus PORTB\".\n• io.h contains the defnition of all ports and SFRs delay.h contains the in built delay routines(us and ms routines)\n• Description :This function is used to initialize the lcd in 4-bit mode\n• Description :This function sends a command to LCD in the following steps.\n• step1: Send the Higher Nibble of the I/P command to LCD.\n• step4: Send a High-to-Low pulse on Enable PIN with some delay_us.\n• step5: Send the Lower Nibble of the I/P command to LCD.\n• step8: Send a High-to-Low pulse on Enable PIN with some delay_us.\n• Description:This function sends a character to be displayed on LCD in the following steps.\n• step1: Send the higher nibble of the character to LCD.\n• step4: Send a High-to-Low pulse on Enable PIN with some delay_us.\n• step6: Send the lower nibble of the character to LCD.\n• step9: Send a High-to-Low pulse on Enable PIN with some delay_us.\n• I/P Arguments: ASCII value of the char to be displayed.\n• Rows are connected to lower 4-bits of PORTC\n• Cols are connected to higher 4-bits of PORTC\n• Description : This function the rows and colums for keypad scan\n• Description : This function waits till the previous key is released.\n• All the ROW lines are pulled low.\n• Column Lines are read to check the key press.\n• If all the Keys are released then Column lines will remain high(0x0f)\n• Description : This function waits till a new key is pressed.\n• All the ROW lines are pulled low.\n• Column Lines are read to check the key press.\n• If any Key is pressed then corresponding Column Line goes low.\n• Wait for Some time and perform the above operation to ensure the True Key Press before decoding the KEY.\n• Description :This function scans all the rows to decode the key pressed.\n• Each time a ROW line is pulled low to detect the KEY.\n• Column Lines are read to check the key press.\n• If any Key is pressed then corresponding Column Line goes low.\n• Return the ScanCode(Combination of ROW & COL) for decoding the key.\n• Return value : char--> Scancode of the Key Pressed\n• Description:This function waits till a key is pressed and returns its ASCII Value\n• Wait for the new key press.\n• Scan all the rows one at a time for the pressed key.\n• Decode the key pressed depending on ROW-COL combination and returns its ASCII value.\n• Return value : char--> ASCII value of the Key Pressed\n• Description :This function is used to initialize the UART at 9600 baud rate by below configuration.\n• Description :This function is used to receive a char from UART module.\n• It waits till a char is received ie.till RXC is set,\n• RXC will be set once a CHAR is received.\n• Description : This function is used to transmit a char through UART module.\n• It waits till previous char is transmitted ie.till UDRE is set.\n• UDRE will be set once a CHAR is transmitted ie UDR becomes empty.\n• Finally the new Char to be transmitted is loaded into UDR.\n• Description :This function is used to transmit the ASCII string through UART.\n• The string_ptr points to the first char of the string.\n• And it is incremented each time to traverse till the end(NULL CHAR).\n• Each time a char is sent to UART_TxChar() fun to transmit it through UART\n• I/P Arguments: String(Address of the string) to be transmitted.\n• Description :This function is used to receive a ASCII string through UART till the carriage_return/New_line.\n• The string_ptr points to the begining of the string and each time UART_RxChar() function is called to receive a char and copy it into the buffer(STRING) and incrment string_ptr.\n• Once the carriage_return/New_line is encountered the loop is breaked and the String is NULL terminated.\n• I/P Arguments: *string_ptr(Address of the string where the received data needs to be stored)\n• The received char is ECHOED back,if not required then comment UART_TxChar(ch) in the code.\n• BackSlash is not taken care.\n• Description :This function is used to transmit a 5-digit integer(0-65535).\n• if the number is 12345 then 12345 is transmitted.\n• if the number is 123 then 00123 is transmitted.\n• Description :This function is used to initialize the I2c Module.\n• Description :This function is used to generate I2C Start Condition.\n• Start Condition: SDA goes low when SCL is High.\n• Description :This function is used to generate I2C Stop Condition.\n• Stop Condition: SDA goes High when SCL is High.\n• Description :This function is used to send a byte on SDA line using I2C protocol\n• 8bit data is sent bit-by-bit on each clock cycle.\n• MSB(bit) is sent first and LSB(bit) is sent at last.\n• Data is sent when SCL is low.\n• I/P Arguments: unsigned char-->8bit data to be sent.\n• Description :This fun is used to receive a byte on SDA line using I2C protocol.\n• 8bit data is received bit-by-bit each clock and finally packed into Byte.\n• MSB(bit) is received first and LSB(bit) is received at last.\n• Below values are fixed and should not be changed.\n• Description :This function is used to initialize the Ds1307 RTC.\n• Ds1307 ic is enabled by sending the DS1307 id on the I2C bus.\n• After selecting DS1307, write 0x00 into Control register of Ds1307\n• Description :This function is used to set Time(hh,mm,ss) into the Ds1307 RTC.\n• Ds1307 ic is enabled by sending the DS1307 id on the I2C bus.\n• After selecting DS1307, select the RAM address 0x00 to point to sec.\n• Initilze Sec, MIN, Hour one after the other.\n• I/P Arguments: char,char,char-->hh,mm,ss to initilize the time into DS1307.\n• Description :This function is used to set Date(dd,mm,yy) into the Ds1307 RTC.\n• Ds1307 ic is enabled by sending the DS1307 id on the I2C bus.\n• After selecting DS1307, select the RAM address 0x04 to point to day.\n• Initilze Day,Month and Year one after the other.\n• I/P Arguments: char,char,char-->day,month,year to initilize the Date into DS1307.\n• Description :This function is used to get the Time(hh,mm,ss) from Ds1307 RTC.\n• Ds1307 ic is enabled by sending the DS1307 id on the I2C bus.\n• After selecting DS1307, select the RAM address 0x00 to point to sec.\n• Get Sec, MIN, Hour one after the other.\n• I/P Arguments: char *,char *,char *-->pointers to get the hh,mm,ss.\n• Description :This function is used to get the Date(y,m,d) from Ds1307 RTC.\n• Ds1307 ic is enabled by sending the DS1307 id on the I2C bus.\n• After selecting DS1307, select the RAM address 0x00 to point to DAY.\n• Get Day, Month, Year one after the other.\n• I/P Arguments: char *,char *,char *-->pointers to get the y,m,d.\n• The below value should be set depending on the controller by refering the respective data sheet.\n• Description:This function is used to write the data at specified EEPROM_address.\n• Wait till previous write operation is completed(ie wait till EEWE becomes zero).\n• Load the eeprom address into EEAR at which the data has to be stored.\n• Load the data into EEDR which has to be stored in Eeprom.\n• Set the EEMWE(Eeprom Master Write Enable) and within four clock cycles.\n• I/P Arguments: int,char-->eeprom_address at which eeprom_data is to be written.\n• Description: This function is used to read the data from specified EEPROM_address.\n• EEWE will be cleared once EEprom write is completed.\n• Load the eeprom address into EEAR from where the data needs to be read.\n• Wait for some time and collect the read data from EEDR.\n• I/P Arguments: int-->eeprom_address from where eeprom_data is to be read.\n• Description:This function is used to write N-bytes of data at specified EEPROM_address.\n• EEPROM_WriteByte() function is called to write a byte at atime.\n• Source(RAM) and destination(EEPROM) address are incremented after each write.\n• NoOfBytes is Decemented each time a byte is written.\n• Above Operation is carried out till all the bytes are written(NoOfBytes!=0).\n• int,-->eeprom_address from where the N-bytes are to be written.\n• char*-->Pointer to the N-bytes of data to be written.\n• char --> Number of bytes to be written\n• Description: This function is used to Read N-bytes of data from specified EEPROM_address.\n• EEPROM_ReadByte() func is called to read a byte at a time.\n• Source(RAM) and destination(EEPROM) address are incremented each time.\n• NoOfBytes is Decemented after a byte is read.\n• Above Operation is carried out till all the bytes are read(NoOfBytes!=0).\n• int,-->eeprom_address from where the N-bytes is to be read.\n• char*-->Pointer into which the N-bytes of data is to be read.\n• char --> Number of bytes to be Read\n• Description: This function is used to Write a String at specified EEPROM_address.\n• EEPROM_WriteByte() function is called to write a byte at a time.\n• Source(RAM) and destination(EEPOM) address are incremented each time.\n• Above Operation is carried out till Null char is identified.\n• int,-->eeprom_address where the String is to be written.\n• char*-->Pointer to String which has to be written.\n• NOTE: Null char is also written into the eeprom.\n• Description: This function is used to Read a String from specified EEPROM_address.\n• EEPROM_ReadByte() function is called to read a byte at a time.\n• Source(EEPROM) and destination(RAM) address are incremented each time.\n• Above Operation is carried out till Null char is identified.\n• int,-->eeprom_address from where the String is to be read.\n• char*-->Pointer into which the String is to be read.\n• Description: This function is used to erase the entire Eeprom memory.\n• Eeprom is filled with 0xFF to accomplish the Eeprom Erase.\n• EEPROM_WriteByte() function is called to write a byte at a time.\n• Whole memory(0-MaxEepromSize) is traversed and filled with 0xFF."
    },
    {
        "link": "https://backlot.aths.org/Download_PDFS/Resources/1123739/AvrMicrocontrollerAndEmbeddedSystemsUsingAssemblyAndC.pdf",
        "document": ""
    },
    {
        "link": "https://slideshare.net/Ismailkhan77481/avr-atmega8-microcontroller-based-projects-list-atmega32-avrpdf-252931509",
        "document": ""
    },
    {
        "link": "https://makeabilitylab.github.io/physcomp/arduino/potentiometers.html",
        "document": "\n• Making an LED dimmer with a potentiometer\n• Add ammeter to Tinkercad prototype\n• How to measure current with a multimeter\n• Intro to analog input\n• How does the Arduino read analog input?\n• Analog-to-digital converter (ADC)\n• Why does the ADC resolution matter?\n• How does the ADC actually work?\n\nIn this lesson, we’ll refresh our memories about potentiometers, learn a bit about multimeters, and then introduce the concept of analog input and hook-up potentiometers as voltage dividers to Arduino! Similar to the buttons lesson, we are going to use potentiometers on their own before learning how to use them with microcontrollers.\n\nA video demonstration of a trimpot hooked up to analog input A0 on the Arduino. The A0 value is graphed on an OLED display in real-time. The code is available here.\n\nIn our Intro to Electronics lessons, we learned about potentiometers. Recall that a potentiometer (or pot) is a three-terminal resistor with a sliding or rotating contact that can be used to dynamically vary resistance.\n\nVideo. This animation shows how the wiper can be used to vary resistance in a rotary potentiometer. The figure on the right is the formal electrical symbol. Animation by Jon Froehlich. Created in PowerPoint.\n\nPotentiometers are common electronic components found in everything from volume controls to analog joysticks. In our UW courses, we often provide 10kΩ potentiometers in our kits like the 10K panel mount potentiometer and 10K trim potentiometer, shown below.\n\nFigure. Two example potentiometers commonly included in our hardware kits: a 10kΩ panel mount and and a 10kΩ trim potentiometer.\n\nPotentiometers have three legs: the resistance between the outer two legs (Leg 1 and Leg 3) will not vary. For example, if you are using a 10kΩ potentiometer, then the resistance between Legs 1 and 3 will always be 10kΩ regardless of wiper position (Leg 2). If you’re using a 1kΩ resistor, then the resistance between Legs 1 and 3 will be 1kΩ, and so on.\n\nThe power of a potentiometer is in that middle leg (Leg 2) whose resistance varies depending on the potentiometer’s sliding or rotating contact (the wiper) position. It may help to think of a potentiometer as containing two interdependent resistors \\(R_1\\) and \\(R_2\\) that always sum to \\(R_{Total}\\) (where \\(R_{Total}\\) is the potentiometer’s total value like 1kΩ or 10kΩ). As you move the slider contact, \\(R_1\\)’s resistance will increase as \\(R_2\\)’s resistance decreases. See animation below.\n\nUsing two multimeters set to measure resistances across both Legs 1-2 and 2-3, we can examine this behavior directly. Notice how as you move the wiper, the resistance across Legs 1 and 2 (\\(R_{1}\\)) and Legs 2 and 3 (\\(R_{2}\\)) proportionally change but always sum to \\(R_{total}\\). We are using a 10kΩ potentiometer so \\(R_{total}=10kΩ\\)\n\nVideo. Using two multimeters, we can examine how the resistances change between Legs 1-2 and 2-3. Note that the resistance between the outer legs (Legs 1-3) will always sum to potentiometers total value. In this case, we’re using a 10kΩ, so it would sum to 10kΩ. Try it out on Tinkercad here.\n\nThere are two common ways to use a potentiometer:\n• As a variable resistor or rheostat—where you only hook up two legs (the wiper leg and an outer leg)\n• And as a voltage divider where we hook up all three legs with the middle leg connected to the analog input of our microcontrollers.\n\nTo use these two-leg variable resistors with a microcontroller, we will need to add an additional fixed resistor to create a voltage divider. We’ll show you how to do that in our next lesson.\n\nBelow, we are going to focus on using a potentiometer first as a two-legged variable resistor and then as a voltage divider with our Arduino.\n\nLet’s start building with the potentiometer! We’ll need the following materials:\n\nFor our first making activity, we’re going to create a potentiometer-based LED dimmer. We won’t yet be using an Arduino. This will be a pure electrical circuit (no microcontrollers for a bit!).\n\nLet’s build a prototype in Tinkercad Circuits before building a physical prototype. While similar to the activity in Variable Resistors, we add in uses of Tinkercad’s multimeter to check our circuits and also emphasize correct and incorrect hookups. Moreover, doing this activity before the Arduino-based one will help reinforce differences between using a potentiometer simply as a two-legged variable resistor and as a three-legged voltage divider.\n\nStill, if you feel confident in your understanding of potentiometers as two-leg variable resistors, then feel free to skip to the Intro to Analog Input part of this lesson!\n\nFirst, let’s build the potentiometer-based LED dimmer. In Tinkercad, you could make your dimmer with or without a breadboard (both are shown in the figure below). Let’s prototype something we would actually make in real life, so go with the breadboarded version:\n\nYou can access these Tinkercad circuits here (no breadboard) and here (with breadboard).\n\nIMPORTANT NOTE: Recall that it’s important to include that additional resistor because many potentiometers, including those provided in your hardware kits, go all the way down to 0Ω. If you don’t have that “backup” current-limiting resistor, you will blow your LED if the potentiometer dial is set to 0Ω. (Indeed, try it out in Tinkercad and see what happens—kablooey!)\n\nHere’s one possible wiring for a potentiometer-based LED fading circuit:\n\nOnce you’re done, try simulating your circuit. Click the “Start Simulation” button (see animation below):\n\nIn the circuit above, we hooked up legs 2 and 3 of the potentiometer. What happens if you, instead, hook up legs 1 and 3 or 1 and 2? Try it!\n\nTo help us observe the effect of the potentiometer’s wiper position on the total current in our circuit, we can use Tinkercad’s multimeter tool. A multimeter can be used for a variety of circuit measurements, including measuring resistance (ohmeter), current (ammeter), voltage (voltmeter), and testing for short circuits (continuity testing).\n\nHow to measure current with a multimeter\n\nVoltmeter’s measure voltage in parallel. Ammeter’s measure current in series (ammeter comes from Amperage meter). See the wiring diagram below.\n\nImage from this great “Science Buddies” tutorial on using multimeters.\n\nTo help us think about and remember how to measure current, I like to return to our water analogies from our Intro to Electronics lessons: think of the ammeter as if it’s a mechanical water flow meter (aka a turbine) that must be in-line within a pipe to measure water flow. An ammeter must be “in line” to measure current—you must rewire your circuit such that current is forced through your ammeter (just like water flowing through a turbine in a pipe).\n\nBecause there is only one path for the current to flow in this circuit (no branches), we could hook up the ammeter at any in-series location—for example, in between the potentiometer and LED or the resistor and potentiometer. I just selected a position that I found convenient.\n\nNote: when you drag over a multimeter, make sure you click on it and change the mode to ammeter to measure current (select Amperage).\n\nHere’s our circuit with the ammeter running in the simulator. Does the simulation match your expectations?\n\nBecause we have Leg 2 hooked to the positive voltage source and Leg 3 as our “output”, as we move the wiper from left-to-right, there is a smaller amount of resistance and an increase in current. You’ll notice a jump in current when the \\(V_f\\) condition of the LED is met (recall the LED IV curves from our LED lesson.\n\nBefore moving on, play around with the multimeter in Tinkercad. You can add multiple voltmeters and ammeters to your Tinkercad circuits, which is a handy way to learn how voltages and currents are working, verify Ohm’s Law, and double check your mental model of a circuit before expending effort actually building it.\n\nWe also made this circuit in CircuitJS, which offers a far more powerful and feature-rich simulation compared with Tinkercad but is still relatively accessible to novices. We like it because it shows an illustrative animation of current (just like some of the animations from our previous lessons that we’ve manually made).\n\nThere are two differences in this circuit compared to the Tinkercad one above. First, we used a 1kΩ potentiometer rather than a 10kΩ but the general effect is the same. Second, here we have Leg 1 hooked up towards the positive voltage source and Leg 2 as our “output”, so resistance is minimized when the dial is all the way left (it was the opposite for our Tinkercad circuit).\n\nOK, let’s build this thing for real with our hardware parts.\n\nBecause not all of us have access to a 9V battery + snap connector (or alligator clips) to easily interface with our breadboards, we can again use our Arduino for a power source (just like we did in our very first Arduino lesson: LED On).\n\nGiven that the Arduino supplies 5V rather than 9V, we can replace our 470Ω resistor with a smaller resistor like a 220Ω (but you can certainly use a 470Ω or 680Ω if you’d like—remember, this is a backup resistor for when the potentiometer’s wiper resistance goes to 0Ω).\n\nYou can play with this Tinkercad circuit here.\n\nHere’s a workbench video of my trimpot circuit where the potentiometer is simply a two-legged variable resistor and we’re using the Arduino only as a 5V voltage source:\n\nWhew, we did it!\n\nBy now, you should feel pretty confident with using a potentiometer as a variable resistor; however, using potentiometers (or any variable resistor) with a microcontroller requires a different circuit configuration as you’ll see below.\n\nIn our previous lessons, we learned about digital output, then analog output, and finally digital input. Now, it’s time for the last frontier: analog input!\n\nSo, what’s analog input?! The world—in all its beauty and complexity—is analog. It’s not simply and but everything in between. How can we sense and access that complexity?\n\nMore formally, just like analog output enabled us to write out voltages between 0V and 5V, analog input enables us to read voltages between 0V and 5V. How does this work? Via an ADC.\n\nVideo. While digital input is simply HIGH (5V) or LOW (0V), analog can be anywhere in between. Our ability to sense gradations in the voltage signal is based on the resolution of the analog-to-digital converter. In the case of the Arduino Uno and Leonardo, this is 10 bits.\n\nThe Arduino Uno has six analog inputs (), which can be read using . The function reads voltage values between 0 and the Arduino’s operating voltage (5V on the Uno and Leonardo) and converts this into integer values between 0 and 1023.\n\nOften, students get confused between the analog output pins (which use PWM, see Fading an LED) and the analog input pins. They are different.\n\nYou can access the analog input pins using , … . For example, to read analog input on pin 0. The Arduino Uno has six analog input pins: - .\n\nWhile at first glance, it appears that the Arduino Leonardo has just six analog inputs (like its close sibling the Arduino Uno). Once again, the PCB silkscreening throws us off!\n\nIn fact, if you flip over the Leonardo, you’ll discover additional white silkscreening, which reveals six more analog inputs (for a total of 12)\n\nYou can access these by specifying - in your code. For example:\n\nAnother view of the back of the Arduino Leonardo board showing the additional analog input pins.\n\nThe mapping between analog input pins and digital I/O pins are described in the docs):\n\nWhen reading Arduino’s analogRead docs, you’ll see a listing of analog input pins, operating voltage, and maximum ADC resolution on common Arduino boards.\n\n* Though A0-A5 are labeled on the board, A6 through A11 are available on pins 4, 6, 8, 9, 10, and 12—as is the case with the Arduino Leonardo.\n\n** Though these boards support higher resolution analog-to-digital conversions (e.g., 14 bits rather than 10), they are set to 10 bits for compatibility (because lots of code exists with 1023 hard-coded in as the max analog input whereas it would be 16383).\n\nHow does the Arduino read analog input?\n\nRemember how we said that Arduino input pins work like voltmeters? Just as voltmeters measure voltage in parallel—you connect the probes to two nodes in your circuit and the voltmeter measures the voltage difference between them—microcontrollers work similarly.\n\nBut, you might say: microcontrollers only have a single pin per input while voltmeters have two. Why the difference? Well, with voltmeters, you provide two reference points. With microcontrollers, the voltage at an input pin is always compared to (so, that second “probe point” is always ground).\n\nIt’s important that you conceptually understand that microcontrollers work by measuring voltages and not current. In fact, the ATmega328 datasheet says analog input pins have an effective resistance of 100,000,000Ω (100MΩ), which means almost no current goes into an input pin (see Table 29.8).\n\nThis means that we have to configure our variable resistor sensors as voltage dividers to work with microcontrollers.\n\nThe Arduino Uno’s ATmega328 microcontroller contains an analog-to-digital converter (ADC), which converts analog voltage signals to computational bits that can be processed by a computer. On both the Uno and Leonardo, the ADC is 10 bits. So, the ADC converts voltages between 0 and \\(V_{cc}\\) (5V) to a \\(0 - 2^{10}\\) range (0-1023). Thus, the resolution between readings is 5V / 1024 or 0.0049 volts (4.9 mV).\n\nFigure. The Arduino Uno and Leonardo have 10-bit ADC’s, which convert analog voltages between 0 - 5V to an integer range of 0 - 1023. Thus, the ADC resolution is 0.0049mV.\n\nMany newer Arduino boards use more modern 3.3V microcontrollers with higher-resolution ADCs. For example, The Arduino Nano 33 IoT and the ESP32 boards are both 3.3V with 12-bit ADCs.\n\nFigure. The Arduino Nano 33 IoT, Arduino Zero, and the ESP32 all operate at 3.3V with 12-bit ADCs (0 - 4095). Thus, the ADC resolution is 0.81mV.\n\nWhy does the ADC resolution matter?\n\nFor many purposes, it probably doesn’t. But the practical implication is that with a 5V board and a 10-bit ADC (like the Uno and Leonardo), we have a 0.0049V resolution. So, you won’t be able to tell the difference between, for example, 2.0140V and 2.0152V (both which would convert to 411) or 4.9148V and 4.9190V (both which would be read as 1003). Does this matter? It depends on the context—for most things we do, it won’t.\n\nWe discuss quantization in more depth in the Sensors and Signals sections.\n\nIf you want to improve the ADC resolution, you have two choices: (1) up the bitrate, which would require different hardware (you can use an external ADC like this 12-bit ADS1015) or (2) decrease the convertible voltage range (so, applying the same 10-bits across a smaller voltage range).\n\nIt’s possible to do the latter on the Arduino. You can change the reference voltage from \\(V_{cc}\\) (which is 5V on the Uno and Leonardo) to a different value—for example, to 2V (1.0V is the minimum) using analogReference(). The reference voltage is fixed to \\(GND\\).\n\nChanging the reference voltage may be useful if you know your max analog input value is less than \\(V_{cc}\\) because you will increase your ADC precision.\n\nOn the Uno and Leonardo, the options are:\n• DEFAULT: the default analog reference of 5V (on 5V boards) or 3.3V (on 3.3V boards)\n• INTERNAL: a built-in reference equal to 1.1V on the ATmega328\n• EXTERNAL: the voltage applied to the AREF pin (between 1.0V-5V)\n\nHow does the ADC actually work?\n\nBut wait, you might wonder, how does the actual conversion from analog-to-digital work? This question is beyond the scope of our class; however, from our research, we found that the ATmega328 uses a successive approximation ADC, which converts continuous analog signals via a binary search through all possible quantization levels before converging on a digital output for each conversion (Wikipedia).\n\nAccording to the ATmega328 datasheet, “the successive approximation circuity requires an input clock frequency between 50 kHz and 200kHz to get maximum resolution. If a lower resolution than 10 bits is needed, the input clock frequency to the ADC can be higher than 200 kHz to get a higher sample rate.” See this EE StackExchange discussion.\n\nJust like with our button lesson, let’s walk through how one might try to hook up a potentiometer with a microcontroller. As before, we’ll learn about what not to do and why as well as what to do.\n\nLet’s first introduce a simple program to read and print analog input values to Serial. This will provide a convenient way to test our input circuits.\n\nLet’s build an initial circuit in Tinkercad—first, the wrong way. And then we’ll fix it and show how to do it the right way.\n\nTo begin, you might treat the potentiometer similar to how we did with our LED circuits above—as a rheostat where we only use two legs (an outer leg and Leg 2). However, this won’t work. Build and try these configurations yourself. Make sure to add the above code to the “Code” window in Tinkercad and then hit the “Simulation” button.\n\nTo try these incorrect circuits on Tinkercad, go here and here.\n\nBecause, remember, our input pins measure voltage and there is no voltage difference across our potentiometer (because no current is flowing!). Here’s an illustrative video of what’s happening (and not happening) in our circuit:\n\nThis is a circuit simulation of Leg 1 of the potentiometer hooked to 5V and Leg 2 (wiper leg) hooked to A0. The “inside the microcontroller” view is for illustrative purposes. The input pin circuitry does not actually look like this. Simulation made in CircuitJS.\n\nNotice how the analog input voltage \\(V_{A0}\\) to the microcontroller is always 5V? And, indeed, if you play with the Tinkercad circuits above, you’ll note that the Serial console simply prints continuously (which translates to 5V).\n\nSo, what do we do? We hook up all three potentiometer legs to form a voltage divider: Leg 1 to \\(V_{CC}\\) and Leg 2 to \\(A0\\) but we’ll also wire Leg 3 to \\(GND\\). This will create a voltage difference across the potentiometer and cause current to flow from \\(V_{CC}\\) to \\(GND\\) (and a voltage divider network to emerge):\n\nTry this circuit+code out on Tinkercad.\n\nAnd here’s an illustrative video of what’s happening in our circuit:\n\nThis is a circuit simulation of the potentiometer correctly hooked up to a microcontroller with Leg 1 hooked to 5V, Leg 2 (wiper leg) hooked to analog input A0, and Leg 3 to GND. The “inside the microcontroller” view is for illustrative purposes. The input pin circuitry does not actually look like this. Simulation made in CircuitJS.\n\nOnce you get the potentiometer-based analog input working in Tinkercad, build the physical circuit and, to begin, copy the code from above.\n\nFor your prototyping journals, we’d also like you to make a version that reads in the analog input (using ) and appropriately sets the brightness of an LED (using ).\n\nIn the next lesson, we’ll learn how to add a fixed resistor to a two-leg variable resistor like a force-sensitive resistor or photocell to create a voltage divider that can be read by a microcontroller."
    },
    {
        "link": "https://ledlabs.uk/some-explained-schematics",
        "document": "In LEDLabs this circuit allows micros and some lower output logic Ic's to drive a heavier load than there output pins can sink and source, which could be typically 10-20ma,\n\n As these 1 watt leds consume up to 350ma a collector driven load circuit is used, known as the common emitter.\n\n The bc337 transistors can handle up to around 600/800ma of collector current so will be okay for this reason.\n\nWe want to drive a load current of around 150ma, not the maximum of 350ma (as will be to bright) so from the data sheet for the bc337, the hFE or gain of the transistor is around 100 @ 100ma and as low as 60 for 300ma so for base resistor ib=ic/hfe = .150/100= 2ma. As there is a .7v drop across base-emitter, our equation is 5v-.7 = 4.3v\n\n so.. 4.3/.002 = 2150 ohms, we want to ensure the transistor is in full saturation and operating as a switch, and not in its linear region,\n\n We factor in a safety margin of at least half times this value and have chosen a 1k resistor, this will ensure the transistor will fully saturate and switch on.\n\nSo we want to drive an led at around 150ma and the data sheet shows us that we can go up to about 350mA. The forward voltage drop across the led is 3.2v. We will require a current limiting resistor (r2) we will factor in the voltage drop (vce) across the transistor switch, the data sheet shows that vce(sat) = 1v max, these conditions are for high current and voltage which we are not using so .3v is the most likely and will use this here.\n\nSo we have: Vsupply=vr2 + vled + vce\n\n rearranging this give us vr2 = vsupply – vled – vce = 5 – 3.2 – .3 = 1.5v\n\n we know that r2 will drop 1.5v and the current will be 150ma\n\nOhms law says r=v/i = 1.5/.150 = 10 ohms so the power is = vxi = 1.5vx150ma = 225mw or .22w for the resistor.\n\nThis is the minimum resistor value to gain maximum brightness. (this is assuming that 150ma was the maximum led current) to keep within safe tolerances use resistor values higher than the calculated value if maximum brightness is not required.\n\nThese kind of leds maximum current is up to 350ma, but we don't need them this bright, so have based it on around 150ma, and there is a variable brightness adjust resistor, which we don't want to exceed its max power rating which is typically up to 150/300mw and when this is adjusted it can share up to half of the load of the other resistor at a certain point.\n\n The other useful reason for this transistor type driver, is it can power higher voltage circuits, this transistor can be connected to a 12 volt supply as its ratings of vceo is 45v.\n\nBy way of example, if this board was powered by a 12 volt source, the circuit would have a 5 volt regulator for the micro, then this transistor circuit could be wired straight back to the 12 volt line. This would change the equation above,\n\n the supply voltage – the forward voltage drop of led/Led current would = 12v-3v = 9v/150ma = 60 ohms. Rated at 1.35w. Note: Ledlabs is 5 volt only.\n\n The main reason for connecting to a higher source is that a component like a 9 volt sounder/buzzer might want to be used, this circuit at 5 volts would not be high enough to drive it correctly.\n\nAs the large leds above do not require maximum brightness for this project board, a higher value of resistor is chosen, this makes the leds run dimmer, and consequently reducing the power, however they still are bright enough.\n\nCare should be taken when switching on any of the larger Leds as they are very bright when the variable brightness is set high and should avoid looking directly into them, always make sure the brightness is set low first. The 20R resistor can be changed to say a 100R to reduce further if required. The 20R resistor sets a current of around 110ma, and not their maximum range of 350ma which is too bright for this purpose. UV should not be looked directly into, as the peak wavelength can not be seen, just the visible side as in the purple colour.\n\nThe LM393 dual comparator is used in this circuit, the power supply is pre-wired to the board, and the inverting input to one of the comparators is wired to a 10k potentiometer in order to set the reference voltage.\n\n An output connector is available to measure and set this voltage, this can be measured by connecting it to the lm3914 voltage input connector.\n\n The other comparator is left open for free use, but has the power supply wired.\n\nThe lm393 is an open collector, so will require a load or pull-up resistor connected from its output to the +ve rail. (earlier revision) In one of the comparator circuits a load/pullup resistor is used, which offers the voltage drop required and toggles a red led and a green led\n\n These represent: Red led: High output, and green led: Low output.\n\n When the ldr etc is connected to the non-inverting input and gets close to the reference voltage of the comparator, set out by vref and analogue out from ldr circuits, the differential inputs can get very close, and because a signal from an ldr is generally a slow moving signal, this can cause the comparator to oscillate .Which in turn could send several pulses out and confuse micros.\n\n So a small amount of hysteresis is added in the form of a 100k resistor from the output back in to the non inverting input, this gives a nice clean single switch over pulse and helps with circuit stability, it also acts a bit like a schmitt trigger.\n\n This can be connected to the pulse counter on board, or indeed a microcontroller.\n\nThe other circuits can also be connected to the comparator or pulse counter. The light switch, over temperature and under temperature switches.\n\n The lm3914 voltmeter can be used to set the threshold voltages for the ldr and thermistor circuits and the voltage reference to the comparators, the scale is 0v-3.6v every led on the lm3914 represent 360mv. Comparator 1, has one input available as the inverting input is connected to a potentiometer, whereas comparator 2 has both inputs available for free use, and can be made to drive given circuits, which comparator 1 may not, as it has leds already attached. remembering that comparator 2 is open collector and would require a pull-up resistor to provide an output voltage. (earlier revision lab).\n\nFour of the various sensor circuits in LEDLabs are in the form of light and temperature, analogue level outputs, comprising light switch / dark switch and over temperature / under temperature these can be set relative to ambient conditions.\n\nAn output connector can be used to measure the corresponding analogue voltage level across the potential divider circuits, which in turn can be measured in the lm3914, which scales from 0v -3.6v . or indeed the op-amp comparator lm393 for sensing.\n\n An analogue input to a micro can also measure this value.\n\nThe thermistors used here are 10k negative temperature coefficient (ntc) whose resistance changes with temperature, the lower the temperature the higher the resistance.\n\n A 10k thermistor is a good choice and measures approximately 10k @ 25 degrees, so with a 10k variable resistor a good swing is achieved.\n\nThe light dependent resistors (ldr) used here have a dark resistance of around 1M ohm. And whose resistance changes with the amount of light falling on it. The more light falling the lower the resistance.\n\nA voltage divider is shown in (fig1) and is generally made up of two or more resistances, here we are looking at r1 and r2, and vout is the right hand side equation with the remaining voltage leftover v1.\n\n So for the ldr circuit above (fig2) in the dark it has high resistance of 1M ohm + and hence has a high vout and acts as a dark activated switch. Under light conditions vout is lower, as the resistance falls of the ldr, and may turn some device off when light falls, if connected to the lm3914 voltmeter the voltage and behaviour of these four circuits can be monitored.\n\nTransposing the ldr and resistor, we then have a light switch as (fig3). LEDLabs has an extra 1k resistor in series with a variable resistor making up the dividing network as shown above, the 10k variable can be swept through 1k to 11k to set the levels more precisely, the 1k allows for more finer control and if used to control a transistor, this fixed resistor must be used to stop zero ohm to the base of the transistor.\n\n To work out the series resistor for an ldr circuit, the equation is : r = square root of rmin x rmax, example rmin = 100 ohms rmax = 1Mohm therefore, 100×1000000 and the square root of this product = 10k, so LEDLabs uses a 10k variable,\n\n if the parameters of the ldr is not known from data sheets, it can be measured under both conditions, to find rmax and rmin measure the resistance when in total darkness and similarly with bright light falling upon it.\n\nLEDLabs has a set of pull-up resistors and pull-down resistors, as fig1 shows, this is useful for micro-controllers, as some pin ports require pulling up or down through a given value resistor to the voltage rail, however some now have embedded pullups.\n\n Various logic ic’s also require these, particularly when interfacing between two types of technologies, for example TTL and CMOS.\n\n It also ensures that a pin is at a logic level either 5v or 0v, so it is not ‘floating’ which could cause oscillation and erratic behaviour by the ic monitoring this. It could take the input as a logic 1 or logic 0.\n\nTwo leds, red for high and green for low are just opto indicators for the set of pullups. LEDLabs also has two button commands, one with a pull-up resistor and one with a pull-down resistor as seen in (fig2).\n\n When sw1 is pressed this pulls down cn1 to 0 volts so is active low when sw2 is pressed this pulls up cn2 to 5 volts so is active high.\n\n So these are useful tools for microcontrollers and various other kinds of logic.\n\nTwo crystal oscillators are on board as shown in (fig3) a 4mhz and a 16 mhz with 22pf capacitors for quick connection to microcontroller pins if required. Also the zif socket can be used for add-on sensor modules, as it has breakout connections.\n\n 8 leds of various colours as shown above in (fig4) are indicators for an 8 bit port test, they are all common to the 0 volt rail, and will light when port pins are active high (logic 1).\n\nThe microcontroller port has connections to ‘breakout’ to other circuits etc as shown in (fig5).\n\nThe 555 timer module gives a variable frequency clock generator, of square waves.\n\n The frequency is varied through a potentiometer (vr1) and a set of four dip switch settings which change the capacitance, which allows for 10hz, 200hz, 5khz, and 50khz.\n\nBy selecting the dip switch 1 with the others off will allow the slower range of frequencies then sweeping (vr1) to its maximum will end that range,\n\n this can be seen through the repeater led as blinking.\n\nIf higher frequencies are required turn off dip switch 1 and select dip switch 2 for the next set of frequencies and so on.\n\n As frequency increases the led will flash so fast that it becomes out of our persistence of vision and appears on all the time.\n\n Clock pulses or serial trains, are useful for toggling logic gates or being read by a micro’s serial interface.\n\n if this output is fed into the 4026b counter,you can see how this toggle effect works.\n\nThe 555 timer is wired as a monostable delay/trigger circuit.\n\n The timing is achieved through the rc network, vr1 c2 capacitor and r2.\n\n A larger capacitor will allow for longer delays a 220uf is used here in LEDLabs\n\n with a 470k variable which gives around about 1 second delay to a couple of minutes or so.\n\nIf the variable is moved to a given setting, switch 1 can be pressed to see how long the delay lasts for, an led light and sounder is triggered.\n\n When a signal from a micro etc goes active low, this will trigger the module, this is a very useful tool for making sure an event has happened, and can be audible or visually realised when program testing.\n\nA reverse bias diode is across the coil of the buzzer in case of any back emf generated, which could damage the 555 timer.\n\nThe stepper motor controller IC used is a ULN2003, which has seven npn darlington pair transistors which are known as current amplifiers, each having a reverse biased diode inbuilt to clamp any back EMF transients caused by switching inductive loads.\n\n Stepper motors have coils so are therefore inductive, and the diode inbuilt protects the transistors from potentially high switching voltages.\n\nThis is a good interface IC to drive heavier loads, as it has high current gains formed by the darlington pair transistors, which are open collector and are in common emitter configuration, and can drive up to 500ma per channel.\n\n The UlN2003 is not limited to driving stepper motors, as they are quite versatile and can drive relays, solenoids, filament lamps, led displays etc.\n\nThe stepper motor bit pattern led indicators A B C D, will show which phase is switched on and how fast they are switched on.\n\n The five port connector drives the four phases of the motor and the common.\n\n The four port input comes from a micro or some other timed switching controller.\n\nLEDLabs is equipped with an onboard atmega 328p microcontroller; the same controller used for the Arduino.\n\n This can be programmed in situ, by simply connecting the tx and rx and reset and common ground to the inputs on the LEDLabs board provided, from such as the arduino uno board(s) output connectors.\n\n Analogue inputs and digital pins including PWM, are accessible on LEDLabs Which can receive input signals from LEDLabs, and act on them, and also output to the LEDLabs board, or indeed any other circuit or device, if another circuit is used make sure to connect the ground from LEDLabs to the ground on the other device, to ensure they use a common ground, or undesirable effects may be noticed like program code not working correctly.\n\nOther micro’s are programmed in the usual way through their programmers, then the micro removed and placed in Led Labs. Some programming boards such as Raspberry pi have output connectors, which can be linked to devices on LedLabs, just connecting the ground from one of these programmers to LedLabs to common them together.\n\nTwo dot matrix displays are driven by the max 7219 driver integrated circuits, which have a data, load, and clock connectors, which can be controlled by the atmega 328p, and reprogrammed without moving the chip, by connecting the rx, tx, reset and common ground pins of the arduino uno board.\n\n A boot loader may have to be installed on the atmega328p to match the programmer board used, and information on this is available on the arduino website, using the arduino as a avr isp.\n\n If the atmega was removed from the uno board and placed in LedLabs it would work straight away as it matches programmer, and can be programmed in situ, by connecting rx, tx, rst, and 0v from the uno board to led labs. If using the uno board, when purchasing the atmega328pu microcontroller chip on its own, purchase with uno bootloader already installed. In any case, the atmega328pu ic should be removed from the uno board when programming the led labs board.\n\n Other Micro’s such as the pic can also control the displays.\n\n If no particular program is running on the dot matrix displays, it will just have random data loaded and may flash or light all segments when not in use, if the data in to the max7219 is taken to 0v, this should blank the display and save power.\n\nLEDLabs has 3 x 8 bit shift registers, forming a 24 led propagation fountain, very good effects can be seen on the display, such as walking ‘ones’, or even sharing the data line which controls the dot matrix displays, (when it is running) to the data input of the shift register, and clock from the 555 astable circuit on board to slow the clocking down.\n\nIt has output enable always on. 3 connectors are provided, one for the strobe and data and clock\n\n The registers shift automatically to the next device. These can be used from the atmega or pic, or other ways like the 555 timer for the clock and two switches manually toggling the strobe and data."
    },
    {
        "link": "https://electronics.stackexchange.com/questions/516888/10k-potentiometer-with-arduino-uno-and-5v-works-but-same-pot-with-esp32-and-3-3v",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://scribd.com/document/444742892/Advanced-View-of-Atmega-Microcontroller-Projects-List-ATMega32-AVR",
        "document": "Most of the electronics geeks are asking the whole list of Atmega AVR projects PDF here we will share list every month as our projects are being updated on daily basis. PDF is a good source to work offline. We will offer direct PDF file download link with info of its release date , number of projects."
    }
]