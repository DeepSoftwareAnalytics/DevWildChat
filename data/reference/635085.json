[
    {
        "link": "https://stackoverflow.com/questions/865668/parsing-command-line-arguments-in-c",
        "document": "A command is basically a string. In general it can be split into two parts - the command's and the command's .\n\nis used for listing the contents of a directory:\n\nThe above is executed inside folder of a user. Here the argument which folder to list is implicitly added to the command. We can explicitly pass some arguments:\n\nHere I have explicitly told which folder's contents I'd like to see. We can use another argument for example for listing the details of each file and folder such as access permissions, size etc.:\n\nOh, the size looks really weird ( , ). Let's add the flag for human-friendly output:\n\nSome commands allow their arguments to be combined (in the above case we might as well write and we'll get the same output), using short (a single letter usually but sometimes more; abbreviation) or long names (in case of we have the or for listing all files including hidden ones with being the long name for ) etc. There are commands where the order of the arguments is very important but there are also others where the order of the arguments is not important at all.\n\nFor example it doesn't matter if I use or however in the case of (moving/renaming files) you have less flexibility for your last 2 arguments that is .\n\nIn order to get a grip of commands and their arguments you can use (example: ) or (example: ).\n\nIn many languages including C/C++ you have a way of parsing command line arguments that the user has attached to the call of the executable (the command). There are also numerous libraries available for this task since in its core it's actually not that easy to do it properly and at the same time offer a large amount of arguments and their varieties:\n\nEvery C/C++ application has the so called entry point, which is basically where your code starts - the function:\n\nNo matter if you use a library (like one of the above I've mentioned; but this is clearly not allowed in your case ;)) or do it on your own your function has the two arguments:\n• - a pointer to an array of strings (you can also see which is basically the same but more difficult to use).\n\nNOTE: actually also has a third argument which allows passing environment variables to your command but this is a more advanced thing and I really don't think that it's required in your case.\n\nThe processing of command line arguments consists of two parts:\n• Tokenizing - this is the part where each argument gets a meaning. Its the process of breaking your arguments list into meaningful elements (tokens). In the case of the is not only a valid character but also a token in itself since it represents a complete, valid argument.\n\nHere is an example how to output the number of arguments and the (unchecked for validity) characters that may or may not actually be arguments:\n• None Parsing - after acquiring the tokens (arguments and their values) you need to check if your command supports these. For example: ls: invalid option -- 'y' Try 'ls --help' for more information. This is because the parsing has failed. Why? Because (and respectively; note that , , etc. is not required and its up to the parsing of the arguments whether you want that stuff there or not; in Unix/Linux systems this is a sort of a convention but you are not bind to it) is an unknown argument for the command.\n\nFor each argument (if successfully recognized as such) you trigger some sort of change in your application. You can use an for example to check if a certain argument is valid and what it does followed by changing whatever you want that argument to change in the execution of the rest of your code. You can go the old C-style or C++-style:\n\nI actually like (when not using a library) to convert to an of strings like this:\n\nThe part is just an easier C++-ish way to handle the array of strings since is a C-style string (with being an array of such strings) which can easily be converted to a C++ string that is . Then we can add all converted strings to a vector by giving the starting address of and then also pointing to its last address namely (we add number of string to the base address of which is basically pointing at the last address of our array).\n\nInside the loop above you can see that I check (using simple ) if a certain argument is available and if yes then handle it accordingly. A word of caution: by using such a loop the order of the arguments doesn't matter. As I've mentioned at the beginning some commands actually have a strict order for some or all of their arguments. You can handle this in a different way by manually calling the content of each (or if you use the initial and not the vector solution):\n\nThis makes sure that at position only the will be expected etc. The problem with this is that you can shoot yourself in the leg by going out of bounds with the indexing so you have to make sure that your index stays within the range set by :\n\nThe example above makes sure you have content at index and but not beyond.\n\nLast but not least the handling of each argument is a thing that is totally up to you. You can use boolean flags that are set when a certain argument is detected (example: and later on in your code do something based on the and its value), numerical types if the argument is a number OR consists of number along with the argument's name (example: has an argument which you can additionally parse as and the last being the value of ) etc. Based on the task at hand you can go crazy and add an insane amount of complexity to your command line arguments.\n\nHope this helps. Let me know if something is unclear or you need more examples."
    },
    {
        "link": "https://medium.com/@mostsignificant/3-ways-to-parse-command-line-arguments-in-c-quick-do-it-yourself-or-comprehensive-36913284460f",
        "document": "If you are writing a C++ tool you often need the user to pass in arguments via the command line. Like with many other C++ topics, there are also many ways to handle command line arguments in C++. In this post I want to introduce three different methods to do this, including the pros and cons of each. You can decide on the method which best suits your project.\n\nMore Than One Way To Skin A Command Line\n\nI will describe the following three methods to parse command line arguments:\n• A Quick-And-Dirty method if you just need to pass a few arguments in a controlled environment\n• Your own Do-It-Yourself command line arguments parser if you need a little bit more, are a fan of homemade C++, or if you suffer from dependophobia (the medical term for being afraid of managing dependencies in your code)\n• Setting up a comprehensive solution with an external library which does the heavy lifting for you\n\nThe first question is a basic one: How do these command line arguments find their way into my C++ source code? The C++ standard mentions two valid signatures for the main function:\n\nYes, you guessed right, the second one is the one we’re after here. It supplies an array of strings ( ) and the number of elements in this array ( ). As C++ developers who find happiness in iterating over things, we very much like the following quote:\n\nThis means we can easily plug those into functions and containers from the C++ standard library. Rewrite your main function signature to if you haven’t already. Next, you can easily print the command line arguments passed to your application with a single line (and some includes) which is useful for quick “debugging” (in my book, printf-ing qualifies as debugging):\n\nThis line will output every passed command line argument on stdout on separate lines. If you execute this, you will see that the first argument is the program’s calling name itself.\n\nBonus: I had my aha-moment when I read that a third form for the function signature exists, which also supplies the host’s environment variables:\n\nYou can read more about this here. However, this is out of scope for this blog post. Additionally, the authors recommend that:\n\nFor showcasing the three methods we are using a simple example application. The application will be called and prints whatever file we give as command line parameter (a simplified command) to the stdout command line. We will make additional features available for the user as command line arguments to display the individual parsing methods. The example can be found on my GitHub repository https://github.com/mostsignificant/dog with three different branches. I might use the main branch for further development or future blog posts."
    },
    {
        "link": "https://learn.microsoft.com/en-us/cpp/cpp/main-function-command-line-args?view=msvc-170",
        "document": "All C++ programs must have a function. If you try to compile a C++ program without a function, the compiler raises an error. (Dynamic-link libraries and static libraries don't have a function.) The function is where your source code begins execution, but before a program enters the function, all static class members without explicit initializers are set to zero. In Microsoft C++, global static objects are also initialized before entry to . Several restrictions apply to the function that don't apply to any other C++ functions. The function:\n• Can't be overloaded (see Function overloading).\n• Can't be declared as .\n• Can't be declared as .\n• Can't have its address taken.\n• Can't be called from your program.\n\nThe function doesn't have a declaration, because it's built into the language. If it did, the declaration syntax for would look like this:\n\nIf no return value is specified in , the compiler supplies a return value of zero.\n\nThe arguments for allow convenient command-line parsing of arguments. The types for and are defined by the language. The names and are traditional, but you can name them whatever you like.\n\nThe argument definitions are as follows:\n\n\n\n An integer that contains the count of arguments that follow in argv. The argc parameter is always greater than or equal to 1.\n\n\n\n An array of null-terminated strings representing command-line arguments entered by the user of the program. By convention, is the command with which the program is invoked. is the first command-line argument. The last argument from the command line is , and is always NULL.\n\nFor information on how to suppress command-line processing, see Customize C++ command-line processing.\n\nIf you design your source code to use Unicode wide characters, you can use the Microsoft-specific entry point, which is the wide-character version of . Here's the effective declaration syntax for :\n\nYou can also use the Microsoft-specific , which is a preprocessor macro defined in . resolves to unless is defined. In that case, resolves to . The macro and other macros that begin with are useful for code that must build separate versions for both narrow and wide character sets. For more information, see Using generic-text mappings.\n\nAs a Microsoft extension, the and functions can be declared as returning (no return value). This extension is also available in some other compilers, but its use isn't recommended. It's available for symmetry when doesn't return a value.\n\nIf you declare or as returning , you can't return an exit code to the parent process or the operating system by using a statement. To return an exit code when or is declared as , you must use the function.\n\nThe or signatures allow an optional Microsoft-specific extension for access to environment variables. This extension is also common in other compilers for Windows and UNIX systems. The name is traditional, but you can name the environment parameter whatever you like. Here are the effective declarations for the argument lists that include the environment parameter:\n\n\n\n The optional parameter is an array of strings representing the variables set in the user's environment. This array is terminated by a NULL entry. It can be declared as an array of pointers to ( ) or as a pointer to pointers to ( ). If your program uses instead of , use the data type instead of .\n\nThe environment block passed to and is a \"frozen\" copy of the current environment. If you later change the environment by making a call to or , the current environment (as returned by or and the or variable) will change, but the block pointed to by won't change. For more information on how to suppress environment processing, see Customize C++ command-line processing. The argument is compatible with the C89 standard, but not with C++ standards.\n\nThe following example shows how to use the , , and arguments to :\n\nThe command line parsing rules used by Microsoft C/C++ code are Microsoft-specific. The runtime startup code uses these rules when interpreting arguments given on the operating system command line:\n• None Arguments are delimited by white space, which is either a space or a tab.\n• None The first argument ( ) is treated specially. It represents the program name. Because it must be a valid pathname, parts surrounded by double quote marks ( ) are allowed. The double quote marks aren't included in the output. The parts surrounded by double quote marks prevent interpretation of a space or tab character as the end of the argument. The later rules in this list don't apply.\n• None A string surrounded by double quote marks is interpreted as a single argument, which may contain white-space characters. A quoted string can be embedded in an argument. The caret ( ) isn't recognized as an escape character or delimiter. Within a quoted string, a pair of double quote marks is interpreted as a single escaped double quote mark. If the command line ends before a closing double quote mark is found, then all the characters read so far are output as the last argument.\n• None A double quote mark preceded by a backslash ( ) is interpreted as a literal double quote mark ( ).\n• None Backslashes are interpreted literally, unless they immediately precede a double quote mark.\n• None If an even number of backslashes is followed by a double quote mark, then one backslash ( ) is placed in the array for every pair of backslashes ( ), and the double quote mark ( ) is interpreted as a string delimiter.\n• None If an odd number of backslashes is followed by a double quote mark, then one backslash ( ) is placed in the array for every pair of backslashes ( ). The double quote mark is interpreted as an escape sequence by the remaining backslash, causing a literal double quote mark ( ) to be placed in .\n\nThe following program demonstrates how command-line arguments are passed:\n\nThe following table shows example input and expected output, demonstrating the rules in the preceding list.\n\nThe Microsoft compiler optionally allows you to use wildcard characters, the question mark ( ) and asterisk ( ), to specify filename and path arguments on the command line.\n\nCommand-line arguments are handled by an internal routine in the runtime startup code, which by default doesn't expand wildcards into separate strings in the string array. You can enable wildcard expansion by including the file ( file for ) in your compiler options or your command line.\n\nFor more information on runtime startup linker options, see Link options.\n\nIf your program doesn't take command-line arguments, you can suppress the command-line processing routine to save a small amount of space. To suppress its use, include the file (for both and ) in your compiler options or your command line.\n\nSimilarly, if you never access the environment table through the argument, you can suppress the internal environment-processing routine. To suppress its use, include the file (for both and ) in your compiler options or your command line.\n\nYour program might make calls to the or family of routines in the C runtime library. If it does, you shouldn't suppress the environment-processing routine, since it's used to pass an environment from the parent process to the child process."
    },
    {
        "link": "https://stackoverflow.com/questions/1814756/parsing-argc-and-argv-in-c",
        "document": "I want to learn more C++... Usually I make a for loop to parse argv, and I wind up with a bunch a C-style strings. I want to do something similar in C++, but preferably without reading from /proc/whatever. At first, I tried to convert the C-style string to a C++ style string without results... The frustrating bit is that everyone on SO seems to want to know how to go the other way, which is what c_str() is for. What's a good C++ way to do this (ie parse argv)?\n\nAlso, one note, I'm looking for a unix style answer, all the techniques for conversion I've seen have to do with Windows, which I'm completely uniterested in."
    },
    {
        "link": "https://reddit.com/r/cpp/comments/qmvxt1/3_ways_to_parse_command_line_arguments_in_c_quick",
        "document": "If you are out of Medium stories, you can also view it here: https://mostsignificant.github.io/c++/2021/11/03/3-ways-to-parse-command-line-arguments-in-C++-quick-do-it-yourself-or-comprehensive.html\n\nMy first blog article - feedback very much welcome! Thank you!"
    },
    {
        "link": "https://cplusplus.com/reference/string/stoi",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/7663709/how-can-i-convert-a-stdstring-to-int",
        "document": "I want to convert a string to an int and I don't mean ASCII codes.\n\nFor a quick run-down, we are passed in an equation as a string. We are to break it down, format it correctly and solve the linear equations. Now, in saying that, I'm not able to convert a string to an int.\n\nI know that the string will be in either the format (-5) or (25) etc. so it's definitely an int. But how do we extract that from a string?\n\nOne way I was thinking is running a for/while loop through the string, check for a digit, extract all the digits after that and then look to see if there was a leading '-', if there is, multiply the int by -1.\n\nIt seems a bit over complicated for such a small problem though. Any ideas?"
    },
    {
        "link": "https://udacity.com/blog/2021/05/the-cpp-stoi-function-explained.html",
        "document": "No developer wants to parse string inputs for integer values, simply because they need these values for another part of their program. Luckily, C++ has a stoi function that converts numeric strings to integers. stoi also has some functionality for getting rid of other material in the string, such as trailing characters.\n\n\n\nIn this article, we’ll provide an overview of the stoi function in C++ and when it’s most appropriate to use.\n\nWhat Is stoi() in C++?\n\nIn C++, the stoi() function converts a string to an integer value. The function is shorthand for “string to integer,” and C++ programmers use it to parse integers out of strings. The stoi() function is relatively new, as it was only added to the language as of its latest revision (C++11) in 2011.\n\nTo use stoi, you’ll need to provide specific criteria for the function:\n\nThe first criterion is the string that needs to be converted.\n\nNext, we’ll need to specify the identifier for the starting position of the number within the string that needs to be parsed.\n\nint base defines the numerical base for the string. As examples, we have 2 for binary, 16 for hexadecimal, and 10 for base 10.\n\nUnless working with a base set other than base 10, the only criterion we require is the string itself. We’ll see examples for hexadecimal and binary numbers a bit later.\n\nstoi() is straightforward to use, as we’ll see below:\n\nAs you can see, we first declare a string, str1, with the value 123. We use the stoi() function to convert this string into an integer and then use cout to output it. Here’s the result:\n\nIf you’re using an older version of C++ that’s locked to pre-C++11 (e.g., C++03), the stoi() function won’t be available to use. Instead, you’ll need to use the stringstream class located in the C++ standard library. Here’s how we use stringstream:\n\nAs you can see, we still declare the str1 to be 123, but then we have to use stringstream instead of stoi. stringstream allows us to place str1 into an object that, in this example, is named container.\n\nNext, we declare an integer x, but this integer can be any value as we’re going to replace it shortly. We use a right shift (>>) to slide the string value stored in the object container to replace the integer previously stored in x.\n\nFinally, we can use cout to output the value of x, which is our original string. Running the code gives us:\n\nThat wasn’t so bad, was it? Let’s now go deeper and examine a few to use C++ STOI.\n\nHow To Use the C++ String to Integer (STOI) Conversion\n\nThe stoi() function works well at pulling integers out of strings save for one major hiccup, which we’ll see below. stoi() can handle + or – signs, zeros at the front of a number, hexadecimal prefixes (0x or 0X) and whitespace characters without issue. stoi() does not even care if other characters follow the number:\n\nThis example returns the following:\n\nAs this example shows, stoi does not mind the minus sign in string s1, chops off the characters we see after 123 in string s2, and removes all those unsightly zeros for us in string s3. Since stoi returns integers, string s4 is truncated and loses everything after the decimal point.\n\nHowever, this only works in cases where letters appear after the integer characters. For strings where a letter precedes a digit, our program throws an error. Let’s have a look:\n\nRunning code that’s based on the examples above returns a std::invalid_argument error because stoi cannot handle the characters before the number in the string.\n\nWhen To Use String to Int in C++\n\nUsing string to int is beneficial when you require user input in the form of a string, and you need to extract an integer from that string. Perhaps the user is listing their address, and you want to use only the address number somewhere further in your program. stoi can separate those house numbers for whatever reason you might need.\n\nAnother instance where stoi shines is in regards to file inputs. Often, file access functions will give strings to work with. The stoi function can take those strings from the file input and extract the integers for later use.\n\nFor example, consider a program that inputs a file with a list of transactions as a set of strings. The stoi function can take those strings and pull out the dollar values as integers for calculation and analysis.\n\nWhen To Avoid Using String to Int in C++\n\nThere are instances where converting a string to int in C++ is not necessary. Under certain circumstances, you can set up your program to simply read an integer right away. Instead of having a user input something as a string, you can use the std::cin variable to have the user input an integer. Here’s an example:\n\nThis program starts off by outputting a command to the user, looking for the user’s age. The code is set up using int x{ } to capture that input as an integer value. As long as the user puts in a valid response, this code shifts that integer to our variable x, and then outputs that back to the user. Should a user put in a floating-point number, this program will truncate the number and return only the integer.\n\nAssuming the user listed “25” at their age, we’ll see the following output:\n\nOther Number Parsing Functions in C++\n\nWhen it comes to parsing numbers, C++11 introduced a few other functions to use in specific scenarios.\n\nThe first, stoul, works much like stoi except that stoul converts a string into an unsigned integer. The stoul function does so by returning the original string as an unsigned long value.\n\nstof and stod work similarly to stoul but convert a string to a floating-point number or a double, respectively. These functions let programmers go beyond the realm of just integers and work with decimal numbers as well.\n\nEarly on, we talked about using stoi to read non-base ten strings. Let’s see how stoi works with a hexadecimal example:\n\nHere, we use the hexadecimal string “FF.” We do need to let the stoi function know that the string has a hexadecimal base (hence the 16 in the int base slot). We get an output of:\n\n\n\nSimilarly, we can likewise use stoi for binary strings:\n\nAt this point, we need to change our base value from the default 10 to a 2 to represent our binary string. We get the following output:\n\nIn this guide to C++ STOI, we’ve barely scratched the surface of the amazing capabilities of the C++ language. Why not go further?\n\n\n\nOur C++ nanodegree program takes you through a hands-on curriculum that’s designed to turn you into a fully fledged C++ developer."
    },
    {
        "link": "https://en.cppreference.com/w/cpp/string/basic_string/stol",
        "document": "Interprets a signed integer value in the string str.\n\nLet ptr be an internal (to the conversion functions) pointer of type char* (1,3,5) or wchar_t* (2,4,6), accordingly.\n\nDiscards any whitespace characters (as identified by calling ) until the first non-whitespace character is found, then takes as many characters as possible to form a valid base-n (where n= ) integer number representation and converts them to an integer value. The valid integer value consists of the following parts:\n• prefix ( ) indicating octal base (applies only when the base is or )\n• prefix ( or ) indicating hexadecimal base (applies only when the base is or )\n\nThe set of valid values for base is . The set of valid digits for base- integers is , for base- integers is , and so on. For bases larger than , valid digits include alphabetic characters, starting from for base- integer, to for base- integer. The case of the characters is ignored.\n\nAdditional numeric formats may be accepted by the currently installed C locale.\n\nIf the value of is ​0​, the numeric base is auto-detected: if the prefix is , the base is octal, if the prefix is or , the base is hexadecimal, otherwise the base is decimal.\n\nIf the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by unary minus in the result type.\n\nIf pos is not a null pointer, then ptr will receive an address of the first unconverted character in str.c_str(), and the index of that character will be calculated and stored in *pos, giving the number of characters that were processed by the conversion.\n\nInteger value corresponding to the content of str.\n• if no conversion could be performed.\n• if the converted value would fall out of the range of the result type or if the underlying function ( or ) sets to .\n\nThe following behavior-changing defect reports were applied retroactively to previously published C++ standards."
    },
    {
        "link": "https://stackoverflow.com/questions/45850806/checking-if-a-string-is-a-number-then-converting-that-number-to-an-int",
        "document": "The problem is that\n\ncreates a fresh string stream from the initial sentence, then tries to extract from it into . Of course that will fail (as the first word in the sentence is not a number). If you wonder why was set to 0, that's because on failure, the zeros the argument (since C++11).\n\nBefore C++11, it left the argument unchanged. See the documentation for more details.\n\nThe correct way is to use a conversion from string to (or ), namely , and replace that line by"
    }
]