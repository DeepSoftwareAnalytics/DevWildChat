[
    {
        "link": "https://stackoverflow.com/questions/31082160/optimize-performance-of-loop",
        "document": "I've been profiling a bottleneck in my code (a function shown below) that gets called several million times. I could use tips on increasing the performance. The numbers were taken from Sleepy.\n\nCompiled with visual studio 2013, and other typical release settings.\n\nis typically 0 to 20 values, and other parameters are the same size ( ).\n\nThanks for the tips guys. Here were the results I got from the suggestions:\n\nI found it interesting that switching to and had such a large impact. I guess the compiler isn't being as smart as it could there. I'm happy with the bump, but still curious if there's more room here through unrolling or vectorization.\n\nFor those interested, here my benchmark for :"
    },
    {
        "link": "https://stackoverflow.com/questions/11583292/optimize-code-for-large-number-of-iterations",
        "document": "I am currently working on a project which involves a large number of iterations (2^32 to be exact). I have mainly been using mathematica for most of my calculations, but it can't handle that sort of amount of processes. It has been suggested to me that c++ would be able to handle it, so last night I learnt c++ and wrote the following code:\n\nThe code runs fine, (I checked on smaller parameters) but I have started running it for 4294967295 = 2^32-1 steps, and I think it will take hundreds of hours. I would be really grateful if someone could tell me if there are ways to optimize bits of this code so that it will run faster? I have no experience with this kind of language and so how I've constructed the functions probably looks quite messy. I think my Ca2step function runs quite efficiently (I'm probably wrong), and I think its my loops in the main section that are slowing everything down. I think there must be faster methods for what I am trying to accomplish, so any help would be great. Thanks, Richard.\n\nThanks so much everybody, I really appreciate it. Ok I this is all very new to me, so I'm finding it quite hard to understand what some things mean. Below is my updated code. However I get the feeling that it's still just as slow. Some people suggested \"parallelising\" but I don't know what this is and how I would do it? Thanks again, Richard."
    },
    {
        "link": "https://hackernoon.com/c-performance-optimization-best-practices",
        "document": "Performance optimization is a critical aspect of C++ programming, as it can significantly impact the speed and efficiency of your applications. In this article, we'll explore various techniques and best practices for optimizing C++ code. Whether you're a beginner or an experienced developer, these tips will help you write faster and more efficient C++ programs.\n\n1. Use the Right Data Structures\n\nChoosing the appropriate data structures can have a massive impact on performance. Use for dynamic arrays, or for key-value pairs and or for unique values. Avoid linked lists when you need random access, as they can lead to poor cache performance.\n\nExample: Using for Dynamic Arrays\n\nCopying objects can be expensive. Use references or move semantics ( ) when passing and returning objects to minimize unnecessary copying. If you use then try to change it in some cases, it will have a better performance.\n\nAllocate objects on the stack whenever possible, as stack allocation is faster than heap allocation. Use dynamic allocation (e.g., and ) only when the object's lifetime extends beyond the current scope.\n\nHowever, it's important to note that stack allocation has limitations:\n• Fixed Size: Stack memory is of fixed size and is limited. This means you can't allocate very large objects or a dynamic number of objects on the stack.\n• Risk of Stack Overflow: Excessive stack memory usage can lead to a stack overflow if the available stack space is exhausted. Heap memory doesn't have this limitation.\n\nProfiling tools can help identify performance bottlenecks. Use tools like (GNU Profiler) or platform-specific profilers to analyze your code's execution time and memory usage.\n• Identify what areas of code are taking how much time\n• See if you can use better data structures/ algorithms to make things faster\n\nExcessive memory allocation and deallocation can lead to performance issues. Reuse objects when possible and consider using object pools for frequently created and destroyed objects.\n\nLoops are often the core of algorithms. Optimize loops by minimizing loop overhead, reducing unnecessary calculations, and using the right loop constructs (e.g., range-based loops).\n\nModern C++ compilers provide optimization flags (e.g., , ) that can significantly improve code performance. Use these flags during compilation to enable various optimization techniques.\n• : Enables basic optimization. This includes optimizations such as common subexpression elimination and instruction scheduling. It's a good balance between optimization and compilation time.\n• : Enables more aggressive optimization, including inlining functions, loop optimizations, and better code scheduling. It provides a significant performance boost.\n• : Enables even more aggressive optimizations. It can lead to faster code but may increase compilation time and the size of the executable.\n\nMinimize function calls within tight loops. Inlining functions (e.g., using or compiler optimizations) can eliminate function call overhead.\n\nOptimize for cache efficiency by minimizing cache misses. Access data sequentially, avoid non-contiguous memory accesses, and use data structures that promote cache locality.\n\nBenchmark your code after each optimization step to measure the impact of changes accurately. Iteratively apply optimizations, focusing on the most significant bottlenecks.\n\nOptimizing C++ code is a crucial skill for achieving high-performance applications. You can significantly enhance your code's speed and efficiency by using the right data structures, avoiding unnecessary copying, and following best practices. Profiling, benchmarking, and iterative optimization are essential tools for achieving optimal performance. Remember that premature optimization is not always beneficial; focus on optimizing critical sections of your code when necessary."
    },
    {
        "link": "https://cplusplus.com/forum/beginner/120176",
        "document": "Hi, this is my first time posting, but I've been teaching myself C++ for a bit and I've created a program which plots the path an electron will take if it's shot into a field filled with stationary electrons. It pretty much works fine, but it essentially involves running a loop, in which the program does some basic algebra based on input, prints the results to a file, and then uses the results as the input for the next loop. The main loop has 10^20th iterations, and is itself inside a loop which runs 50 times.. And i'd like to make the inner loop do a couple more orders of magnitude still.. But it takes half of a day for the program to complete. Are there any basic things I could change about the code which could make the program run faster? \n\n \n\n Like, currently, each iteration requires about 100 (quite small) function calls. How much faster would the program be if I condensed that number into something more like 10 or 5? It would be pretty complicated and hard to test so i'd rather not unless it'd help substantially.\n\n \n\n Also, I use \"fout\" to print to the file, and once I think I accidentally told it not to print to file and it took only 4 hours to complete instead of the 12 it usually took. So is there something faster than fout?\n\n \n\n And I cant copy paste all the code in here, so is there any other information I can give you that would help?\n\n \n\n Sorry for the plethora of questions:p, thank you for any replies\n\n\n\n \n\n No, the memory must have been failing anyway. High processor usage might have caused temperature to be high (though not dangerously high) and accelerated the process.\n\n \n\n \n\n > I accidentally told it not to print to file and it took only 4 hours to complete instead of the 12 it usually took.\n\n \n\n Get rid of the on every line. Flushing an output stream once per line is a very expensive operation. The output stream is buffered, characters are held in a large buffer in memory, and the buffer would be automatically flushed when it becomes full. \n\n \n\n And print a single tab character as a char rather than as a string containing one char.\n\n \n\n Just change just this one line, and then measure the performance. \n\n \n\n \n\n \n\n > each iteration requires about 100 (quite small) function calls. \n\n > How much faster would the program be if I condensed that number into something more like 10 or 5?\n\n \n\n If the code is being compiled with optimization enabled, it would make no perceptible difference in performance. > is it possible my program did that?No, the memory must have been failing anyway. High processor usage might have caused temperature to be high (though not dangerously high) and accelerated the process.> I accidentally told it not to print to file and it took only 4 hours to complete instead of the 12 it usually took.Get rid of theon every line. Flushing an output stream once per line is a very expensive operation. The output stream is buffered, characters are held in a large buffer in memory, and the buffer would be automatically flushed when it becomes full.And print a single tab character as a char rather than as a string containing one char.Just change just this one line, and then measure the performance.> each iteration requires about 100 (quite small) function calls.> How much faster would the program be if I condensed that number into something more like 10 or 5?If the code is being compiled with optimization enabled, it would make no perceptible difference in performance.\n\nI'll certainly change the 's, but the endl's are in there because I open the txt files in excel, so I can create a graph of what's happening. The tabs put each output into a different box, and then the endl puts each new iteration on a new line. Is there a way of accomplishing this without using endl? Like would using '\n\n' fix the problem?\n\n And ok. I'll try ValliusDax's sollution next.\n\n And as for the memory I think I mean RAM. the computer stopped giving the error once I removed one of the memory chip things from inside the pc. It certainly wasn't flash memory, nor the hard drive, so i guess that makes it RAM. Sorry for the non-technical verbage:p\n\n Thank you:)\n\nIs there any particular reason why you wish to use s as opposed to ordinary s? A double has 15 or 16 significant figures, while a long double has only 2 extra - 17 or 18. Do you really need the extra precision?\n\n \n\n Btw, you should never use floating point types in for loops like you have on line 105. There is always a way to calculate how many times the loop should run as an int. OR use a while loop.\n\n \n\n With the function, it just calls a library math function, could you just call the math function direct? If you have lots of calcs, the extra function call can become quite a cost.\n\n \n\n Hope all goes well\n\n \n\n\n\n\n\n > as opposed to printing out a whole bunch of little bits of data- \n\n > There would be somewhere around 2000 lines (~10000 chars) of output per iteration, \n\n > can strings hold that much?\n\n \n\n Yes, a string can hold that much; but if you do that, it will degrade performance. Streams are buffered, and this would be needlessly buffering writes into a buffer. If the stream has a buffer size of say 4K, and you needlessly perform double buffering with a string of size of 10K, the number of flushes of the stream buffer (expensive) would not be any less. Creating and writing into the string first would just become an extra overhead.\n\n \n\n If you want to control buffering, adjust the streams buffer size. There is typically a sweet spot for the buffer size on a particular implementation; measure performance. An unnecessarily large buffer size is a bad idea.\n\n \n\n main() { TAB = ; // values to be written into one line in the file // in the actual program, these would be the calculated values // volatile, because we do not want any super-smart optimization x[] = { 1.2345, 1.2345, 1.2345, 1.2345, 1.2345, 1.2345, 1.2345 }; clock = std::chrono::steady_clock ; msecs = std::chrono::milliseconds ; std::chrono::duration_cast ; // for the actual tests, make this larger, say 1024*1024 NLINES = 1024 * 64 ; std::size_t sz = 1024 ; ( i = 0 ; i < 10 ; ++i, sz *= 2 ) { std::unique_ptr< [] > buf( [sz] ) ; std::cout << << sz ; std::ofstream file ; file.rdbuf()->pubsetbuf( buf.get(), sz ) ; file.open( ) ; // and then open the file start = clock::now() ; ( i = 0 ; i < NLINES ; ++i ) { ( d : x ) file << d << TAB ; file << ; } file << std::flush ; end = clock::now() ; std::cout << << duration_cast<msecs>(end-start).count() << ; } } \n\n http://coliru.stacked-crooked.com/a/8be78a8962c2deaa\n\n \n\n There is a lot of merit in TheIdeasMan's suggestion of using instead of \n\n http://www.cplusplus.com/forum/beginner/112257/#msg613439\n\n \n\n And none at all in the claim that removing the function and calling the math function direct would improve performance in any way. The optimizer knows what you are doing. \n\n \n\n EDIT: If you still want to take the roundabout (first data to string and then string to file) route, turn of buffering for the stream with (before any i/o is performed on the stream). > making a really really long string and printing that out once> as opposed to printing out a whole bunch of little bits of data-> There would be somewhere around 2000 lines (~10000 chars) of output per iteration,> can strings hold that much?Yes, a string can hold that much; but if you do that, it will degrade performance. Streams are buffered, and this would be needlessly buffering writes into a buffer. If the stream has a buffer size of say 4K, and you needlessly perform double buffering with a string of size of 10K, the number of flushes of the stream buffer (expensive) would not be any less. Creating and writing into the string first would just become an extra overhead.If you want to control buffering, adjust the streams buffer size. There is typically a sweet spot for the buffer size on a particular implementation; measure performance. An unnecessarily large buffer size is a bad idea.There is a lot of merit in TheIdeasMan's suggestion of usinginstead ofAnd none at all in the claim that removing thefunction and calling the math function direct would improve performance in any way. The optimizer knows what you are doing.EDIT: If you still want to take the roundabout (first data to string and then string to file) route, turn of buffering for the stream with(before any i/o is performed on the stream)."
    },
    {
        "link": "https://quora.com/How-do-I-reduce-execution-time-while-handling-large-numbers-1-million-in-loops-in-C++",
        "document": "Something went wrong. Wait a moment and try again."
    },
    {
        "link": "https://geeksforgeeks.org/maximum-value-of-long-long-int-in-c",
        "document": "In this article, we will discuss the long long int data type in C++. long long int data type in C++ is used to store 64-bit integers. It is one of the largest data types to store integer values, unlike unsigned long long int both positive and negative.\n\nSome properties of the long long int data type are:\n• Being a signed data type, it can store positive values as well as negative values.\n• Takes a size of 64 bits, where 1 bit is used to store the sign of the integer.\n• A maximum integer value that can be stored in a long long int data type is typically 9, 223, 372, 036, 854, 775, 807 around 263 – 1(but is compiler dependent).\n• The maximum value that can be stored in long long int is stored as a constant in <climits> header file. Whose value can be used as LLONG_MAX.\n• A minimum integer value that can be stored in a long long int data type is typically –9, 223, 372, 036, 854, 775, 808, around –263 (but is compiler dependent).\n• In case of overflow or underflow of data type, the value is wrapped around. For example, if –9, 223, 372, 036, 854, 775, 808 is stored in a long long int data type and 1 is subtracted from it, the value in that variable will become equal to 9, 223, 372, 036, 854, 775, 807. Similarly, in the case of overflow, the value will round back to –9, 223, 372, 036, 854, 775, 808.\n\nBelow is the program to get the highest value that can be stored in long long int in C++:"
    },
    {
        "link": "https://geeksforgeeks.org/cpp-data-types",
        "document": "Data types specify the type of data that a variable can store. Whenever a variable is defined in C++, the compiler allocates some memory for that variable based on the data type with which it is declared as every data type requires a different amount of memory.\n\nC++ supports a wide variety of data types, and the programmer can select the data type appropriate to the needs of the application.\n\nExplanation: In the above code, we needed to store the value 10 in our program, so we created a variable var. But before var, we have used the keyword ‘int‘. This keyword is used to define that the variable var will store data of type integer.\n\nIn C++, different data types are classified into the following categories:\n\nLet’s see how to use some primitive data types in C++ program.\n\nThe character data type is used to store a single character. The keyword used to define a character is char. Its size is 1 byte, and it stores characters enclosed in single quotes (‘ ‘). It can generally store upto 256 characters according to their ASCII codes.\n\nInteger data type denotes that the given variable can store the integer numbers. The keyword used to define integers is int. Its size is 4-bytes (for 64-bit) systems and can store numbers for binary, octal, decimal and hexadecimal base systems in the range from -2,147,483,648 to 2,147,483,647.\n\nTo know more about different base values in C++, refer to the article – Literals in C++\n\nThe boolean data type is used to store logical values: true(1) or false(0). The keyword used to define a boolean variable is bool. Its size is 1 byte.\n\nFloating-point data type is used to store numbers with decimal points. The keyword used to define floating-point numbers is float. Its size is 4 bytes (on 64-bit systems) and can store values in the range from 1.2E-38 to 3.4e+38.\n\nThe double data type is used to store decimal numbers with higher precision. The keyword used to define double-precision floating-point numbers is double. Its size is 8 bytes (on 64-bit systems) and can store the values in the range from 1.7e-308 to 1.7e+308\n\nThe void data type represents the absence of value. We cannot create a variable of void type. It is used for pointer and functions that do not return any value using the keyword void.\n\nC++ is a strongly typed language. It means that all variables’ data type should be specified at the declaration, and it does not change throughout the program. Moreover, we can only assign the values that are of the same type as that of the variable.\n\nExample: If we try to assign floating point value to a boolean variable, it may result in data corruption, runtime errors, or undefined behaviour.\n\nAs we see, the floating-point value is not stored in the bool variable a. It just stores 1. This type checking is not only done for fundamental types, but for all data types to ensure valid operations and no data corruptions.\n\nType conversion refers to the process of changing one data type into another compatible one without losing its original meaning. It’s an important concept for handling different data types in C++.\n\nSize of Data Types in C++\n\nEarlier, we mentioned that the size of the data types is according to the 64-bit systems. Does it mean that the size of C++ data types is different for different computers?\n\nActually, it is partially true. The size of C++ data types can vary across different systems, depending on the architecture of the computer (e.g., 32-bit vs. 64-bit systems) and the compiler being used. But if the architecture of the computer is same, then the size across different computers remains same.\n\nWe can find the size of the data type using sizeof operator. According to this type, the range of values that a variable of given data types can store are decided.\n\nData type modifiers are the keywords used to change or give extra meaning to already existing data types. It is added to primitive data types as a prefix to modify their size or range of data they can store. There are 4 type modifiers in C++: short, long, signed and unsigned.\n\nFor Example, defining an int with long type modifier will change its size to 8 bytes:\n\nSimilarly, other type modifiers also affect the size or range of the data type.\n\nIs size of data types in C++ is different for different machines?\n\nCan I convert one data type value or variable to another?\n\nHow many data types are there in C++?\n\nWhy we need int if we can already represent integer values with float?"
    },
    {
        "link": "https://stackoverflow.com/questions/124332/c-handling-very-large-integers",
        "document": "I am using the RSA Algorithm for encryption/decryption, and in order to decrypt the files you have to deal with some pretty big values. More specifically, things like\n\nNow that is really the only calculations that ill be doing. I have tried using Matt McCutchen's BigInteger Library, but I am getting a lot of compiler errors during linking, such as:\n\nSo I was wondering what would be the best way to go about handling the really big integers that come out of the RSA Algorithm.\n\nI heard that a possibility would be to declare your variables as a double long, so...\n\nbut I'm not sure exactly how big of an integer that can store.\n\nWell for example, I try to compile and run the following program using dev C++:\n\nthen I get those errors.\n\nDerek, I thought that by including the file, that the compiler would go through and compile all the necessary files that it will use.\n\nHow should I try and compile the program above in order to resolve the linking errors?"
    },
    {
        "link": "https://quora.com/In-C++-how-do-you-handle-very-large-numbers",
        "document": "Something went wrong. Wait a moment and try again."
    },
    {
        "link": "https://stackoverflow.com/questions/310276/how-to-handle-arbitrarily-large-integers",
        "document": "If you're building unlimited size decimal math into a language (for learning purposes I'd guess) with today's gigantic memory space, you should just use a byte array where each byte just holds a digit (0-9). You then write your own routine to add, subtract multiply and divide your byte arrays.\n\nIf you're implementing it yourself, the algorithms you use could simply echo the way you'd do the math as a human. For addition just start at the right side and add each position to make a new digit and deal with the carry, etc.\n\nI can give you some Java-like psuedocode but can't really do C++ from scratch at this point:\n\nI use the fact that we have a lot of extra room in a byte to help deal with addition overflows in a generic way. Can work for subtraction too (your bytes can be signed so that [4][3] - [7] = [4][-4], and normalize that to [3][6].\n\nI don't deal with negative BigAssIntegers here, but you could store a sign flag in the class. You could also store a decimal point location, but at that point you're totally replicating BCD style libraries that would be much more performant."
    }
]