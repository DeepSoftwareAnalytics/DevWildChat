[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Regular_expressions/Capturing_group",
        "document": "A capturing group acts like the grouping operator in JavaScript expressions, allowing you to use a subpattern as a single atom.\n\nCapturing groups are numbered by the order of their opening parentheses. The first capturing group is numbered , the second , and so on. Named capturing groups are also capturing groups and are numbered together with other (unnamed) capturing groups. The information of the capturing group's match can be accessed through:\n• The return value (which is an array) of , , and\n• The parameters of the and methods' callback function\n• Backreferences within the same pattern\n\nCapturing groups in the regex source code correspond to their results one-to-one. If a capturing group is not matched (for example, it belongs to an unmatched alternative in a disjunction), the corresponding result is .\n\nCapturing groups can be quantified. In this case, the match information corresponding to this group is the last match of the group.\n\nCapturing groups can be used in lookahead and lookbehind assertions. Because lookbehind assertions match their atoms backwards, the final match corresponding to this group is the one that appears to the left end of the string. However, the indices of the match groups still correspond to their relative locations in the regex source.\n\nCapturing groups can be nested, in which case the outer group is numbered first, then the inner group, because they are ordered by their opening parentheses. If a nested group is repeated by a quantifier, then each time the group matches, the subgroups' results are all overwritten, sometimes with .\n\nIn the example above, the outer group is matched three times:\n\nThe result from the second match is not preserved, because the third match overwrites it with .\n\nYou can get the start and end indices of each capturing group in the input string by using the flag. This creates an extra property on the array returned by .\n\nYou can optionally specify a name to a capturing group, which helps avoid pitfalls related to group positions and indexing. See Named capturing groups for more information.\n\nParentheses have other purposes in different regex syntaxes. For example, they also enclose lookahead and lookbehind assertions. Because these syntaxes all start with , and is a quantifier which normally cannot occur directly after , this does not lead to ambiguities."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions/Groups_and_backreferences",
        "document": "Capturing group: Matches and remembers the match. For example, matches and remembers \"foo\" in \"foo bar\".\n\nA regular expression may have multiple capturing groups. In results, matches to capturing groups typically in an array whose members are in the same order as the left parentheses in the capturing group. This is usually just the order of the capturing groups themselves. This becomes important when capturing groups are nested. Matches are accessed using the index of the result's elements ( ) or from the predefined object's properties ( ).\n\nCapturing groups have a performance penalty. If you don't need the matched substring to be recalled, prefer non-capturing parentheses (see below).\n\nwon't return groups if the flag is set. However, you can still use to get all matches."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions",
        "document": "You construct a regular expression in one of two ways:\n• Using a regular expression literal, which consists of a pattern enclosed between slashes, as follows: Regular expression literals provide compilation of the regular expression when the script is loaded. If the regular expression remains constant, using this can improve performance.\n• Or calling the constructor function of the object, as follows: Using the constructor function provides runtime compilation of the regular expression. Use the constructor function when you know the regular expression pattern will be changing, or you don't know the pattern and are getting it from another source, such as user input.\n\nWhen the search for a match requires something more than a direct match, such as finding one or more b's, or finding white space, you can include special characters in the pattern. For example, to match a single followed by zero or more s followed by , you'd use the pattern : the after means \"0 or more occurrences of the preceding item.\" In the string , this pattern will match the substring . The following pages provide lists of the different special characters that fit into each category, along with descriptions and examples. Assertions include boundaries, which indicate the beginnings and endings of lines and words, and other patterns indicating in some way that a match is possible (including look-ahead, look-behind, and conditional expressions). Distinguish different types of characters. For example, distinguishing between letters and digits. Groups group multiple patterns as a whole, and capturing groups provide extra submatch information when using a regular expression pattern to match against a string. Backreferences refer to a previously captured group in the same regular expression. Indicate numbers of characters or expressions to match. If you want to look at all the special characters that can be used in regular expressions in a single table, see the following: Note: A larger cheat sheet is also available (only aggregating parts of those individual articles).\n\nIf you need to use any of the special characters literally (actually searching for a , for instance), you must escape it by putting a backslash in front of it. For instance, to search for followed by followed by , you'd use — the backslash \"escapes\" the , making it literal instead of special. Similarly, if you're writing a regular expression literal and need to match a slash (\"/\"), you need to escape that (otherwise, it terminates the pattern). For instance, to search for the string \"/example/\" followed by one or more alphabetic characters, you'd use —the backslashes before each slash make them literal. To match a literal backslash, you need to escape the backslash. For instance, to match the string \"C:\\\" where \"C\" can be any letter, you'd use — the first backslash escapes the one after it, so the expression searches for a single literal backslash. If using the constructor with a string literal, remember that the backslash is an escape in string literals, so to use it in the regular expression, you need to escape it at the string literal level. and create the same expression, which searches for \"a\" followed by a literal \"*\" followed by \"b\". The function returns a new string where all special characters in regex syntax are escaped. This allows you to do to create a regular expression that matches only the string .\n\nRegular expressions are used with the methods and and with the methods , , , , , and . Executes a search for a match in a string. It returns an array of information or on a mismatch. Tests for a match in a string. It returns or . Returns an array containing all of the matches, including capturing groups, or if no match is found. Returns an iterator containing all of the matches, including capturing groups. Tests for a match in a string. It returns the index of the match, or if the search fails. Executes a search for a match in a string, and replaces the matched substring with a replacement substring. Executes a search for all matches in a string, and replaces the matched substrings with a replacement substring. Uses a regular expression or a fixed string to break a string into an array of substrings. When you want to know whether a pattern is found in a string, use the or methods; for more information (but slower execution) use the or methods. If you use or and if the match succeeds, these methods return an array and update properties of the associated regular expression object and also of the predefined regular expression object, . If the match fails, the method returns (which coerces to ). In the following example, the script uses the method to find a match in a string. If you do not need to access the properties of the regular expression, an alternative way of creating is with this script: const myArray = /d(b+)d/g.exec(\"cdbbdbsbz\"); // similar to 'cdbbdbsbz'.match(/d(b+)d/g); however, // 'cdbbdbsbz'.match(/d(b+)d/g) outputs [ \"dbbd\" ] // while /d(b+)d/g.exec('cdbbdbsbz') outputs [ 'dbbd', 'bb', index: 1, input: 'cdbbdbsbz' ] If you want to construct the regular expression from a string, yet another alternative is this script: With these scripts, the match succeeds and returns the array and updates the properties shown in the following table. In this example The matched string and all remembered substrings. The 0-based index of the match in the input string. The index at which to start the next match. (This property is set only if the regular expression uses the g option, described in Advanced Searching With Flags.) The text of the pattern. Updated at the time that the regular expression is created, not executed. As shown in the second form of this example, you can use a regular expression created with an object initializer without assigning it to a variable. If you do, however, every occurrence is a new regular expression. For this reason, if you use this form without assigning it to a variable, you cannot subsequently access the properties of that regular expression. For example, assume you have this script: const myRe = /d(b+)d/g; const myArray = myRe.exec(\"cdbbdbsbz\"); console.log(`The value of lastIndex is ${myRe.lastIndex}`); // \"The value of lastIndex is 5\" However, if you have this script: const myArray = /d(b+)d/g.exec(\"cdbbdbsbz\"); console.log(`The value of lastIndex is ${/d(b+)d/g.lastIndex}`); // \"The value of lastIndex is 0\" The occurrences of in the two statements are different regular expression objects and hence have different values for their property. If you need to access the properties of a regular expression created with an object initializer, you should first assign it to a variable.\n\nRegular expressions have optional flags that allow for functionality like global searching and case-insensitive searching. These flags can be used separately or together in any order, and are included as part of the regular expression. Makes and match the start and end of each line instead of those of the entire string. An upgrade to the mode with more Unicode features. Perform a \"sticky\" search that matches starting at the current position in the target string. To include a flag with the regular expression, use this syntax: Note that the flags are an integral part of a regular expression. They cannot be added or removed later. For example, creates a regular expression that looks for one or more characters followed by a space, and it looks for this combination throughout the string. You could replace the line: The flag is used to specify that a multiline input string should be treated as multiple lines. If the flag is used, and match at the start or end of any line within the input string instead of the start or end of the entire string. The , , and flags can be enabled or disabled for specific parts of a regex using the modifier syntax. Using the global search flag with exec() method with the flag returns each match and its position iteratively. In contrast, method returns all matches at once, but without their position. The flag is used to create \"unicode\" regular expressions; that is, regular expressions which support matching against unicode text. An important feature that's enabled in unicode mode is Unicode property escapes. For example, the following regular expression might be used to match against an arbitrary unicode \"word\": Unicode regular expressions have different execution behavior as well. contains more explanation about this."
    },
    {
        "link": "https://stackoverflow.com/questions/432493/how-do-you-access-the-matched-groups-in-a-javascript-regular-expression",
        "document": "The issue was that console.log takes its parameters like a printf statement, and since the string I was logging ( \"%A\" ) had a special value, it was trying to find the value of the next parameter.\n\nReporting that \"%A\" is undefined seems a very strange behaviour, but it is not directly related to this question, so I've opened a new one, Why is a matched substring returning \"undefined\" in JavaScript? .\n\nI've discovered that there was nothing wrong with the regular expression code above: the actual string which I was testing against was this:\n\nI want to match a portion of a string using a regular expression and then access that parenthesized substring:\n\nThe old way to iterate over multiple matches was not very intuitive. This lead to the proposal of the method. This new method is in the ECMAScript 2020 specification. It gives us a clean API and solves multiple problems. It is in major browsers and JS engines since Chrome 73+ / Node 12+ and Firefox 67+. The method returns an iterator and is used as follows: const string = \"something format_abc\"; const regexp = /(?:^|\\s)format_(.*?)(?:\\s|$)/g; const matches = string.matchAll(regexp); for (const match of matches) { console.log(match); console.log(match.index) } As it returns an iterator, we can say it's lazy, this is useful when handling particularly large numbers of capturing groups, or very large strings. But if you need, the result can be easily transformed into an Array by using the spread syntax or the method: In the meantime, while this proposal gets more wide support, you can use the official shim package. Also, the internal workings of the method are simple. An equivalent implementation using a generator function would be as follows: function* matchAll(str, regexp) { const flags = regexp.global ? regexp.flags : regexp.flags + \"g\"; const re = new RegExp(regexp, flags); let match; while (match = re.exec(str)) { yield match; } } A copy of the original regexp is created; this is to avoid side-effects due to the mutation of the property when going through the multple matches. Also, we need to ensure the regexp has the global flag to avoid an infinite loop. I'm also happy to see that even this StackOverflow question was referenced in the discussions of the proposal. You can access capturing groups like this: And if there are multiple matches you can iterate over them: var myString = \"something format_abc\"; var myRegexp = new RegExp(\"(?:^|\\\\s)format_(.*?)(?:\\\\s|$)\", \"g\"); match = myRegexp.exec(myString); while (match != null) { // matched text: match[0] // match start: match.index // capturing group n: match[n] console.log(match[0]) match = myRegexp.exec(myString); }\n\nIn regards to the multi-match parentheses examples above, I was looking for an answer here after not getting what I wanted from: After looking at the slightly convoluted function calls with while and .push() above, it dawned on me that the problem can be solved very elegantly with mystring.replace() instead (the replacing is NOT the point, and isn't even done, the CLEAN, built-in recursive function call option for the second parameter is!): var yourstring = 'something format_abc something format_def something format_ghi'; var matches = []; yourstring.replace(/format_([^\\s]+)/igm, function(m, p1){ matches.push(p1); } ); After this, I don't think I'm ever going to use .match() for hardly anything ever again.\n\n(see the Stage 3 Draft / December 7, 2018 proposal), simplifies acccess to all groups in the match object (mind that Group 0 is the whole match, while further groups correspond to the capturing groups in the pattern): With available, you can avoid the loop and with ... Instead, by using , you get back an iterator which you can use with the more convenient , array spread, or constructs This method yields a similar output to in C#, in Python, in PHP. See a JS demo (tested in Google Chrome 73.0.3683.67 (official build), beta (64-bit)): You may also get match value or specific group values using let matchData = \"key1:value1, key2-value2!!@key3=value3\".matchAll(/(\\w+)[:=-](\\w+)/g) var matches = [...matchData]; // Note matchAll result is not re-iterable console.log(Array.from(matches, m => m[0])); // All match (Group 0) values // => [ \"key1:value1\", \"key2-value2\", \"key3=value3\" ] console.log(Array.from(matches, m => m[1])); // All match (Group 1) values // => [ \"key1\", \"key2\", \"key3\" ]\n\nTerminology used in this answer:\n• Match indicates the result of running your RegEx pattern against your string like so: .\n• Matched patterns indicate all matched portions of the input string, which all reside inside the match array. These are all instances of your pattern inside the input string.\n• Matched groups indicate all groups to catch, defined in the RegEx pattern. (The patterns inside parentheses, like so: , where would be a matched group.) These reside within matched patterns. To get access to the matched groups, in each of the matched patterns, you need a function or something similar to iterate over the match. There are a number of ways you can do this, as many of the other answers show. Most other answers use a while loop to iterate over all matched patterns, but I think we all know the potential dangers with that approach. It is necessary to match against a instead of just the pattern itself, which only got mentioned in a comment. This is because the method behaves similar to a generator function – it stops every time there is a match, but keeps its to continue from there on the next call. Below is an example of a function which returns an of all matched patterns, where each is an with all the containing matched groups. Instead of using a while loop, I have provided examples using both the function as well as a more performant way – using a plain -loop. These are less performant since they basically implement a -loop instead of the faster -loop. // Concise ES6/ES2015 syntax const searchString = (string, pattern) => string .match(new RegExp(pattern.source, pattern.flags)) .map(match => new RegExp(pattern.source, pattern.flags) .exec(match)); // Or if you will, with ES5 syntax function searchString(string, pattern) { return string .match(new RegExp(pattern.source, pattern.flags)) .map(match => new RegExp(pattern.source, pattern.flags) .exec(match)); } let string = \"something format_abc\", pattern = /(?:^|\\s)format_(.*?)(?:\\s|$)/; let result = searchString(string, pattern); // [[\" format_abc\", \"abc\"], null] // The trailing `null` disappears if you add the `global` flag // Performant ES6/ES2015 syntax const searchString = (string, pattern) => { let result = []; const matches = string.match(new RegExp(pattern.source, pattern.flags)); for (let i = 0; i < matches.length; i++) { result.push(new RegExp(pattern.source, pattern.flags).exec(matches[i])); } return result; }; // Same thing, but with ES5 syntax function searchString(string, pattern) { var result = []; var matches = string.match(new RegExp(pattern.source, pattern.flags)); for (var i = 0; i < matches.length; i++) { result.push(new RegExp(pattern.source, pattern.flags).exec(matches[i])); } return result; } let string = \"something format_abc\", pattern = /(?:^|\\s)format_(.*?)(?:\\s|$)/; let result = searchString(string, pattern); // [[\" format_abc\", \"abc\"], null] // The trailing `null` disappears if you add the `global` flag I have yet to compare these alternatives to the ones previously mentioned in the other answers, but I doubt this approach is less performant and less fail-safe than the others."
    },
    {
        "link": "https://javascript.info/regexp-groups",
        "document": "A part of a pattern can be enclosed in parentheses . This is called a “capturing group”.\n\nThat has two effects:\n• It allows to get a part of the match as a separate item in the result array.\n• If we put a quantifier after the parentheses, it applies to the parentheses as a whole.\n\nLet’s see how parentheses work in examples.\n\nWithout parentheses, the pattern means character, followed by repeated one or more times. For instance, or .\n\nParentheses group characters together, so means , , and so on.\n\nLet’s make something more complex – a regular expression to search for a website domain.\n\nAs we can see, a domain consists of repeated words, a dot after each one except the last one.\n\nThe search works, but the pattern can’t match a domain with a hyphen, e.g. , because the hyphen does not belong to class .\n\nWe can fix it by replacing with in every word except the last one: .\n\nThe previous example can be extended. We can create a regular expression for emails based on it.\n\nThe email format is: . Any word can be the name, hyphens and dots are allowed. In regular expressions that’s .\n\nThat regexp is not perfect, but mostly works and helps to fix accidental mistypes. The only truly reliable check for an email can only be done by sending a letter.\n\nParentheses are numbered from left to right. The search engine memorizes the content matched by each of them and allows to get it in the result.\n\nThe method , if has no flag , looks for the first match and returns it as an array:\n• At index : the contents of the first parentheses.\n• At index : the contents of the second parentheses.\n\nFor instance, we’d like to find HTML tags , and process them. It would be convenient to have tag content (what’s inside the angles), in a separate variable.\n\nLet’s wrap the inner content into parentheses, like this: .\n\nNow we’ll get both the tag as a whole and its contents in the resulting array:\n\nParentheses can be nested. In this case the numbering also goes from left to right.\n\nFor instance, when searching a tag in we may be interested in:\n• The tag content as a whole: .\n\nHere’s how they are numbered (left to right, by the opening paren):\n\nThe zero index of always holds the full match.\n\nThen groups, numbered from left to right by an opening paren. The first group is returned as . Here it encloses the whole tag content.\n\nThen in goes the group from the second opening paren – tag name, then in the tag: .\n\nThe contents of every group in the string:\n\nEven if a group is optional and doesn’t exist in the match (e.g. has the quantifier ), the corresponding array item is present and equals .\n\nFor instance, let’s consider the regexp . It looks for optionally followed by optionally followed by .\n\nIf we run it on the string with a single letter , then the result is:\n\nThe array has the length of , but all groups are empty.\n\nAnd here’s a more complex match for the string :\n\nThe array length is permanent: . But there’s nothing for the group , so the result is .\n\nSearching for all matches with groups: matchAll\n\nWhen we search for all matches (flag ), the method does not return contents for groups.\n\nFor example, let’s find all tags in a string:\n\nThe result is an array of matches, but without details about each of them. But in practice we usually need contents of capturing groups in the result.\n\nTo get them, we should search using the method .\n\nIt was added to JavaScript language long after , as its “new and improved version”.\n\nJust like , it looks for matches, but there are 3 differences:\n• It returns not an array, but an iterable object.\n• When the flag is present, it returns every match as an array with groups.\n• If there are no matches, it returns not , but an empty iterable object.\n\nAs we can see, the first difference is very important, as demonstrated in the line . We can’t get the match as , because that object is a pseudoarray. We can turn it into a real using . There are more details about pseudoarrays and iterables in the article Iterables.\n\nThere’s no need for if we’re looping over results:\n\nEvery match, returned by , has the same format as returned by without flag : it’s an array with additional properties (match index in the string) and (source string):\n\nRemembering groups by their numbers is hard. For simple patterns it’s doable, but for more complex ones counting parentheses is inconvenient. We have a much better option: give names to parentheses.\n\nThat’s done by putting immediately after the opening paren.\n\nFor example, let’s look for a date in the format “year-month-day”:\n\nAs you can see, the groups reside in the property of the match.\n\nTo look for all dates, we can add flag .\n\nWe’ll also need to obtain full matches, together with groups:\n\nMethod that replaces all matches with in allows to use parentheses contents in the string. That’s done using , where is the group number.\n\nFor named parentheses the reference will be .\n\nFor example, let’s reformat dates from “year-month-day” to “day.month.year”:\n\nSometimes we need parentheses to correctly apply a quantifier, but we don’t want their contents in results.\n\nA group may be excluded by adding in the beginning.\n\nFor instance, if we want to find , but don’t want the parentheses contents ( ) as a separate array item, we can write: .\n\nIn the example below we only get the name as a separate member of the match:\n\nParentheses group together a part of the regular expression, so that the quantifier applies to it as a whole.\n\nParentheses groups are numbered left-to-right, and can optionally be named with .\n\nThe content, matched by a group, can be obtained in the results:\n• The method returns capturing groups only without flag .\n\nIf the parentheses have no name, then their contents is available in the match array by its number. Named parentheses are also available in the property .\n\nWe can also use parentheses contents in the replacement string in : by the number or the name .\n\nA group may be excluded from numbering by adding in its start. That’s used when we need to apply a quantifier to the whole group, but don’t want it as a separate item in the results array. We also can’t reference such parentheses in the replacement string."
    },
    {
        "link": "https://stackoverflow.com/questions/1252194/regex-performance-optimization-tips-and-tricks",
        "document": "Use the any (dot) operator sparingly, if you can do it any other way, do it, dot will always bite you...\n\ni'm not sure whether PCRE is NFA and i'm only familiar with PCRE but + and * are usually greedy by default, they will match as much as possible to turn this around use +? and *? to match the least possible, bear these two clauses in mind while writing your regexp."
    },
    {
        "link": "https://reddit.com/r/javascript/comments/1fopldz/askjs_what_are_common_performance_optimizations",
        "document": "Example: \"RegExp.exec()\" should be preferred over \"String.match()\" because it offers better performance, especially when the regular expression does not include the global flag g."
    },
    {
        "link": "https://rexegg.com/regex-optimizations.php",
        "document": "The Best Regex Trick Ever!!!"
    },
    {
        "link": "https://medium.com/@scokmen/real-world-performance-pitfalls-1-javascript-regex-string-deburr-0f33ba634d71",
        "document": "The example I will show you is a part of a web application that lists products.\n\nA web application (actually, it was a backend-for-frontend gateway) fetches 48 products, maps them to the UI model, provides some SEO-related fields, and forwards them to the actual web application. Each product has approximately ten variants. To build HTML links, the web application needs SEO-friendly page URLs, which means the gateway has to create 480 URLs on the fly for each request.\n\nWe were provided URL rules, including character mapping and exceptional cases.\n• The digits, dashes, and characters within the range of A-Z must be retained.\n• Space characters must be replaced with a dash.\n• The remaining characters must be removed.\n• URL must not start or end with a dash.\n• URL must not include two or more consecutive dashes.\n• The result must be lowercase.\n\nThe code block consisted of 20 regular expressions, and one toLowerCase() call was added to convert the input to lowercase. This conversion is important and probably was added to reduce the number of required regular expressions. However, it introduced a hidden bug to the code and solved it unintentionally because toLowerCase() follows the default case mappings in Unicode, but some locales (e.g., Turkish) do not.\n\nWhy did the first test fail and the second one pass? It is because the lower of “İ” (U+0130) is not “i”; actually, it is “i̇” and it consists of two codepoints, one “i” (U+0069) and one special character (U+0307). The second test case passed because the regular expression removed that special character. We can easily observe that by changing the regular expression.\n\nLet us take a closer look at the performance of the proposed solution. I created a benchmark suite using the Benny package to analyze the performance. I examined the real data, calculated the percentage of each special character, and created test data based on them.\n\nThe proposed solution satisfies the requirements. However, what if we needed more character mappings? To evaluate sustainability, I ran another benchmark suite that requires 10, 20, 30, and 40 character mappings, respectively.\n\nI will not analyze these graphs because they are baseline metrics of the refactoring process.\n\nThe proposed code block consisted of 20 regular expressions. While it was possible to simplify the block by combining one or two expressions, it would not have significantly impacted performance. Actually, in this case, we do not need any regular expression because it requires just one-to-one mappings.\n\nIn the first iteration, only one loop and one look-up table are used. The algorithm checks for Rule#1 first since digits and valid characters are more frequent in the input set than special characters. If there is no match, it uses the look-up table to find a suitable replacement without violating Rule#5. I found the for…of loop more favorable compared to the classical for-index iteration because it recognizes multi-byte Unicode characters. Unfortunately, when using for…of loop, it is tough to keep track of the current cursor position (string length and character count are different for strings that include multi-byte characters), so I had to add another check for the ending dash character.\n\nAfter implementing iteration #1, I realized that I could use a classical for-index loop instead of a for…of loop because the range of multi-byte unicode characters is much higher than the input set, and I don’t need to worry about them. Additionally, I tried to optimize the code further by removing calls to str#slice() and using two flags to track dashes. In addition, I optimized the hashmap calls and changed the key type to a number.\n\nBy replacing the regex-per-character with a look-up table, the solution has become more efficient and sustainable.\n\nThe final solution may seem complicated and probably hard to understand. However, whether it is worth the effort depends on the situation. If the code is part of a system that is under high load or if the code does not require frequent modification, then I prefer to use the optimized approach.\n\nThese are my opinions, and all feedback is welcomed!"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Performance/JavaScript",
        "document": "It is very important to consider how you are using JavaScript on your websites and think about how to mitigate any performance issues that it might be causing. While images and video account for over 70% of the bytes downloaded for the average website, byte per byte, JavaScript has a greater potential for negative performance impact — it can significantly impact download times, rendering performance, and CPU and battery usage. This article introduces tips and techniques for optimizing JavaScript to enhance the performance of your website. To learn about the effects of JavaScript on web performance and how to mitigate or fix related issues.\n\nTo optimize or not to optimize The first question you should answer before starting to optimize your code is \"what do I need to optimize?\". Some of the tips and techniques discussed below are good practices that will benefit just about any web project, whereas some are only needed in certain situations. Trying to apply all these techniques everywhere is probably unnecessary, and may be a waste of your time. You should figure out what performance optimizations are actually needed in each project. To do this, you need to measure the performance of your site. As the previous link shows, there are several different ways to measure performance, some involving sophisticated performance APIs. The best way to get started however, is to learn how to use tools such as built-in browser network and performance tools, to see what parts of the page load are taking a long time and need optimizing.\n\nThe most performant, least blocking JavaScript you can use is JavaScript that you don't use at all. You should use as little JavaScript as possible. Some tips to bear in mind:\n• You don't always need a framework: You might be familiar with using a JavaScript framework. If you are experienced and confident with using this framework, and like all of the tooling it provides, then it might be your go-to tool for building most projects. However, frameworks are JavaScript-heavy. If you are creating a fairly static experience with few JavaScript requirements, you probably don't need that framework. You might be able to implement what you need using a few lines of standard JavaScript.\n• Consider a simpler solution: You might have a flashy, interesting solution to implement, but consider whether your users will appreciate it. Would they prefer something simpler?\n• Remove unused code: This may sound obvious, but it is surprising how many developers forget to clean up unused functionality that was added during the development process. You need to be careful and deliberate about what is added and removed. All script gets parsed, whether it is used or not; therefore, a quick win to speed up downloads would be to get rid of any functionality not being used. Consider also that often you will only use a small amount of the functionality available in a framework. Is it possible to create a custom build of the framework that only contains the part that you need?\n• Consider built-in browser features: It might be that you can use a feature the browser already has, rather than creating your own via JavaScript. For example:\n• Use the browser's own player.\n• Use CSS animations instead of a JavaScript animation library (see also Handling animations). You should also split your JavaScript into multiple files representing critical and non-critical parts. JavaScript modules allow you to do this more efficiently than just using separate external JavaScript files. Then you can optimize these smaller files. Minification reduces the number of characters in your file, thereby reducing the number of bytes or weight of your JavaScript. Gzipping compresses the file further and should be used even if you don't minify your code. Brotli is similar to Gzip, but generally outperforms Gzip compression. You can split and optimize your code manually, but often a module bundler like webpack will do a better job of this.\n\nBefore looking at the tips contained in this section, it is important to talk about where in the process of browser page rendering JavaScript is handled. When a web page is loaded:\n• The HTML is generally parsed first, in the order in which it appears on the page.\n• Whenever CSS is encountered, it is parsed to understand the styles that need to be applied to the page. During this time, linked assets such as images and web fonts start to be fetched.\n• Whenever JavaScript is encountered, the browser parses, evaluates, and runs it against the page.\n• Slightly later on, the browser works out how each HTML element should be styled, given the CSS applied to it.\n• The styled result is then painted to the screen. Note: This is a very simplified account of what happens, but it does give you an idea. The key step here is Step 3. By default, JavaScript parsing and execution are render-blocking. This means that the browser blocks the parsing of any HTML that appears after the JavaScript is encountered, until the script has been handled. As a result, styling and painting are blocked too. This means that you need to think carefully not only about what you are downloading, but also about when and how that code is being executed. The next few sections provide useful techniques for optimizing the parsing and execution of your JavaScript.\n\nLoading critical assets as soon as possible If a script is really important and you are concerned that it is affecting performance by not being loaded quickly enough, you can load it inside the of the document: This works OK, but is render-blocking. A better strategy is to use to create a preloader for critical JavaScript: The preload fetches the JavaScript as soon as possible, without blocking rendering. You can then use it wherever you want in your page: or inside your script, in the case of a JavaScript module: Note: Preloading does not guarantee that the script will be loaded by the time you include it, but it does mean that it will start being downloaded sooner. Render-blocking time will still be shortened, even if it is not completely removed.\n\nOn the other hand, you should aim to defer parsing and execution of non-critical JavaScript to later on, when it is needed. Loading it all up-front blocks rendering unnecessarily. First of all, you can add the attribute to your elements: This causes the script to be fetched in parallel with the DOM parsing, so it will be ready at the same time and won't block rendering. Note: There is another attribute, , which causes the script to be executed after the document has been parsed, but before firing the event. This has a similar effect to . You could also just not load the JavaScript at all until an event occurs when it is needed. This could be done via DOM scripting, for example: const scriptElem = document.createElement(\"script\"); scriptElem.src = \"index.js\"; scriptElem.addEventListener(\"load\", () => { // Run a function contained within index.js once it has definitely loaded init(); }); document.head.append(scriptElem); JavaScript modules can be dynamically loaded using the function: import(\"./modules/myModule.js\").then((module) => { // Do something with the module });\n\nWhen the browser runs your JavaScript, it will organize the script into tasks that are run sequentially, such as making fetch requests, driving user interactions and input through event handlers, running JavaScript-driven animation, and so on. Most of this happens on the main thread, with exceptions including JavaScript that runs in Web Workers. The main thread can run only one task at a time. When a single task takes longer than 50 ms to run, it is classified as a long task. If the user attempts to interact with the page or an important UI update is requested while a long task is running, their experience will be affected. An expected response or visual update will be delayed, resulting in the UI appearing sluggish or unresponsive. To mitigate this issue, you need to break down long tasks into smaller tasks. This gives the browser more chances to perform vital user interaction handling or UI rendering updates — the browser can potentially do them between each smaller task, rather than only before or after the long task. In your JavaScript, you might do this by breaking your code into separate functions. This also makes sense for several other reasons, such as easier maintenance, debugging, and writing tests. However, this kind of structure doesn't help with main thread blocking. Since all the five functions are being run inside one main function, the browser runs them all as a single long task. To handle this, we tend to run a \"yield\" function periodically to get the code to yield to the main thread. This means that our code is split into multiple tasks, between the execution of which the browser is given the opportunity to handle high-priority tasks such as updating the UI. A common pattern for this function uses to postpone execution into a separate task: This can be used inside a task runner pattern like so, to yield to the main thread after each task has been run: async function main() { // Create an array of functions to run const tasks = [a, b, c, d, e]; // Loop over the tasks while (tasks.length > 0) { // Shift the first task off the tasks array const task = tasks.shift(); // Run the task task(); // Yield to the main thread await yield(); } } To improve this further, we can use where available to allow this code to continue executing ahead of other less critical tasks in the queue: function yield() { // Use scheduler.yield() if available if (\"scheduler\" in window && \"yield\" in scheduler) { return scheduler.yield(); } // Fall back to setTimeout: return new Promise((resolve) => { setTimeout(resolve, 0); }); }\n\nAnimations can improve perceived performance, making interfaces feel snappier and making users feel like progress is being made when they are waiting for a page to load (loading spinners, for example). However, larger animations and a higher number of animations will naturally require more processing power to handle, which can degrade performance. The most obvious piece of animation advice is to use less animations — cut out any non-essential animations, or consider giving your users a preference they can set to turn off animations, for example if they are using a low-powered device or a mobile device with limited battery power. For essential DOM animations, you are advised to use CSS animations where possible, rather than JavaScript animations (the Web Animations API provides a way to directly hook into CSS animations using JavaScript). Using the browser to directly perform DOM animations rather than manipulating inline styles using JavaScript is much faster and more efficient. See also CSS performance optimization > Handling animations. For animations that can't be handled in JavaScript, for example, animating an HTML , you are advised to use rather than older options such as . The method is specially designed for handling animation frames efficiently and consistently, for a smooth user experience. The basic pattern looks like this: function loop() { // Clear the canvas before drawing the next frame of the animation ctx.fillStyle = \"rgb(0 0 0 / 25%)\"; ctx.fillRect(0, 0, width, height); // Draw objects on the canvas and update their positioning data // ready for the next frame for (const ball of balls) { ball.draw(); ball.update(); } // Call requestAnimationFrame to run the loop() function again // at the right time to keep the animation smooth requestAnimationFrame(loop); } // Call the loop() function once to set the animation running loop(); You can find a nice introduction to canvas animations at Drawing graphics > Animations, and a more in-depth example at Object building practice. You can also find a full set of canvas tutorials at Canvas tutorial.\n\nEvents can be expensive for the browser to track and handle, especially when you are running an event continuously. For example, you might be tracking the position of the mouse using the event to check whether it is still inside a certain area of the page: function handleMouseMove() { // Do stuff while mouse pointer is inside elem } elem.addEventListener(\"mousemove\", handleMouseMove); You might be running a game in your page. While the mouse is inside the canvas, you will want to constantly check for mouse movement and cursor position and update the game state — including the score, the time, the position of all the sprites, collision detection information, etc. Once the game is over, you will no longer need to do all that, and in fact, it will be a waste of processing power to keeping listening for that event. It is, therefore, a good idea to remove event listeners that are no longer needed. This can be done using : Another tip is to use event delegation wherever possible. When you have some code to run in response to a user interacting with any one of a large number of child elements, you can set an event listener on their parent. Events fired on any child element will bubble up to their parent, so you don't need to set the event listener on each child individually. Less event listeners to keep track of means better performance. See Event delegation for more details and a useful example.\n\nThere are several general best practices that will make your code run more efficiently.\n• Reduce DOM manipulation: Accessing and updating the DOM is computationally expensive, so you should minimize the amount that your JavaScript does, especially when performing constant DOM animation (see Handling JavaScript animations above).\n• Batch DOM changes: For essential DOM changes, you should batch them into groups that get done together, rather than just firing off each individual change as it occurs. This can reduce the amount of work the browser is doing in real terms, but also improve perceived performance. It can make the UI look smoother to get several updates out of the way in one go, rather than constantly making small updates. A useful tip here is — when you have a large chunk of HTML to add to the page, build the entire fragment first (typically inside a ) and then append it all to the DOM in one go, rather than appending each item separately.\n• Simplify your HTML: The simpler your DOM tree is, the faster it can be accessed and manipulated with JavaScript. Think carefully about what your UI needs, and remove unnecessary cruft.\n• Reduce the amount of looped code: Loops are expensive, so reduce the amount of loop usage in your code wherever possible. In cases where loops are unavoidable:\n• Avoid running the full loop when it is unnecessary, using or statements as appropriate. For example, if you are searching arrays for a specific name, you should break out of the loop once the name is found; there is no need to run further loop iterations: function processGroup(array) { const toFind = \"Bob\"; for (let i = 0; i < array.length - 1; i++) { if (array[i] === toFind) { processMatchingArray(array); break; } } }\n• Do work that is only needed once outside the loop. This may sound a bit obvious, but it is easy to overlook. Take the following snippet, which fetches a JSON object containing data to be processed in some way. In this case the operation is being done on every iteration of the loop, which is a waste of computing power. The fetching, which does not depend on , could be moved outside the loop, so it is only done once.\n• Run computation off the main thread: Earlier on we talked about how JavaScript generally runs tasks on the main thread, and how long operations can block the main thread, potentially leading to bad UI performance. We also showed how to break long tasks up into smaller tasks, mitigating this problem. Another way to handle such problems is to move tasks off the main thread altogether. There are a few ways to achieve this:\n• Use asynchronous code: Asynchronous JavaScript is basically JavaScript that does not block the main thread. Asynchronous APIs tend to handle operations such as fetching resources from the network, accessing a file on the local file system, or opening a stream to a user's web cam. Because those operations could take a long time, it would be bad to just block the main thread while we wait for them to complete. Instead, the browser executes those functions, keeps the main thread running subsequent code, and those functions will return results once they are available at some point in the future. Modern asynchronous APIs are -based, which is a JavaScript language feature designed for handling asynchronous operations. It is possible to write your own Promise-based functions if you have functionality that would benefit from being run asynchronously.\n• Run computation in web workers: Web Workers are a mechanism allowing you to open a separate thread to run a chunk of JavaScript in, so that it won't block the main thread. Workers do have some major restrictions, the biggest being that you can't do any DOM scripting inside a worker. You can do most other things, and workers can send and receive messages to and from the main thread. The main use case for workers is if you have a lot of computation to do, and you don't want it to block the main thread. Do that computation in a worker, wait for the result, and send it back to the main thread when it is ready.\n• Use WebGPU: WebGPU is a browser API that allows web developers to use the underlying system's GPU (Graphics Processing Unit) to carry out high-performance computations and draw complex images that can be rendered in the browser. It is fairly complex, but it can provide even better performance benefits than web workers."
    }
]