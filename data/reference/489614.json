[
    {
        "link": "https://stackoverflow.com/questions/3287518/reliable-and-fast-fft-in-java",
        "document": "I wrote a function for the FFT in Java.\n\nI've released it in the Public Domain so you can use those functions everywhere (for personal or business projects too). Just cite me in the credits and send me a link to your work, and you're okay.\n\nIt is completely reliable. I've checked its output against Mathematica's FFT and they were always correct until the 15th decimal digit. I think it's an excellent FFT implementation for Java. I wrote it on the J2SE 1.6 version and tested it on the J2SE 1.5-1.6 version.\n\nIf you count the number of instructions (it's a lot much simpler than a perfect computational complexity function estimation) you can clearly see that this version is great even if it's not optimized at all. I'm planning to publish the optimized version if there are enough requests.\n\nLet me know if it was helpful, and tell me any comments you like.\n\nI share the same code right here:\n\nEDIT: 5th of May, 2022. Well... after more than 10 years I'm publishing the code on GitHub to avoid losing it: https://github.com/hedoluna/fft Feel free to contribute and send me your opinions :) Thanks!"
    },
    {
        "link": "https://github.com/tambapps/fourier-transform-library",
        "document": "This is a library for computing 1-2 dimensional Fourier Transform. It was written with Java 8, and should be Android-compatible (you can use it in an Android project). This library was written without any compile dependencies.\n\nYou can import it with maven.\n\nIf you are more familiar with the old implementation (version 1.0), consult the legacy branch\n\nHere is an example of a 1D fast fourier transform. There are several algorithms to perform FFT You can see all of them on the FastFouriers class.\n\nYou can also use a which encapsulates a real and imaginary double arrays.\n\nThis is a trivial implementation of a Fourier Transform using the basic Fourier Transform formula\n\nA recursive implementation of the Cooley–Tukey FFT algorithm. Note that this algorithm requires the input length to be a power of 2.\n\nAn iterative implementation of the Cooley–Tukey FFT algorithm Note that this algorithm requires the input length to be a power of 2.\n\nYou can apply 2D FFT with a FastFourierTransformer2D. You can change the algorithm used by the transformer to compute fft by setting the AlgorithmChooser.\n\nYou can consult the fft-image-processing repo, an app that transforms images using FFT"
    },
    {
        "link": "https://algs4.cs.princeton.edu/99scientific/FFT.java.html",
        "document": "Below is the syntax highlighted version of FFT.java from §9.9 Scientific Computing."
    },
    {
        "link": "https://nitrc.org/projects/fft",
        "document": "LONI Software License, Version 2, © 2007 Terms and Conditions of Use: By registering for downloads from the UCLA Laboratory of Neuro Imaging, you are agreeing to the following terms and conditions as well as to the Terms of Use of the LONI website. View the LONI website’s Terms of Use (http://www.loni.ucla.edu/Common/TermsOfUse.pdf). 1. Permission is granted to use this software without charge for non-commercial research purposes only. 2. Other than the rights granted herein, LONI retains all rights, title, and interest in Technology, and You retain all rights, title, and interest in Your Modifications and associated specifications, subject to the terms of this License. 3. You may make verbatim copies of this software for personal use, or for use within your organization, provided that you duplicate all of the original copyright notices and associated disclaimers. If you provide the use of the software to other users within your organization, they also must comply with all the terms of this Software Distribution Agreement. 4. YOU MAY NOT DISTRIBUTE COPIES of this software, or copies of software derived from this software, to others outside your organization without specific prior written permission from the UCLA Laboratory of Neuro Imaging, except where noted for specific software products. 5. You must not remove or alter any copyright or other proprietary notices in the software. Software has not been reviewed or approved by the Food and Drug Administration, and is for non-clinical, IRB-approved Research Use Only. In no event shall data or images generated through the use of the Software be used in the provision of patient care. 6. THE SOFTWARE IS PROVIDED \"AS IS,\" AND THE UNIVERSITY OF CALIFORNIA AND ITS COLLABORATORS DO NOT MAKE ANY WARRANTY, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, NOR DO THEY ASSUME ANY LIABILITY OR RESPONSIBILITY FOR THE USE OF THIS SOFTWARE. 7. This software is for research purposes only and has not been approved for clinical use. 8. You may publish papers and books using results produced using software provided by this site provided that you reference the appropriate citations. A list of citations is available at http://www.loni.ucla.edu/Common/Funding.jsp. 9. You agree to comply with LONI's Trademark Usage Requirements, as modified from time to time, described in the “Use of Materials Limitations” section of the LONI Terms of Use Agreement. Except as expressly provided in this License, you are granted no rights in or to any LONI trademarks now or hereafter used or licensed by LONI. 10. All Technology and technical data delivered under this Agreement are subject to US export control laws and may be subject to export or import regulations in other countries. You agree to comply strictly with all such laws and regulations and acknowledge that you have the responsibility to obtain such licenses to export, re-export, or import as may be required after delivery to you."
    },
    {
        "link": "https://hipparchus.org/hipparchus-fft/jacoco/org.hipparchus.transform/FastFourierTransformer.java.html",
        "document": ""
    },
    {
        "link": "https://baeldung.com/java-complex-numbers",
        "document": "In this tutorial, we’ll examine arithmetic operations on complex numbers. Specifically, we’ll explore how to perform addition, subtraction, multiplication, and division of two complex numbers in Java.\n\nComplex numbers are expressed using a combination of real and imaginary parts. They are generally denoted as a+bi, where a and b are real numbers and i represents the imaginary unit equivalent to the square root of -1. In formal mathematical notation, a is the real part of the complex number, and the term bi is the imaginary component. Complex numbers, although initially confusing for newcomers, play a crucial role in various practical applications, such as physics and mathematics, including fields like quantum mechanics, signal processing, and economics.\n\nLike real numbers, we can perform arithmetic operations such as addition, subtraction, multiplication, and division. Performing arithmetic operations on complex numbers introduces complexities due to the combination of real and imaginary parts. However, specific formulas exist for each of these operations, which streamline them and ensure accurate results.\n\nWe can set up the required foundational code before implementing the arithmetic operations on complex numbers. Let’s start with defining a class for representing complex numbers:\n\nThe above class defines the real and imaginary parts of a complex number. We utilized the record keyword to define the class to represent the complex number. Moreover, we defined the toString() method to return the complex number in the typical format of a+bi.\n\nAdditionally, the fromString() method is overridden to parse a string representation of a complex number into the ComplexNumber record. We utilized regular expression groups to extract the real and imaginary parts from the string.\n\nIn the subsequent sections, we can enhance this record by adding methods to perform various arithmetic operations.\n\nNow that the basic setup is ready, let’s implement the method for adding two complex numbers. Complex number addition involves adding the real and imaginary parts of two numbers separately to obtain the resultant number. To provide a clearer understanding, let’s establish the addition formula. Let’s look at the formula for addition of two complex numbers:\n\nLet’s translate this formula into Java code and incorporate it into the ComplexNumber record:\n\nWe can directly access the real and imaginary components from the record and combine them with the given complex number within the method.\n\nSubtracting two complex numbers involves subtracting their real and imaginary parts separately. When subtracting complex numbers a+bi and c+di, we subtract the real parts (a and c) and the imaginary parts (b and d) separately, resulting in a new complex number with the real part as the difference of the original real parts and the imaginary part as the difference of the original imaginary parts. Here is the formula for the subtraction operation:\n\nLet’s implement the method for subtraction in Java:\n\nThis implements the subtraction using the formula (a-c)+(b-d)i.\n\nUnlike addition and subtraction, multiplication of two complex numbers is not so straightforward. Let’s look at the formula for the multiplication:\n\nWe can translate this formula into Java code and add the method to multiply two complex numbers:\n\nThe above method implements the algorithm for the complex number multiplication.\n\nDivision of two complex numbers is even more complicated than multiplication. It involves a more complex formula:\n\nThe above method effectively divides two complex numbers. It incorporates error handling to prevent division by zero and provides a clear error message in such cases.\n\nNow that we have implemented the arithmetic operations on two complex numbers, let’s write test cases for each method. Complex numbers can have various forms, including those with only a real part, only an imaginary part, or both. To guarantee a robust implementation, we must thoroughly test our implementations across all these scenarios. For comprehensive coverage, we can utilize the parameterized tests from JUnit to test different inputs.\n\nTo maintain conciseness within this article, we will focus on a single test case demonstrating complex number division:\n\nIn the above implementation, we created a comprehensive test suite using @CsvSource to cover many complex number divisions. A custom utility method, isSame(), is implemented to compare the test results effectively. Similarly, we can implement the tests for other arithmetic operations with the same test parameters.\n\nAdditionally, we can also write an individual test to verify the divide-by-zero scenario:\n\nHere, we create a complex number where the real and imaginary parts are zero and then attempt to divide by it. Using assertThrows(), the test ensures an exception is thrown with the expected error message.\n\nIn this article, we implemented arithmetic operations on two complex numbers in Java. We explored addition, subtraction, multiplication, and division of complex numbers, implementing robust functionality through extensive test coverage. This includes utilizing parameterized tests to ensure the code functions correctly across various input values.\n\nAs always, the sample code used in this article is available over on GitHub."
    },
    {
        "link": "https://geeksforgeeks.org/java-program-to-add-two-complex-numbers",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/10098958/java-complex-numbers-3-classes",
        "document": "Though this already been answered I thought people may benefit by the following class which does a lot of functions related to Complex Numbers.\n\nThis has been released under MIT License and the GitHub project is here."
    },
    {
        "link": "https://docs.vultr.com/java/examples/add-two-complex-numbers-by-passing-class-to-a-function",
        "document": "Java Program to Add Two Complex Numbers by Passing Class to a Function\n\nComplex numbers are a fundamental concept in mathematics and programming that have applications in various fields such as engineering, physics, and even computer science. In programming, handling complex numbers involves understanding classes and methods specific to object-oriented programming. Java provides a robust platform to manage such types of data through class and object manipulations.\n\nIn this article, you will learn how to create a simple Java program to add two complex numbers. By passing instances of a class to a function, you can encapsulate behaviors related to complex numbers, thus enhancing code modularity and clarity.\n• None Include two private instance variables to store the real and imaginary parts of the complex numbers.\n• None Implement a method within the class to handle the addition of complex numbers. This class defines a complex number with methods to construct and add complex numbers. When is called, it returns a new instance representing the sum.\n• None Create two instances representing the complex numbers you wish to add.\n• None Use the method to compute the sum of these numbers.\n• Here, two complex numbers, and , are added together. The resulting object, , holds the computed sum, which is printed to the console.\n• None Implement the method in the class to format the complex number as a string.\n• None Modify the class to use the method for displaying the complex number in a clear format. Adding the method improves how complex numbers are displayed, making results like more readable to users.\n\nMaster the basics of handling complex numbers in Java by defining a class and methods that encapsulate specific behaviors, such as addition. The program example provided uses object-oriented principles to add two complex numbers by passing class instances to a function. This approach ensures that the operations related to complex number arithmetic are neatly packaged in modular, reusable components. Experiment further by adding methods for other arithmetic operations like subtraction, multiplication, and division to enhance the class's functionality."
    },
    {
        "link": "https://stackoverflow.com/questions/40017024/how-to-work-with-complex-numbers-in-java",
        "document": "Unfortunately, it doesn't work like in C++ with the copy constructors or overloaded assignment operators.\n\nYou'll have to explicitly call the constructor for your complex, like in\n\nOf course, you'll need use methods of the complex to multiply two numbers, because there's no notion of any other operator overload in Java.\n\nSo, perhaps the class might have some method which you might be able to use instead of the operators, like"
    }
]