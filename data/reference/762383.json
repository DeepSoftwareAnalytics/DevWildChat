[
    {
        "link": "https://developer.android.com/privacy-and-security/safetynet/deprecation-timeline",
        "document": "Google recently announced the Play Integrity API that consolidates multiple integrity offerings (including the SafetyNet Attestation integrity verdict) under a single API.\n\nWe plan to gradually turn down the SafetyNet Attestation API starting in January 2024. We have extended the timeline to give you enough time to migrate to the new Play Integrity API and avoid disruptions to your business.\n\nThe Play Integrity API includes all the integrity signals that SafetyNet Attestation offers and more, like Google Play user license and better error messaging. The new API is designed in a future-forward way so that you can easily get new features with little build time required to upgrade.\n\nSetting up your app to use the Play Integrity API\n\nWe recommend that you migrate to the Play Integrity API during the first year of the deprecation timeline to avoid any disruptions in detecting risky interactions with your app and fighting abuse.\n\nThe two APIs are conceptually similar, so if you’ve already defined your anti-abuse strategy and you’re already using SafetyNet Attestation, the migration is straightforward. You can follow the migration guide and start to set up the Play Integrity API via your Play Console now.\n\nIf you are not distributing your app through Google Play, you can still use the Play Integrity API from the Google Cloud Console without creating a Play developer account or publishing a release in Google Play Console by following these steps.\n\nThe SafetyNet Attestation team added a new field to the SafetyNet Attestation response. The field contains information about the deprecation to make developers aware to migrate to the new Play Integrity API. It also contains information about the migration status of your app. For apps that have migrated, it will say \"The app is allowlisted to use the SafetyNet Attestation API until the full turndown\".\n\nThe full turndown of the SafetyNet Attestation API will happen gradually starting January 31, 2025. The task returned by the attest API will always invoke the on failure listener with an ApiException. The value of the status code will be 7 (NETWORK_ERROR). Developers who have released app versions that use the Play Integrity API should instruct users to update their app.\n\nGetting help and sharing feedback\n\nWe are here to ensure you have a smooth migration. If you have any issues or questions, please visit the Play Console Help Center.\n\nWe also want to hear your thoughts about building better integrity services, so please share feature requests and feedback in your Play Console. To do this, click the question icon at the upper right corner of Play Console then click “Send feedback” in the drop down menu.\n\nIf you have not yet migrated to Play Integrity API or removed SafetyNet Attestation by the migration deadline (January 31, 2024), you can complete this form to request an extension. If approved for an extension, your app will continue receiving responses from SafetyNet Attestation until the full turndown deadline (January 31, 2025)."
    },
    {
        "link": "https://developer.android.com/privacy-and-security/safetynet",
        "document": "Save and categorize content based on your preferences.\n\nStay organized with collections Save and categorize content based on your preferences.\n\nSafetyNet provides a set of services and APIs that help protect your app against security threats, including device tampering, bad URLs, potentially harmful apps, and fake users.\n\nTo prepare your app, first make sure that your app's build file uses the following values:\n\nThen complete the steps in the following sections.\n\nIn your file, include Google's Maven repository and Maven central repository in both your and repository sections:\n\nAdd the Google Play services dependency for the Google Play API to your module's Gradle build file, which is commonly :"
    },
    {
        "link": "https://github.com/googlesamples/android-play-safetynet",
        "document": "SafetyNet Attestation is now deprecated. New and existing developers should use the Play Integrity API instead.\n\nThis repository will remain for reference, but will not receive any updates in the future.\n\nThese samples demonstrate the end-to-end use of the SafetyNet API. SafetyNet provides services for analyzing the configuration of a particular device to verify that it passes the Android compatibility test.\n\nThis repository consists of one client and two server components:\n• client/java: Android sample app in Java, showing the use of Google Play Services for the SafetyNet API on a device.\n• server/java: Two samples, showing how to verify a SafetyNet API response on a server in Java, including offline and online via the Android Device Verification API.\n• server/csharp: Two samples, showing how to verify a SafetyNet API response on a server in C#, including offline and online via the Android Device Verification API.\n\nFor more details, see the documentation for each and component and the guide at https://developer.android.com/training/safetynet/index.html .\n• Build and run the Android component of this sample from the client/java directory.\n• Retrieve a signed statement from the Android app and copy it to your machine. (You can use the \"Share Result\" option.)\n• Build the java server component or C# server component.\n• Run the or checks and provide the signed statement from the app as input.\n\nIf you've found an error in this sample, please file an issue: https://github.com/googlesamples/android-play-safetynet\n\nPatches are encouraged, and may be submitted by forking this project and submitting a pull request through GitHub. Please see CONTRIBUTING.md for more details.\n\nLicensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License."
    },
    {
        "link": "https://wmartins.github.io/2020/01/how-to-implement-safetynet-attestation-in-your-application",
        "document": "How to Implement SafetyNet Attestation in Your Application\n\nThis post is just a collection of information about how to implement SafetyNet Attestation API in your application.\n\nThis whole thing started weeks ago after my team was researching a way to block suspicious requests that were occurring in our authentication API. There were lots of different users trying to log in, from different IP addresses/ranges. We already had a WAF set up, however, in this scenario, this was not effective. We think that there had been a data breach with lots of users and passwords, therefore, attackers were using these information to try a lucky guess in our API, almost like a brute-force attack.\n\nOur first attempt was to use reCAPTCHA as our mechanism to block those requests. However, we've found that user experience using this mechanism was really bad, as reCAPTCHA is an intrusive approach (even though it has an invisible option). After some research, we decided to give a try to use SafetyNet Attestation API.\n\nIn our scenario, the problem we were trying to solve was to separate malicious attacks from real login attempts from our clients. In other words, we wanted to know if a login attempt was occurring from an automation script or from a real device.\n\nTherefore, when we know we have a real device, we allow the user to log in, otherwise, we just block the request.\n\nI'll not get into lots of details about the device implementation, however, it's pretty straightforward: https://developer.android.com/training/safetynet/attestation#request-attestation-step.\n\nFirst and foremost, you need to have in mind that the token verification is up to you. There are some tutorials and even a code in google samples that verifies the token for you using an online API. However, this should not be your production approach.\n\nIn order to verify the token, we must first understand what this token represents. The token is a JWS token. If you want, you'll be able to parse this token using simple tools. For example, one may use https://jwt.io/ debugger to get the token information, or use any standard implementation.\n\nA valid SafetyNet token will have a header that looks like this:\n\nAnd it will have a payload that looks like this:\n\nIf you want, you can have the payload representation as follows (in Go):\n\nNow you're wondering what you should do with that information. And you're not alone. There are many pieces of information and you must decide what to use.\n\nOne thing that is really important to be done is to verify if the token is valid. You can do that using standard tools. If you search for terms like jws and jose you might find some tools for your preferred language. If you're using Go, you can use . Here goes an example on how to check the validity of a JWS token:\n\nAfter that, you need to check if that message was signed by Google itself. If you saw before, we have a property on the header. This information says two things: first, who signed the JWS token itself. Second, who signed the certificate that signed the JWS token. In other words, it's a certificate chain.\n\nThere are lots of solutions for validating a certificate chain. If you're using Go and , it's pretty straightforward to do that:\n\nNow that you know that the message is really sent by Google, the next step is to get its payload. The payload can be used to check device integrity (for example, to check if the phone is not rooted). Here is an example on how to do that:\n\nNow, it's up to you to do whatever you want. I recommend to check if all the fields match the values you expect. Some ideas:\n• Verify if matches the fingerprint of the certificate that was used to sign the app (only your team should have the private key to do that)\n• Verify if matches the package that should call the Attestation API\n• Verify the value from and\n• Verify if the provided timestamp is in a specific range/time limit (for example, consider it expired if generated 10 minutes ago)\n• I couldn't find a practical case for using the , however, you can use it to match if the information given by the client is what you expected. This, combined with some cryptography strategy, makes it even harder for an attacker to \"guess\" the nonce"
    },
    {
        "link": "https://nowsecure.com/blog/2017/08/03/android-apps-google-safetynet-attestation-api",
        "document": "At NowSecure Ioannis spends his days researching mobile security threats with a focus on the Android operating system. Ioannis holds a Ph.D. in Computer Science and a Bachelor of Science in Informatics. Publications Ioannis has contributed to include Detecting Android Root Exploits by Learning from Root Providers , Programming Flows in Dense Mobile Environments: A Multi-user Diversity Perspective , Resource Thrifty Secure Mobile Video Transfers on Open WiFi Networks , and Efficient Real-time Information Delivery in Future Internet Publish-Subscribe Networks .\n\nGoogle SafetyNet helps Android developers add a layer of security to their apps to protect their apps and users from a number of potential security threats including rooted/modified devices, known malicious URLs, malware, and malicious traffic. Recently Google has tried to encourage more developers to use the SafetyNet Attestation API, which allows an app to check whether it’s running on a known, standard build of Android (and not a modified, rooted, or potentially compromised device). We recently conducted a study of 3,000 apps published on the Google Play™ store to see whether its use has caught on with developers. We found that barely a smattering of the more popular Android apps have taken advantage of the APIs, and of those apps that have, not all of them have implemented the attestation API correctly.\n\nWhat’s the problem with rooted Android devices anyway?\n\nRooting an Android device grants a user privileges above and beyond the norm (i.e., “root access”) to the installed Android OS. With root access, a user can modify the OS or install software the device manufacturer doesn’t allow. Rooting a device does not necessarily make it less secure, but many enterprises disallow it and rooting can create an adverse security environment for a mobile app.\n\nThe rooting process sidesteps certain security features built into standard Android builds (e.g., isolating apps from one another). In addition, rooting a device makes the user an administrator on the device. This combination of diminished security defenses and escalated privileges allows malware to wreak more havoc and steal more sensitive data such as credentials, contacts, confidential communications, and more.\n\nIn its security guidelines for developers of mobile payment acceptance apps, the PCI Security Standards Council recommends implementing controls that prevent root privileges on the device because “bypassing permissions can allow untrusted security decisions to be made, thus increasing the number of possible attack vectors.”\n\nGuidance from the Federal Financial Institutions Examination Council (FFEIC) about mobile financial services and security recommends that financial institutions educate users on the risks of using a jailbroken/rooted device and carefully consider whether a rooted/jailbroken mobile device will be allowed to access their mobile services.\n\nHow does the Google SafetyNet Attestation API make Android Apps more secure?\n\nAs part of Google Play Services, SafetyNet helps a developer assess the health and safety of the devices upon which their app is installed. If an app uses the Attestation API check, for example, it won’t run on a rooted device or on a device that uses a modified OS. Google created the SafetyNet Attestation API to protect users from malware that monitors, or “spies on” mobile banking apps or payment apps such as Android Pay.\n\nIn 2016, a strain of Android malware called CopyCat infected 14 million devices and rooted approximately 8 million of them. Users don’t always know that their device has been compromised, and a rooted/modified OS can be a symptom of an infection. Malware with root access may also reside on a compromised device and attempt to steal sensitive files from the app or record keystrokes to steal a user’s banking credentials or other sensitive data. The SafetyNet Attestation API can prevent an app from running on a compromised device and potentially spilling sensitive user data.\n\nUsing the attestation API is a great way to make sensitive apps as secure as possible. On the other hand, people that use a modified version of Android won’t be able to use apps that implement the check. In May, Netflix stopped allowing the download of their mobile app to rooted devices to prevent the circumvention of digital rights management systems and protect against piracy. It was reported in January 2016 that 5 percent of Android devices are rooted.\n\nSafetyNet consists of four different APIs:\n• SafetyNet Attestation API – Profiles the device the app is attempting to run on, compares it to known device profiles, and identifies whether the profiled device may be rooted/modified or potentially compromised. With the API implemented, a mobile banking app can shut down if it’s running on a non-standard phone and protect a user against malware that might abuse root access. For an in-depth review of how the attestation API works, check out John Kozyrakis’s “Inside SafetyNet” blog series.\n• SafetyNet Safe Browsing API: Examines a given URL within a mobile app, compares it to a list of URLs known by Google to be malicious, and presents a warning or blocks the website if it’s potentially a threat.\n• SafetyNet reCAPTCHA API: Based on information from a Google risk analysis engine, an app verifies whether a person is interacting with the app. If it’s suspected that an automated script is interacting with the app, the app can shut itself down (e.g., to protect against brute-force attacks).\n• SafetyNet Verify Apps API: Checks the device to determine whether any known potentially harmful apps are installed on the device. This can help prevent malware on a device from eavesdropping on a user’s interaction with a banking app with the objective of stealing credentials or other sensitive information.\n\nOut with it, already: What percentage of popular Android apps use the Google SafetyNet Attestation API?\n\nTo survey how many popular apps on the Google Play store currently take advantage of Google SafetyNet, we downloaded 3,000 apps in a variety of genres and analyzed them to identify which apps made calls to any of the four SafetyNet APIs.\n• The top 600 apps overall on the Google Play store\n• 1,200 of the top apps in other genres\n\nA surprisingly small number of apps in the sample, only 23 or 0.77 percent, used SafetyNet. Google SafetyNet is a great feature to help developers include an additional layer of security in their apps and make users more secure. It’s good to see developers trying to do the right thing, however, our research shows that not all developers are implementing this security feature correctly.\n\nOne app in particular failed to follow Google’s instruction to “make sure that the compatibility check response actually came from the SafetyNet service and includes data that matches your request data.” In this app, the attestation check only occurred locally, which puts the trust in the client — a bad security model (see “Client-Side Enforcement of Server-Side Security” entry in the Common Weakness Enumeration list). SafetyNet Attestation API documentation also states, “We don’t recommend that you perform the verification directly in your app because, in that case, there is no guarantee that the verification logic itself hasn’t been modified.”\n• Four other apps in the sample incorporated a popular software development kit (SDK). That SDK uses two different implementations of the attestation API. The apps that leverage the SDK initially use a local check for rooted devices (which is not verified). However, at the time of an actual transaction, a second proper/secure implementation of the attestation API is used (i.e., with remote verification).\n• Four other apps referenced the attestation API, but the checks failed to follow Google’s recommendations for performing those checks (e.g., didn’t verify that the result came from Google, didn’t validate the SSL certificate, or didn’t verify the signature of the message).\n• 22 of 23 apps that used Google SafetyNet used the attestation API specifically. The one app that did not used only the Safe Browsing API.\n\nWhy aren’t more Android apps using the Google SafetyNet Attestation API?\n\nWe can’t say for sure why more Android developers don’t take advantage of the attestation API. We recommend that developers do everything they can to protect themselves, their apps, and their users against mobile app security, privacy, and compliance violations.\n\nDevelopers should implement the Google SafetyNet Attestation API in their apps to protect against the potential risks associated with rooted devices running their apps. Sample apps available on GitHub use the API and provide examples of proper implementations: SafetyNet Helper and SafetyNet samples provided by Google.\n\nUsing the API, however, is only one part of an in-depth approach to mobile app security. For more than 50 tips on addressing security threats, addressing compliance gaps, and preventing privacy issues in mobile apps, download our Secure Mobile Development Best Practices guide.\n\nWe’re in the process of reaching out to the developers of the apps we identified that are not properly implementing the Google SafetyNet Attestation API. If you’re implementing aspects of Google SafetyNet into your mobile apps and want guidance from NowSecure, please use our contact form."
    },
    {
        "link": "https://indusface.com/learning/how-to-implement-root-detection-in-android-applications",
        "document": "Rooting is the process of gaining administrative privileges, often referred to as “root access” or “superuser access,” on an Android device.\n\nIt involves unlocking the operating system’s full potential and obtaining control over the device’s core functionalities that are typically restricted to regular users.\n\nSecurity researchers or pen testers require root access to conduct thorough evaluations of application security. This access is crucial for bypassing certificate pinning, necessary for intercepting HTTP communication between the app and a remote server. Root access is also vital for examining and evaluating data storage and secrets handling practices.\n\nOn the other hand, malicious hackers exploit root access to manipulate target application logic or to amplify the impact of malware campaigns.\n\nWhy do We Need Android Root Detection?\n\nRoot detection involves identifying whether an Android device has undergone rooting, enabling users to execute commands with elevated privileges beyond those normally available.\n\nWhile rooting grants users’ greater control over their devices, it also poses several risks:\n\nSecurity Vulnerabilities: Rooted devices are more susceptible to malware, as malicious apps can exploit root privileges to access sensitive data or modify system files.\n\nVoided Warranty: Rooting typically voids the device warranty, leaving users ineligible for manufacturer support or repairs.\n\nInstability and Performance Issues: Improperly executed rooting procedures can lead to device instability, frequent crashes, or reduced performance.\n\nBricking the Device: Incorrectly rooting the device or flashing custom ROMs can render it unusable (bricked), requiring technical expertise to restore functionality.\n\nImplementing root detection helps mitigate these risks by providing insights into the device’s security status and enabling applications to enforce necessary security measures to protect sensitive data and maintain system integrity.\n\nVarious basic techniques exist to determine whether an Android device has been rooted programmatically:\n\nRooted devices often have certain files or directories present on the system that are not present on non-rooted devices. These can include files like Superuser.apk or directories like /system/xbin/su. By checking for the existence of these files or directories, you can infer whether the device is rooted.\n\nThe SU binary (superuser binary) is a common indicator of a rooted device. This binary allows users to execute commands as the root user, providing elevated privileges. By attempting to execute a shell command to check for the presence of the SU binary, you can determine if the device is rooted.\n\nRooted devices might alter certain system properties, such as ro.build.tags, ro.build.type, or ro.debuggable. These properties can provide clues about the device’s root status. For example, the presence of “test-keys” or “eng” in these properties may indicate that the device is rooted.\n\nBusyBox is a common tool installed on rooted devices. It provides a set of Unix utilities in a single executable file. By checking if BusyBox is installed on the device, you can infer that the device may be rooted.\n\nRooted devices often have apps installed for managing root access, such as SuperSU or Magisk Manager. You can check for the presence of these apps on the device to infer whether it’s rooted. However, keep in mind that some users might have rooted their devices without installing such apps.\n\nCheck the integrity of system files and partitions. Rooting often involves modifying system files or partitions. You can compare the checksums or signatures of critical system files against known values to detect any modifications.\n\nBesides the specific properties mentioned earlier, you can examine other build properties such as ro.secure and ro.allow.mock.location. Deviations from typical values or unexpected combinations of properties might indicate a rooted device.\n\nTry to write to protected locations such as /system or /data directories. On non-rooted devices, such attempts will likely fail due to restricted permissions. However, on rooted devices, these operations might succeed.\n\nCheck out the set of 154 test cases for comprehensive penetration testing of Android applications and verify that they don’t have any security loopholes.\n\nRoot detection bypass refers to the process of bypassing security measures put in place to detect rooted or compromised devices.\n\nWhen an application or system employs root detection mechanisms to defend against unauthorized access or tampering, attackers may attempt to bypass these measures to gain unrestricted access to the device or application.\n\nThis bypass can take various forms, including the use of sophisticated tools and techniques designed to conceal root access or manipulate detection mechanisms.\n\nRoot hiding techniques: Attackers may employ tools like Magisk Hide or Xposed Framework to conceal root access from detection mechanisms used by applications or systems.\n\nCode injection and modification: Attackers may inject malicious code into the application’s runtime environment to manipulate or disable root detection checks.\n\nEmulation and virtualization: By running the application in an emulated or virtualized environment, attackers can evade root detection checks that rely on device-specific characteristics.\n\nCustomized firmware and ROMs: Attackers may install custom firmware or ROMs that modify system behavior to bypass root detection mechanisms.\n\nRuntime manipulation: Techniques like hooking and controls with tools like Frida can be used to intercept and modify runtime behavior, including root detection checks, to evade detection.\n\nTo mitigate this risk, developers and security professionals must continuously update and enhance root detection mechanisms to stay ahead of evolving bypass techniques.\n\nAdditionally, implementing layered security measures and adopting best practices for secure coding can help strengthen overall security posture and reduce the likelihood of successful root detection bypass attacks.\n\nThe goal of comprehensive Android root detection is to make running the application on a rooted device more difficult. Detecting rooted devices alone is not sufficient, but implementing various checks throughout the app can improve the effectiveness of overall implementation and improve the security of Android apps.\n\nIn the following section, we outline common Android root detection bypass mitigation methods and provide reference steps for implementing them.\n\nWe highly recommend incorporating all these checks into your application. If any of these checks fail, ranging from Step 1 to Step 5, it’s advisable not to allow the end-user to proceed further.\n\nMany security researchers and penetration testers use virtual devices to test the security of Android applications. Having emulator detection gives one layer of additional protection to your application against runtime manipulation.\n\nUtilize resources like the Android Anti-Emulator GitHub repository. This repository offers various techniques for detecting emulated Android environments and determining whether your application is running on a virtual device.\n\nThe Google SafetyNet Attestation API serves as an anti-abuse mechanism, allowing app developers to verify whether a user’s Android device meets specific requirements and to authenticate the interaction between application servers and genuine apps. This API is essential for abuse detection purposes.\n\nThe SafetyNet Attestation API creates device profiles based on software and hardware information, comparing them to a list of whitelisted device models that have passed Android compatibility testing.\n\nWhen this API is called, SafetyNet will download a package containing device validation code which is provided by Google. Then, the code is dynamically executed on the device to check the integrity of the device.\n\nPurpose: Assess the general integrity of the device and its API.\n\nResult Interpretation: Many rooted devices, emulators, and devices with signs of tampering (such as API hooks) fail the basicIntegrity check.\n\nPurpose: Verify if the device profile matches one of Google’s approved devices.\n\nResult Interpretation: Unmodified devices certified by Google can pass the ctsProfileMatch check. The following types of devices will generally fail ctsProfileMatch check:\n• Devices for which the manufacturer did not apply for, or pass, Google certification\n• Devices with a system image built directly from the AOSP (Android Open Source Program) source files\n• Devices with an operating system image, which was distributed as part of a beta or developer preview program (including the Android Beta Program)\n\nTo use the API, an app can call the SafetyNetApi.attest method, which returns a JWS message with a result. The application can then check various fields from the returned result:\n\nNonces: Used to match the response to its request.\n\nTimestampMs: Indicates the time elapsed since the request was made and the response was received, detecting suspicious delays.\n\nApkPackageName, ApkCertificateDigestSha256, ApkDigestSha256: Provide information about the APK file to verify the app’s identity. These parameters are absent if the API cannot determine APK information.\n\nTrue: The device likely hasn’t been tampered with.\n\nFalse: The device integrity is compromised, possibly due to rooting or other tampering.\n\nFalse: The device profile does not match an approved Google device, indicating potential tampering or non-compliance.\n\nThe following table explains how device status affects the values of basicIntegrity and ctsProfileMatch:\n\nBy leveraging these integrity checks, developers can enhance the security of their apps and protect against potential threats arising from compromised or tampered devices and root detection bypasses.\n\nThe API checks the device’s integrity and provides a cryptographically signed attestation. To create “attestation”, API will examine the device’s software and hardware environment. Besides, it will perform a check for integrity issues, and compare it with reference data of approved Android devices. The attestation also contains a timestamp.\n• The Android app sends a call to the API, including a nonce.\n• The API assesses the device’s runtime environment and requests a signed attestation of the assessment results from Google’s servers.\n• Google’s servers send the signed attestation to the SafetyNet Attestation service on the device.\n• The Attestation service returns the signed attestation to the Android application.\n• The mobile app forwards the signed attestation to its server.\n• The server validates the response and utilizes it for anti-abuse decisions.\n\nThe reference implementation includes the following details:\n• Sample Android App: Android application written in Java that uses Google Play Services for the SafetyNet API on a device.\n• Server-side Java code: Two examples showing how to verify a SafetyNet API response on a server written in Java, including offline and online using the Android Device Verification API.\n• Server-side code C# code: Two samples showing how to verify a SafetyNet API response on a server written in C#, including offline and online via using Android Device Verification API.\n\nSupplementary Security Measure: SafetyNet should not be relied upon as the sole security mechanism for your app. It’s best used alongside other mobile application security measures.\n\nInternet Dependency: The API requires an active internet connection to function. It won’t work when the device is offline. In such cases, the API returns an error if the device lacks internet access.\n\nAvoid Direct Response Interpretation: Responses from the SafetyNet API should not be directly interpreted within the app itself. Instead, it’s advisable to shift all anti-abuse decision logic to a server controlled by the application team. This approach helps prevent potential abuse or exploitation of the API’s responses.\n\nBoolean System Integrity Values: The API provides Boolean values that indicate different levels of system integrity. These values offer insights into the device’s security status, aiding in making informed decisions regarding app functionality or access.\n\nNo DRM Replacement: SafetyNet does not implement or replace Digital Rights Management (DRM) checks. It focuses solely on assessing device integrity and does not address DRM-related concerns or protections.\n\nDetecting root access on Android devices is tough due to modern bypass tools such as RootCloak, RootCloak Plus, “system-less” root, Magisk Hide, and Frida root bypass scripts.\n\nAs no single check can detect all rooting methods, implementing multiple layers of checks strengthens detection capabilities, thereby minimizing the risk of root detection bypass.\n\nBelow are few Android root detection checks:\n\nMost detection apps simply try to run su or perform basic checks. Root Inspector utilizes multiple root detection methods, offering 15 checks via SDK (Java) and 13 checks via NDK (Native Code). This comprehensive approach enhances effectiveness against tools like RootCloak or RootCloak Plus.\n\nTo assess Root Inspector’s effectiveness, we tested an unmodified app version on both a rooted virtual device and a rooted physical device. Various root detection bypass techniques were implemented to simulate real-life scenarios, and the results were analyzed.\n\nMemu Emulator (Running Android 7), Xposed Framework, RootCloak (with native root detection bypass enabled) were used during this test.\n\nMemu Emulator (Running Android 7), Xposed Framework, Frida Objection, Frida root bypass script and RootCloak were used during this test.\n\nXiaomi Mi Pad 1 (Running Lineage OS 14 with Android 7.1.2 ), Magisk Core, Magisk Hide (with Magisk Hide enabled on Root Inspector), and Frida root detection bypass scripts were used during testing.\n\nRootBeer library is an open-source project that checks if the Android device is rooted or not. RootBeer Fresh is based on the original RootBeer project but implements some new and different techniques to detect rooted devices including basic checks to detect Magisk.\n\nMemu Emulator (Running Android 7), Xposed Framework, RootCloak, and Frida Objection were used during this test.\n\nXiaomi Mi Pad 1 (Running Lineage OS 14 with Android 7.1.2 ), Magisk Core, Magisk Hide (with Magisk Hide enabled on RootBeer Sample and RootBeer Fresh) were used during testing.\n\nBy incorporating these root detection mechanisms into your app, you can enhance its security and protect against potential threats posed by rooted devices.\n\nFrida is a popular dynamic instrumentation toolkit commonly used by mobile application penetration testers for various purposes, including root detection bypass and SSL pinning bypass.\n\nTo maintain the security of your application, it’s essential to implement Frida hooking detection to prevent Frida from intercepting and manipulating your app’s behavior.\n\nOne approach to implement Frida detection is by utilizing tools like DetectFrida, a GitHub project that employs three methods to detect Frida hooking:\n• Detection through Named Pipes used by Frida\n\nFrida uses named pipes for communication between the Frida server running on the device and the Frida script executing on the host machine. DetectFrida monitors the presence of these named pipes, and if detected, it indicates the potential presence of Frida hooking.\n\nFrida creates specific threads with unique names during its hooking process. DetectFrida checks for the existence of these threads within the application’s process. If such threads are found, it suggests that Frida may be actively hooking into the application.\n• Comparison of Text Section in Memory with Text Section in Disk\n\nDetectFrida performs a comparison between the text section of the application’s memory and the text section of the application’s disk image. Frida injects its code into the application’s memory, altering the text section. By comparing these sections, DetectFrida can identify discrepancies, indicating potential Frida hooking.\n\nBy incorporating Frida detection mechanisms like those employed by DetectFrida into your application, you can enhance its resilience against Frida-based attacks, ensuring the integrity and security of your app’s execution environment.\n\nAntiFrida, available on GitHub, is a repository designed to identify Frida instrumentation within a process. It accomplishes this by conducting a comprehensive scan of all local TCP ports. For each port, AntiFrida sends a D-Bus message to determine the presence of frida-server. Additionally, it examines text sections to search for specific strings typically found within files like frida-gadget*.so or frida-agent*.so.\n\nWhen a device is rooted using the “systemless root” method, modifications are stored in the boot partition, making it challenging to detect root access through basic checks. Magisk is a popular tool for rooting Android devices in a “systemless” manner, offering features like Magisk Manager for configuring modules and other functionalities.\n\nHowever, Magisk Manager can be hidden by changing its package name, and Magisk Hide prevents applications from detecting root presence. Therefore, implementing Magisk detection is crucial to prevent your Android app from running on rooted devices.\n\nMagisk Detector is a tool that performs multiple checks to detect the presence of Magisk, including verifying if Magisk Hide is enabled. This comprehensive approach ensures effective detection of Magisk and its associated features.\n\nDetectMagiskHide is another GitHub repository aimed at detecting Magisk presence and determining whether Magisk Hide is enabled on the device. Although similar in purpose to MagiskDetector, DetectMagiskHide may offer slightly different detection methods or features.\n\nApplication reverse engineering is a common technique used by application penetration testers to understand the technical details of an application. Analyzing the application’s source code allows them to gain insights into its functioning.\n\nSource code obfuscation is required to enhance the security of the application by making it more difficult for attackers to reverse engineer and understand the underlying logic, thereby protecting intellectual property and sensitive information contained within the codebase.\n\nOne effective tool for source code obfuscation in Android applications is IBM ProGuard. ProGuard offers features to obfuscate, shrink, and optimize your codebase. Here’s how it works:\n\nRenaming: ProGuard renames classes, fields, and methods with obscure names, making it harder for attackers to understand the code’s logic.\n\nUnused Code Removal: In addition to obfuscation, ProGuard removes unused code segments from your application, further reducing the footprint and complexity of the codebase.\n\nOptimizations: ProGuard performs various optimizations to improve the performance of your application, ensuring that it runs efficiently on the target device.\n\nBy employing ProGuard, you not only enhance the security of your application by obfuscating its source code but also reduce the APK file size, leading to faster download and installation times for users.\n\nTo shrink, obfuscate, and optimize the Android application, implement the following code in project-level build.gradle file.\n\nminifyEnabled: Enables code shrinking, obfuscation, and optimization for only your project’s release build type.\n\nshrinkResources: Enables shrinking of resources, performed by the Android Gradle plugin.\n\nproguardFiles getDefaultProguardFile: Includes the default ProGuard rules files that are packaged with the Android Gradle plugin.\n\nStringCare is an Android Library and Android Studio Gradle Plugin for obfuscating strings (strings inside the code) at compilation time. StringCare manages strings and assets files in your Android application. Developers can specify what strings and assets should be obfuscated in the XML files.\n\nStringCare plugin looks for string resources for obfuscating at compilation time. Include the following in your project-level build.gradle file to make it work globally in the project.\n\nThe library is used for revealing the obfuscated string resources generated by the plugin. The obfuscated strings are revealed at runtime. Include the following in-app module’s build.gradle file.\n\nOverall, integrating ProGuard into your Android app development workflow is an effective strategy to protect your code from reverse engineering and ensure the confidentiality of your intellectual property."
    },
    {
        "link": "https://appdome.com/how-to/mobile-app-security/jailbreak-root-detection/build-root-detection-protect-android-apps",
        "document": "How to Build Root Detection in Android Apps Using AI\n\nThis Knowledge Base article describes how to use Appdome’s AI/ML in your CI/CD pipeline to continuously deliver plugins that Detect Rooting in Android apps. Root detection identifies if an Android device has been rooted, a process that grants users elevated privileges to bypass security restrictions. While rooting enables customization, it also exposes apps to significant risks, such as unauthorized data access, manipulation of app logic, or installation of malware. Attackers leverage root access to extract sensitive data, bypass in-app protections, and alter system behaviors. Root detection is essential for preventing privilege escalation attacks, safeguarding sensitive app data, and ensuring compliance with standards like PCI DSS and OWASP MASVS, which require robust protections against elevated privilege risks. Appdome’s dynamic Root Detection plugin for Android identifies rooted devices by inspecting system properties, detecting su binaries, and analyzing behaviors or artifacts that signify the OS has been rooted. The plugin blocks app functionality on rooted devices to prevent unauthorized access, data manipulation, and tampering. Mobile developers can use Appdome’s Threat-Events™ to gather insights on root detection events and create tailored user responses, ensuring app integrity and security. To use Appdome’s mobile app security build system to Detect Rooting , you’ll need: How to Implement Detect Rooting in Android Apps Using Appdome On Appdome, follow these 3 simple steps to create self-defending Android Apps that Detect Rooting without an SDK or gateway:\n• Designate the Mobile App to be protected.\n• Upload an app via the Appdome Mobile Defense platform GUI or via Appdome’s DEV-API or CI/CD Plugins.\n• Root Detection is compatible with: Java, JS, C++, C#, Kotlin, Flutter, React Native, Unity, Xamarin, Cordova and other Android apps.\n• \n• Create and name the Fusion Set (security template) that will contain the Root Detection feature as shown below: Figure 1: Fusion Set that will contain the Root Detection feature\n• Follow the steps in Sections 2.2-2.2.2 of this article to add the Root Detection feature to your Fusion Set via the Appdome Console.\n• When you select the Root Detection you'll notice that the Fusion Set you created in step 2.1 now bears the icon of the protection category that contains Root Detection. Figure 2: Fusion Set that displays the newly added Root Detection protection \n\n Note: Annotating the Fusion Set to identify the protection(s) selected is optional only (not mandatory).\n• Open the Fusion Set Detail Summary by clicking the “...” symbol on the far-right corner of the Fusion Set. Copy the Fusion Set ID from the Fusion Set Detail Summary (as shown below):\n• \n• Refer to the Appdome API Reference Guide for API building instructions.\n• Look for sample APIs in Appdome’s GitHub Repository Follow the instructions below to use the Fusion Set ID inside any standard mobile DevOps or CI/CD toolkit like Bitrise, Jenkins, Travis, Team City, Circle CI or other system:\n• Add the Root Detection feature to your security template.\n• Build > Security tab > OS Integrity section in the Appdome Console. Like all other options in ONEShield™, Root Detection is turned on by default, as shown below: Figure 4: Selecting Root Detection \n\n Note: The App Compromise Notification contains an easy to follow default remediation path for the mobile app end user. You can customize this message as required to achieve brand specific support, workflow or other messaging.\n• Root Detection. \n\n \n\n (a) Choose to monitor this attack vector by checking the Threat Events checkbox associated with Root Detection as shown below. \n\n (b) To receive mobile Threat Monitoring, check the ThreatScope™ box as shown below. For more details, see our knowledge base article on ThreatScope™ Mobile XDR Note: The Appdome Platform displays the Mobile Operation Systems supported by each defense in real-time. For more details, see our OS Support Policy KB\n• Threat Defense and Intelligence policy for Root Detection:\n• Threat-Events™ OFF > In-App Defense If the Threat-Events™ setting is not selected. Appdome will detect and defend the user and app by enforcing Rooting.\n• Threat-Events™ ON > In-App Detection When this setting is used, Appdome detects application is running on rooted device and passes Appdome’s Threat-Event™ attack intelligence to the app’s business logic for processing, enforcement, and user notification. For more information on consuming and using Appdome Threat-Events™ in the app, see section Using Threat-Events™ to Root DetectionDetect Intelligence and Control in Mobile Apps.\n• Threat-Events™ ON > In-App Defense When this setting is used, Appdome detects and defends against Rooting (same as Appdome Enforce) and passes Appdome’s Threat-Event™ attack intelligence to the app’s business logic for processing. For more information on consuming and using Appdome Threat-Events™ in the app, see section Using Threat-Events™ for Root DetectionDetect Intelligence and Control in Mobile Apps.\n• FailSafe Enforcement ON > In-App Detection When this setting is enabled, Appdome enforces specific detections only after a fixed timeframe specified by the app developer.\n• Root Detection: \n\n With Threat-Events™ OFF, Appdome provides several user experience options for mobile brands and developers.\n• App Compromise Notification: Customize the pop-up or toast Appdome uses to notify the user when a threat is present while using the protected mobile app.\n• Short message Option. This is available for mobile devices that allow a banner notification for security events.\n• Localized Message Option. Allows Appdome users to support global languages in security notifications.\n• Root Detection Threat Code™. Appdome uses AI/ML to generate a unique code each time Root Detection is triggered by an active threat on the mobile device. Use the code in Appdome Threat Resolution Center™ to help end users identify, find and resolve active threats on the personal mobile devices. Configure the User Experience Options forWith Threat-Events™ OFF, Appdome provides several user experience options for mobile brands and developers.\n• None Optional Configuration with Root Detection:\n• None Prevent user from running your application on devices with no SELinux enforcement.\n• Build My App at the bottom of the Build Workflow (shown in Initiate the build command either by clickingat the bottom of the Build Workflow (shown in Figure 4 ) or via your CI/CD as described in Section 2.1.4 Congratulations! The Root Detection protection is now added to the mobile app\n• After building Root Detection, Appdome generates a Certified Secure™ certificate to guarantee that the Root Detection protection has been added and is protecting the app. To verify that the Root Detection protection has been added to the mobile app, locate the protection in the Certified Secure™ certificate as shown below: Each Certified Secure™ certificate provides DevOps and DevSecOps organizations the entire workflow summary, audit trail of each build, and proof of protection that Root Detection has been added to each Android app. Certified Secure provides instant and in-line DevSecOps compliance certification that Root Detection and other mobile app security features are in each build of the mobile app.\n\nUsing Threat-Events™ for Rooting Intelligence and Control in Android Apps Appdome Threat-Events™ provides consumable in-app mobile app attack intelligence and defense control when Rooting is detected. To consume and use Threat-Events™ for Rooting in Android Apps, use registerReceiver in the Application OnCreate, and the code samples for Threat-Events™ for Rooting shown below. The specifications and options for Threat-Events™ for Rooting are: Appdome detects the attack or threat and passes the event in a standard format to the app for processing (app chooses how and when to enforce). Uses Appdome Enforce mode for any attack or threat and passes the event in a standard format to the app for processing (gather intel on attacks and threats without losing any protection). Message displayed for the user on event The external ID of the event which can be listened via Threat Events The manufacturer of the current device The task ID of the Appdome fusion of the currently running app Info about the kernel: system name, node name, release, version and machine. PLMN of the device. Only available for Android devices. OS name of the current device Carrier name of the current device. Only available for Android. Is the OS version up to date Is the device face down The last six characters of the threat code specify the OS, allowing the Threat Resolution Center to address the attack on the affected device. \n\n With Threat-Events™ enabled (turned ON), Android developers can get detailed attack intelligence and granular defense control in Android applications and create amazing user experiences for all mobile end users when Rooting is detected. \n\n The following is a code sample for native Android apps, which uses all values in the specification above for Root Detection: \n\n Important! Replace all placeholder instances of <Context Key> with the specific name of your threat event context key across all language examples. This is crucial to ensure your code functions correctly with the intended event data. For example, The <Context Key> could be the message, externalID, OS Version, reason code, etc. \n\n IntentFilter intentFilter = new IntentFilter(); intentFilter.addAction(\"RootedDevice\"); BroadcastReceiver threatEventReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { String message = intent.getStringExtra(\"message\"); // Message shown to the user String reasonData = intent.getStringExtra(\"reasonData\"); // Threat detection cause String reasonCode = intent.getStringExtra(\"reasonCode\"); // Event reason code // Current threat event score String currentThreatEventScore = intent.getStringExtra(\"currentThreatEventScore\"); // Total threat events score String threatEventsScore = intent.getStringExtra(\"threatEventsScore\"); // Replace ' ' with your specific event context key // String variable = intent.getStringExtra(\" \"); // Your logic goes here (Send data to Splunk/Dynatrace/Show Popup...) } }; if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) { registerReceiver(threatEventReceiver, intentFilter, Context.RECEIVER_NOT_EXPORTED); } else { registerReceiver(threatEventReceiver, intentFilter); } val intentFilter = IntentFilter() intentFilter.addAction(\"RootedDevice\") val threatEventReceiver = object : BroadcastReceiver() { override fun onReceive(context: Context?, intent: Intent?) { var message = intent?.getStringExtra(\"message\") // Message shown to the user var reasonData = intent?.getStringExtra(\"reasonData\") // Threat detection cause var reasonCode = intent?.getStringExtra(\"reasonCode\") // Event reason code // Current threat event score var currentThreatEventScore = intent?.getStringExtra(\"currentThreatEventScore\") // Total threat events score var threatEventsScore = intent?.getStringExtra(\"threatEventsScore\") // Replace ' ' with your specific event context key // var variable = intent?.getStringExtra(\" \") // Your logic goes here (Send data to Splunk/Dynatrace/Show Popup...) } } if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) { registerReceiver(threatEventReceiver, intentFilter, Context.RECEIVER_NOT_EXPORTED) } else { registerReceiver(threatEventReceiver, intentFilter) } const { ADDevEvents } = NativeModules; const aDDevEvents = new NativeEventEmitter(ADDevEvents); function registerToDevEvent(action, callback) { NativeModules.ADDevEvents.registerForDevEvent(action); aDDevEvents.addListener(action, callback); } export function registerToAllEvents() { registerToDevEvent( \"RootedDevice\", (userinfo) => Alert.alert(JSON.stringify(userinfo)) var message = userinfo[\"message\"] // Message shown to the user var reasonData = userinfo[\"reasonData\"] // Threat detection cause var reasonCode = userinfo[\"reasonCode\"] // Event reason code // Current threat event score var currentThreatEventScore = userinfo[\"currentThreatEventScore\"] // Total threat events score var threatEventsScore = userinfo[\"threatEventsScore\"] // Replace ' ' with your specific event context key // var variable = userinfo[\" \"] // Your logic goes here (Send data to Splunk/Dynatrace/Show Popup...) ); } RegisterReceiver(new ThreatEventReceiver(), new IntentFilter(\"RootedDevice\")); class ThreatEventReceiver : BroadcastReceiver { public override void OnReceive(Context context, Intent intent) { String message = intent.GetStringExtra(\"message\"); // Message shown to the user String reasonData = intent.GetStringExtra(\"reasonData\"); // Threat detection cause String reasonCode = intent.GetStringExtra(\"reasonCode\"); // Event reason code // Current threat event score String currentThreatEventScore = intent.GetStringExtra(\"currentThreatEventScore\"); // Total threat events score String threatEventsScore = intent.GetStringExtra(\"threatEventsScore\"); // Replace ' ' with your specific event context key // String variable = intent.GetStringExtra(\" \"); // Your logic goes here (Send data to Splunk/Dynatrace/Show Popup...) } } NSNotificationCenter.DefaultCenter.AddObserver( (NSString)\"RootedDevice\", // Threat-Event Identifier delegate (NSNotification notification) { // Message shown to the user var message = notification.UserInfo.ObjectForKey(\"message\"); // Threat detection cause var reasonData = notification.UserInfo.ObjectForKey(\"reasonData\"); // Event reason code var reasonCode = notification.UserInfo.ObjectForKey(\"reasonCode\"); // Current threat event score var currentThreatEventScore = notification.UserInfo.ObjectForKey(\"currentThreatEventScore\"); // Total threat events score var threatEventsScore = notification.UserInfo.ObjectForKey(\"threatEventsScore\"); // Replace ' ' with your specific event context key // var variable = notification.UserInfo.ObjectForKey(\" \"); // Your logic goes here (Send data to Splunk/Dynatrace/Show Popup...) } ); window.broadcaster.addEventListener(\"RootedDevice\", function(userInfo) { var message = userInfo.message // Message shown to the user var reasonData = userInfo.reasonData // Threat detection cause var reasonCode = userInfo.reasonCode // Event reason code // Current threat event score var currentThreatEventScore = userInfo.currentThreatEventScore // Total threat events score var threatEventsScore = userInfo.threatEventsScore // Replace ' ' with your specific event context key // var variable = userInfo. // Your logic goes here (Send data to Splunk/Dynatrace/Show Popup...) }); import 'dart:async'; import 'package:flutter/material.dart'; import 'package:flutter/services.dart'; class PlatformChannel extends StatefulWidget { const PlatformChannel({super.key}); @override State createState() => _PlatformChannelState(); } class _PlatformChannelState extends State { // Replace with your EventChannel name static const String _eventChannelName = \"RootedDevice\"; static const EventChannel _eventChannel = EventChannel(_eventChannelName); @override void initState() { super.initState(); _eventChannel.receiveBroadcastStream().listen(_onEvent, onError: _onError); } void _onEvent(Object? event) { setState(() { // Adapt this section based on your specific event data structure var eventData = event as Map; // Example: Accessing 'externalID' field from the event var externalID = eventData['externalID']; // Customize the rest of the fields based on your event structure String message = eventData['message']; // Message shown to the user String reasonData = eventData['reasonData']; // Threat detection cause String reasonCode = eventData['reasonCode']; // Event reason code // Current threat event score String currentThreatEventScore = eventData['currentThreatEventScore']; // Total threat events score String threatEventsScore = eventData['threatEventsScore']; // Replace ' ' with your specific event context key // String variable = eventData[' ']; }); } // Your logic goes here (Send data to Splunk/Dynatrace/Show Popup...) }\n\nUsing Appdome, there are no development or coding prerequisites to build secured Apps by using Root Detection. There is no SDK and no library to code or implement in the app and no gateway to deploy in your network. All protections are built into each app and the resulting app is self-defending and self-protecting.\n\nAfter successfully securing your app by using Appdome, there are several available options to complete your project, depending on your app lifecycle or workflow. These include:\n• How to Protect iOS Apps from Liberty Lite Jailbreak Detection Bypass\n• Check out the full menu of features in the Appdome Mobile Security Suite\n\nHow Do I Learn More?\n\nIf you have any questions, please send them our way at support.appdome.com or via the chat window on the Appdome platform.\n\nThanks for visiting Appdome! Our mission is to secure every app on the planet by making mobile app security easy. We hope we’re living up to the mission with your project."
    },
    {
        "link": "https://medium.com/@ahmedafatah/android-security-for-dummies-root-detection-695bd4d90db8",
        "document": "Hey everyone! Welcome to my series on Android security. Today, we will tackle another crucial aspect of keeping your app safe and sound: Root\n\nwhile beneficial for power users, exposes devices to vulnerabilities such as tampering, data theft, and bypassing critical security measures. For developers, especially those working on sensitive applications, detecting rooted devices becomes an essential layer of protection.\n\nThis article explores a robust root detection implementation using layered methodologies, showcasing a combination of Java-based checks and native integrations. The implementation is based on modular classes designed to ensure extensibility and effectiveness.\n\nThe implementation uses a layered approach to detect rooted devices. Key detection mechanisms include:\n\n1. Root Binaries and Apps Check: Scans for the presence of files and applications commonly associated with rooting.\n\nEach layer serves a specific purpose in our defense strategy:\n\nThe first layer involves checking for common indicators of root access\n\nOne effective method is checking for the presence of files commonly associated with rooted devices:\n\nWe scan for known root-related applications:\n\nWe implement additional checks at the native level for increased security:\n\nsequenceDiagram:\n\n App->>PS: Check Running Processes\n\n PS-->>App: Return Process List\n\n App->>App: Search for Frida Markers\n\n App->>Port: Check Port 27042\n\n Port-->>App: Port Status\n\n alt Frida Detected\n\n App->>Handler: Trigger Detection\n\n Handler->>Handler: Log Event\n\n Handler->>App: Execute Countermeasures\n\n else No Detection\n\n App->>App: Continue Normal Operation\n\n end\n\nWhen root detection occurs, it's crucial to implement appropriate responses. Here's how we handle different scenarios:\n\nOne of the more sophisticated detection methods involves analyzing running processes:\n\nImplementing robust root detection is an ongoing process that requires constant attention and updates. The code examples and implementation strategies provided here serve as a foundation for building a comprehensive security solution. Remember to:\n\n- Regularly update detection methods\n\n- Monitor for new rooting techniques\n\n- Balance security with user experience\n\n- Implement proper testing procedures\n\n- Maintain logs and analytics\n\n- Keep security definitions current\n\nRemember that no single approach is foolproof, and the best defense is a layered approach combining multiple detection methods with proper response handling."
    },
    {
        "link": "https://source.android.com/docs/security/overview/implement",
        "document": "The Android Security Team regularly receives requests for information about preventing potential security issues on Android devices. We also occasionally spot check devices and let device manufacturers and affected partners know of potential issues.\n\nThis page provides security best practices based on our experiences, extending the Designing for Security documentation we've provided for developers and includes details unique to building or installing system-level software on devices.\n\nTo facilitate adoption of these best practices, where possible the Android Security Team incorporates tests into the Android Compatibility Test Suite (CTS) and Android Lint. We encourage device implementers to contribute tests that can help other Android users (view security-related tests at ).\n\nUse the following best practices in your development processes and environment.\n\nSource code review can detect a broad range of security issues, including those identified in this document. Android strongly encourages both manual and automated source code review. Best practices:\n• Run Android Lint on all app code using the Android SDK and correct any identified issues.\n• Native code should be analyzed using an automated tool that can detect memory management issues such as buffer overflows and off-by-one errors.\n• The Android build system has support for many of the LLVM sanitizers, such as AddressSanitizer and UndefinedBehaviorSanitizer which can be used for this purpose.\n\nAutomated testing can detect a broad range of security issues, including several issues discussed below. Best practices:\n• CTS is regularly updated with security tests; run the most recent version of CTS to verify compatibility.\n• Run CTS regularly throughout the development process to detect problems early and reduce time to correction. Android uses CTS as part of continuous integration in our automated build process, which builds multiple times per day.\n• Device manufacturers should automate security testing of interfaces, including testing with malformed inputs (fuzz testing).\n\nThe signature of the system image is critical for determining the integrity of the device. Best practices:\n• Devices must not be signed with a key that is publicly known.\n• Keys used to sign devices should be managed in a manner consistent with industry standard practices for handling sensitive keys, including a hardware security module (HSM) that provides limited, auditable access.\n\nApp signatures play an important role in device security and are used for permissions checks as well as software updates. When selecting a key to use for signing apps, it is important to consider whether an app will be available only on a single device or common across multiple devices. Best practices:\n• Apps must not be signed with a key that is publicly known.\n• Keys used to sign apps should be managed in a manner consistent with industry standard practices for handling sensitive keys, including an HSM that provides limited, auditable access.\n• Apps shouldn't be signed with the platform key.\n• Apps with the same package name shouldn't be signed with different keys. This often occurs when creating an app for different devices, especially when using the platform key. If the app is device-independent, use the same key across devices. If the app is device-specific, create unique package names per device and key.\n\nGoogle Play provides device manufacturers the ability to update apps without performing a complete system update. This can expedite response to security issues and delivery of new features, as well as provide a way to ensure your app has a unique package name. Best practices:\n• Upload your apps to Google Play to allow automated updates without requiring a full over-the-air (OTA) update. Apps that are uploaded but unpublished aren't directly downloadable by users but the apps are still updated. Users who have previously installed the app can re-install it and/or install on other devices.\n• Create an app package name that is clearly associated with your company, such as by using a company trademark.\n• Apps published by device manufacturers should be uploaded on the Google Play store to avoid package name impersonation by third-party users. If a device manufacturer installs an app on a device without publishing the app on the Play store, another developer could upload the same app, use the same package name, and change the metadata for the app. When the app is presented to the user, this unrelated metadata could create confusion.\n\nExternal parties must have the ability to contact device manufacturers about device-specific security issues. We recommend creating a publicly accessible email address for managing security incidents. Best practices:\n• Create a security@your-company.com or similar address and publicize it.\n• If you become aware of a security issue affecting Android OS or Android devices from multiple device manufacturers, you should contact the Android Security Team by filing a Security bug report.\n\nUse the following best practices when implementing a product.\n\nRoot processes are the most frequent target of privilege escalation attacks, so reducing the number of root processes reduces risk of privilege escalation. CTS includes an informational test that lists root processes. Best practices:\n• Devices should run the minimum necessary code as root. Where possible, use a regular Android process rather than a root process. The ICS Galaxy Nexus has only six root processes: vold, inetd, zygote, tf_daemon, ueventd, and init. If a process must run as root on a device, document the process in an AOSP feature request so it can be publicly reviewed.\n• Where possible, root code should be isolated from untrusted data and accessed via IPC. For example, reduce root functionality to a small Service accessible via Binder and expose the Service with signature permission to an app with low or no privileges to handle network traffic.\n• Root processes must not listen on a network socket.\n• Root processes must not provide a general-purpose runtime for apps (for example, a Java VM).\n\nIn general, pre-installed apps shouldn't run with the shared system UID. If is it necessary, however, for an app to use the shared UID of system or another privileged service, the app shouldn't export any services, broadcast receivers, or content providers that can be accessed by third-party apps installed by users. Best practices:\n• Devices should run the minimum necessary code as system. Where possible, use an Android process with its own UID rather than reusing the system UID.\n• Where possible, system code should be isolated from untrusted data and expose IPC only to other trusted processes.\n• System processes must not listen on a network socket.\n\nThe Android Application Sandbox provides apps with an expectation of isolation from other processes on the system, including root processes and debuggers. Unless debugging is specifically enabled by the app and the user, no app should violate that expectation. Best practices:\n• Root processes must not access data within individual app data folders, unless using a documented Android debugging method.\n• Root processes must not access memory of apps, unless using a documented Android debugging method.\n• Devices must not include any app that accesses data or memory of other apps or processes.\n\nNew setuid programs shouldn't be accessible by untrusted programs. Setuid programs have frequently been the location of vulnerabilities that can be used to gain root access, so strive to minimize the availability of the setuid program to untrusted apps. Best practices:\n• SUID processes must not provide a shell or backdoor that can be used to circumvent the Android security model.\n• SUID programs must not be writable by any user.\n• SUID programs shouldn't be world readable or executable. Create a group, limit access to the SUID binary to members of that group, and place any apps that should be able to execute the SUID program into that group.\n• SUID programs are a common source of user rooting of devices. To reduce this risk, SUID programs shouldn't be executable by the shell user.\n\nCTS verifier includes an informational test listing SUID files; some setuid files aren't permitted per CTS tests.\n\nCTS tests fail when a device is listening on any port, on any interface. In the event of a failure, Android verifies the following best practices are in use:\n• There should be no listening ports on the device.\n• Listening ports must be able to be disabled without an OTA. This can be either a server or user-device configuration change.\n• Root processes must not listen on any port.\n• Processes owned by the system UID must not listen on any port.\n• For local IPC using sockets, apps must use a UNIX Domain Socket with access limited to a group. Create a file descriptor for the IPC and make it +RW for a specific UNIX group. Any client apps must be within that UNIX group.\n• Some devices with multiple processors (e.g. a radio/modem separate from the app processor) use network sockets to communicate between processors. In such instances, the network socket used for inter-processor communication must use an isolated network interface to prevent access by unauthorized apps on the device (that is, use to prevent access by other apps on the device).\n• Daemons that handle listening ports must be robust against malformed data. Google may conduct fuzz-testing against the port using an unauthorized client, and, where possible, authorized client. Any crashes are filed as bugs with an appropriate severity.\n\nLogging data increases the risk of exposure of that data and reduces system performance. Multiple public security incidents have occurred as the result of logging sensitive user data by apps installed by default on Android devices. Best practices:\n• Apps or system services shouldn't log data provided from third-party apps that might include sensitive information.\n• Apps must not log any personally identifiable information (PII) as part of normal operation.\n\nCTS includes tests that check for the presence of potentially sensitive information in the system logs.\n\nWorld-writable directories can introduce security weaknesses and enable an app to rename trusted files, substitute files, or conduct symlink-based attacks (attackers may use a symlink to a file to trick a trusted program into performing actions it shouldn't). Writable directories can also prevent the uninstall of an app from properly cleaning up all files associated with an app.\n\nAs a best practice, directories created by the system or root users should not be world writable. CTS tests help enforce this best practice by testing known directories.\n\nMany drivers and services rely on configuration and data files stored in directories such as and . If these files are processed by a privileged process and are world writable, it is possible for an app to exploit a vulnerability in the process by crafting malicious contents in the world-writable file. Best practices:\n• Configuration files used by privileged processes shouldn't be world readable.\n• Configuration files used by privileged processes must not be world writable.\n\nAny code used by privileged device manufacturer processes must be in or ; these filesystems are mounted read-only on boot. As a best practice, libraries used by system or other highly-privileged apps installed on the device should also be in these filesystems. This can prevent a security vulnerability that could allow an attacker to control the code that a privileged process executes.\n\nOnly trusted code should have direct access to drivers. Where possible, the preferred architecture is to provide a single-purpose daemon that proxies calls to the driver and restricts driver access to that daemon. As a best practice, driver device nodes shouldn't be world readable or writable. CTS tests help enforce this best practice by checking for known instances of exposed drivers.\n\nAndroid debug bridge (adb) is a valuable development and debugging tool, but is designed for use in controlled, secure environments and shouldn't be enabled for general use. Best practices:\n• ADB must be disabled by default.\n• ADB must require the user to turn it on before accepting connections.\n\nMany Android devices support unlocking, enabling the device owner to modify the system partition and/or install a custom operating system. Common use cases include installing a third-party ROM and performing systems-level development on the device. For example, a Google Nexus device owner can run to start the unlocking process, which presents the following message to the user:\n\nAs a best practice, unlockable Android devices must securely erase all user data prior to being unlocked. Failure to properly delete all data on unlocking may allow a physically proximate attacker to gain unauthorized access to confidential Android user data. To prevent the disclosure of user data, a device that supports unlocking must implement it properly (we've seen numerous instances where device manufacturers improperly implemented unlocking). A properly implemented unlocking process has the following properties:\n• When the unlocking command is confirmed by the user, the device must start an immediate data wipe. The flag must not be set until after the secure deletion is complete.\n• If a secure deletion can't be completed, the device must stay in a locked state.\n• If supported by the underlying block device, or equivalent should be used. For eMMC devices, this means using a Secure Erase or Secure Trim command. For eMMC 4.5 and later, this means using a normal Erase or Trim followed by a Sanitize operation.\n• If isn't supported by the underlying block device, must be used instead. On eMMC devices, this is a normal Trim operation.\n• If isn't supported, overwriting the block devices with all zeros is acceptable.\n• An end user must have the option to require that user data be wiped prior to flashing a partition. For example, on Nexus devices, this is done via the command.\n• A device may record, via efuses or similar mechanism, whether a device was unlocked and/or relocked.\n\nThese requirements ensure that all data is destroyed upon the completion of an unlock operation. Failure to implement these protections is considered a moderate level security vulnerability.\n\nA device that is unlocked may be subsequently relocked using the command. Locking the bootloader provides the same protection of user data with the new custom OS as was available with the original device manufacturer OS (e.g. user data will be wiped if the device is unlocked again)."
    },
    {
        "link": "https://appknox.com/blog/root-detection-techniques",
        "document": "Phone manufacturers and mobile network operators often implement stringent software restrictions for security reasons. However, these constraints can be circumvented by rooting your Android phone.\n\nRooting is the process of gaining access to more administrative-level controls on an Android device. Despite its benefits, attackers often use rooting to target sensitive user and business data.\n\nSecurity experts say 36 out of 1000 Android devices are rooted globally. Because a rooted device is considerably more vulnerable to attack, it's critical to use tools to detect this vulnerability. To ensure that your apps only run where, when, and how you want them to, you must first determine whether the device is rooted.\n\n\n\n\n\nAndroid is very similar to Linux because it runs on the Linux kernel. With access control similar to Linux, regular users of Android devices have very limited permissions compared to users who have rooted their devices.\n\nWithout rooting, users cannot access or modify system files and folders. Once rooted, the user has full access to the device. Rooting allows users to make changes to everything on the device, allowing users to do previously impossible things, like removing bloatware, customization, custom ROMs, etc. \n\n\n\n\n\nWhat do we need root detection for?\n\nRooting Android devices has many benefits but also many security issues. Once you have root privileges, you have full control to make changes across the device. However, this also means your device is now an open target for threat actors.\n\nRooted devices may contain many apps that process sensitive information, such as banking, payment, social media, and cloud storage apps. Malicious downloads can expose your device to hackers. For these reasons, the apps installed on a device need to ensure that it isn't rooted. This is a precautionary measure to protect critical user and business information data. \n\n\n\n\n\nHackers frequently root devices to acquire access to sensitive user data and other insights housed in an app's source code or take advantage of devices that the owner has rooted. Detecting this vulnerability is critical to keeping apps safe because it is difficult to guarantee system security and other measures after the root.\n\nLet us take a look at some of the most commonly used root detection methods:\n\n\n\n\n\nMany files and packages on Android devices can be checked to determine if the device is rooted or not. This might include the packages for the apps that are used to root the device, such as \"eu.chainfire.supersu\" and \"com.topjohnwu.magick.\" The presence of apps with such package names shows the presence of root on the Android device.\n\nThe below piece of code detects whether or not any of the mentioned packages are present on the device.\n\nThe below piece of code tries to find the SU binary in commonly found locations.\n\nA check can be implemented to test against custom ROMs on the Android device. We can achieve this by checking build tags. Usually, when a kernel is compiled by a third party, instead of the release keys, we can find test keys in the build tags. Being compiled by a third party shows the presence of a custom ROM on the Android device.\n\nThe following code can be used to detect if the build has test keys or release keys.\n\nAlong with the build tags, looking for Google Over-The-Air certificates is another way of detecting whether the device is a stock Android build or a custom ROM. The following command can detect whether the OTA certificates are present on the device.\n\nThe build.prop file on an Android device contains system properties and build information applied throughout the operating device. Properties are stored in key-value pairs. The file is stored in the /system folder and is loaded every time the device is booted.\n\nSome custom builds/rooting apps modify the build.prop on the Android device and change some of the properties that can only be done by a root user.\n\nWe can use the following code in our app to detect if the properties are modified. Some properties that are usually modified are ro.debuggable and ro.secure.\n\nWe can also use the following command to check the same from a shell.\n\nAnother common method security experts use for root detection is to search for applications commonly found on a rooted device. Some examples are Busyboy, Titanium Backup, Xposed Manager, and Luckypatcher.\n\nSimilarly, we can also use the shell to confirm some of the apps. For example, the command below can be run to see if Busybox is present.\n\nSometimes, when a device is rooted, the permissions on some of the system directories change. By default, the system files and folders on Android devices are mounted as read-only. Once the device is rooted, we can find some files and folders with read-write permissions. We can check the permissions on the system directories to determine whether the device might have been rooted.\n\nFollowing are some of the directories that we can check for permissions.\n\nBelow is a perfect piece of code that checks for permissions on specific folders based on the SDK version of the software.\n\nThere are many root-cloaking apps available that can hide an Android device's root status so that other apps cannot detect whether it is rooted. We can list all the packages and search for the commonly used root-cloaking apps.\n\nThe code below is an example that can detect root-cloaking apps installed on the device.\n\nFrom a security standpoint, developers that prevent users from running their apps on rooted devices may be a bright idea, but this becomes highly inconvenient for users who cannot execute the app only because they rooted their devices.\n\nThe majority of the time, rooting techniques can be readily bypassed, hence it is highly advised that developers utilize sophisticated techniques for root detection and prevent attackers from bypassing their validation measures."
    }
]