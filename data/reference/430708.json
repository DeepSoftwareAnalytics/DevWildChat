[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script",
        "document": "Scripts loaded using the attribute will download the script without blocking the page while the script is being fetched. However, once the download is complete, the script will execute, which blocks the page from rendering. This means that the rest of the content on the web page is prevented from being processed and displayed to the user until the script finishes executing. You get no guarantee that scripts will run in any specific order. It is best to use when the scripts in the page run independently from each other and depend on no other script on the page. Scripts loaded with the attribute will load in the order they appear on the page. They won't run until the page content has all loaded, which is useful if your scripts depend on the DOM being in place (e.g. they modify one or more elements on the page). Here is a visual representation of the different script loading methods and what that means for your page: This image is from the HTML spec, copied and cropped to a reduced version, under CC BY 4.0 license terms. For example, if you have the following script elements: You can't rely on the order the scripts will load in. may load before or after and and if this is the case, any functions in those scripts depending on will produce an error because will not be defined at the time the script runs. should be used when you have a bunch of background scripts to load in, and you just want to get them in place as soon as possible. For example, maybe you have some game data files to load, which will be needed when the game actually begins, but for now you just want to get on with showing the game intro, titles, and lobby, without them being blocked by script loading. Scripts loaded using the attribute (see below) will run in the order they appear in the page and execute them as soon as the script and content are downloaded: In the second example, we can be sure that will load before and and that will load before . They won't run until the page content has all loaded, which is useful if your scripts depend on the DOM being in place (e.g. they modify one or more elements on the page).\n• and both instruct the browser to download the script(s) in a separate thread, while the rest of the page (the DOM, etc.) is downloading, so the page loading is not blocked during the fetch process.\n• scripts with an attribute will execute as soon as the download is complete. This blocks the page and does not guarantee any specific execution order.\n• scripts with a attribute will load in the order they are in and will only execute once everything has finished loading.\n• If your scripts should be run immediately and they don't have any dependencies, then use .\n• If your scripts need to wait for parsing and depend on other scripts and/or the DOM being in place, load them using and put their corresponding elements in the order you want the browser to execute them.\n\nWhen importing modules in scripts, if you don't use the feature, then each module must be imported using a module specifier that is either an absolute or relative URL. In the example below, the first module specifier (\"./shapes/square.js\") resolves relative to the base URL of the document, while the second is an absolute URL. import { name as squareName, draw } from \"./shapes/square.js\"; import { name as circleName } from \"https://example.com/shapes/circle.js\"; An import map allows you to provide a mapping that, if matched, can replace the text in the module specifier. The import map below defines keys and that can be used as aliases for the module specifiers shown above. This allows us to import modules using names in the module specifier (rather than absolute or relative URLs). import { name as squareName, draw } from \"square\"; import { name as circleName } from \"circle\"; For more examples of what you can do with import maps, see the Importing modules using import maps section in the JavaScript modules guide."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/HTML/Element",
        "document": "This page lists all the HTML elements, which are created using tags. They are grouped by function to help you find what you have in mind easily. An alphabetical list of all elements is provided in the sidebar on every element's page as well as this one. Note: For more information about the basics of HTML elements and attributes, see Anatomy of an HTML element.\n\nUse HTML text content elements to organize blocks or sections of content placed between the opening and closing tags. Important for accessibility and SEO, these elements identify the purpose or structure of that content. Indicates that the enclosed text is an extended quotation. Usually, this is rendered visually by indentation. A URL for the source of the quotation may be given using the attribute, while a text representation of the source can be given using the element. Provides the description, definition, or value for the preceding term ( ) in a description list ( ). The generic container for flow content. It has no effect on the content or layout until styled in some way using CSS (e.g., styling is directly applied to it, or some kind of layout model like flexbox is applied to its parent element). Represents a description list. The element encloses a list of groups of terms (specified using the element) and descriptions (provided by elements). Common uses for this element are to implement a glossary or to display metadata (a list of key-value pairs). Specifies a term in a description or definition list, and as such must be used inside a element. It is usually followed by a element; however, multiple elements in a row indicate several terms that are all defined by the immediate next element. Represents a caption or legend describing the rest of the contents of its parent element. Represents self-contained content, potentially with an optional caption, which is specified using the element. The figure, its caption, and its contents are referenced as a single unit. Represents a thematic break between paragraph-level elements: for example, a change of scene in a story, or a shift of topic within a section. Represents an item in a list. It must be contained in a parent element: an ordered list ( ), an unordered list ( ), or a menu ( ). In menus and unordered lists, list items are usually displayed using bullet points. In ordered lists, they are usually displayed with an ascending counter on the left, such as a number or letter. A semantic alternative to , but treated by browsers (and exposed through the accessibility tree) as no different than . It represents an unordered list of items (which are represented by elements). Represents an ordered list of items — typically rendered as a numbered list. Represents a paragraph. Paragraphs are usually represented in visual media as blocks of text separated from adjacent blocks by blank lines and/or first-line indentation, but HTML paragraphs can be any structural grouping of related content, such as images or form fields. Represents preformatted text which is to be presented exactly as written in the HTML file. The text is typically rendered using a non-proportional, or monospaced, font. Whitespace inside this element is displayed as written. Represents an unordered list of items, typically rendered as a bulleted list.\n\nUse the HTML inline text semantic to define the meaning, structure, or style of a word, line, or any arbitrary piece of text. Together with its attribute, creates a hyperlink to web pages, files, email addresses, locations within the current page, or anything else a URL can address. Used to draw the reader's attention to the element's contents, which are not otherwise granted special importance. This was formerly known as the Boldface element, and most browsers still draw the text in boldface. However, you should not use for styling text or granting importance. If you wish to create boldface text, you should use the CSS property. If you wish to indicate an element is of special importance, you should use the element. Tells the browser's bidirectional algorithm to treat the text it contains in isolation from its surrounding text. It's particularly useful when a website dynamically inserts some text and doesn't know the directionality of the text being inserted. Overrides the current directionality of text, so that the text within is rendered in a different direction. Produces a line break in text (carriage-return). It is useful for writing a poem or an address, where the division of lines is significant. Used to mark up the title of a cited creative work. The reference may be in an abbreviated form according to context-appropriate conventions related to citation metadata. Displays its contents styled in a fashion intended to indicate that the text is a short fragment of computer code. By default, the content text is displayed using the user agent's default monospace font. Links a given piece of content with a machine-readable translation. If the content is time- or date-related, the element must be used. Used to indicate the term being defined within the context of a definition phrase or sentence. The ancestor element, the / pairing, or the nearest section ancestor of the element, is considered to be the definition of the term. Marks text that has stress emphasis. The element can be nested, with each nesting level indicating a greater degree of emphasis. Represents a range of text that is set off from the normal text for some reason, such as idiomatic text, technical terms, and taxonomical designations, among others. Historically, these have been presented using italicized type, which is the original source of the naming of this element. Represents a span of inline text denoting textual user input from a keyboard, voice input, or any other text entry device. By convention, the user agent defaults to rendering the contents of a element using its default monospace font, although this is not mandated by the HTML standard. Represents text which is marked or highlighted for reference or notation purposes due to the marked passage's relevance in the enclosing context. Indicates that the enclosed text is a short inline quotation. Most modern browsers implement this by surrounding the text in quotation marks. This element is intended for short quotations that don't require paragraph breaks; for long quotations use the element. Used to provide fall-back parentheses for browsers that do not support the display of ruby annotations using the element. One element should enclose each of the opening and closing parentheses that wrap the element that contains the annotation's text. Specifies the ruby text component of a ruby annotation, which is used to provide pronunciation, translation, or transliteration information for East Asian typography. The element must always be contained within a element. Represents small annotations that are rendered above, below, or next to base text, usually used for showing the pronunciation of East Asian characters. It can also be used for annotating other kinds of text, but this usage is less common. Renders text with a strikethrough, or a line through it. Use the element to represent things that are no longer relevant or no longer accurate. However, is not appropriate when indicating document edits; for that, use the and elements, as appropriate. Used to enclose inline text which represents sample (or quoted) output from a computer program. Its contents are typically rendered using the browser's default monospaced font (such as Courier or Lucida Console). Represents side-comments and small print, like copyright and legal text, independent of its styled presentation. By default, it renders text within it one font size smaller, such as from to . A generic inline container for phrasing content, which does not inherently represent anything. It can be used to group elements for styling purposes (using the or attributes), or because they share attribute values, such as . It should be used only when no other semantic element is appropriate. is very much like a div element, but div is a block-level element whereas a is an inline-level element. Indicates that its contents have strong importance, seriousness, or urgency. Browsers typically render the contents in bold type. Specifies inline text which should be displayed as subscript for solely typographical reasons. Subscripts are typically rendered with a lowered baseline using smaller text. Specifies inline text which is to be displayed as superscript for solely typographical reasons. Superscripts are usually rendered with a raised baseline using smaller text. Represents a specific period in time. It may include the attribute to translate dates into machine-readable format, allowing for better search engine results or custom features such as reminders. Represents a span of inline text which should be rendered in a way that indicates that it has a non-textual annotation. This is rendered by default as a single solid underline but may be altered using CSS. Represents the name of a variable in a mathematical expression or a programming context. It's typically presented using an italicized version of the current typeface, although that behavior is browser-dependent. Represents a word break opportunity—a position within text where the browser may optionally break a line, though its line-breaking rules would not otherwise create a break at that location.\n\nWarning: These are old HTML elements that are deprecated and should not be used. You should never use them in new projects, and you should replace them in old projects as soon as you can. They are listed here for completeness only. Allows authors to clearly indicate a sequence of characters that compose an acronym or abbreviation for a word. Renders the enclosed text at a font size one level larger than the surrounding text ( becomes , for example). The size is capped at the browser's maximum permitted font size. Displays its block-level or inline contents centered horizontally within its containing element. An obsolete part of the Web Components suite of technologies—was used inside of Shadow DOM as an insertion point, and wasn't meant to be used in ordinary HTML. It has now been replaced by the element, which creates a point in the DOM at which a shadow DOM can be inserted. Consider using instead. Container for a directory of files and/or folders, potentially with styles and icons applied by the user agent. Do not use this obsolete element; instead, you should use the element for lists, including lists of files. Defines the font size, color and face for its content. Defines a particular area in which another HTML document can be displayed. A frame should be used within a . Used to contain elements. An ancient and poorly supported precursor to the element. It should not be used. Used to insert a scrolling area of text. You can control what happens when the text reaches the edges of its content area using its attributes. Represents a command that a user is able to invoke through a popup menu. This includes context menus, as well as menus that might be attached to a menu button. Prevents the text it contains from automatically wrapping across multiple lines, potentially resulting in the user having to scroll horizontally to see the entire width of the text. An obsolete, non-standard way to provide alternative, or \"fallback\", content for browsers that do not support the embed element or do not support the type of embedded content an author wishes to use. This element was deprecated in HTML 4.01 and above in favor of placing fallback content between the opening and closing tags of an element. Provides content to be presented in browsers that don't support (or have disabled support for) the element. Although most commonly-used browsers support frames, there are exceptions, including certain special-use browsers including some mobile browsers, as well as text-mode browsers. Renders everything following the start tag as raw text, ignoring any following HTML. There is no closing tag, since everything after it is considered raw text. Used to delimit the base text component of a ruby annotation, i.e. the text that is being annotated. One element should wrap each separate atomic segment of the base text. Embraces semantic annotations of characters presented in a ruby of elements used inside of element. elements can have both pronunciation ( ) and semantic ( ) annotations. An obsolete part of the Web Components technology suite that was intended to be used as a shadow DOM insertion point. You might have used it if you have created multiple shadow roots under a shadow host. Consider using instead. Creates inline text which is presented using the user agent default monospace font face. This element was created for the purpose of rendering text as it would be displayed on a fixed-width display such as a teletype, text-only screen, or line printer. Renders text between the start and end tags without interpreting the HTML in between and using a monospaced font. The HTML2 specification recommended that it should be rendered wide enough to allow 80 characters per line."
    },
    {
        "link": "https://w3.org/TR/2011/WD-html5-author-20110809/the-script-element.html",
        "document": "The element allows authors to include dynamic script and data blocks in their documents. The element does not represent content for the user.\n\nWhen used to include dynamic scripts, the scripts may either be embedded inline or may be imported from an external file using the attribute. If the language is not that described by \" \", then the attribute must be present, as described below. Whatever language is used, the contents of the element must conform with the requirements of that language's specification.\n\nWhen used to include data blocks (as opposed to scripts), the data must be embedded inline, the format of the data must be given using the attribute, the attribute must not be specified, and the contents of the element must conform to the requirements defined for the format used.\n\nThe attribute gives the language of the script or format of the data. If the attribute is present, its value must be a valid MIME type. The parameter must not be specified. The default, which is used if the attribute is absent, is \" \".\n\nThe attribute, if specified, gives the address of the external script resource to use. The value of the attribute must be a valid non-empty URL potentially surrounded by spaces identifying a script resource of the type given by the attribute, if the attribute is present, or of the type \" \", if the attribute is absent. A resource is a script resource of a given type if that type identifies a scripting language and the resource conforms with the requirements of that language's specification.\n\nThe attribute gives the character encoding of the external script resource. The attribute must not be specified if the attribute is not present. If the attribute is set, its value must be a valid character encoding name, must be an ASCII case-insensitive match for the preferred MIME name for that encoding, and must match the encoding given in the parameter of the Content-Type metadata of the external file, if any. [IANACHARSET]\n\nThe and attributes are boolean attributes that indicate how the script should be executed. The and attributes must not be specified if the attribute is not present.\n\nThere are three possible modes that can be selected using these attributes. If the attribute is present, then the script will be executed asynchronously, as soon as it is available. If the attribute is not present but the attribute is present, then the script is executed when the page has finished parsing. If neither attribute is present, then the script is fetched and executed immediately, before the user agent continues parsing the page.\n\nThe exact processing details for these attributes are, for mostly historical reasons, somewhat non-trivial, involving a number of aspects of HTML. The implementation requirements are therefore by necessity scattered throughout the specification. The algorithms below (in this section) describe the core of this processing, but these algorithms reference and are referenced by the parsing rules for start and end tags in HTML, in foreign content, and in XML, the rules for the method, the handling of scripting, etc.\n\nThe attribute may be specified even if the attribute is specified, to cause legacy Web browsers that only support (and not ) to fall back to the behavior instead of the synchronous blocking behavior that is the default.\n\nChanging the , , , , and attributes dynamically has no direct effect; these attribute are only used at specific times described below.\n\nThe IDL attributes , , , and , each must reflect the respective content attributes of the same name.\n\nThe IDL attribute controls whether the element will execute asynchronously or not. If the element's \"force-async\" flag is set, then, on getting, the IDL attribute must return true, and on setting, the \"force-async\" flag must first be unset, and then the content attribute must be removed if the IDL attribute's new value is false, and must be set to the empty string if the IDL attribute's new value is true. If the element's \"force-async\" flag is not set, the IDL attribute must reflect the content attribute.\n\nWhen inserted using the method, elements execute (typically synchronously), but when inserted using and attributes, they do not execute at all.\n\nIn this example, two elements are used. One embeds an external script, and the other includes some data. The data in this case might be used by the script to generate the map of a video game. The data doesn't have to be used that way, though; maybe the map data is actually embedded in other parts of the page's markup, and the data block here is just used by the site's search engine to help users who are looking for particular features in their game maps.\n\nThe following lists some MIME type strings and the languages to which they refer:\n\nThe of a element must match the production in the following ABNF, the character set for which is Unicode. [ABNF]\n\nWhen a element contains script documentation, there are further restrictions on the contents of the element, as described in the section below.\n\nIf a element's attribute is specified, then the contents of the element, if any, must be such that the value of the IDL attribute, which is derived from the element's contents, matches the production in the following ABNF, the character set for which is Unicode. [ABNF]\n\nThis corresponds to putting the contents of the element in JavaScript comments.\n\nThis requirement is in addition to the earlier restrictions on the syntax of contents of elements."
    },
    {
        "link": "https://w3schools.com/html/html5_semantic_elements.asp",
        "document": "A semantic element clearly describes its meaning to both the browser and the developer.\n\nExamples of non-semantic elements: and - Tells nothing about its content.\n\nExamples of semantic elements: , , and - Clearly defines its content.\n\nMany web sites contain HTML code like: <div id=\"nav\"> <div class=\"header\"> <div id=\"footer\"> to indicate navigation, header, and footer.\n\nIn HTML there are several semantic elements that can be used to define different parts of a web page:\n\nAccording to W3C's HTML documentation: \"A section is a thematic grouping of content, typically with a heading.\"\n\nExamples of where a element can be used:\n\nA web page could normally be split into sections for introduction, content, and contact information.\n\nAn article should make sense on its own, and it should be possible to distribute it independently from the rest of the web site.\n\nExamples of where the element can be used:\n\nCan we use the definitions to decide how to nest those elements? No, we cannot!\n\nSo, you will find HTML pages with elements containing elements, and elements containing elements.\n\nThe element represents a container for introductory content or a set of navigational links.\n• one or more heading elements (<h1> - <h6>)\n\nNote: You can have several elements in one HTML document. However, cannot be placed within a , or another element.\n\nThe element defines a footer for a document or section.\n\nYou can have several elements in one document.\n\nThe element defines some content aside from the content it is placed in (like a sidebar).\n\nThe content should be indirectly related to the surrounding content.\n\nThe tag specifies self-contained content, like illustrations, diagrams, photos, code listings, etc.\n\nThe tag defines a caption for a element. The element can be placed as the first or as the last child of a element.\n\nAccording to the W3C: \"A semantic Web allows data to be shared and reused across applications, enterprises, and communities.\"\n\nBelow is a list of some of the semantic elements in HTML."
    },
    {
        "link": "https://stackoverflow.com/questions/436411/where-should-i-put-script-tags-in-html-markup",
        "document": "Here's what happens when a browser loads a website with a tag on it:\n• The browser requests the script file. Meanwhile, the parser blocks and stops parsing the other HTML on your page.\n• After some time the script is downloaded and subsequently executed.\n• The parser continues parsing the rest of the HTML document.\n\n(*) without attribute or and not of module.\n\nStep #4 causes a bad user experience. Your website basically stops loading until you've downloaded all scripts. If there's one thing that users hate it's waiting for a website to load.\n\nWhy does this even happen?\n\nAny script can insert its own HTML via or other DOM manipulations. This implies that the parser has to wait until the script has been downloaded and executed before it can safely parse the rest of the document. After all, the script could have inserted its own HTML in the document.\n\nHowever, most JavaScript developers no longer manipulate the DOM while the document is loading. Instead, they wait until the document has been loaded before modifying it. For example:\n\nBecause your browser does not know my-script.js isn't going to modify the document until it has been downloaded and executed, the parser stops parsing.\n\nThe old approach to solving this problem was to put tags at the bottom of your , because this ensures the parser isn't blocked until the very end.\n\nThis approach has its own problem: the browser cannot start downloading the scripts until the entire document is parsed. For larger websites with large scripts and stylesheets, being able to download the script as soon as possible is very important for performance. If your website doesn't load within 2 seconds, people will go to another website.\n\nIn an optimal solution, the browser would start downloading your scripts as soon as possible, while at the same time parsing the rest of your document.\n\nToday, browsers support the and attributes on scripts. These attributes tell the browser it's safe to continue parsing while the scripts are being downloaded.\n\nScripts with the async attribute are executed asynchronously. This means the script is executed as soon as it's downloaded, without blocking the browser in the meantime. This implies that it's possible that script 2 is downloaded and executed before script 1.\n\nAccording to http://caniuse.com/#feat=script-async, 97.78% of all browsers support this.\n\nScripts with the defer attribute are executed in order (i.e. first script 1, then script 2). This also does not block the browser.\n\nUnlike async scripts, defer scripts are only executed after the entire document has been loaded.\n\nScripts that include will be treated as JavaScript modules and are loaded like red scripts.\n\nThe current state-of-the-art is to put scripts in the tag and use the or attributes. This allows your scripts to be downloaded ASAP without blocking your browser.\n\nThe good thing is that your website should still load correctly on the 2% of browsers that do not support these attributes while speeding up the other 98%."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener",
        "document": "Note: This feature is available in Web Workers. The method of the interface sets up a function that will be called whenever the specified event is delivered to the target. Common targets are , or its children, , and , but the target may be any object that supports events (such as ). Note: The method is the recommended way to register an event listener. The benefits are as follows:\n• It allows adding more than one handler for an event. This is particularly useful for libraries, JavaScript modules, or any other kind of code that needs to work well with other libraries or extensions.\n• In contrast to using an property, it gives you finer-grained control of the phase when the listener is activated (capturing vs. bubbling).\n• It works on any event target, not just HTML or SVG elements. The method works by adding a function, or an object that implements a function, to the list of event listeners for the specified event type on the on which it's called. If the function or object is already in the list of event listeners for this target, the function or object is not added a second time. Note: If a particular anonymous function is in the list of event listeners registered for a certain target, and then later in the code, an identical anonymous function is given in an call, the second function will also be added to the list of event listeners for that target. Indeed, anonymous functions are not identical even if defined using the same unchanging source-code called repeatedly, even if in a loop. Repeatedly defining the same unnamed function in such cases can be problematic. (See Memory issues, below.) If an event listener is added to an from inside another listener — that is, during the processing of the event — that event will not trigger the new listener. However, the new listener may be triggered during a later stage of event flow, such as during the bubbling phase.\n\nThe value of \"this\" within the handler It is often desirable to reference the element on which the event handler was fired, such as when using a generic handler for a set of similar elements. When attaching a handler function to an element using , the value of inside the handler will be a reference to the element. It will be the same as the value of the property of the event argument that is passed to the handler. my_element.addEventListener(\"click\", function (e) { console.log(this.className); // logs the className of my_element console.log(e.currentTarget === this); // logs `true` }); As a reminder, arrow functions do not have their own context. my_element.addEventListener(\"click\", (e) => { console.log(this.className); // WARNING: `this` is not `my_element` console.log(e.currentTarget === this); // logs `false` }); If an event handler (for example, ) is specified on an element in the HTML source, the JavaScript code in the attribute value is effectively wrapped in a handler function that binds the value of in a manner consistent with the ; an occurrence of within the code represents a reference to the element. <table id=\"my_table\" onclick=\"console.log(this.id);\"> <!-- `this` refers to the table; logs 'my_table' --> … </table> Note that the value of inside a function, called by the code in the attribute value, behaves as per standard rules. This is shown in the following example: <script> function logID() { console.log(this.id); } </script> <table id=\"my_table\" onclick=\"logID();\"> <!-- when called, `this` will refer to the global object --> … </table> The value of within is a reference to the global object (or in the case of strict mode. Specifying \"this\" using bind() The method lets you establish a fixed context for all subsequent calls — bypassing problems where it's unclear what will be, depending on the context from which your function was called. Note, however, that you'll need to keep a reference to the listener around so you can remove it later. This is an example with and without : class Something { name = \"Something Good\"; constructor(element) { // bind causes a fixed `this` context to be assigned to `onclick2` this.onclick2 = this.onclick2.bind(this); element.addEventListener(\"click\", this.onclick1, false); element.addEventListener(\"click\", this.onclick2, false); // Trick } onclick1(event) { console.log(this.name); // undefined, as `this` is the element } onclick2(event) { console.log(this.name); // 'Something Good', as `this` is bound to the Something instance } } const s = new Something(document.body); Another solution is using a special function called to catch any events: class Something { name = \"Something Good\"; constructor(element) { // Note that the listeners in this case are `this`, not this.handleEvent element.addEventListener(\"click\", this, false); element.addEventListener(\"dblclick\", this, false); } handleEvent(event) { console.log(this.name); // 'Something Good', as this is bound to newly created object switch (event.type) { case \"click\": // some code here… break; case \"dblclick\": // some code here… break; } } } const s = new Something(document.body); Another way of handling the reference to is to use an arrow function, which doesn't create a separate context. class SomeClass { name = \"Something Good\"; register() { window.addEventListener(\"keydown\", (e) => { this.someMethod(e); }); } someMethod(e) { console.log(this.name); switch (e.code) { case \"ArrowUp\": // some code here… break; case \"ArrowDown\": // some code here… break; } } } const myObject = new SomeClass(); myObject.register();\n\nconst elts = document.getElementsByTagName(\"*\"); // Case 1 for (const elt of elts) { elt.addEventListener( \"click\", (e) => { // Do something }, false, ); } // Case 2 function processEvent(e) { // Do something } for (const elt of elts) { elt.addEventListener(\"click\", processEvent, false); } In the first case above, a new (anonymous) handler function is created with each iteration of the loop. In the second case, the same previously declared function is used as an event handler, which results in smaller memory consumption because there is only one handler function created. Moreover, in the first case, it is not possible to call because no reference to the anonymous function is kept (or here, not kept to any of the multiple anonymous functions the loop might create.) In the second case, it's possible to do because is the function reference. Actually, regarding memory consumption, the lack of keeping a function reference is not the real issue; rather it is the lack of keeping a static function reference.\n\nIf an event has a default action — for example, a event that scrolls the container by default — the browser is in general unable to start the default action until the event listener has finished, because it doesn't know in advance whether the event listener might cancel the default action by calling . If the event listener takes too long to execute, this can cause a noticeable delay, also known as jank, before the default action can be executed. By setting the option to , an event listener declares that it will not cancel the default action, so the browser can start the default action immediately, without waiting for the listener to finish. If the listener does then call , this will have no effect. The specification for defines the default value for the option as always being . However, to realize the scroll performance benefits of passive listeners in legacy code, modern browsers have changed the default value of the option to for the , , and events on the document-level nodes , , and . That prevents the event listener from canceling the event, so it can't block page rendering while the user is scrolling. Because of that, when you want to override that behavior and ensure the option is , you must explicitly set the option to (rather than relying on the default). You don't need to worry about the value of for the basic event. Since it can't be canceled, event listeners can't block page rendering anyway. See Improving scroll performance using passive listeners for an example showing the effect of passive listeners.\n\nThe following example shows the effect of setting . It includes a that contains some text, and a check box. <div id=\"container\"> <p> But down there it would be dark now, and not the lovely lighted aquarium she imagined it to be during the daylight hours, eddying with schools of tiny, delicate animals floating and dancing slowly to their own serene currents and creating the look of a living painting. That was wrong, in any case. The ocean was different from an aquarium, which was an artificial environment. The ocean was a world. And a world is not art. Dorothy thought about the living things that moved in that world: large, ruthless and hungry. Like us up here. </p> </div> <div> <input type=\"checkbox\" id=\"passive\" name=\"passive\" checked /> <label for=\"passive\">passive</label> </div> The code adds a listener to the container's event, which by default scrolls the container. The listener runs a long-running operation. Initially the listener is added with the option, and whenever the checkbox is toggled, the code toggles the option. const passive = document.querySelector(\"#passive\"); passive.addEventListener(\"change\", (event) => { container.removeEventListener(\"wheel\", wheelHandler); container.addEventListener(\"wheel\", wheelHandler, { passive: passive.checked, once: true, }); }); const container = document.querySelector(\"#container\"); container.addEventListener(\"wheel\", wheelHandler, { passive: true, once: true, }); function wheelHandler() { function isPrime(n) { for (let c = 2; c <= Math.sqrt(n); ++c) { if (n % c === 0) { return false; } } return true; } const quota = 1000000; const primes = []; const maximum = 1000000; while (primes.length < quota) { const candidate = Math.floor(Math.random() * (maximum + 1)); if (isPrime(candidate)) { primes.push(candidate); } } console.log(primes); }\n• Initially, the listener is passive, so trying to scroll the container with the wheel is immediate.\n• If you uncheck \"passive\" and try to scroll the container using the wheel, then there is a noticeable delay before the container scrolls, because the browser has to wait for the long-running listener to finish."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Scripting/Events",
        "document": "Events are things that happen in the system you are programming, which the system tells you about so your code can react to them. For example, if the user clicks a button on a webpage, you might want to react to that action by displaying an information box. In this article, we discuss some important concepts surrounding events, and look at the fundamentals of how they work in browsers. An understanding of HTML and the fundamentals of CSS, familiarity with JavaScript basics as covered in previous lessons.\n• What events are — a signal fired by the browser when something significant happens, which the developer can run some code in response to.\n• Setting up event handlers using (and ) and event handler properties.\n• Inline event handler attributes, and why you shouldn't use them.\n\nWhat is an event? Events are things that happen in the system you are programming — the system produces (or \"fires\") a signal of some kind when an event occurs, and provides a mechanism by which an action can be automatically taken (that is, some code running) when the event occurs. Events are fired inside the browser window, and tend to be attached to a specific item that resides in it. This might be a single element, a set of elements, the HTML document loaded in the current tab, or the entire browser window. There are many different types of events that can occur.\n• The user selects, clicks, or hovers the cursor over a certain element.\n• The user presses a key on the keyboard.\n• The user resizes or closes the browser window. You can gather from this (and from glancing at the MDN event reference) that there are a lot of events that can be fired. To react to an event, you attach an event handler to it. This is a block of code (usually a JavaScript function that you as a programmer create) that runs when the event fires. When such a block of code is defined to run in response to an event, we say we are registering an event handler. Note: Event handlers are sometimes called event listeners — they are pretty much interchangeable for our purposes, although strictly speaking, they work together. The listener listens out for the event happening, and the handler is the code that runs in response to it happening. Note: Web events are not part of the core JavaScript language — they are defined as part of the APIs built into the browser.\n\nIn the following example, we have a single in the page: Then we have some JavaScript. We'll look at this in more detail in the next section, but for now we can just say: it adds an event handler to the button's event, and the handler reacts to the event by setting the page background to a random color: The example output is as follows. Try clicking the button:\n\nIf you've added an event handler using , you can remove it again using the method. For example, this would remove the event handler: Event handlers can also be removed by passing an to and then later calling on the controller owning the . For example, to add an event handler that we can remove with an : const controller = new AbortController(); btn.addEventListener(\"click\", () => { const rndCol = `rgb(${random(255)} ${random(255)} ${random(255)})`; document.body.style.backgroundColor = rndCol; }, { signal: controller.signal } // pass an AbortSignal to this handler ); Then the event handler created by the code above can be removed like this: controller.abort(); // removes any/all event handlers associated with this controller For simple, small programs, cleaning up old, unused event handlers isn't necessary, but for larger, more complex programs, it can improve efficiency. Also, the ability to remove event handlers allows you to have the same button performing different actions in different circumstances: all you have to do is add or remove handlers.\n\nObjects (such as buttons) that can fire events also usually have properties whose name is followed by the name of the event. For example, elements have a property . This is called an event handler property. To listen for the event, you can assign the handler function to the property. For example, we could rewrite the random-color example like this: You can also set the handler property to a named function: With event handler properties, you can't add more than one handler for a single event. For example, you can call on an element multiple times, with different functions specified in the second argument: This is impossible with event handler properties because any subsequent attempts to set the property will overwrite earlier ones:\n\nYou might also see a pattern like this in your code: The earliest method of registering event handlers found on the Web involved event handler HTML attributes (or inline event handlers) like the one shown above — the attribute value is literally the JavaScript code you want to run when the event occurs. The above example invokes a function defined inside a element on the same page, but you could also insert JavaScript directly inside the attribute, for example: <button onclick=\"alert('Hello, this is my old-fashioned event handler!');\"> Press me </button> You can find HTML attribute equivalents for many of the event handler properties; however, you shouldn't use these — they are considered bad practice. It might seem easy to use an event handler attribute if you are doing something really quick, but they quickly become unmanageable and inefficient. For a start, it is not a good idea to mix up your HTML and your JavaScript, as it becomes hard to read. Keeping your JavaScript separate is a good practice, and if it is in a separate file you can apply it to multiple HTML documents. Even in a single file, inline event handlers are not a good idea. One button is OK, but what if you had 100 buttons? You'd have to add 100 attributes to the file; it would quickly turn into a maintenance nightmare. With JavaScript, you could easily add an event handler function to all the buttons on the page no matter how many there were, using something like this: Finally, many common server configurations will disallow inline JavaScript, as a security measure. You should never use the HTML event handler attributes — those are outdated, and using them is bad practice.\n\nSometimes, inside an event handler function, you'll see a parameter specified with a name such as , , or . This is called the event object, and it is automatically passed to event handlers to provide extra features and information. For example, let's rewrite our random color example again slightly: Note: You can find the full source code for this example on GitHub (also see it running live). Here you can see we are including an event object, e, in the function, and in the function setting a background color style on — which is the button itself. The property of the event object is always a reference to the element the event occurred upon. So, in this example, we are setting a random background color on the button, not the page. Note: You can use any name you like for the event object — you just need to choose a name that you can then use to reference it inside the event handler function. / / is most commonly used by developers because they are short and easy to remember. It's always good to be consistent — with yourself, and with others if possible.\n\nSometimes, you'll come across a situation where you want to prevent an event from doing what it does by default. The most common example is that of a web form, for example, a custom registration form. When you fill in the details and click the submit button, the natural behavior is for the data to be submitted to a specified page on the server for processing, and the browser to be redirected to a \"success message\" page of some kind (or the same page, if another is not specified). The trouble comes when the user has not submitted the data correctly — as a developer, you want to prevent the submission to the server and give an error message saying what's wrong and what needs to be done to put things right. Some browsers support automatic form data validation features, but since many don't, you are advised to not rely on those and implement your own validation checks. Let's look at an example. First, a simple HTML form that requires you to enter your first and last name: Now some JavaScript — here we implement a very simple check inside a handler for the event (the submit event is fired on a form when it is submitted) that tests whether the text fields are empty. If they are, we call the function on the event object — which stops the form submission — and then display an error message in the paragraph below our form to tell the user what's wrong: const form = document.querySelector(\"form\"); const fname = document.getElementById(\"fname\"); const lname = document.getElementById(\"lname\"); const para = document.querySelector(\"p\"); form.addEventListener(\"submit\", (e) => { if (fname.value === \"\" || lname.value === \"\") { e.preventDefault(); para.textContent = \"You need to fill in both names!\"; } }); Obviously, this is pretty weak form validation — it wouldn't stop the user from validating the form with spaces or numbers entered into the fields, for example — but it is OK for example purposes. The output is as follows: Note: For the full source code, see preventdefault-validation.html (also see it running live here)."
    },
    {
        "link": "https://w3schools.com/js/js_htmldom_eventlistener.asp",
        "document": "The method attaches an event handler to the specified element.\n\nThe method attaches an event handler to an element without overwriting existing event handlers.\n\nYou can add many event handlers to one element.\n\nYou can add many event handlers of the same type to one element, i.e two \"click\" events.\n\nYou can add event listeners to any DOM object not only HTML elements. i.e the window object.\n\nThe method makes it easier to control how the event reacts to bubbling.\n\nWhen using the method, the JavaScript is separated from the HTML markup, for better readability and allows you to add event listeners even when you do not control the HTML markup.\n\nYou can easily remove an event listener by using the method.\n\n\n\nThe first parameter is the type of the event (like \" \" or \" \" or any other HTML DOM Event.)\n\nThe second parameter is the function we want to call when the event occurs.\n\nThe third parameter is a boolean value specifying whether to use event bubbling or event capturing. This parameter is optional.\n\nAdd an Event Handler to an Element\n\nYou can also refer to an external \"named\" function:\n\nAdd Many Event Handlers to the Same Element\n\nThe method allows you to add many events to the same element, without overwriting existing events:\n\nYou can add events of different types to the same element:\n\nAdd an Event Handler to the window Object\n\nThe method allows you to add event listeners on any HTML DOM object such as HTML elements, the HTML document, the window object, or other objects that support events, like the object.\n\nWhen passing parameter values, use an \"anonymous function\" that calls the specified function with the parameters:\n\nThere are two ways of event propagation in the HTML DOM, bubbling and capturing.\n\nEvent propagation is a way of defining the element order when an event occurs. If you have a <p> element inside a <div> element, and the user clicks on the <p> element, which element's \"click\" event should be handled first?\n\nIn bubbling the inner most element's event is handled first and then the outer: the <p> element's click event is handled first, then the <div> element's click event.\n\nIn capturing the outer most element's event is handled first and then the inner: the <div> element's click event will be handled first, then the <p> element's click event.\n\nWith the addEventListener() method you can specify the propagation type by using the \"useCapture\" parameter:\n\nThe default value is false, which will use the bubbling propagation, when the value is set to true, the event uses the capturing propagation.\n\nThe method removes event handlers that have been attached with the addEventListener() method:\n\nFor a list of all HTML DOM events, look at our complete HTML DOM Event Object Reference."
    },
    {
        "link": "https://sencha.com/blog/event-handling-in-javascript-a-practical-guide-with-examples",
        "document": "Back in the day, websites used to be static, meaning users could only view the content but not interact with it. However, we can now create highly interactive user interfaces thanks to JavaScript and JS frameworks. Specifically, event handlers in JavaScript are what allow us to build dynamic web pages and deliver interactive experiences. In the modern web development landscape, events are essentially user actions that occur as a result of user interaction with the web page, such as submitting a form, clicking a button, playing a video on the web page, minimizing the browser window, etc. Event handling allows developers to verify and handle these actions to deliver a more responsive and engaging user experience.\n\nHence, understanding how events work and how to handle them efficiently is essential for every developer looking to create modern web applications. This article will discuss all the ins and outs of event handling in JavaScript. We’ll also briefly discuss how a good JavaScript framework like Ext JS handles events.\n\nEvents are essentially the actions that occur on a web app due to user interaction, such as clicking a button. In JavaScript, when an event occurs, the app fires the event, which is kind of a signal that an event has occurred. The app then automatically responds to the user in the form of output, thanks to event handlers in JavaScript. An event handler is essentially a function with a block of code that is executed or triggered when a specific event fires.\n\nSometimes, when an event occurs, it triggers multiple events. This is because web elements in an app are often nested. This is where event propagation comes in. Event propagation involves capturing and bubbling phases as the event travels across the DOM hierarchy. We’ll discuss these phases later in the article.\n\nThere are common types of events:\n• Keyboard/touch events: Occur when a user presses or releases a key on the keyboard or performs an action with a touch-enabled smartphone, laptop or tablet.\n• Click events: Fires when a user clicks on a button or other such web element.\n• Mouse hover events: These events are fired when a user performs an action with the mouse, such as scrolling a page or moving the cursor.\n• Form/submit events: Triggered when a user submits a form, modifies it, or resets it.\n• Drag and drop events: Occurs when a user drags and drops an element on the web page, such as dragging and dropping an image on a file uploader.\n\nAn event listener is essentially a JavaScript function that waits for a specific event to occur and then executes a callback function to respond to that event. Event listeners and event handlers are often considered the same thing. However, in essence, they work together to respond to an event. As the name suggests, the listener listens for the event, and the handler is the code that is executed in response to that event.\n\nThere are two common built-in event listener methods in JavaScript: addEventListener and removeEventListener. The addEventListener() method enables us to attach an event handler to an element. We can also add multiple event handlers to an element. removeEventListener() allows us to remove an event listener/handler from a specific element.\n\nWhen an event occurs, it belongs to a specific event object. The event object is essentially the argument passed into the callback/event handler function. It provides information about the event, such as the target element, the type of event, etc. It also contains additional properties for the specific event type.\n• target: Represents the element that fired the event.\n• type: Tells about the specific type of the event, such as click or submit\n• keyCode: Used for keyboard events. It contains the Unicode value of the key pressed by the user\n\nHere is an example code demonstrating the use of the event object (Click event):\n\nBased on the concepts we discussed in the previous sections, here is an example for creating a simple button-click event:\n\nHere is a basic example demonstrating how to handle form submissions:\n\nWeb browsers often have a default behavior for certain events. When such an event occurs, the browser’s default behavior is triggered in response to that event. preventDefault() provides us with a way to stop or prevent this default behavior.\n\nFor instance, when a user submits a form, the browser automatically initializes a request to the server. This results in page reload or navigation to a new page, affecting the user experience. Developers can use preventDefault() to stop this default behavior and handle form submission asynchronously without causing a page to reload. For example, in the above code, we’ve used preventDefault() to stop or prevent the default form submission behavior.\n\nEvent delegation in JavaScript is an advanced technique for handling events more efficiently. In event delegation, we add or attach an event listener/listeners to a common parent element. This way, we don’t have to attach the event listener to each element separately. Events are processed and monitored as they traverse the DOM hierarchy. Event delegation is common in popular javascript frameworks\n\nHere is an example of event delegation:\n\nHandling keyboard events, such as key down and key up, allows us to:\n• Respond to user interactions/inputs with the keyboard\n\nKey Down and Key Up are two main types of mouse events. A key-down event occurs when a user presses a key on the keyboard. A key-up event is triggered when a user releases the key after it is pressed down.\n\nHere is an example code for handling a key-down event:\n\nHere is an example code for handling a key-up event:\n\nHandling touch and mobile events to create a responsive and touch-friendly design, providing an intuitive way to interact with the web app.\n\nHere is an example code for Touchstart, Touchmove, and Touchend:\n• Gesture events, such as gesturestart, gesturechange, and gestureend. These events are used for gestures like pinch-zoom.\n• orientationchange event used for detecting changes in device orientation.\n\nAlso Read: Angular vs Ext JS: Which JavaScript Framework Should You Use?\n\nAs aforementioned, event bubbling and capturing are a part of the event propagation process. In event bubbling, the event starts from the same target element that fired the event. It then bubbles up or propagates through its parent and ancestor elements in the DOM till it reaches the root element. This allows you to handle the event in a parent element instead of the target element. Event bubbling is the default event behaviour on elements.\n\nIn event capturing, the event traverses from the outermost parent or ancestor element to the target element. It is also called event trickling.\n\nJavaScript also allows you to create and dispatch custom events designed to meet your specific application needs. For instance, you can create custom events for cross-component state management.\n\nHere is how to create a custom event:\n\nHere is how to dispatch the event:\n• Combine multiple events that trigger similar actions into one event listener.\n• Use event capturing only when needed. Otherwise, use bubbling.\n\nExt JS is a leading Javascript framework for creating high-performance web and mobile applications. It offers over 140+ pre-built components and supports MVVM architecture and two-way data binding. Events are a core concept in the Ext JS framework that enables your code to react to changes in your app. Here is an example code for button-click event in Ext JS:\n\nYou can learn more about handling events in Ext JS here.\n\nTransform your digital landscape with Sencha: Master JavaScript frameworks for unrivalled web development excellence\n\nIn the web development process, events refer to user actions, such as such as clicking a button, minimizing the browser window, or submitting a form. Event handling in JavaScript and JavaScript frameworks allows us to respond to user actions and interactions and create dynamic and interactive websites. This article explores various concerts related to event handling in JavaScript with examples.\n\nWhat is event handling in JavaScript?\n\nEvent handling in JS refers to using event listeners to wait for an event to occur on an element and responding to that event using event handlers or callback functions.\n\nHow do I attach an event listener to an element?\n\nYou can use JavaScript’s built-in addEventListener() method to attach an event to an element.\n\nWhat is the event object in JavaScript?\n\nThe event object in JS is essentially the argument passed into the callback/event handler function. It provides valuable information about the event, such as the target element, the type of event, etc.\n\nWhat are the most popular JavaScript frameworks?\n\nBest JavaScript frameworks and JavaScript libraries include Ext JS, React and Angular. Ext JS offers 140+ high-performance pre-built components for developing web applications quickly. React is another popular JavaScript framework known for creating customized and reusable elements and virtual DOM. Angular is another open-source JavaScript framework that utilizes component-based architecture and allows developers to build high-performance single-page applications."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/Events/Event_handlers",
        "document": "Events are signals fired inside the browser window that notify of changes in the browser or operating system environment. Programmers can create event handler code that will run when an event fires, allowing web pages to respond appropriately to change. This page provides a very brief \"reminder\" of how to work with events and event handlers. New developers should instead read Introduction to events.\n\nWhat are the available events? Events are documented in and/or below the pages for the JavaScript objects that emit them. For example, to find out events fired on the browser window or the current document see the events sections in and . You can use the Event reference to find out what JavaScript objects fire events for particular APIs, e.g. animation, media, and so on.\n\nThere are two recommended approaches for registering handlers. Event handler code can be made to run when an event is triggered by assigning it to the target element's corresponding onevent property, or by registering the handler as a listener for the element using the method. In either case the handler will receive an object that conforms to the interface (or a derived interface). The main difference is that multiple event handlers can be added (or removed) using the event listener methods. Warning: A third approach for setting event handlers using HTML onevent attributes is not recommended! They inflate the markup and make it less readable and harder to debug. For more information see Inline event handlers.\n\nBy convention, JavaScript objects that fire events have a corresponding \"onevent\" properties (named by prefixing \"on\" to the name of the event). These properties are called to run associated handler code when the event is fired, and may also be called directly by your own code. To set event handler code you can just assign it to the appropriate onevent property. Only one event handler can be assigned for every event in an element. If needed the handler can be replaced by assigning another function to the same property. Below we show how to set a function for the event using the property. Note that an object representing the event is passed as the first argument to the event handler. This event object either implements or is derived from the interface.\n\nThe most flexible way to set an event handler on an element is to use the method. This approach allows multiple listeners to be assigned to an element, and for listeners to be removed if needed (using ). Note: The ability to add and remove event handlers allows you to, for example, have the same button performing different actions in different circumstances. In addition, in more complex programs cleaning up old/unused event handlers can improve efficiency. Below we show how a function can be set as a listener/event handler for the event (you could use an anonymous function expression instead of a named function if desired). Note again that the event is passed as the first argument to the event handler. The method can also take additional arguments/options to control aspects of how the events are captured and removed. More information can be found on the reference page. A notable event listener feature is the ability to use an abort signal to clean up multiple event handlers at the same time. This is done by passing the same to the call for all the event handlers that you want to be able to remove together. You can then call on the controller owning the , and it will remove all event handlers that were added with that signal. For example, to add an event handler that we can remove with an : const controller = new AbortController(); btn.addEventListener( \"click\", (event) => { console.log(\"greet:\", event); }, { signal: controller.signal }, ); // pass an AbortSignal to this handler Then the event handler created by the code above can be removed like this: controller.abort(); // removes any/all event handlers associated with this controller"
    }
]