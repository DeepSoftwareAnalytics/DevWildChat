[
    {
        "link": "https://typescriptlang.org/docs/handbook/2/classes.html",
        "document": "TypeScript offers full support for the keyword introduced in ES2015.\n\nAs with other JavaScript language features, TypeScript adds type annotations and other syntax to allow you to express relationships between classes and other types.\n\nHere’s the most basic class - an empty one:\n\nThis class isn’t very useful yet, so let’s start adding some members.\n\nAs with other locations, the type annotation is optional, but will be an implicit if not specified.\n\nFields can also have initializers; these will run automatically when the class is instantiated:\n\nJust like with , , and , the initializer of a class property will be used to infer its type:\n\nThe setting controls whether class fields need to be initialized in the constructor.\n\nNote that the field needs to be initialized in the constructor itself. TypeScript does not analyze methods you invoke from the constructor to detect initializations, because a derived class might override those methods and fail to initialize the members.\n\nIf you intend to definitely initialize a field through means other than the constructor (for example, maybe an external library is filling in part of your class for you), you can use the definite assignment assertion operator, :\n\nFields may be prefixed with the modifier. This prevents assignments to the field outside of the constructor.\n\nClass constructors are very similar to functions. You can add parameters with type annotations, default values, and overloads:\n\nThere are just a few differences between class constructor signatures and function signatures:\n• Constructors can’t have type parameters - these belong on the outer class declaration, which we’ll learn about later\n• Constructors can’t have return type annotations - the class instance type is always what’s returned\n\nJust as in JavaScript, if you have a base class, you’ll need to call in your constructor body before using any members:\n\nForgetting to call is an easy mistake to make in JavaScript, but TypeScript will tell you when it’s necessary.\n\nA function property on a class is called a method. Methods can use all the same type annotations as functions and constructors:\n\nOther than the standard type annotations, TypeScript doesn’t add anything else new to methods.\n\nNote that inside a method body, it is still mandatory to access fields and other methods via . An unqualified name in a method body will always refer to something in the enclosing scope:\n\nClasses can also have accessors:\n\nTypeScript has some special inference rules for accessors:\n• If exists but no , the property is automatically\n• If the type of the setter parameter is not specified, it is inferred from the return type of the getter\n\nSince TypeScript 4.3, it is possible to have accessors with different types for getting and setting.\n\nClasses can declare index signatures; these work the same as Index Signatures for other object types:\n\nBecause the index signature type needs to also capture the types of methods, it’s not easy to usefully use these types. Generally it’s better to store indexed data in another place instead of on the class instance itself.\n\nLike other languages with object-oriented features, classes in JavaScript can inherit from base classes.\n\nYou can use an clause to check that a class satisfies a particular . An error will be issued if a class fails to correctly implement it:\n\nIt’s important to understand that an clause is only a check that the class can be treated as the interface type. It doesn’t change the type of the class or its methods at all. A common source of error is to assume that an clause will change the class type - it doesn’t!\n\nIn this example, we perhaps expected that ’s type would be influenced by the parameter of . It is not - clauses don’t change how the class body is checked or its type inferred.\n\nSimilarly, implementing an interface with an optional property doesn’t create that property:\n\nClasses may from a base class. A derived class has all the properties and methods of its base class, and can also define additional members.\n\nA derived class can also override a base class field or property. You can use the syntax to access base class methods. Note that because JavaScript classes are a simple lookup object, there is no notion of a “super field”.\n\nTypeScript enforces that a derived class is always a subtype of its base class.\n\nFor example, here’s a legal way to override a method:\n\nIt’s important that a derived class follow its base class contract. Remember that it’s very common (and always legal!) to refer to a derived class instance through a base class reference:\n\nIf we compiled this code despite the error, this sample would then crash:\n\nWhen or is , class fields are initialized after the parent class constructor completes, overwriting any value set by the parent class. This can be a problem when you only want to re-declare a more accurate type for an inherited field. To handle these cases, you can write to indicate to TypeScript that there should be no runtime effect for this field declaration.\n\nThe order that JavaScript classes initialize can be surprising in some cases. Let’s consider this code:\n\nThe order of class initialization, as defined by JavaScript, is:\n\nThis means that the base class constructor saw its own value for during its own constructor, because the derived class field initializations hadn’t run yet.\n\nIn ES2015, constructors which return an object implicitly substitute the value of for any callers of . It is necessary for generated constructor code to capture any potential return value of and replace it with .\n\nAs a result, subclassing , , and others may no longer work as expected. This is due to the fact that constructor functions for , , and the like use ECMAScript 6’s to adjust the prototype chain; however, there is no way to ensure a value for when invoking a constructor in ECMAScript 5. Other downlevel compilers generally have the same limitation by default.\n\nFor a subclass like the following:\n\nyou may find that:\n• methods may be on objects returned by constructing these subclasses, so calling will result in an error.\n• will be broken between instances of the subclass and their instances, so will return .\n\nAs a recommendation, you can manually adjust the prototype immediately after any calls.\n\nHowever, any subclass of will have to manually set the prototype as well. For runtimes that don’t support , you may instead be able to use .\n\nUnfortunately, these workarounds will not work on Internet Explorer 10 and prior. One can manually copy methods from the prototype onto the instance itself (i.e. onto ), but the prototype chain itself cannot be fixed.\n\nYou can use TypeScript to control whether certain methods or properties are visible to code outside the class.\n\nThe default visibility of class members is . A member can be accessed anywhere:\n\nBecause is already the default visibility modifier, you don’t ever need to write it on a class member, but might choose to do so for style/readability reasons.\n\nmembers are only visible to subclasses of the class they’re declared in.\n\nDerived classes need to follow their base class contracts, but may choose to expose a subtype of base class with more capabilities. This includes making members :\n\nNote that was already able to freely read and write , so this doesn’t meaningfully alter the “security” of this situation. The main thing to note here is that in the derived class, we need to be careful to repeat the modifier if this exposure isn’t intentional.\n\nTypeScript doesn’t allow accessing members of a sibling class in a class hierarchy:\n\nThis is because accessing in should only be legal from ’s subclasses, and isn’t one of them. Moreover, if accessing through a reference is illegal (which it certainly should be!), then accessing it through a base class reference should never improve the situation.\n\nSee also Why Can’t I Access A Protected Member From A Derived Class? which explains more of C#‘s reasoning on the same topic.\n\nis like , but doesn’t allow access to the member even from subclasses:\n\nBecause members aren’t visible to derived classes, a derived class can’t increase their visibility:\n\nDifferent OOP languages disagree about whether different instances of the same class may access each others’ members. While languages like Java, C#, C++, Swift, and PHP allow this, Ruby does not.\n\nLike other aspects of TypeScript’s type system, and are only enforced during type checking.\n\nThis means that JavaScript runtime constructs like or simple property lookup can still access a or member:\n\nalso allows access using bracket notation during type checking. This makes -declared fields potentially easier to access for things like unit tests, with the drawback that these fields are soft private and don’t strictly enforce privacy.\n\nUnlike TypeScripts’s , JavaScript’s private fields ( ) remain private after compilation and do not provide the previously mentioned escape hatches like bracket notation access, making them hard private.\n\nWhen compiling to ES2021 or less, TypeScript will use WeakMaps in place of .\n\nIf you need to protect values in your class from malicious actors, you should use mechanisms that offer hard runtime privacy, such as closures, WeakMaps, or private fields. Note that these added privacy checks during runtime could affect performance.\n\nClasses may have members. These members aren’t associated with a particular instance of the class. They can be accessed through the class constructor object itself:\n\nStatic members can also use the same , , and visibility modifiers:\n\nIt’s generally not safe/possible to overwrite properties from the prototype. Because classes are themselves functions that can be invoked with , certain names can’t be used. Function properties like , , and aren’t valid to define as members:\n\nTypeScript (and JavaScript) don’t have a construct called the same way as, for example, C# does.\n\nThose constructs only exist because those languages force all data and functions to be inside a class; because that restriction doesn’t exist in TypeScript, there’s no need for them. A class with only a single instance is typically just represented as a normal object in JavaScript/TypeScript.\n\nFor example, we don’t need a “static class” syntax in TypeScript because a regular object (or even top-level function) will do the job just as well:\n\nStatic blocks allow you to write a sequence of statements with their own scope that can access private fields within the containing class. This means that we can write initialization code with all the capabilities of writing statements, no leakage of variables, and full access to our class’s internals.\n\nClasses, much like interfaces, can be generic. When a generic class is instantiated with , its type parameters are inferred the same way as in a function call:\n\nClasses can use generic constraints and defaults the same way as interfaces.\n\nThis code isn’t legal, and it may not be obvious why:\n\nRemember that types are always fully erased! At runtime, there’s only one property slot. This means that setting (if that were possible) would also change - not good. The members of a generic class can never refer to the class’s type parameters.\n\nIt’s important to remember that TypeScript doesn’t change the runtime behavior of JavaScript, and that JavaScript is somewhat famous for having some peculiar runtime behaviors.\n\nJavaScript’s handling of is indeed unusual:\n\nLong story short, by default, the value of inside a function depends on how the function was called. In this example, because the function was called through the reference, its value of was rather than the class instance.\n\nThis is rarely what you want to happen! TypeScript provides some ways to mitigate or prevent this kind of error.\n\nIf you have a function that will often be called in a way that loses its context, it can make sense to use an arrow function property instead of a method definition:\n\nThis has some trade-offs:\n• The value is guaranteed to be correct at runtime, even for code not checked with TypeScript\n• This will use more memory, because each class instance will have its own copy of each function defined this way\n• You can’t use in a derived class, because there’s no entry in the prototype chain to fetch the base class method from\n\nIn a method or function definition, an initial parameter named has special meaning in TypeScript. These parameters are erased during compilation:\n\nTypeScript checks that calling a function with a parameter is done so with a correct context. Instead of using an arrow function, we can add a parameter to method definitions to statically enforce that the method is called correctly:\n\nThis method makes the opposite trade-offs of the arrow function approach:\n• JavaScript callers might still use the class method incorrectly without realizing it\n• Only one function per class definition gets allocated, rather than one per class instance\n• Base method definitions can still be called via .\n\nIn classes, a special type called refers dynamically to the type of the current class. Let’s see how this is useful:\n\nHere, TypeScript inferred the return type of to be , rather than . Now let’s make a subclass of :\n\nYou can also use in a parameter type annotation:\n\nThis is different from writing — if you have a derived class, its method will now only accept other instances of that same derived class:\n\nYou can use in the return position for methods in classes and interfaces. When mixed with a type narrowing (e.g. statements) the type of the target object would be narrowed to the specified .\n\nA common use-case for a this-based type guard is to allow for lazy validation of a particular field. For example, this case removes an from the value held inside box when has been verified to be true:\n\nTypeScript offers special syntax for turning a constructor parameter into a class property with the same name and value. These are called parameter properties and are created by prefixing a constructor argument with one of the visibility modifiers , , , or . The resulting field gets those modifier(s):\n\nClass expressions are very similar to class declarations. The only real difference is that class expressions don’t need a name, though we can refer to them via whatever identifier they ended up bound to:\n\nJavaScript classes are instantiated with the operator. Given the type of a class itself, the InstanceType utility type models this operation.\n\nClasses, methods, and fields in TypeScript may be abstract.\n\nAn abstract method or abstract field is one that hasn’t had an implementation provided. These members must exist inside an abstract class, which cannot be directly instantiated.\n\nThe role of abstract classes is to serve as a base class for subclasses which do implement all the abstract members. When a class doesn’t have any abstract members, it is said to be concrete.\n\nLet’s look at an example:\n\nWe can’t instantiate with because it’s abstract. Instead, we need to make a derived class and implement the abstract members:\n\nNotice that if we forget to implement the base class’s abstract members, we’ll get an error:\n\nSometimes you want to accept some class constructor function that produces an instance of a class which derives from some abstract class.\n\nFor example, you might want to write this code:\n\nTypeScript is correctly telling you that you’re trying to instantiate an abstract class. After all, given the definition of , it’s perfectly legal to write this code, which would end up constructing an abstract class:\n\nInstead, you want to write a function that accepts something with a construct signature:\n\nNow TypeScript correctly tells you about which class constructor functions can be invoked - can because it’s concrete, but cannot.\n\nIn most cases, classes in TypeScript are compared structurally, the same as other types.\n\nFor example, these two classes can be used in place of each other because they’re identical:\n\nSimilarly, subtype relationships between classes exist even if there’s no explicit inheritance:\n\nThis sounds straightforward, but there are a few cases that seem stranger than others.\n\nEmpty classes have no members. In a structural type system, a type with no members is generally a supertype of anything else. So if you write an empty class (don’t!), anything can be used in place of it:"
    },
    {
        "link": "https://typescriptlang.org/docs/handbook/classes.html",
        "document": "Traditional JavaScript uses functions and prototype-based inheritance to build up reusable components, but this may feel a bit awkward to programmers more comfortable with an object-oriented approach, where classes inherit functionality and objects are built from these classes. Starting with ECMAScript 2015, also known as ECMAScript 6, JavaScript programmers can build their applications using this object-oriented class-based approach. In TypeScript, we allow developers to use these techniques now, and compile them down to JavaScript that works across all major browsers and platforms, without having to wait for the next version of JavaScript.\n\nLet’s take a look at a simple class-based example:\n\nThe syntax should look familiar if you’ve used C# or Java before. We declare a new class . This class has three members: a property called , a constructor, and a method .\n\nYou’ll notice that in the class when we refer to one of the members of the class we prepend . This denotes that it’s a member access.\n\nIn the last line we construct an instance of the class using . This calls into the constructor we defined earlier, creating a new object with the shape, and running the constructor to initialize it.\n\nIn TypeScript, we can use common object-oriented patterns. One of the most fundamental patterns in class-based programming is being able to extend existing classes to create new ones using inheritance.\n\nLet’s take a look at an example:\n\nThis example shows the most basic inheritance feature: classes inherit properties and methods from base classes. Here, is a derived class that derives from the base class using the keyword. Derived classes are often called subclasses, and base classes are often called superclasses.\n\nBecause extends the functionality from , we were able to create an instance of that could both and .\n\nLet’s now look at a more complex example.\n\nThis example covers a few other features we didn’t previously mention. Again, we see the keywords used to create two new subclasses of : and .\n\nOne difference from the prior example is that each derived class that contains a constructor function must call which will execute the constructor of the base class. What’s more, before we ever access a property on in a constructor body, we have to call . This is an important rule that TypeScript will enforce.\n\nThe example also shows how to override methods in the base class with methods that are specialized for the subclass. Here both and create a method that overrides the from , giving it functionality specific to each class. Note that even though is declared as an , since its value is a , calling will call the overriding method in :\n\nIn our examples, we’ve been able to freely access the members that we declared throughout our programs. If you’re familiar with classes in other languages, you may have noticed in the above examples we haven’t had to use the word to accomplish this; for instance, C# requires that each member be explicitly labeled to be visible. In TypeScript, each member is by default.\n\nYou may still mark a member explicitly. We could have written the class from the previous section in the following way:\n\nWith TypeScript 3.8, TypeScript supports the new JavaScript syntax for private fields:\n\nThis syntax is built into the JavaScript runtime and can have better guarantees about the isolation of each private field. Right now, the best documentation for these private fields is in the TypeScript 3.8 release notes.\n\nTypeScript also has its own way to declare a member as being marked , it cannot be accessed from outside of its containing class. For example:\n\nTypeScript is a structural type system. When we compare two different types, regardless of where they came from, if the types of all members are compatible, then we say the types themselves are compatible.\n\nHowever, when comparing types that have and members, we treat these types differently. For two types to be considered compatible, if one of them has a member, then the other must have a member that originated in the same declaration. The same applies to members.\n\nLet’s look at an example to better see how this plays out in practice:\n\nIn this example, we have an and a , with being a subclass of . We also have a new class that looks identical to in terms of shape. We create some instances of these classes and then try to assign them to each other to see what will happen. Because and share the side of their shape from the same declaration of in , they are compatible. However, this is not the case for . When we try to assign from an to we get an error that these types are not compatible. Even though also has a member called , it’s not the one we declared in .\n\nThe modifier acts much like the modifier with the exception that members declared can also be accessed within deriving classes. For example,\n\nNotice that while we can’t use from outside of , we can still use it from within an instance method of because derives from .\n\nA constructor may also be marked . This means that the class cannot be instantiated outside of its containing class, but can be extended. For example,\n\nYou can make properties readonly by using the keyword. Readonly properties must be initialized at their declaration or in the constructor.\n\nIn our last example, we had to declare a readonly member and a constructor parameter in the class. This is needed in order to have the value of accessible after the constructor is executed. Parameter properties let you create and initialize a member in one place. Here’s a further revision of the previous class using a parameter property:\n\nNotice how we dropped altogether and just use the shortened parameter on the constructor to create and initialize the member. We’ve consolidated the declarations and assignment into one location.\n\nParameter properties are declared by prefixing a constructor parameter with an accessibility modifier or , or both. Using for a parameter property declares and initializes a private member; likewise, the same is done for , , and .\n\nTypeScript supports getters/setters as a way of intercepting accesses to a member of an object. This gives you a way of having finer-grained control over how a member is accessed on each object.\n\nLet’s convert a simple class to use and . First, let’s start with an example without getters and setters.\n\nWhile allowing people to randomly set directly is pretty handy, we may also want enforce some constraints when is set.\n\nIn this version, we add a setter that checks the length of the to make sure it’s compatible with the max-length of our backing database field. If it isn’t we throw an error notifying client code that something went wrong.\n\nTo preserve existing functionality, we also add a simple getter that retrieves unmodified.\n\nTo prove to ourselves that our accessor is now checking the length of values, we can attempt to assign a name longer than 10 characters and verify that we get an error.\n\nA couple of things to note about accessors:\n\nFirst, accessors require you to set the compiler to output ECMAScript 5 or higher. Downleveling to ECMAScript 3 is not supported. Second, accessors with a and no are automatically inferred to be . This is helpful when generating a file from your code, because users of your property can see that they can’t change it.\n\nUp to this point, we’ve only talked about the instance members of the class, those that show up on the object when it’s instantiated. We can also create static members of a class, those that are visible on the class itself rather than on the instances. In this example, we use on the origin, as it’s a general value for all grids. Each instance accesses this value through prepending the name of the class. Similarly to prepending in front of instance accesses, here we prepend in front of static accesses.\n\nAbstract classes are base classes from which other classes may be derived. They may not be instantiated directly. Unlike an interface, an abstract class may contain implementation details for its members. The keyword is used to define abstract classes as well as abstract methods within an abstract class.\n\nMethods within an abstract class that are marked as abstract do not contain an implementation and must be implemented in derived classes. Abstract methods share a similar syntax to interface methods. Both define the signature of a method without including a method body. However, abstract methods must include the keyword and may optionally include access modifiers.\n\nWhen you declare a class in TypeScript, you are actually creating multiple declarations at the same time. The first is the type of the instance of the class.\n\nHere, when we say , we’re using as the type of instances of the class . This is almost second nature to programmers from other object-oriented languages.\n\nWe’re also creating another value that we call the constructor function. This is the function that is called when we up instances of the class. To see what this looks like in practice, let’s take a look at the JavaScript created by the above example:\n\nHere, is going to be assigned the constructor function. When we call and run this function, we get an instance of the class. The constructor function also contains all of the static members of the class. Another way to think of each class is that there is an instance side and a static side.\n\nLet’s modify the example a bit to show this difference:\n\nIn this example, works similarly to before. We instantiate the class, and use this object. This we have seen before.\n\nNext, we then use the class directly. Here we create a new variable called . This variable will hold the class itself, or said another way its constructor function. Here we use , that is “give me the type of the class itself” rather than the instance type. Or, more precisely, “give me the type of the symbol called ,” which is the type of the constructor function. This type will contain all of the static members of Greeter along with the constructor that creates instances of the class. We show this by using on , creating new instances of and invoking them as before. It is also good to mention that changing static property is frowned upon, here has instead of on .\n\nUsing a class as an interface\n\nAs we said in the previous section, a class declaration creates two things: a type representing instances of the class and a constructor function. Because classes create types, you can use them in the same places you would be able to use interfaces."
    },
    {
        "link": "https://blog.logrocket.com/writing-constructor-typescript",
        "document": "Any mature TypeScript codebase will typically make heavy use of interfaces.\n\nThey are, after all, the building blocks of adding static compile-time checks on your code, and they ensure you are sensibly using the collective/custom types you define within your code.\n\nInterface syntax is simple, and interfaces offer a host of advantages when used in your code, such as:\n• Used heavily by the TypeScript community, so they are a common best practice, (the TypeScript documentation utilizes them heavily also)\n• The TypeScript team endorses interfaces, too. Daniel Rosenwasser, TypeScript’s program manager, has endorsed interfaces over\n\nLet’s learn more about constructors and how we’ll use constructors in interfaces:\n• Using a constructor on an interface\n\nConstructors are also a code feature heavily used in TypeScript codebases too.\n\nThe TypeScript docs have a great example of constructor usage:\n\nConstructors essentially allow the creation of objects from classes.\n\nClasses act like a blueprint for typing the objects you create with the necessary properties and methods.\n\nConstructors often make use of a code technique called dependency injection — that is key to utilizing them to their fullest potential.\n\nThis is where the dependencies necessary for the object we’re going to create are passed into the constructor.\n\nIn the above example, we see we pass in the argument into the constructor to allow unique customization of the object:\n\nThe ability for the same class (the class) to provide different results from a method call is often called polymorphism.\n\nA final important thing to remember when using constructors is that you cannot use multiple constructors implementations — like you can in other object-orientated languages.\n\nAn example of multiple constructors would be like so:\n\nThe above code won’t compile and logs the error .\n\nIf you need to use multiple constructors to provide different functionality from a base class, there are ways of doing this, but you can only use one implementation.\n\nIf you need different constructors — there are ways to work around this though, you can type multiple constructors — you just can’t implement them.\n\nA real-world example would look like:\n\nUsing a constructor on an interface\n\nWe’ve discussed the more common use cases for utilizing constructors, but their functionality doesn’t end there.\n\nSometimes, as part of a design pattern or for certain use cases, developers may want to specifically create an instance variable from an interface.\n\nA simple example of an interface we might want to construct could be:\n\nBut how we add a constructor to this type is not clear.\n\nEven more confusingly, in the compiled JavaScript, the interface won’t even exist. It only exists to check our types and then will be totally removed, thanks to a process called type erasure.\n\nSo, let’s start with a failing example and solve it iteratively:\n\nThe error we are currently facing is:\n\nEven though our two constructors match (in the interface versus in the class implementing the interface), it throws an error and won’t compile.\n\nYou can see in the two code examples that they are using the same type, and, by the looks of it, should compile just fine.\n\nThe docs include an example covering this exact scenario.\n\nOur earlier examples are failing because, according to the docs, “when a class implements an interface, only the instance side of the class is checked. Because the constructor sits in the static side, it is not included in this check.”\n\nThis reads weirdly, but it essentially means that the constructor isn’t an instance type method.\n\nBy instance type method, we’re referring to a “normal” function that would be called with existing on the object instance, as a result of using the keyword. The constructor actually belongs to the static type.\n\nIn this case, the static type means the type it belongs to, without instantiating it, e.g., .\n\nTo fix this, we need to create two interfaces: one for the static type methods/properties and one for the instance type methods.\n\nOur new working example, inspired by the engineering lead of TypeScript, looks like this.\n\nThis now logs as .\n\nBy using this language feature, you can create more composable objects that don’t rely on inheritance to share code.\n\nWith a constructor on the interface, you can specify that all of your types must have certain methods/properties (normal interface compliance) but also control how the types get constructed by typing the interface like you would with any other method/property.\n\nWe are relying on abstractions rather than concretions. There’s an example from the old TypeScript docs to highlight this.\n\nThe old docs are still valid TypeScript, and they’re a really clear example of what we’re discussing – so I have kept the legacy URL for clarity.\n\nHere, we are creating a strictly typed constructor function with the arguments we need other classes to use, but at the same time, allowing it to be generic enough it fits multiple use-cases.\n\nIt also ensures we are keeping low coupling, high cohesion in our code.\n\nI hope this has explained not only how to add a constructor onto an interface, but some of the common use cases for when and why it might be done, as well as the syntax of how you can achieve it.\n\nIt is a common enough occurrence that the docs even explain the basic approach, and it is useful to understand the two sides of static versus instance scope in the underlying JavaScript/TypeScript world."
    },
    {
        "link": "https://refine.dev/blog/typescript-classes",
        "document": "TypeScript classes are an extension of the ES6 classes of JavaScript, adding type annotations, access modifiers ( , , ), and other features such as fields, members, and parameter properties.\n• Class members - fields, methods, and accessors can have type annotations and visibility modifiers.\n• The fields marked as can only be assigned during declaration or in the constructor.\n• Declare and initialize fields directly in the constructor using parameter properties.\n• TypeScript mitigates the issues with binding by using arrow functions or the parameter. - Classes support generics and multiple interfaces using the keyword. :::\n\nTypeScript supports all the features of JavaScript Class syntax introduced in ES2015. Basically, type annotations are applied to all members, namely: fields, constructors, methods and accessors -- and where applicable, parameters as well. TypeScript also bakes in a special syntax to class constructors called parameter properties which allows us to declare a class field from the constructor function's parameters.\n\nA TypeScript class definition creates a type from itself and it is used to validate conformity of an instance. TypeScript allows generic classes with type parameters passed to the outer class definition. Usually, generic class type parameters are accepted as constructor parameters, but they can also be passed to fields, methods and accessors as well. A single TS class can implement multiple other interfaces, something that is done with the keyword.\n\nBesides type annotations, TypeScript adds member visibility across the prototype chain with three access modifiers: , and -- a feature distinct from how ES2022 implements member privacy with .\n\nJavaScript keyword leads to some unpredictability in different call site contexts. TypeScript is geared to mitigate during development some of the call site uncertainties by allocating a possible parameter to a method's first argument.\n\nSteps we'll cover in this post:\n\nIn this post, we focus on the essentials of class based programming in TypeScript using a simple class. We begin with how type annotations are applied to different class members and their parameters.\n\nWe first consider typing class fields and delve into details of their initialization options, particularly investigating definite initialization with the bang operator and strict initialization with the flag.\n\nWe then familiarize with how member visibility is implemented in TypeScript. Member visibility in TypeScript classes is largely related to effective usage of prototypal heritage in JavaScript. However, in this post, we don't cover inheritance in TypeScript classes: for brevity, we only consider privacy of fields for a simple uninherited class and its instances. We also touch base on static fields which acts the same as that in JavaScript.\n\nWe elaborate on what fields are and how they are limited to be initialized at the top or re/assigned from a constructor function. We extensively cover typing a constructor function with examples from our uninherited class and relate that constructor parameters are typed similar to any TS function. We end up learning how parameter properties work inside a constructor. Moving forward, we also work our way through easy-to-pick examples of typing methods and accessors, along with their parameters.\n\nIn the later half of this post, we zoom in on the way TypeScript mitigates errors related to the object. We expound on how arrow functions and the special TS parameter in non-arrow functions can be used for correctly setting a class method's object and also learn about some of their caveats.\n\nWe also explore generic classes with passed in type parameters and see examples of how TypeScript facilitates class conformity to multiple interfaces with the keyword.\n\nTowards the end, we briefly discuss the structural type system that TypeScript bases itself on. We observe with an example how instances of different but identically typed and subtype classes conform to a given class (or rather the type from it) and how a supertype cannot not conform to a subtype because of missing properties.\n\nBefore we begin with type annotation examples, in the next section, let's first go through how to set up the environment for using TypeScript.\n\nA TypeScript class commonly has type annotations for its members and where applicable, their parameters. In the following sections, one by one, we cover the details of typing TypeScript class fields, constructor functions, methods, accessors and their parameters.\n\nBelow is an unsophisticated example with a few fields for a class:\n\nAs you can notice, typing a class field in TypeScript is done like typing a variable. For example, as the usual story goes, the type of is being inferred from its initializer type. With the rest of the properties, we are being explicit about the types for , and .\n\nTypeScript class syntax adds some particular options to field initializations. A field may be initialized at declaration, or remain uninitialized, or uninitialized but aimed to be initialized definitely at some point during runtime.\n\nFor example, in the class, field is assigned a random string and the name fields are uninitialized. Notice the field with a bang!\n\nabove is uninitialized but it is accompanied by a bang ( ) operator which is called the definite assignment assertion operator. It is used to indicate that leaving the field uninitialized is good enough to avoid TypeScript strict property initialization (see next section) error but it is expected to be definitely assigned a value with the specified type at some point.\n\nIt is common to use definite assignments when fields are assigned to an instance by APIs from some external libraries:\n\nThe flag in TypeScript controls how strict field/property initialization should be. We can set the strictness of property initialization from the file using the following entry to :\n\nIn TypeScript Playground, you can activate strict property initialization first by visiting the dropdown and then selecting from the section.\n\nSetting necessitates all fields to either have an initializer, or they should be set in the constructor function, or they should be definitely assigned at a later point. Otherwise, TypeScript throws a error:\n\nTypeScript offers , and visibility options for its members. These privacy options are different from how JavaScript implements member privacy in ES2022.\n\nVisibility in TypeScript classes is a general feature applicable to all members. We are covering it for fields, but the same principles apply to methods as well.\n\nFields that are not designated any privacy are by default . We can access or set properties from an instance:\n\nWe have to explicitly state when a field or any member should be or . visibility restricts member access and assignment to within the class. limits the member to be accessed and set from its subclasses as well. This means that we can't access or set or fields from an instance. Attempting to do so, as shown in the series of log statements below, throws errors:\n\nJust as in JavaScript, we set class members on TypeScript classes with the keyword. Let's introduce a static field to our class:\n\nAs it happens in JavaScript, static fields in TypeScript represent class properties. One thing to note is that while declaring static fields, we have to place privacy modifiers ( here, which we technically don't need, but just to make a point) before the keyword. Otherwise, TypeScript feels uncomfortable:\n\nTypeScript allows fields to be . As it implies, fields tempt not be assigned from an instance, even with a setter. They are legal to be initialized at the top declaration and also assigned inside the constructor:\n\nAs you already have noticed above, just like in regular TS functions that take parameters, class constructor parameters also get annotated with their types. Below is a more common example:\n\nIt is important to note that a constructor function in a TypeScript class does not take types as parameters. In other words, there is nothing like this:\n\nInstead, the class declaration itself takes type parameters. Type parameters passed to a class are useful for defining generic class types, since a class ends up creating its own type. We'll explore generic classes in a later section.\n\nIt should be also noted that we do not need to type the return value of a TypeScript class constructor. Because, it always returns the instance's type, which is the type created from the class.\n\nIt should be pretty obvious that a TypeScript class creates a type from itself:\n\nIn TypeScript, we can turn a constructor parameter into a class property using parameter properties. The way to implement parameter properties is by designating field visibility modifiers ( , , ) and/or accessor modifiers ( ) to respective constructor parameters, instead of declaring field definitions that we usually perform at the top:\n\nAbove, we have a reworked class where we no longer need to declare and as fields at the top. Notice closely that we also don't need to carry out respective field assignments inside the constructor body. This way, TypeScript neatly keeps our code compact.\n\nApplying type annotations to class methods is easy and follow the same principles as other functions. We already have the example of method above that has an inferred return type of . In the below code, is another method that has an explicit return type of . It is annotated a parameter as well:\n\nIn a similar vein, we can annotate types for accessor function parameters. Let's see how to do that for our field:\n\nIt is worth noting that although we can annotate a type for the return value of accessors, TypeScript complains if we assign a type for the return value of setters. Annotating a return type for setters is not allowed, so the following is invalid:\n\nThere are a couple of quirks related to accessors typing in TypeScript. Let's consider them now.\n\nFor example, the above setter can have its parameter type omitted. That's because when a getter exists, the setter's type parameter is inferred from the return type of getter:\n\nTS Classes - Field With Only Getter is Set to\n\nWhen we have only a ter method, and no corresponding setter, the field is automatically set to :\n\nIn JavaScript, the object on which a method is called depends on the call site of the method. At runtime, the object can be one of the root causes of unpredictable outcomes of a method call. In this section, we consider how TypeScript has a couple of options for controlling the object predictably in order to produce more stable outcomes.\n\nAs with JavaScript, when we want to permanently attach a class instance to a method, we can use the arrow syntax to define our method. For example, a redefined method with arrow syntax:\n\nAs it happens in JavaScript, the arrow syntax permanently binds the method to the instance of class , here. So, regardless of whether we invoke it directly on or extract it and call it later on, the object remains .\n\nOne of the caveats of using context binding with arrow syntax is that in a derived class of , we can't access as arrow functions don't have a property.\n\nAnother way TypeScript helps handle method context binding is that it spares the object for the first parameter to every method or accessor. When we want to bind an instance of the class to the method, we can specify the instance as the parameter and type it as the class itself. Like this:\n\nContext binding with the parameter is specifically useful when we are sure to use the method on an instance of the class, and without taking it out of context. An added advantage is that we can also call it from a derived class using .\n\nThe drawback, as we can see above, is that the method loses the instance as its when it is extracted out of context.\n\nQ: How are TypeScript classes different from JavaScript classes? TypeScript classes differ from the ES6 classes of plain JavaScript in that they enable type annotations, access modifiers, fields, parameter properties, generics, and multiple implementations of interfaces.\n\nQ: Do classes in TypeScript have private fields? Yes, you can use modifiers such as or for classes in TypeScript. It's another syntax compared to syntax in JavaScript ES2022.\n\nQ: What are the purposes of fields in TypeScript? The fields are supposed to create immutable properties that can only be assigned during initialization or in the constructor.\n\nQ: How does TypeScript bind this in classes? TypeScript provides two means to deal with :\n• Use arrow functions for methods to permanently bind to the class instance.\n• Employing the special parameter for explicitly specifying the type of class instance.\n\nQ: Is it possible to implement multiple interfaces with classes in TypeScript? Yes, TypeScript allows you to implement multiple interfaces using the keyword implements.\n\nQ: Can static members in TypeScript have type parameters? No, in TypeScript, static members cannot refer to class type parameters.\n\nQ: What is the advantage of parameter properties in TypeScript? Parameter properties in C# allow you to declare and initialize the fields directly in constructor parameters, which reduces boilerplate code.\n\nAs it does with other generic types, TypeScript allows us to declare generic classes by passing in type parameters at class declaration. The passed in type can then be used to annotate types for any member inside the class.\n\nIt is, however, not legal to pass class type parameters to members:\n\nIt is possible for a TypeScript class to implement more than one interface. We use the clause for this. Any interface that the class satisfies can be passed to . For example, the following interfaces are all satisfied by the class:\n\nTypeScript throws a error when a given interface property is not satisfied by the class. For example, for a interface, the method is not implemented by , so it does not satisfy the interface:\n\nTypeScript has a structural type system. And in structural type systems, the shape of the class and their instances are enough to compare them.\n\nIf the shapes of two classes are identical, their types are compliant:\n\nHere, we are able to type : an instance of with , and : an instance of with because the shapes of the two classes are the same.\n\nSimilarly, subtyped classes that have partial but the same members with a supertype is compliant to the supertype:\n\nIn this example, , is still compliant to because the has all the members of and an additional one. The opposite ( ) is not true though, because has the missing member that is present in .\n• Use Readonly Fields for Immutable Data: Use the modifier to ensure a field is never changed after it's initialized.\n• Leverage Parameter Properties: Reduce boilerplate code by initializing and declaring fields in the constructor.\n• Use Access Modifiers: Use access modifiers such as , , and to protect class members and guarantee encapsulation.\n• Avoid Overusing Static Members: Excessive use of static members can lead to tight coupling.\n• Use Generics: Write more flexible, reusable classes using type parameters.\n• Annotate Method Return Types: Specify the return types for methods to make the class behavior more explicit.\n• Test binding: Use arrow functions or the parameter to ensure the context is correctly bound to class instances.\n\nIn this post, we have traversed a long way in our exploration of classes in TypeScript. We have covered the essentials of type annotation in TS classes. We began with how to type class fields, their initialization options and visibility modifiers. We touched on fields, and with an example covered the concept of fields that TypeScript implements. We have went through in depth how class constructor, method and accessor parameters, and their return values are annotated. We saw how properties can be assigned from a constructor function, and how to implement parameter properties.\n\nWe also expounded on how arrow functions are used to bind a method permanently to an instance and discovered how the parameter in TypeScript methods allows us to bind an instance more selectively to its methods.\n\nNear the end, we learned about how a class should implement multiple interfaces with the clause. We also explored how subtypes from classes are compliant to those from supertyped classes and and not the other way around because of TypeScript's structural typing system."
    },
    {
        "link": "https://dev.to/logrocket/writing-a-constructor-in-typescript-5bo3",
        "document": "Any mature TypeScript codebase will typically make heavy use of interfaces.\n\nThey are, after all, the building blocks of adding static compile-time checks on your code, and they ensure you are sensibly using the collective/custom types you define within your code.\n\nInterface syntax is simple, and interfaces offer a host of advantages when used in your code, such as:\n• Used heavily by the TypeScript community, so they are a common best practice, (the TypeScript documentation utilizes them heavily also)\n• The TypeScript team endorses interfaces, too. Daniel Rosenwasser, TypeScript's program manager, has endorsed interfaces over\n\nSometimes, as part of a design pattern or for certain use-cases, developers may want to specifically create an instance variable from an interface.\n\nA simple example of an interface we might want to construct could be:\n\nBut how we add a constructor to this type is not clear.\n\nEven more confusingly, in the compiled JavaScript, the interface won’t even exist. It only exists to check our types and then will be totally removed, thanks to a process called type erasure.\n\nSo, let’s start with a failing example and solve it iteratively:\n\nThe error we are currently facing is:\n\nEven though our two constructors match (in the interface versus in the class implementing the interface), it throws an error and won’t compile.\n\nYou can see in the two code examples that they are using the same type, and, by the looks of it, should compile just fine.\n\nThe docs include an example covering this exact scenario.\n\nOur earlier examples are failing because, according to the docs, “when a class implements an interface, only the instance side of the class is checked. Because the constructor sits in the static side, it is not included in this check.”\n\nThis reads weirdly, but it essentially means that the constructor isn’t an instance type method.\n\nBy instance type method, we’re referring to a “normal” function that would be called with existing on the object instance, as a result of using the keyword. The constructor actually belongs to the static type.\n\nIn this case, the static type means the type it belongs to, without instantiating it, e.g., .\n\nTo fix this, we need to create two interfaces: one for the static type methods/properties and one for the instance type methods.\n\nOur new working example, inspired by the engineering lead of TypeScript, looks like this.\n\nThis now logs as .\n\nBy using this language feature, you can create more composable objects that don’t rely on inheritance to share code.\n\nWith a constructor on the interface, you can specify that all of your types must have certain methods/properties (normal interface compliance) but also control how the types get constructed by typing the interface like you would with any other method/property.\n\nWe are relying on abstractions rather than concretions. There’s an example from the old TypeScript docs to highlight this.\n\nThe old docs are still valid TypeScript, and they’re a really clear example of what we’re discussing - so I have kept the legacy URL for clarity.\n\nHere, we are creating a strictly typed constructor function with the arguments we need other classes to use, but at the same time, allowing it to be generic enough it fits multiple use-cases.\n\nIt also ensures we are keeping low coupling, high cohesion in our code.\n\nI hope this has explained not only how to add a constructor onto an interface, but some of the common use-cases for when and why it might be done, as well as the syntax of how you can achieve it.\n\nIt is a common enough occurrence that the docs even explain the basic approach, and it is useful to understand the two sides of static versus instance scope in the underlying JavaScript/TypeScript world.\n\nWriting a lot of TypeScript? Watch the recording of our recent TypeScript meetup to learn about writing more readable code.\n\nTypeScript brings type safety to JavaScript. There can be a tension between type safety and readable code. Watch the recording for a deep dive on some new features of TypeScript 4.4."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/FileReader",
        "document": "This feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020 .\n\nThe interface lets web applications asynchronously read the contents of files (or raw data buffers) stored on the user's computer, using or objects to specify the file or data to read.\n\nFile objects may be obtained from a object returned as a result of a user selecting files using the element, or from a drag and drop operation's object. can only access the contents of files that the user has explicitly selected; it cannot be used to read a file by pathname from the user's file system. To read files on the client's file system by pathname, use the File System Access API. To read server-side files, use , with CORS permission if reading cross-origin."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/js-file-reader",
        "document": "Web browsers that support and allow users to upload files.\n\nIn this article, you will explore the , , and APIs.\n\nIf you would like to follow along with this article, you will need:\n• An understanding of JavaScript methods, , and will be helpful.\n\nFirst, to get a file from a user, we need to use an element:\n\nThis code will let users upload files from their machines.\n\nHere’s an example of uploading a file using an HTML :\n\nFor greater control in handling uploads, you can use JavaScript instead of an HTML to submit the files:\n\nThis approach uses and .\n\nIn modern browsers, have properties and functions. These functions allows us to read the file.\n• transforms the file into a stream and then into a string.\n• returns an that contains the blob’s data in binary form.\n• allows you to get slices of the file.\n\nCreate a new file with some text:\n\nOpen in your web browser and add the file to the . In your web developer console, you will see the file contents read out using , , , and .\n\nThis approach uses , , and .\n\nThere are 6 main events attached to FileReader:\n• : Fires when the blob is read in memory.\n• : Fires when the read is successful.\n• : Fires when the file is loaded and if error or abort didn’t get called or if load starts a new read.\n\nTo start loading our file we have four methods:\n• : Reads the file or blob as an array buffer. One use case is to send large files to a service worker.\n• : Reads the file as USVString (almost like a string), and you can specify an optional format.\n• : This will return a URL where you can access the file’s content, it is Base64 encoded and ready to send to your server\n\nCreate a new file that uses :\n\nOpen in your web browser and add the file to the . A progress bar will appear on the screen as the file is processed. If it loads successfully, it will indicate , , and .\n\nis an asynchronous API because we do not want to block the main thread while reading files. For example, we don’t want our user interface to stop working when the browser is trying to read a very large file. However, there is a synchronous version of called . We can only use in Web Workers. Web workers have their own thread so they won’t block the main thread. uses the same methods as :\n\nThere are no event handlers because it’s synchronous.\n\nIn this article, you explored the , , and APIs.\n\nTake the time to check the browser support for these features to ensure that they are applicable to the users of your projects."
    },
    {
        "link": "https://javascripttutorial.net/web-apis/javascript-filereader",
        "document": "Summary: in this tutorial, you’ll learn about the JavaScript FileReader API and how to use it to implement the file upload.\n\nWhen you drag and drop files to the web browser or select files to upload via the file input element, JavaScript represents each file as a object.\n\nThe object allows you to access the selected file in JavaScript. And JavaScript uses the object to hold the objects.\n\nTo read the content of a file, you use the object. Note that the only can access the files you selected via drag & drop or file input.\n\nTo use the object, you follow these steps:\n\nSecond, call one of the read methods to read the content of a file. For example:\n\nThe method reads the content of the file, which you get from the object.\n\nThe method returns an object with the property that contains the data as a . The represents the file’s data as a base64 encoded string.\n\nFor example, you can use the to read an image and show its base64 encoded string on a webpage.\n\nBesides the method, the has other methods for reading file’s data such as , , and .\n\nSince all of these methods read the file’s data asynchronously, you cannot just return the result like this:\n\nWhen the method completes reading the file successfully, the fires the event.\n\nThird, add an event handler to handle the event of the object:\n\nUsing JavaScript FileReader to implement an image upload application\n\nWe’ll use the to implement an image upload application:\n\nWhen you drag & drop images to the drop zone, the application will use the to read the images and show them on the page together with the filename and filesize:\n\nAlso, the application will use the Fetch API to upload the files to the server.\n\nFor the server-side, we’ll implement a simple PHP script that uploads the images to the folder on the server.\n\nFirst, create the following file and directory structure:\n\nThe following shows the file:\n\nIn the , we add the to the of the document and before the enclosing tag.\n\nThe element with the class allows you to drag and drop images into it. Also, the file input element will enable you to select files to upload.\n\nThe file input element accepts multiple files and only allows jpeg and png images:\n\nThe provides the styles that transform the file input element into a button. Also, it has the class that highlights the dropzone when you drag the file into it.\n\nThe element with the class will show the uploaded images.\n\nFirst, select dropzone, file input (files), and image list elements using the method:\n\nSecond, define a function that adds the active class to or remove it from the dropzone:\n\nIf you call , it’ll add the active class to the . If you call , it’ll remove the class from the .\n\nThird, highlight the when the and events occur and remove the highlight when the and events occur:\n\nFourth, get the object in the as in the event handler of :\n\nIn the drop event handler, we use object destructuring to get the object and call the function to handle the uploaded images:\n\nThe function gets the valid images, shows each valid image on the page using the function and uploads all the images to the server using the function.\n\nSixth, define the function that shows each image in the array:\n\nThe uses the to read the uploaded image as the data URL. Once the completes reading the file, it’ll create a new element to hold the image information.\n\nNote that the function converts the size in bytes into a human-readable format:\n\nSeventh, define the function that uploads all images to the server:\n\nThe function uses the API to construct data for submission:\n\nFor each image, we add it to the object:\n\nNote that the variable is a object, not an array. To use the method, you use the spread operator ( ) to convert the object to an array like this:\n\nAll key/value pairs in the form data have the same key as ; in PHP, you can access it as an array ( )\n\nThe function uses the Fetch API to upload the images (as the object) to the server:\n\nEighth, add the change event handler to the file input element if users select files using this input element:\n\nIn the change event handler, you can access the FileList object as . The logic for showing and uploading images is the same as drag & drop.\n\nNote that if you drag & drop images outside the dropzone, the web browser will display the images by default.\n\nTo prevent this, you call the method of the and event objects of the document like this:\n\nThe following shows the complete file:\n\nFinally, create a simple script that moves the uploaded images to the folder:\n\nRead more on how to upload multiple files in PHP for more information.\n• Use the JavaScript FileReader API to read the files selected by users via drag & drop or file input element."
    },
    {
        "link": "https://javascript.info/file",
        "document": "A File object inherits from and is extended with filesystem-related capabilities.\n\nThere are two ways to obtain it.\n• – is an array of Blob/BufferSource/String values.\n• – optional object:\n• – the timestamp (integer date) of last modification.\n\nSecond, more often we get a file from or drag’n’drop or other browser interfaces. In that case, the file gets this information from OS.\n\nAs inherits from , objects have the same properties, plus:\n• – the timestamp of last modification.\n\nThat’s how we can get a object from :\n\nFileReader is an object with the sole purpose of reading data from (and hence too) objects.\n\nIt delivers the data using events, as reading from disk may take time.\n• – read the data as a text string with the given encoding ( by default).\n• – read the binary data and encode it as base64 data url.\n\nThe choice of method depends on which format we prefer, how we’re going to use the data.\n• – for binary files, to do low-level binary operations. For high-level operations, like slicing, inherits from , so we can call them directly, without reading.\n• – for text files, when we’d like to get a string.\n• – when we’d like to use this data in for or another tag. There’s an alternative to reading a file for that, as discussed in chapter Blob: .\n\nAs the reading proceeds, there are events:\n• – reading finished with either success or failure.\n\nWhen the reading is finished, we can access the result as:\n• is the result (if successful)\n• is the error (if failed).\n\nThe most widely used events are for sure and .\n\nHere’s an example of reading a file:\n\nIn addition to methods and properties, objects also have and properties, plus the internal ability to read from filesystem. We usually get objects from user input, like or Drag’n’Drop events ( ).\n\nobjects can read from a file or a blob, in one of three formats:\n\nIn many cases though, we don’t have to read the file contents. Just as we did with blobs, we can create a short url with and assign it to or . This way the file can be downloaded or shown up as an image, as a part of canvas etc.\n\nAnd if we’re going to send a over a network, that’s also easy: network API like or natively accepts objects."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/FileReader/readAsDataURL",
        "document": "This feature is well established and works across many devices and browser versions. It’s been available across browsers since January 2020 .\n\nNote: This feature is available in Web Workers.\n\nThe method of the interface is used to read the contents of the specified or . When the read operation is finished, the property becomes , and the event is triggered. At that time, the attribute contains the data as a data: URL representing the file's data as a base64 encoded string.\n\nNote: The blob's cannot be directly decoded as Base64 without first removing the Data-URL declaration preceding the Base64-encoded data. To retrieve only the Base64 encoded string, first remove from the result."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
        "document": "A is a proxy for a value not necessarily known when the promise is created. It allows you to associate handlers with an asynchronous action's eventual success value or failure reason. This lets asynchronous methods return values like synchronous methods: instead of immediately returning the final value, the asynchronous method returns a promise to supply the value at some point in the future. A is in one of these states:\n• fulfilled: meaning that the operation was completed successfully. The eventual state of a pending promise can either be fulfilled with a value or rejected with a reason (error). When either of these options occur, the associated handlers queued up by a promise's method are called. If the promise has already been fulfilled or rejected when a corresponding handler is attached, the handler will be called, so there is no race condition between an asynchronous operation completing and its handlers being attached. A promise is said to be settled if it is either fulfilled or rejected, but not pending. You will also hear the term resolved used with promises — this means that the promise is settled or \"locked-in\" to match the eventual state of another promise, and further resolving or rejecting it has no effect. The States and fates document from the original Promise proposal contains more details about promise terminology. Colloquially, \"resolved\" promises are often equivalent to \"fulfilled\" promises, but as illustrated in \"States and fates\", resolved promises can be pending or rejected as well. For example: This promise is already resolved at the time when it's created (because the is called synchronously), but it is resolved with another promise, and therefore won't be fulfilled until 1 second later, when the inner promise fulfills. In practice, the \"resolution\" is often done behind the scenes and not observable, and only its fulfillment or rejection are. Note: Several other languages have mechanisms for lazy evaluation and deferring a computation, which they also call \"promises\", e.g. Scheme. Promises in JavaScript represent processes that are already happening, which can be chained with callback functions. If you are looking to lazily evaluate an expression, consider using a function with no arguments e.g. to create the lazily-evaluated expression, and to evaluate the expression immediately. itself has no first-class protocol for cancellation, but you may be able to directly cancel the underlying asynchronous operation, typically using .\n\nThe promise methods , , and are used to associate further action with a promise that becomes settled. The method takes up to two arguments; the first argument is a callback function for the fulfilled case of the promise, and the second argument is a callback function for the rejected case. The and methods call internally and make error handling less verbose. For example, a is really just a without passing the fulfillment handler. As these methods return promises, they can be chained. For example: We will use the following terminology: initial promise is the promise on which is called; new promise is the promise returned by . The two callbacks passed to are called fulfillment handler and rejection handler, respectively. The settled state of the initial promise determines which handler to execute.\n• If the initial promise is fulfilled, the fulfillment handler is called with the fulfillment value.\n• If the initial promise is rejected, the rejection handler is called with the rejection reason. The completion of the handler determines the settled state of the new promise.\n• If the handler returns a thenable value, the new promise settles in the same state as the returned value.\n• If the handler returns a non-thenable value, the new promise is fulfilled with the returned value.\n• If the handler throws an error, the new promise is rejected with the thrown error.\n• If the initial promise has no corresponding handler attached, the new promise will settle to the same state as the initial promise — that is, without a rejection handler, a rejected promise stays rejected with the same reason. For example, in the code above, if rejects, will be called, and if completes normally (without throwing or returning a rejected promise), the promise returned by the first will be fulfilled instead of staying rejected. Therefore, if an error must be handled immediately, but we want to maintain the error state down the chain, we must throw an error of some type in the rejection handler. On the other hand, in the absence of an immediate need, we can leave out error handling until the final handler. Using arrow functions for the callback functions, implementation of the promise chain might look something like this: myPromise .then((value) => `${value} and bar`) .then((value) => `${value} and bar again`) .then((value) => `${value} and again`) .then((value) => `${value} and again`) .then((value) => { console.log(value); }) .catch((err) => { console.error(err); }); Note: For faster execution, all synchronous actions should preferably be done within one handler, otherwise it would take several ticks to execute all handlers in sequence. JavaScript maintains a job queue. Each time, JavaScript picks a job from the queue and executes it to completion. The jobs are defined by the executor of the constructor, the handlers passed to , or any platform API that returns a promise. The promises in a chain represent the dependency relationship between these jobs. When a promise settles, the respective handlers associated with it are added to the back of the job queue. A promise can participate in more than one chain. For the following code, the fulfillment of will cause both and to be added to the job queue. Because is registered first, it will be invoked first. An action can be assigned to an already settled promise. In this case, the action is added immediately to the back of the job queue and will be performed when all existing jobs are completed. Therefore, an action for an already \"settled\" promise will occur only after the current synchronous code completes and at least one loop-tick has passed. This guarantees that promise actions are asynchronous. const promiseA = new Promise((resolve, reject) => { resolve(777); }); // At this point, \"promiseA\" is already settled. promiseA.then((val) => console.log(\"asynchronous logging has val:\", val)); console.log(\"immediate logging\"); // produces output in this order: // immediate logging // asynchronous logging has val: 777\n\nThe class offers four static methods to facilitate async task concurrency: Fulfills when all of the promises fulfill; rejects when any of the promises rejects. Fulfills when any of the promises fulfills; rejects when all of the promises reject. Settles when any of the promises settles. In other words, fulfills when any of the promises fulfills; rejects when any of the promises rejects. All these methods take an iterable of promises (thenables, to be exact) and return a new promise. They all support subclassing, which means they can be called on subclasses of , and the result will be a promise of the subclass type. To do so, the subclass's constructor must implement the same signature as the constructor — accepting a single function that can be called with the and callbacks as parameters. The subclass must also have a static method that can be called like to resolve values to promises. Note that JavaScript is single-threaded by nature, so at a given instant, only one task will be executing, although control can shift between different promises, making execution of the promises appear concurrent. Parallel execution in JavaScript can only be achieved through worker threads.\n\nThis example shows diverse techniques for using Promise capabilities and diverse situations that can occur. To understand this, start by scrolling to the bottom of the code block, and examine the promise chain. Upon provision of an initial promise, a chain of promises can follow. The chain is composed of calls, and typically (but not necessarily) has a single at the end, optionally followed by . In this example, the promise chain is initiated by a custom-written construct; but in actual practice, promise chains more typically start with an API function (written by someone else) that returns a promise. The example function shows that a promise generator will utilize while setting up an asynchronous call, or within the call-back, or both. The function illustrates how an API function might generate and return a promise in a self-contained manner. Note that the function ends with a . That is forced because a promise chain goes through all the promises, even after an error, and without the , the error would seem \"fixed\". This is a hassle, and for this reason, it is common to omit throughout the chain of promises, and just have a single in the final . This code can be run under NodeJS. Comprehension is enhanced by seeing the errors actually occur. To force more errors, change the values. // To experiment with error handling, \"threshold\" values cause errors randomly const THRESHOLD_A = 8; // can use zero 0 to guarantee error function tetheredGetNumber(resolve, reject) { setTimeout(() => { const randomInt = Date.now(); const value = randomInt % 10; if (value < THRESHOLD_A) { resolve(value); } else { reject(`Too large: ${value}`); } }, 500); } function determineParity(value) { const isOdd = value % 2 === 1; return { value, isOdd }; } function troubleWithGetNumber(reason) { const err = new Error(\"Trouble getting number\", { cause: reason }); console.error(err); throw err; } function promiseGetWord(parityInfo) { return new Promise((resolve, reject) => { const { value, isOdd } = parityInfo; if (value >= THRESHOLD_A - 1) { reject(`Still too large: ${value}`); } else { parityInfo.wordEvenOdd = isOdd ? \"odd\" : \"even\"; resolve(parityInfo); } }); } new Promise(tetheredGetNumber) .then(determineParity, troubleWithGetNumber) .then(promiseGetWord) .then((info) => { console.log(`Got: ${info.value}, ${info.wordEvenOdd}`); return info; }) .catch((reason) => { if (reason.cause) { console.error(\"Had previously handled error\"); } else { console.error(`Trouble with promiseGetWord(): ${reason}`); } }) .finally((info) => console.log(\"All done\"));\n\nThis small example shows the mechanism of a . The method is called each time the is clicked. It creates a promise that will be fulfilled, using , to the promise count (number starting from 1) every 1-3 seconds, at random. The constructor is used to create the promise. The fulfillment of the promise is logged, via a fulfill callback set using . A few logs show how the synchronous part of the method is decoupled from the asynchronous completion of the promise. By clicking the button several times in a short amount of time, you'll even see the different promises being fulfilled one after another. \"use strict\"; let promiseCount = 0; function testPromise() { const thisPromiseCount = ++promiseCount; const log = document.getElementById(\"log\"); // begin log.insertAdjacentHTML(\"beforeend\", `${thisPromiseCount}) Started<br>`); // We make a new promise: we promise a numeric count of this promise, // starting from 1 (after waiting 3s) const p1 = new Promise((resolve, reject) => { // The executor function is called with the ability // to resolve or reject the promise log.insertAdjacentHTML( \"beforeend\", `${thisPromiseCount}) Promise constructor<br>`, ); // This is only an example to create asynchronism setTimeout( () => { // We fulfill the promise resolve(thisPromiseCount); }, Math.random() * 2000 + 1000, ); }); // We define what to do when the promise is resolved with the then() call, // and what to do when the promise is rejected with the catch() call p1.then((val) => { // Log the fulfillment value log.insertAdjacentHTML(\"beforeend\", `${val}) Promise fulfilled<br>`); }).catch((reason) => { // Log the rejection reason console.log(`Handle rejected promise (${reason}) here.`); }); // end log.insertAdjacentHTML(\"beforeend\", `${thisPromiseCount}) Promise made<br>`); } const btn = document.getElementById(\"make-promise\"); btn.addEventListener(\"click\", testPromise);\n\nA settings object is an environment that provides additional information when JavaScript code is running. This includes the realm and module map, as well as HTML specific information such as the origin. The incumbent settings object is tracked in order to ensure that the browser knows which one to use for a given piece of user code. To better picture this, we can take a closer look at how the realm might be an issue. A realm can be roughly thought of as the global object. What is unique about realms is that they hold all of the necessary information to run JavaScript code. This includes objects like and . Each settings object has its own \"copy\" of these and they are not shared. That can cause some unexpected behavior in relation to promises. In order to get around this, we track something called the incumbent settings object. This represents information specific to the context of the user code responsible for a certain function call. To illustrate this a bit further we can take a look at how an embedded in a document communicates with its host. Since all web APIs are aware of the incumbent settings object, the following will work in all browsers: <!doctype html> <iframe></iframe> <!-- we have a realm here --> <script> // we have a realm here as well const bound = frames[0].postMessage.bind(frames[0], \"some data\", \"*\"); // bound is a built-in function — there is no user // code on the stack, so which realm do we use? setTimeout(bound); // this still works, because we use the youngest // realm (the incumbent) on the stack </script> The same concept applies to promises. If we modify the above example a little bit, we get this: <!doctype html> <iframe></iframe> <!-- we have a realm here --> <script> // we have a realm here as well const bound = frames[0].postMessage.bind(frames[0], \"some data\", \"*\"); // bound is a built in function — there is no user // code on the stack — which realm do we use? Promise.resolve(undefined).then(bound); // this still works, because we use the youngest // realm (the incumbent) on the stack </script> If we change this so that the in the document is listening to post messages, we can observe the effect of the incumbent settings object: <!-- x.html --> <!doctype html> <script> window.addEventListener( \"message\", (event) => { document.querySelector(\"#text\").textContent = \"hello\"; // this code will only run in browsers that track the incumbent settings object console.log(event); }, false, ); </script> In the above example, the inner text of the will be updated only if the incumbent settings object is tracked. This is because without tracking the incumbent, we may end up using the wrong environment to send the message. Note: Currently, incumbent realm tracking is fully implemented in Firefox, and has partial implementations in Chrome and Safari."
    },
    {
        "link": "https://javascript.info/promise-error-handling",
        "document": "Promise chains are great at error handling. When a promise rejects, the control jumps to the closest rejection handler. That’s very convenient in practice.\n\nFor instance, in the code below the URL to is wrong (no such site) and handles the error:\n\nAs you can see, the doesn’t have to be immediate. It may appear after one or maybe several .\n\nOr, maybe, everything is all right with the site, but the response is not valid JSON. The easiest way to catch all errors is to append to the end of chain:\n\nNormally, such doesn’t trigger at all. But if any of the promises above rejects (a network problem or invalid json or whatever), then it would catch it.\n\nThe code of a promise executor and promise handlers has an “invisible ” around it. If an exception happens, it gets caught and treated as a rejection.\n\n…Works exactly the same as this:\n\nThe “invisible ” around the executor automatically catches the error and turns it into rejected promise.\n\nThis happens not only in the executor function, but in its handlers as well. If we inside a handler, that means a rejected promise, so the control jumps to the nearest error handler.\n\nThis happens for all errors, not just those caused by the statement. For example, a programming error:\n\nThe final not only catches explicit rejections, but also accidental errors in the handlers above.\n\nAs we already noticed, at the end of the chain is similar to . We may have as many handlers as we want, and then use a single at the end to handle errors in all of them.\n\nIn a regular we can analyze the error and maybe rethrow it if it can’t be handled. The same thing is possible for promises.\n\nIf we inside , then the control goes to the next closest error handler. And if we handle the error and finish normally, then it continues to the next closest successful handler.\n\nIn the example below the successfully handles the error:\n\nHere the block finishes normally. So the next successful handler is called.\n\nIn the example below we see the other situation with . The handler catches the error and just can’t handle it (e.g. it only knows how to handle ), so it throws it again:\n\nThe execution jumps from the first to the next one down the chain.\n\nWhat happens when an error is not handled? For instance, we forgot to append to the end of the chain, like here:\n\nIn case of an error, the promise becomes rejected, and the execution should jump to the closest rejection handler. But there is none. So the error gets “stuck”. There’s no code to handle it.\n\nIn practice, just like with regular unhandled errors in code, it means that something has gone terribly wrong.\n\nWhat happens when a regular error occurs and is not caught by ? The script dies with a message in the console. A similar thing happens with unhandled promise rejections.\n\nThe JavaScript engine tracks such rejections and generates a global error in that case. You can see it in the console if you run the example above.\n\nIn the browser we can catch such errors using the event :\n\nThe event is the part of the HTML standard.\n\nIf an error occurs, and there’s no , the handler triggers, and gets the object with the information about the error, so we can do something.\n\nUsually such errors are unrecoverable, so our best way out is to inform the user about the problem and probably report the incident to the server.\n\nIn non-browser environments like Node.js there are other ways to track unhandled errors.\n• handles errors in promises of all kinds: be it a call, or an error thrown in a handler.\n• also catches errors in the same manner, if given the second argument (which is the error handler).\n• We should place exactly in places where we want to handle errors and know how to handle them. The handler should analyze errors (custom error classes help) and rethrow unknown ones (maybe they are programming mistakes).\n• It’s ok not to use at all, if there’s no way to recover from an error.\n• In any case we should have the event handler (for browsers, and analogs for other environments) to track unhandled errors and inform the user (and probably our server) about them, so that our app never “just dies”."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises",
        "document": "A is an object representing the eventual completion or failure of an asynchronous operation. Since most people are consumers of already-created promises, this guide will explain consumption of returned promises before explaining how to create them. Essentially, a promise is a returned object to which you attach callbacks, instead of passing callbacks into a function. Imagine a function, , which asynchronously generates a sound file given a configuration record and two callback functions: one called if the audio file is successfully created, and the other called if an error occurs. Here's some code that uses : If were rewritten to return a promise, you would attach your callbacks to it instead: This convention has several advantages. We will explore each one.\n\nA common need is to execute two or more asynchronous operations back to back, where each subsequent operation starts when the previous operation succeeds, with the result from the previous step. In the old days, doing several asynchronous operations in a row would lead to the classic callback hell: With promises, we accomplish this by creating a promise chain. The API design of promises makes this great, because callbacks are attached to the returned promise object, instead of being passed into a function. Here's the magic: the function returns a new promise, different from the original: This second promise ( ) represents the completion not just of , but also of the or you passed in — which can be other asynchronous functions returning a promise. When that's the case, any callbacks added to get queued behind the promise returned by either or . Note: If you want a working example to play with, you can use the following template to create any function returning a promise: function doSomething() { return new Promise((resolve) => { setTimeout(() => { // Other things to do before completion of the promise console.log(\"Did something\"); // The fulfillment value of the promise resolve(\"https://example.com/\"); }, 200); }); } The implementation is discussed in the Creating a Promise around an old callback API section below. With this pattern, you can create longer chains of processing, where each promise represents the completion of one asynchronous step in the chain. In addition, the arguments to are optional, and is short for — so if your error handling code is the same for all steps, you can attach it to the end of the chain: You might see this expressed with arrow functions instead: Note: Arrow function expressions can have an implicit return; so, is short for . and can return any value — if they return promises, that promise is first waited until it settles, and the next callback receives the fulfillment value, not the promise itself. It is important to always return promises from callbacks, even if the promise always resolves to . If the previous handler started a promise but did not return it, there's no way to track its settlement anymore, and the promise is said to be \"floating\". doSomething() .then((url) => { // Missing `return` keyword in front of fetch(url). fetch(url); }) .then((result) => { // result is undefined, because nothing is returned from the previous // handler. There's no way to know the return value of the fetch() // call anymore, or whether it succeeded at all. }); By returning the result of the call (which is a promise), we can both track its completion and receive its value when it completes. Floating promises could be worse if you have race conditions — if the promise from the last handler is not returned, the next handler will be called early, and any value it reads may be incomplete. const listOfIngredients = []; doSomething() .then((url) => { // Missing `return` keyword in front of fetch(url). fetch(url) .then((res) => res.json()) .then((data) => { listOfIngredients.push(data); }); }) .then(() => { console.log(listOfIngredients); // listOfIngredients will always be [], because the fetch request hasn't completed yet. }); Therefore, as a rule of thumb, whenever your operation encounters a promise, return it and defer its handling to the next handler. const listOfIngredients = []; doSomething() .then((url) => { // `return` keyword now included in front of fetch call. return fetch(url) .then((res) => res.json()) .then((data) => { listOfIngredients.push(data); }); }) .then(() => { console.log(listOfIngredients); // listOfIngredients will now contain data from fetch call. }); Even better, you can flatten the nested chain into a single chain, which is simpler and makes error handling easier. The details are discussed in the Nesting section below. Using / can help you write code that's more intuitive and resembles synchronous code. Below is the same example using / : Note how the code looks exactly like synchronous code, except for the keywords in front of promises. One of the only tradeoffs is that it may be easy to forget the keyword, which can only be fixed when there's a type mismatch (e.g. trying to use a promise as a value). / builds on promises — for example, is the same function as before, so there's minimal refactoring needed to change from promises to / . You can read more about the / syntax in the async functions and references. Note: / has the same concurrency semantics as normal promise chains. within one async function does not stop the entire program, only the parts that depend on its value, so other async jobs can still run while the is pending.\n\nIn the examples above involving , the first one has one promise chain nested in the return value of another handler, while the second one uses an entirely flat chain. Simple promise chains are best kept flat without nesting, as nesting can be a result of careless composition. Nesting is a control structure to limit the scope of statements. Specifically, a nested only catches failures in its scope and below, not errors higher up in the chain outside the nested scope. When used correctly, this gives greater precision in error recovery: Note that the optional steps here are nested — with the nesting caused not by the indentation, but by the placement of the outer and parentheses around the steps. The inner error-silencing handler only catches failures from and , after which the code resumes with . Importantly, if fails, its error is caught by the final (outer) only, and does not get swallowed by the inner handler. In / , this code looks like: async function main() { try { const result = await doSomethingCritical(); try { const optionalResult = await doSomethingOptional(result); await doSomethingExtraNice(optionalResult); } catch (e) { // Ignore failures in optional steps and proceed. } await moreCriticalStuff(); } catch (e) { console.error(`Critical failure: ${e.message}`); } } Note: If you don't have sophisticated error handling, you very likely don't need nested handlers. Instead, use a flat chain and put the error handling logic at the end.\n\nIf a promise rejection event is not handled by any handler, it bubbles to the top of the call stack, and the host needs to surface it. On the web, whenever a promise is rejected, one of two events is sent to the global scope (generally, this is either the or, if being used in a web worker, it's the or other worker-based interface). The two events are: Sent when a promise is rejected but there is no rejection handler available. Sent when a handler is attached to a rejected promise that has already caused an event. In both cases, the event (of type ) has as members a property indicating the promise that was rejected, and a property that provides the reason given for the promise to be rejected. These make it possible to offer fallback error handling for promises, as well as to help debug issues with your promise management. These handlers are global per context, so all errors will go to the same event handlers, regardless of source. In Node.js, handling promise rejection is slightly different. You capture unhandled rejections by adding a handler for the Node.js event (notice the difference in capitalization of the name), like this: process.on(\"unhandledRejection\", (reason, promise) => { // Add code here to examine the \"promise\" and \"reason\" values }); For Node.js, to prevent the error from being logged to the console (the default action that would otherwise occur), adding that listener is all that's necessary; there's no need for an equivalent of the browser runtime's method. However, if you add that listener but don't also have code within it to handle rejected promises, they will just be dropped on the floor and silently ignored. So ideally, you should add code within that listener to examine each rejected promise and make sure it was not caused by an actual code bug.\n\nThere are four composition tools for running asynchronous operations concurrently: , , , and . We can start operations at the same time and wait for them all to finish like this: If one of the promises in the array rejects, immediately rejects the returned promise and aborts the other operations. This may cause unexpected state or behavior. is another composition tool that ensures all operations are complete before resolving. These methods all run promises concurrently — a sequence of promises are started simultaneously and do not wait for each other. Sequential composition is possible using some clever JavaScript: In this example, we reduce an array of asynchronous functions down to a promise chain. The code above is equivalent to: This can be made into a reusable compose function, which is common in functional programming: The function accepts any number of functions as arguments and returns a new function that accepts an initial value to be passed through the composition pipeline: Sequential composition can also be done more succinctly with async/await: let result; for (const f of [func1, func2, func3]) { result = await f(result); } /* use last result (i.e. result3) */ However, before you compose promises sequentially, consider if it's really necessary — it's always better to run promises concurrently so that they don't unnecessarily block each other unless one promise's execution depends on another's result.\n\nIn the callback-based API, when and how the callback gets called depends on the API implementor. For example, the callback may be called synchronously or asynchronously: The above design is strongly discouraged because it leads to the so-called \"state of Zalgo\". In the context of designing asynchronous APIs, this means a callback is called synchronously in some cases but asynchronously in other cases, creating ambiguity for the caller. For further background, see the article Designing APIs for Asynchrony, where the term was first formally presented. This API design makes side effects hard to analyze: let value = 1; doSomething(() => { value = 2; }); console.log(value); // 1 or 2? On the other hand, promises are a form of inversion of control — the API implementor does not control when the callback gets called. Instead, the job of maintaining the callback queue and deciding when to call the callbacks is delegated to the promise implementation, and both the API user and API developer automatically gets strong semantic guarantees, including:\n• Callbacks added with will never be invoked before the completion of the current run of the JavaScript event loop.\n• These callbacks will be invoked even if they were added after the success or failure of the asynchronous operation that the promise represents.\n• Multiple callbacks may be added by calling several times. They will be invoked one after another, in the order in which they were inserted. To avoid surprises, functions passed to will never be called synchronously, even with an already-resolved promise: Instead of running immediately, the passed-in function is put on a microtask queue, which means it runs later (only after the function which created it exits, and when the JavaScript execution stack is empty), just before control is returned to the event loop; i.e. pretty soon: const wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms)); wait(0).then(() => console.log(4)); Promise.resolve() .then(() => console.log(2)) .then(() => console.log(3)); console.log(1); // 1, 2, 3, 4"
    },
    {
        "link": "https://tr.javascript.info/promise-error-handling",
        "document": ""
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/try",
        "document": "You may have an API that takes a callback. The callback may be synchronous or asynchronous. You want to handle everything uniformly by wrapping the result in a promise. The most straightforward way might be . The problem is that if synchronously throws an error, this error would not be caught and turned into a rejected promise.\n\nThe common approach (lifting a function call result into a promise, fulfilled or rejected) often looks like this:\n\nBut is more helpful here:\n\nFor the built-in constructor, errors thrown from the executor are automatically caught and turned into rejections, so these two approaches are mostly equivalent, except that is more concise and readable.\n\nNote that is not equivalent to this, despite being highly similar:\n\nThe difference is that the callback passed to is always called asynchronously, while the executor of the constructor is called synchronously. also calls the function synchronously, and resolves the promise immediately if possible.\n\n, combined with and , can be used to handle both synchronous and asynchronous errors in a single chain, and make promise error handling appear almost like synchronous error handling.\n\nLike , accepts extra arguments that are passed to the callback. This means instead of doing this:\n\nYou can do this:\n\nWhich are equivalent, but the latter avoids creating an extra closure and is more efficient."
    }
]