[
    {
        "link": "https://docs.python.org/3/library/dataclasses.html",
        "document": "This module provides a decorator and functions for automatically adding generated special methods such as and to user-defined classes. It was originally described in PEP 557.\n\nThe member variables to use in these generated methods are defined using PEP 526 type annotations. For example, this code:\n\nwill add, among other things, a that looks like:\n\nNote that this method is automatically added to the class: it is not directly specified in the definition shown above.\n\nThis function is a decorator that is used to add generated special methods to classes, as described below. The decorator examines the class to find s. A is defined as a class variable that has a type annotation. With two exceptions described below, nothing in examines the type specified in the variable annotation. The order of the fields in all of the generated methods is the order in which they appear in the class definition. The decorator will add various “dunder” methods to the class, described below. If any of the added methods already exist in the class, the behavior depends on the parameter, as documented below. The decorator returns the same class that it is called on; no new class is created. If is used just as a simple decorator with no parameters, it acts as if it has the default values documented in this signature. That is, these three uses of are equivalent: The parameters to are:\n• None init: If true (the default), a method will be generated. If the class already defines , this parameter is ignored.\n• None repr: If true (the default), a method will be generated. The generated repr string will have the class name and the name and repr of each field, in the order they are defined in the class. Fields that are marked as being excluded from the repr are not included. For example: . If the class already defines , this parameter is ignored.\n• None eq: If true (the default), an method will be generated. This method compares the class as if it were a tuple of its fields, in order. Both instances in the comparison must be of the identical type. If the class already defines , this parameter is ignored.\n• None order: If true (the default is ), , , , and methods will be generated. These compare the class as if it were a tuple of its fields, in order. Both instances in the comparison must be of the identical type. If order is true and eq is false, a is raised. If the class already defines any of , , , or , then is raised.\n• None unsafe_hash: If (the default), a method is generated according to how eq and frozen are set. is used by built-in , and when objects are added to hashed collections such as dictionaries and sets. Having a implies that instances of the class are immutable. Mutability is a complicated property that depends on the programmer’s intent, the existence and behavior of , and the values of the eq and frozen flags in the decorator. By default, will not implicitly add a method unless it is safe to do so. Neither will it add or change an existing explicitly defined method. Setting the class attribute has a specific meaning to Python, as described in the documentation. If is not explicitly defined, or if it is set to , then may add an implicit method. Although not recommended, you can force to create a method with . This might be the case if your class is logically immutable but can still be mutated. This is a specialized use case and should be considered carefully. Here are the rules governing implicit creation of a method. Note that you cannot both have an explicit method in your dataclass and set ; this will result in a . If eq and frozen are both true, by default will generate a method for you. If eq is true and frozen is false, will be set to , marking it unhashable (which it is, since it is mutable). If eq is false, will be left untouched meaning the method of the superclass will be used (if the superclass is , this means it will fall back to id-based hashing).\n• None frozen: If true (the default is ), assigning to fields will generate an exception. This emulates read-only frozen instances. If or is defined in the class, then is raised. See the discussion below.\n• None match_args: If true (the default is ), the tuple will be created from the list of parameters to the generated method (even if is not generated, see above). If false, or if is already defined in the class, then will not be generated.\n• None kw_only: If true (the default value is ), then all fields will be marked as keyword-only. If a field is marked as keyword-only, then the only effect is that the parameter generated from a keyword-only field must be specified with a keyword when is called. There is no effect on any other aspect of dataclasses. See the parameter glossary entry for details. Also see the section.\n• None slots: If true (the default is ), attribute will be generated and new class will be returned instead of the original one. If is already defined in the class, then is raised. Calling no-arg in dataclasses using will result in the following exception being raised: TypeError: super(type, obj): obj must be an instance or subtype of type . The two-arg is a valid workaround. See gh-90562 for full details. Passing parameters to a base class when using will result in a . Either use with no parameters or use default values as a workaround. See gh-91126 for full details. Changed in version 3.11: If a field name is already included in the of a base class, it will not be included in the generated to prevent overriding them. Therefore, do not use to retrieve the field names of a dataclass. Use instead. To be able to determine inherited slots, base class may be any iterable, but not an iterator.\n• None weakref_slot: If true (the default is ), add a slot named “__weakref__”, which is required to make an instance . It is an error to specify without also specifying . s may optionally specify a default value, using normal Python syntax: # 'a' has no default value In this example, both and will be included in the added method, which will be defined as: will be raised if a field without a default value follows a field with a default value. This is true whether this occurs in a single class, or as a result of class inheritance. For common and simple use cases, no other functionality is required. There are, however, some dataclass features that require additional per-field information. To satisfy this need for additional information, you can replace the default field value with a call to the provided function. For example: As shown above, the value is a sentinel object used to detect if some parameters are provided by the user. This sentinel is used because is a valid value for some parameters with a distinct meaning. No code should directly use the value. The parameters to are:\n• None default: If provided, this will be the default value for this field. This is needed because the call itself replaces the normal position of the default value.\n• None default_factory: If provided, it must be a zero-argument callable that will be called when a default value is needed for this field. Among other purposes, this can be used to specify fields with mutable default values, as discussed below. It is an error to specify both default and default_factory.\n• None init: If true (the default), this field is included as a parameter to the generated method.\n• None repr: If true (the default), this field is included in the string returned by the generated method.\n• None hash: This can be a bool or . If true, this field is included in the generated method. If false, this field is excluded from the generated . If (the default), use the value of compare: this would normally be the expected behavior, since a field should be included in the hash if it’s used for comparisons. Setting this value to anything other than is discouraged. One possible reason to set but would be if a field is expensive to compute a hash value for, that field is needed for equality testing, and there are other fields that contribute to the type’s hash value. Even if a field is excluded from the hash, it will still be used for comparisons.\n• None compare: If true (the default), this field is included in the generated equality and comparison methods ( , , et al.).\n• None metadata: This can be a mapping or . is treated as an empty dict. This value is wrapped in to make it read-only, and exposed on the object. It is not used at all by Data Classes, and is provided as a third-party extension mechanism. Multiple third-parties can each have their own key, to use as a namespace in the metadata.\n• None kw_only: If true, this field will be marked as keyword-only. This is used when the generated method’s parameters are computed. If the default value of a field is specified by a call to , then the class attribute for this field will be replaced by the specified default value. If default is not provided, then the class attribute will be deleted. The intent is that after the decorator runs, the class attributes will all contain the default values for the fields, just as if the default value itself were specified. For example, after: The class attribute will be , the class attribute will be , and the class attributes and will not be set. objects describe each defined field. These objects are created internally, and are returned by the module-level method (see below). Users should never instantiate a object directly. Its documented attributes are:\n• None : The name of the field.\n• None : The type of the field.\n• None , , , , , , , and have the identical meaning and values as they do in the function. Other attributes may exist, but they are private and must not be inspected or relied on. Returns a tuple of objects that define the fields for this dataclass. Accepts either a dataclass, or an instance of a dataclass. Raises if not passed a dataclass or instance of one. Does not return pseudo-fields which are or . Converts the dataclass obj to a dict (by using the factory function dict_factory). Each dataclass is converted to a dict of its fields, as pairs. dataclasses, dicts, lists, and tuples are recursed into. Other objects are copied with . Example of using on nested dataclasses: To create a shallow copy, the following workaround may be used: raises if obj is not a dataclass instance. Converts the dataclass obj to a tuple (by using the factory function tuple_factory). Each dataclass is converted to a tuple of its field values. dataclasses, dicts, lists, and tuples are recursed into. Other objects are copied with . Continuing from the previous example: To create a shallow copy, the following workaround may be used: raises if obj is not a dataclass instance. Creates a new dataclass with name cls_name, fields as defined in fields, base classes as given in bases, and initialized with a namespace as given in namespace. fields is an iterable whose elements are each either , , or . If just is supplied, is used for . The values of init, repr, eq, order, unsafe_hash, frozen, match_args, kw_only, slots, and weakref_slot have the same meaning as they do in . If module is defined, the attribute of the dataclass is set to that value. By default, it is set to the module name of the caller. This function is not strictly required, because any Python mechanism for creating a new class with can then apply the function to convert that class to a dataclass. This function is provided as a convenience. For example: Creates a new object of the same type as obj, replacing fields with values from changes. If obj is not a Data Class, raises . If keys in changes are not field names of the given dataclass, raises . The newly returned object is created by calling the method of the dataclass. This ensures that , if present, is also called. Init-only variables without default values, if any exist, must be specified on the call to so that they can be passed to and . It is an error for changes to contain any fields that are defined as having . A will be raised in this case. Be forewarned about how fields work during a call to . They are not copied from the source object, but rather are initialized in , if they’re initialized at all. It is expected that fields will be rarely and judiciously used. If they are used, it might be wise to have alternate class constructors, or perhaps a custom (or similarly named) method which handles instance copying. Dataclass instances are also supported by generic function . Return if its parameter is a dataclass (including subclasses of a dataclass) or an instance of one, otherwise return . If you need to know if a class is an instance of a dataclass (and not a dataclass itself), then add a further check for : A sentinel value used as a type annotation. Any fields after a pseudo-field with the type of are marked as keyword-only fields. Note that a pseudo-field of type is otherwise completely ignored. This includes the name of such a field. By convention, a name of is used for a field. Keyword-only fields signify parameters that must be specified as keywords when the class is instantiated. In this example, the fields and will be marked as keyword-only fields: In a single dataclass, it is an error to specify more than one field whose type is . Raised when an implicitly defined or is called on a dataclass which was defined with . It is a subclass of .\n\nWhen defined on the class, it will be called by the generated , normally as . However, if any fields are defined, they will also be passed to in the order they were defined in the class. If no method is generated, then will not automatically be called. Among other uses, this allows for initializing field values that depend on one or more other fields. For example: The method generated by does not call base class methods. If the base class has an method that has to be called, it is common to call this method in a method: Note, however, that in general the dataclass-generated methods don’t need to be called, since the derived dataclass will take care of initializing all fields of any base class that is a dataclass itself. See the section below on init-only variables for ways to pass parameters to . Also see the warning about how handles fields.\n\nAnother place where inspects a type annotation is to determine if a field is an init-only variable. It does this by seeing if the type of a field is of type . If a field is an , it is considered a pseudo-field called an init-only field. As it is not a true field, it is not returned by the module-level function. Init-only fields are added as parameters to the generated method, and are passed to the optional method. They are not otherwise used by dataclasses. For example, suppose a field will be initialized from a database, if a value is not provided when creating the class: In this case, will return objects for and , but not for .\n\nWhen the dataclass is being created by the decorator, it looks through all of the class’s base classes in reverse MRO (that is, starting at ) and, for each dataclass that it finds, adds the fields from that base class to an ordered mapping of fields. After all of the base class fields are added, it adds its own fields to the ordered mapping. All of the generated methods will use this combined, calculated ordered mapping of fields. Because the fields are in insertion order, derived classes override base classes. An example: The final list of fields is, in order, , , . The final type of is , as specified in class . The generated method for will look like:\n\nFields that are assigned descriptor objects as their default value have the following special behaviors:\n• None The value for the field passed to the dataclass’s method is passed to the descriptor’s method rather than overwriting the descriptor object.\n• None Similarly, when getting or setting the field, the descriptor’s or method is called rather than returning or overwriting the descriptor object.\n• None To determine whether a field contains a default value, will call the descriptor’s method using its class access form: . If the descriptor returns a value in this case, it will be used as the field’s default. On the other hand, if the descriptor raises in this situation, no default value will be provided for the field. Note that if a field is annotated with a descriptor type, but is not assigned a descriptor object as its default value, the field will act like a normal field."
    },
    {
        "link": "https://typing.python.org/en/latest/spec/dataclasses.html",
        "document": "Type checkers should support dataclasses created through the module. In addition, the type system contains a mechanism to make third-party classes behave like standard dataclasses.\n\nThis specification describes a decorator function in the module named . This decorator can be applied to either a function that is itself a decorator, a class, or a metaclass. The presence of tells a static type checker that the decorated function, class, or metaclass performs runtime “magic” that transforms a class, endowing it with dataclass-like behaviors. If is applied to a function, using the decorated function as a decorator is assumed to apply dataclass-like semantics. If the function has overloads, the decorator can be applied to the implementation of the function or any one, but not more than one, of the overloads. When applied to an overload, the decorator still impacts all usage of the function. If is applied to a class, dataclass-like semantics will be assumed for any class that directly or indirectly derives from the decorated class or uses the decorated class as a metaclass. Attributes on the decorated class and its base classes are not considered to be fields. Examples of each approach are shown in the following sections. Each example creates a class with dataclass-like semantics. The implementation of the decorated objects is omitted for brevity, but we assume that they modify classes in the following ways:\n• None They synthesize an method using data fields declared within the class and its parent classes. Type checkers will recognize that the class can be instantiated using the synthesized method: # These calls will generate runtime errors and should be flagged as # The ``create_model`` decorator is defined by a library. # This could be in a type stub or inline. # The ``create_model`` decorator can now be used to create new model # The ``ModelBase`` class is defined by a library. This could be in # The ``ModelBase`` class can now be used to create new model # The ``ModelMeta`` metaclass and ``ModelBase`` class are defined by # a library. This could be in a type stub or inline. # The ``ModelBase`` class can now be used to create new model\n\nParameters to allow for some basic customization of default behaviors:\n• None indicates whether the parameter is assumed to be True or False if it is omitted by the caller. If not specified, will default to True (the default assumption for dataclass).\n• None indicates whether the parameter is assumed to be True or False if it is omitted by the caller. If not specified, will default to False (the default assumption for dataclass).\n• None indicates whether the parameter is assumed to be True or False if it is omitted by the caller. If not specified, will default to False (the default assumption for dataclass).\n• None indicates whether the parameter is assumed to be True or False if it is omitted by the caller. If not specified, will default to False (the default assumption for dataclass).\n• None specifies a static list of supported classes that describe fields. Some libraries also supply functions to allocate instances of field specifiers, and those functions may also be specified in this tuple. If not specified, will default to an empty tuple (no field specifiers supported). The standard dataclass behavior supports only one type of field specifier called plus a helper function ( ) that instantiates this class, so if we were describing the stdlib dataclass behavior, we would provide the tuple argument .\n• None allows arbitrary additional keyword args to be passed to . This gives type checkers the freedom to support experimental parameters without needing to wait for changes in . Type checkers should report errors for any unrecognized parameters. The following sections provide additional examples showing how these parameters are used. # Indicate that the ``create_model`` function assumes keyword-only # parameters for the synthesized ``__init__`` method unless it is # invoked with ``kw_only=False``. It always synthesizes order-related # methods and provides no way to override this behavior. # Example of how this decorator would be used by code that imports # Indicate that classes that derive from this class default to # Example of how this class would be used by code that imports # Indicate that classes that use this metaclass default to # Example of how this class would be used by code that imports\n\nMost libraries that support dataclass-like semantics provide one or more “field specifier” types that allow a class definition to provide additional metadata about each field in the class. This metadata can describe, for example, default values, or indicate whether the field should be included in the synthesized method. Field specifiers can be omitted in cases where additional metadata is not required: # Field with type annotation and simple initializer to # Not a field (but rather a class variable) because type Libraries that support dataclass-like semantics and support field specifier classes typically use common parameter names to construct these field specifiers. This specification formalizes the names and meanings of the parameters that must be understood for static type checkers. These standardized parameters must be keyword-only. These parameters are a superset of those supported by , excluding those that do not have an impact on type checking such as and . Field specifier classes are allowed to use other parameters in their constructors, and those parameters can be positional and may use other names.\n• None is an optional bool parameter that indicates whether the field should be included in the synthesized method. If unspecified, defaults to True. Field specifier functions can use overloads that implicitly specify the value of using a literal bool value type ( or ).\n• None is an optional parameter that provides the default value for the field.\n• None is an optional parameter that provides a runtime callback that returns the default value for the field. If neither nor are specified, the field is assumed to have no default value and must be provided a value when the class is instantiated.\n• None is an alias for . Stdlib dataclasses use the name , but attrs uses the name in many scenarios, so this alias is necessary for supporting attrs.\n• None is an optional bool parameter that indicates whether the field should be marked as keyword-only. If true, the field will be keyword-only. If false, it will not be keyword-only. If unspecified, the value of the parameter on the object decorated with will be used, or if that is unspecified, the value of on will be used.\n• None is an optional str parameter that provides an alternative name for the field. This alternative name is used in the synthesized method.\n• None is an optional parameter that specifies a callable used to convert values when assigning to the field. It is an error to specify more than one of , and . This example demonstrates the above: # In this library, passing a resolver means that init must be False, # and the overload with Literal[False] enforces that.\n\nExcept where stated otherwise, classes impacted by , either by inheriting from a class that is decorated with or by being decorated with a function decorated with , are assumed to behave like stdlib . This includes, but is not limited to, the following semantics:\n• None Frozen dataclasses cannot inherit from non-frozen dataclasses. A class that has been decorated with is considered neither frozen nor non-frozen, thus allowing frozen classes to inherit from it. Similarly, a class that directly specifies a metaclass that is decorated with is considered neither frozen nor non-frozen. # ModelBase is not considered either \"frozen\" or \"non-frozen\" # because it is decorated with ``dataclass_transform`` # Vehicle is considered non-frozen because it does not specify # Car is a frozen class that derives from Vehicle, which is a # non-frozen class. This is an error. # ModelBase is not considered either \"frozen\" or \"non-frozen\" # because it directly specifies ModelMeta as its metaclass. # Vehicle is considered non-frozen because it does not specify # Car is a frozen class that derives from Vehicle, which is a # non-frozen class. This is an error.\n• None Field ordering and inheritance is assumed to follow the rules specified in the Python docs. This includes the effects of overrides (redefining a field in a child class that has already been defined in a parent class).\n• None PEP 557 indicates that all fields without default values must appear before fields with default values. Although not explicitly stated in PEP 557, this rule is ignored when , and this specification likewise ignores this requirement in that situation. Likewise, there is no need to enforce this ordering when keyword-only parameters are used for , so the rule is not enforced if semantics are in effect.\n• None As with , method synthesis is skipped if it would overwrite a method that is explicitly declared within the class. Method declarations on base classes do not cause method synthesis to be skipped. For example, if a class declares an method explicitly, an method will not be synthesized for that class.\n• None KW_ONLY sentinel values are supported as described in the Python docs and bpo-43532.\n• None ClassVar attributes are not considered dataclass fields and are ignored by dataclass mechanisms.\n• None A dataclass field may be annotated with . For example, in a dataclass body specifies a dataclass field , which will be initialized in the generated and cannot be assigned to thereafter. A dataclass field initialized in the class body is not a class attribute unless explicitly annotated with . For example, is a dataclass field named with a default value of in the generated method. A final class variable on a dataclass must be explicitly annotated as e.g. ."
    },
    {
        "link": "https://typing.readthedocs.io/en/latest/spec/dataclasses.html",
        "document": "Type checkers should support dataclasses created through the module. In addition, the type system contains a mechanism to make third-party classes behave like standard dataclasses.\n\nThis specification describes a decorator function in the module named . This decorator can be applied to either a function that is itself a decorator, a class, or a metaclass. The presence of tells a static type checker that the decorated function, class, or metaclass performs runtime “magic” that transforms a class, endowing it with dataclass-like behaviors. If is applied to a function, using the decorated function as a decorator is assumed to apply dataclass-like semantics. If the function has overloads, the decorator can be applied to the implementation of the function or any one, but not more than one, of the overloads. When applied to an overload, the decorator still impacts all usage of the function. If is applied to a class, dataclass-like semantics will be assumed for any class that directly or indirectly derives from the decorated class or uses the decorated class as a metaclass. Attributes on the decorated class and its base classes are not considered to be fields. Examples of each approach are shown in the following sections. Each example creates a class with dataclass-like semantics. The implementation of the decorated objects is omitted for brevity, but we assume that they modify classes in the following ways:\n• None They synthesize an method using data fields declared within the class and its parent classes. Type checkers will recognize that the class can be instantiated using the synthesized method: # These calls will generate runtime errors and should be flagged as # The ``create_model`` decorator is defined by a library. # This could be in a type stub or inline. # The ``create_model`` decorator can now be used to create new model # The ``ModelBase`` class is defined by a library. This could be in # The ``ModelBase`` class can now be used to create new model # The ``ModelMeta`` metaclass and ``ModelBase`` class are defined by # a library. This could be in a type stub or inline. # The ``ModelBase`` class can now be used to create new model\n\nParameters to allow for some basic customization of default behaviors:\n• None indicates whether the parameter is assumed to be True or False if it is omitted by the caller. If not specified, will default to True (the default assumption for dataclass).\n• None indicates whether the parameter is assumed to be True or False if it is omitted by the caller. If not specified, will default to False (the default assumption for dataclass).\n• None indicates whether the parameter is assumed to be True or False if it is omitted by the caller. If not specified, will default to False (the default assumption for dataclass).\n• None indicates whether the parameter is assumed to be True or False if it is omitted by the caller. If not specified, will default to False (the default assumption for dataclass).\n• None specifies a static list of supported classes that describe fields. Some libraries also supply functions to allocate instances of field specifiers, and those functions may also be specified in this tuple. If not specified, will default to an empty tuple (no field specifiers supported). The standard dataclass behavior supports only one type of field specifier called plus a helper function ( ) that instantiates this class, so if we were describing the stdlib dataclass behavior, we would provide the tuple argument .\n• None allows arbitrary additional keyword args to be passed to . This gives type checkers the freedom to support experimental parameters without needing to wait for changes in . Type checkers should report errors for any unrecognized parameters. The following sections provide additional examples showing how these parameters are used. # Indicate that the ``create_model`` function assumes keyword-only # parameters for the synthesized ``__init__`` method unless it is # invoked with ``kw_only=False``. It always synthesizes order-related # methods and provides no way to override this behavior. # Example of how this decorator would be used by code that imports # Indicate that classes that derive from this class default to # Example of how this class would be used by code that imports # Indicate that classes that use this metaclass default to # Example of how this class would be used by code that imports\n\nMost libraries that support dataclass-like semantics provide one or more “field specifier” types that allow a class definition to provide additional metadata about each field in the class. This metadata can describe, for example, default values, or indicate whether the field should be included in the synthesized method. Field specifiers can be omitted in cases where additional metadata is not required: # Field with type annotation and simple initializer to # Not a field (but rather a class variable) because type Libraries that support dataclass-like semantics and support field specifier classes typically use common parameter names to construct these field specifiers. This specification formalizes the names and meanings of the parameters that must be understood for static type checkers. These standardized parameters must be keyword-only. These parameters are a superset of those supported by , excluding those that do not have an impact on type checking such as and . Field specifier classes are allowed to use other parameters in their constructors, and those parameters can be positional and may use other names.\n• None is an optional bool parameter that indicates whether the field should be included in the synthesized method. If unspecified, defaults to True. Field specifier functions can use overloads that implicitly specify the value of using a literal bool value type ( or ).\n• None is an optional parameter that provides the default value for the field.\n• None is an optional parameter that provides a runtime callback that returns the default value for the field. If neither nor are specified, the field is assumed to have no default value and must be provided a value when the class is instantiated.\n• None is an alias for . Stdlib dataclasses use the name , but attrs uses the name in many scenarios, so this alias is necessary for supporting attrs.\n• None is an optional bool parameter that indicates whether the field should be marked as keyword-only. If true, the field will be keyword-only. If false, it will not be keyword-only. If unspecified, the value of the parameter on the object decorated with will be used, or if that is unspecified, the value of on will be used.\n• None is an optional str parameter that provides an alternative name for the field. This alternative name is used in the synthesized method.\n• None is an optional parameter that specifies a callable used to convert values when assigning to the field. It is an error to specify more than one of , and . This example demonstrates the above: # In this library, passing a resolver means that init must be False, # and the overload with Literal[False] enforces that.\n\nExcept where stated otherwise, classes impacted by , either by inheriting from a class that is decorated with or by being decorated with a function decorated with , are assumed to behave like stdlib . This includes, but is not limited to, the following semantics:\n• None Frozen dataclasses cannot inherit from non-frozen dataclasses. A class that has been decorated with is considered neither frozen nor non-frozen, thus allowing frozen classes to inherit from it. Similarly, a class that directly specifies a metaclass that is decorated with is considered neither frozen nor non-frozen. # ModelBase is not considered either \"frozen\" or \"non-frozen\" # because it is decorated with ``dataclass_transform`` # Vehicle is considered non-frozen because it does not specify # Car is a frozen class that derives from Vehicle, which is a # non-frozen class. This is an error. # ModelBase is not considered either \"frozen\" or \"non-frozen\" # because it directly specifies ModelMeta as its metaclass. # Vehicle is considered non-frozen because it does not specify # Car is a frozen class that derives from Vehicle, which is a # non-frozen class. This is an error.\n• None Field ordering and inheritance is assumed to follow the rules specified in the Python docs. This includes the effects of overrides (redefining a field in a child class that has already been defined in a parent class).\n• None PEP 557 indicates that all fields without default values must appear before fields with default values. Although not explicitly stated in PEP 557, this rule is ignored when , and this specification likewise ignores this requirement in that situation. Likewise, there is no need to enforce this ordering when keyword-only parameters are used for , so the rule is not enforced if semantics are in effect.\n• None As with , method synthesis is skipped if it would overwrite a method that is explicitly declared within the class. Method declarations on base classes do not cause method synthesis to be skipped. For example, if a class declares an method explicitly, an method will not be synthesized for that class.\n• None KW_ONLY sentinel values are supported as described in the Python docs and bpo-43532.\n• None ClassVar attributes are not considered dataclass fields and are ignored by dataclass mechanisms.\n• None A dataclass field may be annotated with . For example, in a dataclass body specifies a dataclass field , which will be initialized in the generated and cannot be assigned to thereafter. A dataclass field initialized in the class body is not a class attribute unless explicitly annotated with . For example, is a dataclass field named with a default value of in the generated method. A final class variable on a dataclass must be explicitly annotated as e.g. ."
    },
    {
        "link": "https://stackoverflow.com/questions/54668000/type-hint-for-an-instance-of-a-non-specific-dataclass",
        "document": "Despite its name, doesn't expose a class interface. It just allows you to declare a custom class in a convenient way that makes it obvious that it is going to be used as a data container. So, in theory, there is little opportunity to write something that only works on dataclasses, because dataclasses really are just ordinary classes.\n\nIn practice, there a couple of reasons why you would want to declare dataclass-only functions anyway, and something like this is how you should go about it:\n\nThis approach is also what you alluded to in your question. If you want to go for it, keep in mind that you'll need a third party library such as to do the static type checking for you, and if you are on python or earlier, you need to manually install since only became part of the standard library in .\n\nAlso noted that older version of mypy ( ) mistakenly expect to be an instance attribute, so the protocol should be just [1].\n\nWhen I first wrote it, this post also featured The Old Way of Doing Things, back when we had to make do without type checkers. I'm leaving it up, but it's not recommended to handle this kind of feature with runtime-only failures any more:\n\n[1] Kudos to @Kound for updating and testing the behavior."
    },
    {
        "link": "https://discuss.python.org/t/dataclasses-make-use-of-annotated/30028",
        "document": "are great and I make extensive use of them but there is something which I always find non-matching. Example: Having declared to be of type the assignment is the result of a callable which (as an end-user) I am not sure it is returning an Given that can convey metainformation, would it not be really appropriate to use it for dataclasses, as in: This should be clearer for anyone:\n• the type for is\n• the information that it must not be part of is in the metainformation inside with the use of .\n• And the default value is assigned to as expected.\n\nAnd here is a small proof of concept #!/usr/bin/env python # -*- coding: utf-8; py-indent-offset:4 -*- ############################################################################### from __future__ import annotations from collections.abc import Callable from dataclasses import dataclass, Field, MISSING import inspect from typing import Annotated, get_args, get_origin, overload @overload def ann_dataclass(cls: None = None, **kwargs) -> Callable[[type], type]: ... @overload def ann_dataclass(cls: type, **kwargs) -> type: ... def ann_dataclass(cls: type | None = None, **kwargs) -> type | Callable[[type], type]: # actual decorator for when cls is not None def _annotify(cls: type) -> type: # Fetch the annotations using latest best practices # and from __future__ import annotations mey the default in the future ann = inspect.get_annotations(cls, eval_str=True) for name, thint in ann.items(): if get_origin(thint) is not Annotated: continue # It is an Annotated type hint, see if there is any Field metainfo _type, *metainfos = get_args(thint) for metainfo in metainfos: if not isinstance(metainfo, Field): continue # not the use case, let it go try: default = getattr(cls, name) # check if default value exists except AttributeError: pass else: # standard dc check for both default and default_factory if ( default is not MISSING and metainfo.default_factory is not MISSING ): raise ValueError( \"cannot specify both default and default_factory\" ) metainfo.default = default # can be safely assigned # record the actual type defined in Annotated metainfo.type = _type # put the \"Field\" as default value for dataclass decorator setattr(cls, name, metainfo) break # only 1 Field to be processed ... break out return dataclass(cls, **kwargs) # class ready for further processing if cls is None: return _annotify # -> Callable[[type], type] return _annotify(cls) # -> type # Small test if __name__ == '__main__': from dataclasses import field, fields from typing import ClassVar @ann_dataclass class A: cv: ClassVar[str] = 'classvar' a: int = 5 b: Annotated[str, field(init=False)] = 'annotated field' a = A() print(f\"{a.__annotations__ = }\") print(f\"{a.cv = }\") print(f\"{a.a = }\") print(f\"{a.b = }\") print(f\"{fields(a) = }\") Edit: recording the actual type defined in in the resulting\n\nExisting stdlib modules are not changed just because a new thing is added to the language, but when it solves a problem or really improves something. Having declared to be of type the assignment is the result of a callable which (as an end-user) I am not sure it is returning an I am not a heavy user of typing, but I do not see a problem.\n\n We declare to be an int variable on instances of the class.\n\n We also assign to whatever returns so that the class works.\n\n These two things make sense to me, and type checkers also think it’s fine. No problem here!\n\nThese two things make sense to me, and type checkers also think it’s fine. No problem here! In fairness, type checkers think it’s fine because they have a special case for dataclasses. One benefit of the proposal is that it removes the special case, which is a benefit to readers of code. On the other hand, does this proposal work with the stringifying that currently happens when someone does ? Would it be better to wait for PEP 649 to be added to the language? We declare to be an int variable on instances of the class.\n\n We also assign to whatever returns so that the class works. Yeah, but it’s odd to assign a value of type to a variable of type . There aren’t many places where type checkers think it’s okay for you to do anything like that. Question: may it be the type checkers have been properly “trained” to ignore a instance (the return value of ) rather than actually doing some type checking? At least MyPy and Pyright are type checking fields. They verify that the field’s default or default-factory has the correct type.\n\nIt certainly is doable. And I suspect that maybe if existed when dataclasses was being proposed, it mightve been used instead of what we have today. However, just because there’s a new way of doing things, I don’t think justifies making it so there’s multiple ways of representing the same information. What’s the value add, that outweighs the cost of additional maintenance, additional type-checker code, documentation, etc…? Again, I think what you propose is ideal in a vacuum. But it has to be worthwhile to break “there should be one, and preferably one, way of doing things” Edit: but this is just my opinion. Please do see what others think. But he prepared with strong arguments for why it needs to exist\n\nFrom typing perspective how dataclasses fits in is reasonably well explained by PEP 681. The introduction of PEP highlights a lot of core aspects of dataclasses and how they are exceptional typing wise. It serves as main way to help other similar libraries also be understood by type checkers mostly by saying if you are similar enough to dataclasses you can say your library implements a dataclass transform. I’d say biggest two special aspects of dataclasses from typing view is that the decorator derives an init based on fields and the specialness of how dataclasses.field behaves. Another view is that dataclasses are a decorator that extends a class with additional methods. There’s currently no good way in type system do describe that. For example, let’s say you have a decorator that introduces one new method to your class like def support_metrics(cls): def _log_metrics(metric: str, value: float) -> None: … cls.log_metrics = _log_metrics return cls @support_metrics class Foo: … a = Foo() a.log_metrics(“user_event”, 1.0) # Code is safe and fine at runtime but no type checker will understand this. You can view dataclasses as more complex/much nicer decorator than that one. But how do you say in type system that you take a cls as input and return that same type extended with new methods? There’s currently no way to do that which is big reason why dataclasses is so special. There are various proposals/discussions for ways to support this kind of stuff but I don’t think any of them are at PEP stage."
    },
    {
        "link": "https://stackoverflow.com/questions/66540017/whats-the-best-practice-of-typing-hint-after-python-3-9",
        "document": "After python3.9, there are at least three ways to use typing hint. Take the build-in collection for instance:\n\nFurthermore, for some abstract type there are two version in and , take for instance:\n\nAccording to The Zen of Python:\n\nI am confused which one is best?"
    },
    {
        "link": "https://docs.python.org/3/library/typing.html",
        "document": "This module provides runtime support for type hints.\n\nConsider the function below:\n\nThe function takes an argument expected to be an instance of , as indicated by the type hint . The function is expected to return an instance of , as indicated by the hint.\n\nWhile type hints can be simple classes like or , they can also be more complex. The module provides a vocabulary of more advanced type hints.\n\nNew features are frequently added to the module. The typing_extensions package provides backports of these new features to older versions of Python.\n\nUse the helper to create distinct types: The static type checker will treat the new type as if it were a subclass of the original type. This is useful in helping catch logical errors: # fails type checking; an int is not a UserId You may still perform all operations on a variable of type , but the result will always be of type . This lets you pass in a wherever an might be expected, but will prevent you from accidentally creating a in an invalid way: # 'output' is of type 'int', not 'UserId' Note that these checks are enforced only by the static type checker. At runtime, the statement will make a callable that immediately returns whatever parameter you pass it. That means the expression does not create a new class or introduce much overhead beyond that of a regular function call. More precisely, the expression is always true at runtime. It is invalid to create a subtype of : # Fails at runtime and does not pass type checking However, it is possible to create a based on a ‘derived’ : and typechecking for will work as expected. See PEP 484 for more details. Recall that the use of a type alias declares two types to be equivalent to one another. Doing will make the static type checker treat as being exactly equivalent to in all cases. This is useful when you want to simplify complex type signatures. In contrast, declares one type to be a subtype of another. Doing will make the static type checker treat as a subclass of , which means a value of type cannot be used in places where a value of type is expected. This is useful when you want to prevent logic errors with minimal runtime cost. Changed in version 3.10: is now a class rather than a function. As a result, there is some additional runtime cost when calling over a regular function. Changed in version 3.11: The performance of calling has been restored to its level in Python 3.9.\n\nFor most containers in Python, the typing system assumes that all elements in the container will be of the same type. For example: # Type checker will infer that all elements in ``x`` are meant to be ints # Type checker will infer that all keys in ``z`` are meant to be strings, # and that all values in ``z`` are meant to be either strings or ints only accepts one type argument, so a type checker would emit an error on the assignment above. Similarly, only accepts two type arguments: the first indicates the type of the keys, and the second indicates the type of the values. Unlike most other Python containers, however, it is common in idiomatic Python code for tuples to have elements which are not all of the same type. For this reason, tuples are special-cased in Python’s typing system. accepts any number of type arguments: # OK: ``x`` is assigned to a tuple of length 1 where the sole element is an int # OK: ``y`` is assigned to a tuple of length 2; # element 1 is an int, element 2 is a str # Error: the type annotation indicates a tuple of length 1, # but ``z`` has been assigned to a tuple of length 3 To denote a tuple which could be of any length, and in which all elements are of the same type , use . To denote an empty tuple, use . Using plain as an annotation is equivalent to using : # These reassignments are OK: ``tuple[int, ...]`` indicates x can be of any length # This reassignment is an error: all elements in ``x`` must be ints # ``y`` can only ever be assigned to an empty tuple # These reassignments are OK: plain ``tuple`` is equivalent to ``tuple[Any, ...]``\n\nA user-defined class can be defined as a generic class. This syntax indicates that the class is parameterised around a single type variable . This also makes valid as a type within the class body. Generic classes implicitly inherit from . For compatibility with Python 3.11 and lower, it is also possible to inherit explicitly from to indicate a generic class: Generic classes have methods, meaning they can be parameterised at runtime (e.g. below): A generic type can have any number of type variables. All varieties of are permissible as parameters for a generic type: Each type variable argument to must be distinct. This is thus invalid: Generic classes can also inherit from other classes: When inheriting from generic classes, some type parameters could be fixed: In this case has a single parameter, . Using a generic class without specifying type parameters assumes for each position. In the following example, is not generic but implicitly inherits from : # Return type here is same as Iterable[str] | int For backward compatibility, generic type aliases can also be created through a simple assignment: Changed in version 3.7: no longer has a custom metaclass. Changed in version 3.12: Syntactic support for generics and type aliases is new in version 3.12. Previously, generic classes had to explicitly inherit from or contain a type variable in one of their bases. User-defined generics for parameter expressions are also supported via parameter specification variables in the form . The behavior is consistent with type variables’ described above as parameter specification variables are treated by the typing module as a specialized type variable. The one exception to this is that a list of types can be used to substitute a : Classes generic over a can also be created using explicit inheritance from . In this case, is not used: Another difference between and is that a generic with only one parameter specification variable will accept parameter lists in the forms and also for aesthetic reasons. Internally, the latter is converted to the former, so the following are equivalent: Note that generics with may not have correct after substitution in some cases because they are intended primarily for static type checking. Changed in version 3.10: can now be parameterized over parameter expressions. See and PEP 612 for more details. A user-defined generic class can have ABCs as base classes without a metaclass conflict. Generic metaclasses are not supported. The outcome of parameterizing generics is cached, and most types in the typing module are hashable and comparable for equality.\n\nA special kind of type is . A static type checker will treat every type as being compatible with and as being compatible with every type. This means that it is possible to perform any operation or method call on a value of type and assign it to any variable: # Passes type checking; 'item' could be any type, # and that type might have a 'bar' method Notice that no type checking is performed when assigning a value of type to a more precise type. For example, the static type checker did not report an error when assigning to even though was declared to be of type and receives an value at runtime! Furthermore, all functions without a return type or parameter types will implicitly default to using : # A static type checker will treat the above # as having the same signature as: This behavior allows to be used as an escape hatch when you need to mix dynamically and statically typed code. Contrast the behavior of with the behavior of . Similar to , every type is a subtype of . However, unlike , the reverse is not true: is not a subtype of every other type. That means when the type of a value is , a type checker will reject almost all operations on it, and assigning it to a variable (or using it as a return value) of a more specialized type is a type error. For example: # Fails type checking; an object does not have a 'magic' method. # Passes type checking, since ints and strs are subclasses of object # Passes type checking, since Any is compatible with all types Use to indicate that a value could be any type in a typesafe manner. Use to indicate that a value is dynamically typed."
    },
    {
        "link": "https://docs.python.org/3.9/library/typing.html",
        "document": "This module provides runtime support for type hints. The most fundamental support consists of the types , , , , and . For a full specification, please see PEP 484. For a simplified introduction to type hints, see PEP 483.\n\nThe function below takes and returns a string and is annotated as follows:\n\nIn the function , the argument is expected to be of type and the return type . Subtypes are accepted as arguments.\n\nNew features are frequently added to the module. The typing_extensions package provides backports of these new features to older versions of Python.\n\nUse the helper to create distinct types: The static type checker will treat the new type as if it were a subclass of the original type. This is useful in helping catch logical errors: # does not typecheck; an int is not a UserId You may still perform all operations on a variable of type , but the result will always be of type . This lets you pass in a wherever an might be expected, but will prevent you from accidentally creating a in an invalid way: # 'output' is of type 'int', not 'UserId' Note that these checks are enforced only by the static type checker. At runtime, the statement will make a callable that immediately returns whatever parameter you pass it. That means the expression does not create a new class or introduce any overhead beyond that of a regular function call. More precisely, the expression is always true at runtime. This also means that it is not possible to create a subtype of since it is an identity function at runtime, not an actual type: # Fails at runtime and does not typecheck However, it is possible to create a based on a ‘derived’ : and typechecking for will work as expected. See PEP 484 for more details. Recall that the use of a type alias declares two types to be equivalent to one another. Doing will make the static type checker treat as being exactly equivalent to in all cases. This is useful when you want to simplify complex type signatures. In contrast, declares one type to be a subtype of another. Doing will make the static type checker treat as a subclass of , which means a value of type cannot be used in places where a value of type is expected. This is useful when you want to prevent logic errors with minimal runtime cost.\n\nA user-defined class can be defined as a generic class. as a base class defines that the class takes a single type parameter . This also makes valid as a type within the class body. The base class defines so that is valid as a type: A generic type can have any number of type variables. All varieties of are permissible as parameters for a generic type: Each type variable argument to must be distinct. This is thus invalid: You can use multiple inheritance with : When inheriting from generic classes, some type variables could be fixed: In this case has a single parameter, . Using a generic class without specifying type parameters assumes for each position. In the following example, is not generic but implicitly inherits from : # Return type here is same as Union[Iterable[str], int] Changed in version 3.7: no longer has a custom metaclass. A user-defined generic class can have ABCs as base classes without a metaclass conflict. Generic metaclasses are not supported. The outcome of parameterizing generics is cached, and most types in the typing module are hashable and comparable for equality.\n\nA special kind of type is . A static type checker will treat every type as being compatible with and as being compatible with every type. This means that it is possible to perform any operation or method call on a value of type and assign it to any variable: # Typechecks; 'item' could be any type, # and that type might have a 'bar' method Notice that no typechecking is performed when assigning a value of type to a more precise type. For example, the static type checker did not report an error when assigning to even though was declared to be of type and receives an value at runtime! Furthermore, all functions without a return type or parameter types will implicitly default to using : # A static type checker will treat the above # as having the same signature as: This behavior allows to be used as an escape hatch when you need to mix dynamically and statically typed code. Contrast the behavior of with the behavior of . Similar to , every type is a subtype of . However, unlike , the reverse is not true: is not a subtype of every other type. That means when the type of a value is , a type checker will reject almost all operations on it, and assigning it to a variable (or using it as a return value) of a more specialized type is a type error. For example: # Fails; an object does not have a 'magic' method. # Typechecks, since ints and strs are subclasses of object # Typechecks, since Any is compatible with all types Use to indicate that a value could be any type in a typesafe manner. Use to indicate that a value is dynamically typed.\n\nInitially PEP 484 defined the Python static type system as using nominal subtyping. This means that a class is allowed where a class is expected if and only if is a subclass of . This requirement previously also applied to abstract base classes, such as . The problem with this approach is that a class had to be explicitly marked to support them, which is unpythonic and unlike what one would normally do in idiomatic dynamically typed Python code. For example, this conforms to PEP 484: PEP 544 allows to solve this problem by allowing users to write the above code without explicit base classes in the class definition, allowing to be implicitly considered a subtype of both and by static type checkers. This is known as structural subtyping (or static duck-typing): Moreover, by subclassing a special class , a user can define new custom protocols to fully enjoy structural subtyping (see examples below)."
    },
    {
        "link": "https://medium.com/@BryMei/modernize-your-python-with-type-hints-a907a15fd904",
        "document": "I like Python because it’s often the quickest solution with a mature ecosystem that gets the job done. It’s incredibly versatile, letting me work on CI/CD deployments with Dagger or AWS, automate boring tasks like spreadsheet creation, run a webserver, or even create desktop games (though I’ve only followed the PyGame tutorial to make Snake). However, as projects grow, maintaining code quality becomes challenging, especially in a team setting. Multiple times I’ve returned to refactor Python code I wrote only a year ago to find it too “spaghetti-like” for my liking.\n\nFortunately, modern Python offers great built-in and community tools. Learning and following best practices can address some of Python’s weaknesses. Let’s explore how type hints and static analysis can make your Python code cleaner, more maintainable, and less error-prone in a team environment.\n\nType hints, introduced in PEP 484 in 2014, are a game-changer to larger python projects. They allow you to add static type information to your code, bringing the benefits of static typing to your dynamically typed Python programs. Skeptic say, “well actually it doesn’t enforce anything at run time” and they’d be right. But it’s called a “hint” for a reason;\n\nThere is a standard library called that has a bunch of types. Some of these…"
    },
    {
        "link": "https://dagster.io/blog/python-type-hinting",
        "document": "In part VI of our Data Engineering with Python series, we explore type hinting functions and classes, and how type hints reduce errors.\n\nOne of the powerful tools Python provides to promote clear and reliable code is the concept of 'type hints'. You might wonder, \"Python is a dynamically-typed language, so why should I bother with types?\"\n\nAs a data engineer or a Python beginner interested in coding best practices, understanding and applying type hints in your Python code can be a real asset.\n\nIn this article, we will delve deeper into type hints, their applications, and their benefits in Python programming. As Dagster is a type-annotated framework, we’ll also explain how types can be used in data engineering pipelines to improve its readability and make it less error-prone. It's like providing a map to your future self and other developers who may interact with your code - a map that details the types of data flowing in and out of your functions and classes.\n\nPython is a dynamically-typed language. In static-typed languages like Java or C++, you have to declare the type of variables before using them. For example, you need to specify whether a variable is an integer, a float, a string, etc. In Python, you can code without giving a second thought to data types until runtime–which is one of the features that make Python particularly beginner-friendly.\n\nFor example, you can declare a variable and directly assign a value to it without specifying its type, hence the term 'dynamically-typed'. Python interpreter implicitly binds the value and its type at runtime.\n\nIn the first line, is an integer. In the second line, the same becomes a string. Python handles this transition seamlessly thanks to its dynamic typing nature.\n\nHowever, this dynamic nature can also lead to bugs that are difficult to debug, especially in large codebases or complex data processing pipelines, where the data flow might not be immediately obvious.\n\nType hints, introduced in Python 3.5 as a part of the standard library via PEP 484, allow you to specify the expected type of a variable, function parameter, or return value.\n\nWhile dynamic typing offers flexibility, it also creates room for potential bugs. Here's where type hints come in. They can significantly enhance code readability and prevent type-related errors.\n\nImproved code readability: Type hints act as a form of documentation that helps developers understand the types of arguments a function expects and what it returns. This enhanced clarity makes the code more readable and easier to understand.\n\nError detection: Tools like 'pyright' and can be used to statically analyze your Python code. It checks the consistency of types in your code based on the type hints and alerts you about type-related errors before runtime. Learn why the Dagster team recommends skipping entirely and just using .\n\nBetter IDE support: Many Integrated Development Environments (IDEs) and linters can utilize type hints to provide better code completion, error checking, and refactoring.\n\nFacilitates large-scale projects: For larger projects with multiple developers, type hints can be very beneficial in understanding the structure and flow of data throughout the codebase. We’ve published a guide on how to include and maintain type annotations for public Python projects.\n\nNot enforced at runtime: Python's type hints are not enforced but are merely hints, and the Python interpreter will not raise errors if the provided types do not match the actual values. This might lead to a misconception that type hints can enforce type safety, which they cannot.\n\nOver-complicated: For small or simple scripts, type hints might seem like an overkill, and could potentially complicate code that should be straightforward and simple.\n\nNot flexible: One of the reasons for Python's popularity is its dynamic nature and type hints can restrict this.\n\nPython's module contains several functions and classes that are used to provide type hints for your Python code. Here's how you can apply type hints in different scenarios.\n\nTo provide type hints for variables, you can use the colon symbol followed by the type. Here's an example:\n\nHere, is hinted as an integer, as a string, and as a boolean.\n\nYou can provide type hints for function parameters and return values. This helps other developers understand what types of arguments are expected by the function and what type the function returns.\n\nIn this example, the function expects to be a string and will return a string.\n\nPython has several built-in types. The most commonly used are:\n\nThere are also complex types such as lists, tuples, and dictionaries that can be used to provide more detailed type hints that we will look at later on.\n\nYou will also find a list of Python's main types in the appendix.\n\nIn Python, there is a distinction between atomic and composite types when it comes to type hinting. Atomic types, such as , , and , are simple and indivisible, and their type annotations can be provided directly using the type itself, like .\n\nOn the other hand, composite types like and are composed of other types, and before Python 3.9, they often required importing specific definitions from the typing module, such as for a list of integers.\n\nIn newer versions of Python, you can write instead of .\n\nType hints can be particularly useful when incorporated into function signatures. This not only allows developers to understand what types of arguments a function expects but also gives them an idea of what the function will return.\n\nHow to specify argument types and return type of a function\n\nYou can specify the types of arguments and the return type of a function using the symbol for the arguments and the symbol for the return type. Here's the general syntax:\n\nIn this syntax, , , etc. are the function arguments, and , , etc. are the types of these arguments. is the type of value the function returns.\n\nExamples of using type hints in function signatures\n\nLet's consider a function that calculates the area of a rectangle:\n\nIn this function, and are expected to be floats, and the function also returns a float. The function will still work if you pass integers or even strings that can be converted to a float, but the type hint makes it clear that it's designed to handle floating-point numbers.\n\nAnother example can be a function that accepts a list of integers and returns their sum as an integer:\n\nIn this example, the parameter is hinted as a list of integers, and the return type is an integer.\n\nNote that these type hints do not enforce type checking at runtime. They are hints for developers, and Python will not raise a if the actual types do not match the specified types.\n\nThe typing module in Python provides several classes that can be used to provide more complex type hints. Below are some of the most commonly used classes:\n\nThe , , , and classes can be used to provide type hints for lists, dictionaries, tuples, and sets respectively. They can be parameterized to provide even more detailed type hints.\n\nIn these examples, is hinted as a list of integers, is a dictionary with string keys and float values, is a tuple with integers and a string, and is a set of strings.\n\nThe type hint can be used to indicate that a variable can be either a specific type or .\n\nThe type hint is used to indicate that a variable can be one of several types. For example, if a variable can be either a or an , you can provide a type hint like this:\n\nIn newer versions of Python, you can use the pipe (|) operator to indicate a type that can be one of several options, replacing the need for :\n\nThe class is used to indicate that a variable can be of any type. This is equivalent to not providing a type hint at all.\n\nThese tools from the module can help you provide detailed type hints that make your code easier to understand and debug.\n\nHowever, remember that Python's type hints are optional and not enforced at runtime. They are intended as a tool for developers, not a way to enforce type safety.\n\nIn Python, you can define your own types using classes, which is the fundamental mechanism to create custom types. You can use these classes in type hints just like you'd use the built-in types. The module also provides additional tools for creating more specific types, including and .\n\nDefining your own types using classes\n\nYou can create a class and use it as a type hint. Here's an example:\n\nis a user-defined type, and it's used as a type hint in the function.\n\nThe class from the module can be used to indicate that a variable will be a class, not an instance of a class. This is commonly used when a function argument is expected to be a class, for example in factory functions.\n\nIn this example, expects a class (or a subclass of ) as its first argument.\n\nis used to create distinct types. It's useful when you want to distinguish between two types that would otherwise be the same.\n\nFor example, let's say you're dealing with student IDs and course IDs in your program, and you want to make sure you don't mix them up. Both are represented as integers, so you can use to create two distinct types:\n\nEven though and are both integers, they are considered distinct types and cannot be used interchangeably. However, remember that this check is not enforced at runtime, but during static type checking using tools like .\n\nGenerics allows you to define a function, class, or data structure that works with different types. The class and the function from the module are used to define generic types. For example, a list is a generic data structure because it can contain elements of any type.\n\nTypeVar is used to define a type variable, which can be any type, and the specific type is determined by the client code. Here's an example:\n\nHere, is a type variable that can be any type. The function works with a list of any type and returns an element of that type. The specific type of would be determined by the list you pass to the function.\n\nis used to define generic classes. A generic class can be initialized with a variety of types, and those types are used in type hints within the class.\n\nHere, is a generic class that works with any type . When you create an instance of , you can specify the type of , and that type is used in the attribute and the method.\n\nis a that contains an integer, and is a that contains a string.\n\nA type checker like is a tool used to enforce type hinting in Python. At Dagster, we really like because it is faster than other alternatives such as .\n\nPython itself is a dynamically-typed language, which means type checks happen at runtime and it does not enforce type hinting rules. If you try to perform an operation that's not supported for a given data type, Python will raise an error during runtime. For example, calling an undefined method on an object will only trigger an error during runtime.\n\nHowever, when developing large or complex systems, enforcing type consistency can help catch potential bugs early. performs static type checking, meaning it checks the types of your variables, function arguments, and return values before the code is actually run. It uses the type hints you've provided in your code to do this. It's important to understand that does not execute or run your code; it simply reads and analyzes it.\n\nHow to use a type checker to verify your types\n\nTo use , you first need to install it:\n\nThen, to check a Python file, you run with the file as an argument:\n\nPyright will then analyze the file and report any type errors it finds.\n\nFor example, if you have a function that's annotated to receive a as an argument and you pass an , will catch this.\n\nStatic type checking is the process of verifying the type safety of a program based on analysis of a program's text (source code). Static type checking is done at compile-time (before the program is run). Languages that enforce static type checking include C++, Java, and Rust.\n\nDynamic type checking, on the other hand, is the process of verifying the type safety of a program at runtime. Dynamic type checking occurs while the program is running. Languages that use dynamic type checking include Python, Ruby, and JavaScript.\n\nIn static type checking, types are checked before the program runs, which makes it easier to catch and prevent type errors. This makes the program safer to run, as most type-related bugs have been caught at compile-time. However, it also requires the programmer to explicitly declare the types of all variables and function return values, which can be seen as reducing flexibility.\n\nDynamic type checking provides more flexibility, as you don't have to explicitly declare the type of every variable. However, this also means that type errors can occur at runtime, which could potentially cause the program to crash.\n\nPython is a dynamically-typed language, but it also supports optional static type checking through tools like and type hints. This provides Python programmers with a unique flexibility, allowing them to choose when they want the safety of static type checking and when they prefer the flexibility of dynamic typing.\n\nType hints, as we've discussed, indicate the types of variables, function parameters, and return values. They can help other developers understand what types of data your function expects and what it will return.\n\nDocstrings, on the other hand, are used to provide a description of what your function, class, or module does. A docstring can include a description of the function's purpose, its arguments, its return value, and any exceptions it may raise.\n\nHere's an example of how you can use type hints and docstrings together:\n\nHere, the function signature shows that the function takes a list of dictionaries representing products, a string representing an attribute, and an integer representing a minimum value. It returns a list of filtered and sorted dictionaries.\n\nThe doc strings explain the purpose of the function, its parameters, return value, possible exceptions (such as a if the given attribute is not present), and includes an example of how to call the function.\n\nThis combination of type hints and docstrings can greatly improve the readability and maintainability of your code.\n\nBuilding on Python programming best practices, we’ve looked at how type hints improve the readability and maintainability of your code.\n\nIf you have any questions or need further clarification, feel free to join the Dagster Slack and ask the community for help. Thank you for reading!\n\nOur next article builds on these data engineering concepts and explores how Factory Patterns help you automate steps in your pipeline.\n\nSign up for our newsletter to stay in the loop!\n\nWe're always happy to hear your feedback, so please reach out to us! If you have any questions, ask them in the Dagster community Slack (join here!) or start a Github discussion. If you run into any bugs, let us know with a Github issue. And if you're interested in working with us, check out our open roles!"
    }
]