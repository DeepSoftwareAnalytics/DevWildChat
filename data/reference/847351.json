[
    {
        "link": "https://docs.python.org/3/tutorial/controlflow.html",
        "document": ""
    },
    {
        "link": "https://wiki.python.org/moin/ForLoop",
        "document": "There are two ways to create loops in Python: with the for-loop and the while-loop.\n\nWhen do I use for loops\n\nfor loops are used when you have a block of code which you want to repeat a fixed number of times. The for-loop is always used in combination with an iterable object, like a list or a range. The Python for statement iterates over the members of a sequence in order, executing the block each time. Contrast the for statement with the ''while'' loop, used when a condition needs to be checked each iteration or to repeat a block of code forever. For example:\n\nFor loop from 0 to 2, therefore running 3 times.\n\nWhile loop from 1 to infinity, therefore running forever.\n\nWhen running the above example, you can stop the program by pressing ctrl+c at the same time. As you can see, these loop constructs serve different purposes. The for loop runs for a fixed amount of times, while the while loop runs until the loop condition changes. In this example, the condition is the boolean True which will never change, so it will run forever.\n\nHow do they work?\n\nIf you've done any programming before, you have undoubtedly come across a for loop or an equivalent to it. Many languages have conditions in the syntax of their for loop, such as a relational expression to determine if the loop is done, and an increment expression to determine the next loop value. In Python, this is controlled instead by generating the appropriate sequence. Basically, any object with an iterable method can be used in a for loop. Even strings, despite not having an iterable method - but we'll not get on to that here. Having an iterable method basically means that the data can be presented in list form, where there are multiple values in an orderly fashion. You can define your own iterables by creating an object with next() and iter() methods. This means that you'll rarely be dealing with raw numbers when it comes to for loops in Python - great for just about anyone!\n\nWhen you have a block of code you want to run x number of times, then a block of code within that code which you want to run y number of times, you use what is known as a \"nested loop\". In Python, these are heavily used whenever someone has a list of lists - an iterable object within an iterable object.\n\nLike the while loop, the for loop can be made to exit before the given object is finished. This is done using the break statement, which will immediately drop out of the loop and continue execution at the first statement after the block. You can also have an optional else clause, which will run should the for loop exit cleanly - that is, without breaking.\n\nYour own range generator using yield\n\nThe ''range'' function is seen so often in for statements that you might think range is part of the for syntax. It is not: it is a Python built-in function that returns a sequence following a specific pattern (most often sequential integers), which thus meets the requirement of providing a sequence for the for statement to iterate over. Since for can operate directly on sequences, there is often no need to count. This is a common beginner construct (if they are coming from another language with different loop syntax):\n\nIt can be replaced with this:\n\nConsider to be a flag for possibly non-optimal Python coding.\n\nIf you'd like to learn more, try these links:\n• None Python for loop and while loop tutorial with interactive code examples"
    },
    {
        "link": "https://tomasbeuzen.com/python-programming-for-data-science/chapters/chapter2-loops-functions.html",
        "document": "For loops allow us to execute code a specific number of times. The number is 2 and its square is 4 The number is 7 and its square is 49 The number is -1 and its square is 1 The number is 5 and its square is 25 I'm outside the loop!\n• None Keyword begins the loop. Colon ends the first line of the loop.\n• None Block of code indented is executed for each value in the list (hence the name “for” loops)\n• None The loop ends after the variable has taken all the values in the list\n• None We can iterate over any kind of “iterable”: , , , , .\n• None An iterable is really just any object with a sequence of values that can be looped over. In this case, we are iterating over the values in a list. A very common pattern is to use with the . gives you a sequence of integers up to some value (non-inclusive of the end-value) and is typically used for looping. We can also specify a start value and a skip-by value with : We can write a loop inside another loop to iterate over multiple dimensions of data: There are many clever ways of doing these kinds of things in Python. When looping over objects, I tend to use and quite a lot in my work. returns a zip object which is an iterable of tuples. We can even “unpack” these tuples directly in the loop: adds a counter to an iterable which we can use within the loop. index 0, value a index 1, value b index 2, value c We can loop through key-value pairs of a dictionary using . The general syntax is for key, value in dictionary.items() . DSCI 521, is awesome DSCI 551, is riveting DSCI 511, is naptime! We can even use to do more complex un-packing: Item 0: DSCI 521, is awesome Item 1: DSCI 551, is riveting Item 2: DSCI 511, is naptime!\n\nWe can also use a loop to excute a block of code several times. But beware! If the conditional expression is always , then you’ve got an infintite loop! Let’s read the statement above as if it were in English. It means, “While is greater than 0, display the value of and then decrement by 1. When you get to 0, display the word Blast off!” For some loops, it’s hard to tell when, or if, they will stop! Take a look at the Collatz conjecture. The conjecture states that no matter what positive integer we start with, the sequence will always eventually reach 1 - we just don’t know how many iterations it will take. Hence, in some cases, you may want to force a loop to stop based on some criteria, using the keyword. The keyword is similar to but won’t stop the loop. Instead, it just restarts the loop from the top. # this line is never executed because continue restarts the loop from the top\n\nAbove: the Blue Screen of Death at a Nine Inch Nails concert! Source: cnet.com. If something goes wrong, we don’t want our code to crash - we want it to fail gracefully. In Python, this can be accomplished using / . Here is a basic example: # code fails before getting to this line Traceback (most recent call last) # code fails before getting to this line : name 'this_variable_does_not_exist' is not defined \"You did something bad! But I won't raise an error.\" You did something bad! But I won't raise an error. Another line Python tries to execute the code in the block. If an error is encountered, we “catch” this in the block (also called / in other languages). There are many different error types, or exceptions - we saw above. Traceback (most recent call last) : division by zero Traceback (most recent call last) : list index out of range Traceback (most recent call last) : 'tuple' object does not support item assignment Ok, so there are apparently a bunch of different errors one could run into. With / you can also catch the exception itself: You did something bad! name 'this_variable_does_not_exist' is not defined <class 'NameError'> In the above, we caught the exception and assigned it to the variable so that we could print it out. This is useful because you can see what the error message would have been, without crashing your program. You can also catch specific exceptions types. This is typically the recommended way to catch errors, you want to be specific in catching your error so you know exactly where and why your code failed. \"You made some other sort of error\" The final would trigger if the error is none of the above types, so this sort of has an / / feel to it. There is also an optional and keyword (which I almost never used), but you can read more about here. \"The variable does not exist!\" The variable does not exist! I'm printing anyway! We can also write code that raises an exception on purpose, using : # we'll get to functions in the next section Traceback (most recent call last) in # we'll get to functions in the next section : can only concatenate str (not \"int\") to str \"Sorry, x must be numeric, you entered a Traceback (most recent call last) in \"Sorry, x must be numeric, you entered a : Sorry, x must be numeric, you entered a <class 'str'>. This is useful when your function is complicated and would fail in a complicated way, with a weird error message. You can make the cause of the error much clearer to the user of the function. If you do this, you should ideally describe these exceptions in the function documentation, so a user knows what to expect if they call your function. Finally, we can even define our own exception types. We do this by inheriting from the class - we’ll explore classes and inheritance more in the next chapter! \"Sorry, x must be numeric\" Traceback (most recent call last) in \"Sorry, x must be numeric\" : Sorry, x must be numeric\n\nA function is a reusable piece of code that can accept input parameters, also known as “arguments”. For example, let’s define a function called which takes one input parameter and returns the square : Functions begin with the keyword, then the function name, arguments in parentheses, and then a colon ( ). The code executed by the function is defined by indentation. The output or “return” value of the function is specified using the keyword. When you create a variable inside a function, it is local, which means that it only exists inside the function. For example: 'My name is Tom' Traceback (most recent call last) : name 'string' is not defined If a function changes the variables passed into it, then it is said to have side effects. For example: The above looks like what we wanted? But wait… it changed our object… If your function has side effects like this, you must mention it in the documentation (which we’ll touch on later in this chapter). If you do not specify a return value, the function returns when it terminates: Sometimes it is convenient to have default values for some arguments in a function. Because they have default values, these arguments are optional, and are hence called “optional arguments”. For example: # do not specify `n`; it is optional Ideally, the default value for optional arguments should be carefully chosen. In the function above, the idea of “repeating” something makes me think of having 2 copies, so feels like a reasonable default. You can have any number of required arguments and any number of optional arguments. All the optional arguments must come after the required arguments. The required arguments are mapped by the order they appear. The optional arguments can be specified out of order when using the function. Using the defaults for and : Specifying and as keyword arguments (i.e. by name): Specifying only one of the optional arguments, by keyword: Specifying all the arguments as keyword arguments, even though only and are optional: Specifying by the fact that it comes 3rd (I do not recommend this because I find it is confusing): Specifying the optional arguments by keyword, but in the wrong order (this can also be confusing, but not so terrible - I am fine with it): Specifying the non-optional arguments by keyword (I am fine with this): Specifying the non-optional arguments by keyword, but in the wrong order (not recommended, I find it confusing): Specifying keyword arguments before non-keyword arguments (this throws an error): In many programming languages, functions can only return one object. That is technically true in Python too, but there is a “workaround”, which is to return a tuple. The parentheses can be omitted (and often are), and a is implicitly returned as defined by the use of the comma: It is common to immediately unpack a returned tuple into separate variables, so it really feels like the function is returning multiple values: As an aside, it is conventional in Python to use for values you don’t want: You can also call/define functions that accept an arbitrary number of positional or keyword arguments using and .\n\nDRY stands for Don’t Repeat Yourself. See the relevant Wikipedia article for more about this principle. As an example, consider the task of turning each element of a list into a palindrome. # creates a slice that starts at the end and moves backwards, syntax is [begin:end:step] The code above is gross, terrible, yucky code for several reasons:\n• None It only works for a list with 3 elements;\n• None It only works for a list named ;\n• None If we want to change its functionality, we need to change 3 similar lines of code (Don’t Repeat Yourself!!);\n• None It is hard to understand what it does just by looking at it. Let’s try this a different way: The above is slightly better and we have solved problems (1) and (3). But let’s create a function to make our life easier: Okay, this is even better. We have now also solved problem (2), because you can call the function with any list, not just . For example, what if we had multiple lists: How far you go and how you choose to apply the DRY principle is up to you and the programming context. These decisions are often ambiguous. Should be a function if I’m only ever doing it once? Twice? Should the loop be inside the function, or outside? Should there be TWO functions, one that loops over the other? In my personal opinion, does a bit too much to be understandable. I prefer this: From here, if we want to “apply to every element of a list” we could use list comprehension: There is also the in-built function which does exactly this, applies a function to every element of a sequence:\n\nRecall list comprehension from earlier in the chapter: Comprehensions evaluate the entire expression at once, and then returns the full data product. Sometimes, we want to work with just one part of our data at a time, for example, when we can’t fit all of our data in memory. For this, we can use generators. Notice that we just created a . Generator objects are like a “recipe” for generating values. They don’t actually do any computation until they are asked to. We can get values from a generator in three main ways: Once the generator is exhausted, it will no longer return values: Traceback (most recent call last) in : We can see all the values of a generator using but this defeats the purpose of using a generator in the first place: Finally, we can loop over generator objects too: Above, we saw how to create a generator object using comprehension syntax but with parentheses. We can also create a generator using functions and the keyword (instead of the keyword): Below is some real-world motivation of a case where a generator might be useful. Say we want to create a list of dictionaries containing information about houses in Canada. # we'll learn about imports in a later chapter What happens if we want to create a list of 1,000,000 houses? How much time/memory will it take? Memory usage before: 48 mb Memory usage after: 52 mb Time taken: 0.16s Although, if we used to extract all of the genertator values, we’d lose our memory savings:\n\nOne problem we never really solved when talking about writing good functions was: “4. It is hard to understand what it does just by looking at it”. This brings up the idea of function documentation, called “docstrings”. The docstring goes right after the line and is wrapped in triple quotes . \"\"\"Turns the string into a palindrome by concatenating itself with a reversed version of itself.\"\"\" In Python we can use the function to view another function’s documentation. In IPython/Jupyter, we can use to view the documentation string of any function in our environment. But, even easier than that, if your cursor is in the function parentheses, you can use the shortcut to open the docstring at will. # make_palindrome('uncomment this line and try pressing shift+tab here.') General docstring convention in Python is described in PEP 257 - Docstring Conventions. There are many different docstring style conventions used in Python. The exact style you use can be important for helping you to render your documentation, or for helping your IDE parse your documentation. Common styles include:\n• None Single-line: If it’s short, then just a single line describing the function will do (as above).\n• None NumPy style: see here. (RECOMMENDED! and MDS-preferred) \"\"\"First line is a short description of the function. A paragraph describing in a bit more detail what the function does and what algorithms it uses and common A longer description because maybe this requires more explanation and we can use several lines. A description of the output, datatypes and behaviours. Describe special cases and anything the user needs to know to use the function. \"\"\"Turns the string into a palindrome by concatenating itself with a reversed version of itself. The string to turn into a palindrome. When specifying function arguments, we specify the defaults for optional arguments: the number of times, by default = 2 Type hinting is exactly what it sounds like, it hints at the data type of function arguments. You can indicate the type of an argument in a function using the syntax , and the type of the return value using . Let’s see an example: Type hinting just helps your users and IDE identify dtypes and identify bugs. It’s just another level of documentation. They do not force users to use that date type, for example, I can still pass an to if I want to: Traceback (most recent call last) in : unsupported operand type(s) for *: 'dict' and 'int' Most IDE’s are clever enough to even read your type hinting and warn you if you’re using a different dtype in the function, e.g., this VScode screenshot:"
    },
    {
        "link": "https://w3schools.com/python/python_for_loops.asp",
        "document": "A for loop is used for iterating over a sequence (that is either a list, a tuple, a dictionary, a set, or a string).\n\nThis is less like the for keyword in other programming languages, and works more like an iterator method as found in other object-orientated programming languages.\n\nWith the for loop we can execute a set of statements, once for each item in a list, tuple, set etc.\n\nThe for loop does not require an indexing variable to set beforehand.\n\nEven strings are iterable objects, they contain a sequence of characters:\n\nWith the break statement we can stop the loop before it has looped through all the items:\n\nWith the continue statement we can stop the current iteration of the loop, and continue with the next:\n\nTo loop through a set of code a specified number of times, we can use thefunction,\n\nThe range() function returns a sequence of numbers, starting from 0 by default, and increments by 1 (by default), and ends at a specified number.\n\nThe range() function defaults to 0 as a starting value, however it is possible to specify the starting value by adding a parameter: range(2, 6), which means values from 2 to 6 (but not including 6):\n\nThe range() function defaults to increment the sequence by 1, however it is possible to specify the increment value by adding a third parameter: range(2, 30, 3):\n\nElse in For Loop\n\nThe keyword in a loop specifies a block of code to be executed when the loop is finished:\n\nThe \"inner loop\" will be executed one time for each iteration of the \"outer loop\":\n\nloops cannot be empty, but if you for some reason have a loop with no content, put in the statement to avoid getting an error."
    },
    {
        "link": "https://python101.pythonlibrary.org/chapter5_loops.html",
        "document": "Every programming language I have tried has some kind of looping construct. Most have more than one. The Python world has two types of loops:\n\nYou will find that the for loop is by far the most popular of the two. Loops are used when you want to do something many times. Usually you will find that you need to do some operation or a set of operations on a piece of data over and over. This is where loops come in. They make it really easy to apply this sort of logic to your data.\n\nLet’s get started learning how these fun structures work!\n\nAs mentioned above, you use a loop when you want to iterate over something n number of times. It’s a little easier to understand if we see an example. Let’s use Python’s builtin range function. The range function will create a list that is n in length. In Python 2.x, there is actually another function called xrange that is a number generator and isn’t as resource intensive as range. They basically changed xrange into range in Python 3. Here is an example: As you can see, the range function above took an integer and returned a range object. The range function also accepts a beginning value, an end value and a step value. Here are two more examples: The first example demonstrates that you can pass a beginning and end value and the range function will return the numbers from the beginning value up to but not including the end value. So in the case of 5-10, we get 5-9. The second example shows how to use the list function to cause the range function to return every second element between 1 and 10. So it starts with one, skips two, etc. Now you’re probably wondering what this has to do with loops. Well one easy way to show how a loop works is if we use the range function! Take a look: What happened here? Let’s read it from left to right to figure it out. For each number in a range of 5, print the number. We know that if we call range with a value of 5, it will return a list of 5 elements. So each time through the loop, it prints out each of the elements. The for loop above would be the equivalent of the following: The range function just makes it a little bit smaller. The for loop can loop over any kind of Python iterator. We’ve already seen how it can iterate over a list. Let’s see if it can also iterate over a dictionary. When you use a for loop with a dictionary, you’ll see that it automatically loops over the keys. We didn’t have to say for key in a_dict.keys() (although that would have worked too). Python just did the right thing for us. You may be wondering why the keys printed in a different order than they were defined in the dictionary. As you may recall from chapter 3, dictionaries are unordered, so when we iterate over it, the keys could be in any order. Now if you know that the keys can be sorted, then you can do that before you iterate over them. Let’s change the dictionary slightly to see how that works. Let’s take a moment to figure out what this code does. First off, we create a dictionary that has integers for keys instead of strings. Then we extract the keys from the dictionary. Whenever you call the keys() method, it will return an unordered list of the keys. If you print them out and find them to be in ascending order, then that’s just happenstance. Now we have a view of the dictionary’s keys that are stored in a variable called keys. We sort it and then we use the for loop to loop over it. Now we’re ready to make things a little bit more interesting. We are going to loop over a range, but we want to print out only the even numbers. To do this, we want to use a conditional statement instead of using the range’s step parameter. Here’s one way you could do this: You’re probably wondering what’s going on here. What’s up with the percent sign? In Python, the % is called a modulus operator. When you use the modulus operator, it will return the remainder. There is no remainder when you divide an even number by two, so we print those numbers out. You probably won’t use the modulus operator a lot in the wild, but I have found it useful from time to time. Now we’re ready to learn about the while loop.\n\nThe while loop is also used to repeat sections of code, but instead of looping n number of times, it will only loop until a specific condition is met. Let’s look at a very simple example: The while loop is kind of like a conditional statement. Here’s what this code means: while the variable i is less than ten, print it out. Then at the end, we increase i’s value by one. If you run this code, it should print out 0-9, each on its own line and then stop. If you remove the piece where we increment i’s value, then you’ll end up with an infinite loop. This is usually a bad thing. Infinite loops are to be avoided and are known as logic errors. There is another way to break out of a loop. It is by using the break builtin. Let’s see how that works: In this piece of code, we add a conditional to check if the variable i ever equals 5. If it does, then we break out of the loop. As you can see from the sample output, as soon as it reaches 5, the code stops even though we told the while loop to keep looping until it reached 10. You will also note that we changed how we increment the value by using +=. This is a handy shortcut that you can also use with other math operations, like subtraction (-=) and multiplication (*=). The break builtin is known as a flow control tool. There is another one called continue that is used to basically skip an iteration or continue with the next iteration. Here’s one way to use it: This is a little confusing, no? Basically we added a second conditional that checks if i equals 3. If it does, we increment the variable and continue with the next loop, which effectively skips printing the value 3 to the screen. As before, when we reach a value of 5, we break out of the loop. There’s one more topic we need to cover regarding loops and that’s the else statement.\n\nWhat else is for in loops¶ The else statement in loops only executes if the loop completes successfully. The primary use of the else statement is for searching for items: In this code, we break out of the loop when i equals 3. This causes the else statement to be skipped. If you want to experiment, you can change the conditional to look for a value that’s not in the list, which will cause the else statement to execute. To be honest, I have never seen anyone use this structure in all my years as a programmer. Most of the examples I have seen are bloggers trying to explain what it is used for. I have seen several who use it to raise an error if an item is not found in the iterable that you were searching. You can read a fairly in depth article by one of the Python core developers here.\n\nHopefully at this point you can see the value in Python loops. They make repetition easier and pretty easy to understand. You will likely see the for loop much more often than the while loop. In fact, we are going to look at another way for loops are used in the next chapter when we learn about comprehensions! If you’re still not quite sure how all this works, you may want to re-read this chapter before continuing."
    },
    {
        "link": "https://stackoverflow.com/questions/48107286/optimizing-a-primality-test-based-on-runtime-in-python",
        "document": "You would probably get a minor boost from computing only once per iteration instead of times. As you can see, this will greatly reduce the constant factor in your complexity. It won't change the fundamental complexity because you still need to compute the remainder. Change\n\nThe is implicit in Python.\n\nAll this is just trivial improvement to an extremely inefficieny algorithm. The biggest speedup I can think of is to reduce the check to only prime . For any composite such that , it must be the case that (if is divisible by , it must also be divisible by the factors of ).\n\nI am assuming that you don't want to use any kind of pre-computed prime tables in your code. In that case, you can compute the table yourself. This will involve checking all the numbers up to a given only once ever, instead of once per iteration of , since we can stash the previously computed primes in say a . That will effectively increase the lower limit of the range in your current from 2 to the square root of the previous .\n\nLet's define a function to extend our set of primes using the seive of Eratosthenes:\n\nNow we can use this function to extend our list of primes at every iteration of the original loop. This allows us to check the divisibility of only against the slowly growing list of primes, not against all numbers:\n\nI am not 100% sure that my extend function is optimal, but I am able to get to , in <10 minutes on my ridiculously old and slow laptop, so I guess it's not too bad. That means that the algorithm builds a complete table of primes up to ~7e7 in that time.\n\nA sort-of-but-not-really optimization you could do would be to check before calling . This would save you a lot of cycles for numbers that have small prime factors, but would probably catch up to you later on, when you would end up having to compute all the primes up to some enormous number. Here is a sample of how you could do that:\n\nWhile this version does not do much for the long run, it does explain why you were able to get to 15 so quickly in your original run. The prime table does note get extended after , until , which is when the terrible delay occurs in this version as well. The net runtime to 16 should be identical in both versions.\n\nAs @paxdiablo suggests, the only numbers we need to consider in are multiples of 6 +/- 1. We can combine that with the fact that only a small number of primes generally need to be tested, and convert the functionality of into a generator that will only compute as many primes as absolutely necessary. Using Python's lazy generation should help. Here is a completely rewritten version:\n\nThis version gets to 15 almost instantly. It gets stuck at 16 because the smallest prime factor for is . Some future expectations:\n• should be a breeze: has factor\n• will take a while: has factor\n• is easy: is divisible by\n• also easy: is divisible by\n\nSo in terms of instant gratification, this method will get you much further if you can make it past 18 (which will take >100 times longer than getting past 16, which in my case took ~1.25hrs).\n\nThat being said, your greatest speedup at this point would be re-writing this in C or some similar low-level language that does not have as much overhead for loops.\n\nJust for giggles, here is an implementation of the latest Python version in C. I chose to go with GMP for arbitrary precision integers, because it is easy to use and install on my Red Hat system, and the docs are very clear:\n\nWhile this version has the exact same algorithmic complexity as the Python one, I expect it to run a few orders of magnitude faster because of the relatively minimal overhead incurred in C. And indeed, it took about 15 minutes to get stuck at , which is ~5 times faster than the Python version so far.\n\nThis is going to be the last one, I promise.\n\nGMP has a function called , which offers a potentially much faster implementation of this algorightm, especially with caching. According to the docs:\n\nThis means that it is probably much faster than the current prime generator I implemented, with a slight cost offset of some false primes being added to the cache. This cost should be minimal: even adding a few thousand extra modulo operations should be fine if the prime generator is faster than it is now.\n\nThe only part that needs to be replaced/modified is the portion of below the comment . Basically that whole section just becomes a series of calls to instead of recursion.\n\nAt that point, you may as well adapt to use when possible. You only need to check for sure if the result of is uncertain:\n\nSure enough, this version makes it to in a couple of seconds at most. It appears to get stuck on , probably because can't determine if is a prime for sure. I doubt that computing all the primes up to ~10^80 is going to take a trivial amount of time."
    },
    {
        "link": "https://geeksforgeeks.org/introduction-to-primality-test-and-school-method",
        "document": "Given a positive integer, check if the number is prime or not. A prime is a natural number greater than 1 that has no positive divisors other than 1 and itself. Examples of the first few prime numbers are {2, 3, 5, …}\n\nExamples :\n\nA simple solution is to iterate through all numbers from 2 to n-1 and for every number check if it divides n. If we find any number that divides, we return false.\n\n// A school method based C++ program to check if a // to check if a number is prime // program to check if a number is prime\n\nWe can do the following optimizations: Instead of checking till n, we can check till √n because a larger factor of n must be a multiple of a smaller factor that has been already checked. The implementation of this method is as follows:\n\n// Optimised school method based C++ program to check if a // Check from 2 to square root of n // This code is contributed by Vikash Sangai // to check if a number is prime // Check from 2 to square root of n // This code is contributed by Vikash Sangai # to check if a number is prime # function to check whether the number is prime or not # Check from 2 to square root of n # This code is contributed by bhoomikavemula // program to check if a number is prime // This code is contributed by Vikash Sangai // JavaScript code for the above approach // Check from 2 to square root of n // This code is contributed by sanjoy_62.\n\nIt is based on the fact that all primes greater than 3 are of the form 6k ± 1, where k is any integer greater than 0. This is because all integers can be expressed as (6k + i), where i = −1, 0, 1, 2, 3, or 4. And note that 2 divides (6k + 0), (6k + 2), and (6k + 4) and 3 divides (6k + 3). So, a more efficient method is to test whether n is divisible by 2 or 3, then to check through all numbers of the form 6k ± 1 <= √n. This is 3 times faster than testing all numbers up to √n.\n\n// C++ program to check the given number // Function to check if the given number // To check through all numbers of the form 6k ± 1 // JAVA program to check the given number // since 2 and 3 are prime // if n<=1 or divided by 2 or 3 then it can not be prime // To check through all numbers of the form 6k ± 1 // This code is contributed by Ujjwal Kumar Bhardwaj # Python program to check the given number # Function to check if the given number # To check through all numbers of the form 6k ± 1 # until i <= square root of n, with step value 6 # # This code is contributed by Harsh Master // C# program to check the given number // since 2 and 3 are prime // if n<=1 or divided by 2 or 3 then it can not be prime // To check through all numbers of the form 6k ± 1 // This code is contributed by Aman Kumar // JavaScript program to check the given number // Function to check if the given number // To check through all numbers of the form 6k ± 1"
    },
    {
        "link": "https://stackoverflow.com/questions/61536322/fast-primality-testing-for-large-n-in-python",
        "document": "I'm working on a project that requires me to find whether extremely large numbers are prime numbers or not. Of course, I've read how to find prime numbers and have come up with a very simple brute force method:\n\nI've also investigated such probabilistic methods as the Miller-Rabin Primality Test and Fermat's little theorem (see here for Rosetta code's implementation of the former).\n\nThough the probabilistic options are an order of magnitude faster than brute force, they're still very slow for very large inputs of (for example, the known prime ).\n\nI came across an interesting observation (of course I'm not the first to come across such an observation) that all primes fit the equation or . In Python, such a function looks like this\n\nThe above is guaranteed to return true if is a prime, but a true result does not mean the is a prime. An easy example is 25 (25 = 1 (mod 6), but clearly 25 = 5^2).\n\nI'm wondering if there's some more general way to apply this interesting property of primes, perhaps with different values of to improve the speed of my function."
    },
    {
        "link": "https://reddit.com/r/Python/comments/1gd18w8/aks_primality_test",
        "document": "I just finished writing an implementation of the AKS primality test.\n\nWhat my project does\n\nThe project implements the AKS primality test, the first deterministic prime test that can be run in polynomial time. (although this implementation may not run in polynomial time because of implementation inefficiencies)\n\nAbsolutely no one. The point of AKS is its the first polynomial time primality test that can deterministically determine if any given number is prime or composite, however in practice, its much slower than everything else.\n\nMuch worse than other primality tests, to the point of being completely unusable (takes about 1.6s to check if 1009 is a prime)"
    },
    {
        "link": "https://labex.io/tutorials/python-how-to-check-primality-in-python-418855",
        "document": "A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. In other words, a prime number can only be divided evenly by 1 and itself.\n\ngraph LR A[Start] --> B{Is number > 1?} B -->|Yes| C{Check divisibility} B -->|No| D[Not Prime] C -->|Divisible by other numbers| D C -->|Only divisible by 1 and itself| E[Prime Number]\n\nAt LabEx, we understand the significance of prime numbers in solving complex computational challenges."
    }
]