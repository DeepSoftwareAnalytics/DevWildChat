[
    {
        "link": "https://stackoverflow.com/questions/1437250/connecting-to-ldap-from-c-sharp-using-directoryservices",
        "document": "Well, I think your connection string is missing a bit - specifying just the server name isn't good enough - you also need to specify a \"starting point\" for your search.\n\nIn AD, this would typically be something like the \"Users\" container in your domain, which you'd specify like this in LDAP parlance:\n\nNot sure how LDAP compliant the newer versions of eDirectory are - but that should work since in theory, it's standard LDAP regardless of the implementation :-)\n\nBut then again: only in theory, there's no difference between theory and practice.....\n\nThere's also a namespace which offers low-level LDAP calls directly - and that's definitely not tied to AD at all, but it's really quite low-level.....\n\nThere's also a Novell C# LDAP library but I've never tried it and can't say how complete or capable it is. It might give you some clues, though!\n\nAlso see this other Stackoverflow question about Novell, LDAP and C# - it might give you additional info."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.directoryservices.protocols.ldapconnection?view=net-9.0-pp",
        "document": "Some information relates to prerelease product that may be substantially modified before it’s released. Microsoft makes no warranties, express or implied, with respect to the information provided here.\n\nIf the ClientCertificates property on the LdapConnection object and QueryClientCertificate property on the LdapSessionOptions object are both set, the certificate specified in the ClientCertificates property is ignored."
    },
    {
        "link": "https://stackoverflow.com/questions/34813550/how-to-connect-to-active-directory-via-ldaps-in-c",
        "document": "Found a documentation (here) in an answer thread on this site but i can´t get an connection to an AD. When i use a program like Active Directory Explorer i can connect. I think, because i am trying to connect to a LDAPS i need a different approach?\n\nI have the server IP, a domain, username/pwd and the port 636. I tried various combinations @ but couldn´t get it to connect. Always get a .\n\nBackground Infos: User places his card to a Card Reader Unit. Porgram gets ID from card and searches the DB for this ID and returns the eMail address belonging to the ID/User . And here the working solution:"
    },
    {
        "link": "https://auth0.com/blog/using-ldap-with-c-sharp",
        "document": "In this post series, we will study the Lightweight Directory Access Protocol (LDAP): a protocol developed in the 90s to be an open, simpler alternative to other directory protocols. We will also talk about Active Directory (Microsoft's LDAP implementation with extra features) and how to use it as an authentication mechanism. For the purposes of this post, we will focus on the generic LdapConnection API. In the next post, we will take a look at the Active Directory specific PrincipalContext API. Get the full code and read on!\n\nLDAP is a protocol that defines a series of operations through which you can access information that is part of a directory. A directory is a tree containing a set of attributes associated with a unique identifier (or primary key). If you are familiar with document-based databases, this may sound familiar. The primary key is usually a name. This means that LDAP is perfectly suited to be a user information database. Even though most of the time it is used as a user directory, LDAP can also work as a generic information sharing service.\n\nOne common use of LDAP is as part of single-sign-on (SSO) systems. If you are not familiar with SSO, read our introduction to SSO.\n\nThe following diagram shows how a simple SSO system can work using LDAP. The diagram shows a simplified Microsoft Active Directory configuration using LDAP. Active Directory stores user information in an LDAP server. When users attempt to login to their Windows PC, Windows validates the login information against the LDAP/Active Directory server. Whenever a user tries to do something that requires authentication, an application can use information from the Active Directory server to validate the user's identity. Of course, if SSO is not required, Active Directory can also be used as a simple authentication mechanism.\n\nThe best way to understand a protocol is to get your hands a bit dirty and learn its inner workings. Fortunately, barring binary encoding details and other low-level stuff, LDAP is a fairly simple protocol. LDAP defines a series of operations that are available to clients. Clients can connect to two types of servers:\n• Global Catalog: a special type of server that stores reduced sets of replicated information from DSAs to speed up searches.\n\nClients send requests to the server. In turn, the server answers those requests. Most requests are asynchronous; others are necessarily synchronous (such as the connection handshake). Additionally, the server may send special messages to clients even when there are no pending requests that require a response (for example, the server may send a message to notify clients that it is shutting down). All information is encoded using ASN.1 (see below for more details). TLS and/or SASL may be used to ensure privacy and perform authentication.\n\nThe following operations have .NET samples. A full working example can be found in the example section below.\n• Test to determine whether a given attribute is present and has the specified value.\n• Move an entry to a different path.\n\nFurthermore, additional protocol management operations are defined (connect, disconnect, negotiate protocol version, etc.).\n\nAll operations are performed using messages encoded in Abstract Syntax Notation One (ASN.1) format using Basic Encoding Rules (BER). ASN.1 is defined in ITU standard X.680, while BER and other encodings are part of ITU standard X.690.\n\nASN.1 defines a series of datatypes (such as integer, string, etc.), a textual format description (schema), and a textual representation of values. BER, on the other hand, defines a binary encoding for ASN.1. BER is a traditional tag-length-value encoding. If you are interested in the gritty details, you can read a nice summary of BER encoding at Wikipedia.\n\nHere is a schema taken directly from LDAP's RFC that shows the message format for LDAP:\n\nIn the example above, we can see that an LDAP message carries a message id (an integer going from 0 to\n\n), an operation object (each object is defined elsewhere), and an extra field called(which is defined somewhere else in the schema under). LDAP is defined using the same notation as the data format it uses internally. Behold the power of ASN.1!\n\nIn this example we first see a schema for a\n\n. Ahas two required fields (and) and an optional field (). Thefield has a default value of \"Hello World\" in case it is missing in a model. Thefield in turn can be one of two options:(any integer from one to 1000) or(any integer from one to 100). What follows after the schema is amodel conforming to the above schema (a human named \"Adam,\" using the default value for, with a biblical age of 930).\n\nEven though LDAP uses ASN.1 internally, and ASN.1 can be represented as text, there is a different textual representation for LDAP information called LDAP Data Interchange Format (LDIF). Here's a sample:\n\nThe two-letter attributes in the example above are:\n\nLDIF can also be used as a means to perform operations:\n\nThe examples above make it clear that the distinguished name (DN) uniquely identifies an entry.\n\nWhen it comes to LDAP, LDIF is much more common than the alternatives. In fact, tools such as OpenLDAP use LDIF as input/output.\n\nExample: using LDAP from a C# client\n\n.NET provides a convenient set of classes to access LDAP and Active Directory servers. Here are the relevant .NET docs. The following example has been tested against OpenLDAP 2.4. Get the full code.\n\nThe user model for our example includes fields for:\n\nNote this is not the model for an Active Directory user. Active Directory users can be validated using the bind operation (see below).\n\nIn practice, credentials stored in an LDAP directory are validated using the bind operation. The bind operation means \"log-in to an LDAP server using a specific set of credentials.\" If the bind operation succeeds, the credentials are valid. The mapping of a user to an actual entry in the LDAP directory is set up in the server configuration (Active Directory has specific rules for this; other LDAP servers leave this detail to the administrator).\n\nIf you have full access to the credentials stored in the directory, you can compare the hashed passwords of your users to validate credentials. Note that this is NOT how Active Directory stores credentials. Users in an Active Directory server must be validated using the \"bind\" operation (using either this API or PrincipalContext, which we will discuss in the next post). See the previous example for information on how to perform a bind operation using this API.\n\nConnection parameters used for this example are:\n\nCheck your server's configuration to pick the right connection parameters. If you are using LDAP + SASL, do not forget to set the right SASL params in the OpenLDAP config file. For instance, the following line tells OpenLDAP to use the SASL database directly.\n\nSee the full code for examples on searching, modifying and deleting entries.\n\nAside: setting up Auth0 for LDAP use\n\nAt Auth0 we care about all our clients. If you have an existing LDAP deployment, you can integrate it with Auth0. LDAP deployments are usually installed inside a corporate network. In other words, they are private. Since they are private, there is no access to the LDAP server from the outside. Since our authentication solution works from the cloud, it is necessary to provide a means for the internal network to communicate with our servers. This is what we provide in the form of the Active Directory/LDAP connector. This is a service that is installed in your network to provide a bridge between your LDAP server and our own servers in the cloud. Worry not! The connector uses an outbound connection to our servers so you don't need to set up special rules in your firewall.\n\nTo enable LDAP for your Auth0 apps, first go to\n\n->->. Follow the steps to setup the LDAP connector (you will need the LDAP server details) and then enable LDAP for your app.\n\nThe following examples use the LDAP server setup for our C# example above.\n\nOnce you have enabled LDAP in the dashboard and set up the connector, you can follow the usual steps for our Resource Owner Password flow. Logging in using an email and password just works!\n\nYou can log in using our RESTful API for database, passwordless and LDAP users.\n\nLDAP was designed as a lightweight protocol that can access directory contents. As it evolved over the years, it gained important features, such as authentication and transport security. As a well defined means to get user information, it has found its way to small and big deployments. Its simplicity and openness have kept LDAP relevant through the years. Nowadays, single sign on systems can also work using LDAP. Fortunately, integrating LDAP to existing or new projects is easy. In our next post, we will focus on Active Directory specifics using the PrincipalContext API. Stay tuned!\n\nWant to learn more about Single Sign-On? Get The Definitive Guide on SSO (74-page free eBook) here."
    },
    {
        "link": "https://nuget.org/packages/System.DirectoryServices.Protocols",
        "document": "System.DirectoryServices.Protocols provides a managed implementation of Lightweight Directory Access Protocol (LDAP) version 3 and Directory Services Markup Language (DSML) version 2.0 (V2) standards.\n\nIt primarily uses the type for interacting with LDAP servers, using system native libraries to establish TCP/IP or UDP LDAP connections. Supports both Windows and Unix, but certain features, such as setting client or server certificate options, are not available on Unix.\n\nHow to Use\n\nUsing the type, you can establish connections to LDAP servers and issue requests.\n\nHere is a simple example:\n\nThe main types provided by this library are:\n\nSystem.DirectoryServices.Protocols is released as open source under the MIT license. Bug reports and contributions are welcome at the GitHub repository."
    },
    {
        "link": "https://stackoverflow.com/questions/58095523/use-ssl-to-connect-to-ldap-with-net-directoryservices",
        "document": "I have some .NET working code (both as a desktop application and as a IIS deployment) to read data from LDAP:\n\nBut when I try to connect to the LDAPS port (636), it fails with a\n• None I have added the server CA to my acount through MMC.\n• None After that, I can connect to the LDAPS port using LdapAdmin.\n• None I have tried the following changes:\n• None Just adding the port to the server URL1:\n• None Adding the port and changing the authTypes to 2:\n• None Adding the port and changing the authType to 2:\n\nAnd I always get the same results.\n\nI have found some examples using directly the LDAP connections (from ) but I would prefer not to change the code as I already got it working.\n\nI often see some people claiming that I should changefor, but it seems that it is not how DirectoryServices works. And in any case that fails, too.\n\n2 I am pretty sure those two options are for authentication and not for setting up the SSL connection, but I have tried them anyway."
    },
    {
        "link": "https://stackoverflow.com/questions/77109472/c-sharp-how-to-connect-to-ldap-ad-dc-server-using-ssl-or-tls-from-linux-ubuntu",
        "document": "I am running a C# .NET 6 App in a Linux Ubuntu 22.04 container. I need the app to connect to an Active Directory Domain Controller in order to authenticate users of the app. I can get non-secure LDAP connections to the DC to work, but I get exceptions for any attempts at SSL or TLS LDAP connections. The exception messages are fairly vague so I am stuck on how to investigate further. I need to use secure connections to LDAP so that the app does not send users' credentials in the clear.\n\nMy Linux container is not connected to the Active Directory Domain.\n\nI am using nuget packages System.DirectoryServices Version 7.0.1 and System.DirectoryServices.Protocols Version 7.0.1. According to Pull Request #52904, support for TLS has been added but I'm not clear on what the prerequisites are or on which scenarios are supported.\n\nShould I be using a different AuthType or am I missing a prerequiste package? Any help would be much appreciated.\n\nI have been testing using the code below. (Where is a sAMAccountName and is a Distinguished Name). My thinking had been that I was using the wrong connection options so this code cycles through various options.\n\nAll the test scenarios work when I run the test code from a Windows workstation. When I try it on Ubuntu 22.04 the insecure connections work but I get the following Exceptions for secure connections (summary of output from the code above). I was expecting at least one of the secure connection options to work.\n\nI have installed the AD root certificate using . My ldap.conf file points to the crt file where all my CAs are installed.\n\nOther details of my environment:\n\nI have installed the following packages in my container:\n\nI am using the symlink work-around described in #69456 for the hard-coded reference to libldap-2.4.so.2 which is not available in Ubuntu 22.04.\n\nI have successfully run to make an ldaps:// connection to the domain controller from my Linux container."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/framework/network-programming/tls",
        "document": ".NET Framework supports the use of the Transport Layer Security (TLS) protocol to secure network communications.\n\nThe Transport Layer Security (TLS) protocol is an industry latest version of the standard designed to help protect the privacy of information communicated over the Internet. TLS 1.3 is a standard that provides security improvements over previous versions. This article presents recommendations to secure .NET Framework applications that use the TLS protocol.\n\nWho can benefit from this document?\n• Directly using the System.Net APIs (for example, System.Net.Http.HttpClient and System.Net.Security.SslStream).\n• Directly using WCF clients and services using the System.ServiceModel namespace.\n\nSince the .NET Framework is dependent on on Windows, which versions can be negotiated and which version will be used depends on the operating system.\n\nHere is an updated example table showing the highest supported TLS version for different combinations of operating system versions and .NET Framework target versions:\n\nFor more information see TLS protocol version support in Schannel.\n• For TLS 1.3, target .NET Framework 4.8 or later. Check Audit your code section how to verify your .\n• Do not specify the TLS version explicitly, i.e. don't use the method overloads of that take an explicit parameter.\n• That way your code will let the OS decide on the TLS version.\n• If you must set ServicePointManager.SecurityProtocol, then set it to SecurityProtocolType.SystemDefault. That will also use OS default.\n• If you must use the method overloads of that take an explicit parameter, then pass as argument. That will also use OS default.\n• Perform a thorough code audit to verify you're not specifying a TLS or SSL version explicitly.\n\nWhen your app lets the OS choose the TLS version:\n• It automatically takes advantage of new TLS protocols added in the future.\n• The OS blocks protocols that are discovered not to be secure (e.g. SSL3 and TLS 1.0).\n\nThis article explains how to enable the strongest security available for the version of .NET Framework that your app targets and runs on. When an app explicitly sets a security protocol and version, it opts out of any other alternative, and opts out of .NET Framework and OS default behavior. If you want your app to be able to negotiate a TLS 1.3 connection, explicitly setting to a lower TLS version prevents a TLS 1.3 connection.\n\nIf you can't avoid specifying a protocol version explicitly, we strongly recommend that you specify TLS 1.2 or TLS 1.3 (which is ). For guidance on identifying and removing TLS 1.0 dependencies, download the Solving the TLS 1.0 Problem white paper.\n\nWCF supports TLS 1.2 as the default in .NET Framework 4.7. Starting with .NET Framework 4.7.1, WCF defaults to the operating system configured version. If an application is explicitly configured with , WCF uses the operating system default setting when using the NetTcp transport.\n\nYou can ask questions about this document in the GitHub issue Transport Layer Security (TLS) best practices with the .NET Framework.\n\nAudit your code and make code changes\n\nFor ASP.NET applications, inspect the element of web.config to verify you're using the targeting intended version of the .NET Framework.\n\nFor Windows Forms and other applications, see How to: Target a Version of the .NET Framework.\n\nUse the following sections to verify you're not using a specific TLS or SSL version.\n\nIf you must explicitly set a Security Protocol\n\nIf you must explicitly set a security protocol instead of letting .NET or the OS pick the security protocol, pick these protocols:\n• For .NET Framework 4.6.2 or later: TLS 1.3\n\nIf you can't find specified protocols in enum, you can add those as an extension file. See below:\n\nFor more information, see Support for TLS System Default Versions included in .NET Framework 3.5 on Windows 8.1 and Windows Server 2012 R2.\n\nIf your app targets .NET Framework 4.7 or later versions\n\nThe following sections show how to configure your application to use of TLS. (TLS 1.2, TLS 1.3)\n\nServicePointManager, using .NET Framework 4.7 and later versions, will use the default security protocol configured in the OS. To get the default OS choice, if possible, don't set a value for the ServicePointManager.SecurityProtocol property, which defaults to SecurityProtocolType.SystemDefault.\n\nBecause the SecurityProtocolType.SystemDefault setting causes the ServicePointManager to use the default security protocol configured by the operating system, your application may run differently based on the OS it's run on. For example, Windows 10 uses TLS 1.2 while Windows 11 uses TLS 1.3.\n\nSslStream, using .NET Framework 4.7 and later versions, defaults to the OS choosing the best security protocol and version. To get the default OS best choice, if possible, don't use the method overloads of SslStream that take an explicit SslProtocols parameter. Otherwise, pass SslProtocols.None. We recommend that you don't use Default; setting forces the use of SSL 3.0 /TLS 1.0 and prevents TLS 1.2.\n\nDon't set a value for the SecurityProtocol property (for HTTP networking).\n\nDon't use the method overloads of SslStream that take an explicit SslProtocols parameter (for TCP sockets networking). When you retarget your app to .NET Framework 4.7 or later versions, you'll be following the best practices recommendation.\n\nIf your app targets .NET Framework 4.7 or later versions\n\nThe following sections show how to configure your application to use of TLS. (TLS 1.2, TLS 1.3)\n\nUsing TCP transport using transport security with certificate credentials\n\nWCF uses the same networking stack as the rest of .NET Framework.\n\nIf you're targeting 4.7.1, WCF is configured to allow the OS to choose the best security protocol by default unless explicitly configured:\n• Or, in your application in the source code.\n\nBy default, .NET Framework 4.7 and later versions are configured to use TLS 1.2 and allow connections using TLS 1.1 or TLS 1.0. Configure WCF to allow the OS to choose the best security protocol by configuring your binding to use SslProtocols.None. This can be set on SslProtocols. can be accessed from Transport. can be accessed from Security.\n• Configure WCF to allow the OS to choose the best security protocol by setting SslProtocols to use SslProtocols.None.\n• Or configure the protocol used with the configuration path .\n\nIf you're not using a custom binding and you're setting your WCF binding using configuration, set the protocol used with the configuration path .\n\n.NET Framework 4.7 and later versions by default use the protocol specified in the SecurityProtocol property. When the AppContextSwitch is set to , WCF chooses the best protocol, up to TLS 1.0.\n\nIf your app targets a .NET Framework version earlier than 4.7\n\nThe following sections show how to configure your application to use of TLS. (TLS 1.2, TLS 1.3)\n\nUsing .NET Framework 4.6.2 using TCP transport security with Certificate Credentials\n\nThe WCF framework automatically chooses the highest protocol available up to TLS 1.2 unless you explicitly configure a protocol version. For more information, see the preceding section For WCF TCP transport using transport security with certificate credentials.\n\nUsing .NET Framework 3.5 using TCP transport security with Certificate Credentials\n\nThese versions of the WCF framework are explicitly specified to use values SSL 3.0 and TLS 1.0. These values cannot be changed. You must update and retarget to NET Framework 4.6.2 or later versions to use TLS 1.2.\n\nConfigure security via AppContext switches (for .NET Framework 4.6.2 or later versions)\n\nThe AppContext switches described in this section are relevant if your app targets, or runs on, .NET Framework 4.6.2 or later versions. Whether by default, or by setting them explicitly, the switches should be if possible. If you want to configure security via one or both switches, then don't specify a security protocol value in your code; doing so would override the switch(es).\n\nThe switches have the same effect whether you're doing HTTP networking (ServicePointManager) or TCP sockets networking (SslStream).\n\nA value of for causes your app to use strong cryptography. A value of for uses more secure network protocols (TLS 1.2 and TLS 1.1) and blocks protocols that are not secure. For more info, see The SCH_USE_STRONG_CRYPTO flag. A value of disables strong cryptography for your app. This switch affects only client (outgoing) connections in your application.\n\nIf your app targets .NET Framework 4.6.2 or later versions, this switch defaults to . That's a secure default, which we recommend. If your app runs on .NET Framework 4.6.2, but targets an earlier version, the switch defaults to . In that case, you should explicitly set it to .\n\nshould only have a value of if you need to connect to legacy services that don't support strong cryptography and can't be upgraded.\n\nA value of for causes your app to allow the operating system to choose the protocol. A value of causes your app to use protocols picked by the .NET Framework.\n\nIf your app targets .NET Framework 4.7 or later versions, this switch defaults to . That's a secure default that we recommend. If your app runs on .NET Framework 4.7 or later versions, but targets an earlier version, the switch defaults to . In that case, you should explicitly set it to .\n\nA value of for causes your application to use the value defined in for message security using certificate credentials. A value of uses the highest protocol available, up to TLS1.0\n\nFor applications targeting .NET Framework 4.7 and later versions, this value defaults to . For applications targeting .NET Framework 4.6.2 and earlier, this value defaults to .\n\nA value of for sets the default configuration to allow the operating system to choose the protocol. A value of sets the default to the highest protocol available, up to TLS1.2.\n\nFor applications targeting .NET Framework 4.7.1 and later versions, this value defaults to . For applications targeting .NET Framework 4.7 and earlier, this value defaults to .\n\nFor more information about TLS protocols, see Mitigation: TLS Protocols. For more information about switches, see .\n\nIf setting one or both switches isn't an option, you can control the security protocols that your app uses with the Windows Registry keys described in this section. You might not be able to use one or both the switches if your app runs on .NET Framework 3.5, or if you can't edit the configuration file. If you want to configure security with the registry, don't specify a security protocol value in your code; doing so overrides the registry setting.\n\nThe names of the registry keys are similar to the names of the corresponding switches but without a prepended to the name. For example, the switch is the registry key called SchUseStrongCrypto.\n\nThese keys are available in all .NET Framework versions.\n\nAll of the registry keys described below have the same effect whether you're doing HTTP networking (ServicePointManager) or TCP sockets networking (SslStream).\n\nThe registry entry has a value of type DWORD. A value of 1 causes your app to use strong cryptography. The strong cryptography uses more secure network protocols (TLS 1.2 and TLS 1.1) and blocks protocols that aren't secure. A value of 0 disables strong cryptography. For more information, see The SCH_USE_STRONG_CRYPTO flag. This registry setting affects only client (outgoing) connections in your application.\n\nIf your app targets .NET Framework 4.6 or later versions, this key defaults to a value of 1. That's a secure default that we recommend. If your app targets .NET Framework 4.5.2 or earlier versions, the key defaults to 0. In that case, you should explicitly set its value to 1.\n\nThis key should only have a value of 0 if you need to connect to legacy services that don't support strong cryptography and can't be upgraded.\n\nThe registry entry has a value of type DWORD. A value of 1 causes your app to allow the operating system to choose the protocol. A value of 0 causes your app to use protocols picked by the .NET Framework.\n\nmust be v4.0.30319 (for .NET Framework 4 and above) or v2.0.50727 (for .NET Framework 3.5).\n\nIf your app targets .NET Framework 4.7 or later versions, this key defaults to a value of 1. That's a secure default that we recommend. If your app targets .NET Framework 4.6.1 or earlier versions, the key defaults to 0. In that case, you should explicitly set its value to 1.\n\nFor more info, see Cumulative Update for Windows 10 Version 1511 and Windows Server 2016 Technical Preview 4: May 10, 2016.\n\nFor more information with .NET Framework 3.5.1, see Support for TLS System Default Versions included in .NET Framework 3.5.1 on Windows 7 SP1 and Server 2008 R2 SP1.\n\nThe following .REG file sets the registry entries and their variants to their most safe values:\n\nYou can use the registry for fine-grained control over the protocols that your client and/or server app negotiates. Your app's networking goes through Schannel (which is another name for Secure Channel). By configuring , you can configure your app's behavior.\n\nStart with the registry key. Under that key you can create any subkeys in the set , . Under each of those subkeys, you can create subkeys and/or . Under and , you can create DWORD values (0 or 1) and (0 or 1).\n\nFor more information see: TLS Registry Settings - Schannel\n\nWhen it's enabled (by default, by an switch, or by the Windows Registry), .NET Framework uses the flag when your app initiates a TLS connection to a server. .NET Framework passes the flag to to instruct it to disable known weak cryptographic algorithms, cipher suites, and TLS/SSL protocol versions that may be otherwise enabled for better interoperability. For more information, see:\n\nThe flag is also passed to for client (outgoing) connections when you explicitly use the or enumerated values of SecurityProtocolType or SslProtocols. The flag is used only for connections where your application acts the role of the client. You can disable weak protocols and algorithms when your applications acts the role of the server by configuring the machine-wide registry settings."
    },
    {
        "link": "https://learn.microsoft.com/en-us/troubleshoot/windows-server/active-directory/enable-ldap-over-ssl-3rd-certification-authority",
        "document": "This article describes how to enable Lightweight Directory Access Protocol (LDAP) over Secure Sockets Layer (SSL) with a third-party certification authority.\n\nThe LDAP is used to read from and write to Active Directory. By default, LDAP traffic is transmitted unsecured. You can make LDAP traffic confidential and secure by using SSL/Transport Layer Security (TLS) technology. You can enable LDAP over SSL (LDAPS) by installing a properly formatted certificate from either a Microsoft certification authority (CA) or a non-Microsoft CA according to the guidelines in this article.\n\nThere's no user interface for configuring LDAPS. Installing a valid certificate on a domain controller permits the LDAP service to listen for, and automatically accept, SSL connections for both LDAP and global catalog traffic.\n\nTo enable LDAPS, you must install a certificate that meets the following requirements:\n• None The LDAPS certificate is located in the Local Computer's Personal certificate store (programmatically known as the computer's MY certificate store). If there is a certificate in the NT Directory Services (NTDS) store, DC use the certificate in the NTDS store instead.\n• None A private key that matches the certificate is present in the Local Computer's store and is correctly associated with the certificate. The private key must not have strong private key protection enabled.\n• None The Enhanced Key Usage extension includes the Server Authentication (1.3.6.1.5.5.7.3.1) object identifier (also known as OID).\n• None The Active Directory fully qualified domain name of the domain controller (for example, dc01.contoso.com) must appear in one of the following places:\n• The Common Name (CN) in the Subject field.\n• DNS entry in the Subject Alternative Name extension.\n• None The certificate was issued by a CA that the domain controller and the LDAPS clients trust. Trust is established by configuring the clients and the server to trust the root CA to which the issuing CA chains.\n• None Use the Schannel cryptographic service provider (CSP) to generate the key.\n\nAny utility or application that creates a valid PKCS #10 request can be used to form the SSL certificate request. Use Certreq to form the request.\n\nCertreq.exe requires a text instruction file to generate an appropriate X.509 certificate request for a domain controller. You can create this file by using your preferred ASCII text editor. Save the file as an .inf file to any folder on your hard drive.\n\nTo request a Server Authentication certificate that is suitable for LDAPS, follow these steps:\n• None Create the .inf file. Following is an example .inf file that can be used to create the certificate request. Subject = \"CN=<DC fqdn>\" ; replace with the FQDN of the DC\n\n KeySpec = 1\n\n KeyLength = 1024\n\n ; Can be 1024, 2048, 4096, 8192, or 16384.\n\n ; Larger key sizes are more secure, but have\n\n ; a greater impact on performance.\n\n Exportable = TRUE\n\n MachineKeySet = TRUE\n\n SMIME = False\n\n PrivateKeyArchive = FALSE\n\n UserProtected = FALSE\n\n UseExistingKeySet = FALSE\n\n ProviderName = \"Microsoft RSA SChannel Cryptographic Provider\"\n\n ProviderType = 12\n\n RequestType = PKCS10\n\n KeyUsage = 0xa0 OID=1.3.6.1.5.5.7.3.1 ; this is for Server Authentication Cut and paste the sample file into a new text file named Request.inf. Provide the fully qualified DNS name of the domain controller in the request. Some third-party certification authorities may require additional information in the Subject parameter. Such information includes an e-mail address (E), organizational unit (OU), organization (O), locality, or city (L), state or province (S), and country or region (C). You can append this information to the Subject name (CN) in the Request.inf file. For example:\n• None Create the request file by running the following command at the command prompt: A new file called Request.req is created. It's the base64-encoded request file.\n• None Submit the request to a CA. You can submit the request to a Microsoft CA or to a third-party CA.\n• None Retrieve the certificate that's issued, and then save the certificate as Certnew.cer in the same folder as the request file by following these steps:\n• Open the file in Notepad, paste the encoded certificate into the file, and then save the file. The saved certificate must be encoded as base64. Some third-party CAs return the issued certificate to the requestor as base64-encoded text in an e-mail message.\n• None Accept the issued certificate by running the following command at the command prompt:\n• None Verify that the certificate is installed in the computer's Personal store by following these steps:\n• Add the Certificates snap-in that manages certificates on the local computer.\n• Expand Certificates (Local Computer), expand Personal, and then expand Certificates. A new certificate should exist in the Personal store. In the Certificate Properties dialog box, the intended purpose displayed is Server Authentication. This certificate is issued to the computer's fully qualified host name.\n\nFor more information about creating the certificate request, see the following Advanced Certificate Enrollment and Management white paper. To view this white paper, see Advanced Certificate Enrollment and Management.\n\nAfter a certificate is installed, follow these steps to verify that LDAPS is enabled:\n• None Type the name of the domain controller to which you want to connect.\n• RootDSE information should print in the right pane, indicating a successful connection.\n• LDAPS communication occurs over port TCP 636. LDAPS communication to a global catalog server occurs over TCP 3269. When connecting to ports 636 or 3269, SSL/TLS is negotiated before any LDAP traffic is exchanged.\n• Schannel, the Microsoft SSL provider, selects the first valid certificate that it finds in the local computer store. If there are multiple valid certificates available in the local computer store, Schannel may not select the correct certificate.\n• If an existing LDAPS certificate is replaced with another certificate, either through a renewal process or because the issuing CA has changed, the server must be restarted for Schannel to use the new certificate.\n\nThe original recommendation in this article was to put certificates in the Local Machine's Personal store. Although this option is supported, you can also put certificates in the NTDS Service's Personal certificate store in Windows Server 2008 and in later versions of Active Directory Domain Services (AD DS). For more information about how to add the certificate to the NTDS service's Personal certificate store, see Event ID 1220 - LDAP over SSL.\n\nAD DS preferentially looks for certificates in this store over the Local Machine's store. This makes it easier to configure AD DS to use the certificate that you want it to use. It's because there might be multiple certificates in the Local Machines Personal store, and it can be difficult to predict which one is selected.\n\nAD DS detects when a new certificate is dropped into its certificate store and then triggers an SSL certificate update without having to restart AD DS or restart the domain controller.\n\nA new rootDse operation that's named renewServerCertificate can be used to manually trigger AD DS to update its SSL certificates without having to restart AD DS or restart the domain controller. This attribute can be updated using adsiedit.msc, or by importing the change in LDAP Directory Interchange Format (LDIF) using ldifde.exe. For more information on using LDIF to update this attribute, see renewServerCertificate.\n\nFinally, if a Windows Server 2008 or a later version domain controller finds multiple certificates in its store, it will random chose one of these certificates.\n\nAll these work for Windows Server 2008 AD DS and for 2008 Active Directory Lightweight Directory Services (AD LDS). For AD LDS, put certificates into the Personal certificate store for the service that corresponds to the AD LDS instance instead of for the NTDS service."
    },
    {
        "link": "https://reddit.com/r/sysadmin/comments/3gq9ur/ldap_over_ssl_how_to_install_certificates",
        "document": "I have been struggling with this for some time and I just can't seem to figure it out. I am trying to connect to an Active Directory Windows Server from a Windows Web Server using a C#.NET application I created. I can connect fine but not over SSL.\n\nIn order to connect over SSL and correct me if I am wrong I need certificates installed on each server? Could someone walk me through how to do this? I have a CA installed on stand alone server that I can use to generate a self signed cert. I honestly I have no idea what I am doing. This is my first time working with Certs and really Windows Servers in general. Any help is appreciated. Thanks."
    }
]