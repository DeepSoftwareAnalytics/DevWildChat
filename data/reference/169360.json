[
    {
        "link": "https://stackoverflow.com/questions/5290141/android-broadcastreceiver-on-startup-keep-running-when-activity-is-in-backgrou",
        "document": "Service or Boot Completed is not mandatory\n\nIn fact, you don't need to implement a or register to\n\nSome examples shows how to register/unregister a when activity is created and destroyed. However, this is useful for intents that you expect only when app is opened (for internal communication between Service/Activity for example).\n\nHowever, in case of a SMS, you want to listen to the intent all the time (and not only when you app is opened).\n\nThere's another way\n\nYou can create a which extends and register to desired intents via . This way, the will be indepedent from your Activity (and will not depend from Activity's Life Cycle)\n\nThis way, your will be notified automatically by Android as soon as an SMS arrive even if your app is closed.\n\nYou can add others intent-filters to AndroidManifest and handle all of them in same .\n\nStart a Service only if you will perform a long task. You just need to display a notification or update some database, just use the code above."
    },
    {
        "link": "https://stackoverflow.com/questions/8950854/auto-start-application-after-boot-completed-in-android",
        "document": "I want to make an application which has auto start option in its settings. I have made Settings activity in my application which is derived from PreferenceActivity and give CheckBoxPreference for auto start option. If auto start option is enabled my application should start when booting of phone is completed. And if auto start option is disabled then it should not start on boot completed.\n\nTo achieve this I have implemented derived class of BroadcastReceiver which receives BOOT_COMPLETED intent, declare receiver in AndroidManifest.xml and also give permission in AndroidManifest.xml.\n\nIn application also there is a derived class of Application and start service also from the onCreate method of application derived class. If I declare receiver in AndroidManifest.xml then after booting completed onCreate of my application called and after that onReceive method of BroadcastReceiver called.\n\nNow the problem is that my application starts on boot completed every time whether auto start is enabled or disabled. Is it possible to not start application when auto start is disabled ?"
    },
    {
        "link": "https://developer.android.com/develop/background-work/background-tasks/broadcasts",
        "document": "Android apps send and receive broadcast messages from the Android system and other Android apps, similar to the publish-subscribe design pattern. The system and apps typically send broadcasts when certain events occur. For example, the Android system sends broadcasts when various system events occur, such as system boot or device charging. Apps also send custom broadcasts, for example, to notify other apps of something that might interest them (for example, new data download).\n\nApps can register to receive specific broadcasts. When a broadcast is sent, the system automatically routes broadcasts to apps that have subscribed to receive that particular type of broadcast.\n\nGenerally speaking, broadcasts can be used as a messaging system across apps and outside of the normal user flow. However, you must be careful not to abuse the opportunity to respond to broadcasts and run jobs in the background that can contribute to a slow system performance.\n\nThe system automatically sends broadcasts when various system events occur, such as when the system switches in and out of Airplane Mode. All subscribed apps receive these broadcasts.\n\nThe object wraps the broadcast message. The string identifies the event that occurred, such as . The intent might also include additional information bundled into its extra field. For example, the Airplane Mode intent includes a boolean extra that indicates whether or not Airplane Mode is on.\n\nFor more information about how to read intents and get the action string from an intent, see Intents and Intent Filters.\n\nFor a complete list of system broadcast actions, see the file in the Android SDK. Each broadcast action has a constant field associated with it. For example, the value of the constant is . Documentation for each broadcast action is available in its associated constant field.\n\nAs the Android platform evolves, it periodically changes how system broadcasts behave. Keep the following changes in mind to support all versions of Android.\n\nWhile apps are in a cached state, the system optimizes broadcast delivery for system health. For example, the system defers less important system broadcasts such as while the app is in a cached state. Once the app goes from the cached state into an active process lifecycle, the system delivers any deferred broadcasts.\n\nImportant broadcasts that are declared in the manifest temporarily remove apps from the cached state for delivery.\n\nBeginning with Android 9 (API level 28), The broadcast doesn't receive information about the user's location or personally identifiable data.\n\nIf your app is installed on a device running Android 9.0 (API level 28) or higher, the system doesn't include SSIDs, BSSIDs, connection information, or scan results in Wi-Fi broadcasts. To get this information, call instead.\n\nBeginning with Android 8.0 (API level 26), the system imposes additional restrictions on manifest-declared receivers.\n\nIf your app targets Android 8.0 or higher, you cannot use the manifest to declare a receiver for most implicit broadcasts (broadcasts that don't target your app specifically). You can still use a context-registered receiver when the user is actively using your app.\n\nAndroid 7.0 (API level 24) and higher don't send the following system broadcasts:\n\nAlso, apps targeting Android 7.0 and higher must register the broadcast using . Declaring a receiver in the manifest doesn't work.\n\nApps can receive broadcasts in two ways: through context-registered receivers and manifest-declared receivers.\n\nContext-registered receivers receive broadcasts as long as their registering context is valid. This is typically between the calls to and . The registering context also becomes invalid when the system destroys the corresponding context. For example, if you register within an context, you receive broadcasts as long as the activity remains active. If you register with the Application context, you receive broadcasts as long as the app runs.\n\nTo register a receiver with a context, perform the following steps:\n• None In your app's module-level build file, include version 1.9.0 or higher of the AndroidX Core library: // To use the Animator APIs // Optional - To enable APIs that query the performance characteristics of GMS devices. // Optional - to use ShortcutManagerCompat to donate shortcuts to be used by Google // To use the Animator APIs // Optional - To enable APIs that query the performance characteristics of GMS devices. // Optional - to use ShortcutManagerCompat to donate shortcuts to be used by Google\n• None Choose whether the broadcast receiver should be exported and visible to other apps on the device. If this receiver is listening for broadcasts sent from the system or from other apps—even other apps that you own—use the flag. If instead this receiver is listening only for broadcasts sent by your app, use the flag. Some system broadcasts come from highly privileged apps, such as Bluetooth and telephony, that are part of the Android framework but don't run under the system's unique process ID (UID). To receive all system broadcasts, including broadcasts from highly privileged apps, flag your receiver with . If you flag your receiver with , the receiver is able to receive some system broadcasts and broadcasts from your app, but not broadcasts from the highly privileged apps. If your app is listening for multiple broadcasts, but only some should be flagged and some , partition the broadcasts among different broadcast receivers. Caution: If you export the broadcast receiver, other apps could send unprotected broadcasts to your app.\n• None To stop receiving broadcasts, call . Be sure to unregister the receiver when you no longer need it or the context is no longer valid.\n\nWhile the broadcast receiver is registered, it holds a reference to the Context that you registered it with. This can potentially cause leaks if the receiver's registered scope exceeds the Context lifecycle scope. For example, this can occur when you register a receiver on an Activity scope, but you forget to unregister it when the system destroys the Activity. Therefore, always unregister your broadcast receiver.\n\nYour broadcast receiver should only be registered when you're actually interested in the result. Choose the smallest possible receiver scope:\n• or activity / lifecycle methods: The broadcast receiver only receives updates while the app is in its resumed state.\n• or activity / lifecycle methods: The broadcast receiver only receives updates while the app is in its resumed state.\n• : The broadcast receiver only receives updates while the composable is in the composition tree. This scope is not attached to the activity lifecycle scope. Consider registering the receiver on the application context. This is because the composable could theoretically outlive the activity lifecycle scope and leak the activity.\n• Activity / : The broadcast receiver receives updates while the activity is in its created state. Make sure to unregister in and not because this might not be called.\n• A custom scope: For example, you can register a receiver in your scope, so it survives activity recreation. Make sure to use the application context to register the receiver on, as the receiver can outlive the activity lifecycle scope and leak the activity.\n\nCompose has stateful and stateless composables. Registering or unregistering a broadcast receiver inside a composable makes it stateful. The composable is not a deterministic function that renders the same content when passed the same parameters. Internal state can change based on calls to the registered broadcast receiver.\n\nAs a best practice in Compose, we recommend that you split your composables into stateful and stateless versions. Therefore, we recommend that you hoist the creation of the broadcast receiver out of a Composable to make it stateless:\n\nIf you declare a broadcast receiver in your manifest, the system launches your app when the broadcast is sent. If the app is not already running, the system launches the app.\n\nTo declare a broadcast receiver in the manifest, perform the following steps:\n• None Specify the element in your app's manifest. <!-- If this receiver listens for broadcasts sent from the system or from other apps, even other apps that you own, set android:exported to \"true\". --> <receiver android:name=\".MyBroadcastReceiver\" android:exported=\"false\"> <intent-filter> <action android:name=\"com.example.snippets.ACTION_UPDATE_DATA\" /> </intent-filter> </receiver> The intent filters specify the broadcast actions your receiver subscribes to.\n• None Subclass and implement . The broadcast receiver in the following example logs and displays the contents of the broadcast: // Do something with the data, for example send it to a data repository: // Do something with the data, for example send it to a data repository:\n\nThe system package manager registers the receiver when the app is installed. The receiver then becomes a separate entry point into your app which means that the system can start the app and deliver the broadcast if the app is not running.\n\nThe system creates a new component object to handle each broadcast that it receives. This object is valid only for the duration of the call to . Once your code returns from this method, the system considers the component no longer active.\n\nWhether your is operating or not affects its contained process, which can alter its system-killing likelihood. A foreground process executes a receiver's method. The system runs the process except under extreme memory pressure.\n\nThe system deactivates the after . The receiver's host process's significance depends on its app components. If that process hosts only a manifest-declared receiver, the system might kill it after to free resources for other more critical processes. This is common for apps the user has never or not recently interacted with.\n\nThus, broadcast receivers shouldn't initiate long-running background threads. The system can stop the process at any moment after to reclaim memory, terminating the created thread. To keep the process alive, schedule a from the receiver using the so the system knows the process is still working. Background Work Overview provides more details.\n\nAndroid provides two ways for apps to send broadcasts:\n• The method sends broadcasts to one receiver at a time. As each receiver executes in turn, it can propagate a result to the next receiver. It can also completely abort the broadcast so that it doesn't reach other receivers. You can control the order in which receivers run. To do so, use the android:priority attribute of the matching intent-filter. Receivers with the same priority are run in an arbitrary order.\n• The method sends broadcasts to all receivers in an undefined order. This is called a Normal Broadcast. This is more efficient, but means that receivers cannot read results from other receivers, propagate data received from the broadcast, or abort the broadcast.\n\nThe following code snippet demonstrates how to send a broadcast by creating an Intent and calling .\n\nThe broadcast message is wrapped in an object. The intent's string must provide the app's Java package name syntax and uniquely identify the broadcast event. You can attach additional information to the intent with . You can also limit a broadcast to a set of apps in the same organization by calling on the intent.\n\nPermissions allow you to restrict broadcasts to the set of apps that hold certain permissions. You can enforce restrictions on either the sender or receiver of a broadcast.\n\nWhen you call or , you can specify a permission parameter. Only receivers who have requested that permission with the tag in their manifest can receive the broadcast. If the permission is dangerous, you must grant the permission before the receiver can receive the broadcast. For example, the following code sends a broadcast with a permission:\n\nTo receive the broadcast, the receiving app must request the permission as follows:\n\nYou can specify either an existing system permission like or define a custom permission with the element. For information on permissions and security in general, see the System Permissions.\n\nIf you specify a permission parameter when registering a broadcast receiver (either with or in tag in your manifest), then only broadcasters who have requested the permission with the tag in their manifest can send an Intent to the receiver. If the permission is dangerous, the broadcaster must also be granted the permission.\n\nFor example, assume your receiving app has a manifest-declared receiver as follows:\n\nOr your receiving app has a context-registered receiver as follows:\n\nThen, to be able to send broadcasts to those receivers, the sending app must request the permission as follows:\n\nHere are some security considerations for sending and receiving broadcasts:\n• None If many apps have registered to receive the same broadcast in their manifest, it can cause the system to launch a lot of apps, causing a substantial impact on both device performance and user experience. To avoid this, prefer using context registration over manifest declaration. Sometimes, the Android system itself enforces the use of context-registered receivers. For example, the broadcast is delivered only to context-registered receivers.\n• None Don't broadcast sensitive information using an implicit intent. Any app can read the information if it registers to receive the broadcast. There are three ways to control who can receive your broadcasts:\n• You can specify a permission when sending a broadcast.\n• In Android 4.0 (API level 14) and higher, you can specify a package with when sending a broadcast. The system restricts the broadcast to the set of apps that match the package.\n• None When you register a receiver, any app can send potentially malicious broadcasts to your app's receiver. There are several ways to limit the broadcasts that your app receives:\n• You can specify a permission when registering a broadcast receiver.\n• For manifest-declared receivers, you can set the android:exported attribute to \"false\" in the manifest. The receiver does not receive broadcasts from sources outside of the app.\n• None The namespace for broadcast actions is global. Make sure that action names and other strings are written in a namespace you own. Otherwise, you may inadvertently conflict with other apps.\n• None Because a receiver's method runs on the main thread, it should execute and return quickly. If you need to perform long-running work, be careful about spawning threads or starting background services because the system can kill the entire process after returns. For more information, see Effect on process state To perform long running work, we recommend:\n• Calling in your receiver's method and passing the to a background thread. This keeps the broadcast active after returning from . However, even with this approach the system expects you to finish with the broadcast very quickly (under 10 seconds). It does allow you to move work to another thread to avoid glitching the main thread.\n• Scheduling a job with the . For more information, see Intelligent Job Scheduling.\n• None Don't start activities from broadcast receivers because the user experience is jarring; especially if there is more than one receiver. Instead, consider displaying a notification."
    },
    {
        "link": "https://digi.com/resources/documentation/digidocs/embedded/android/oreo/cc6/android_t_faq-autostart-custom-apps",
        "document": "When an Android system boots, it sends out a boot complete event. Android applications can listen and capture this event to take specific actions, such as automatically starting an activity or service. You can use this mechanism to create an application with the required permissions to listen for the boot complete event and automatically start an activity or service every time Android starts up. To do so, follow these steps:\n• Declare the permission in AndroidManifest.xml. Add the android.permission.RECEIVE_BOOT_COMPLETED permission to your application’s manifest file just before the application declaration node:\n• Define the Activity that will be auto-started in the AndroidManifest.xml. Place this declaration inside the application node:\n• Register the Receiver listening for the boot complete event in the AndroidManifest.xml. Place this declaration inside the application node:\n• Create the receiver class to listen for the boot complete event. This class must extend BroadcastReceiver abstract class. Its onReceive() method is called when the device boot is complete. For example, create a Java class called StartMyActivityAtBootReceiver.java and place it in the same package as the activity class to auto-start: When this class receives an intent, it checks if it is the ACTION_BOOT_COMPLETE. If so, it creates a new activity intent and fills it with the activity class to be started. Finally, it executes the startActivity() method using the Android context and the activity intent. Due to security reasons, Android does not auto-start any application until you manually launch it at least once. After that, the applications will automatically start on each Android boot.\n\nThe home screen you see on your Android device after boot is a standard application that reacts to a home event. When Android finishes booting and is ready to start the home activity, the home event is sent and qualifying applications identify themselves as bootable candidates. The system sends out the android.intent.category.HOME and android.intent.category.DEFAULT intents when it is done initializing. Android looks for application manifests with these intent filters when it starts up. If there is more than one, Android lists all of them and allows you to select the one to launch. To designate your application as a home application, follow these steps:\n• Add the intent filters to AndroidManifest.xml. Copy these two lines into the intent filter of your application main activity: Your main activity definition should look similar to the following:\n• Install your application in the device. On the next startup, Android displays a dialog box that allows you to choose between the default Android launcher and the application you just modified: You can set your selection as the default home application for the future. The Replace the default Android Home application procedure is only valid for already-deployed Android systems. If you want to deploy an Android system with a custom home application already designated, you must make additional changes to the Android BSP sources:\n• Create a custom home application and include it in the Android BSP sources. You can directly include the application source code or a pre-compiled version of it. Verify that your custom Android home application includes the android.intent.category.HOME and android.intent.category.DEFAULT intent filters in the application manifest file.\n• Force your application to override the default launcher applications. Add the following entry in your application’s Android.mk file just before the include $(BUILD_PACKAGE) line: Your application’s Android.mk file should look similar to the following:\n• Include your application in the Android firmware build. Add your application’s module name \"MyApplication\" (as defined in the LOCAL_PACKAGE_NAME of your Application’s Android.mk file) to the list of packages of the firmware at device/digi/ccimx6sbc/ccimx6sbc.mk:\n• Build the Android firmware. Issue this command sequence in the root folder of the Android sources.\n• Clean the artifacts from the previous build:\n• <Number_Of_Jobs> is the number of cores you want to use for the build process. The resulting firmware will boot your custom Android home application by default."
    },
    {
        "link": "https://developer.android.com/about/versions/11/reference/broadcast-intents-30",
        "document": "The Android system automatically sends broadcasts when various system events occur, such as when the system switches in and out of airplane mode. The system sends these broadcasts to all apps that are subscribed to receive the event.\n\nThe table below lists the standard system broadcast intents that your app can receive in Android 11 (API level 30). To learn more about each broadcast Intent, use the links below. To learn more about broadcasts or how to receive them, see the documentation.\n\nIf you discover issues with the intents below or they are not broadcast on a specific device, please let us know by giving us feedback."
    },
    {
        "link": "https://stackoverflow.com/questions/17456320/is-it-possible-to-run-processbuilder-from-an-android-service",
        "document": "I've encountered very strange problem. I have service which have to send command \"input keyevent NUMBER\". I'm using ProcessBuilder to launch it. The strange thing is - when my Activity(the one I use to launch the service) is active, the commands are processed. Hovewer, when Activity is not on the foreground, the commands aren't doing anything! Why is is it so?\n\nI'm thinking about creating JNI library with function which calls something like \"system(whatever I'd like to call)\". Is is a correct approach?"
    },
    {
        "link": "https://stackoverflow.com/questions/21253614/execute-a-shell-command-using-processbuilder-and-interact-with-it",
        "document": "I'm trying to create a program allowing me to execute a command through a terminal (which is OmxPlayer for raspberry pi if you want to know) with arguments, but i'd want to be able to interact with it once I have launched the command.\n\nFor example i'd want to do : omxplayer -win x1 y1 x2 y2 and then be able to press \"p\" to pause the video/audio media\n\nI already have something that can launch the omxplayer with arguments (actually it's \"ls\" but it should work exactly the same way) but I don't understand how to interact with the terminal once i've launched the command through the processBuilder.\n\nHere's what i've got at the moment :"
    },
    {
        "link": "https://developer.android.com/reference/java/lang/ProcessBuilder",
        "document": "This class is used to create operating system processes.\n\nEach instance manages a collection of process attributes. The method creates a new instance with those attributes. The method can be invoked repeatedly from the same instance to create new subprocesses with identical or related attributes.\n• a command, a list of strings which signifies the external program file to be invoked and its arguments, if any. Which string lists represent a valid operating system command is system-dependent. For example, it is common for each conceptual argument to be an element in this list, but there are operating systems where programs are expected to tokenize command line strings themselves - on such a system a Java implementation might require commands to contain exactly two elements.\n• an environment, which is a system-dependent mapping from variables to values. The initial value is a copy of the environment of the current process (see ).\n• a working directory. The default value is the current working directory of the current process, usually the directory named by the system property .\n• a source of standard input. By default, the subprocess reads input from a pipe. Java code can access this pipe via the output stream returned by . However, standard input may be redirected to another source using . In this case, will return a null output stream, for which:\n• the method does nothing\n• a destination for standard output and standard error. By default, the subprocess writes standard output and standard error to pipes. Java code can access these pipes via the input streams returned by and . However, standard output and standard error may be redirected to other destinations using and . In this case, and/or will return a null input stream, for which:\n• the method does nothing\n• a redirectErrorStream property. Initially, this property is , meaning that the standard output and error output of a subprocess are sent to two separate streams, which can be accessed using the and methods. If the value is set to , then:\n• standard error is merged with the standard output and always sent to the same destination (this makes it easier to correlate error messages with the corresponding output)\n• the common destination of standard error and standard output can be redirected using\n• any redirection set by the method is ignored when creating a subprocess\n• the stream returned from will always be a null input stream\n\nModifying a process builder's attributes will affect processes subsequently started by that object's method, but will never affect previously started processes or the Java process itself.\n\nMost error checking is performed by the method. It is possible to modify the state of an object so that will fail. For example, setting the command attribute to an empty list will not throw an exception unless is invoked.\n\nNote that this class is not synchronized. If multiple threads access a instance concurrently, and at least one of the threads modifies one of the attributes structurally, it must be synchronized externally.\n\nStarting a new process which uses the default working directory and environment is easy:\n\nHere is an example that starts a process with a modified working directory and environment, and redirects standard output and error to be appended to a log file:\n\nTo start a process with an explicit set of environment variables, first call before adding environment variables."
    },
    {
        "link": "https://developer.android.com/reference/android/content/Intent",
        "document": "An intent is an abstract description of an operation to be performed. It can be used with to launch an , to send it to any interested components, and or to communicate with a background .\n\nAn Intent provides a facility for performing late runtime binding between the code in different applications. Its most significant use is in the launching of activities, where it can be thought of as the glue between activities. It is basically a passive data structure holding an abstract description of an action to be performed.\n\nFor information about how to create and resolve intents, read the Intents and Intent Filters developer guide.\n\nThe primary pieces of information in an intent are:\n\ndata -- The data to operate on, such as a person record in the contacts database, expressed as a Uri .\n\naction -- The general action to be performed, such as ACTION_VIEW , ACTION_EDIT , ACTION_MAIN , etc.\n\nSome examples of action/data pairs are:\n\nACTION_VIEW content://contacts/people/ -- Display a list of people, which the user can browse through. This example is a typical top-level entry into the Contacts application, showing you the list of people. Selecting a particular person to view would result in a new intent { ACTION_VIEW content://contacts/people/N } being used to start an activity to display that person.\n\nACTION_EDIT content://contacts/people/1 -- Edit information about the person whose identifier is \"1\".\n\nACTION_DIAL tel:123 -- Display the phone dialer with the given number filled in.\n\nACTION_VIEW tel:123 -- Display the phone dialer with the given number filled in. Note how the VIEW action does what is considered the most reasonable thing for a particular URI.\n\nACTION_DIAL content://contacts/people/1 -- Display the phone dialer with the person filled in.\n\nACTION_VIEW content://contacts/people/1 -- Display information about the person whose identifier is \"1\".\n\nIn addition to these primary attributes, there are a number of secondary attributes that you can also include with an intent:\n\nextras -- This is a Bundle of any additional information. This can be used to provide extended information to the component. For example, if we have a action to send an e-mail message, we could also include extra pieces of data here to supply a subject, body, etc.\n\ncomponent -- Specifies an explicit name of a component class to use for the intent. Normally this is determined by looking at the other information in the intent (the action, data/type, and categories) and matching that with a component that can handle it. If this attribute is set then none of the evaluation is performed, and this component is used exactly as is. By specifying this attribute, all of the other Intent attributes become optional.\n\ntype -- Specifies an explicit type (a MIME type) of the intent data. Normally the type is inferred from the data itself. By setting this attribute, you disable that evaluation and force an explicit type.\n\ncategory -- Gives additional information about the action to execute. For example, CATEGORY_LAUNCHER means it should appear in the Launcher as a top-level application, while CATEGORY_ALTERNATIVE means it should be included in a list of alternative actions the user can perform on a piece of data.\n\nHere are some examples of other operations you can specify as intents using these additional parameters:\n\nACTION_GET_CONTENT with MIME type */* and category CATEGORY_OPENABLE -- Display all pickers for data that can be opened with ContentResolver.openInputStream() , allowing the user to pick one of them and then some data inside of it and returning the resulting URI to the caller. This can be used, for example, in an e-mail application to allow the user to pick some data to include as an attachment.\n\nACTION_GET_CONTENT with MIME type vnd.android.cursor.item/phone -- Display the list of people's phone numbers, allowing the user to browse through them and pick one and return it to the parent activity.\n\nThere are a variety of standard Intent action and category constants defined in the Intent class, but applications can also define their own. These strings use Java-style scoping, to ensure they are unique -- for example, the standard is called \"android.intent.action.VIEW\".\n\nPut together, the set of actions, data types, categories, and extra data defines a language for the system allowing for the expression of phrases such as \"call john smith's cell\". As applications are added to the system, they can extend this language by adding new actions, types, and categories, or they can modify the behavior of existing phrases by supplying their own activities that handle them.\n\nThere are two primary forms of intents you will use.\n\nImplicit Intents have not specified a component; instead, they must include enough information for the system to determine which of the available components is best to run for that intent.\n\nExplicit Intents have specified a component (via setComponent(ComponentName) or setClass(Context, Class) ), which provides the exact class to be run. Often these will not include any other information, simply being a way for an application to launch various internal activities it has as the user interacts with the application.\n\nWhen using implicit intents, given such an arbitrary intent we need to know what to do with it. This is handled by the process of Intent resolution, which maps an Intent to an , , or (or sometimes two or more activities/receivers) that can handle it.\n\nThe intent resolution mechanism basically revolves around matching an Intent against all of the <intent-filter> descriptions in the installed application packages. (Plus, in the case of broadcasts, any objects explicitly registered with .) More details on this can be found in the documentation on the class.\n\nThere are three pieces of information in the Intent that are used for resolution: the action, type, and category. Using this information, a query is done on the for a component that can handle the intent. The appropriate component is determined based on the intent information supplied in the file as follows:\n\nThe categories , if supplied, must all be listed by the activity as categories it handles. That is, if you include the categories CATEGORY_LAUNCHER and CATEGORY_ALTERNATIVE , then you will only resolve to components with an intent that lists both of those categories. Activities will very often need to support the CATEGORY_DEFAULT so that they can be found by Context.startActivity() .\n\nThe type is retrieved from the Intent's data, if not already supplied in the Intent. Like the action, if a type is included in the intent (either explicitly or implicitly in its data), then this must be listed by the component as one it handles.\n\nThe action , if given, must be listed by the component as one it handles.\n\nFor example, consider the Note Pad sample application that allows a user to browse through a list of notes data and view details about individual items. Text in italics indicates places where you would replace a name with one specific to your own package.\n\nThe first activity, , serves as our main entry into the app. It can do three things as described by its three intent templates:\n\nThis filter describes the ability to return to the caller a note selected by the user without needing to know where it came from. The data type vnd.android.cursor.item/vnd.google.note is a URI from which a Cursor of exactly one ( vnd.android.cursor.item ) item can be retrieved which contains our note pad data ( vnd.google.note ). The GET_CONTENT action is similar to the PICK action, where the activity will return to its caller a piece of data selected by the user. Here, however, the caller specifies the type of data they desire instead of the type of data the user will be picking from.\n\nThis declares the things that the activity can do on a directory of notes. The type being supported is given with the <type> tag, where vnd.android.cursor.dir/vnd.google.note is a URI from which a Cursor of zero or more items ( vnd.android.cursor.dir ) can be retrieved which holds our note pad data ( vnd.google.note ). The activity allows the user to view or edit the directory of data (via the VIEW and EDIT actions), or to pick a particular note and return it to the caller (via the PICK action). Note also the DEFAULT category supplied here: this is required for the Context.startActivity method to resolve your activity when its component name is not explicitly specified.\n\nThis provides a top-level entry into the NotePad application: the standard MAIN action is a main entry point (not requiring any other information in the Intent), and the LAUNCHER category says that this entry point should be listed in the application launcher.\n\nGiven these capabilities, the following intents will resolve to the NotesList activity:\n\n{ action=android.app.action.GET_CONTENT type=vnd.android.cursor.item/vnd.google.note } is similar to the pick action, but allows the caller to specify the kind of data they want back so that the system can find the appropriate activity to pick something of that data type.\n\n{ action=android.app.action.PICK data=content://com.google.provider.NotePad/notes } provides a list of the notes under \"content://com.google.provider.NotePad/notes\", from which the user can pick a note whose data URL is returned back to the caller.\n\n{ action=android.intent.action.VIEW data=content://com.google.provider.NotePad/notes } displays a list of all the notes under \"content://com.google.provider.NotePad/notes\", which the user can browse through and see the details on.\n\n{ action=android.app.action.MAIN, category=android.app.category.LAUNCHER } is the actual intent used by the Launcher to populate its top-level list.\n\n{ action=android.app.action.MAIN } matches all of the activities that can be used as top-level entry points into an application.\n\nThe second activity, , shows the user a single note entry and allows them to edit it. It can do two things as described by its two intent templates:\n\nThe secondary use of this activity is to insert a new note entry into an existing directory of notes. This is used when the user creates a new note: the INSERT action is executed on the directory of notes, causing this activity to run and have the user create the new note data which it then adds to the content provider.\n\nThe first, primary, purpose of this activity is to let the user interact with a single note, as decribed by the MIME type vnd.android.cursor.item/vnd.google.note . The activity can either VIEW a note or allow the user to EDIT it. Again we support the DEFAULT category to allow the activity to be launched without explicitly specifying its component.\n\nGiven these capabilities, the following intents will resolve to the NoteEditor activity:\n\n{ action=android.app.action.INSERT data=content://com.google.provider.NotePad/notes } creates a new, empty note in the notes list at \"content://com.google.provider.NotePad/notes\" and allows the user to edit it. If they keep their changes, the URI of the newly created note is returned to the caller.\n\n{ action=android.app.action.EDIT data=content://com.google.provider.NotePad/notes/ {ID} } allows the user to edit the content of note {ID} .\n\nThe last activity, , allows the user to edit the title of a note. This could be implemented as a class that the application directly invokes (by explicitly setting its component in the Intent), but here we show a way you can publish alternative operations on existing data:\n\nIn the single intent template here, we have created our own private action called which means to edit the title of a note. It must be invoked on a specific note (data type ) like the previous view and edit actions, but here displays and edits the title contained in the note data.\n\nIn addition to supporting the default category as usual, our title editor also supports two other standard categories: ALTERNATIVE and SELECTED_ALTERNATIVE. Implementing these categories allows others to find the special action it provides without directly knowing about it, through the method, or more often to build dynamic menu items with . Note that in the intent template here was also supply an explicit name for the template (via ) to better control what the user sees when presented with this activity as an alternative action to the data they are viewing.\n\nGiven these capabilities, the following intent will resolve to the TitleEditor activity:\n\n{ action=com.android.notepad.action.EDIT_TITLE data=content://com.google.provider.NotePad/notes/ {ID} } displays and allows the user to edit the title associated with note {ID} .\n\nThese are the current standard actions that Intent defines for launching activities (usually through . The most important, and by far most frequently used, are and .\n\nThese are the current standard actions that Intent defines for receiving broadcasts (usually through or a <receiver> tag in a manifest).\n\nNote: If your app targets Android 11 (API level 30) or higher, registering broadcast such as that includes package details in the extras receives a filtered list of apps or nothing. Learn more about how to manage package visibility.\n\nThese are the current standard categories that can be used to further clarify an Intent via .\n\nThese are the current standard fields that can be used as extra data via .\n\nThese are the possible flags that can be used in the Intent via and . See for a list of all possible flags.\n\n[[[\"Easy to understand\",\"easyToUnderstand\",\"thumb-up\"],[\"Solved my problem\",\"solvedMyProblem\",\"thumb-up\"],[\"Other\",\"otherUp\",\"thumb-up\"]],[[\"Missing the information I need\",\"missingTheInformationINeed\",\"thumb-down\"],[\"Too complicated / too many steps\",\"tooComplicatedTooManySteps\",\"thumb-down\"],[\"Out of date\",\"outOfDate\",\"thumb-down\"],[\"Samples / code issue\",\"samplesCodeIssue\",\"thumb-down\"],[\"Other\",\"otherDown\",\"thumb-down\"]],[\"Last updated 2025-03-13 UTC.\"],[],[]]"
    },
    {
        "link": "https://quora.com/How-do-I-create-an-Android-app-to-run-a-particular-shell-script-at-specific-times",
        "document": "Something went wrong. Wait a moment and try again."
    },
    {
        "link": "https://stackoverflow.com/questions/7399028/android-adb-permission-denied",
        "document": "Without rooting: If you can't root your phone, use the command to be able to access data of your application.\n\nexecutes the command without starting a shell and mangling the output."
    },
    {
        "link": "https://stackoverflow.com/questions/52079343/how-can-i-use-adb-to-grant-permission-without-root",
        "document": "I'm trying to create an app that can grant and revoke permissions of other apps.\n\n To do this I'm using adb commands:\n\nThis works great if I call it through a shell with root permissions.\n\nThe problem is that when I call this command without root permissions, I receive\n\nThis is to be expected (it would be a big problem otherwise).\n\nIs it possible to allow my app to manage other apps permissions through Android settings?\n\n I'm looking for something like granting USAGE_STATS permission to an app going to Settings -> Security -> \"App with usage access\", but for GRANT_RUNTIME_PERMISSIONS (and REVOKE_RUNTIME_PERMISSIONS)."
    },
    {
        "link": "https://android.stackexchange.com/questions/220292/list-of-adb-settable-permissions",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://dev.to/larsonzhong/most-complete-adb-commands-4pcg",
        "document": "\n• Basic usage\n• Specify the target device for the command\n• Specify the network port of adb server\n• Device connection management\n• Wireless connection (no need to use USB cable)\n• Interact with the application\n• Revoke the permissions of the application\n• File Management\n• Copy the files in the device to the computer\n• Useful functions\n• Check if the device is rooted\n\n*The content of this article is integrated from the Internet, welcome to reprint. *\n\nI believe that friends who do Android development have used ADB commands, but they are only limited to installing application push files and device restarting. I don’t know the deeper ones. In fact, we can understand a little more. There are some uncommon scenarios we should at least Knowing that it can be done, for example, we know adb install but not adb shell am start. The former is used to install software, and the latter is used to open the software. A usage scenario of the latter makes me pay attention to him: the company customizes the Android system. When debugging the screen, it depends on whether the screen is full to verify that the driver is normal. This is a troublesome approach. It is to be installed and opened in the hands of Android developers with eclipse or other ide. Obviously, it is much more complicated than the driver who connects the data line and uses the adb command. Therefore, it is necessary to know more.\n\nThe following may be more cumbersome, I will try to be simple, please be patient and finish reading.\n\nThe full name of Adb is Android Debug Bridge: Android Debug Bridge. The picture below shows the official introduction of Adb by Android:\n\nIt can be seen that the original intention of Android is to use a tool such as adb to assist developers in debugging apk faster and better in the process of developing android applications, so adb has the ability to install and uninstall apk, copy and push files, view device hardware information, and view Functions such as applications occupying resources and executing shell commands on the device;\n\nWe can find the adb tool in the platform-tools directory of the android sdk installation directory;\n\nThe permission mechanism of the existing Android system is becoming more and more perfect. Many operations that hope to bypass the permission management mechanism are no longer available, but Adb can achieve it. In fact, Adb has a lot of authority to some extent, even on the latest version of the Android system. Because Adb is designed to facilitate debugging by developers, it is necessary to expose some interfaces outside of permissions. So many companies can use this feature to bypass the permission mechanism to do some operations on non-Root non-customized machines (the specific usage is mentioned below), of course, there are also various ways, such as connecting via mobile phone OTG, which will not be repeated here.\n\nIn order to facilitate understanding, we start with three instructions, we often use adb start-server, adb devices, adb kill-server.\n\n Then we often see this output interface:\n\nSo there are three questions here, why is the server, the server corresponds to the server or the server? If the mobile phone is the client, does the server refer to the service opened on the computer. And what is this daemon?\n\nADB is a C/S architecture application, composed of three parts:\n• Adb client running on the PC side: The command line program \"adb\" is used to run adb commands from a shell or script. First, the \"adb\" program tries to locate the ADB server on the host. If the ADB server cannot be found, the \"adb\" program automatically starts an ADB server. Next, when the adbd of the device and the adb server on the pc side establish a connection, the adb client can send a service request to the ADB servcer;\n• Adb server running on the PC side: ADB Server is a background process running on the host. Its function is to detect the connection and removal of the USB port sensing device, and the start or stop of the emulator instance. ADB Server also needs to send the request of the adb client to the corresponding adbd via usb or tcp;\n• The resident process adb demon (adbd) running on the device side: The program \"adbd\" runs as a background process in the Android device or emulator system. Its function is to connect to the ADB server and provide some services for the client running on the host;\n\nA small partner said that he hoped that I would put the Adb startup problem at the top, because he often encountered the problem of adb unable to find the device, then I will put it in front, I think it is definitely not only she will encounter this situation .\n\n5037 is the default port of adb. If port 5037 is occupied, we will be troubled by not finding the device when using the Adb command. This problem is often encountered for those who are not very familiar with Adb, so I will This usage is placed at the beginning of the article so that friends can find it easily;\n\n The idea of ​​solving this kind of port occupation problem is the same, three steps:\n• Find the Pid of the process using the port;\n• Find the corresponding process name through PID (easy to locate, you can skip);\n• Use the command to terminate the operation of the command;\n\nWhat can adb do? The answer is that all operations that can be performed on mobile phones can be implemented with adb. That is to say, if you play 6, your touch screen is completely broken, and the display is completely broken, just give you a motherboard, and you can still complete the actions you want to do. Of course, this is not recommended in general scenarios, efficiency is the priority.\n\nThe following content is transferred from the blog of a big cow on github. If there is any infringement, please inform and delete it immediately;\n\n Late\n\nThe basic syntax of the adb command is as follows:\n\nIf there is only one device/emulator connected, you can omit the part [-d|-e|-s ] and use adb directly.\n\nSpecify the target device for the command\n\nIf there are multiple devices/emulators connected, you need to specify the target device for the command.\n\nWhen multiple devices/emulators are connected, the -s parameter is commonly used. The serialNumber can be obtained through the adb devices command. Such as:\n\nCf264b8f, emulator-5554 and 10.129.164.6:5555 in the output are serialNumber.\n\nFor example, you want to specify the device cf264b8f to run the adb command to obtain the screen resolution:\n\nAnother example is to install an application on the device 10.129.164.6:5555 (the format of serialNumber in this form is :, which is generally a wirelessly connected device or a third-party Android emulator such as Genymotion):\n\n*In the case of multiple devices/simulators, these parameters are used to specify the target device for the command. The following is a simplified description and will not be repeated. *\n\nThe operating principle of adb is that the adb server on the PC side establishes a connection with the daemon adbd on the mobile phone side, and then the adb client on the PC side forwards the command through the adb server, and adbd parses and runs after receiving the command.\n\nSo if adbd is executed with normal permissions, some commands that require root permissions to execute cannot be directly executed with adb xxx. At this time, you can execute commands after adb shell and then su, or you can let adbd execute with root privileges, which can execute high-privileged commands at will.\n\nNow run adb shell again and see if the command line prompt becomes #?\n\nSome mobile phones cannot be executed with root privileges through the adb root command after rooting. For example, some Samsung models will prompt adbd cannot run as root in production builds. You can install adbd Insecure first, and then adb root Try it.\n\nCorrespondingly, if you want to restore adbd to non-root privileges, you can use the adb unroot command.\n\nSpecify the network port of adb server\n\nThe output format is [serialNumber] [state], serialNumber is what we often call SN, and the state is as follows:\n\noffline —— Indicates that the device is not successfully connected or has no response.\n\ndevice-The device is connected. Note that this state does not indicate that the Android system has been fully started and operable. The device instance can be connected to adb during the device startup process, but the system will be in an operable state after startup.\n\nThe above output shows that three devices/emulators are currently connected, and cf264b8f, emulator-5554 and 10.129.164.6:5555 are their SNs respectively. It can be seen from the name emulator-5554 that it is an Android emulator, and 10.129.164.6:5555, which is the serialNumber of the form :, is generally a wirelessly connected device or a third-party Android emulator such as Genymotion.\n\nList of devices attached\n\n The device/emulator is not connected to adb or not responding.\n\nTo use adb normally through USB connection, you need to ensure several points:\n\nIncluding the Android device is in the normal boot state, the USB cable and various interfaces are intact.\n\nDeveloper options and USB debugging mode for Android devices are turned on.\n\nYou can go to \"Settings\"-\"Developer Options\"-\"Android Debugging\" to view.\n\nIf you can't find the developer option in the settings, you need to use an easter egg to show it: click the \"version number\" 7 times in \"Settings\"-\"About Phone\".\n\nIt seems that you don’t need to worry about this under Linux and Mac OS X. Under Windows, you may encounter a situation where you need to install a driver. To confirm this, you can right-click \"Computer\"-\"Properties\" and go to the \"Device Manager\" to view related devices Whether there is a yellow exclamation mark or question mark, if not, it means the drive status is good. Otherwise, you can download a mobile assistant program to install the driver first.\n\nConfirm the status after connecting the computer and the device via the USB cable.\n\nIf you can see\n\n xxxxxx device\n\n The connection is successful.\n\nIn addition to connecting the device and the computer via USB to use adb, you can also use a wireless connection-although there are steps to use USB during the connection process, your device can get rid of the limitation of the USB cable within a certain range after the connection is successful. !\n\nSteps:\n\n Connect the Android device and the computer to run adb to the same local area network, for example to the same WiFi.\n\n Connect the device to the computer via a USB cable.\n\n Make sure that the connection is successful (you can run adb devices to see if the device can be listed).\n\n Let the device monitor TCP/IP connections on port 5555:\n\nDisconnect the USB connection.\n\n Find the IP address of the device.\n\n Generally, it can be found in \"Settings\"-\"About Phone\"-\"Status Information\"-\"IP Address\", or you can use the adb command to view it using the method in the section View Device Information-IP Address below.\n\nHere is the device IP address found in the previous step.\n\nIf you can see\n\nThe connection is successful.\n\n If you can't connect, please confirm that the Android device and the computer are connected to the same WiFi, and then execute the step of again;\n\n If it still does not work, restart adb via adb kill-server and try again from the beginning.\n\nWireless connection (no need to use USB cable)\n\nThe previous section \"Wireless connection (requires USB cable)\" is the method introduced in the official document, which requires the help of USB data cable to achieve wireless connection.\n\n Since we want to achieve wireless connection, can all steps be wireless? The answer is yes.\n\n Install a terminal emulator on the Android device.\n\n Devices that have already been installed can skip this step. The download address of the terminal emulator I use is: Terminal Emulator for Android Downloads\n\n Connect the Android device and the computer to run adb to the same local area network, for example to the same WiFi.\n\n Open the terminal emulator on the Android device and run the commands in sequence:\n\nFind the IP address of the Android device.\n\nGenerally, it can be found in \"Settings\"-\"About Phone\"-\"Status Information\"-\"IP Address\", or you can use the adb command to view it using the method in the section View Device Information-IP Address below.\n\nConnect the Android device via adb and IP address on the computer.\n\nHere is the device IP address found in the previous step.\n\nIf you can see the output connected to :5555, it means the connection is successful.\n\nSome devices, such as Xiaomi 5S + MIUI 8.0 + Android 6.0.1 MXB48T, may need to restart the adbd service before step 5, and run on the device's terminal emulator:\n\nIf restart does not work, try the following command:\n\nThe basic command format for viewing the application list is\n\nThat is, on the basis of adb shell pm list packages, you can add some parameters to filter and view different lists. The supported filter parameters are as follows:\n\nApplications whose package name contains a certain string\n\n For example, to view the list of applications whose package name contains the string mazhuang, command:\n\nOf course, you can also use grep to filter:\n\nAdb install can be followed by some optional parameters to control the behavior of installing APK. The available parameters and their meanings are as follows:\n\nAfter running the command, if you see output similar to the following (the status is Success), the installation is successful:\n\nThe above is the output of the latest version of adb of v1.0.36, which will show the progress percentage of pushing the apk file to the phone.\n\nUsing the old version of adb, the output is like this:\n\nAnd if the status is Failure, the installation failed, for example:\n\nCommon installation failure output codes, meanings and possible solutions are as follows:\n\nadb install is actually completed in three steps:\n• Delete the corresponding apk file under /data/local/tmp.\n\nTherefore, when necessary, you can also follow this step to manually perform the installation process step by step.\n\nrepresents the package name of the application, and the -k parameter is optional, meaning that the application is uninstalled but the data and cache directory are retained.\n\n Command example:\n\nrepresents the application name package. The effect of this command is equivalent to clicking \"Clear Cache\" and \"Clear Data\" on the application information interface in the settings.\n\nMeans to clear the data and cache of 360 Mobile Guard.\n\nAmong them, is the Activity currently in the foreground.\n\nThe parameter is not necessary. Specifying means viewing the Services related to a certain package name, and not specifying it means viewing all Services.\n\ndoes not have to give a complete package name. For example, if you run adb shell dumpsys activity services org.mazhuang, then the package name org.mazhuang.demo1, org.mazhuang.demo2, org.mazhuang123 and other related Services will be listed come out.\n\nThe output contains a lot of information, including Activity Resolver Table, Registered ContentProviders, package name, userId, path to file resource code after installation, version information, permission information and grant status, signature version information, etc.\n\nMainly use the command, the commonly used are as follows:\n\nThe parameters are very flexible, and correspond to the Intent in the code when writing Android programs.\n\nThe options used to determine the intent object are as follows:\n\ncan also carry data, just like Bundle when writing code:\n\nIndicates that the main interface of WeChat is activated.\n\nIt means to call up org.mazhuang.boottimemeasure/.MainActivity and pass it the string data key-value pair toast-hello, world.\n\nIndicates that a certain service of WeChat has been activated.\n\nIt can be broadcast to all components or only to specified components.\n\nFor example, to broadcast BOOT_COMPLETED to all components:\n\nFor another example, only broadcast BOOT_COMPLETED to org.mazhuang.boottimemeasure/.BootCompletedReceiver:\n\nThis type of usage is very practical when testing. For example, a broadcast scene is difficult to create. You can consider sending broadcasts in this way.\n\n It can send the pre-defined broadcast of the system and also send the self-defined broadcast. The following is part of the system predefined broadcast and normal trigger timing:\n\nMeans to stop all the processes and services of 360 Security Guard.\n\nRevoke the permissions of the application\n• Grant permissions to the app. Only optional permissions declared by the application can be granted\n\nOption --user user_id: the user to be disabled For example, grant permissions to the application. On devices running Android 6.0 (API level 23) and higher, the permission can be any permission declared in the application manifest. On devices running Android 5.1 (API level 22) and lower, it must be an optional permission defined by the application.\n\nCopy the files in the device to the computer\n\nAmong them, the directory parameter on the computer can be omitted, and the default is copied to the current directory.\n\n*Tips: *The file path on the device may require root privileges to access. If your device has been rooted, you can use the adb shell and su commands to obtain root privileges in the adb shell, then cp /path/on/device /sdcard/filename Copy the file to sdcard, then adb pull /sdcard/filename /path/on/pc.\n\n*Tips: *The file path on the device may not be directly written by ordinary permissions. If your device has been rooted, you can first adb push /path/on/pc /sdcard/filename, and then adb shell and su in adb shell After obtaining root permissions, cp /sdcard/filename /path/on/device.\n\nThere is a very useful command called input in adb shell, through which you can do some interesting things.\n\n The complete help information of the input command is as follows:\n\nFor example, to simulate a click: //Click the position of the coordinate point x=50 y=250 on the screen.\n\nFor example, using the adb shell input keyevent command, different keycodes can achieve different functions. For the complete keycode list, see KeyEvent. The excerpts are as follows:\n\nThe following are some usage examples of input command.\n\nThe effect is equivalent to pressing the power button.\n\nThe analog power button described above can be used to switch the screen on and off, but if you clearly want to turn on or off the screen, you can use the following method.\n\nIf the lock screen does not have a password and is unlocked by swiping gestures, you can unlock it by input swipe.\n\nCommand (parameters are based on model Nexus 5, for example, swipe up gesture to unlock):\n\nThe parameters 300 1000 300 500 respectively represent the start point x coordinate, the start point y coordinate, the end point x coordinate, and the end point y coordinate.\n\nWhen the focus is on a text box, you can use the input command to enter text.\n\nNow hello appears in the text box.\n\nThe Android system log is divided into two parts, the underlying Linux kernel log is output to /proc/kmsg, and the Android log is output to /dev/log.\n\nCommon usages are listed as follows:\n\nAndroid logs are divided into the following priority (priority):\n\n-V —— Verbose (lowest, most output)\n\n -D —— Debug I —— Info\n\n -W —— Warning\n\n -E —— Error\n\n -F—— Fatal\n\n -S —— Silent (the highest, nothing is output)\n\nFiltering logs by a certain level will output logs of that level and above.\n\nFor example, the command:\n\nWarning, Error, Fatal and Silent logs will be output.\n\ncan be composed of multiple .\n\nFor example, the command:\n\nIt means to output the log above Info of tag ActivityManager, output the log above Debug of tag MyApp, and the Silent log of other tags (that is, to block other tag logs).\n\nYou can use the option to specify the log output format.\n\nThe log supports the following types of :\n\nThe default format. The format is:\n\nThe specified format can be used simultaneously with the above filtering. such as:\n\nThe [14201.684016] in the brackets represents the time since the kernel started, in seconds.\n\nThrough the kernel log we can do some things, such as measuring the kernel startup time, find the time before the Freeing init memory line in the kernel log after the system is started.\n\nAmong them, scale represents the maximum power, and level represents the current power. The output above indicates that 44% of the battery is left.\n\nIf it is modified using the command, the output may be:\n\nIndicates that the screen resolution of the device was originally 1080px * 1920px, but is currently modified to 480px * 1024px.\n\nIf it is modified using the command, the output may be:\n\nPhysical density: 480\n\n Override density: 160\n\n Indicates that the screen density of the device was originally 480dpi, but is currently modified to 160dpi.\n\nAmong them, mDisplayId is the display number, init is the initial resolution and screen density. The height of the app is smaller than that in init, which means that there are virtual buttons at the bottom of the screen. The height is 1920-1794 = 126px and 42dp.\n\nIn Android 4.4 and below versions, IMEI can be obtained by the following command:\n\nIn Android 5.0 and above, the output of this command is empty, and it must be obtained by other means (root permission is required):\n\nExtracting the effective content inside is the IMEI, for example, here is 860955027785041.\n\nEvery time you want to know the IP address of the device, you have to \"Settings\"-\"About Phone\"-\"Status Information\"-\"IP Address\", which is annoying, right? It can be easily viewed through adb.\n\nThen 10.130.245.230 is the device IP address.\n\nThis command has no output on some devices. If the device is connected to WiFi, you can use the following command to view the local area network adb shell ifconfig wlan0 Example:\n\nIf the above command still does not get the expected information, you can try the following command (available in some system versions):\n\nYou can see information such as the network connection name, activation status, IP address, and Mac address.\n\nThis is the local area network Mac address, mobile network or other connection information can be viewed through the adb shell netcfg command mentioned in the previous section \"IP address\".\n\nThis is the CPU information of Nexus 5. We can see from the output that the hardware used is Qualcomm MSM 8974, and the processor number is 0 to 3, so it is quad-core and the architecture used is ARMv7 Processor rev 0 (v71).\n\nAmong them, MemTotal is the total memory of the device, and MemFree is the current free memory.\n\nMore hardware and system properties of the device can be viewed through the following commands:\n\nThis will output a lot of information, including the \"model\" and \"Android system version\" mentioned in the previous sections.\n\nThe output also includes some other useful information, which can also be viewed separately through the adb shell getprop command. Some properties are listed as follows:\n\nSome ROMs customized by small factories may have modified the attribute name of the abi list supported by the CPU. If you can’t find it with the ro.product.cpu.abilist attribute name, you can try:\n\n*Note: After modifying the settings, running the recovery command may still display abnormalities. You can run adb reboot to restart the device, or manually restart. *\n\nThe principle of modifying settings is mainly to modify the setting values ​​stored in /data/data/com.android.providers.settings/databases/settings.db through the settings command.\n\nMeans to modify the resolution to 480px * 1024px.\n\nMeans to modify the screen density to 160dpi.\n\nThe four numbers respectively indicate the margin pixels from the left, top, right, and bottom edges. The above command means to leave the bottom of the screen 200px blank.\n\nIt can't be restored with commands, after all, if USB debugging is turned off, adb cannot connect to the Android device.\n\nGo to the device to manually restore it: \"Settings\"-\"Developer Options\"-\"Android Debugging\".\n\nThe related settings mentioned in this section correspond to \"Extended Desktop\" in Cyanogenmod.\n\ncan be composed of the following keys and their corresponding values, in the format of .\n\nThe values ​​corresponding to these keys can be combined with commas as the following values:\n\nIndicates that the status bar and navigation bar are hidden at the same time in all interfaces.\n\nIt means setting to hide the status bar in applications with package names com.package1 and com.package2, and hide the navigation bar in all applications except package names com.package3.\n\nWhat if I don't want to be full screen?\n\nIf the adb version is older and the exec-out command cannot be used, it is recommended to update the adb version at this time. If you cannot update, you can use the following troublesome methods:\n\nFirst save the screenshot to the device:\n\nThen export the png file to the computer:\n\nYou can use adb shell screencap -h to view the help information of the screencap command. The following are two meaningful parameters and their meanings:\n\nActually, if the specified file name ends with .png, you can omit the -p parameter; otherwise, you need to use the -p parameter. If you do not specify the file name, the content of the screenshot file will be directly output to stdout.\n\nAnother way to take a screenshot of a one-line command and save it to the computer:\n\nThis method needs to use the gnu sed command, which is available directly under Linux, and under the bin folder of the Git installation directory under Windows. If you really cannot find the command, you can download sed for Windows and add the folder where sed.exe is located to the PATH environment variable.\n\nHowever, using the sed command that comes with the system under Mac will report an error:\n\nNeed to install gnu-sed, and then use the gsed command:\n\nThe recorded screen is saved to /sdcard in mp4 format:\n\nPress Ctrl-C when you need to stop, the default recording time and maximum recording time are both 180 seconds.\n\nIf you need to export to a computer:\n\nYou can use adb shell screenrecord --help to view the help information of the screenrecord command. The following are common parameters and their meanings:\n\nThe /system partition is mounted as read-only by default, but some operations such as adding commands to the Android system, deleting its own applications, etc. require writing to /system, so you need to remount it as read-write.\n\nEnter the shell and switch to root user authority.\n\nFind the line with /system that we are concerned about:\n\nHere /dev/block/platform/msm_sdcc.1/by-name/system is the file path we got from the output of the previous step.\n\nIf the output does not prompt an error, the operation is successful, and you can do whatever you want with the files under /system.\n\nssid is the name we see in the WLAN settings, psk is the password, and key_mgmt is the security encryption method.\n\nMeans to change the system date and time to 13:15:00 on August 23, 2016.\n\nCheck if the device is rooted\n\nAt this time, the command line prompt is $, which means that there is no root authority, and # means that it is rooted.\n\nMonkey can generate pseudo-random user events to simulate clicks, touches, gestures and other operations, and can perform random stress tests on programs under development.\n\nIt means to send 500 pseudo-random events to the application specified by .\n\nFor detailed usage of Monkey, refer to the official documentation.\n\nSometimes you need to control the WiFi status of the device, you can use the following commands to complete.\n\nSet wifi priority, use wifi first when there is network and wifi\n\nIf the execution is successful, the output will be empty; if the command is executed without root permission, the execution will fail and the output will be Killed.\n\nThis command can close the data connection, that is, the Internet traffic. Everyone knows that there are many switches to control the Internet, but most of them are realized by adding a suffix to the access point on the apn, but this command will not change any settings of the apn. The bottom layer closes the data connection. It should be the most thorough, and does not affect the apn settings. What is the difference between this and apndroid? When apndroid closes the Internet data, the downloading connection may not be forcibly closed (this is also mentioned in apndroid's own instructions). For example, if you are downloading a 10M movie, if you download 1M, the download will not sound. Use apndroid to close the connection, maybe the download will continue, not immediately. But with this command, it clicked away without mercy.\n\nThis is to open the Internet data connection, which is the opposite of the previous command.\n\nThis command is to control the data connection prior to wifi. We all know that under normal circumstances, when there is wifi, the data network connection will not be used. But this command is the opposite. If there is a data network, use data network traffic first, and use wifi when there is no data network.\n\nIf we download the system update package corresponding to the Android device to the computer, we can also complete the update through adb.\n\nTake the update in Recovery mode as an example:\n\nOperate on the Recovery interface of the device to enter Apply update-Apply from ADB.\n\n*Note: Different Recovery menus may be different from this. Some first-level menus have Apply update from ADB. *\n\n*Upload and update the system via adb. *\n\nThe Android system is based on the Linux kernel, so many commands in Linux have the same or similar implementations in Android and can be called in adb shell. The adb shell command has been used in the previous part of this document.\n\nThe top command also supports some command line parameters, the detailed usage is as follows:\n\nThere are two options:\n\nAfter finding the pid of the corresponding process through the ps command,\n\nThe following is a brief description of other commonly used commands. The commands that have been specifically mentioned above will not be explained separately:\n\nThe 5037 port that the adb server process wants to use is occupied.\n\nFind the process occupying port 5037, and then terminate it. Take Windows as an example:\n\nHere 1548 is the process ID, end the process with the command:\n\nThen start adb and there is no problem."
    },
    {
        "link": "https://xdaforums.com/t/app-no-root-adb-on-boot-run-adb-commands-at-boot-automatically.4368281",
        "document": "Are you able to use Tasker in the stick?\n\n I tried in my device and it won't even show a simple Toast and possible reason as I said is that Tasker have subscription checking thing in it and that requires Play services which are missing in Fire OS. So unless you have direct purchased version of Tasker or unless you install Play services in it, I don't see any good way of running Tasker in it.\n\nYes I have Tasker running on FireTV 4K without play service. You can download an apk with 7 day trial directly from the tasker website and it works without playstore. If it has issues with subscription or trial expired, it will tell so and refuse to execute some advanced features.I can run intents and stuff with tasker just fine, but as Fire TV has no Accessibility service installed, you can not use most of the nice features and plugins of Tasker. Issuing shell commands for example does not work. so I can not issue any keyinput with tasker. That's why I have to rely on your app.With your app however I was able to completely avoid tasker for now.I used Tasker to run an intent that opens a youtube link. Now I run this intent from your app. Also i can now issue keyinput with your app. With Tasker that was not possible due to missing accessibility service, which Tasker relies on.How is your app able to issue keyinput via shell, while tasker can not due to mssing accessibility services? Maybe you can make your app more advanced and allow it to be used as a proxy for issuing shell keyinput on devices without accessibility service. This is the one single reason why I wish i had root on this device. Just to have accessibility service back, which Amazon removed in the recent firmware versions.I use input to press home key, which makes Fire TV switch the HDMI input of the TV to itself. Now Whenever I start the tv, Fire TV automatically switches input to itself and starts playing youtube.What I now also want is to be able to use your app also after boot, as I need to switch input and issue keyinput after boot while running several times. Thats why I asked you to add an option to runn it also after boot.Because if I press \"test script\" keyinput also works with your app. But not with Tasker.Will it work, if I open your app with intent \"android.intent.action.MAIN\"? Will it execute the shell script like when at boot? if yes, then I will try to run this intent from Tasker.Also It would be good if it was possible to have multiple scripts that you can execute so that you are not stuck with one single script. For example allow to save script a, b, c etc, and then have an intent to be ebale to run a specific script a, b or c. etc..Your script is very helpful and solves a big problems that amazon has introduced by cutting accesisbility service. Without your app, fire tv would be so useless for me. Thanks for releasing it."
    }
]