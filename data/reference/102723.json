[
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/csharp/linq/how-to-extend-linq",
        "document": "All LINQ based methods follow one of two similar patterns. They take an enumerable sequence. They return either a different sequence, or a single value. The consistency of the shape enables you to extend LINQ by writing methods with a similar shape. In fact, the .NET libraries have gained new methods in many .NET releases since LINQ was first introduced. In this article, you see examples of extending LINQ by writing your own methods that follow the same pattern.\n\nYou extend the set of methods that you use for LINQ queries by adding extension methods to the IEnumerable<T> interface. For example, in addition to the standard average or maximum operations, you create a custom aggregate method to compute a single value from a sequence of values. You also create a method that works as a custom filter or a specific data transform for a sequence of values and returns a new sequence. Examples of such methods are Distinct, Skip, and Reverse.\n\nWhen you extend the IEnumerable<T> interface, you can apply your custom methods to any enumerable collection. For more information, see Extension Methods.\n\nAn aggregate method computes a single value from a set of values. LINQ provides several aggregate methods, including Average, Min, and Max. You can create your own aggregate method by adding an extension method to the IEnumerable<T> interface.\n\nThe following code example shows how to create an extension method called to compute a median for a sequence of numbers of type .\n\nYou call this extension method for any enumerable collection in the same way you call other aggregate methods from the IEnumerable<T> interface.\n\nThe following code example shows how to use the method for an array of type .\n\nYou can overload your aggregate method so that it accepts sequences of various types. The standard approach is to create an overload for each type. Another approach is to create an overload that takes a generic type and convert it to a specific type by using a delegate. You can also combine both approaches.\n\nYou can create a specific overload for each type that you want to support. The following code example shows an overload of the method for the type.\n\nYou can now call the overloads for both and types, as shown in the following code:\n\nYou can also create an overload that accepts a generic sequence of objects. This overload takes a delegate as a parameter and uses it to convert a sequence of objects of a generic type to a specific type.\n\nThe following code shows an overload of the method that takes the Func<T,TResult> delegate as a parameter. This delegate takes an object of generic type T and returns an object of type .\n\nYou can now call the method for a sequence of objects of any type. If the type doesn't have its own method overload, you have to pass a delegate parameter. In C#, you can use a lambda expression for this purpose. Also, in Visual Basic only, if you use the or clause instead of the method call, you can pass any value or expression that is in the scope this clause.\n\nThe following example code shows how to call the method for an array of integers and an array of strings. For strings, the median for the lengths of strings in the array is calculated. The example shows how to pass the Func<T,TResult> delegate parameter to the method for each case.\n\nYou can extend the IEnumerable<T> interface with a custom query method that returns a sequence of values. In this case, the method must return a collection of type IEnumerable<T>. Such methods can be used to apply filters or data transforms to a sequence of values.\n\nThe following example shows how to create an extension method named that returns every other element in a collection, starting from the first element.\n\nYou can call this extension method for any enumerable collection just as you would call other methods from the IEnumerable<T> interface, as shown in the following code:\n\nThe following example shows how to group elements into chunks that represent subsequences of contiguous keys. For example, assume that you're given the following sequence of key-value pairs:\n\nThe following groups are created in this order:\n• We, think, that\n\nThe solution is implemented as a thread-safe extension method that returns its results in a streaming manner. It produces its groups as it moves through the source sequence. Unlike the or operators, it can begin returning groups to the caller before reading the entire sequence. The following example shows both the extension method and the client code that uses it:\n\nIn the presented code of the class implementation, the loop in the method iterates through source sequence and creates a copy of each Chunk. On each pass, the iterator advances to the first element of the next \"Chunk\", represented by a object, in the source sequence. This loop corresponds to the outer foreach loop that executes the query. In that loop, the code does the following actions:\n• Get the key for the current Chunk and assign it to variable. The source iterator consumes the source sequence until it finds an element with a key that doesn't match.\n• Make a new Chunk (group) object, and store it in variable. It has one GroupItem, a copy of the current source element.\n• Return that Chunk. A Chunk is an , which is the return value of the method. The Chunk only has the first element in its source sequence. The remaining elements are returned only when the client code foreach's over this chunk. See for more info.\n• Check to see if:\n• The chunk has a copy of all its source elements, or\n• The iterator reached the end of the source sequence.\n• When the caller has enumerated all the chunk items, the method has copied all chunk items. If the loop didn't enumerate all elements in the chunk, do it now to avoid corrupting the iterator for clients that might be calling it on a separate thread.\n\nThe class is a contiguous group of one or more source elements that have the same key. A Chunk has a key and a list of ChunkItem objects, which are copies of the elements in the source sequence:\n\nEach (represented by class) has a reference to the next in the list. The list consists of its - which stores the contents of the first source element that belongs with this chunk, and its - which is an end of the list. The tail is repositioned each time a new is added. The tail of the linked list is set to in the method if the key of the next element doesn't match the current chunk's key, or there are no more elements in the source.\n\nThe method of the class adds one to the current group of items. It tries to advance the iterator on the source sequence. If the method returns the iteration is at the end, and is set to .\n\nThe method is called after the end of the last chunk was reached. It checks whether there are more elements in the source sequence. If there are, it returns if the enumerator for this chunk was exhausted. In this method, when the private field is checked for , if isLastSourceElement is , it signals to the outer iterator to continue iterating.\n\nThe inner foreach loop invokes the method of the class. This method stays one element ahead of the client requests. It adds the next element of the chunk only after the client requests the previous last element in the list."
    },
    {
        "link": "https://stackoverflow.com/questions/45140566/custom-extension-function-to-implement-in-in-c-sharp-linq-2-entities",
        "document": ".Contains(...) is supporten in Linq2Entities and is transformed to \"IN\" SQL-Expression.\n\nin form like there:\n\nHow can I write correspondend custom In(...) Extension-Function?"
    },
    {
        "link": "https://stackoverflow.com/questions/4867100/workarounds-for-using-custom-methods-extension-methods-in-linq-to-entities",
        "document": "I have defined a GenericRepository class which does the db interaction.\n\nAnd in my BLL classes, I can query the db like:\n\nBinaryAnd is an extension method which checks two int values bit by bit. e.g. => and both return true.\n\nHowever I cannot use this extension method in my LINQ queries. I get a runtime error as follows:\n\n LINQ to Entities does not recognize the method 'Boolean BinaryAnd(System.Object, System.Object)' method, and this method cannot be translated into a store expression.\n\nAlso tried changing it to a custom method but no luck. What are the workarounds?\n\nShould I get all the albums and then iterate them through a foreach loop and pick those which match the AccessLevels?"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.data.entity.queryableextensions?view=entity-framework-6.2.0",
        "document": ""
    },
    {
        "link": "https://linkedin.com/advice/1/how-do-you-design-custom-linq-extension",
        "document": "Designing a custom LINQ extension method that is reusable and maintainable requires following some general guidelines. Name the method using a verb or verb phrase that describes its functionality, such as FilterBy(), GroupBy(), or DistinctBy(). Utilize generic type parameters to make the method applicable to different types of data sources and elements, like <TSource>, <TKey>, or <TResult>. Employ the this keyword to mark the first parameter as the type you want to extend, for instance this IEnumerable<TSource> source, this IQueryable<TSource> source, or this IParallelEnumerable<TSource> source. Incorporate lambda expressions or delegates to pass the logic or criteria for your method, like Func<TSource, bool> predicate, Func<TSource, TKey> keySelector, or Func<TSource, TResult> selector. Take advantage of the yield return statement to return an iterator that lazily evaluates the elements of your method, avoiding unnecessary memory allocation or computation. Implement the method logic with extension methods from the System.Linq namespace or the System.Linq.Parallel namespace, such as Where(), Select(), GroupBy(), or AsParallel(). And use the DebuggerStepThrough attribute to prevent the debugger from stepping into your method, making it easier to debug your queries."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/core/testing/unit-testing-with-mstest",
        "document": "Unit testing C# with MSTest and .NET\n\nThis tutorial takes you through an interactive experience building a sample solution step-by-step to learn unit testing concepts. If you prefer to follow the tutorial using a pre-built solution, view or download the sample code before you begin. For download instructions, see Samples and Tutorials.\n\nThis article is about testing a .NET Core project. If you're testing an ASP.NET Core project, see Integration tests in ASP.NET Core.\n\nOpen a shell window. Create a directory called unit-testing-using-mstest to hold the solution. Inside this new directory, run to create a new solution file for the class library and the test project. Create a PrimeService directory. The following outline shows the directory and file structure thus far:\n\nMake PrimeService the current directory and run to create the source project. Rename Class1.cs to PrimeService.cs. Replace the code in the file with the following code to create a failing implementation of the class:\n\nChange the directory back to the unit-testing-using-mstest directory. Run to add the class library project to the solution:\n\nCreate the PrimeService.Tests directory. The following outline shows the directory structure:\n\nMake the PrimeService.Tests directory the current directory and create a new project using . The dotnet new command creates a test project that uses MSTest as the test library. The template configures the test runner in the PrimeServiceTests.csproj file:\n\nThe test project requires other packages to create and run unit tests. in the previous step added the necessary MSTest packages and tools for code coverage reporting.\n\nAdd the class library as another dependency to the project. Use the command:\n\nYou can see the entire file in the samples repository on GitHub.\n\nThe following outline shows the final solution layout:\n\nChange to the unit-testing-using-mstest directory, and run :\n\nWrite a failing test, make it pass, then repeat the process. Remove UnitTest1.cs from the PrimeService.Tests directory and create a new C# file named PrimeService_IsPrimeShould.cs with the following content:\n\nThe TestClass attribute denotes a class that contains unit tests. The TestMethod attribute indicates a method is a test method.\n\nSave this file and execute to build the tests and the class library and then run the tests. The MSTest test runner contains the program entry point to run your tests. starts the test runner using the unit test project you've created.\n\nYour test fails. You haven't created the implementation yet. Make this test pass by writing the simplest code in the class that works:\n\nIn the unit-testing-using-mstest directory, run again. The command runs a build for the project and then for the project. After building both projects, it runs this single test. It passes.\n\nNow that you've made one test pass, it's time to write more. There are a few other simple cases for prime numbers: 0, -1. You could add new tests with the TestMethod attribute, but that quickly becomes tedious. There are other MSTest attributes that enable you to write a suite of similar tests. A test method can execute the same code but have different input arguments. You can use the DataRow attribute to specify values for those inputs.\n\nInstead of creating new tests, apply these two attributes to create a single data driven test. The data driven test is a method that tests several values less than two, which is the lowest prime number. Add a new test method in PrimeService_IsPrimeShould.cs:\n\nRun , and two of these tests fail. To make all of the tests pass, change the clause at the beginning of the method in the PrimeService.cs file:\n\nContinue to iterate by adding more tests, more theories, and more code in the main library. You have the finished version of the tests and the complete implementation of the library.\n\nYou've built a small library and a set of unit tests for that library. You've structured the solution so that adding new packages and tests is part of the normal workflow. You've concentrated most of your time and effort on solving the goals of the application.\n• Use the MSTest framework in unit tests"
    },
    {
        "link": "https://learn.microsoft.com/en-us/visualstudio/test/walkthrough-creating-and-running-unit-tests-for-managed-code?view=vs-2022",
        "document": "This article steps you through creating, running, and customizing a series of unit tests using the Microsoft unit test framework for managed code and Visual Studio Test Explorer. You start with a C# project that is under development, create tests that exercise its code, run the tests, and examine the results. Then you change the project code and rerun the tests. If you would like a conceptual overview of these tasks before going through these steps, see Unit test basics. If you would like to generate tests automatically from existing code, see Create unit test method stubs from code.\n• None On the start window, choose Create a new project.\n• None Search for and select the C# Console App project template for .NET, and then click Next. If you do not see the Console App template, you can install it from the Create a new project window. In the Not finding what you're looking for? message, choose the Install more tools and features link. Then, in the Visual Studio Installer, choose the .NET desktop development workload.\n• None Name the project Bank, and then click Next. Choose either the recommended target framework or .NET 8, and then choose Create. The Bank project is created and displayed in Solution Explorer with the Program.cs file open in the code editor. If Program.cs is not open in the editor, double-click the file Program.cs in Solution Explorer to open it.\n• None Replace the contents of Program.cs with the following C# code that defines a class, BankAccount: using System; namespace BankAccountNS { /// <summary> /// Bank account demo class. /// </summary> public class BankAccount { private readonly string m_customerName; private double m_balance; private BankAccount() { } public BankAccount(string customerName, double balance) { m_customerName = customerName; m_balance = balance; } public string CustomerName { get { return m_customerName; } } public double Balance { get { return m_balance; } } public void Debit(double amount) { if (amount > m_balance) { throw new ArgumentOutOfRangeException(\"amount\"); } if (amount < 0) { throw new ArgumentOutOfRangeException(\"amount\"); } m_balance += amount; // intentionally incorrect code } public void Credit(double amount) { if (amount < 0) { throw new ArgumentOutOfRangeException(\"amount\"); } m_balance += amount; } public static void Main() { BankAccount ba = new BankAccount(\"Mr. Bryan Walton\", 11.99); ba.Credit(5.77); ba.Debit(11.22); Console.WriteLine(\"Current balance is ${0}\", ba.Balance); } } }\n• None Rename the file to BankAccount.cs by right-clicking and choosing Rename in Solution Explorer.\n• None On the Build menu, click Build Solution (or press Ctrl + SHIFT + B).\n\nYou now have a project with methods you can test. In this article, the tests focus on the method. The method is called when money is withdrawn from an account.\n• None On the File menu, select Add > New Project. You can also right-click on the solution in Solution Explorer and choose Add > New Project.\n• None Type test in the search box, select C# as the language, and then select the C# MSTest Test Project for .NET template, and then click Next. In Visual Studio 2019 version 16.9, the MSTest project template is Unit Test Project.\n• None Name the project BankTests and click Next.\n• None Choose either the recommended target framework or .NET 8, and then choose Create. Starting in Visual Studio 2022 version 17.10, you can also select a test runner. For the test runner, you can choose either VSTest or MSTest. For more information on the difference between test runners, see Microsoft.Testing.Platform and VSTest comparison. The BankTests project is added to the Bank solution.\n• None In the BankTests project, add a reference to the Bank project. In Solution Explorer, select Dependencies under the BankTests project and then choose Add Reference (or Add Project Reference) from the right-click menu.\n• None In the Reference Manager dialog box, expand Projects, select Solution, and then check the Bank item.\n\nCreate a test class to verify the class. You can use the UnitTest1.cs file that was generated by the project template, but give the file and class more descriptive names.\n• None To rename the file, in Solution Explorer, select the UnitTest1.cs file in the BankTests project. From the right-click menu, choose Rename (or press F2), and then rename the file to BankAccountTests.cs.\n• None To rename the class, position the cursor on in the code editor, right-click, and then choose Rename (or press F2). Type in BankAccountTests and then press Enter.\n\nThe BankAccountTests.cs file now contains the following code:\n\nAdd a statement to the test class to be able to call into the project under test without using fully qualified names. At the top of the class file, add:\n\nThe minimum requirements for a test class are:\n• None The attribute is required on any class that contains unit test methods that you want to run in Test Explorer.\n• None Each test method that you want Test Explorer to recognize must have the attribute.\n\nYou can have other classes in a unit test project that do not have the attribute, and you can have other methods in test classes that do not have the attribute. You can call these other classes and methods from your test methods.\n\nIn this procedure, you write unit test methods to verify the behavior of the method of the class.\n\nThere are at least three behaviors that need to be checked:\n• None The method throws an ArgumentOutOfRangeException if the debit amount is greater than the balance.\n• None The method throws an ArgumentOutOfRangeException if the debit amount is less than zero.\n• None If the debit amount is valid, the method subtracts the debit amount from the account balance.\n\nThe first test verifies that a valid amount (that is, one that is less than the account balance and greater than zero) withdraws the correct amount from the account. Add the following method to that class:\n\nThe method is straightforward: it sets up a new object with a beginning balance and then withdraws a valid amount. It uses the Assert.AreEqual method to verify that the ending balance is as expected. Methods such as , Assert.IsTrue, and others are frequently used in unit testing. For more conceptual information on writing a unit test, see Write your tests.\n\nA test method must meet the following requirements:\n• None It's decorated with the attribute.\n• None It cannot have parameters.\n• None On the Build menu, choose Build Solution (or press Ctrl + SHIFT + B).\n• None If Test Explorer is not open, open it by choosing Test > Test Explorer (or Test > Windows > Test Explorer) from the top menu bar (or press Ctrl + E, T).\n• None Choose Run All to run the test (or press Ctrl + R, V). While the test is running, the status bar at the top of the Test Explorer window is animated. At the end of the test run, the bar turns green if all the test methods pass, or red if any of the tests fail. In this case, the test fails.\n• None Select the method in Test Explorer to view the details at the bottom of the window.\n\nFix your code and rerun your tests\n\nThe test result contains a message that describes the failure. You might need to drill down to see this message. For the method, the message displays what was expected and what was actually received. You expected the balance to decrease, but instead it increased by the amount of the withdrawal.\n\nThe unit test has uncovered a bug: the amount of the withdrawal is added to the account balance when it should be subtracted.\n\nTo correct the error, in the BankAccount.cs file, replace the line:\n\nIn Test Explorer, choose Run All to rerun the test (or press Ctrl + R, V). The red/green bar turns green to indicate that the test passed.\n\nUse unit tests to improve your code\n\nThis section describes how an iterative process of analysis, unit test development, and refactoring can help you make your production code more robust and effective.\n\nYou've created a test method to confirm that a valid amount is correctly deducted in the method. Now, verify that the method throws an ArgumentOutOfRangeException if the debit amount is either:\n• greater than the balance, or\n• less than zero.\n\nCreate a test method to verify correct behavior when the debit amount is less than zero:\n\nUse the <xref:Microsoft.VisualStudio.TestTools.UnitTesting.Assert.ThrowsException%2A> method to assert that the correct exception has been thrown. This method causes the test to fail unless an ArgumentOutOfRangeException is thrown. If you temporarily modify the method under test to throw a more generic ApplicationException when the debit amount is less than zero, the test behaves correctly—that is, it fails.\n\nTo test the case when the amount withdrawn is greater than the balance, do the following steps:\n• None Copy the method body from to the new method.\n• None Set the to a number greater than the balance.\n\nRun the two tests and verify that they pass.\n\nThe method being tested can be improved further. With the current implementation, we have no way to know which condition ( or ) led to the exception being thrown during the test. We just know that an was thrown somewhere in the method. It would be better if we could tell which condition in caused the exception to be thrown ( or ) so we can be confident that our method is sanity-checking its arguments correctly.\n\nLook at the method being tested ( ) again, and notice that both conditional statements use an constructor that just takes name of the argument as a parameter:\n\nThere's a constructor you can use that reports far richer information: ArgumentOutOfRangeException(String, Object, String) includes the name of the argument, the argument value, and a user-defined message. You can refactor the method under test to use this constructor. Even better, you can use publicly available type members to specify the errors.\n\nFirst, define two constants for the error messages at class scope. Place the definitions in the class under test, :\n\nThen, modify the two conditional statements in the method:\n\nRefactor the test methods by removing the call to <xref:Microsoft.VisualStudio.TestTools.UnitTesting.Assert.ThrowsException%2A?displayProperty=nameWithType>. Wrap the call to in a block, catch the specific exception that's expected, and verify its associated message. The Microsoft.VisualStudio.TestTools.UnitTesting.StringAssert.Contains method provides the ability to compare two strings.\n\nNow, the might look like this:\n\nCurrently, the test method doesn't handle all the cases that it should. If the method under test, the method, failed to throw an ArgumentOutOfRangeException when the was larger than the balance (or less than zero), the test method would pass. This scenario isn't good because you want the test method to fail if no exception is thrown.\n\nThis outcome is a bug in the test method. To resolve the issue, add an Assert.Fail assert at the end of the test method to handle the case where no exception is thrown.\n\nRerunning the test shows that the test now fails if the correct exception is caught. The block catches the exception, but the method continues to execute and it fails at the new Assert.Fail assert. To resolve this problem, add a statement after the in the block. Rerunning the test confirms that you've fixed this problem. The final version of the looks like this:\n\nThe improvements to the test code led to more robust and informative test methods. But more importantly, they also improved the code under test.\n\nFor information about how to run tests from a command line, see VSTest.Console.exe command-line options."
    },
    {
        "link": "https://lambdatest.com/blog/most-complete-mstest-framework-tutorial-using-net-core-2",
        "document": "With the advent of programming languages like Python, Ruby on Rails, etc., there is thinking amongst the developer community that the C language is losing relevance. Strikingly, C is still considered a dominant programming language for system programming as it provides optimized machine instructions for any type of provided input. Not only C, the languages that are derived from C, i.e., C# and C++, are also embraced with arms wide open by the developer community. As far as unit testing/automation testing using C# is concerned, there are some frameworks like NUnit, xUnit.Net, MSTest Framework, etc., to save the day.\n\nSelenium is a widely popular test automation framework as it is compatible with C# and other popular programming languages. It is predominantly used for cross browser testing as it enables interactions with the web elements (present on a web-page) via Selenium WebDriver. It supports all popular web browsers: Firefox, Chrome, Safari, Internet Explorer, Microsoft Edge, etc.\n\nWe have covered What Is Selenium? and Selenium WebDriver architecture in more detail in our earlier blogs. You should definitely check them out in case you are relatively new to the Selenium framework. Test frameworks compatible with Selenium can be used to perform automated browser testing or cross browser testing of website/web applications.\n\nIn this Selenium C# tutorial, we have a look at the MSTest framework, which is the default test framework for testing .Net applications. We will also cover the aspects related to cross browser testing and parallel testing with MSTest.\n\nBelow are some of the sub-topics that are covered as a part of this MSTest tutorial:\n\nWhat is the MSTest framework?\n\nMSTest framework for Selenium automated testing is the default test framework that comes along with Visual Studio. In the earlier days, it started as a command-line tool for executing tests. It is also referred to as Visual Studio Unit Testing Framework; however, the name MSTest is more synonymous with the developers.\n\nThe MSTest framework provides the necessary tools to verify & validate your source code. The framework recognizes tests via the different attributes/annotations under which the test code is present. Some of the popular attributes are [TestInitialize], [TestMethod], [TestCleanup], etc. We will have a detailed look at each of these attributes in further sections of this MSTest tutorial.\n\nSince the MSTest framework comes pre-bundled with Visual Studio, developers who use the Visual Studio IDE for development & testing prefer the MSTest framework over other test frameworks like NUnit, xUnit.Net, etc. However, the choice & preference will also depend on the type & complexity of the project.\n\nFor development, we are making use of the Community Edition of Visual Studio 2019; the same can be downloaded from the official download site of Visual Studio. You also have the option to choose from the Professional or Enterprise edition, though the choice should solely depend upon your project requirements.\n\nThe necessary packages are selected for the installation since the packages occupy a good amount of disk space after installation.\n\nOnce the installation is complete, we have to install the required packages for executing the tests based on the MSTest framework.\n\nEvery test framework requires the corresponding Test Adapter to be installed, as the test adapter is an enabler for executing the test code. As this Selenium C# tutorial is focused on the MSTest framework, you have to install MSTest Adapter to run MSTests.\n\nIn order to install the required packages, perform the following steps:\n• Create a new project of the type ‘MSTest Test Project (.Net Core)’ in Visual Studio.\n• As it is a project based on the MSTest framework, the default C# file that comes along with the project has a couple of attributes, i.e., [TestMethod] and [TestClass].\n\nIn case you have not created an MSTest Test Project, you can still install the MSTest framework using the ‘NuGet Package Manager Console commands’ or using the NuGet GUI.\n\nAt the time of this blog, the latest version of the MSTest framework and MSTest Adapter was 2.2.1, respectively.\n\nYou can download and install the MSTest framework by either of the two methods, as shown below:\n\na. PM (Package Manager) commands from the ‘‘NuGet Package Manager Console” – For executing commands from the NuGet PM console, go to ‘Tools’ -> ‘NuGet Package Manager’ -> ‘Package Manager Console.’\n\nTo install the packages, we make use of the Install-Package command with the required as the argument to the command.\n\nThe installation screenshots are shown below:\n\nYou can confirm whether the packages are installed or not by executing the command Get-Package on the Package Manager Console. Shown below is the command execution output:\n\nb. NuGet Package Manager – To open the NuGet Package Manager, go to ‘Tools’ -> ‘NuGet Package Manager’ -> ‘Manage NuGet Packages for Solution.’\n\nIn the Browse section, search for the following packages and click Install:\n\nIn this MSTest tutorial, any reference to the MSTest framework refers to MSTest v2, i.e., version 2.2.1.\n\nTo know about the installation and setup of the MSTest framework in detail, you can refer to our blog: MSTest Tutorial On: Environment Setup For Selenium Testing.\n\nTake this certification to master the fundamentals of Selenium automation testing with C# and prove your credibility as a tester.\n\nHere’s a short glimpse of the Selenium C# 101 certification from LambdaTest:\n\nThe M2Test V2 framework was introduced a couple of years back with powerful features that are ideal for using the MSTest framework for cross browser testing. Some of the striking features of MSTest V2 are below:\n• Open-Source – MSTest V2 is open-source, and the project is hosted on GitHub. The public repositories of the MSTest V2 are Microsoft/testfx and Microsoft/testfx-docs. Since the project is open-source, it allows contributions from the community.\n• Cross-Platform support – V2 version of the MSTest framework is a cross-platform implementation of the framework using which developers can write tests targeting .NET Framework, .NET Core, and ASP.NET Core on platforms like Linux, Mac, and Windows. Begin your free ASP.NET testing.\n• Extensible – Like other test frameworks, the MSTest framework can now be extended with custom test attributes & custom asserts.\n• Data-driven testing -The framework allows the users to define their tests’ behavior by providing the facility to data drive the tests. By making the tests data-driven, one method can be executed multiple times by providing different input arguments.\n• Annotations – Similar to other test frameworks like NUnit that support annotations, the V2 version of MSTest framework allows customizing the execution of the test execution lifecycle via annotations e.g. [TestClass], [TestMethod], [TestInitialize], [TestCleanup], etc.\n• Parallel Test execution – Using MSTest V2, tests can be executed in parallel, reducing the test execution time. Parallel test execution can be achieved using In-Assembly Parallel (via Annotations or RunSettings).\n\nThe MSTest V2 portfolio comprises the framework, adapter, templates, etc.\n\nDue to the implementation of these features, MSTest V2 is preferred by developers who are performing automated browser testing using Selenium C#.\n\nWe highly recommend using the latest version of Visual Studio, i.e., VS 2019, but in case you are using an old version that comes with MSTest V1, you can migrate to MSTest V2 by following these simple steps:\n\nThis MSTest Tutorial for beginners and professionals will help you learn how to use MSTest framework with Selenium C# for performing Selenium automation testing.\n\nThe primary role of annotations in a test framework is to inform the underlying framework on how the source code should be interpreted. Once the code is compiled, a DLL (Dynamic Link Library) is generated, which can be executed using the console or a GUI.\n\nLike the NUnit framework annotations, the MSTest framework also adds annotations between brackets before the method is declared. For example, the basic setup for automated browser testing can be done using the [TestInitialize] annotation. The resources allocated during initialization can be freed using the method implemented under the [TestCleanup] annotation.\n\nIn this MSTest tutorial, we will cover the most frequently used MSTest framework annotations:\n\nThere are other annotations like [DynamicData], [DataSource], etc., but these are not much relevant in the context of cross browser testing or automated browser testing.\n\nTo demonstrate the usage of annotations in the MSTest Framework, we will create a simple test code with two test cases. The code under each Annotation only has a Console.WriteLine to trace the execution flow.\n\nShown below is the execution log:\n\nImplementation under [ClassInitialize] & [ClassCleanup] annotations are respectively called once before & after executing the methods in the class. Similarly, implementation under [TestInitialize] and [TestCleanup] annotations are respectively called once before & after executing each test of the class.\n\nDuring the process of web product development, you would have encountered situations where some functionalities do not work as expected on certain browsers (or browser versions) or devices or operating systems. Hence, it is necessary to test the product functionalities on different browsers, particularly on those browsers which your customers will use to access your website/web application.\n\n From a development standpoint, you have to ensure that changes for browser compatibility do not hamper the design aspects of the product, i.e., the UI and UX. MSTest can be used with the Selenium framework to perform cross browser testing and ensure that the behavior of the product is uniform across different browsers and devices, you can also read what is Selenium to understand better.\n\nCross browser testing can be performed by installing the Selenium WebDriver of the browser on which you want to do the testing. Selenium WebDriver for popular web browsers like Chrome, Firefox, Internet Explorer, Microsoft Edge, etc. can be downloaded from the locations mentioned below:\n\nIf the WebDriver executable is present in the location where the web browser executable is present, you need not specify the path when the WebDriver instance is created in the source code.To demonstrate the MSTest framework usage with local Selenium WebDriver, we will take the example of a simple To-Do app.\n\nThe test scenario for the Sample ToDo app will be:\n• Navigate to the to-do app https://lambdatest.github.io/sample-todo-app/ using the Firefox WebDriver.\n• Mark the first two items as Done, i.e., Check those two items.\n• Add a new item – Adding item to the list.\n• Click the Add button to add that new item to the list.\n\nCreate a new project of the type MSTest Test Project (.Net Core). The default test framework for this project is MSTest. Hence you need not perform the package installation for the MSTest framework again. As we will be using the Selenium framework, you have to install the Selenium WebDriver.\n\nTo install the Selenium WebDriver packages for Visual Studio, you have to execute the following commands on the Package Manager Console:\n\nIn case you require in-depth information about Selenium WebDrivers and web element locators, we recommend you to check out the Locators In Selenium WebDriver tutorial.\n\nTo make the code more modular, we have separated the task of creating Selenium WebDrivers for different web browsers in a separate file, i.e., WebDriverInfra.cs. All it has is the implementation for the creation of WebDriver instances of Chrome, Firefox, Edge, etc.\n\nThe code structure is as shown below:\n\nStep 1 – To start with, the entire Test Code is added under an [TestClass] annotation.\n\nStep 2 – The ‘LambdaTest ToDo app’ is executed against two web-browsers, i.e., Firefox and Chrome. Hence, the [DataRow] attribute is used to set the values of the parameters (Firefox and Chrome) of the test.\n\nStep 3 – The method, i.e., NavigateToDoApp, which contains the actual test implementation, is added under the [TestMethod] annotation.\n\nThe test method is iteratively called for each browser type, i.e., Chrome and Firefox, and once the browser instance is created, the required test operations are performed.\n\nThe first two items on https://lambdatest.github.io/sample-todo-app/ are checked and a new item with the text ‘Yey, Let’s add it to list’ is added to the list. The required web elements on the page are located using the Inspect Tool functionality of the respective browser.\n\nBelow is the execution snapshot on the Firefox browser and a screenshot from Test Explorer on Visual Studio.\n\nParallelism in the MSTest framework can be achieved by using the In-assembly Parallel feature of MSTest V2. Below are the two ways in which it can be implemented:\n\nParallelism is possible at the Class level or the Method level. The syntax is as shown below: In the above syntax:\n• Workers – Indicate the number of threads to run the tests. Set it to ‘0’ in case you do want serial execution.\n• Scope – Indicates if the runner should parallelize threads at the Method Level or Class Level. If the Scope is set to MethodLevel, all the tests are executed in parallel. If the Scope is set to ClassLevel, tests in the class are executed serially, whereas the test classes will be executed in parallel. If there are scenarios where there is inter-dependency between the tests, you should use parallel execution at ClassLevel. In case your project has multiple test assemblies which you want to parallelize, you can achieve parallelism by creating a file named .runsettings at the root of the solution.\n\nThe example demonstrated as a part of Local Testing can be converted to Parallel Test by simply adding the following line in src/Test/LocalMsTest.cs\n\nCross Browser Testing using MSTest Framework on the Cloud\n\nParallel testing on local infrastructure can hit a roadblock if you want to test your website/web application across ‘N’ different browsers, browser versions, operating systems, and devices. You obviously cannot invest endlessly in setting up the test infrastructure since it is neither scalable nor economical. Not performing thorough cross browser testing might result in a buggy experience if the customer accesses your product from an untested web browser. It reduces the overall test coverage as well.\n\nA feasible solution is to use a cloud based cross browser testing platform like the LambdaTest, where tests are executed on a Remote Selenium Grid. Using LambdaTest, cross browser tests can be executed on 3000+ different combinations of browsers, operating systems, and devices.\n\nPorting the existing implementation to remote Selenium Grid requires changes in the infrastructure-related code. Once you create an account on LambdaTest, you should make a note of the user-name & access-key from Profile Section as that combination is used for accessing the remote Selenium Grid on LambdaTest. The Automation Dashboard can be used to view all your text logs, screenshots, and video recording for your entire Selenium test.\n\nThe desired browser and platform capabilities are generated using LambdaTest capabilities Generator. For example, below are the capabilities for Safari on the macOS Mojave platform:\n\nFor demonstrating the usage of LambdaTest and the effectiveness of Parallel test execution on a Remote Selenium Grid, we will implement the below three test cases:\n• Mark the first two items as Done, i.e., Check those two items.\n• Add a new item – Adding item to the list.\n• Click the Add button to add that new item to the list.\n\nBrowsers on which cross-browser testing is performed are:\n\nBoth the test cases are the same, but the execution will be performed on different web browsers.\n\nStep 1 – OpenQA.Selenium.Remote package/namespace is imported as RemoteWebDriver class is defined in it.\n\nStep 2 – The LambdaTest credentials are passed for accessing the remote Selenium Grid. Refer to our documentation on LambdaTest Authentication Credentials to learn how to integrate LambdaTest in your test scripts.\n\nStep 3 – Browser & Device capabilities are generated using the LambdaTest capabilities generator, and the same is passed to the Remote WebDriver API.\n\nStep 4 – The current plan on LambdaTest defines how many tests can be executed in parallel on the Remote Selenium Grid. For demo purposes, we have used 5 Parallel tests. Therefore, we have set the scope of Parallelism to MethodLevel with Workers to 5, i.e., five threads/tests.\n\nStep 5 – The initialization code is implemented as a part of the [TestInitialize] attribute. It will be called only once during the initialization of the tests.\n\nStep 6 – As the browser capabilities on LambdaTest accept input parameters as browser-name, browser-version, platform-name, the combination is passed via [DataRow] attribute. These are passed as the input parameters to each test-case.\n\nEach test is executed iteratively till all the test combinations as a part of [DataRow] are exhausted. The remote web-driver is created as a part of the test-case as it uses these three parameters to create a browser instance on the target platform.\n\nThe rest of the implementation is specific to what needs to be achieved as a part of the test case, i.e., Operations on LambdaTest ToDo app or Google Search for ‘LambdaTest’ on specific browser/OS combinations.\n\nAs seen in the execution snapshot procured from Visual Studio, the test case is performed for 4 different browser/OS combinations, which were passed in the [DataRow] attribute.\n\nYou can visit https://automation.lambdatest.com/logs/?testID= &build= to check the execution status of the test. As seen in the screenshot from LambdaTest automation, three tests were executed in Parallel.\n\nBelow is the snapshot of successful test execution from Test Explorer on Visual Studio and Automation Tab (Test Status = Completed) on LambdaTest.\n\nIn this Selenium C# tutorial, we had a look at the MSTest framework – default test framework that comes along with Visual Studio. MSTest V2 can be used for cross browser testing as it supports parallelism, which is an important aspect when it comes to automated browser testing. The advantage of MSTest V2 is that it has cross-platform support and is highly extensible. Annotations/attributes simplify the division of the various sections involved in a test case, i.e., initialization, test case logic, de-initialization. The MSTest framework can also be used to define the behavior of the tests as it supports data-driven tests.\n\nWhen it comes to cross-browser testing, cloud-based testing can opt over local cross-browser testing. It is more scalable and helps you test the product thoroughly on different (browser + platform + device) combinations."
    },
    {
        "link": "https://linkedin.com/pulse/unit-testing-mstest-c-comprehensive-guide-examples-ghadi-%E0%A4%B8%E0%A4%9A-%E0%A4%A8-%E0%A4%98-%E0%A4%A1--bq2cf",
        "document": "Unit testing is a crucial practice in software development, helping developers ensure that individual units of code (like methods or classes) work as expected. In C#, one of the most popular frameworks for unit testing is MSTest. MSTest is the default testing framework for the .NET ecosystem and integrates seamlessly with Visual Studio, making it an excellent choice for developers working with Microsoft technologies.\n\nIn this article, we will explore unit testing with MSTest in C#, discussing how to set up MSTest, write unit tests, and execute them. We will also cover some advanced features of MSTest with examples.\n\nMSTest is a testing framework provided by Microsoft for .NET applications. It allows you to write unit tests, integration tests, and other types of automated tests. MSTest is built into Visual Studio, so it’s easy to get started, especially for developers working in the .NET ecosystem.\n\nSetting Up MSTest in C#\n• [TestClass]: This attribute marks the class that contains the unit tests.\n• [TestMethod]: This attribute is used to mark a method as a unit test method.\n• [TestInitialize]: This attribute is used to define a method that runs before each test method. It's commonly used for initializing objects that are shared by multiple test methods.\n• [ExpectedException]: This attribute is used to test that a specific exception is thrown during the test. In this case, we expect an ArgumentException when dividing by zero.\n• Assert.AreEqual(expected, actual): This method checks whether the actual result equals the expected value.\n• Open Test Explorer in Visual Studio by going to Test → Test Explorer.\n• Once the build is successful, all your tests will appear in the Test Explorer.\n• Click on Run All to execute all tests or select specific tests to run.\n\nExample 3: Using Mocking with MSTest (Moq)\n\nIn real-world applications, you might need to test code that interacts with external dependencies like databases or APIs. For this, you can use mocking. The Moq library is commonly used to mock interfaces and dependencies in C#.\n\nUnit testing with MSTest is a powerful way to ensure your C# code is working as expected. By using MSTest, you can write tests for your methods, verify behaviors, and catch bugs early. With features like test initialization, exception handling, asynchronous testing, and mocking, MSTest makes it easy to write comprehensive and maintainable unit tests."
    },
    {
        "link": "https://csharp.com/article/unit-testing-with-ms-tests-in-c-sharp",
        "document": "Many junior/fresher developers might be confused about who really should deal with Unit Testing. Unit test cases are written by developers.\n\nIt tests the behavior of a function/method by writing another piece of code.\n• Normally, software projects are intended to run for a long time, at least for a minimum of five years.\n• During this period, maintaining the application is very crucial.\n• Any change request received might impact the other functionality of the application.\n• So, before deploying the change in production, a lot of regression testing has to be done. This consumes a lot of tester’s time.\n\nImagine a situation where the change requests are happening very frequently. The efforts required for regression testing will be very high and the possibility of having defects will also be high.\n\nRegression Testing is the process of testing changes to computer programs, in order to make sure that the older programming still works with the new changes.\n• Unit Tests will certainly help in minimizing the Regression Testing.\n• Every method will be associated with Test Methods. Test Methods will test the purpose of the actual method.\n• Test Methods will check for the following scenarios.\n• A normal method might require more than one Test Method depending on the complexity of the Method.\n• Before code delivery, the developer has to ensure that all the test methods (in the entire solution) are getting passed.\n\nTDD is an evolutionary approach to development. It combines test-first development where you write a test before you write just enough production code to fulfill that test; and then, refactor the code to pass the test.\n\nWe have two frameworks to write Unit Test cases in C#.\n\nWe have a AAA pattern to write Unit Test cases.\n• Arrange all the necessary preconditions and inputs.\n• Act on the object or method under test.\n• Assert that the expected results have occurred.\n\nFollowing are the steps to create the unit test project.\n\nRight-click on the solution explorer click on Add and select Unit Test Project.\n\nI hope this will help you to get an idea about Unit Testing."
    }
]