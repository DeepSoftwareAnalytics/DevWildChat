[
    {
        "link": "https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Component.GetComponent.html",
        "document": "Suggest a change Thank you for helping us improve the quality of Unity Documentation. Although we cannot accept all submissions, we do read each suggested change from our users and will make updates where applicable. Close For some reason your suggested change could not be submitted. Please <a>try again</a> in a few minutes. And thank you for taking the time to help us improve the quality of Unity Documentation. Close\n\nThe typical usage for this method is to call it from a MonoBehaviour script (which itself is a type of component), to find references to other Components or MonoBehaviours attached to the same GameObject as that script. In this case you can call the method with no preceding object specified. For example:\n\n\n\n \n\n\n\nYou can also call this method on a reference to different component, which might be attached to a different GameObject. In this case, the GameObject to which that component is attached is searched. For example:\n\n\n\n \n\n\n\nNote: GetComponent returns only the first matching component found on the GameObject on which it is called, and the order that the components are checked is not defined. Therefore, if there are more than one of the specified type that could match, and you need to find a specific one, you should use Component.GetComponents and check the list of components returned to identify the one you want.\n\n\n\nTo find components attached to other GameObjects, you need a reference to that other GameObject (or any component attached to that GameObject). You can then call on that reference.\n\n\n\nSee the Component and GameObject class reference pages for the other variations of the family of methods.\n\n\n\nThe following example gets a reference to a hinge joint component on the same GameObject as the script, and if found, sets a property on that hinge joint component.\n\nNote: If the type you request is a derivative of MonoBehaviour and the associated script can't be loaded then this function will return `null` for that component.\n\nThis version of GetComponent is not as efficient as the Generic version (above), so you should only use it if necessary.\n\nThis version of GetComponent is not as efficient as the Generic version (above), so you should only use it if necessary."
    },
    {
        "link": "https://docs.unity3d.com/6000.0/Documentation/ScriptReference/GameObject.GetComponent.html",
        "document": "returns only the first matching component found on the GameObject, and components aren't checked in a defined order. If there are multiple components of the same type and you need to find a specific one, use GameObject.GetComponents and check the list of components returned to identify the one you want.\n\n\n\nNote: If the type you request is a derivative of MonoBehaviour and the script it's defined in can't be loaded, then this function returns `null` for that component. This might happen if you've named your class ambiguously. Refer to Naming scripts in the Manual for more information on naming considerations.\n\n\n\nThe typical usage for this method is to call it on a reference to a different GameObject than the one your script is on. For example:\n\n\n\n \n\n\n\nTo find components attached to other GameObjects, you need a reference to that other GameObject, or to any component attached to that GameObject. You can then call on that reference.\n\n\n\nYou can also use this method to get a reference to a component on the GameObject that this script is attached to, by calling this method inside a -derived class attached to the GameObject. You can omit the preceding qualifier to reference the GameObject the script is attached to. In this instance, you're actually calling Component.GetComponent because the script itself is a type of component, but the result is the same as if you'd referenced the GameObject itself. For example:\n\n\n\n \n\n\n\nThe following example gets a reference to a hinge joint component on the referenced GameObject, and if found, sets a property on it.\n\nThis version of isn't as efficient as the generic version. Use this version only if necessary.\n\n\n\n returns only the first matching component found on the GameObject, and components aren't checked in a defined order. If there are multiple components of the same type and you need to find a specific one, use GameObject.GetComponents and check the list of components returned to identify the one you want.\n\n\n\nNote: If the type you request is a derivative of MonoBehaviour and the script it's defined in can't be loaded, then this function returns `null` for that component. This might happen if you've named your class ambiguously. Refer to Naming scripts in the Manual for more information on naming considerations.\n\n\n\nThe typical usage for this method is to call it on a reference to a different GameObject than the one your script is on. For example:\n\n\n\n \n\n\n\nTo find components attached to other GameObjects, you need a reference to that other GameObject, or to any component attached to that GameObject. You can then call on that reference.\n\n\n\nYou can also use this method to get a reference to a component on the GameObject that this script is attached to, by calling this method inside a -derived class attached to the GameObject. You can omit the preceding qualifier to reference the GameObject the script is attached to. In this instance, you're actually calling Component.GetComponent because the script itself is a type of component, but the result is the same as if you'd referenced the GameObject itself. For example:\n\n\n\n \n\n\n\nThe following example gets a reference to a hinge joint component on the referenced GameObject, and if found, sets a property on it.\n\nThis version of isn't as efficient as the generic version. Use this version only if necessary.\n\n\n\n returns only the first matching component found on the GameObject, and components aren't checked in a defined order. If there are multiple components of the same type and you need to find a specific one, use GameObject.GetComponents and check the list of components returned to identify the one you want.\n\n\n\nNote: If the type you request is a derivative of MonoBehaviour and the script it's defined in can't be loaded then this function returns `null` for that component. This might happen if you've named your class ambiguously. Refer to Naming scripts in the Manual for more information on naming considerations.\n\n\n\nThe typical usage for this method is to call it on a reference to a different GameObject than the one your script is on. For example:\n\n\n\n \n\n\n\nTo find components attached to other GameObjects, you need a reference to that other GameObject, or to any component attached to that GameObject. You can then call on that reference.\n\n\n\nYou can also use this method to get a reference to a component on the GameObject that this script is attached to, by calling this method inside a -derived class attached to the GameObject. You can omit the preceding qualifier to reference the GameObject the script is attached to. In this instance, you're actually calling Component.GetComponent because the script itself is a type of component, but the result is the same as if you'd referenced the GameObject itself. For example:\n\n\n\n \n\n\n\nThe following example gets a reference to a hinge joint component on the referenced GameObject, and if found, sets a property on it."
    },
    {
        "link": "https://discussions.unity.com/t/getcomponent-script/393628",
        "document": ""
    },
    {
        "link": "https://discussions.unity.com/t/gameobject-getcomponent-valid-types/552204",
        "document": ""
    },
    {
        "link": "https://reddit.com/r/Unity3D/comments/o5g4be/whats_the_point_of_using_getcomponent_when_you",
        "document": "A subreddit for News, Help, Resources, and Conversation regarding Unity, the game engine. Do NOT use your phone to take screenshots. Video and photos of computer screens taken by phones are NOT allowed. All screenshots must be grabbed from the computer itself."
    },
    {
        "link": "https://discussions.unity.com/t/general-scripting-best-practices/509286",
        "document": ""
    },
    {
        "link": "https://reddit.com/r/Unity3D/comments/7jjhx8/im_struggling_to_understand_how_unitys_component",
        "document": "Hey guys. I've got an issue that I've been trying to wrap my head around and maybe you can help me better understand it.\n\nAs far as I know, Unity's got a component based approach when it comes to writing up your scripts - for example, creating a bunch of GameObject as public in a script and then manually drag/drop objects into the scripts as you load them up.\n\nFor something that is very small where I am testing gameplay features, this isn't a big deal. But as a project grows larger, this becomes a problem, especially when I start losing track of what other components are connected to my GameObject that makes it necessary for the script to function.\n\nSo not only will my script have dependencies to the GameObject, but within my script I would have additional dependencies to other components within the gameobject, but it may not be apparent when I drag/drop it into the script and when I find the error, I'll have to retrace, etc.\n\nI have a handful of scripts that I created that can be reused in other games, but I find I'd also have to document each and every one of them indicating which gameObjects can be attached to it, what each gameObject needs to have (rigidbody, collider, etc), etc. I've always been very used to just programming everything within a text editor and testing stuff from there, but with Unity I feel everything is \"drag and drop and hope you remember what goes where\".\n\nI did some programming in java and we were taught about loose coupling between classes in OOP but for some reason I feel like in Unity all of this is completely discarded.\n• Am I doing something wrong?\n• Is there a book or reference I can be referred to to \"best practices\" of design patterns in Unity? At the moment all I am using are tutorials and while doing several tutorials can be a good way of knowing a \"common\" way that everyone seems to be naming/structuring their scripts, is there a standardization to coding in Unity?\n• How is this coordinated with larger projects/bigger game studios? I can understand if for one developer who's progressing his game incrementally, but what if you have several developers working different scripts for one gameObject? How do they prevent conflict interaction?"
    },
    {
        "link": "https://medium.com/lonely-vertex-development/how-we-optimised-our-scripts-in-unity-447924863b3a",
        "document": "During the development of our game we ran into issues that caused an occasional lag during the gameplay. After some time spent with the Unity Profiler we found two types of issues:\n\nMost of the issues came from the second group, so I decided to focus this article on C# scripting (and maybe also because I have never written a single shader in my entire life). If you want to know more about best practices for writing your shaders just wait for an article that my colleague is about to write soon.\n\nThe point of this article is not to give a tutorial how to use the profiler, I just want to highlight what we focused on during the profiling.\n\nUnity Profiler is always the best way to go while trying to find the scripts causing your lag. I strongly recommend to profile the game directly on the device instead of profiling in the editor. So because our game is an iOS game I just had to connect the device and use the Build Settings shown in the picture below and the profiler was connected automatically\n\nIf you try to google “Random lag in Unity” or any other similar phrase you can find that most people recommend to focus on Garbage Collection, so I did exactly that. Garbage is generated anytime you stop using some object (instance of a class) then from time to time Unity’s Garbage collector is ran to clear the mess and deallocate the memory which takes insane amount of time causing frame rate to drop.\n\nHow to find the scripts causing garbage allocation in the profiler?\n\nYour goal should be to get to all zeros in the GC alloc column in your gameplay scene.\n\nAnother good point is to sort the records by “Time ms” (execution time) and optimise the scripts to take as little time as possible. This was a huge thing for us, because one of your components contains a large for-loop that took almost forever to execute (yeah we have not found a way to get rid of the loop, yet) so optimising the execution time for all the scripts was an absolute necessity for us, because we needed to save some execution time for this time-consuming for-loop while maintaining 60 fps.\n\nSo based on the profiling, I split the optimisation into two parts :\n• Getting rid of the garbage\n\nThis part focuses on what we did to get rid of all the garbage. These are the absolute basics that every developer should know and it also became an important part of our code review with every pull/merge request on daily basis.\n\n1st Rule: No New Objects in Update Methods\n\nIdeally you should have no “new” keywords used in the Update, FixedUpdate or LateUpdate methods. You should always try to use, what you already have.\n\nSometimes the new object creation is hidden in some Unity’s internal methods so it is not so obvious. We will discuss these later.\n\n2nd Rule: Create Once and Reuse, Reuse and Reuse!\n\nThis basically means to allocate everything you can in the Start and Awake methods. The rule is very similar to the 1st one. Actually it’s just an another way of removing “new” keywords from the Update methods.\n\nYou should always try to move all code that:\n\nout of the Update methods and move it to Start or Awake.\n\nHere are examples of changes that we did:\n\nAllocate Lists in the Start method, Clear them when needed and reuse wherever you want.\n\nStore references and reuse them like this:\n\nThe same applies to FindGameObjectsWithTag method or any other method that returns a new array.\n\nStrings are horrible when it comes to garbage allocations. Even basic string operations can generate a lot of garbage. Why is that? Strings are just arrays and these arrays are immutable. That means whenever you try to concatenate two strings together a new array is created and the old one becomes garbage. Thankfully you can use StringBuilder to avoid or minimise this garbage allocation.\n\nHere is an example how to improve this:\n\nThe example shown above is ok, but there is still a lot of space to improve the code. As you can see, almost entire string can be considered as static. So what we did is that we split the string into two parts, into two UI.Text objects. First one containing only the static text “Player “ + name + “ has score “ which can be assigned in the Start method and the second one containing the score value which is updated every frame. Always make static strings really static and generate them in Start or Awake method. With this improvement it is almost ok, but still some garbage is generated by calling Int.ToString(), Float.ToString() etc.\n\nWe solved this by generating and pre-allocating all possible strings. It might sound stupid and memory consuming, but it perfectly fits our needs and solve this issue completely. So we ended up with a static array that you can access directly using indices to get the required string representing the number :\n\nThis can be very tricky, because even a simple accessor like this one generates Garbage:\n\nTry to avoid using the accessors in the Update method. Call the Accessor only once in the Start method and cache the return value.\n\nIn general I recommend to NOT call any String accessors or Array accessors in the Update methods. In most of the cases You only need to get the reference once in the Start method.\n\nHere are two common examples of another unoptimised accessor code:\n\nFor certain Unity functions you can find their alternatives that don’t allocate anything. In our case these functions are all related to Physics. Our collision detection is based on\n\nFor this one specifically it is possible to find a function that does not allocate anything called\n\nMany other functions have alternatives like this one, so always check the documentation for NonAlloc functions.\n\nJust don’t. I mean don’t use it in any code that is executed often. I know the code is easier to read when using LINQ, but in many cases the performance and memory allocation of such code is horrible. Of course it is possible to use it sometimes, but I want to keep this simple and honestly in our game we don’t use LINQ at all.\n\n7th Rule: Create Once and Reuse, Reuse and Reuse vol 2.\n\nThis time it is about object pooling. I will not go into details of object pooling because it has been said many times, for example check this tutorial https://learn.unity.com/tutorial/object-pooling\n\nIn our case the scenario for object pooling is this one. We have a generated level that is full of obstacles that live only for a certain period of time, until a player passes this level section. These obstacles are instantiated from prefabs when certain conditions are met. The code is in the Update method. This code is absolutely inefficient considering both memory and execution time. We solved this be generating a pool of 40 obstacles and taking these obstacles from the pool when needed and returning the objects back to the pool after they are not needed anymore.\n\n8th Rule: Look out for Boxing!\n\nBoxing generates garbage! But what is boxing? The most common occurrence of boxing is when you pass a value type (int, float, bool etc) into a function that expects a parameter of type Object.\n\nHere is an example of boxing that we needed to solve in our project:\n\nWe implemented our own messaging system in the project. Every message can contain an unlimited amount of data. The data were stored in a dictionary that was defined like this\n\nAnd we had a setter to set values into this dictionary\n\nThe boxing here is pretty obvious. You can call the function like this\n\nSo the value “12” is boxed and that generates garbage.\n\nWe solved this by having separate data containers for each primitive type and the previous Object container is used only for reference types.\n\nand having separate setters for each data type\n\nAnd all these setters were implemented to call the same generic function\n\nAnd the boxing is gone!\n\nTo find more details check this article https://docs.microsoft.com/cs-cz/dotnet/csharp/programming-guide/types/boxing-and-unboxing\n\nThis is very similar the first and second rule. Just try to remove all unnecessary code from Loops for both performance and memory allocation reasons.\n\nWe try to avoid loops in Update methods in general, but when it is really need we at least avoid any allocation in such loops. So follow again all 1–8 rules and apply this for Loops in general and not just for Update methods.\n\nIn case you find out that some of the garbage is generated by a code that you downloaded from Asset store you have multiple options how to solve this, but before doing any reverse engineering and debugging just check the Asset store again and update the library. In our case, all assets we used were still maintained by authors and they keep doing performance updates, so this solved all our issues. Keep your dependencies up to date! I would rather get rid of the library instead of keeping an unmaintained one.\n\nPart 2: Pushing the Execution Time to Its Limits\n\nSome of the rules mentioned here make barely noticeable difference if the code is not called often. In our case we have a large Loop that is executed every frame so even these little changes made a significant difference for us.\n\nSome of these changes when used incorrectly or in an inappropriate situation might lead to even worse execution times. Always check the profiler after every single optimisation change in the code to be sure that it is going the desired direction.\n\nHonestly some of these rules lead to a code that is much harder to read and sometimes even breaks coding best practices, for example code inlining mentioned in the rules below.\n\nA lot of these rules overlap with the rules mentioned in the first part of this article. Usually garbage allocating code performs poorly compered to non allocating code. So I recommend to go through the first part of the article before reading this one.\n\nMove your code from FixedUpdate, Update, LateUpdate methods to Start and Awake methods. I know this sounds crazy but trust me, if you dig deep into your code, you can find hundreds of lines of code that can be moved to one of the methods that are executed only once.\n\nIn our case such code was usually related to:\n• Calculations that actually returns same result for every frame\n• Getting references to Transforms and using other accessors\n\nHere is a list of examples of code, that we moved from Update methods to Start methods:\n\n2nd Rule: Run the Code Only When It Is Needed\n\nIn our case this was mostly relevant for the scripts that update UI. Here is an example how we changed the implementation of a code that displays current state of “collectibles” in the level.\n\nBecause we only have few collectibles in each level, it does not make any sense to change the UI text every frame, so instead we change the text only when the actual number changes.\n\nThe code above is much better, especially if the code is more complex than just simple UI change.\n\nIf you are looking for a more complex solution I recommend to implement an Observer pattern (https://en.wikipedia.org/wiki/Observer_pattern) using C#’s Events (https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/events/)\n\nAnyway this was still not good enough for us and we wanted to implemented a completely generic solution so we created a library that implements Flux (https://facebook.github.io/flux/) into Unity. This leads to a very simple solution where you have all game state stored in a “Store” object and all UI elements and other components get notified when any state is changed and they react to this change with no code needed in Update method. If you are interested in this solution, my colleague will write an article about this soon, so subscribe or follow us and stay tuned :).\n\nThis is exactly the same rule as the one mentioned in the first part of this article. If you have any loop in the code iterating over large number of elements always apply all the rules mentioned above in both parts of this article to improve the performance of the loop.\n\nForeach loop is so easy to write but “so complex” to execute. Foreach loop internally uses Enumerators to iterate given set of data and to return the value. This is more more complex than just iterating indices in a simple For loop.\n\nSo in our project whenever it was possible we changed Foreach loops to For loops like this:\n\nIn our case of the large for loop, this change was really significant. The simple for loop resulted in a 2 times faster code.\n\nIn our code, we found out that most of the Lists either have fixed length or we can calculate the maximum number of items. So we reimplemented these using arrays which in some cases led to even 2x faster iteration of the data.\n\nIn some cases you can not avoid using Lists or any other complex data structures. The common situation is if you need to add or remove elements often, if this case it is better to use Lists. Anyway in general always use Arrays for fixed size lists.\n\nThis difference is barely noticeable unless you do thousands of operations like this, which was exactly our case, so this performance increase became significant for us.\n\nWe did changes like this:\n\nAlways consider if you really need to use GameObject.Find() method. This method is a beast and takes insane amount of time. You should never have such method in any of the Update methods. We found out that most of our Find calls could be replaced by direct reference association in the Editor, which is of course the better way to go.\n\nIn case you can not do it like this you should at least consider using Tags and finding the object by its Tag using GameObject.FindWithTag.\n\nIn our case this was significant for collision detection using RayCasts (CircleCasts etc) . Instead of detecting all collisions and making decision which ones are relevant in code, we moved our game objects to proper layers so we can calculate collisions only on relevant objects.\n\nHere is an example\n\nThere are no doubts that tags are very useful and can improve performance of your code, but keep in mind that there is only one correct way of comparing object tags!\n\nIt is so simple to use Camera.main, but the performance of such action is really bad. The reason is that behind each Camera.main call Unity actually does FindGameObjectsWithTag() to get the result, so we already know that it is not a good idea to call this frequently and the best way to solve this is to cache the reference in the Start or Awake method.\n\nUse Transform.LocalPosition everywhere you can instead of Transform.Position for both getters and setters. The reason is that there are much more operations executed behind each Transform.Position call, specifically calculating the global position in case of calling a getter or calculating local position from the global one in case of calling a setter. In our case we found out that we could use LocalPositions in 99 percents of occurrences of Transform.Position with no other changes needed to be done in the code.\n\nAlready discussed in the first part. Just don’t use it, that’s it.\n\n13th Rule: Don’t Be Afraid to Break Best Practices (sometimes)\n\nSometimes even a simple function call can be too expensive. In this case, you should always consider Code Inlining. What that means? Basically it means you just take the code from the function and copy the code directly to the place where you wanted to use the function to avoid any additional method calls.\n\nIn most of the cases this will not make any difference because the code inlining is done automatically at compile time, but there are certain rules by which the compiler decided whether the code will be inlined or not (for example Virtual methods are never inlined, for more details check https://docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity8.html). So just open profiler, run the game on the actual device and see if there is any space for improvement.\n\nIn our case, we found a few functions that we decided to inline for better performance, especially in the large for-loop that we have in the game.\n\nBy applying the rules mentioned in the article we easily managed to get a stable 60 fps in an iOS game even on an iPhone 5S. Some of these rules might be too specific for our use case, but I still think that most of them should be in your mind while coding or doing code reviews to avoid any problems in later stages. It is always easier to continuously write code with performance aspects in mind than refactoring large chunks of the code later."
    },
    {
        "link": "https://discussions.unity.com/t/best-way-to-handle-ui-elements-scripts-components-elements/602762",
        "document": ""
    },
    {
        "link": "https://docs.unity3d.com/6000.0/Documentation/Manual/creating-scripts.html",
        "document": "Scripts allow you to customize and extend the capabilities of your applicaton with C# code. With scripts that derive from Unity’s built-in MonoBehaviour class you can create your own custom Components to control the behavior of GameObjectsThe fundamental object in Unity scenes, which can represent characters, props, scenery, cameras, waypoints, and more. A GameObject’s functionality is defined by the Components attached to it. More info\n\nSee in Glossary. With scripts that derive from ScriptableObject you can store large amounts of data efficiently in your application. Alternatively, you can start with an empty C# script to develop your own non-Unity classes.\n\nUnlike most other assets, scripts are usually created within Unity directly. To create a new script:\n• From the main menu: go to Assets > Create > Scripting and select the type of script you want to create.\n• From the Create menu (plus sign) in the Project window toolbar: go to Scripting and select the type of script you want to create.\n\nThis creates a new script in whichever folder you have selected in the Project panel. It also selects the script’s file name for editing, prompting you to change the name. For things you should take into account when naming your scripts, refer to Naming considerations for scripts."
    }
]