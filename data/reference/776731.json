[
    {
        "link": "https://realpython.com/fibonacci-sequence-python",
        "document": "The Fibonacci sequence is a pretty famous sequence of integer numbers. The sequence comes up naturally in many problems and has a nice recursive definition. Learning how to generate it is an essential step in the pragmatic programmer’s journey toward mastering recursion. In this tutorial, you’ll focus on learning what the Fibonacci sequence is and how to generate it using Python.\n\nIn this tutorial, you’ll learn how to:\n• Generate the Fibonacci sequence using an iterative algorithm\n\nTo get the most out of this tutorial, you should know the basics of Big O notation, object-oriented programming, Python’s special methods, conditional statements, functions, and basic data structures like lists, queues, and stacks. Having some familiarity with these concepts will greatly help you understand the new ones you’ll be exploring in this tutorial.\n\nGetting Started With the Fibonacci Sequence Leonardo Fibonacci was an Italian mathematician who was able to quickly produce an answer to this question asked by Emperor Frederick II of Swabia: “How many pairs of rabbits are obtained in a year, excluding cases of death, supposing that each couple gives birth to another couple every month and that the youngest couples are able to reproduce already at the second month of life?” The answer was the following sequence: The pattern begins after the first two numbers, 0 and 1, where each number in the sequence is always the sum of the two numbers before it. Indian mathematicians had known about this sequence since the sixth century, and Fibonacci leveraged it to calculate the growth of rabbit populations. F(n) is used to indicate the number of pairs of rabbits present in month n, so the sequence can be expressed like this: In mathematical terminology, you’d call this a recurrence relation, meaning that each term of the sequence (beyond 0 and 1) is a function of the preceding terms. There’s also a version of the sequence where the first two numbers are both 1, like so: In this alternative version, F(0) is still implicitly 0, but you start from F(1) and F(2) instead. The algorithm remains the same because you’re always summing the previous two numbers to get the next number in the sequence. For the purposes of this tutorial, you’ll use the version of the sequence that starts with 0.\n\nExamining the Recursion Behind the Fibonacci Sequence Generating the Fibonacci sequence is a classic recursive problem. Recursion is when a function refers to itself to break down the problem it’s trying to solve. In every function call, the problem becomes smaller until it reaches a base case, after which it will then return the result to each intermediate caller until it returns the final result back to the original caller. If you wanted to calculate the F(5) Fibonacci number, you’d need to calculate its predecessors, F(4) and F(3), first. And in order to calculate F(4) and F(3), you would need to calculate their predecessors. The breakdown of F(5) into smaller subproblems would look like this: Each time the Fibonacci function is called, it gets broken down into two smaller subproblems because that’s how you defined the recurrence relation. When it reaches the base case of either F(0) or F(1), it can finally return a result back to its caller. In order to calculate the fifth number in the Fibonacci sequence, you solve smaller but identical problems until you reach the base cases, where you can start returning a result: The colored subproblems on this diagram represent repetitive solutions to the same problem. If you go further up the tree, you’ll find more of these repetitive solutions. This means that to generate a Fibonacci sequence recursively, you have to calculate many intermediate numbers over and over. This is one of the fundamental issues in the recursive approach to the Fibonacci sequence.\n\nThe most common and minimal algorithm to generate the Fibonacci sequence requires you to code a recursive function that calls itself as many times as needed until it computes the desired Fibonacci number: Inside , you first check the base case. You then return the sum of the values that results from calling the function with the two preceding values of . The list comprehension at the end of the example generates a Fibonacci sequence with the first fifteen numbers. This function quickly falls into the repetition issue you saw in the above section. The computation gets more and more expensive as gets bigger. The required time grows exponentially because the function calculates many identical subproblems over and over again. Note: Do not try this function at home with a number greater than 50. Depending on your hardware, you might be waiting for a long time before seeing the result—if you make it to the end. To calculate F(5), has to call itself fifteen times. To calculate F(n), the maximum depth of the call tree is n, and since each function call produces two additional function calls, the time complexity of this recursive function is O(2n). Most of those calls are redundant because you’ve already calculated their results. F(3) appears twice, and F(2) appears three times. F(1) and F(0) are base cases, so it’s fine to call them multiple times. You may want to avoid this wasteful repetition, which is the topic of the following sections.\n\nOptimizing the Recursive Algorithm for the Fibonacci Sequence There are at least two techniques you can use to make the algorithm to generate the Fibonacci sequence more efficient—in other words, to make it take less time to compute. These techniques ensure that you don’t keep computing the same values over and over again, which is what made the original algorithm so inefficient. They’re called memoization and iteration. As you saw in the code above, the Fibonacci function calls itself several times with the same input. Instead of a new call every time, you can store the results of previous calls in something like a memory cache. You can use a Python list to store the results of previous computations. This technique is called memoization. Memoization speeds up the execution of expensive recursive functions by storing previously calculated results in a cache. This way, when the same input occurs again, the function just has to look up the corresponding result and return it without having to run the computation again. You can refer to these results as cached or memoized: With memoization, you just have to traverse up the call tree of depth n once after returning from the base case, as you retrieve all the previously calculated values highlighted in yellow, F(2) and F(3), from the cache earlier. The orange path shows that no input to the Fibonacci function is called more than once. This significantly reduces the time complexity of the algorithm from exponential O(2n) to linear O(n). Even for the base cases, you can replace calling F(0) and F(1) with just retrieving the values directly from the cache at indices 0 and 1, so you end up calling the function just six times instead of fifteen! Here’s a possible translation of this optimization into Python code: In this example, you use a Python dictionary to cache the computed Fibonacci numbers. Initially, contains the starting values of the Fibonacci sequence, 0 and 1. Inside the function, you first check if the Fibonacci number for the current input value of is already in . If so, then you return the number at hand. If there is no Fibonacci number for the current value of , then you compute it by calling recursively and updating . The final step is to return the requested Fibonacci number. What if you don’t even have to call the recursive Fibonacci function at all? You can actually use an iterative algorithm to compute the number at position in the Fibonacci sequence. You know that the first two numbers in the sequence are 0 and 1 and that each subsequent number in the sequence is the sum of its previous two predecessors. So, you can just create a loop that adds the previous two numbers, and , together to find the number at position in the sequence. The bolded purple numbers in the diagram below represent the new numbers that need to be calculated and added to in each iterative step: To calculate the Fibonacci number at position , you store the first two numbers of the sequence, 0 and 1, in . Then, calculate the next numbers consecutively until you can return .\n\nNow that you know the basics of how to generate the Fibonacci sequence, it’s time to go deeper and further explore the different ways to implement the underlying algorithm in Python. In the following sections, you’ll explore how to implement different algorithms to generate the Fibonacci sequence using recursion, Python object-oriented programming, and also iteration. Your first approach to generating the Fibonacci sequence will use a Python class and recursion. An advantage of using the class over the memoized recursive function you saw before is that a class keeps state and behavior (encapsulation) together within the same object. In the function example, however, is a completely separate object, so you don’t have control over it. Below is the code that implements your class-based solution: # Validate the value of n Here’s a breakdown of what’s happening in the code:\n• Line 4 defines the class initializer, . It’s a special method that you can use to initialize your class instances. Special methods are sometimes referred to as dunder methods, short for double underscore methods.\n• Line 5 creates the instance attribute, which means that whenever you create a object, there will be a cache for it. This attribute initially contains the first numbers in the Fibonacci sequence.\n• Line 7 defines another special method, . This method turns the instances of into callable objects.\n• Lines 9 and 10 validate the value of by using a conditional statement. If is not a positive integer number, then the method raises a .\n• Line 13 defines a conditional statement to check for those Fibonacci numbers that were already calculated and are available in . If the number at index is already in , then line 14 returns it. Otherwise, line 17 computes the number, and line 18 appends it to so you don’t have to compute it again. To try this code, go ahead and save it into . Then run this code in your interactive shell: Here, you create and then call an instance of the class named . The first call uses as an argument and returns , which is the sixth Fibonacci number because you’re using zero-based indices. This implementation of the Fibonacci sequence algorithm is quite efficient. Once you have an instance of the class, the attribute holds the already computed numbers from call to call. You can effectively understand how each call to a recursive Fibonacci function is handled using a call stack representation. The way each call is pushed onto the stack and popped off reflects exactly how the program runs. It clearly demonstrates how calculating large numbers will take a long time if you don’t optimize the algorithm. In a call stack, whenever a function returns a result, a stack frame representing the function call is popped off the stack. Whenever you call a function, you add a new stack frame to the top of the stack. In general, this operation has a space complexity of O(n) because there are no more than n stack frames on the call stack at a single time. Note: There’s a beginner-friendly code editor called Thonny that allows you to visualize the call stack of a recursive function in a graphical way. You can check out Thonny: The Beginner-Friendly Python Editor to learn more. To visualize the memoized recursive Fibonacci algorithm, you’ll use a set of diagrams representing the call stack. The step number is indicated by the blue label below each call stack. Say you want to compute F(5). To do this, you push the first call to the function onto the call stack: To compute F(5), you must compute F(4) as outlined by the Fibonacci recurrence relation, so you add that new function call to the stack: To compute F(4), you must compute F(3), so you add another function call to the stack: To compute F(3), you must compute F(2), so you add yet another function call to the call stack: To compute F(2), you must compute F(1), so you add that to the stack. As F(1) is a base case, it returns immediately with 1, and you remove this call from the stack: Now you start to unwind the results recursively. F(1) returns the result back to its calling function, F(2). To compute F(2), you also need to compute F(0): You add F(0) to the stack. Since F(0) is a base case, it returns immediately, giving you 0. Now you can remove it from the call stack: This result of calling F(0) is returned to F(2). Now you have what you need to compute F(2) and remove it from the stack: The result of F(2) is returned to its caller, F(3). F(3) also needs the results of F(1) to complete its calculation, so you add it back to the stack: F(1) is a base case and its value is available in the cache, so you can return the result immediately and remove F(1) from the stack: You can complete the calculation for F(3), which is 2: You remove F(3) from the stack after completing its calculation and return the result to its caller, F(4). F(4) also needs the result of F(2) to compute its value: You push the call to F(2) onto the stack. This is where the nifty cache comes in. You have calculated it before, so you can just retrieve the value from the cache, avoiding a recursive call to compute the result of F(2) again. The cache returns 1, and you remove F(2) from the stack: F(2) is returned to its caller, and now F(4) has all it needs to compute its value, which is 3: Next, you remove F(4) from the stack and return its result to the final and original caller, F(5): F(5) now has the result of F(4) and also the result of F(3). You push an F(3) call onto the stack, and the nifty cache comes into play again. You previously calculated F(3), so all you need to do is retrieve it from the cache. There’s no recursive process to compute F(3). It returns 2, and you remove F(3) from the stack: Now F(5) has all the values it needs to calculate its own value. You get 5 by adding 3 and 2, and that’s the final step before you pop the F(5) call off the stack. This action ends your sequence of recursive function calls: The call stack is empty now. You’ve completed the final step to compute F(5): Representing recursive function calls using a call stack diagram helps you understand all the work that takes place behind the scenes. It also allows you to see how many resources a recursive function can take up. Putting all these diagrams together allows you to visualize how the whole process looks: You can click the image above to zoom in on individual steps. If you don’t cache previously computed Fibonacci numbers, some of the stack stages in this diagram would be way taller, which means that they would take longer to return a result to their respective callers. The example in the previous sections implements a recursive solution that uses memoization as an optimization strategy. In this section, you’ll code a function that uses iteration. The code below implements an iterative version of your Fibonacci sequence algorithm: # Validate the value of n # Compute the next Fibonacci number, remember the previous one Now, instead of using recursion in , you’re using iteration. This implementation of the Fibonacci sequence algorithm runs in O(n) linear time. Here’s a breakdown of the code:\n• Line 3 defines , which takes a positive integer, , as an argument.\n• Lines 5 and 6 perform the usual validation of .\n• Lines 9 and 10 handle the base cases where is either 0 or 1.\n• Line 12 defines two local variables, and , and initializes them with the first two numbers in the Fibonacci sequence.\n• Line 13 starts a loop that iterates from to . The loop uses an underscore ( ) for the loop variable because it’s a throwaway variable and you won’t be using this value in the code.\n• Line 15 computes the next Fibonacci number in the sequence and remembers the previous one. To give this code a try, get back to your interactive session and run the following code: This implementation of is quite minimal. It uses iterable unpacking to compute the Fibonacci numbers during the loops, which is quite efficient memory-wise. However, every time you call the function with a different value of , it has to recompute the sequence over again. To fix this, you can use closures and make your function remember the already computed values between calls. Go ahead and give it a try!"
    },
    {
        "link": "https://stackoverflow.com/questions/18172257/efficient-calculation-of-fibonacci-series",
        "document": "Is there any way to make this faster? Or is it okay even this way...\n\nThe problem's solution can be easily found by printing sum(list2). However, it is taking a lot of time to come up with the list2 I'm guessing.\n\nI'm working on Project Euler problem 2 : the one about the sum of the even Fibonacci numbers up to four million.\n\nYes. The primitive recursive solution takes a lot of time. The reason for this is that for each number calculated, it needs to calculate all the previous numbers more than once. Take a look at the following image. It represents calculating with your function. As you can see, it computes the value of three times, and the value of five times. That just gets worse and worse the higher the number you want to compute. What makes it even worse is that with each fibonacci number you calculate in your list, you don't use the previous numbers you have knowledge of to speed up the computation – you compute each number \"from scratch.\" There are a few options to make this faster: 1. Create a list \"from the bottom up\" The easiest way is to just create a list of fibonacci numbers up to the number you want. If you do that, you build \"from the bottom up\" or so to speak, and you can reuse previous numbers to create the next one. If you have a list of the fibonacci numbers , you can use the last two numbers in that list to create the next number. This approach would look something like this: Then you can get the first 20 fibonacci numbers by doing Or you can get the 17th fibonacci number from a list of the first 40 by doing Another alternative to make it faster exists, but it is a little more complicated as well. Since your problem is that you re-compute values you have already computed, you can instead choose to save the values you have already computed in a dict, and try to get them from that before you recompute them. This is called memoization. It may look something like this: >>> def fib(n, computed = {0: 0, 1: 1}): ... if n not in computed: ... computed[n] = fib(n-1, computed) + fib(n-2, computed) ... return computed[n] This allows you to compute big fibonacci numbers in a breeze: This is in fact such a common technique that Python 3 includes a decorator to do this for you. I present to you, automatic memoization! This does pretty much the same thing as the previous function, but with all the stuff handled by the decorator. A third method, as suggested by Mitch, is to just count up without saving the intermediary values in a list. You could imagine doing I don't recommend these last two methods if your goal is to create a list of fibonacci numbers. is going to be a lot faster than because with the latter, you still get the problem of computing each number in the list from scratch.\n\nI realize this question was asked 8 years ago and it's been thoroughly answered… sorry to bounce it back up to the top. But there is always more to be said. I came across this in a search to improve my own algorithm, which I'd like to share. I'd like to offer my own take since I see this wasn't really brought up. I think my algorithm is unique amongst the contributors thus far. I make use of well known Fibonacci number equations (wikipedia) in order to scale down the index. One or two others briefly cover a basic version, but I take it a step further. This is a recursive algorithm, but I'm able to calculate Fib(2 million) in 0.15 seconds, Fib(10 million) in under 2 seconds, and Fib(100 million) in 75 seconds. All without error. I will say this, it isn't the fastest for calculating a whole list of consecutive Fibonacci numbers; this is best for picking out individuals that are very large. Most algorithms mentioned so far - no matter how fast they may be - struggle to get above Fib(100) without recursion depth issues. A couple of contributors have eluded to parts of my algorithm, though they have some disadvantages that mine doesn't. Not saying mines the best or anything, but I think it's quite fast and can calculate really large fibs. I think it's worth adding to the discussion. Best of all, I don't make any use of memory. No lists, dictionaries or arrays of any kind. No caches or memoization. Not even a single persistent saved constant. No special packages imported. Just basic, plain, python with basic integer types. Ive also extended the function to compute negative fibs with negligible impact to run time. I should warn though… I'm a mathematician, not a programmer. I have no doubts this can be improved further. And I have no idea what the Big O is. def fib(n): if n<0: return int(pow(-1, (n&1)+1))*fib(-n) if n == 0: return 0 if n==1 or n==2: return 1 if n==3: return 2 # n is multiple of 3 if n%3 == 0: third = n//3 fibthird = fib(third) return 5*pow(fibthird,3) + 3*pow(-1, third)*fibthird # even n if n&1==0: return pow(fib((n>>1) + 1),2) - pow(fib((n>>1) - 1), 2) # for odd n return ( pow(fib((n>>1)+1),2) + pow(fib(n>>1),2) ) Run the code, tell me what you think. I'd love to hear from the community. I'm impressed by it, personally, and have been running it for a while. Can't find a way in my limited (programming) knowledge to improve it though. Trying to add lists, memoization, caches, etc., either fails to improve anything, or makes runtime worse. In the rare instance I find something that improves runtime, the benefits to runtime are negligible and the costs to memory are significant, and I don't think it's a fair trade. For added fun, I include a basic probabilistic is_prime test below that relates to Fibonacci numbers: def is_prime_fib(n): # Fibonacci Probabilistic is_prime test. Compositeness deterministic. if n==1: return False if n==5: return True if n%5 in [1,4] and fib(n-1) % n == 0: return True if n%5 in [2,3] and fib(n+1) % n == 0: return True return False I include this just for fun even though its off topic. Its a well-known primality test using fibonacci numbers, but unfortunately it goes unused precisely because most fibonacci calculating algorithms are slow, cause recursion error, or otherwise produce inaccuracies, thus making the test unreliable and we naturally resort to other algorithms. I think the game can be changed a bit though. On its own, the Fibonacci primality test is probabilistic. The n=1 and n=5 cases are oddities that fail to produce correct results, but they are too obvious to worry about. Aside from that, a False is deterministic in compositeness, a True is probabilistic in primeness. A composite that passes as true by this test is a Fibonacci Pseudoprime. In conjunction with other probabilistic tests, we can achieve emergent determinism.\n\nHere's an answer with fully runnable code and benchmark, that provides a objectively the most efficient (so far) way to calculate . The algorithms can be implemented in whichever language. Benchmark results below, after summary of methods\n• Binet formula (spoiler: it looks like O(1) but it's very slow)\n• Code to calculate Fibonacci using GMP (a big math library) that is well tested, to check correctness of my code It can be downloaded here (can only be run on Linux, oops): https://github.com/lehuyduc/fast-fibonacci/tree/main Summary of methods and their time complexity: Space complexity of 3 best methods are . In fact, for , total memory usage for calculating is guaranteed to be <= bytes for those methods Binet's formula has time complexity , while other methods have are , so a better way to approximate the cost is by using the number of times FFT (Fast Fourier Transform) is called. FFT is used to multiply big numbers in computer.\n• : idk how to evaluate this but it's a lot slower than the next method This formula has a few forms, but let's use:\n• None Fast doubling in group of 3, slightly different formula : FFT I measure time to calculate with , unit is dp cost = 27.7669 (almost similar method 3, a bit slower) mpz_fib_ui cost = 16.284 (GMP math library) dp no-recursion cost = 16.274 (method 6. It has the same speed as mpz_fib_ui, but for larger numbers it uses 2 threads, making it faster) binet cost = 657.771 (Binet's formula) matrix cost = 232.092 (Matrix fast exponentiation) cost to convert number to base10 string = 105.358 For the 3 fast methods, the actual result does not fit the cost estimation super well, that's because: a) We just count number of FFTs, meaning we treat all FFT to cost the same. But in reality, the last few FFTs take up most of the time. The actual formula is something like: The first 2 terms is the same for all methods, and cost the most. b) We're ignoring the cost of a few other computations But the main point is to show the reason why those methods are faster, so that estimation is good enough. Actual code (need to install or just use script in the repo) #include <iostream> #include <gmpxx.h> #include <unordered_map> #include <string> #include <sstream> #include <chrono> #include <map> #include <fstream> #include <thread> #include <mutex> #include <memory> #include <vector> #include \"gmp-impl.h\" #include \"longlong.h\" using namespace std; // Important functions: // gmp_fibo // F(int n), dp_fibo // best_fibo // binet_fibo // matrix_fibo class MyTimer { std::chrono::time_point<std::chrono::system_clock> start; public: void startCounter() { start = std::chrono::system_clock::now(); } int64_t getCounterNs() { return std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::system_clock::now() - start).count(); } int64_t getCounterMs() { return std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now() - start).count(); } double getCounterMsPrecise() { return std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::system_clock::now() - start).count() / 1000000.0; } }; bool ktt = false; mpz_class gmp_fibo(int n) { mpz_class fib_n, fib_n1; mpz_fib_ui(fib_n.get_mpz_t(), n); return fib_n; } unordered_map<int, mpz_class> dp; mpz_class& F(int n) { if (n <= 2) return dp[n]; auto it = dp.find(n); if (it != dp.end()) return it->second; int k = n / 2; auto Fk = F(k); auto Fk1 = F(k - 1); if (n % 2 == 0) { return dp[n] = Fk * (Fk + 2 * Fk1); } int sign = (k % 2 == 0) ? 1 : - 1; return dp[n] = (2 * Fk + Fk1) * (2 * Fk - Fk1) + 2 * sign; } mpz_class dp_fibo(int n) { return F(n); } void list_dependency(map<int,int>& mp, int n) { if (n <= 1 || mp[n]) return; mp[n] = 1; list_dependency(mp, n / 2); list_dependency(mp, n / 2 - 1); } void mpz_class_reserve_bits(mpz_class& x, mp_bitcnt_t bitcount) { // mpz_realloc2 is a C function, so we must call it on x.get_mpz_t(). mpz_realloc2(x.get_mpz_t(), bitcount); } void mpz_rsblsh2(mpz_class& c, mpz_class& a, mpz_class& b) { // Access the internal representation of a, b, and c auto a_mpz = a.get_mpz_t(); auto b_mpz = b.get_mpz_t(); auto c_mpz = c.get_mpz_t(); // Get the limb data and sizes mp_size_t a_size = abs(a_mpz->_mp_size); // Number of limbs in a mp_size_t b_size = abs(b_mpz->_mp_size); // Number of limbs in b // Compute the maximum size needed // Idk why it has to realloc every time. If I alloc one big block at the start, its size is reset to a small size anyway mp_size_t max_size = std::max(a_size, b_size) + 2; // +2 for carry/borrow mpz_realloc2(c_mpz, (max_size) * GMP_LIMB_BITS); mpz_realloc2(a_mpz, (max_size) * GMP_LIMB_BITS); mpz_realloc2(b_mpz, (max_size) * GMP_LIMB_BITS); mp_ptr a_limbs = a_mpz->_mp_d; mp_ptr b_limbs = b_mpz->_mp_d; for (mp_size_t i = a_size; i < max_size; ++i) { a_mpz->_mp_d[i] = 0; } for (mp_size_t i = b_size; i < max_size; ++i) { b_mpz->_mp_d[i] = 0; } // Ensure c's limb data is clean std::fill(c_mpz->_mp_d + a_size, c_mpz->_mp_d + max_size, 0); mp_limb_t carry = mpn_rsblsh2_n(c_mpz->_mp_d, b_limbs, a_limbs, a_size); // Determine the number of significant limbs mp_size_t result_size = max_size; while (result_size > 0 && c_mpz->_mp_d[result_size - 1] == 0) { result_size--; // Trim trailing zeros } // Handle carry propagation correctly if (carry > 0) { c_mpz->_mp_d[result_size] = carry; // Add carry as a new highest limb result_size++; } // Update the size of c c_mpz->_mp_size = result_size; // Final sanity check for size mismatches if (result_size == 0 || result_size > max_size) { throw std::logic_error(\"Unexpected result size mismatch\"); } } mpz_class best_fibo(int n) { if (n <= 100) return gmp_fibo(n); map<int,int> mp; list_dependency(mp, n); mpz_class f[3], dummy; bool started = false; bool flag = 0; map<int, mpz_class*> temps; for (int i = 0; i < 3; i++) { f[i] = 0; mpz_class_reserve_bits(f[i], 2 * n + 64); } dummy = 0; mpz_class_reserve_bits(dummy, 2 * n + 64); MyTimer timer; timer.startCounter(); // for (auto [key, value] : mp) cout << key << \"\n\n\"; // cout << std::endl; vector<thread> threads; for (auto &[key, value] : mp) if (key >= 20 && mp.count(key - 1) && !mp.count(key - 2)) { int N = key; // cout << \"key = \" << N << std::endl; if (!started) { f[0] = gmp_fibo(N - 1); f[1] = gmp_fibo(N); f[2] = f[0] + f[1]; temps[N - 1] = &f[0]; temps[N] = &f[1]; temps[N + 1] = &f[2]; started = true; continue; } // edge cases: 160, 170 // 2 3 4 5, 8 9 10, 18 19 20, 38 39 40, 79 80, 160 // 2 3 4 5, 8 9 10, 19 20 21, 41 42, 84 85, 170 // 13 14 15, 29 30 31, 61 62 63, 125 126 252 // 13 14 15, 29 30 31, 61 62 63, 125 126 253 // 13 14 15, 29 30 31, 60 61 62, 123 124 125, 248 249 250, 499 500, 1000 // F[2k] = F[k]*(F[k]+2F[k-1]) // F[2k+1] = (2F[k]+F[k-1])*(2F[k]-F[k-1]) + 2*(-1)^k // OR // F[2k+1] = 4*F[k]^2 - F[k-1]^2 + 2*(-1)^k // F[2k-1] = F[k]^2 + F[k-1]^2 // F[2k] = F[2k+1] - F[2k-1] int k = N / 2; auto &Fk = *temps[k]; auto &Fk1 = *temps[k - 1]; int sign = (k % 2 == 0) ? 1 : -1; if (N % 2 == 1) { // in this case, previous F[k+1] is unused. We that to store temporary result auto& Fkb = *temps[k + 1]; // Use f[k + 1] to store F[n - 1], f[k] = F[n], F[k - 1] = F[n + 1] if (n >= 50'000'000) { threads.clear(); threads.emplace_back([&]() { Fk *= Fk; }); Fk1 *= Fk1; threads[0].join(); } else { Fk *= Fk; Fk1 *= Fk1; } //Fkb = (4 * Fk + 2 * sign) - Fk1; // Fkb = F[2 * k + 1] = F[N] mpz_rsblsh2(Fkb, Fk, Fk1); Fkb += 2 * sign; Fk1 += Fk; // Fk1 = F[2 * k - 1] = F[n - 2] Fk = Fkb - Fk1; // F[k] = F[2 * k] = F[n - 1] if (mp.count(N + 1)) Fk1 = Fkb + Fk; temps.clear(); temps[N - 1] = &Fk; temps[N] = &Fkb; temps[N + 1] = &Fk1; } else { // in this case, F[k - 2] is unused. Use it to store F[n - 1] auto& Fk2 = *temps[k - 2]; if (n >= 50'000'000) { threads.clear(); threads.emplace_back([&]() { Fk *= Fk; }); Fk1 *= Fk1; threads[0].join(); } else { Fk *= Fk; Fk1 *= Fk1; } // Fk2 = (4 * Fk + 2 * sign) - Fk1; // Fk2 = F[2k + 1] = F[N + 1] mpz_rsblsh2(Fk2, Fk, Fk1); Fk2 += 2 * sign; Fk1 += Fk; // Fk1 = F[2k -1]; F[2k - 1] = F[N - 1] Fk = Fk2 - Fk1; // Fk = F[2k] = F[N] temps[N - 1] = &Fk1; temps[N] = &Fk; temps[N + 1] = &Fk2; } } int k = n / 2; auto& Fk = *temps[k]; auto& Fk1 = *temps[k - 1]; int sign = (k % 2 == 0) ? 1 : -1; if (n % 2 == 0) { //return Fk * (Fk + 2 * Fk1); Fk1 *= 2; Fk *= (Fk + Fk1); return std::move(Fk); } //return (2 * Fk + Fk1) * (2 * Fk - Fk1) + 2 * sign; Fk *= 2; Fk1 = (Fk + Fk1) * (Fk - Fk1) + 2 * sign; return std::move(Fk1); } mpz_class binet_fibo(int n) { // Increase default precision so we don't lose accuracy for large n. mpf_set_default_prec(n + 64); // Use mpf_class for floating-point operations mpf_class sqrt5(5); sqrt5 = sqrt(sqrt5); // sqrt(5) mpf_class phi = (mpf_class(1) + sqrt5) / 2; // (1 + sqrt(5)) / 2 // power = phi^n mpf_class power;//(0, 2 * n + 32); mpf_pow_ui(power.get_mpf_t(), phi.get_mpf_t(), n); // result_float = power / sqrt(5) + 0.5 mpf_class result_float = power / sqrt5; result_float += 0.5; // Convert the floating-point approximation to an integer (mpz_class) mpz_class result = mpz_class(result_float); return result; } struct Matrix { int n; vector<mpz_class> data; Matrix(int n) { this->n = n; data.resize(n * n); } Matrix(int n, const vector<int> &a) { this->n = n; data.resize(n * n); for (int i = 0; i < n * n; i++) data[i] = a[i]; } mpz_class& get(int row, int col) { return data[row * n + col]; } const mpz_class& get(int row, int col) const { return data[row * n + col]; } Matrix& operator*=(const Matrix& other) { Matrix dummy(n); for (int i = 0; i < n; i++) for (int j = 0; j < n; j++) { dummy.get(i, j) = 0; for (int k = 0; k < n; k++) dummy.get(i, j) += get(i, k) * other.get(k, j); } for (int i = 0; i < n * n; i++) data[i] = std::move(dummy.data[i]); return *this; } }; mpz_class matrix_fibo(int n) { if (n <= 2) return n; n--; Matrix pow = Matrix(2, {1, 1, 1, 0}); Matrix res = Matrix(2, {1, 0, 0, 1}); while (n > 0) { if (n & 1) res *= pow; pow *= pow; n >>= 1; } return res.data[0]; } //----------------------- // sum of all even fibonacci number <= Fib(n) mpz_class sum_even_fib(int n) { if (n == 0) return 0; n -= n % 3; n /= 3; return (best_fibo(3 * n + 2) - 1) / 2; } //----------------------- bool test_even(int N) { mpz_class tmp, tmp1 = 1, tmp2 = 0; mpz_class sum = 0; for (int n = 2; n <= N; n++) { tmp = tmp1 + tmp2; tmp2 = tmp1; tmp1 = tmp; if (tmp % 2 == 0) sum += tmp; if (sum != sum_even_fib(n)) { cout << \"test_even wrong at \" << n << \"\n\n\"; cout << sum << \"\n\n\" << sum_even_fib(n) << \"\n\n\"; exit(0); } } cout << \"test_even correct\n\n\"; return true; } bool test(int L, int R) { for (int n = L; n <= R; n++) { cout << \"n = \" << n << \"\n\n\"; auto res1 = gmp_fibo(n); auto res2 = best_fibo(n); string s1 = res1.get_str(); string s2 = res2.get_str(); if (s1.length() != s2.length()) cout << \"Wrong length\n\n\"; if (s1 != s2) { cout << s1 << \" \" << s2 << \"\n\n\"; cout << \"Fail at n = \" << n << \"\n\n\"; return false; } } cout << \"Pass all\n\n\"; return true; } bool test(int n) { MyTimer timer; timer.startCounter(); auto res2 = dp_fibo(n); double cost2 = timer.getCounterMsPrecise(); cout << \"dp cost = \" << cost2 << std::endl; timer.startCounter(); auto res1 = gmp_fibo(n); double cost1 = timer.getCounterMsPrecise(); cout << \"mpz_fib_ui cost = \" << cost1 << std::endl; timer.startCounter(); auto res3 = best_fibo(n); double cost3 = timer.getCounterMsPrecise(); cout << \"dp no-recursion cost = \" << cost3 << std::endl; timer.startCounter(); //auto res4 = res1; auto res4 = binet_fibo(n); double cost4 = timer.getCounterMsPrecise(); cout << \"binet cost = \" << cost4 << std::endl; timer.startCounter(); //auto res5 = res1; auto res5 = matrix_fibo(n); double cost5 = timer.getCounterMsPrecise(); cout << \"matrix cost = \" << cost5 << std::endl; timer.startCounter(); string s1 = res1.get_str(); cout << \"cost to convert number to base10 string = \" << timer.getCounterMsPrecise() << std::endl; string s2 = res2.get_str(); string s3 = res3.get_str(); string s4 = res4.get_str(); string s5 = res5.get_str(); bool ok = true; if (s2 != s1) {cout << \"DP wrong answer\n\n\"; ok = false;}; if (s3 != s1) {cout << \"Non-recursive DP wrong answer\n\n\"; ok = false;} if (s4 != s1) {cout << \"Binet wrong answer\n\n\"; ok = false;} if (s5 != s1) {cout << \"Matrix wrong answer\n\n\"; ok = false;} timer.startCounter(); ofstream fo(\"output.txt\"); fo << s1 << \"\n\n\"; fo.close(); cout << \"Output string cost = \" << timer.getCounterMsPrecise() << \"\n\n\"; return ok; } int main(int argc, char* argv[]) { std::ios_base::sync_with_stdio(false); cin.tie(0); int L = (argc > 1) ? atoi(argv[1]) : 10000000; int R = (argc > 2) ? atoi(argv[2]) : L; R = max(L, R); dp[0] = 0; dp[1] = 1; dp[2] = 1; dp[3] = 2; // test_even(100'000); if (L < 0) { L = abs(L); MyTimer timer; timer.startCounter(); auto res = sum_even_fib(L); cout << \"Time to compute sum of Fibonacci numbers <= Fibo(\" << L << \") with even values: \" << timer.getCounterMsPrecise() << \"ms\" << std::endl; timer.startCounter(); ofstream fo(\"output.txt\"); string s = res.get_str(); fo << s << \"\n\n\"; fo.close(); cout << \"Time to output result as string to output.txt \" << timer.getCounterMsPrecise() << \"ms\n\n\"; if (s.length() <= 100) cout << \"Value = \" << s << \"\n\n\"; return 0; } bool result; if (L == R) result = test(L); else result = test(L, R); if (result) cout << \"Correct\n\n\"; else cout << \"Wrong\n\n\"; return 0; }\n• To add 2 numbers with digits, it takes . Multiplying a big number with a small number (int32 or int64), also takes\n• Use to mean\n• To multiply 2 numbers with digits, it takes using FFT or some other algorithms. It requires FFT 3 times: once for each number in forward direction, and once in reverse direction to get the result.\n• The n-th Fibonacci number has around digits (apply to Binet's Formula). So the cost to multiply 2 Fibonacci number close together is around\n• We focus on very large . For smaller numbers, addition/multiplication can use which happens in , instead of\n• The slowest part of calculating Fibonacci number is multiplication, and its slowest part is performing FFT. So, we can evaluate the speed of an algorithm by the number of times FFT is called.\n• This takes additions, and addition takes steps (because has length around 2. Matrix exponentiation: The code to do fast power of a matrix is something like: is called times, can treat it as . Let's count the actual number of multiplication needed to multiply two matrices: So the number of times FFT called is around: 2 * log(n) * 8 * 3 = 48 * log(n) : number of times and are multiplied : number of FFT per multiplication So, the actual time complexity for this method is around . We'll see later that this is the best possible time complexity to calculate Fibonacci number. But the difference in constant factors matters a lot in the real world. 3. Binet's formula: Though it looks O(1), it requires multiplication of irrational integer with around bits. Cost per multiplication is still Number of multiplication to do fast exponentiation: log(n) => In practice, this is much slower than the fast doubling method shown below. The code looks something like: unordered_map<int, mpz_class> dp; dp[1] = 1; dp[2] = 1; mpz_class& F(int n) { if (n <= 2) return dp[n]; auto it = dp.find(n); if (it != dp.end()) return it->second; int k = n / 2; auto Fk = F(k); auto Fk1 = F(k - 1); if (n % 2 == 0) { return dp[n] = Fk * (Fk + 2 * Fk1); } int sign = (k % 2 == 0) ? 1 : - 1; return dp[n] = (2 * Fk + Fk1) * (2 * Fk - Fk1) + 2 * sign; } A good approximation for is is => FFT, which is a lot better than of matrix exponentiation Let's look at a few examples to see why we can do this approximation: The sequence can be split into 3 parts: a) <= 2 leftover number of the beginning (in case of , it's a single ). They can be pre-computed in and doesn't need FFT In each iteration, the center number in a group of 3 is doubled. And the center number always start from >= 4, so the number of groups is => is called around times. Each group of 3 can be represented by: Instead of using the fast doubling formula for all 3 numbers, we just need to calculate , then => 2 multiplication = 6 FFT per group instead of 9 FFT per group In method (4) and (5), we used the formula: However, we can also transform the formula to: Notice that, in a group, we need to calculate and . Multiplying 2 different numbers require 3 FFT, but squaring a number of takes 2 FFT Note that for each group of 3, their values only depend on the previous group. So, it's possible to just use 3 variables in total to calculate , instead of storing all the intermediate results. See the code for details There are more ways to make computation faster, but the real bottleneck is in converting the result to decimal string. So I stop here. Fibonacci numbers with even value are the ones at position . Sum of the first even Fibonacci is equal to: . Proof here: https://math.stackexchange.com/questions/323058/closed-form-for-the-sum-of-even-fibonacci-numbers So to calculate the sum of Fibonacci numbers with even value that is <= , the code is: Basically, it has same cost as finding\n\nI figured I would add my two cents in too. I added the code below and will now explain it. The essential idea is to use Binet's formula (description here) but in a way that avoids radicals. Any number in Binet's formula will be of the form so the pair and in the above are multiples of 1/2 and respectively. There are a couple of observations. We know from applying the Binomial theorem that only odd powers of sqrt(5) will contribute to the final formula because the even powers will cancel as per Binet's formula. That means we only need to focus on the first term in the formula and in particular the number b will be the final answer once we have performed the exponentiation. Because I used some of the ideas of Piotr Dabkowski's answer (which Piotr's answer helped me improve it even further), but the method is not really explained, I will explain it here. We want to know X^n where X is some object with given multiplication properties. In Piotr's case X is a matrix. In this case X is the pair (a,b) which has multiplication properties I will explain below. First we convert n to its bitwise representation, which is the second line in the function. In python bit strings start with '0b' and, since we know the first bit is 1, we start from the second bit in the number. If we consider any bitwise representation as where the as are 0 or 1, and we start from the inner-most bracket and expand outward. This means we will continually double the previous value and add a_i (1 or 0 depending on its value) as we move across the bits until we reach the last bit. As n is an exponent in X^n, doubling means X^l x X^l (where l is the current value we have in the exponent) and adding 1 means multiplying as X^l x X. However, we don't care about the exponent but the above X^l at any given time. We start with a_m=1. Now for the multiplication properties of a,b. The first case is multiplying by 1,1 (which is 1/2 + sqrt(5)/2) and this corresponds to ''add 1'' above. We see that: hence if the current 'char'==1 then we perform this operation, keeping in mind that a and b are in multiples of 1/2 and sqrt(5)/2. In the case of doubling we have the result: which is reflected in the code once more. One point to note is the division by 2. From the results above we see that if a and b are both even or both odd, then the result for for the first equation (prior to division) is that they are both even. Moreover, after the division the new a and b are both even odd or both even. Thus the division by two is always possible as the initial conditions are (an induction argument). It probably is not necessary to prove this, but for the second equation you can also show if a and b are both even (odd) then the new a and b are both even (odd). In testing the code it seems to be comparable speed to the \"faster\" implementations here. As for the answer to the question, if you note that you can get telescoping cancellations so that and therefore the sum since F(32) is the highest even term not exceeding four million, the sum of even Fibonacci numbers not exceeding four million is . It appears I misunderstood the task and it is to find the sum of even Fibonacci terms not indices. That is slightly more complicated but can be done in the above method. First note that even terms have indices divisible by 3, so all even terms have the form F(3n). Using the above approach Adding all these up, we see terms on the right cancel so we have replacing n-1 with n this gives which is again straightforward. Now it is F(33) which is the highest even term smaller than four million, so that the sum of the even terms up to F(33) is So I've made further changes, removing as much redundant multiplication as possible."
    },
    {
        "link": "https://simplilearn.com/tutorials/python-tutorial/fibonacci-series",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/10924096/optimization-of-fibonacci-sequence-generating-algorithm",
        "document": "I have read about some of the methods for calculating Fibonacci with efficient time complexity following are some of them -\n\nMethod 1 - Dynamic Programming Now here the substructure is commonly known hence I'll straightly Jump to the solution -\n\nA space-optimized version of above can be done as follows -\n\nMethod 2- ( Using power of the matrix {{1,1},{1,0}} )\n\nThis an O(n) which relies on the fact that if we n times multiply the matrix M = {{1,1},{1,0}} to itself (in other words calculate power(M, n )), then we get the (n+1)th Fibonacci number as the element at row and column (0, 0) in the resultant matrix. This solution would have O(n) time.\n\nThe matrix representation gives the following closed expression for the Fibonacci numbers: fibonaccimatrix\n\nThis can be optimized to work in O(Logn) time complexity. We can do recursive multiplication to get power(M, n) in the previous method.\n\nMethod 3 (O(log n) Time) Below is one more interesting recurrence formula that can be used to find nth Fibonacci Number in O(log n) time.\n\nIf n is even then k = n/2: F(n) = [2*F(k-1) + F(k)]*F(k)\n\nIf n is odd then k = (n + 1)/2 F(n) = F(k)*F(k) + F(k-1)*F(k-1) How does this formula work? The formula can be derived from the above matrix equation. fibonaccimatrix\n\nTaking determinant on both sides, we get (-1)n = Fn+1Fn-1 – Fn2 Moreover, since AnAm = An+m for any square matrix A, the following identities can be derived (they are obtained from two different coefficients of the matrix product)\n\nTo get the formula to be proved, we simply need to do the following If n is even, we can put k = n/2 If n is odd, we can put k = (n+1)/2\n\nMethod 4 - Using a formula In this method, we directly implement the formula for the nth term in the Fibonacci series. Time O(1) Space O(1) Fn = {[(√5 + 1)/2] ^ n} / √5"
    },
    {
        "link": "https://modernagecoders.com/blog/fibonacci-series-in-python",
        "document": ""
    },
    {
        "link": "https://docs.python.org/3/tutorial/controlflow.html",
        "document": ""
    },
    {
        "link": "https://docs.python.org/3/tutorial/datastructures.html",
        "document": "This chapter describes some things you’ve learned about already in more detail, and adds some new things as well.\n\nThe list data type has some more methods. Here are all of the methods of list objects: Add an item to the end of the list. Similar to . Extend the list by appending all the items from the iterable. Similar to . Insert an item at a given position. The first argument is the index of the element before which to insert, so inserts at the front of the list, and is equivalent to . Remove the first item from the list whose value is equal to x. It raises a if there is no such item. Remove the item at the given position in the list, and return it. If no index is specified, removes and returns the last item in the list. It raises an if the list is empty or the index is outside the list range. Remove all items from the list. Similar to . Return zero-based index in the list of the first item whose value is equal to x. Raises a if there is no such item. The optional arguments start and end are interpreted as in the slice notation and are used to limit the search to a particular subsequence of the list. The returned index is computed relative to the beginning of the full sequence rather than the start argument. Return the number of times x appears in the list. Sort the items of the list in place (the arguments can be used for sort customization, see for their explanation). Reverse the elements of the list in place. Return a shallow copy of the list. Similar to . An example that uses most of the list methods: You might have noticed that methods like , or that only modify the list have no return value printed – they return the default . This is a design principle for all mutable data structures in Python. Another thing you might notice is that not all data can be sorted or compared. For instance, doesn’t sort because integers can’t be compared to strings and can’t be compared to other types. Also, there are some types that don’t have a defined ordering relation. For example, isn’t a valid comparison. The list methods make it very easy to use a list as a stack, where the last element added is the first element retrieved (“last-in, first-out”). To add an item to the top of the stack, use . To retrieve an item from the top of the stack, use without an explicit index. For example: It is also possible to use a list as a queue, where the first element added is the first element retrieved (“first-in, first-out”); however, lists are not efficient for this purpose. While appends and pops from the end of list are fast, doing inserts or pops from the beginning of a list is slow (because all of the other elements have to be shifted by one). To implement a queue, use which was designed to have fast appends and pops from both ends. For example: # The first to arrive now leaves # The second to arrive now leaves List comprehensions provide a concise way to create lists. Common applications are to make new lists where each element is the result of some operations applied to each member of another sequence or iterable, or to create a subsequence of those elements that satisfy a certain condition. For example, assume we want to create a list of squares, like: Note that this creates (or overwrites) a variable named that still exists after the loop completes. We can calculate the list of squares without any side effects using: which is more concise and readable. A list comprehension consists of brackets containing an expression followed by a clause, then zero or more or clauses. The result will be a new list resulting from evaluating the expression in the context of the and clauses which follow it. For example, this listcomp combines the elements of two lists if they are not equal: Note how the order of the and statements is the same in both these snippets. If the expression is a tuple (e.g. the in the previous example), it must be parenthesized. # create a new list with the values doubled # apply a function to all the elements # the tuple must be parenthesized, otherwise an error is raised File , line : did you forget parentheses around the comprehension target? # flatten a list using a listcomp with two 'for' List comprehensions can contain complex expressions and nested functions: The initial expression in a list comprehension can be any arbitrary expression, including another list comprehension. Consider the following example of a 3x4 matrix implemented as a list of 3 lists of length 4: The following list comprehension will transpose rows and columns: As we saw in the previous section, the inner list comprehension is evaluated in the context of the that follows it, so this example is equivalent to: which, in turn, is the same as: # the following 3 lines implement the nested listcomp In the real world, you should prefer built-in functions to complex flow statements. The function would do a great job for this use case: See Unpacking Argument Lists for details on the asterisk in this line.\n\nWe saw that lists and strings have many common properties, such as indexing and slicing operations. They are two examples of sequence data types (see Sequence Types — list, tuple, range). Since Python is an evolving language, other sequence data types may be added. There is also another standard sequence data type: the tuple. A tuple consists of a number of values separated by commas, for instance: File , line , in : # but they can contain mutable objects: As you see, on output tuples are always enclosed in parentheses, so that nested tuples are interpreted correctly; they may be input with or without surrounding parentheses, although often parentheses are necessary anyway (if the tuple is part of a larger expression). It is not possible to assign to the individual items of a tuple, however it is possible to create tuples which contain mutable objects, such as lists. Though tuples may seem similar to lists, they are often used in different situations and for different purposes. Tuples are immutable, and usually contain a heterogeneous sequence of elements that are accessed via unpacking (see later in this section) or indexing (or even by attribute in the case of ). Lists are mutable, and their elements are usually homogeneous and are accessed by iterating over the list. A special problem is the construction of tuples containing 0 or 1 items: the syntax has some extra quirks to accommodate these. Empty tuples are constructed by an empty pair of parentheses; a tuple with one item is constructed by following a value with a comma (it is not sufficient to enclose a single value in parentheses). Ugly, but effective. For example: The statement is an example of tuple packing: the values , and are packed together in a tuple. The reverse operation is also possible: This is called, appropriately enough, sequence unpacking and works for any sequence on the right-hand side. Sequence unpacking requires that there are as many variables on the left side of the equals sign as there are elements in the sequence. Note that multiple assignment is really just a combination of tuple packing and sequence unpacking.\n\nPython also includes a data type for sets. A set is an unordered collection with no duplicate elements. Basic uses include membership testing and eliminating duplicate entries. Set objects also support mathematical operations like union, intersection, difference, and symmetric difference. Curly braces or the function can be used to create sets. Note: to create an empty set you have to use , not ; the latter creates an empty dictionary, a data structure that we discuss in the next section. Here is a brief demonstration: # show that duplicates have been removed # Demonstrate set operations on unique letters from two words # letters in a but not in b # letters in a or b or both # letters in both a and b # letters in a or b but not both Similarly to list comprehensions, set comprehensions are also supported:\n\nAnother useful data type built into Python is the dictionary (see Mapping Types — dict). Dictionaries are sometimes found in other languages as “associative memories” or “associative arrays”. Unlike sequences, which are indexed by a range of numbers, dictionaries are indexed by keys, which can be any immutable type; strings and numbers can always be keys. Tuples can be used as keys if they contain only strings, numbers, or tuples; if a tuple contains any mutable object either directly or indirectly, it cannot be used as a key. You can’t use lists as keys, since lists can be modified in place using index assignments, slice assignments, or methods like and . It is best to think of a dictionary as a set of key: value pairs, with the requirement that the keys are unique (within one dictionary). A pair of braces creates an empty dictionary: . Placing a comma-separated list of key:value pairs within the braces adds initial key:value pairs to the dictionary; this is also the way dictionaries are written on output. The main operations on a dictionary are storing a value with some key and extracting the value given the key. It is also possible to delete a key:value pair with . If you store using a key that is already in use, the old value associated with that key is forgotten. It is an error to extract a value using a non-existent key. Performing on a dictionary returns a list of all the keys used in the dictionary, in insertion order (if you want it sorted, just use instead). To check whether a single key is in the dictionary, use the keyword. Here is a small example using a dictionary: The constructor builds dictionaries directly from sequences of key-value pairs: In addition, dict comprehensions can be used to create dictionaries from arbitrary key and value expressions: When the keys are simple strings, it is sometimes easier to specify pairs using keyword arguments:\n\nWhen looping through dictionaries, the key and corresponding value can be retrieved at the same time using the method. When looping through a sequence, the position index and corresponding value can be retrieved at the same time using the function. To loop over two or more sequences at the same time, the entries can be paired with the function. What is your name? It is lancelot. What is your quest? It is the holy grail. What is your favorite color? It is blue. To loop over a sequence in reverse, first specify the sequence in a forward direction and then call the function. To loop over a sequence in sorted order, use the function which returns a new sorted list while leaving the source unaltered. Using on a sequence eliminates duplicate elements. The use of in combination with over a sequence is an idiomatic way to loop over unique elements of the sequence in sorted order. It is sometimes tempting to change a list while you are looping over it; however, it is often simpler and safer to create a new list instead.\n\nThe conditions used in and statements can contain any operators, not just comparisons. The comparison operators and are membership tests that determine whether a value is in (or not in) a container. The operators and compare whether two objects are really the same object. All comparison operators have the same priority, which is lower than that of all numerical operators. Comparisons can be chained. For example, tests whether is less than and moreover equals . Comparisons may be combined using the Boolean operators and , and the outcome of a comparison (or of any other Boolean expression) may be negated with . These have lower priorities than comparison operators; between them, has the highest priority and the lowest, so that A and not B or C is equivalent to (A and (not B)) or C . As always, parentheses can be used to express the desired composition. The Boolean operators and are so-called short-circuit operators: their arguments are evaluated from left to right, and evaluation stops as soon as the outcome is determined. For example, if and are true but is false, A and B and C does not evaluate the expression . When used as a general value and not as a Boolean, the return value of a short-circuit operator is the last evaluated argument. It is possible to assign the result of a comparison or other Boolean expression to a variable. For example, Note that in Python, unlike C, assignment inside expressions must be done explicitly with the walrus operator . This avoids a common class of problems encountered in C programs: typing in an expression when was intended.\n\nSequence objects typically may be compared to other objects with the same sequence type. The comparison uses lexicographical ordering: first the first two items are compared, and if they differ this determines the outcome of the comparison; if they are equal, the next two items are compared, and so on, until either sequence is exhausted. If two items to be compared are themselves sequences of the same type, the lexicographical comparison is carried out recursively. If all items of two sequences compare equal, the sequences are considered equal. If one sequence is an initial sub-sequence of the other, the shorter sequence is the smaller (lesser) one. Lexicographical ordering for strings uses the Unicode code point number to order individual characters. Some examples of comparisons between sequences of the same type: Note that comparing objects of different types with or is legal provided that the objects have appropriate comparison methods. For example, mixed numeric types are compared according to their numeric value, so 0 equals 0.0, etc. Otherwise, rather than providing an arbitrary ordering, the interpreter will raise a exception."
    },
    {
        "link": "https://linode.com/docs/guides/python-for-and-while-loops",
        "document": "This credit will be applied to any valid services used during your first days.\n\nPrograms often have to run the same commands over and over again. Python provides two types of loop statements to handle two different situations. The Python loop is used when the number of iterations is known before the loop starts running. In contrast, the Python loop repeats as long as a certain condition is true. This tutorial describes how to use both types of loops and explains how to use Python for common scenarios like looping through a dictionary.\n\nAn Introduction to Python for and while Loops\n\nThe Python statement is a control flow statement that executes a specific block of code a certain number of times. Without this command, programming would be tedious and much less useful. Each loop contains a sequencer that determines how many times the loop should run. Some loops use the function to delimit the starting and stopping points. Other loops use a sequential data structure, such as a list, string, or dictionary, to define the sequence. In this case, the length of the data structure determines the range. The loop repeats once for each item in the structure.\n\nA loop is used whenever the loop should run a certain number of times. Under normal circumstances, changes inside the loop do not cause the loop to terminate early. However, the statement allows for early termination of the loop under unexpected or adverse conditions. Here are some cases when a loop might be useful.\n• Count how many times each letter grade appears in a student transcript.\n• Given a list of employees, determine how many did not complete the mandatory ethics course.\n• Update a macro-economic model for each of the next ten years.\n\nIn these cases, the program can determine the range of the loop before it begins looping. In the first case, a finite list of grades is used as a sequencer for the loop. If the list is , then the loop iterates five times, once for each grade.\n\nThe Python statement continues to execute a block of code as long as a test condition is true. The loop stops running when the condition no longer holds. Therefore, it is impossible to tell in advance how many times the loop might run. To determine whether the loop should iterate again, Python calculates the Boolean value of the statement’s conditional expression. An example of this type of expression is . If the expression evaluates to , then Python executes the loop again. If it is , then Python stops running the loop. Control flow passes to the next statement after the loop.\n\nAs long as its expression continues to be , a loop can keep running indefinitely. For the loop to terminate, the conditional expression must change to at some point. This means at least one of the variables used in the expression must be updated somewhere within the code block. A conditional expression that can never change to leads to an infinite loop. This type of loop is defined as an endlessly repeating sequence of instructions. There are a few cases where this is desirable, for instance, in the kernel of an operating system. But most of the time, this is a bug. Always ensure the conditional expression can change given the correct exit conditions.\n\nIn certain situations, it is sensible to add a guard condition to a conditional expression. For example, a loop that validates a user password should limit the number of attempts. The guard often takes the form of a loop counter that increments with every iteration.\n\nHere are a few examples of cases where a statement could be used:\n• A user is repeatedly prompted for a password until they enter it correctly.\n• A program accepts and processes new input until the user enters an escape sequence.\n• A function continues reading data from a stream as long as the connection remains open.\n\nTo summarize, a statement is used when the maximum number of iterations is known in advance. Use a statement when the loop should keep running until something changes.\n• None If you have not already done so, create a Linode account and Compute Instance. See our Getting Started with Linode and Creating a Compute Instance guides.\n• None Follow our Setting Up and Securing a Compute Instance guide to update your system. You may also wish to set the timezone, configure your hostname, create a limited user account, and harden SSH access.\n• None Ensure Python is properly installed on the Linode and you can launch and use the Python programming environment. To run Python on Ubuntu, use the command . For information on how to use Python, see our guide on How to Install Python 3 on Ubuntu 20.04.\n\nThe Python statement is a compound statement. It consists of a header and a block of code. The first line of the statement, up until the symbol, is the header. The header contains the following components:\n• The keyword, which begins the statement.\n• A loop variable, which is also known as the iterator. This variable is incremented or decremented with each new iteration of the loop. It is not necessary to define the loop variable beforehand. Python creates this variable when it is first used.\n• A sequence to constrain how many times the loop executes. This is supplied using either the function or a sequential data object. The built-in function accepts up to three integers. These stand for the starting position, the ending position, and the for the sequence. The sequential data type can be a String, List, Set, Tuple, or Dictionary. More details are provided in the following sections.\n\nEach statement is paired with a block of executable code, known as the suite. The code block consists of one or more indented lines of code. The first non-indented line of code terminates the code block. According to Python’s PEP 8 style guidelines, the indentation should be four spaces long.\n\nAt the beginning of each loop, Python increments the value of the iterator and verifies whether the loop should continue. If so, Python executes the code block again.\n\nUsing the Python for Loop with a Range\n\nThe Python statement is frequently used with the keyword. When the function is used to calculate the sequence, the loop keeps running as long as the iterator falls within the range. When used with the function, the syntax for a Python loop follows the format below:\n\nThe operator accepts up to three integer parameters:\n• : This serves as the initial value of the and the starting point of the . If the value is omitted, it defaults to . It is inclusive, which means the is set to this value for the first instance of the loop.\n• : This mandatory value determines the end position of the . A comparison is made between the value of the and the endpoint at the start of the loop. If the is still within the range, the loop continues to iterate. This value is exclusive, so if and the are equal, the loop stops running.\n• : The indicates how much the should increment each cycle. It is optional, and has a default value of . If a is used, all three values must be specified.\n\nTo illustrate how these values work together, increments the iterator from to and runs five times. sets the iterator to to start off and increments it by with each iteration. It only runs two times, because the third time the iterator is , which is equal to the value.\n\nThe following program demonstrates how to use the function to constrain a Python loop. The uses the default value and an point of 5. The iterator is set to zero at the start of the loop and continues to increment each cycle. The loop continues to run while is less than . The code block prints out the new value of the iterator each time it runs.\n\nIn the next example, the loop initializes to and adds to each loop, up to an upper limit of . When is , the loop executes again. When it increments to , it is no longer less than the value, so the loop terminates. Control passes to the next statement outside the loop.\n\nNegative values can be used for or points and for the . When the step is negative, Python verifies whether the iterator is still greater than the value. The following example decrements the iterator by each time the loop begins.\n\nA loop can also have an statement, although it is not used too often. The code associated with the statement runs after the loop ends. It can be used for post-loop processing or for situations when the loop does not run at all.\n\nUsing the Python for Loop with Sequential Data Types\n\nThe Python loop can also be used with sequential data structures such as Strings, Lists, Tuples, and Dictionaries. In these cases, the length of the data structure defines the range of the sequence. The loop continues to iterate while there are more items. For example, if a loop uses a list containing five items, the loop iterates five times. Each item in the data structure is assigned in turn to the iterator.\n\nWhen a loop is used with a sequential data type, the syntax changes slightly. The function is no longer used, but the structure is much the same otherwise.\n\nHow to Loop Through a List in Python\n\nPython uses the List’s built-in function to step through the List. Each new loop assigns the next item in the List to the iterator variable. The loop is guaranteed to iterate through all items in the List in sequential order. It continues to iterate as long as the List contains more items.\n\nThe following example demonstrates how to use the Python statement to loop through a List. In this case, the program defines a List named . The line iterates through the List. At the start of each loop, it assigns the next item in the List to . Upon each new loop, contains the name of the next city. Within the code block, each city is printed on a new line.\n\nHow to Loop Through a Dictionary in Python\n\nPython can loop through a dictionary in much the same way it loops through a List. However, the structure of a dictionary is more complicated. A dictionary maps keys to values. Each dictionary item is a key-value pair which uses the key as its index. To be valid, a key must be comparable to other keys and cannot change. However, a value can be of any Python type, and types can be mixed within the same dictionary. A value can also be a sequential data type, such as a List or Tuple, or even another Dictionary.\n\nBeginning with release 3.6, Python iterates over dictionary keys in the same order the entries were created. The loop provides the name of the next key, not the value. However, the value can be accessed using the indexing operator . To use the indexing operator, specify the name of the dictionary and append the indexing operator, placing the name of the key inside. The syntax for this operation is . For example, if a dictionary named contains a key named , the associated value of is retrieved using .\n\nThe file demonstrates how to loop through a Dictionary named . In this Dictionary, the key is the name of the city while the value is the name of the state. More specifically, contains the name of the city, and contains the name of the corresponding state. The code block prints both variables. Because the Dictionary contains four entries, the loop iterates four times.\n\nEvery Python Dictionary has a built-in method named . To use the method, append an empty arguments list . This function supplies a view object containing all the values from the Dictionary without the corresponding keys. This method is useful when a program does not require the keys, only the Dictionary values. Although a view object is not actually a List, a loop can process it in the same way. The loop iterates through the view, supplying the next value in the view each time the loop runs.\n\nThe following example loops through the Dictionary values. The loop retrieves each subsequent item in . It then prints the value, which is the name of the state. The key is never retrieved or used, and the indexing operator is not required. In this case, the loop iterates through a view object of the Dictionary values, not the Dictionary itself.\n\nThe built-in method generates a view object containing all the key-value pairs from a Python dictionary. Each pair is a tuple object. The values in a tuple can be separated using a technique known as tuple unpacking. To unpack a tuple, assign the tuple to a sequence of variables, separated by commas. The number of variables must match the number of items in the tuple. To assign the values of the two-item tuple to the variables and , use the statement . This assigns the first value in to and the second value to .\n\nA loop can be paired with the method to iterate through all key-value pairs in a Python dictionary. Upon each iteration through the view object, the next key-value tuple is extracted and unpacked to the loop variables. The following example assigns the key and value from to the and variables. When this method is used, the indexing operator is no longer required to access the value.\n\nBuilt-in Python dictionary methods, like can be used to efficiently loop over a Python dictionary. To learn about these built-in dictionary methods, see our guide How to Use Dictionaries in Python 3.\n\nHow to Break or Exit from a For Loop in Python\n\nThe Python statement immediately breaks out of the innermost loop. It is often used to handle unexpected conditions or errors. For example, a loop might read data from a file and write it to a database. If the database suddenly becomes inaccessible, a statement can immediately end the loop. Otherwise, the program would repeatedly keep timing out. It is better to give prompt feedback that something is not working.\n\nIn the example file, the statement terminates the loop when the factorial of the iterator exceeds . Based on the and values, the program is expected to loop through the code block five times. However, it stops after three cycles because the factorial of is greater than the guard value of .\n\nThe Python loop is similar to the loop, but it is used in slightly different circumstances. It works best in situations where the number of iterations is not known when the program first begins to loop. A good example is a guessing game. The game ends when the player guesses the correct number. So the loop keeps running until the correct number is chosen.\n\nLike the Python loop, the Python statement is structured as a compound statement. It also contains a header and an associated code block. This code block is executed every time the loop iterates. The entire code block must be indented, so the first non-indented line signifies the end of the block. The indentation should be four spaces.\n\nThe header for a statement is somewhat simpler than the loop header. It contains the following items:\n• A conditional expression, which must evaluate to a Boolean value of either or . If the expression is , Python executes the corresponding code block.\n• A symbol, terminating the header and introducing the code block.\n\nA loop does not have an iterator or a range and does not assign any variables. It does not lend itself to handling a sequential data structure. It can be thought of as an “indefinite” statement. Upon each iteration, Python evaluates the Boolean expression. If it is , the code block is executed. If it is , the loop terminates and control flow passes to the first non-indented line following its code block. The conditional expression can use any of Python’s logical or comparison operators, including , , or . If the expression is the first time through the loop, the loop never runs at all.\n\nAs long as the Boolean expression remains , the statement keeps looping. To avoid an infinite loop, one of two events must happen. Either the conditional expression must eventually evaluate as , or a statement must be used inside the code block. For the expression to change, the code block must change one of the values used in the expression.\n\nThe syntax for a loop is structured as follows:\n\nIn this example, the statement is used to validate a password. The program defines the and then queries the user for their password. The user input is assigned to . If the loop continues to run. If the user does not remember their password, they can get stuck in an infinite loop. Therefore, it is good practice to add a guard counter to a loop.\n\nThe following statement keeps looping while the password is wrong and the user has made fewer than ten attempts to guess it. Inside the loop, the program increments the counter and prompts the user to guess the password. If the equals the , the program tells the user they are right. Program control flow passes back to the start of the loop to see if the block should run again. However, this time is and the loop terminates.\n\nIf the user never guesses the password in five attempts, the program ends gracefully.\n\nHow to Break or Exit from a While Loop in Python\n\nThe statement is used more frequently inside a loop than in a loop. A statement could be used when a special character or a control sequence can terminate a loop. Instead of setting a flag and then determining if the flag is set in the conditional, it is easier to exit the loop immediately.\n\nPython also supports a loop. This structure works the same way the statement does. The clause is executed if the statement conditional is . This is used for post-processing or clean-up tasks when the precondition is reached. For example, it can be used for a good-bye message when the user enters a certain sequence. It is also commonly used when a positive response breaks the loop. In this case, the statement only executes when the attempt fails.\n\nThe use of a statement and an directive make the preceding program more efficient. The program already compares and when deciding whether to display a success message. Therefore, a statement can be added right after the message, causing the loop to immediately terminate. The unnecessary comparison at the start of the next loop does not have to be performed.\n\nAdditionally, the conditional expression can be simplified. It only has to compare to the guard value. The program does not have to compare to because it knows the two values are different. If the user had guessed correctly, making and the same, the statement would have been used. Therefore, is already known to be and does not have to be re-evaluated. The only time when the conditional fails are when the maximum number of guesses has been made. This implies the user never entered the password, so the clause can confidently display an error message.\n\nIf the user fails to guess correctly, the error statement is printed.\n\nUnlike the loop, a loop evaluates the conditional expression at the end of the loop. Therefore it always executes the code block at least once. If the expression evaluates to , the loop runs again.\n\nPython does not support the loop structure even though it is available in many other languages. However, the equivalent logic can be implemented in Python using the statement along with one or more statements. The expression is always so the loop is guaranteed to run once. In fact, it runs until a statement is encountered within the loop. A statement inside the loop is used to determine when to break out of the loop. The code block must contain a statement to terminate the loop. Otherwise, an infinite loop is formed.\n\nHere is a basic outline demonstrating how a loop might be implemented in Python. This example breaks out of the loop on the tenth cycle.\n\nSummarizing the Python for and while Loops\n\nTwo Python statements are used to create loops. The Python statement iterates for a fixed number of times. In contrast, a statement keeps running as long as a conditional expression is satisfied. Both statements supply a block of code, which runs each time the loop iterates.\n\nThe statement is often used with a indicator that specifies the starting and ending points of the loop sequence. The range determines how many times the loop iterates. However, a loop is also used to iterate through sequential data structures, including Lists and Dictionaries. At the start of each loop, either the next item in the structure or the next value in the sequence is assigned to the iterator.\n\nA conditional expression constrains the Python statement. If the expression evaluates to , Python runs the corresponding code block. If it is , the loop terminates. Unless the expression can change based on updates within the code block, it is possible to get trapped in an infinite loop.\n\nBoth the and statements can be paired with an directive that only executes when the loop terminates. In addition, the Python statement in the code block can be used to forcibly break out of the loop. This technique is handy for dealing with unexpected error conditions. For more information about the Python and statements, consult the Python documentation.\n\nYou may wish to consult the following resources for additional information on this topic. While these are provided in the hope that they will be useful, please note that we cannot vouch for the accuracy or timeliness of externally hosted materials."
    },
    {
        "link": "https://docs.python.org/3/reference/simple_stmts.html",
        "document": "A simple statement is comprised within a single logical line. Several simple statements may occur on a single line separated by semicolons. The syntax for simple statements is:\n\nExpression statements are used (mostly interactively) to compute and write a value, or (usually) to call a procedure (a function that returns no meaningful result; in Python, procedures return the value ). Other uses of expression statements are allowed and occasionally useful. The syntax for an expression statement is: An expression statement evaluates the expression list (which may be a single expression). In interactive mode, if the value is not , it is converted to a string using the built-in function and the resulting string is written to standard output on a line by itself (except if the result is , so that procedure calls do not cause any output.)\n\nAssignment statements are used to (re)bind names to values and to modify attributes or items of mutable objects: An assignment statement evaluates the expression list (remember that this can be a single expression or a comma-separated list, the latter yielding a tuple) and assigns the single resulting object to each of the target lists, from left to right. Assignment is defined recursively depending on the form of the target (list). When a target is part of a mutable object (an attribute reference, subscription or slicing), the mutable object must ultimately perform the assignment and decide about its validity, and may raise an exception if the assignment is unacceptable. The rules observed by various types and the exceptions raised are given with the definition of the object types (see section The standard type hierarchy). Assignment of an object to a target list, optionally enclosed in parentheses or square brackets, is recursively defined as follows.\n• None If the target list is a single target with no trailing comma, optionally in parentheses, the object is assigned to that target.\n• \n• None If the target list contains one target prefixed with an asterisk, called a “starred” target: The object must be an iterable with at least as many items as there are targets in the target list, minus one. The first items of the iterable are assigned, from left to right, to the targets before the starred target. The final items of the iterable are assigned to the targets after the starred target. A list of the remaining items in the iterable is then assigned to the starred target (the list can be empty).\n• None Else: The object must be an iterable with the same number of items as there are targets in the target list, and the items are assigned, from left to right, to the corresponding targets. Assignment of an object to a single target is recursively defined as follows.\n• None If the target is an identifier (name):\n• None If the name does not occur in a or statement in the current code block: the name is bound to the object in the current local namespace.\n• None Otherwise: the name is bound to the object in the global namespace or the outer namespace determined by , respectively. The name is rebound if it was already bound. This may cause the reference count for the object previously bound to the name to reach zero, causing the object to be deallocated and its destructor (if it has one) to be called.\n• None If the target is an attribute reference: The primary expression in the reference is evaluated. It should yield an object with assignable attributes; if this is not the case, is raised. That object is then asked to assign the assigned object to the given attribute; if it cannot perform the assignment, it raises an exception (usually but not necessarily ). Note: If the object is a class instance and the attribute reference occurs on both sides of the assignment operator, the right-hand side expression, can access either an instance attribute or (if no instance attribute exists) a class attribute. The left-hand side target is always set as an instance attribute, creating it if necessary. Thus, the two occurrences of do not necessarily refer to the same attribute: if the right-hand side expression refers to a class attribute, the left-hand side creates a new instance attribute as the target of the assignment: This description does not necessarily apply to descriptor attributes, such as properties created with .\n• None If the target is a subscription: The primary expression in the reference is evaluated. It should yield either a mutable sequence object (such as a list) or a mapping object (such as a dictionary). Next, the subscript expression is evaluated. If the primary is a mutable sequence object (such as a list), the subscript must yield an integer. If it is negative, the sequence’s length is added to it. The resulting value must be a nonnegative integer less than the sequence’s length, and the sequence is asked to assign the assigned object to its item with that index. If the index is out of range, is raised (assignment to a subscripted sequence cannot add new items to a list). If the primary is a mapping object (such as a dictionary), the subscript must have a type compatible with the mapping’s key type, and the mapping is then asked to create a key/value pair which maps the subscript to the assigned object. This can either replace an existing key/value pair with the same key value, or insert a new key/value pair (if no key with the same value existed). For user-defined objects, the method is called with appropriate arguments.\n• None If the target is a slicing: The primary expression in the reference is evaluated. It should yield a mutable sequence object (such as a list). The assigned object should be a sequence object of the same type. Next, the lower and upper bound expressions are evaluated, insofar they are present; defaults are zero and the sequence’s length. The bounds should evaluate to integers. If either bound is negative, the sequence’s length is added to it. The resulting bounds are clipped to lie between zero and the sequence’s length, inclusive. Finally, the sequence object is asked to replace the slice with the items of the assigned sequence. The length of the slice may be different from the length of the assigned sequence, thus changing the length of the target sequence, if the target sequence allows it. CPython implementation detail: In the current implementation, the syntax for targets is taken to be the same as for expressions, and invalid syntax is rejected during the code generation phase, causing less detailed error messages. Although the definition of assignment implies that overlaps between the left-hand side and the right-hand side are ‘simultaneous’ (for example swaps two variables), overlaps within the collection of assigned-to variables occur left-to-right, sometimes resulting in confusion. For instance, the following program prints : # i is updated, then x[i] is updated The specification for the feature. Augmented assignment is the combination, in a single statement, of a binary operation and an assignment statement: An augmented assignment evaluates the target (which, unlike normal assignment statements, cannot be an unpacking) and the expression list, performs the binary operation specific to the type of assignment on the two operands, and assigns the result to the original target. The target is only evaluated once. An augmented assignment statement like can be rewritten as to achieve a similar, but not exactly equal effect. In the augmented version, is only evaluated once. Also, when possible, the actual operation is performed in-place, meaning that rather than creating a new object and assigning that to the target, the old object is modified instead. Unlike normal assignments, augmented assignments evaluate the left-hand side before evaluating the right-hand side. For example, first looks-up , then it evaluates and performs the addition, and lastly, it writes the result back to . With the exception of assigning to tuples and multiple targets in a single statement, the assignment done by augmented assignment statements is handled the same way as normal assignments. Similarly, with the exception of the possible in-place behavior, the binary operation performed by augmented assignment is the same as the normal binary operations. For targets which are attribute references, the same caveat about class and instance attributes applies as for regular assignments. Annotation assignment is the combination, in a single statement, of a variable or attribute annotation and an optional assignment statement: The difference from normal Assignment statements is that only a single target is allowed. The assignment target is considered “simple” if it consists of a single name that is not enclosed in parentheses. For simple assignment targets, if in class or module scope, the annotations are evaluated and stored in a special class or module attribute that is a dictionary mapping from variable names (mangled if private) to evaluated annotations. This attribute is writable and is automatically created at the start of class or module body execution, if annotations are found statically. If the assignment target is not simple (an attribute, subscript node, or parenthesized name), the annotation is evaluated if in class or module scope, but not stored. If a name is annotated in a function scope, then this name is local for that scope. Annotations are never evaluated and stored in function scopes. If the right hand side is present, an annotated assignment performs the actual assignment before evaluating annotations (where applicable). If the right hand side is not present for an expression target, then the interpreter evaluates the target except for the last or call. The proposal that added syntax for annotating the types of variables (including class variables and instance variables), instead of expressing them through comments. The proposal that added the module to provide a standard syntax for type annotations that can be used in static analysis tools and IDEs. Changed in version 3.8: Now annotated assignments allow the same expressions in the right hand side as regular assignments. Previously, some expressions (like un-parenthesized tuple expressions) caused a syntax error.\n\nIf no expressions are present, re-raises the exception that is currently being handled, which is also known as the active exception. If there isn’t currently an active exception, a exception is raised indicating that this is an error. Otherwise, evaluates the first expression as the exception object. It must be either a subclass or an instance of . If it is a class, the exception instance will be obtained when needed by instantiating the class with no arguments. The type of the exception is the exception instance’s class, the value is the instance itself. A traceback object is normally created automatically when an exception is raised and attached to it as the attribute. You can create an exception and set your own traceback in one step using the exception method (which returns the same exception instance, with its traceback set to its argument), like so: The clause is used for exception chaining: if given, the second expression must be another exception class or instance. If the second expression is an exception instance, it will be attached to the raised exception as the attribute (which is writable). If the expression is an exception class, the class will be instantiated and the resulting exception instance will be attached to the raised exception as the attribute. If the raised exception is not handled, both exceptions will be printed: File , line , in : The above exception was the direct cause of the following exception: File , line , in : A similar mechanism works implicitly if a new exception is raised when an exception is already being handled. An exception may be handled when an or clause, or a statement, is used. The previous exception is then attached as the new exception’s attribute: File , line , in : During handling of the above exception, another exception occurred: File , line , in : Exception chaining can be explicitly suppressed by specifying in the clause: Additional information on exceptions can be found in section Exceptions, and information about handling exceptions is in section The try statement. Changed in version 3.3: is now permitted as in . Added the attribute to suppress automatic display of the exception context. Changed in version 3.11: If the traceback of the active exception is modified in an clause, a subsequent statement re-raises the exception with the modified traceback. Previously, the exception was re-raised with the traceback it had when it was caught.\n\nimport_stmt ::= \"import\" [\"as\" ] (\",\" [\"as\" ])* | \"from\" \"import\" [\"as\" ] (\",\" [\"as\" ])* | \"from\" \"import\" \"(\" [\"as\" ] (\",\" [\"as\" ])* [\",\"] \")\" | \"from\" \"import\" \"*\" module ::= ( \".\")* relative_module ::= \".\"* | \".\"+ The basic import statement (no clause) is executed in two steps:\n• None find a module, loading and initializing it if necessary\n• None define a name or names in the local namespace for the scope where the statement occurs. When the statement contains multiple clauses (separated by commas) the two steps are carried out separately for each clause, just as though the clauses had been separated out into individual import statements. The details of the first step, finding and loading modules, are described in greater detail in the section on the import system, which also describes the various types of packages and modules that can be imported, as well as all the hooks that can be used to customize the import system. Note that failures in this step may indicate either that the module could not be located, or that an error occurred while initializing the module, which includes execution of the module’s code. If the requested module is retrieved successfully, it will be made available in the local namespace in one of three ways:\n• None If the module name is followed by , then the name following is bound directly to the imported module.\n• None If no other name is specified, and the module being imported is a top level module, the module’s name is bound in the local namespace as a reference to the imported module\n• None If the module being imported is not a top level module, then the name of the top level package that contains the module is bound in the local namespace as a reference to the top level package. The imported module must be accessed using its full qualified name rather than directly The form uses a slightly more complex process:\n• None find the module specified in the clause, loading and initializing it if necessary;\n• None for each of the identifiers specified in the clauses:\n• None check if the imported module has an attribute by that name\n• None if not, attempt to import a submodule with that name and then check the imported module again for that attribute\n• None if the attribute is not found, is raised.\n• None otherwise, a reference to that value is stored in the local namespace, using the name in the clause if it is present, otherwise using the attribute name If the list of identifiers is replaced by a star ( ), all public names defined in the module are bound in the local namespace for the scope where the statement occurs. The public names defined by a module are determined by checking the module’s namespace for a variable named ; if defined, it must be a sequence of strings which are names defined or imported by that module. The names given in are all considered public and are required to exist. If is not defined, the set of public names includes all names found in the module’s namespace which do not begin with an underscore character ( ). should contain the entire public API. It is intended to avoid accidentally exporting items that are not part of the API (such as library modules which were imported and used within the module). The wild card form of import — — is only allowed at the module level. Attempting to use it in class or function definitions will raise a . When specifying what module to import you do not have to specify the absolute name of the module. When a module or package is contained within another package it is possible to make a relative import within the same top package without having to mention the package name. By using leading dots in the specified module or package after you can specify how high to traverse up the current package hierarchy without specifying exact names. One leading dot means the current package where the module making the import exists. Two dots means up one package level. Three dots is up two levels, etc. So if you execute from a module in the package then you will end up importing . If you execute from within you will import . The specification for relative imports is contained in the Package Relative Imports section. is provided to support applications that determine dynamically the modules to be loaded. A future statement is a directive to the compiler that a particular module should be compiled using syntax or semantics that will be available in a specified future release of Python where the feature becomes standard. The future statement is intended to ease migration to future versions of Python that introduce incompatible changes to the language. It allows use of the new features on a per-module basis before the release in which the feature becomes standard. future_stmt ::= \"from\" \"__future__\" \"import\" [\"as\" ] (\",\" [\"as\" ])* | \"from\" \"__future__\" \"import\" \"(\" [\"as\" ] (\",\" [\"as\" ])* [\",\"] \")\" feature ::= A future statement must appear near the top of the module. The only lines that can appear before a future statement are:\n• None the module docstring (if any), The only feature that requires using the future statement is (see PEP 563). All historical features enabled by the future statement are still recognized by Python 3. The list includes , , , , , , and . They are all redundant because they are always enabled, and only kept for backwards compatibility. A future statement is recognized and treated specially at compile time: Changes to the semantics of core constructs are often implemented by generating different code. It may even be the case that a new feature introduces new incompatible syntax (such as a new reserved word), in which case the compiler may need to parse the module differently. Such decisions cannot be pushed off until runtime. For any given release, the compiler knows which feature names have been defined, and raises a compile-time error if a future statement contains a feature not known to it. The direct runtime semantics are the same as for any import statement: there is a standard module , described later, and it will be imported in the usual way at the time the future statement is executed. The interesting runtime semantics depend on the specific feature enabled by the future statement. Note that there is nothing special about the statement: That is not a future statement; it’s an ordinary import statement with no special semantics or syntax restrictions. Code compiled by calls to the built-in functions and that occur in a module containing a future statement will, by default, use the new syntax or semantics associated with the future statement. This can be controlled by optional arguments to — see the documentation of that function for details. A future statement typed at an interactive interpreter prompt will take effect for the rest of the interpreter session. If an interpreter is started with the option, is passed a script name to execute, and the script includes a future statement, it will be in effect in the interactive session started after the script is executed. The original proposal for the __future__ mechanism."
    },
    {
        "link": "https://stackoverflow.com/questions/18972873/unpacking-object-variables-in-python",
        "document": "I'm thinking if there is some way to unpack object attributes. Usually doing this involves series of:\n\nHowever it should be possible to do it better.\n\nI'm thinking about something like:\n\nor even function like:\n\nAny ideas? Or is there some more pythonic way to do this?"
    }
]