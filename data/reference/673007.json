[
    {
        "link": "https://geeksforgeeks.org/structures-c",
        "document": "In C, a structure is a user-defined data type that can be used to group items of possibly different types into a single type. The struct keyword is used to define a structure. The items in the structure are called its member and they can be of any valid data type.\n\nExplanation: In this example, a structure A is defined to hold an integer member x. A variable a of type struct A is created and its member x is initialized to 11 by accessing it using dot operator. The value of a.x is then printed to the console.\n\nStructures are used when you want to store a collection of different data types, such as integers, floats, or even other structures under a single name. To understand how structures are foundational to building complex data structures, the C Programming Course Online with Data Structures provides practical applications and detailed explanations.\n\nThere are two steps of creating a structure in C:\n\nA structure is defined using the struct keyword followed by the structure name and its members. It is also called a structure template or structure prototype, and no memory is allocated to the structure in the declaration.\n• structure_name: Name of the structure.\n• member1, member2, …: Name of the members.\n\nBe careful not to forget the semicolon at the end.\n\nAfter structure definition, we have to create variable of that structure to use it. It is similar to the any other type of variable declaration:\n\nWe can also declare structure variables with structure definition.\n\nFollowing are the basic operations commonly used on structures:\n\nTo access or modify members of a structure, we use the ( . ) dot operator. This is applicable when we are using structure variables directly.\n\nIn the case where we have a pointer to the structure, we can also use the arrow operator to access the members.\n\nStructure members cannot be initialized with the declaration. For example, the following C program fails in the compilation.\n\nThe reason for the above error is simple. When a datatype is declared, no memory is allocated for it. Memory is allocated only when variables are created. So there is no space to store the value assigned.\n\nWe can initialize structure members in 4 ways which are as follows:\n\nBy default, structure members are not automatically initialized to 0 or NULL. Uninitialized structure members will contain garbage values. However, when a structure variable is declared with an initializer, all members not explicitly initialized are zero-initialized.\n\nNote: We cannot initialize the arrays or strings using assignment operator after variable declaration.\n\nIn this type of initialization, the values are assigned in sequential order as they are declared in the structure template.\n\nDesignated Initialization allows structure members to be initialized in any order. This feature has been added in the C99 standard.\n\nThe Designated Initialization is only supported in C but not in C++.\n\nCopying structure is simple as copying any other variables. For example, s1 is copied into s2 using assignment operator.\n\nBut this method only creates a shallow copy of s1 i.e. if the structure s1 have some dynamic resources allocated by malloc, and it contains pointer to that resource, then only the pointer will be copied to s2. If the dynamic resource is also needed, then it has to be copied manually (deep copy).\n\nStructure can be passed to a function in the same way as normal variables. Though, it is recommended to pass it as a pointer to avoid copying a large amount of data.\n\nThe typedef keyword is used to define an alias for the already existing datatype. In structures, we have to use the struct keyword along with the structure name to define the variables. Sometimes, this increases the length and complexity of the code. We can use the typedef to define some new shorter name for the structure.\n\nExplanation: In this code, str1 and str2 are defined as aliases for the unnamed structures, allowing the creation of structure variables (var1 and var2) using these new names. This simplifies the syntax when declaring variables of the structure.\n\nTechnically, the size of the structure in C should be the sum of the sizes of its members. But it may not be true for most cases. The reason for this is Structure Padding.\n\nStructure padding is the concept of adding multiple empty bytes in the structure to naturally align the data members in the memory. It is done to minimize the CPU read cycles to retrieve different data members in the structure.\n\nThere are some situations where we need to pack the structure tightly by removing the empty bytes. In such cases, we use Structure Packing. C language provides two ways for structure packing:\n\nTo know more about structure padding and packing, refer to this article – Structure Member Alignment, Padding and Data Packing.\n\nIn C, a nested structure refers to a structure that contains another structure as one of its members. This allows you to create more complex data types by grouping multiple structures together, which is useful when dealing with related data that needs to be grouped within a larger structure.\n\nThere are two ways in which we can nest one structure into another:\n• Embedded Structure Nesting: The structure being nested is also declared inside the parent structure.\n• Separate Structure Nesting: Two structures are declared separately and then the member structure is nested inside the parent structure.\n\nWe can access nested Members by using the same ( . ) dot operator two times as shown:\n\nExplanation: In this code, the structure parent contains another structure child as a member. The parent structure is then initialized with values, including the values for the child structure’s members.\n\nA pointer to a structure allows us to access structure members using the ( -> ) arrow operator instead of the dot operator.\n\nExplanation: In this example, ptr is a pointer to the structure Point. It holds the address of the structure variable p. The structure members x and y are accessed using the -> operator, which is used to dereference the pointer and access the members of the structure.\n\nThe self-referential structures are those structures that contain references to the same type as themselves i.e. they contain a member of the type pointer pointing to the same structure type.\n\nSuch kinds of structures are used in different data structures such as to define the nodes of linked lists, trees, etc.\n\nBit Fields are used to specify the length of the structure members in bits. When we know the maximum length of the member, we can use bit fields to specify the size and reduce memory consumption.\n\nUses of Structure in C\n\nC structures are used for the following:\n• None The structure can be used to define the custom data types that can be used to create some complex data types such as dates, time, complex numbers, etc. which are not present in the language.\n• None It can also be used in data organization where a large amount of data can be stored in different fields.\n• None Structures are used to create data structures such as trees, linked lists, etc.\n• None They can also be used for returning multiple values from a function."
    },
    {
        "link": "https://geeksforgeeks.org/data-types-in-c",
        "document": "Each variable in C has an associated data type. It specifies the type of data that the variable can store like integer, character, floating, double, etc. Each data type requires different amounts of memory and has some specific operations which can be performed over it.\n\nThe data types in C can be classified as follows:\n\nThe following are some main primitive data types in C:\n\nThe integer datatype in C is used to store the integer numbers (any number including positive, negative and zero without decimal part). Octal values, hexadecimal values, and decimal values can be stored in int data type in C.\n\nWe use int keyword to declare the integer variable:\n\nThe integer data type can also be used as\n• unsigned int: Unsigned int data type in C is used to store the data values from zero to positive numbers but it can’t store negative values like signed int.\n• short int: It is lesser in size than the int by 2 bytes so can only store values from -32,768 to 32,767.\n• long int: Larger version of the int datatype so can store values greater than int.\n• unsigned short int: Similar in relationship with short int as unsigned int with int.\n\nCharacter data type allows its variable to store only a single character. The size of the character is 1 byte. It is the most basic data type in C. It stores a single character and requires a single byte of memory in almost all compilers.\n\nThe char keyword is used to declare the variable of character type:\n\nIn C programming float data type is used to store floating-point values. Float in C is used to store decimal and exponential values. It is used to store decimal numbers (numbers with floating point values) with single precision.\n\nThe float keyword is used to declare the variable as a floating point:\n\nA Double data type in C is used to store decimal numbers (numbers with floating point values) with double precision. It is used to define numeric values which hold numbers with decimal values in C.\n\nThe double data type is basically a precision sort of data type that is capable of holding 64 bits of decimal numbers or floating points. Since double has more precision as compared to that float then it is much more obvious that it occupies twice the memory occupied by the floating-point type. It can easily accommodate about 16 to 17 digits after or before a decimal point.\n\nThe variable can be declared as double precision floating point using the double keyword:\n\nThe void data type in C is used to specify that no value is present. It does not provide a result value to its caller. It has no values and no operations. It is used to represent nothing. Void is used in multiple ways as function return type, function arguments as void, and pointers to void.\n\nSize of Data Types in C\n\nThe size of the data types in C is dependent on the size of the architecture, so we cannot define the universal size of the data types. For that, the C language provides the sizeof() operator to check the size of the data types.\n\nDifferent data types also have different ranges up to which they can store numbers. These ranges may vary from compiler to compiler. Below is a list of ranges along with the memory requirement and format specifiers on the 32-bit GCC compiler.\n\nTo check your knowledge of data types in C, go through the Quiz on Data Types."
    },
    {
        "link": "https://w3schools.com/c/c_structs.php",
        "document": "Structures (also called structs) are a way to group several related variables into one place. Each variable in the structure is known as a member of the structure.\n\nUnlike an array, a structure can contain many different data types (int, float, char, etc.).\n\nYou can create a structure by using the keyword and declare each of its members inside curly braces:\n\nTo access the structure, you must create a variable of it.\n\nUse the keyword inside the method, followed by the name of the structure and then the name of the structure variable:\n\nTo access members of a structure, use the dot syntax ( ):\n\nNow you can easily create multiple structure variables with different values, using just one structure:\n\nWhat About Strings in Structures?\n\nRemember that strings in C are actually an array of characters, and unfortunately, you can't assign a value to an array like this:\n\nHowever, there is a solution for this! You can use the function and assign the value to , like this:\n\nYou can also assign values to members of a structure variable at declaration time, in a single line.\n\nJust insert the values in a comma-separated list inside curly braces . Note that you don't have to use the function for string values with this technique:\n\nYou can also assign one structure to another.\n\nIn the following example, the values of s1 are copied to s2:\n\nIf you want to change/modify a value, you can use the dot syntax ( ).\n\nAnd to modify a string value, the function is useful again:\n\nModifying values are especially useful when you copy structure values:\n\nOk, so, how are structures useful? Imagine you have to write a program to store different information about Cars, such as brand, model, and year. What's great about structures is that you can create a single \"Car template\" and use it for every cars you make. See below for a real life example.\n\nUse a structure to store different information about Cars:"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/struct",
        "document": "A structure type (or struct type) is a value type that can encapsulate data and related functionality. You use the keyword to define a structure type:\n\nFor information about and types, see the ref structure types article.\n\nStructure types have value semantics. That is, a variable of a structure type contains an instance of the type. By default, variable values are copied on assignment, passing an argument to a method, and returning a method result. For structure-type variables, an instance of the type is copied. For more information, see Value types.\n\nTypically, you use structure types to design small data-centric types that provide little or no behavior. For example, .NET uses structure types to represent a number (both integer and real), a Boolean value, a Unicode character, a time instance. If you're focused on the behavior of a type, consider defining a class. Class types have reference semantics. That is, a variable of a class type contains a reference to an instance of the type, not the instance itself.\n\nBecause structure types have value semantics, we recommend you define immutable structure types.\n\nYou use the modifier to declare that a structure type is immutable. All data members of a struct must be read-only as follows:\n• Any field declaration must have the modifier.\n• Any property, including automatically implemented ones, must be read-only or only. Init-only setters are only available from C# version 9 onwards.\n\nThat guarantees that no member of a struct modifies the state of the struct. That means that other instance members except constructors are implicitly .\n\nThe following code defines a struct with init-only property setters:\n\nYou can also use the modifier to declare that an instance member doesn't modify the state of a struct. If you can't declare the whole structure type as , use the modifier to mark the instance members that don't modify the state of the struct.\n\nWithin a instance member, you can't assign to structure's instance fields. However, a member can call a non- member. In that case, the compiler creates a copy of the structure instance and calls the non- member on that copy. As a result, the original structure instance isn't modified.\n\nTypically, you apply the modifier to the following kinds of instance members:\n• You can also apply the modifier to methods that override methods declared in System.Object:\n• If you need to apply the modifier to both accessors of a property or indexer, apply it in the declaration of the property or indexer. The compiler declares a accessor of an automatically implemented property as , regardless of presence of the modifier in a property declaration. You can apply the modifier to a property or indexer with an accessor:\n\nYou can apply the modifier to static fields of a structure type, but not any other static members, such as properties or methods.\n\nThe compiler can make use of the modifier for performance optimizations. For more information, see Avoiding allocations.\n\nYou can use the expression to produce a copy of a structure-type instance with the specified properties and fields modified. You use object initializer syntax to specify what members to modify and their new values, as the following example shows:\n\nYou can define record structure types. Record types provide built-in functionality for encapsulating data. You can define both and types. A record struct can't be a . For more information and examples, see Records.\n\nBeginning with C# 12, you can declare inline arrays as a type:\n\nAn inline array is a structure that contains a contiguous block of N elements of the same type. It's a safe-code equivalent of the fixed buffer declaration available only in unsafe code. An inline array is a with the following characteristics:\n• The struct doesn't specify an explicit layout.\n\nIn addition, the compiler validates the System.Runtime.CompilerServices.InlineArrayAttribute attribute:\n• The length must be greater than zero ( ).\n• The target type must be a struct.\n\nIn most cases, an inline array can be accessed like an array, both to read and write values. In addition, you can use the range and index operators.\n\nThere are minimal restrictions on the type of the single field of an inline array. It can't be a pointer type:\n\nBut it can be any reference type, or any value type:\n\nYou can use inline arrays with almost any C# data structure.\n\nInline arrays are an advanced language feature. They're intended for high-performance scenarios where an inline, contiguous block of elements is faster than other alternative data structures. You can learn more about inline arrays from the feature speclet.\n\nA variable of a type directly contains the data for that . That creates a distinction between an uninitialized , which has its default value and an initialized , which stores values set by constructing it. For example consider the following code:\n\nAs the preceding example shows, the default value expression ignores a parameterless constructor and produces the default value of the structure type. Structure-type array instantiation also ignores a parameterless constructor and produces an array populated with the default values of a structure type.\n\nThe most common situation where you see default values is in arrays or in other collections where internal storage includes blocks of variables. The following example creates an array of 30 structures, each of which has the default value:\n\nAll of a struct's member fields must be definitely assigned when created because types directly store their data. The value of a struct definitely assigned all fields to 0. All fields must be definitely assigned when a constructor is invoked. You initialize fields using the following mechanisms:\n• You can add field initializers to any field or auto implemented property.\n• You can initialize any fields, or auto properties, in the body of the constructor.\n\nBeginning with C# 11, if you don't initialize all fields in a struct, the compiler adds code to the constructor that initializes those fields to the default value. A struct assigned to its value is initialized to the 0-bit pattern. A struct initialized with is initialized to the 0-bit pattern, followed by executing any field initializers and a constructor.\n\nEvery has a parameterless constructor. If you write a parameterless constructor, it must be public. If a struct declares any field initializers, it must explicitly declare a constructor. That constructor need not be parameterless. If a struct declares a field initializer but no constructors, the compiler reports an error. Any explicitly declared constructor (with parameters, or parameterless) executes all field initializers for that struct. All fields without a field initializer or an assignment in a constructor are set to the default value. For more information, see the Parameterless struct constructors feature proposal note.\n\nBeginning with C# 12, types can define a primary constructor as part of its declaration. Primary constructors provide a concise syntax for constructor parameters that can be used throughout the body, in any member declaration for that struct.\n\nIf all instance fields of a structure type are accessible, you can also instantiate it without the operator. In that case you must initialize all instance fields before the first use of the instance. The following example shows how to do that:\n\nFor the built-in value types, use the corresponding literals to specify a value of the type.\n\nLimitations with the design of a structure type\n\nStructs have most of the capabilities of a class type. There are some exceptions:\n• A structure type can't inherit from other class or structure type and it can't be the base of a class. However, a structure type can implement interfaces.\n• You can't declare a finalizer within a structure type.\n• Before C# 11, a constructor of a structure type must initialize all instance fields of the type.\n\nWhen you pass a structure-type variable to a method as an argument or return a structure-type value from a method, the whole instance of a structure type is copied. Pass by value can affect the performance of your code in high-performance scenarios that involve large structure types. You can avoid value copying by passing a structure-type variable by reference. Use the , , , or method parameter modifiers to indicate that an argument must be passed by reference. Use ref returns to return a method result by reference. For more information, see Avoid allocations.\n\nYou also use the keyword in the constraint to specify that a type parameter is a non-nullable value type. Both structure and enumeration types satisfy the constraint.\n\nFor any structure type (except types), there exist boxing and unboxing conversions to and from the System.ValueType and System.Object types. There exist also boxing and unboxing conversions between a structure type and any interface that it implements.\n\nFor more information, see the Structs section of the C# language specification.\n\nFor more information about features, see the following feature proposal notes:"
    },
    {
        "link": "https://gnu.org/software/gnu-c-manual/gnu-c-manual.html",
        "document": "This is the GNU C reference manual.\n\nThis is a reference manual for the C programming language as implemented by the GNU Compiler Collection (GCC). Specifically, this manual aims to document:\n• The 1989 ANSI C standard, commonly known as “C89”\n• The 1999 ISO C standard, commonly known as “C99”, to the extent that C99 is implemented by GCC\n• The current state of GNU extensions to standard C\n\nThis manual describes C89 as its baseline. C99 features and GNU extensions are explicitly labeled as such.\n\nBy default, GCC will compile code as C89 plus GNU-specific extensions. Much of C99 is supported; once full support is available, the default compilation dialect will be C99 plus GNU-specific extensions. (Some of the GNU extensions to C89 ended up, sometimes slightly modified, as standard language features in C99.)\n\nThe C language includes a set of preprocessor directives, which are used for things such as macro text replacement, conditional compilation, and file inclusion. Although normally described in a C language manual, the GNU C preprocessor has been thoroughly documented in , a separate manual which covers preprocessing for C, C++, and Objective-C programs, so it is not included here.\n\nThanks to everyone who has helped with editing, proofreading, ideas, typesetting, and administrivia, including: Diego Andres Alvarez Marin, Nelson H. F. Beebe, Karl Berry, Robert Chassell, Hanfeng Chen, Mark de Volld, Antonio Diaz Diaz, dine, Andreas Foerster, Denver Gingerich, Lisa Goldstein, Robert Hansen, Jean-Christophe Helary, Mogens Hetsholm, Teddy Hogeborn, Joe Humphries, J. Wren Hunt, Dutch Ingraham, Adam Johansen, Vladimir Kadlec, Benjamin Kagia, Dright Kayorent, Sugun Kedambadi, Felix Lee, Bjorn Liencres, Steve Morningthunder, Aljosha Papsch, Matthew Plant, Jonathan Sisti, Richard Stallman, J. Otto Tennant, Ole Tetlie, Keith Thompson, T.F. Torrey, James Youngman, and Steve Zachar. Trevis Rothwell serves as project maintainer and, along with James Youngman, wrote the bulk of the text.\n\nSome example programs are based on algorithms in Donald Knuth’s .\n\nPlease send bug reports and suggestions to gnu-c-manual@gnu.org.\n\nThis chapter describes the lexical elements that make up C source code after preprocessing. These elements are called tokens. There are five types of tokens: keywords, identifiers, constants, operators, and separators. White space, sometimes required to separate tokens, is also described in this chapter.\n\nIdentifiers are sequences of characters used for naming variables, functions, new data types, and preprocessor macros. You can include letters, decimal digits, and the underscore character ‘ ’ in identifiers.\n\nThe first character of an identifier cannot be a digit.\n\nLowercase letters and uppercase letters are distinct, such that and are two different identifiers.\n\nWhen using GNU extensions, you can also include the dollar sign character ‘ ’ in identifiers.\n\nKeywords are special identifiers reserved for use as part of the programming language itself. You cannot use them for any other purpose.\n\nHere is a list of keywords recognized by ANSI C89:\n\nIn both ISO C99 and C89 with GNU extensions, the following is also recognized as a keyword:\n\nA constant is a literal numeric or character value, such as or . All constants are of a particular data type; you can use type casting to explicitly specify the type of a constant, or let the compiler use the default type based on the value of the constant.\n\nAn integer constant is a sequence of digits, with an optional prefix to denote a number base.\n\nIf the sequence of digits is preceded by or (zero x or zero X), then the constant is considered to be hexadecimal (base 16). Hexadecimal values may use the digits from 0 to 9, as well as the letters to and to . Here are some examples:\n\nIf the first digit is 0 (zero), and the next character is not ‘ ’ or ‘ ’, then the constant is considered to be octal (base 8). Octal values may only use the digits from 0 to 7; 8 and 9 are not allowed. Here are some examples:\n\nIn all other cases, the sequence of digits is assumed to be decimal (base 10). Decimal values may use the digits from 0 to 9. Here are some examples:\n\nThere are various integer data types, for short integers, long integers, signed integers, and unsigned integers. You can force an integer constant to be of a long and/or unsigned integer type by appending a sequence of one or more letters to the end of the constant:\n\nFor example, is an constant. You can also combine letters: is an constant. (The letters may be used in any order.)\n\nBoth ISO C99 and GNU C extensions add the integer types and . You can use two ‘ ’s to get a constant; add a ‘ ’ to that and you have an constant. For example: .\n\nA character constant is usually a single character enclosed within single quotation marks, such as . A character constant is of type by default.\n\nSome characters, such as the single quotation mark character itself, cannot be represented using only one character. To represent such characters, there are several “escape sequences” that you can use:\n\nTo use any of these escape sequences, enclose the sequence in single quotes, and treat it as if it were any other character. For example, the letter m is and the newline character is .\n\nThe octal number escape sequence is the backslash character followed by one, two, or three octal digits (0 to 7). For example, 101 is the octal equivalent of 65, which is the ASCII character . Thus, the character constant is the same as the character constant .\n\nThe hexadecimal escape sequence is the backslash character, followed by and an unlimited number of hexadecimal digits (0 to 9, and to or to ).\n\nWhile the length of possible hexadecimal digit strings is unlimited, the number of character constants in any given character set is not. (The much-used extended ASCII character set, for example, has only 256 characters in it.) If you try to use a hexadecimal value that is outside the range of characters, you will get a compile-time error.\n\nA real number constant is a value that represents a fractional (floating point) number. It consists of a sequence of digits which represents the integer (or “whole”) part of the number, a decimal point, and a sequence of digits which represents the fractional part.\n\nEither the integer part or the fractional part may be omitted, but not both. Here are some examples:\n\nReal number constants can also be followed by or , and an integer exponent. The exponent can be either positive or negative.\n\nYou can append a letter to the end of a real number constant to cause it to be of a particular type. If you append the letter F (or f) to a real number constant, then its type is . If you append the letter L (or l), then its type is . If you do not append any letters, then its type is .\n\nA string constant is a sequence of zero or more characters, digits, and escape sequences enclosed within double quotation marks. A string constant is of type “array of characters”. All string constants contain a null termination character ( ) as their last character. Strings are stored as arrays of characters, with no inherent size attribute. The null termination character lets string-processing functions know where the string ends.\n\nAdjacent string constants are concatenated (combined) into one string, with the null termination character added to the end of the final concatenated string.\n\nA string cannot contain double quotation marks, as double quotation marks are used to enclose the string. To include the double quotation mark character in a string, use the escape sequence. You can use any of the escape sequences that can be used as character constants in strings. Here are some example of string constants:\n\nIf a string is too long to fit on one line, you can use a backslash to break it up onto separate lines.\n\nAdjacent strings are automatically concatenated, so you can also have string constants span multiple lines by writing them as separate, adjacent, strings. For example:\n\nis the same as\n\nTo insert a newline character into the string, so that when the string is printed it will be printed on two different lines, you can use the newline escape sequence ‘ ’.\n\nAn operator is a special token that performs an operation, such as addition or subtraction, on either one, two, or three operands. Full coverage of operators can be found in a later chapter. See Expressions and Operators.\n\nA separator separates tokens. White space (see next section) is a separator, but it is not a token. The other separators are all single-character tokens themselves:\n\nWhite space is the collective term used for several characters: the space character, the tab character, the newline character, the vertical tab character, and the form-feed character. White space is ignored (outside of string and character constants), and is therefore optional, except when it is used to separate tokens. This means that\n\nare functionally the same program.\n\nAlthough you must use white space to separate many tokens, no white space is required between operators and operands, nor is it required between other separators and that which they separate.\n\nFurthermore, wherever one space is allowed, any amount of white space is allowed.\n\nIn string constants, spaces and tabs are not ignored; rather, they are part of the string. Therefore,\n\nis not the same as\n\nThe integer data types range in size from at least 8 bits to at least 32 bits. The C99 standard extends this range to include integer sizes of at least 64 bits. You should use integer types for storing whole number values (and the data type for storing characters). The sizes and ranges listed for these types are minimums; depending on your computer platform, these sizes and ranges may be larger.\n\nWhile these ranges provide a natural ordering, the standard does not require that any two types have a different range. For example, it is common for and to have the same range. The standard even allows and to have the same range, though such platforms are very unusual.\n• The 8-bit data type can hold integer values in the range of -128 to 127.\n• The 8-bit data type can hold integer values in the range of 0 to 255.\n• Depending on your system, the data type is defined as having the same range as either the or the data type (they are three distinct types, however). By convention, you should use the data type specifically for storing ASCII characters (such as ), including escape sequences (such as ).\n• The 16-bit data type can hold integer values in the range of -32,768 to 32,767. You may also refer to this data type as , , or .\n• The 16-bit data type can hold integer values in the range of 0 to 65,535. You may also refer to this data type as .\n• The 32-bit data type can hold integer values in the range of -2,147,483,648 to 2,147,483,647. You may also refer to this data type as or .\n• The 32-bit data type can hold integer values in the range of 0 to 4,294,967,295. You may also refer to this data type simply as .\n• The 32-bit data type can hold integer values in the range of at least -2,147,483,648 to 2,147,483,647. (Depending on your system, this data type might be 64-bit, in which case its range is identical to that of the data type.) You may also refer to this data type as , , or .\n• The 32-bit data type can hold integer values in the range of at least 0 to 4,294,967,295. (Depending on your system, this data type might be 64-bit, in which case its range is identical to that of the data type.) You may also refer to this data type as .\n• The 64-bit data type can hold integer values in the range of -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 . You may also refer to this data type as , or . This type is not part of C89, but is both part of C99 and a GNU C extension.\n• The 64-bit data type can hold integer values in the range of at least 0 to 18,446,744,073,709,551,615 . You may also refer to this data type as . This type is not part of C89, but is both part of C99 and a GNU C extension.\n\nHere are some examples of declaring and defining integer variables:\n\nThe first line declares an integer named but does not define its value; it is left uninitialized, and its value should not be assumed to be anything in particular.\n\nThere are three data types that represent fractional numbers. While the sizes and ranges of these types are consistent across most computer systems in use today, historically the sizes of these types varied from system to system. As such, the minimum and maximum values are stored in macro definitions in the library header file . In this section, we include the names of the macro definitions in place of their possible values; check your system’s for specific numbers.\n• The data type is the smallest of the three floating point types, if they differ in size at all. Its minimum value is stored in the , and should be no greater than . Its maximum value is stored in , and should be no less than .\n• The data type is at least as large as the type, and it may be larger. Its minimum value is stored in , and its maximum value is stored in .\n• The data type is at least as large as the type, and it may be larger. Its minimum value is stored in , and its maximum value is stored in .\n\nAll floating point data types are signed; trying to use , for example, will cause a compile-time error.\n\nHere are some examples of declaring and defining real number variables:\n\nThe first line declares a float named but does not define its value; it is left uninitialized, and its value should not be assumed to be anything in particular.\n\nThe real number types provided in C are of finite precision, and accordingly, not all real numbers can be represented exactly. Most computer systems that GCC compiles for use a binary representation for real numbers, which is unable to precisely represent numbers such as, for example, 4.2. For this reason, we recommend that you consider not comparing real numbers for exact equality with the operator, but rather check that real numbers are within an acceptable tolerance.\n\nThere are other more subtle implications of these imprecise representations; for more details, see David Goldberg’s paper What Every Computer Scientist Should Know About Floating-Point Arithmetic and section 4.2.2 of Donald Knuth’s .\n\nGCC introduced some complex number types as an extension to C89. Similar features were introduced in C991, but there were a number of differences. We describe the standard complex number types first.\n\nComplex types were introduced in C99. There are three complex types:\n\nThe names here begin with an underscore and an uppercase letter in order to avoid conflicts with existing programs’ identifiers. However, the C99 standard header file introduces some macros which make using complex types easier.\n• Expands to . This allows a variable to be declared as which seems more natural.\n• A constant of type having the value of the imaginary unit normally referred to as i.\n\nThe header file also declares a number of functions for performing computations on complex numbers, for example the and functions which respectively return the real and imaginary parts of a number. Other functions are also provided, as shown in this example:\n\nGCC also introduced complex types as a GNU extension to C89, but the spelling is different. The floating-point complex types in GCC’s C89 extension are:\n\nGCC’s extension allow for complex types other than floating-point, so that you can declare complex character types and complex integer types; in fact can be used with any of the primitive data types. We won’t give you a complete list of all possibilities, but here are some examples:\n• The data type has two components: a real part and an imaginary part, both of which are of the data type.\n• The data type also has two components: a real part and an imaginary part, both of which are of the data type.\n\nTo extract the real part of a complex-valued expression, use the keyword , followed by the expression. Likewise, use to extract the imaginary part.\n\nThis example creates a complex floating point variable , and defines its real part as 4 and its imaginary part as 3. Then, the real part is assigned to the floating point variable , and the imaginary part is assigned to the floating point variable .\n\nAn enumeration is a custom data type used for storing constant integer values and referring to them by names. By default, these values are of type ; however, you can use the GCC compiler option to cause the smallest possible integer type to be used instead. Both of these behaviors conform to the C89 standard, but mixing the use of these options within the same program can produce incompatibilities.\n\nYou define an enumeration using the keyword, followed by the name of the enumeration (this is optional), followed by a list of constant names (separated by commas and enclosed in braces), and ending with a semicolon.\n\nThat example defines an enumeration, , which contains four constant integer values, , , , and , whose values are, by default, 0, 1, 2, and 3, respectively. You can also specify one or more of the values explicitly:\n\nThat example defines to be -17, and the remaining values are incremented by 1: is -16, is -15, and is -14. Unless specified otherwise, an enumeration value is equal to one more than the previous value (and the first value defaults to 0).\n\nYou can also refer to an enumeration value defined earlier in the same enumeration:\n\nIn that example, is 0, is 1, is 2, and is 4.\n\nYou can’t use the same name for an as a or in the same scope.\n\nYou can declare variables of an enumeration type both when the enumeration is defined and afterward. This example declares one variable, named of type , all in a single statement:\n\nwhile this example declares the type and variable separately:\n\nAlthough such variables are considered to be of an enumeration type, you can assign them any value that you could assign to an variable, including values from other enumerations. Furthermore, any variable that can be assigned an value can be assigned a value from an enumeration.\n\nHowever, you cannot change the values in an enumeration once it has been defined; they are constant values. For example, this won’t work:\n\nEnumerations are useful in conjunction with the statement, because the compiler can warn you if you have failed to handle one of the enumeration values. Using the example above, if your code handles , and only but not , GCC can generate a warning.\n\nA union is a custom data type used for storing several variables in the same memory space. Although you can access any of those variables at any time, you should only read from one of them at a time—assigning a value to one of them overwrites the values in the others.\n\nYou define a union using the keyword followed by the declarations of the union’s members, enclosed in braces. You declare each member of a union just as you would normally declare a variable—using the data type followed by one or more variable names separated by commas, and ending with a semicolon. Then end the union definition with a semicolon after the closing brace.\n\nYou should also include a name for the union between the keyword and the opening brace. This is syntactically optional, but if you leave it out, you can’t refer to that union data type later on (without a , see The typedef Statement).\n\nHere is an example of defining a simple union for holding an integer value and a floating point value:\n\nThat defines a union named , which contains two members, and , which are of type and , respectively.\n\nYou can declare variables of a union type when both you initially define the union and after the definition, provided you gave the union type a name.\n\nYou can declare variables of a union type when you define the union type by putting the variable names after the closing brace of the union definition, but before the final semicolon. You can declare more than one such variable by separating the names with commas.\n\nThat example declares two variables of type , and .\n\nYou can declare variables of a union type after you define the union by using the keyword and the name you gave the union type, followed by one or more variable names separated by commas.\n\nThat example declares two variables of type , and .\n\nYou can initialize the first member of a union variable when you declare it:\n\nIn that example, the member of gets the value 5. The member is left alone.\n\nAnother way to initialize a union member is to specify the name of the member to initialize. This way, you can initialize whichever member you want to, not just the first one. There are two methods that you can use—either follow the member name with a colon, and then its value, like this:\n\nor precede the member name with a period and assign a value with the assignment operator, like this:\n\nYou can also initialize a union member when you declare the union variable during the definition:\n\nYou can access the members of a union variable using the member access operator. You put the name of the union variable on the left side of the operator, and the name of the member on the right side.\n\nNotice in that example that giving a value to the member overrides the value stored in the member.\n\nThis size of a union is equal to the size of its largest member. Consider the first union example from this section:\n\nThe size of the union data type is the same as , because the type is larger than the type. Since all of the members of a union occupy the same memory space, the union data type size doesn’t need to be large enough to hold the sum of all their sizes; it just needs to be large enough to hold the largest member.\n\nA structure is a programmer-defined data type made up of variables of other data types (possibly including other structure types).\n\nYou define a structure using the keyword followed by the declarations of the structure’s members, enclosed in braces. You declare each member of a structure just as you would normally declare a variable—using the data type followed by one or more variable names separated by commas, and ending with a semicolon. Then end the structure definition with a semicolon after the closing brace.\n\nYou should also include a name for the structure in between the keyword and the opening brace. This is optional, but if you leave it out, you can’t refer to that structure data type later on (without a , see The typedef Statement).\n\nHere is an example of defining a simple structure for holding the X and Y coordinates of a point:\n\nThat defines a structure type named , which contains two members, and , both of which are of type .\n\nStructures (and unions) may contain instances of other structures and unions, but of course not themselves. It is possible for a structure or union type to contain a field which is a pointer to the same type (see Incomplete Types).\n\nYou can declare variables of a structure type when both you initially define the structure and after the definition, provided you gave the structure type a name.\n\nYou can declare variables of a structure type when you define the structure type by putting the variable names after the closing brace of the structure definition, but before the final semicolon. You can declare more than one such variable by separating the names with commas.\n\nThat example declares two variables of type , and .\n\nYou can declare variables of a structure type after defining the structure by using the keyword and the name you gave the structure type, followed by one or more variable names separated by commas.\n\nThat example declares two variables of type , and .\n\nYou can initialize the members of a structure type to have certain values when you declare structure variables.\n\nIf you do not initialize a structure variable, the effect depends on whether it has static storage (see Storage Class Specifiers) or not. If it is, members with integral types are initialized with 0 and pointer members are initialized to NULL; otherwise, the value of the structure’s members is indeterminate.\n\nOne way to initialize a structure is to specify the values in a set of braces and separated by commas. Those values are assigned to the structure members in the same order that the members are declared in the structure in definition.\n\nIn that example, the member of gets the value 5, and the member gets the value 10.\n\nAnother way to initialize the members is to specify the name of the member to initialize. This way, you can initialize the members in any order you like, and even leave some of them uninitialized. There are two methods that you can use. The first method is available in C99 and as a C89 extension in GCC:\n\nYou can also omit the period and use a colon instead of ‘ ’, though this is a GNU C extension:\n\nYou can also initialize the structure variable’s members when you declare the variable during the structure definition:\n\nYou can also initialize fewer than all of a structure variable’s members:\n\nHere, is initialized with 5, is initialized with 0, and is initialized with NULL. The rule here is that and are initialized just as they would be if they were static variables.\n\nHere is another example that initializes a structure’s members which are structure variables themselves:\n\nThat example defines the structure to consist of two structure variables. Then it declares one variable of type and initializes its members. Since its members are structure variables, we used an extra set of braces surrounding the members that belong to the structure variables. However, those extra braces are not necessary; they just make the code easier to read.\n\nYou can access the members of a structure variable using the member access operator. You put the name of the structure variable on the left side of the operator, and the name of the member on the right side.\n\nYou can also access the members of a structure variable which is itself a member of a structure variable.\n\nYou can create structures with integer members of nonstandard sizes, called bit fields. You do this by specifying an integer ( , , , etc.) member as usual, and inserting a colon and the number of bits that the member should occupy in between the member’s name and the semicolon.\n\nThat example defines a structure type with two bit fields, and , which take up 2 bits and 4 bits, respectively. can hold values from 0 to 3, and can hold values from 0 to 15. Notice that these bit fields were declared as ; had they been signed integers, then their ranges would have been from -2 to 1, and from -8 to 7, respectively.\n\nMore generally, the range of an unsigned bit field of N bits is from 0 to 2^N - 1, and the range of a signed bit field of N bits is from -(2^N) / 2 to ((2^N) / 2) - 1.\n\nBit fields can be specified without a name in order to control which actual bits within the containing unit are used. However, the effect of this is not very portable and it is rarely useful. You can also specify a bit field of size 0, which indicates that subsequent bit fields not further bit fields should be packed into the unit containing the previous bit field. This is likewise not generally useful.\n\nYou may not take the address of a bit field with the address operator (see Pointer Operators).\n\nThe size of a structure type is equal to the sum of the size of all of its members, possibly including padding to cause the structure type to align to a particular byte boundary. The details vary depending on your computer platform, but it would not be atypical to see structures padded to align on four- or eight-byte boundaries. This is done in order to speed up memory accesses of instances of the structure type.\n\nAs a GNU extension, GCC allows structures with no members. Such structures have zero size.\n\nIf you wish to explicitly omit padding from your structure types (which may, in turn, decrease the speed of structure memory accesses), then GCC provides multiple methods of turning packing off. The quick and easy method is to use the compiler option. For more details on omitting packing, please see the GCC manual which corresponds to your version of the compiler.\n\nAn array is a data structure that lets you store one or more elements consecutively in memory. In C, array elements are indexed beginning at position zero, not one.\n\nYou declare an array by specifying the data type for its elements, its name, and the number of elements it can store. Here is an example that declares an array that can store ten integers:\n\nFor standard C code, the number of elements in an array must be positive.\n\nAs a GNU extension, the number of elements can be as small as zero. Zero-length arrays are useful as the last element of a structure which is really a header for a variable-length object:\n\nAnother GNU extension allows you to declare an array size using variables, rather than only constants. For example, here is a function definition that declares an array using its parameter as the number of elements:\n\nYou can initialize the elements in an array when you declare it by listing the initializing values, separated by commas, in a set of braces. Here is an example:\n\nYou don’t have to explicitly initialize all of the array elements. For example, this code initializes the first three elements as specified, and then initializes the last two elements to a default value of zero:\n\nWhen using either ISO C99, or C89 with GNU extensions, you can initialize array elements out of order, by specifying which array indices to initialize. To do this, include the array index in brackets, and optionally the assignment operator, before the value. Here is an example:\n\nOr, using the assignment operator:\n\nBoth of those examples are equivalent to:\n\nWhen using GNU extensions, you can initialize a range of elements to the same value, by specifying the first and last indices, in the form . Here is an example:\n\nThat initializes elements 0 through 9 to 1, elements 10 through 98 to 2, and element 99 to 3. (You also could explicitly write .) Also, notice that you must have spaces on both sides of the ‘ ’.\n\nIf you initialize every element of an array, then you do not have to specify its size; its size is determined by the number of elements you initialize. Here is an example:\n\nAlthough this does not explicitly state that the array has five elements using , it initializes five elements, so that is how many it has.\n\nAlternately, if you specify which elements to initialize, then the size of the array is equal to the highest element number initialized, plus one. For example:\n\nIn that example, only four elements are initialized, but the last one initialized is element number 99, so there are 100 elements.\n\nYou can access the elements of an array by specifying the array name, followed by the element index, enclosed in brackets. Remember that the array elements are numbered starting with zero. Here is an example:\n\nThat assigns the value 5 to the first element in the array, at position zero. You can treat individual array elements like variables of whatever data type the array is made up of. For example, if you have an array made of a structure data type, you can access the structure elements like this:\n\nYou can make multidimensional arrays, or “arrays of arrays”. You do this by adding an extra set of brackets and array lengths for every additional dimension you want your array to have. For example, here is a declaration for a two-dimensional array that holds five elements in each dimension (a two-element array consisting of five-element arrays):\n\nMultidimensional array elements are accessed by specifying the desired index of both dimensions:\n\nIn our example, is itself an array. The element is followed by , not by .\n\nYou can use an array of characters to hold a string (see String Constants). The array may be built of either signed or unsigned characters.\n\nWhen you declare the array, you can specify the number of elements it will have. That number will be the maximum number of characters that should be in the string, including the null character used to end the string. If you choose this option, then you do not have to initialize the array when you declare it. Alternately, you can simply initialize the array to a value, and its size will then be exactly large enough to hold whatever string you used to initialize it.\n\nThere are two different ways to initialize the array. You can specify of comma-delimited list of characters enclosed in braces, or you can specify a string literal enclosed in double quotation marks.\n\nHere are some examples:\n\nIn each of these cases, the null character is included at the end of the string, even when not explicitly stated. (Note that if you initialize a string using an array of individual characters, then the null character is not guaranteed to be present. It might be, but such an occurrence would be one of chance, and should not be relied upon.)\n\nAfter initialization, you cannot assign a new string literal to an array using the assignment operator. For example, this will not work:\n\nHowever, there are functions in the GNU C library that perform operations (including copy) on string arrays. You can also change one character at a time, by accessing individual string elements as you would any other array:\n\nIt is possible for you to explicitly state the number of elements in the array, and then initialize it using a string that has more characters than there are elements in the array. This is not a good thing. The larger string will not override the previously specified size of the array, and you will get a compile-time warning. Since the original array size remains, any part of the string that exceeds that original size is being written to a memory location that was not allocated for it.\n\nYou can create an array of a union type just as you can an array of a primitive data type.\n\nThat example creates a 3-element array of variables called . You can also initialize the first members of the elements of a number array:\n\nThe additional inner grouping braces are optional.\n\nAfter initialization, you can still access the union members in the array using the member access operator. You put the array name and element number (enclosed in brackets) to the left of the operator, and the member name to the right.\n\nYou can create an array of a structure type just as you can an array of a primitive data type.\n\nThat example creates a 3-element array of variables called . You can also initialize the elements of a structure array:\n\nAs with initializing structures which contain structure members, the additional inner grouping braces are optional. But, if you use the additional braces, then you can partially initialize some of the structures in the array, and fully initialize others:\n\nIn that example, the first element of the array has only its member initialized. Because of the grouping braces, the value 4 is assigned to the member of the second array element, not to the member of the first element, as would be the case without the grouping braces.\n\nAfter initialization, you can still access the structure members in the array using the member access operator. You put the array name and element number (enclosed in brackets) to the left of the operator, and the member name to the right.\n\nPointers hold memory addresses of stored constants or variables. For any data type, including both primitive types and custom types, you can create a pointer that holds the memory address of an instance of that type.\n\nYou declare a pointer by specifying a name for it and a data type. The data type indicates of what type of variable the pointer will hold memory addresses.\n\nTo declare a pointer, include the indirection operator (see Pointer Operators) before the identifier. Here is the general form of a pointer declaration:\n\nWhite space is not significant around the indirection operator:\n\nHere is an example of declaring a pointer to hold the address of an variable:\n\nBe careful, though: when declaring multiple pointers in the same statement, you must explicitly declare each as a pointer, using the indirection operator:\n\nYou can initialize a pointer when you first declare it by specifying a variable address to store in it. For example, the following code declares an variable ‘ ’, and a pointer which is initialized with the address of ‘ ’:\n\nNote the use of the address operator (see Pointer Operators), used to get the memory address of a variable. After you declare a pointer, you do not use the indirection operator with the pointer’s name when assigning it a new address to point to. On the contrary, that would change the value of the variable that the points to, not the value of the pointer itself. For example:\n\nThe value stored in a pointer is an integral number: a location within the computer’s memory space. If you are so inclined, you can assign pointer values explicitly using literal integers, casting them to the appropriate pointer type. However, we do not recommend this practice unless you need to have extremely fine-tuned control over what is stored in memory, and you know exactly what you are doing. It would be all too easy to accidentally overwrite something that you did not intend to. Most uses of this technique are also non-portable.\n\nIt is important to note that if you do not initialize a pointer with the address of some other existing object, it points nowhere in particular and will likely make your program crash if you use it (formally, this kind of thing is called undefined behavior).\n\nYou can create a pointer to a union type just as you can a pointer to a primitive data type.\n\nThat example creates a new union type, , and declares (and initializes the first member of) a variable of that type named . Finally, it declares a pointer to the type , and gives it the address of .\n\nYou can access the members of a union variable through a pointer, but you can’t use the regular member access operator anymore. Instead, you have to use the indirect member access operator (see Member Access Expressions). Continuing with the previous example, the following example will change the value of the first member of :\n\nNow the member in is 450.\n\nYou can create a pointer to a structure type just as you can a pointer to a primitive data type.\n\nThat example creates a new structure type, , and declares (and initializes) a variable of that type named . Finally, it declares a pointer to the type , and gives it the address of .\n\nYou can access the members of a structure variable through a pointer, but you can’t use the regular member access operator anymore. Instead, you have to use the indirect member access operator (see Member Access Expressions). Continuing with the previous example, the following example will change the values of the members of :\n\nNow the and members in are 5.1 and 6.2, respectively.\n\nYou can define structures, unions, and enumerations without listing their members (or values, in the case of enumerations). Doing so results in an incomplete type. You can’t declare variables of incomplete types, but you can work with pointers to those types.\n\nAt some time later in your program you will want to complete the type. You do this by defining it as you usually would:\n\nThis technique is commonly used to for linked lists:\n\nThere are two type qualifiers that you can prepend to your variable declarations which change how the variables may be accessed: and .\n\ncauses the variable to be read-only; after initialization, its value may not be changed.\n\nIn addition to helping to prevent accidental value changes, declaring variables with can aid the compiler in code optimization.\n\ntells the compiler that the variable is explicitly changeable, and seemingly useless accesses of the variable (for instance, via pointers) should not be optimized away. You might use variables to store data that is updated via callback functions or signal handlers. Sequence Points and Signal Delivery.\n\nThere are four storage class specifiers that you can prepend to your variable declarations which change how the variables are stored in memory: , , , and .\n\nYou use for variables which are local to a function, and whose values should be discarded upon return from the function in which they are declared. This is the default behavior for variables declared within functions.\n\nis nearly identical in purpose to , except that it also suggests to the compiler that the variable will be heavily used, and, if possible, should be stored in a register. You cannot use the address-of operator to obtain the address of a variable declared with . This means that you cannot refer to the elements of an array declared with storage class . In fact the only thing you can do with such an array is measure its size with . GCC normally makes good choices about which values to hold in registers, and so is not often used.\n\nis essentially the opposite of : when applied to variables within a function or block, these variables will retain their value even when the function or block is finished. This is known as static storage duration.\n\nYou can also declare variables (or functions) at the top level (that is, not inside a function) to be ; such variables are visible (global) to the current source file (but not other source files). This gives an unfortunate double meaning to ; this second meaning is known as static linkage. Two functions or variables having static linkage in separate files are entirely separate; neither is visible outside the file in which it is declared.\n\nUninitialized variables that are declared as are given default values of , , or , depending on the type. Uninitialized variables that are declared as or (including the default usage of ) are left uninitialized, and hence should not be assumed to hold any particular value.\n\nis useful for declaring variables that you want to be visible to all source files that are linked into your project. You cannot initialize a variable in an declaration, as no space is actually allocated during the declaration. You must make both an declaration (typically in a header file that is included by the other source files which need to access the variable) and a non- declaration which is where space is actually allocated to store the variable. The declaration may be repeated multiple times.\n\nSee Program Structure and Scope, for related information.\n\nSometimes it is convenient to give a new name to a type. You can do this using the statement. See The typedef Statement, for more information.\n\nAn expression consists of at least one operand and zero or more operators. Operands are typed objects such as constants, variables, and function calls that return values. Here are some examples:\n\nInnermost expressions are evaluated first. In the above example, and evaluate to and , respectively. Then is subtracted from , resulting in . Finally, is multiplied by , resulting in . The outermost parentheses are completely optional.\n\nAn operator specifies an operation to be performed on its operand(s). Operators may have one, two, or three operands, depending on the operator.\n\nAssignment operators store values in variables. C provides several variations of assignment operators.\n\nThe standard assignment operator simply stores the value of its right operand in the variable specified by its left operand. As with all assignment operators, the left operand (commonly referred to as the “lvalue”) cannot be a literal or constant value.\n\nNote that, unlike the other assignment operators described below, you can use the plain assignment operator to store values of a structure type.\n\nCompound assignment operators perform an operation involving both the left and right operands, and then assign the resulting expression to the left operand. Here is a list of the compound assignment operators, and a brief description of what they do:\n• Adds the two operands together, and then assign the result of the addition to the left operand.\n• Subtract the right operand from the left operand, and then assign the result of the subtraction to the left operand.\n• Multiply the two operands together, and then assign the result of the multiplication to the left operand.\n• Divide the left operand by the right operand, and assign the result of the division to the left operand.\n• Perform modular division on the two operands, and assign the result of the division to the left operand.\n• Perform a left shift operation on the left operand, shifting by the number of bits specified by the right operand, and assign the result of the shift to the left operand.\n• Perform a right shift operation on the left operand, shifting by the number of bits specified by the right operand, and assign the result of the shift to the left operand.\n• Perform a bitwise conjunction operation on the two operands, and assign the result of the operation to the left operand.\n• Performs a bitwise exclusive disjunction operation on the two operands, and assign the result of the operation to the left operand.\n• Performs a bitwise inclusive disjunction operation on the two operands, and assign the result of the operation to the left operand.\n\nHere is an example of using one of the compound assignment operators:\n\nSince there are no side effects wrought by evaluating the variable as an lvalue, the above code produces the same result as:\n\nThe increment operator adds 1 to its operand. The operand must be a either a variable of one of the primitive data types, a pointer, or an enumeration variable. You can apply the increment operator either before or after the operand. Here are some examples:\n\nA prefix increment adds 1 before the operand is evaluated. A postfix increment adds 1 after the operand is evaluated. In the previous examples, changing the position of the operator would make no difference. However, there are cases where it does make a difference:\n\nThe output of the above example is:\n\nLikewise, you can subtract 1 from an operand using the decrement operator:\n\nThe concepts of prefix and postfix application apply here as with the increment operator.\n\nC provides operators for standard arithmetic operations: addition, subtraction, multiplication, and division, along with modular division and negation. Usage of these operators is straightforward; here are some examples:\n\nYou can add and subtract memory pointers, but you cannot multiply or divide them.\n\nInteger division of positive values truncates towards zero, so 5/3 is 1. However, if either operand is negative, the direction of rounding is implementation-defined. Signed Integer Division for information about overflow in signed integer division.\n\nYou use the modulus operator to obtain the remainder produced by dividing its two operands. You put the operands on either side of the operator, and it does matter which operand goes on which side: and do not have the same result. The operands must be expressions of a primitive data type.\n\nModular division returns the remainder produced after performing integer division on the two operands. The operands must be of a primitive integer type.\n\nIf the operand you use with the negative operator is of an unsigned data type, then the result cannot negative, but rather is the maximum value of the unsigned data type, minus the value of the operand.\n\nMany systems use twos-complement arithmetic, and on such systems the most negative value a signed type can hold is further away from zero than the most positive value. For example, on one platform, this program:\n\nTrivially, you can also apply a positive operator to a numeric expression:\n\nNumeric values are assumed to be positive unless explicitly made negative, so this operator has no effect on program operation.\n\nAs a GNU extension, you can use the complex conjugation operator to perform complex conjugation on its operand — that is, it reverses the sign of its imaginary component. The operand must be an expression of a complex number type. Here is an example:\n\nSince an imaginary number (a + bi) multiplied by its conjugate is equal to a^2 + b^2, the above statement will print 314, which is equal to 25 + 289.\n\nYou use the comparison operators to determine how two operands relate to each other: are they equal to each other, is one larger than the other, is one smaller than the other, and so on. When you use any of the comparison operators, the result is either 1 or 0, meaning true or false, respectively.\n\nThe equal-to operator tests its two operands for equality. The result is 1 if the operands are equal, and 0 if the operands are not equal.\n\nThe not-equal-to operator tests its two operands for inequality. The result is 1 if the operands are not equal, and 0 if the operands are equal.\n\nComparing floating-point values for exact equality or inequality can produce unexpected results. Real Number Types for more information.\n\nYou can compare function pointers for equality or inequality; the comparison tests if two function pointers point to the same function or not.\n\nBeyond equality and inequality, there are operators you can use to test if one value is less than, greater than, less-than-or-equal-to, or greater-than-or-equal-to another value. Here are some code samples that exemplify usage of these operators:\n\nLogical operators test the truth value of a pair of operands. Any nonzero expression is considered true in C, while an expression that evaluates to zero is considered false.\n\nThe logical conjunction operator tests if two expressions are both true. If the first expression is false, then the second expression is not evaluated.\n\nThe logical disjunction operator tests if at least one of two expressions it true. If the first expression is true, then the second expression is not evaluated.\n\nYou can prepend a logical expression with a negation operator to flip the truth value:\n\nSince the second operand in a logical expression pair is not necessarily evaluated, you can write code with perhaps unintuitive results:\n\nIf is ever zero, then not only would not be called, but would not be incremented. If you intend to increment regardless of the value of , you should do so outside of the conjunction expression.\n\nYou use the left-shift operator to shift its first operand’s bits to the left. The second operand denotes the number of bit places to shift. Bits shifted off the left side of the value are discarded; new bits added on the right side will all be 0.\n\nSimilarly, you use the right-shift operator to shift its first operand’s bits to the right. Bits shifted off the right side are discarded; new bits added on the left side are usually 0, but if the first operand is a signed negative value, then the added bits will be either 0 or whatever value was previously in the leftmost bit position.\n\nFor both and , if the second operand is greater than the bit-width of the first operand, or the second operand is negative, the behavior is undefined.\n\nYou can use the shift operators to perform a variety of interesting hacks. For example, given a date with the day of the month numbered as , the month numbered as , and the year , you can store the entire date in a single number :\n\nYou can then extract the original day, month, and year out of using a combination of shift operators and modular division:\n\nC provides operators for performing bitwise conjunction, inclusive disjunction, exclusive disjunction, and negation (complement).\n\nBiwise conjunction examines each bit in its two operands, and when two corresponding bits are both 1, the resulting bit is 1. All other resulting bits are 0. Here is an example of how this works, using binary numbers:\n\nBitwise inclusive disjunction examines each bit in its two operands, and when two corresponding bits are both 0, the resulting bit is 0. All other resulting bits are 1.\n\nBitwise exclusive disjunction examines each bit in its two operands, and when two corresponding bits are different, the resulting bit is 1. All other resulting bits are 0.\n\nBitwise negation reverses each bit in its operand:\n\nIn C, you can only use these operators with operands of an integer (or character) type, and for maximum portability, you should only use the bitwise negation operator with unsigned integer types. Here are some examples of using these operators in C code:\n\nYou can use the address operator to obtain the memory address of an object.\n\nIt is not necessary to use this operator to obtain the address of a function, although you can:\n\nFunction pointers and data pointers are not compatible, in the sense that you cannot expect to store the address of a function into a data pointer, and then copy that into a function pointer and call it successfully. It might work on some systems, but it’s not a portable technique.\n\nAs a GNU extension to C89, you can also obtain the address of a label with the label address operator . The result is a pointer which can be used with . See The goto Statement.\n\nGiven a memory address stored in a pointer, you can use the indirection operator to obtain the value stored at the address. (This is called dereferencing the pointer.)\n\nAvoid using dereferencing pointers that have not been initialized to a known memory location.\n\nYou can use the operator to obtain the size (in bytes) of the data type of its operand. The operand may be an actual type specifier (such as or ), as well as any valid expression. When the operand is a type name, it must be enclosed in parentheses. Here are some examples:\n\nThe result of the operator is of a type called , which is defined in the header file . is an unsigned integer type, perhaps identical to or ; it varies from system to system.\n\nThe type is often a convenient type for a loop index, since it is guaranteed to be able to hold the number of elements in any array; this is not the case with , for example.\n\nThe operator can be used to automatically compute the number of elements in an array:\n\nThere are two cases where this technique does not work. The first is where the array element has zero size (GCC supports zero-sized structures as a GNU extension). The second is where the array is in fact a function parameter (see Function Parameters).\n\nYou can use a type cast to explicitly cause an expression to be of a specified data type. A type cast consists of a type specifier enclosed in parentheses, followed by an expression. To ensure proper casting, you should also enclose the expression that follows the type specifier in parentheses. Here is an example:\n\nIn that example, since and are both integers, integer division is performed, and even though is a floating-point variable, it receives the value 2. Explicitly casting the result of the division to does no good, because the computed value of is already 2.\n\nTo fix this problem, you need to convert one of the operands to a floating-point type before the division takes place:\n\nHere, a floating-point value close to 2.333… is assigned to .\n\nType casting only works with scalar types (that is, integer, floating-point or pointer types). Therefore, this is not allowed:\n\nYou can access array elements by specifying the name of the array, and the array subscript (or index, or element number) enclosed in brackets. Here is an example, supposing an integer array called :\n\nThe array subscript expression is defined as being identical to the expression . This means that many uses of an array name are equivalent to a pointer expression. It also means that you cannot subscript an array having the storage class.\n\nA call to any function which returns a value is an expression.\n\nYou use the comma operator to separate two (ostensibly related) expressions. For instance, the first expression might produce a value that is used by the second expression:\n\nMore commonly, the comma operator is used in statements, like this:\n\nThis lets you conveniently set, monitor, and modify multiple control expressions for the statement.\n\nA comma is also used to separate function parameters; however, this is not the comma operator in action. In fact, if the comma operator is used as we have discussed here in a function call, then the compiler will interpret that as calling the function with an extra parameter.\n\nIf you want to use the comma operator in a function argument, you need to put parentheses around it. That’s because commas in a function argument list have a different meaning: they separate arguments. Thus,\n\nis interpreted as a function call with four arguments, but\n\nis a function call with just three arguments. (The second argument is .)\n\nYou can use the member access operator to access the members of a structure or union variable. You put the name of the structure variable on the left side of the operator, and the name of the member on the right side.\n\nYou can also access the members of a structure or union variable via a pointer by using the indirect member access operator . is equivalent to .\n\nYou use the conditional operator to cause the entire conditional expression to evaluate to either its second or its third operand, based on the truth value of its first operand. Here’s an example:\n\nIf expression is true, then expression is evaluated and the result is the value of . Otherwise, expression is evaluated and the result is .\n\nExpressions and must be compatible. That is, they must both be\n• pointers to compatible types (one of which might be the NULL pointer)\n\nAlternatively, one operand is a pointer and the other is a pointer.\n\nHere is an example\n\nHere, if equals 5, then will receive the value of . Otherwise, will receive the value of . This can be considered a shorthand method for writing a simple … statement. The following example will accomplish the same task as the previous one:\n\nIf the first operand of the conditional operator is true, then the third operand is never evaluated. Similarly, if the first operand is false, then the second operand is never evaluated. The first operand is always evaluated.\n\nAs a GNU C extension, you can build an expression using compound statement enclosed in parentheses. This allows you to included loops, switches, and local variables within an expression.\n\nRecall that a compound statement (also known as a block) is a sequence of statements surrounded by braces. In this construct, parentheses go around the braces. Here is an example:\n\nThat is a valid (though slightly more complex than necessary) expression for the absolute value of .\n\nThe last thing in the compound statement should be an expression followed by a semicolon; the value of this subexpression serves as the value of the entire construct. (If you use some other kind of statement last within the braces, the construct has type , and thus effectively no value.)\n\nThis feature is especially useful in making macro definitions “safe” (so that they evaluate each operand exactly once). For example, the “maximum” function is commonly defined as a macro in standard C as follows:\n\nBut this definition computes either or twice, with bad results if the operand has side effects. In GNU C, if you know the type of the operands (here let’s assume ), you can define the macro safely as follows:\n\nIf you don’t know the type of the operand, you can still do this, but you must use expressions or type naming.\n\nEmbedded statements are not allowed in constant expressions, such as the value of an enumeration constant, the width of a bit field, or the initial value of a static variable.\n\nWhen an expression contains multiple operators, such as , the operators are grouped based on rules of precedence. For instance, the meaning of that expression is to call the function with no arguments, multiply the result by , then add that result to . That’s what the C rules of operator precedence determine for this expression.\n\nThe following is a list of types of expressions, presented in order of highest precedence first. Sometimes two or more operators have equal precedence; all those operators are applied from left to right unless stated otherwise.\n• Unary operators, including logical negation, bitwise complement, increment, decrement, unary positive, unary negative, indirection operator, address operator, type casting, and expressions. When several unary operators are consecutive, the later ones are nested within the earlier ones: means .\n• Conditional expressions (using ). When used as subexpressions, these are evaluated right to left.\n• All assignment expressions, including compound assignment. When multiple assignment statements appear as subexpressions in a single larger expression, they are evaluated right to left.\n\nThe above list is somewhat dry and is apparently straightforward, but it does hide some pitfalls. Take this example:\n\nHere is incremented as a side effect of the expression, but takes the value of rather than , since the unary operators bind right to left. There are other examples of potential surprises lurking behind the C precedence table. For this reason if there is the slightest risk of the reader misunderstanding the meaning of the program, you should use parentheses to make your meaning clear.\n\nIn C you cannot assume that multiple subexpressions are evaluated in the order that seems natural. For instance, consider the expression . Does this increment before or after calling the function ? The compiler could do it in either order, so you cannot make assumptions.\n\nThis manual explains the semantics of the C language in the abstract. However, an actual compiler translates source code into specific actions in an actual computer, and may re-order operations for the sake of efficiency. The correspondence between the program you write and the things the computer actually does are specified in terms of side effects and sequence points.\n\nA side effect is one of the following:\n• a call to a function which performs any of the above side effects\n\nThese are essentially the externally-visible effects of running a program. They are called side effects because they are effects of expression evalation beyond the expression’s actual resulting value.\n\nThe compiler is allowed to perform the operations of your program in an order different to the order implied by the source of your program, provided that in the end all the necessary side effects actually take place. The compiler is also allowed to entirely omit some operations; for example it’s allowed to skip evaluating part of an expression if it can be certain that the value is not used and evaluating that part of the expression won’t produce any needed side effects.\n\nAnother requirement on the compiler is that side effects should take place in the correct order. In order to provide this without over-constraining the compiler, the C89 and C90 standards specify a list of sequence points. A sequence point is one of the following:\n• a call to a function (after argument evaluation is complete)\n• the end of the left-hand operand of the and operator\n• the end of the left-hand operand of the or operator\n• the end of the left-hand operand of the comma operator\n• the end of the first operand of the ternary operator\n• the end of an initialisation expression\n• the end of an expression statement (i.e. an expression followed by )\n• the end of the controlling expression of an or statement\n• the end of the controlling expression of a or statement\n• the end of any of the three controlling expressions of a statement\n• the end of the expression in a return statement\n• immediately before the return of a library function\n• after the actions associated with an item of formatted I/O (as used for example with the or the and famlies of functions).\n• immediately before and after a call to a comparison function (as called for example by )\n\nAt a sequence point, all the side effects of previous expression evaluations must be complete, and no side effects of later evaluations may have taken place.\n\nThis may seem a little hard to grasp, but there is another way to consider this. Imagine you wrote a library (some of whose functions are external and perhaps others not) and compiled it, allowing someone else to call one of your functions from their code. The definitions above ensure that, at the time they call your function, the data they pass in has values which are consistent with the behaviour specified by the abstract machine, and any data returned by your function has a state which is also consistent with the abstract machine. This includes data accessible via pointers (i.e. not just function parameters and identifiers with external linkage).\n\nThe above is a slight simplification, since compilers exist that perform whole-program optimisation at link time. Importantly however, although they might perform optimisations, the visible side effects of the program must be the same as if they were produced by the abstract machine.\n\nis quite normal and no doubt occurs in many programs. However, the quite similar code fragment\n\nis a little harder to understand; what is the final value of ? The C standards (both C89 and C99) both forbid this construct in conforming programs.\n• an object may have its stored value modified at most once by the evaluation of an expression\n• the prior value of the object shall be read only to determine the value to be stored.\n\nThe first of these two conditions forbids expressions like . The second condition forbids expressions like .\n\nLet’s go back to the example we used to introduce the problem of the order of evaluation, . Suppose the code actually looks like this:\n\nIs this code allowed in a standard-conforming program? Although the expression in modifies twice, this is not a problem. Let’s look at the two possible cases.\n\nSo, we see that our program is standard-conforming. Notice that the above argument does not actually depend on the details of the body of the function . It only depends on the function containing something ending in a sequence point – in our example this is a return statement, but an expression statement or a full declarator would do just as well.\n\nHowever, the result of executing this code depends on the order of evaluation of the operands of . If the left-hand operand is evaluated first, returns 6. Otherwise, it returns 303. The C standard does not specify in which order the operands should be evaluated, and also does not require an implementation either to document the order or even to stick to one order. The effect of this code is unspecified, meaning that one of several specific things will happen, but the C standards do not say which.\n\nSignals are mainly documented in the GNU C Library manual rather than this document, even though the C standards consider the compiler and the C library together to be “the implementation”.\n\nWhen a signal is received, this will happen between sequence points. Side effects on objects prior to the previous sequence point will have occurred, but other updates may not have occurred yet. This even applies to straight assignments, such as , because the code generated for that statement may require more than one instruction, meaning that it can be interrupted part-way through by the delivery of a signal.\n\nThe C standard is quite restrictive about what data access can occur within a signal handler. They can of course use variables, but in terms of reading or writing other objects, they must be . The type qualifier ensures that access to the variable in the other parts of the program doesn’t span sequence points and the use of the type ensures that changes to the variable are atomic with respect to signal delivery.\n\nThe POSIX standard also allows a small number of library functions to be called from a signal handler. These functions are referred to as the set of async-signal-safe functions. If your program is intended to run on a POSIX system but not on other systems, you can safely call these from your signal handler too.\n\nYou write statements to cause actions and to control flow within your programs. You can also write statements that do not do anything at all, or do things that are uselessly trivial.\n\nYou can use labels to identify a section of source code for use with a later (see The goto Statement). A label consists of an identifier (such as those used for variable names) followed by a colon. Here is an example:\n\nYou should be aware that label names do not interfere with other identifier names:\n\nThe ISO C standard mandates that a label must be followed by at least one statement, possibly a null statement (see The Null Statement). GCC will compile code that does not meet this requirement, but be aware that if you violate it, your code may have portability issues.\n\nYou can turn any expression into a statement by adding a semicolon to the end of the expression. Here are some examples:\n\nIn each of those, all that happens is that each expression is evaluated. However, they are useless because they do not store a value anywhere, nor do they actually do anything, other than the evaluation itself. The compiler is free to ignore such statements.\n\nExpression statements are only useful when they have some kind of side effect, such as storing a value, calling a function, or (this is esoteric) causing a fault in the program. Here are some more useful examples:\n\nThe last of those statements, , could potentially cause a fault in the program if the value of is both not a valid pointer and has been declared as .\n\nYou can use the statement to conditionally execute part of your program, based on the truth value of a given expression. Here is the general form of an statement:\n\nIf evaluates to true, then is executed and is not. If evaluates to false, then is executed and is not. The clause is optional.\n\nHere is an actual example:\n\nIf evaluates to true, then the statement is executed. If evaluates to false, then the statement is not executed.\n\nHere is an example using :\n\nYou can use a series of statements to test for multiple conditions:\n\nThis function calculates and displays the date of Easter for the given year :\n\nYou can use the statement to compare one expression with others, and then execute a series of sub-statements based on the result of the comparisons. Here is the general form of a statement:\n\nThe statement compares to each of the expressions, until it finds one that is equal to . Then, the statements following the successful case are executed. All of the expressions compared must be of an integer type, and the expressions must be of a constant integer type (e.g., a literal integer or an expression built of literal integers).\n\nOptionally, you can specify a default case. If doesn’t match any of the specific cases listed prior to the default case, then the statements for the default case are executed. Traditionally, the default case is put after the specific cases, but that isn’t required.\n\nNotice the usage of the statement in each of the cases. This is because, once a matching case is found, not only are its statements executed, but so are the statements for all following cases:\n\nThe output of that example is:\n\nThis is often not desired. Including a statement at the end of each case redirects program flow to after the statement.\n\nAs a GNU C extension, you can also specify a range of consecutive integer values in a single label, like this:\n\nThis has the same effect as the corresponding number of individual labels, one for each integer value from to , inclusive.\n\nThis feature is especially useful for ranges of ASCII character codes:\n\nBe careful to include spaces around the ; otherwise it may be parsed incorrectly when you use it with integer values. For example, write this:\n\ninstead of this:\n\nIt is common to use a statement to handle various possible values of . In this case a portable program should watch out for the possibility that two macros for values in fact have the same value, for example and .\n\nThe statement is a loop statement with an exit test at the beginning of the loop. Here is the general form of the statement:\n\nThe statement first evaluates . If evaluates to true, is executed, and then is evaluated again. continues to execute repeatedly as long as is true after each execution of .\n\nThis example prints the integers from zero through nine:\n\nA statement can also cause a loop to exit.\n\nThe statement is a loop statement with an exit test at the end of the loop. Here is the general form of the statement:\n\nThe statement first executes . After that, it evaluates . If is true, then is executed again. continues to execute repeatedly as long as is true after each execution of .\n\nThis example also prints the integers from zero through nine:\n\nA statement can also cause a loop to exit.\n\nThe statement is a loop statement whose structure allows easy variable initialization, expression testing, and variable modification. It is very convenient for making counter-controlled loops. Here is the general form of the statement:\n\nThe statement first evaluates the expression . Then it evaluates the expression . If is false, then the loop ends and program control resumes after . Otherwise, if is true, then is executed. Finally, is evaluated, and the next iteration of the loop begins with evaluating again.\n\nMost often, assigns values to one or more variables, which are generally used as counters, compares those variables to a predefined expression, and modifies those variables’ values. Here is another example that prints the integers from zero through nine:\n\nFirst, it evaluates , which assigns the value 0. Then, as long as is less than 10, the value of is printed (in the body of the loop). Then is incremented in the clause and the test re-evaluated.\n\nAll three of the expressions in a statement are optional, and any combination of the three is valid. Since the first expression is evaluated only once, it is perhaps the most commonly omitted expression. You could also write the above example as:\n\nIn this example, receives its value prior to the beginning of the statement.\n\nIf you leave out the expression, then the statement is an infinite loop (unless you put a or statement somewhere in ). This is like using as ; it is never false.\n\nThis statement starts printing numbers at 1 and then continues indefinitely, always printing incremented by 1:\n\nIf you leave out the expression, then no progress is made toward completing the loop—at least not as is normally expected with a statement.\n\nThis example prints the number 1 over and over, indefinitely:\n\nPerhaps confusingly, you cannot use the comma operator (see The Comma Operator) for monitoring multiple variables in a statement, because as usual the comma operator discards the result of its left operand. This loop:\n\nIf you need to test two conditions, you will need to use the operator:\n\nA statement can also cause a loop to exit.\n\nHere is an example of a function that computes the summation of squares, given a starting integer to square and an ending integer to square:\n\nA block is a set of zero or more statements enclosed in braces. Blocks are also known as compound statements. Often, a block is used as the body of an statement or a loop statement, to group statements together.\n\nYou can also put blocks inside other blocks:\n\nYou can declare variables inside a block; such variables are local to that block. In C89, declarations must occur before other statements, and so sometimes it is useful to introduce a block simply for this purpose:\n\nThe null statement is merely a semicolon alone.\n\nA null statement does not do anything. It does not store a value anywhere. It does not cause time to pass during the execution of your program.\n\nMost often, a null statement is used as the body of a loop statement, or as one or more of the expressions in a statement. Here is an example of a statement that uses the null statement as the body of the loop (and also calculates the integer square root of , just for fun):\n\nHere is another example that uses the null statement as the body of a loop and also produces output:\n\nA null statement is also sometimes used to follow a label that would otherwise be the last thing in a block.\n\nYou can use the statement to unconditionally jump to a different place in the program. Here is the general form of a statement:\n\nYou have to specify a label to jump to; when the statement is executed, program control jumps to that label. See Labels. Here is an example:\n\nThe label can be anywhere in the same function as the statement that jumps to it, but a statement cannot jump to a label in a different function.\n\nYou can use statements to simulate loop statements, but we do not recommend it—it makes the program harder to read, and GCC cannot optimize it as well. You should use , , and statements instead of statements, when possible.\n\nAs an extension, GCC allows a goto statement to jump to an address specified by a variable. To make this work, you also need to take the address of a label by using the unary operator (not ). Here is a contrived example:\n\nYou can use the statement to terminate a , , , or statement. Here is an example:\n\nThat example prints numbers from 1 to 7. When is incremented to 8, is true, so the statement is executed, terminating the loop prematurely.\n\nIf you put a statement inside of a loop or statement which itself is inside of a loop or statement, the only terminates the innermost loop or statement.\n\nYou can use the statement in loops to terminate an iteration of the loop and begin the next iteration. Here is an example:\n\nIf you put a statement inside a loop which itself is inside a loop, then it affects only the innermost loop.\n\nYou can use the statement to end the execution of a function and return program control to the function that called it. Here is the general form of the statement:\n\nis an optional expression to return. If the function’s return type is , then it is invalid to return an expression. You can, however, use the statement without a return value.\n\nIf the function’s return type is not the same as the type of , and automatic type conversion cannot be performed, then returning is invalid.\n\nIf the function’s return type is not and no return value is specified, then the statement is valid unless the function is called in a context that requires a return value. For example:\n\nIn that case, the function was called in a context that required a return value, so the value could be assigned to .\n\nEven in contexts where a return value is not required, it is a bad idea for a non- function to omit the return value. With GCC, you can use the command line option to issue a warning if you omit the return value in such functions.\n\nHere are some examples of using the statement, in both a and non- function:\n\nYou can use the statement to create new names for data types. Here is the general form of the statement:\n\nis the existing name for the type, and may consist of more than one token (e.g., ). is the resulting new name for the type, and must be a single identifier. Creating this new name for the type does not cause the old name to cease to exist. Here are some examples:\n\nIn the case of custom data types, you can use to make a new name for the type while defining the type:\n\nTo make a type definition of an array, you first provide the type of the element, and then establish the number of elements at the end of the type definition:\n\nWhen selecting names for types, you should avoid ending your type names with a suffix. The compiler will allow you to do this, but the POSIX standard reserves use of the suffix for standard library type names.\n\nYou can write functions to separate parts of your program into distinct subprocedures. To write a function, you must at least create a function definition. It is a good idea also to have an explicit function declaration; you don’t have to, but if you leave it out, then the default implicit declaration might not match the function itself, and you will get some compile-time warnings.\n\nEvery program requires at least one function, called . That is where the program’s execution begins.\n\nYou write a function declaration to specify the name of a function, a list of parameters, and the function’s return type. A function declaration ends with a semicolon. Here is the general form:\n\nindicates the data type of the value returned by the function. You can declare a function that doesn’t return anything by using the return type .\n\ncan be any valid identifier (see Identifiers).\n\nconsists of zero or more parameters, separated by commas. A typical parameter consists of a data type and an optional name for the parameter. You can also declare a function that has a variable number of parameters (see Variable Length Parameter Lists), or no parameters using . Leaving out entirely also indicates no parameters, but it is better to specify it explicitly with .\n\nHere is an example of a function declaration with two parameters:\n\nIf you include a name for a parameter, the name immediately follows the data type, like this:\n\nThe parameter names can be any identifier (see Identifiers), and if you have more than one parameter, you can’t use the same name more than once within a single declaration. The parameter names in the declaration need not match the names in the definition.\n\nYou should write the function declaration above the first use of the function. You can put it in a header file and use the directive to include that function declaration in any source code files that use the function.\n\nYou write a function definition to specify what a function actually does. A function definition consists of information regarding the function’s name, return type, and types and names of parameters, along with the body of the function. The function body is a series of statements enclosed in braces; in fact it is simply a block (see Blocks).\n\nHere is the general form of a function definition:\n\nand are the same as what you use in the function declaration (see Function Declarations).\n\nis the same as the parameter list used in the function declaration (see Function Declarations), except you must include names for the parameters in a function definition.\n\nHere is an simple example of a function definition—it takes two integers as its parameters and returns the sum of them as its return value:\n\nFor compatibility with the original design of C, you can also specify the type of the function parameters after the closing parenthesis of the parameter list, like this:\n\nHowever, we strongly discourage this style of coding; it can cause subtle problems with type casting, among other problems.\n\nYou can call a function by using its name and supplying any needed parameters. Here is the general form of a function call:\n\nA function call can make up an entire statement, or it can be used as a subexpression. Here is an example of a standalone function call:\n\nIn that example, the function ‘ ’ is called with the parameter .\n\nHere is an example of a function call used as a subexpression:\n\nSupposing that the function ‘ ’ squares its parameter, the above example assigns the value 25 to .\n\nIf a parameter takes more than one argument, you separate parameters with commas:\n\nFunction parameters can be any expression—a literal value, a value stored in variable, an address in memory, or a more complex expression built by combining these.\n\nWithin the function body, the parameter is a local copy of the value passed into the function; you cannot change the value passed in by changing the local copy.\n\nIn that example, even though the parameter is modified in the function ‘ ’, the variable that is passed to the function does not change. If you wish to use the function to change the original value of , then you would have to incorporate the function call into an assignment statement:\n\nIf the value that you pass to a function is a memory address (that is, a pointer), then you can access (and change) the data stored at the memory address. This achieves an effect similar to pass-by-reference in other languages, but is not the same: the memory address is simply a value, just like any other value, and cannot itself be changed. The difference between passing a pointer and passing an integer lies in what you can do using the value within the function.\n\nHere is an example of calling a function with a pointer parameter:\n\nThe formal parameter for the function is of type pointer-to- , and we call the function by passing it the address of a variable of type . By dereferencing the pointer within the function body, we can both see and change the value stored in the address. The above changes the value of to ‘ ’.\n\nEven if you don’t want to change the value stored in the address, passing the address of a variable rather than the variable itself can be useful if the variable type is large and you need to conserve memory space or limit the performance impact of parameter copying. For example:\n\nIn this case, unless you are working on a computer with very large memory addresses, it will take less memory to pass a pointer to the structure than to pass an instance of the structure.\n\nOne type of parameter that is always passed as a pointer is any sort of array:\n\nIn this example, calling the function with the parameter does not copy the entire array into a new local parameter within ; rather, it passes as a pointer to the first element in . Be careful, though: within the function, you cannot use to determine the size of the array — instead tells you the size of the pointer . Indeed, the above code is equivalent to:\n\nExplicitly specifying the length of the array in the parameter declaration will not help. If you really need to pass an array by value, you can wrap it in a , though doing this will rarely be useful (passing a -qualified pointer is normally sufficient to indicate that the caller should not modify the array).\n\nYou can write a function that takes a variable number of arguments; these are called variadic functions. To do this, the function needs to have at least one parameter of a known data type, but the remaining parameters are optional, and can vary in both quantity and data type.\n\nYou list the initial parameters as normal, but then after that, use an ellipsis: ‘ ’. Here is an example function prototype:\n\nTo work with the optional parameters in the function definition, you need to use macros that are defined in the library header file ‘ ’, so you must that file. For a detailed description of these macros, see manual’s section on variadic functions.\n\nHere is an example:\n\nTo use optional parameters, you need to have a way to know how many there are. This can vary, so it can’t be hard-coded, but if you don’t know how many optional parameters you have, then you could have difficulty knowing when to stop using the ‘ ’ function. In the above example, the first parameter to the ‘ ’ function, ‘ ’, is the number of optional parameters actually passed. So, we might call the function like this:\n\nThe first parameter indicates how many optional parameters follow it.\n\nAlso, note that you don’t actually need to use ‘ ’ function. In fact, with GCC it doesn’t do anything at all. However, you might want to include it to maximize compatibility with other compilers.\n\nYou can also call a function identified by a pointer. The indirection operator is optional when doing this.\n\nEvery program requires at least one function, called ‘ ’. This is where the program begins executing. You do not need to write a declaration or prototype for , but you do need to define it.\n\nThe return type for is always . You do not have to specify the return type for , but you can. However, you cannot specify that it has a return type other than .\n\nIn general, the return value from indicates the program’s exit status. A value of zero or EXIT_SUCCESS indicates success and EXIT_FAILURE indicates an error. Otherwise, the significance of the value returned is implementation-defined.\n\nReaching the at the end of without a return, or executing a statement with no value (that is, ) are both equivalent. In C89, the effect of this is undefined, but in C99 the effect is equivalent to .\n\nYou can write your function to have no parameters (that is, as ), or to accept parameters from the command line. Here is a very simple function with no parameters:\n\nTo accept command line parameters, you need to have two parameters in the function, followed by . You can change the names of those parameters, but they must have those data types— and array of pointers to . is the number of command line parameters, including the name of the program itself. is an array of the parameters, as character strings. , the first element in the array, is the name of the program as typed at the command line4; any following array elements are the parameters that followed the name of the program.\n\nHere is an example function that accepts command line parameters, and prints out what those parameters are:\n\nYou can write a function that is recursive—a function that calls itself. Here is an example that computes the factorial of an integer:\n\nBe careful that you do not write a function that is infinitely recursive. In the above example, once is 1, the recursion stops. However, in the following example, the recursion does not stop until the program is interrupted or runs out of memory:\n\nFunctions can also be indirectly recursive, of course.\n\nYou can define a function to be static if you want it to be callable only within the source file where it is defined:\n\nThis is useful if you are building a reusable library of functions and need to include some subroutines that should not be callable by the end user.\n\nFunctions which are defined in this way are said to have static linkage. Unfortunately the keyword has multiple meanings; Storage Class Specifiers.\n\nAs a GNU C extension, you can define functions within other functions, a technique known as nesting functions.\n\nHere is an example of a tail-recursive factorial function, defined using a nested function:\n\nNote that nested functions must be defined along with variable declarations at the beginning of a function, and all other statements follow.\n\nNow that we have seen all of the fundamental elements of C programs, it’s time to look at the big picture.\n\nA C program may exist entirely within a single source file, but more commonly, any non-trivial program will consist of several custom header files and source files, and will also include and link with files from existing libraries.\n\nBy convention, header files (with a “.h” extension) contain variable and function declarations, and source files (with a “.c” extension) contain the corresponding definitions. Source files may also store declarations, if these declarations are not for objects which need to be seen by other files. However, header files almost certainly should not contain any definitions.\n\nFor example, if you write a function that computes square roots, and you wanted this function to be accessible to files other than where you define the function, then you would put the function declaration into a header file (with a “.h” file extension):\n\nThis header file could be included by other source files which need to use your function, but do not need to know how it was implemented.\n\nThe implementation of the function would then go into a corresponding source file (with a “.c” file extension):\n\nScope refers to what parts of the program can “see” a declared object. A declared object can be visible only within a particular function, or within a particular file, or may be visible to an entire set of files by way of including header files and using declarations.\n\nUnless explicitly stated otherwise, declarations made at the top-level of a file (i.e., not within a function) are visible to the entire file, including from within functions, but are not visible outside of the file.\n\nDeclarations made within functions are visible only within those functions.\n\nA declaration is not visible to declarations that came before it; for example:\n\nSee Storage Class Specifiers, for more information on changing the scope of declared objects. Also see Static Functions.\n\nTo conclude our description of C, here is a complete program written in C, consisting of both a C source file and a header file. This program is an expanded version of the quintessential “hello world” program, and serves as an example of how to format and structure C code for use in programs for FSF Project GNU. (You can always download the most recent version of this program, including sample makefiles and other examples of how to produce GNU software, from .)\n\nThis program uses features of the preprocessor; for a description of preprocessor macros, see , available as part of the GCC documentation.\n\n[This appendix, written principally by Paul Eggert, is from the GNU Autoconf manual. We thought that it would be helpful to include here. –TJR]\n\nIn practice many portable C programs assume that signed integer overflow wraps around reliably using two’s complement arithmetic. Yet the C standard says that program behavior is undefined on overflow, and in a few cases C programs do not work on some modern implementations because their overflows do not wrap around as their authors expected. Conversely, in signed integer remainder, the C standard requires overflow behavior that is commonly not implemented.\n\nIn languages like C, unsigned integer overflow reliably wraps around; e.g., yields zero. This is guaranteed by the C standard and is portable in practice, unless you specify aggressive, nonstandard optimization options suitable only for special applications.\n\nIn contrast, the C standard says that signed integer overflow leads to undefined behavior where a program can do anything, including dumping core or overrunning a buffer. The misbehavior can even precede the overflow. Such an overflow can occur during addition, subtraction, multiplication, division, and left shift.\n\nDespite this requirement of the standard, many C programs assume that signed integer overflow silently wraps around modulo a power of two, using two’s complement arithmetic, so long as you cast the resulting value to a signed integer type or store it into a signed integer variable. If you use conservative optimization flags, such programs are generally portable to the vast majority of modern platforms, with a few exceptions discussed later.\n\nFor historical reasons the C standard also allows implementations with ones’ complement or signed magnitude arithmetic, but it is safe to assume two’s complement nowadays.\n\nAlso, overflow can occur when converting an out-of-range value to a signed integer type. Here a standard implementation must define what happens, but this might include raising an exception. In practice all known implementations support silent wraparound in this case, so you need not worry about other possibilities.\n\nThere has long been a tension between what the C standard requires for signed integer overflow, and what C programs commonly assume. The standard allows aggressive optimizations based on assumptions that overflow never occurs, but many practical C programs rely on overflow wrapping around. These programs do not conform to the standard, but they commonly work in practice because compiler writers are understandably reluctant to implement optimizations that would break many programs, unless perhaps a user specifies aggressive optimization.\n\nThe C Standard says that if a program has signed integer overflow its behavior is undefined, and the undefined behavior can even precede the overflow. To take an extreme example:\n\nIf the variable equals , must overflow and the behavior is undefined, so the C standard allows the compiler to optimize away the test against and the call. Worse, if an earlier bug in the program lets the compiler deduce that or that previously overflowed, the C standard allows the compiler to optimize away the password test and generate code that allows superuser privileges unconditionally.\n\nDespite this requirement by the standard, it has long been common for C code to assume wraparound arithmetic after signed overflow, and all known practical C implementations support some C idioms that assume wraparound signed arithmetic, even if the idioms do not conform strictly to the standard. If your code looks like the following examples it will almost surely work with real-world compilers.\n\nHere is an example derived from the 7th Edition Unix implementation of (1979-01-10):\n\nEven if the input string is in range, on most modern machines this has signed overflow when computing the most negative integer (the overflows) or a value near an extreme integer (the first overflows).\n\nHere is another example, derived from the 7th Edition implementation of (1979-01-10). Here the programmer expects both multiplication and addition to wrap on overflow:\n\nIn the following example, derived from the C Library 2.5 implementation of (2006-09-09), the code assumes wraparound arithmetic in to detect signed overflow:\n\nIf your code looks like these examples, it is probably safe even though it does not strictly conform to the C standard. This might lead one to believe that one can generally assume wraparound on overflow, but that is not always true, as can be seen in the next section.\n\nCompilers sometimes generate code that is incompatible with wraparound integer arithmetic. A simple example is an algebraic simplification: a compiler might translate to because it assumes that does not overflow. The translation is not equivalent to the original when overflow occurs: e.g., in the typical case of 32-bit signed two’s complement wraparound , if has type and value , the original expression returns -2147483 but the optimized version returns the mathematically correct value 2147484.\n\nMore subtly, loop induction optimizations often exploit the undefined behavior of signed overflow. Consider the following contrived function :\n\nTo avoid multiplying by 53 each time through the loop, an optimizing compiler might internally transform to the equivalent of the following:\n\nThis transformation is allowed by the C standard, but it is invalid for wraparound arithmetic when , because then the overflow in computing expressions like can cause the expression to yield a different value from the transformed expression .\n\nFor this reason, compilers that use loop induction and similar techniques often do not support reliable wraparound arithmetic when a loop induction variable like is involved. Since loop induction variables are generated by the compiler, and are not visible in the source code, it is not always trivial to say whether the problem affects your code.\n\nHardly any code actually depends on wraparound arithmetic in cases like these, so in practice these loop induction optimizations are almost always useful. However, edge cases in this area can cause problems. For example:\n\nHere, the loop attempts to iterate through all powers of 2 that can represent, but the C standard allows a compiler to optimize away the comparison and generate an infinite loop, under the argument that behavior is undefined on overflow. As of this writing this optimization is not done by any production version of with , but it might be performed by other compilers, or by more aggressive optimization options, and the developers have not decided whether it will continue to work with and .\n\nIdeally the safest approach is to avoid signed integer overflow entirely. For example, instead of multiplying two signed integers, you can convert them to unsigned integers, multiply the unsigned values, then test whether the result is in signed range.\n\nRewriting code in this way will be inconvenient, though, particularly if the signed values might be negative. Also, it may hurt performance. Using unsigned arithmetic to check for overflow is particularly painful to do portably and efficiently when dealing with an integer type like whose width and signedness vary from platform to platform.\n\nFurthermore, many C applications pervasively assume wraparound behavior and typically it is not easy to find and remove all these assumptions. Hence it is often useful to maintain nonstandard code that assumes wraparound on overflow, instead of rewriting the code. The rest of this section attempts to give practical advice for this situation.\n\nIf your code wants to detect signed integer overflow in , it is generally safe to use an expression like .\n\nIf your code uses a signed loop index, make sure that the index cannot overflow, along with all signed expressions derived from the index. Here is a contrived example of problematic code with two instances of overflow.\n\nBecause of the two overflows, a compiler might optimize away or transform the two comparisons in a way that is incompatible with the wraparound assumption.\n\nIf your code uses an expression like and you actually want the multiplication to wrap around on overflow, use unsigned arithmetic to do it, e.g., .\n\nIf your code assumes wraparound behavior and you want to insulate it against any optimizations that would fail to support that behavior, you should use ’s option, which causes signed overflow to wrap around reliably (except for division and remainder, as discussed in the next section).\n\nIf you need to port to platforms where signed integer overflow does not reliably wrap around (e.g., due to hardware overflow checking, or to highly aggressive optimizations), you should consider debugging with ’s option, which causes signed overflow to raise an exception.\n\nOverflow in signed integer division is not always harmless: for example, on CPUs of the i386 family, dividing by yields a SIGFPE signal which by default terminates the program. Worse, taking the remainder of these two values typically yields the same signal on these CPUs, even though the C standard requires to yield zero because the expression does not overflow.\n• PREAMBLE The purpose of this License is to make a manual, textbook, or other functional and useful document free in the sense of freedom: to assure everyone the effective freedom to copy and redistribute it, with or without modifying it, either commercially or noncommercially. Secondarily, this License preserves for the author and publisher a way to get credit for their work, while not being considered responsible for modifications made by others. This License is a kind of “copyleft”, which means that derivative works of the document must themselves be free in the same sense. It complements the GNU General Public License, which is a copyleft license designed for free software. We have designed this License in order to use it for manuals for free software, because free software needs free documentation: a free program should come with manuals providing the same freedoms that the software does. But this License is not limited to software manuals; it can be used for any textual work, regardless of subject matter or whether it is published as a printed book. We recommend this License principally for works whose purpose is instruction or reference.\n• APPLICABILITY AND DEFINITIONS This License applies to any manual or other work, in any medium, that contains a notice placed by the copyright holder saying it can be distributed under the terms of this License. Such a notice grants a world-wide, royalty-free license, unlimited in duration, to use that work under the conditions stated herein. The “Document”, below, refers to any such manual or work. Any member of the public is a licensee, and is addressed as “you”. You accept the license if you copy, modify or distribute the work in a way requiring permission under copyright law. A “Modified Version” of the Document means any work containing the Document or a portion of it, either copied verbatim, or with modifications and/or translated into another language. A “Secondary Section” is a named appendix or a front-matter section of the Document that deals exclusively with the relationship of the publishers or authors of the Document to the Document’s overall subject (or to related matters) and contains nothing that could fall directly within that overall subject. (Thus, if the Document is in part a textbook of mathematics, a Secondary Section may not explain any mathematics.) The relationship could be a matter of historical connection with the subject or with related matters, or of legal, commercial, philosophical, ethical or political position regarding them. The “Invariant Sections” are certain Secondary Sections whose titles are designated, as being those of Invariant Sections, in the notice that says that the Document is released under this License. If a section does not fit the above definition of Secondary then it is not allowed to be designated as Invariant. The Document may contain zero Invariant Sections. If the Document does not identify any Invariant Sections then there are none. The “Cover Texts” are certain short passages of text that are listed, as Front-Cover Texts or Back-Cover Texts, in the notice that says that the Document is released under this License. A Front-Cover Text may be at most 5 words, and a Back-Cover Text may be at most 25 words. A “Transparent” copy of the Document means a machine-readable copy, represented in a format whose specification is available to the general public, that is suitable for revising the document straightforwardly with generic text editors or (for images composed of pixels) generic paint programs or (for drawings) some widely available drawing editor, and that is suitable for input to text formatters or for automatic translation to a variety of formats suitable for input to text formatters. A copy made in an otherwise Transparent file format whose markup, or absence of markup, has been arranged to thwart or discourage subsequent modification by readers is not Transparent. An image format is not Transparent if used for any substantial amount of text. A copy that is not “Transparent” is called “Opaque”. Examples of suitable formats for Transparent copies include plain ASCII without markup, Texinfo input format, LaTeX input format, or using a publicly available , and standard-conforming simple , PostScript or designed for human modification. Examples of transparent image formats include , and . Opaque formats include proprietary formats that can be read and edited only by proprietary word processors, or for which the and/or processing tools are not generally available, and the machine-generated , PostScript or produced by some word processors for output purposes only. The “Title Page” means, for a printed book, the title page itself, plus such following pages as are needed to hold, legibly, the material this License requires to appear in the title page. For works in formats which do not have any title page as such, “Title Page” means the text near the most prominent appearance of the work’s title, preceding the beginning of the body of the text. The “publisher” means any person or entity that distributes copies of the Document to the public. A section “Entitled XYZ” means a named subunit of the Document whose title either is precisely XYZ or contains XYZ in parentheses following text that translates XYZ in another language. (Here XYZ stands for a specific section name mentioned below, such as “Acknowledgements”, “Dedications”, “Endorsements”, or “History”.) To “Preserve the Title” of such a section when you modify the Document means that it remains a section “Entitled XYZ” according to this definition. The Document may include Warranty Disclaimers next to the notice which states that this License applies to the Document. These Warranty Disclaimers are considered to be included by reference in this License, but only as regards disclaiming warranties: any other implication that these Warranty Disclaimers may have is void and has no effect on the meaning of this License.\n• VERBATIM COPYING You may copy and distribute the Document in any medium, either commercially or noncommercially, provided that this License, the copyright notices, and the license notice saying this License applies to the Document are reproduced in all copies, and that you add no other conditions whatsoever to those of this License. You may not use technical measures to obstruct or control the reading or further copying of the copies you make or distribute. However, you may accept compensation in exchange for copies. If you distribute a large enough number of copies you must also follow the conditions in section 3. You may also lend copies, under the same conditions stated above, and you may publicly display copies.\n• COPYING IN QUANTITY If you publish printed copies (or copies in media that commonly have printed covers) of the Document, numbering more than 100, and the Document’s license notice requires Cover Texts, you must enclose the copies in covers that carry, clearly and legibly, all these Cover Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on the back cover. Both covers must also clearly and legibly identify you as the publisher of these copies. The front cover must present the full title with all words of the title equally prominent and visible. You may add other material on the covers in addition. Copying with changes limited to the covers, as long as they preserve the title of the Document and satisfy these conditions, can be treated as verbatim copying in other respects. If the required texts for either cover are too voluminous to fit legibly, you should put the first ones listed (as many as fit reasonably) on the actual cover, and continue the rest onto adjacent pages. If you publish or distribute Opaque copies of the Document numbering more than 100, you must either include a machine-readable Transparent copy along with each Opaque copy, or state in or with each Opaque copy a computer-network location from which the general network-using public has access to download using public-standard network protocols a complete Transparent copy of the Document, free of added material. If you use the latter option, you must take reasonably prudent steps, when you begin distribution of Opaque copies in quantity, to ensure that this Transparent copy will remain thus accessible at the stated location until at least one year after the last time you distribute an Opaque copy (directly or through your agents or retailers) of that edition to the public. It is requested, but not required, that you contact the authors of the Document well before redistributing any large number of copies, to give them a chance to provide you with an updated version of the Document.\n• MODIFICATIONS You may copy and distribute a Modified Version of the Document under the conditions of sections 2 and 3 above, provided that you release the Modified Version under precisely this License, with the Modified Version filling the role of the Document, thus licensing distribution and modification of the Modified Version to whoever possesses a copy of it. In addition, you must do these things in the Modified Version:\n• Use in the Title Page (and on the covers, if any) a title distinct from that of the Document, and from those of previous versions (which should, if there were any, be listed in the History section of the Document). You may use the same title as a previous version if the original publisher of that version gives permission.\n• List on the Title Page, as authors, one or more persons or entities responsible for authorship of the modifications in the Modified Version, together with at least five of the principal authors of the Document (all of its principal authors, if it has fewer than five), unless they release you from this requirement.\n• State on the Title page the name of the publisher of the Modified Version, as the publisher.\n• Preserve all the copyright notices of the Document.\n• Add an appropriate copyright notice for your modifications adjacent to the other copyright notices.\n• Include, immediately after the copyright notices, a license notice giving the public permission to use the Modified Version under the terms of this License, in the form shown in the Addendum below.\n• Preserve in that license notice the full lists of Invariant Sections and required Cover Texts given in the Document’s license notice.\n• Include an unaltered copy of this License.\n• Preserve the section Entitled “History”, Preserve its Title, and add to it an item stating at least the title, year, new authors, and publisher of the Modified Version as given on the Title Page. If there is no section Entitled “History” in the Document, create one stating the title, year, authors, and publisher of the Document as given on its Title Page, then add an item describing the Modified Version as stated in the previous sentence.\n• Preserve the network location, if any, given in the Document for public access to a Transparent copy of the Document, and likewise the network locations given in the Document for previous versions it was based on. These may be placed in the “History” section. You may omit a network location for a work that was published at least four years before the Document itself, or if the original publisher of the version it refers to gives permission.\n• For any section Entitled “Acknowledgements” or “Dedications”, Preserve the Title of the section, and preserve in the section all the substance and tone of each of the contributor acknowledgements and/or dedications given therein.\n• Preserve all the Invariant Sections of the Document, unaltered in their text and in their titles. Section numbers or the equivalent are not considered part of the section titles.\n• Delete any section Entitled “Endorsements”. Such a section may not be included in the Modified Version.\n• Do not retitle any existing section to be Entitled “Endorsements” or to conflict in title with any Invariant Section. If the Modified Version includes new front-matter sections or appendices that qualify as Secondary Sections and contain no material copied from the Document, you may at your option designate some or all of these sections as invariant. To do this, add their titles to the list of Invariant Sections in the Modified Version’s license notice. These titles must be distinct from any other section titles. You may add a section Entitled “Endorsements”, provided it contains nothing but endorsements of your Modified Version by various parties—for example, statements of peer review or that the text has been approved by an organization as the authoritative definition of a standard. You may add a passage of up to five words as a Front-Cover Text, and a passage of up to 25 words as a Back-Cover Text, to the end of the list of Cover Texts in the Modified Version. Only one passage of Front-Cover Text and one of Back-Cover Text may be added by (or through arrangements made by) any one entity. If the Document already includes a cover text for the same cover, previously added by you or by arrangement made by the same entity you are acting on behalf of, you may not add another; but you may replace the old one, on explicit permission from the previous publisher that added the old one. The author(s) and publisher(s) of the Document do not by this License give permission to use their names for publicity for or to assert or imply endorsement of any Modified Version.\n• COMBINING DOCUMENTS You may combine the Document with other documents released under this License, under the terms defined in section 4 above for modified versions, provided that you include in the combination all of the Invariant Sections of all of the original documents, unmodified, and list them all as Invariant Sections of your combined work in its license notice, and that you preserve all their Warranty Disclaimers. The combined work need only contain one copy of this License, and multiple identical Invariant Sections may be replaced with a single copy. If there are multiple Invariant Sections with the same name but different contents, make the title of each such section unique by adding at the end of it, in parentheses, the name of the original author or publisher of that section if known, or else a unique number. Make the same adjustment to the section titles in the list of Invariant Sections in the license notice of the combined work. In the combination, you must combine any sections Entitled “History” in the various original documents, forming one section Entitled “History”; likewise combine any sections Entitled “Acknowledgements”, and any sections Entitled “Dedications”. You must delete all sections Entitled “Endorsements.”\n• COLLECTIONS OF DOCUMENTS You may make a collection consisting of the Document and other documents released under this License, and replace the individual copies of this License in the various documents with a single copy that is included in the collection, provided that you follow the rules of this License for verbatim copying of each of the documents in all other respects. You may extract a single document from such a collection, and distribute it individually under this License, provided you insert a copy of this License into the extracted document, and follow this License in all other respects regarding verbatim copying of that document.\n• AGGREGATION WITH INDEPENDENT WORKS A compilation of the Document or its derivatives with other separate and independent documents or works, in or on a volume of a storage or distribution medium, is called an “aggregate” if the copyright resulting from the compilation is not used to limit the legal rights of the compilation’s users beyond what the individual works permit. When the Document is included in an aggregate, this License does not apply to the other works in the aggregate which are not themselves derivative works of the Document. If the Cover Text requirement of section 3 is applicable to these copies of the Document, then if the Document is less than one half of the entire aggregate, the Document’s Cover Texts may be placed on covers that bracket the Document within the aggregate, or the electronic equivalent of covers if the Document is in electronic form. Otherwise they must appear on printed covers that bracket the whole aggregate.\n• TRANSLATION Translation is considered a kind of modification, so you may distribute translations of the Document under the terms of section 4. Replacing Invariant Sections with translations requires special permission from their copyright holders, but you may include translations of some or all Invariant Sections in addition to the original versions of these Invariant Sections. You may include a translation of this License, and all the license notices in the Document, and any Warranty Disclaimers, provided that you also include the original English version of this License and the original versions of those notices and disclaimers. In case of a disagreement between the translation and the original version of this License or a notice or disclaimer, the original version will prevail. If a section in the Document is Entitled “Acknowledgements”, “Dedications”, or “History”, the requirement (section 4) to Preserve its Title (section 1) will typically require changing the actual title.\n• TERMINATION You may not copy, modify, sublicense, or distribute the Document except as expressly provided under this License. Any attempt otherwise to copy, modify, sublicense, or distribute it is void, and will automatically terminate your rights under this License. However, if you cease all violation of this License, then your license from a particular copyright holder is reinstated (a) provisionally, unless and until the copyright holder explicitly and finally terminates your license, and (b) permanently, if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation. Moreover, your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means, this is the first time you have received notice of violation of this License (for any work) from that copyright holder, and you cure the violation prior to 30 days after your receipt of the notice. Termination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License. If your rights have been terminated and not permanently reinstated, receipt of a copy of some or all of the same material does not give you any rights to use it.\n• FUTURE REVISIONS OF THIS LICENSE The Free Software Foundation may publish new, revised versions of the GNU Free Documentation License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns. See http://www.gnu.org/copyleft/. Each version of the License is given a distinguishing version number. If the Document specifies that a particular numbered version of this License “or any later version” applies to it, you have the option of following the terms and conditions either of that specified version or of any later version that has been published (not as a draft) by the Free Software Foundation. If the Document does not specify a version number of this License, you may choose any version ever published (not as a draft) by the Free Software Foundation. If the Document specifies that a proxy can decide which future versions of this License can be used, that proxy’s public statement of acceptance of a version permanently authorizes you to choose that version for the Document.\n• RELICENSING “Massive Multiauthor Collaboration Site” (or “MMC Site”) means any World Wide Web server that publishes copyrightable works and also provides prominent facilities for anybody to edit those works. A public wiki that anybody can edit is an example of such a server. A “Massive Multiauthor Collaboration” (or “MMC”) contained in the site means any set of copyrightable works thus published on the MMC site. “CC-BY-SA” means the Creative Commons Attribution-Share Alike 3.0 license published by Creative Commons Corporation, a not-for-profit corporation with a principal place of business in San Francisco, California, as well as future copyleft versions of that license published by that same organization. “Incorporate” means to publish or republish a Document, in whole or in part, as part of another Document. An MMC is “eligible for relicensing” if it is licensed under this License, and if all works that were first published under this License somewhere other than this MMC, and subsequently incorporated in whole or in part into the MMC, (1) had no cover texts or invariant sections, and (2) were thus incorporated prior to November 1, 2008. The operator of an MMC Site may republish an MMC contained in the site under CC-BY-SA on the same site at any time before August 1, 2009, provided the MMC is eligible for relicensing.\n\nADDENDUM: How to use this License for your documents\n\nTo use this License in a document you have written, include a copy of the License in the document and put the following copyright and license notices just after the title page:\n\nIf you have Invariant Sections, Front-Cover Texts and Back-Cover Texts, replace the “with…Texts.” line with this:\n\nIf you have Invariant Sections without Cover Texts, or some other combination of the three, merge those two alternatives to suit the situation.\n\nIf your document contains nontrivial examples of program code, we recommend releasing these examples in parallel under your choice of free software license, such as the GNU General Public License, to permit their use in free software."
    },
    {
        "link": "https://stackoverflow.com/questions/37242890/data-validation-in-c-ensuring-the-input-is-in-a-correct-format",
        "document": "I want to write a code to ensure that the users input only 1 digit. If a user enters something like \"0 1 3\" I want my program to read an error message which I have no idea how to do. Anyone has an idea how to approach this? My current code just takes in the first number if a user enters bunch of numbers with a space in between.\n\nPlease see my code below. Thanks :D"
    },
    {
        "link": "https://stackoverflow.com/questions/12998258/input-validation-in-c",
        "document": "I'm writing a program in C. In the program, the user has to choose a number, either 1, 2 or 3. I would like to construct the code so that when the user enters in a number that isn't 1, 2 or 3, he/she will be told \"Invalid selection - choose again\" and then they will be brought back to the start of the program:\n\nWhat I would like is that after \"Invalid selection, choose again\" appears, the user is brought back to the start of the program, so they can input their choice again. How would I do this?"
    },
    {
        "link": "https://blog.heycoach.in/handling-input-validation-in-c-programs",
        "document": "Welcome, brave coder! Today, we’re diving into the wild world of input validation in C programs. Think of input validation as the bouncer at a club, making sure only the right people (or data) get in. Without it, your program could end up with a bunch of rowdy data that just wants to cause chaos. So, let’s get started!\n\nInput validation is the process of ensuring that the data provided to your program is both correct and useful. It’s like checking if your friend is actually bringing pizza to the party instead of a fruitcake. Here are some key points:\n• Purpose: To prevent invalid data from causing errors or unexpected behavior.\n• Importance: Essential for security, as it helps prevent attacks like buffer overflows.\n• Real-World Analogy: Think of it as a security guard checking IDs at the door.\n• Implementation: Can be done using conditional statements, loops, and functions.\n• Feedback: Providing user feedback on invalid input is crucial for a good user experience.\n• Testing: Always test your validation logic with various inputs.\n• Best Practices: Keep it simple and clear; don’t overcomplicate your validation logic.\n\nJust like there are different types of pizza (because who doesn’t love pizza?), there are various types of input validation. Let’s break them down:\n\nThis ensures that the input is of the expected data type. For example, if you’re expecting an integer, you don’t want a string sneaking in like a ninja.\n\nRange checking ensures that the input falls within a specified range. It’s like making sure your friend doesn’t bring a pet elephant to the party.\n\nThis checks if the input matches a specific format, like ensuring an email address has the right structure. No one wants to receive emails from ‘notarealemail@fake.com’.\n\nLength checking ensures that the input isn’t too long or too short. It’s like making sure your password isn’t just ‘123’.\n\nWhitelist validation only allows specific values. It’s like only letting your friends into the party, and not their weird cousin.\n\nBlacklist validation checks against a list of disallowed values. It’s like saying, “No, you can’t bring that fruitcake!”\n\nRegular expressions are powerful tools for complex pattern matching. They’re like the Swiss Army knife of input validation.\n\nWhen dealing with databases, always validate inputs to prevent SQL injection attacks. It’s like making sure no one sneaks in with a fake ID.\n\nWhen accepting user input for web applications, validate to prevent XSS attacks. It’s like not letting anyone bring glitter to the party—no one wants that mess!\n\nAlways ensure that your input doesn’t exceed the buffer size. It’s like making sure your suitcase isn’t overpacked for a weekend trip.\n\nNow that we’ve covered the types of input validation, let’s talk about some best practices. Because who doesn’t love a good list of dos and don’ts?\n• Validate Early: Check inputs as soon as they are received.\n• Be Specific: Use specific error messages to guide users.\n• Fail Gracefully: Ensure your program can handle invalid input without crashing.\n• Keep It Simple: Don’t overcomplicate your validation logic.\n• Use Libraries: Consider using existing libraries for complex validations.\n• Test Thoroughly: Test your validation with various inputs, including edge cases.\n• Document Your Logic: Keep a record of your validation rules for future reference.\n• Stay Updated: Keep up with security best practices to protect against new threats.\n• Educate Users: Provide clear instructions on what input is expected.\n• Review Regularly: Regularly review and update your validation logic as needed.\n\nEven the best of us make mistakes. Here are some common pitfalls to avoid:\n• Ignoring Edge Cases: Always consider the extremes of input values.\n• Overly Complex Logic: Keep your validation simple and straightforward.\n• Not Providing Feedback: Users need to know what went wrong.\n• Neglecting Security: Always consider security implications in your validation.\n• Not Testing: Failing to test your validation logic can lead to unexpected behavior.\n• Using Deprecated Functions: Stay updated with the latest C standards.\n• Ignoring User Experience: Make sure your validation enhances the user experience.\n• Skipping Documentation: Always document your validation rules for clarity.\n\nAnd there you have it! Input validation in C is like having a trusty sidekick that keeps your program safe from the bad guys. Remember, a little validation goes a long way in ensuring your program runs smoothly and securely. So, the next time you’re coding, think of input validation as your program’s personal bodyguard.\n\nNow, go forth and validate! And if you’re feeling adventurous, check out our next post on advanced C topics. Who knows? You might just become the superhero of C programming!"
    },
    {
        "link": "https://labex.io/tutorials/c-how-to-validate-input-in-c-programming-425511",
        "document": "Input validation is a critical aspect of robust C programming that ensures the reliability and security of software applications. This tutorial explores comprehensive techniques for validating user inputs, helping developers prevent potential vulnerabilities and improve the overall quality of their C programs by implementing systematic input checking methods.\n\n%%%%{init: {'theme':'neutral'}}%%%% flowchart RL c((\"C\")) -.-> c/BasicsGroup([\"Basics\"]) c((\"C\")) -.-> c/ControlFlowGroup([\"Control Flow\"]) c((\"C\")) -.-> c/FunctionsGroup([\"Functions\"]) c((\"C\")) -.-> c/UserInteractionGroup([\"User Interaction\"]) c/BasicsGroup -.-> c/operators(\"Operators\") c/ControlFlowGroup -.-> c/if_else(\"If...Else\") c/FunctionsGroup -.-> c/function_declaration(\"Function Declaration\") c/FunctionsGroup -.-> c/function_parameters(\"Function Parameters\") c/UserInteractionGroup -.-> c/user_input(\"User Input\") subgraph Lab Skills c/operators -.-> lab-425511{{\"How to validate input in C programming\"}} c/if_else -.-> lab-425511{{\"How to validate input in C programming\"}} c/function_declaration -.-> lab-425511{{\"How to validate input in C programming\"}} c/function_parameters -.-> lab-425511{{\"How to validate input in C programming\"}} c/user_input -.-> lab-425511{{\"How to validate input in C programming\"}} end"
    },
    {
        "link": "https://medium.com/@future_fanatic/mastering-input-with-scanf-in-c-a-comprehensive-guide-e7d955ac5a48",
        "document": "In the world of C programming, handling user input is a fundamental skill. One of the key functions used for this purpose is scanf(). In this guide, we’ll delve deep into the scanf() function, exploring its syntax, usage, common pitfalls, and best practices. By the end of this article, you’ll be equipped with the knowledge and confidence to handle user input like a pro in your C programs.\n• Best Practices for Using\n\nThe scanf() function in C is used to read input from the standard input stream (usually the keyboard) and store it in variables. It allows programmers to interact with users by prompting them for input and capturing their responses.\n\nThe syntax of scanf() resembles that of printf(), with the addition of format specifiers (%d, %f, %c, %s, etc.) to indicate the type of input expected. For example:\n\nThis line reads an integer from the standard input and stores it in the variable ‘num’.\n\nThe scanf() function in C is a versatile tool for reading different data types from the standard input (usually the keyboard). It allows programmers to prompt users for input and store that input in variables of various data types. Here’s a closer look at how scanf() can be used to read different types of data:\n\nReading Integers: To read an integer using scanf(), you need to use the %d format specifier. For example:\n\nIn this example, the user is prompted to enter an integer, which is then stored in the variable num.\n\nReading Floating-Point Numbers: To read a floating-point number (such as a decimal) using scanf(), you can use the %f format specifier. For example:\n\nHere, the user is prompted to enter a floating-point number representing the price, which is stored in the variable price.\n\nReading Characters: To read a single character using scanf(), you can use the %c format specifier. For example:\n\nThis code prompts the user to enter a single character, which is then stored in the variable ch.\n\nReading Strings: To read a string (a sequence of characters) using scanf(), you can use the %s format specifier. For example:\n\nHere, the user is prompted to enter their name, which is stored in the character array name.\n\nIt’s important to note that scanf() can behave unpredictably if the input doesn’t match the specified format, leading to potential buffer overflows or other issues. Therefore, it’s essential to handle input validation and error checking to ensure robust program behavior.\n\nWhile scanf() offers flexibility in reading user input, it also poses a risk of security vulnerabilities if not used carefully. One common challenge is handling unexpected input from users, which can lead to buffer overflow and other security issues. To mitigate these risks, it’s crucial to validate and sanitize user input before processing it further. This involves checking the input against expected formats, ensuring that it falls within acceptable ranges, and sanitizing it to remove any potentially harmful characters or sequences. By implementing robust input validation and sanitization mechanisms, developers can enhance the security and reliability of their C programs, safeguarding against potential exploits and vulnerabilities.\n• Forgetting to include the ‘&’ operator before variable names in scanf() calls\n• Neglecting to check the return value of scanf() for errors\n• Providing incorrect format specifiers that do not match the input data type\n• Failing to handle newline characters left in the input buffer, leading to unexpected behavior\n• Using scanf() for input validation without considering its limitations and potential security risks\n\nBest Practices for Using scanf():\n• Always check the return value of scanf() to detect errors or unexpected input\n• Use appropriate format specifiers (%d for integers, %f for floating-point numbers, %c for characters, %s for strings) corresponding to the data type being read\n• Validate input data to ensure it meets expected criteria, such as range checking for integers or length checking for strings\n• Clear the input buffer after reading data to prevent leftover newline characters from interfering with subsequent input operations\n\nscanf() is a powerful function in C for reading user input, but it requires careful handling to avoid common pitfalls and security issues. By understanding its syntax, usage, and best practices, you can harness the full potential of scanf() and create robust, user-friendly C programs.\n\nReady to take your C programming skills to the next level? Explore our recommended books on C programming and enhance your knowledge today! Check here to browse our curated selection of C programming books on Amazon.\n\nAffiliate Buy Links : if you from this links I will earn commission, no extra cost to pay.\n\nC Programming Absolute Beginner’s Guide, 3e : https://amzn.to/3uOWPUi\n\nThe C Programming Language 2e : https://amzn.to/3URU4wb\n\nC: THE COMPLETE REFERENCE : https://amzn.to/48y6z2X\n\nHead First C: A Brain-Friendly Guide : https://amzn.to/42Tf2Nd\n\nC Programming in easy steps, 5th Edition : https://amzn.to/3uRkhjQ"
    },
    {
        "link": "https://stackoverflow.com/questions/21540737/date-algorithm-with-leap-days-in-c",
        "document": "I've edited my answer to provide the code I used, along with a commentary of changes relative to your initially supplied code.\n\nInitially you needed to remove the from your operator, and place it instead within your function.\n\nI implemented a function belonging to your so that you can easily display the date held in the class.\n\nI made the operator a void operator. This is probably not a great plan, and might be worth changing, but working out how to return an appropriate class object seemed more effort. You could try or something similar.\n\nI added a function to allow you to instantiate an array holding the number of days in a month, with changing days in February for leap years. If the number of days entered cause the year to move into a leap year, it's likely that this won't work quite properly - you should check this and move some function calls around so that it properly checks the year, sets the days in February ( ) and then after that checks through the loop.\n\nA loop was used to reduce the number of days held in until it fell below the number of days in the expected month, at which point a would be triggered.\n\nThe Date class has no constructor, so it is created and assigned values in the function. You could consider writing two constructors, one with three int arguments, and the other blank, allowing you to write or etc.\n\nGood luck with any changes you wish to make :)"
    },
    {
        "link": "https://stackoverflow.com/questions/66568146/leap-year-by-only-using-arithmetical-operators-in-c",
        "document": "I have the weirdest exercise I've ever seen: I have to find a leap year by scanning a year in the console and to control if that is a leap year.\n\nI can only use as arithmetical operators; I am not allowed to use any other operators or functions.\n\nHere is what I have so far:\n\nSo I don't understand what I am doing wrong here. It works so far, the only case that's freaking me out is for year \"1900\". It shouldn't be a leap year, but appears to, by my code.\n\nWhat am I missing here?"
    },
    {
        "link": "https://azure.microsoft.com/en-us/blog/is-your-code-ready-for-the-leap-year",
        "document": "2016 is a leap year, and that can mean trouble for software applications not carefully coded to prevent bugs. Learn more about the types of bugs you should be on the lookout for, and how the leap year has affected Azure and other software in the past.\n\nAs we enter February, it’s a good time to remember that 2016 is a leap year. For most people, this may just be an interesting oddity; an extra day to work or play. But for software developers, the leap year can cause significant pain.\n\nIf you are just now thinking about checking your code for leap year bugs, you better move quickly. In fact, you might already be experiencing the effects and may not even realize it! What kind of bugs might be lurking in your code?\n• Off-by-one issues, especially around data filtering using date-range queries\n• Potential for exceptions, crashes, or hanging as edge cases are encountered\n\n“Meh,” you say. “My code is just fine. We have unit tests.”\n\n“Oh really,” I say. “Do your tests properly mock the clock? Do they test edge cases including February 29 and December 31? Have you tested any low-level C++ code you might have as well as the rest of your system? Do you even know what a leap year bug looks like?”\n\nWhy does this matter for Azure?\n\nWell really, it applies to just about any code a developer might write, and quite a lot of it may end up running in the Azure cloud! Azure had a leap year outage of its own in 2012, and we’ve been working hard to ensure a smooth experience this time around. We’d like all of our customers to benefit from our research and experiences since then.\n\nOk, so what do I need to know?\n\nThere’s a lot to cover here, so let’s start with the most important things first.\n• February 29 is not the only day affected by the leap year. Another very important date is December 31, because it is the 366th day of the year and many applications mistakenly hard-code a year as 365 days.\n• With particular consideration for the cloud, also consider the vast majority of cloud applications use UTC (Coordinated Universal Time), or at least, they should. That means at midnight on February 29, it may actually be some other time in your local time zone. For example, in the US Pacific time zone, the leap day will hit UTC when it is 4:00 PM on February 28 (the previous day on the calendar). Check times in other time zones.\n• If you are preparing to monitor your system in real-time for leap day issues, you should be considering the three-day window from February 28 through March 1. Likewise, you should watch out for day 366 issues from December 30 through January 1.\n• Leap year bugs can be found anywhere, in any language, but are most dangerous in C / C++ code, where they can cause application crashes or buffer overflows (which are a security risk).\n• Past leap years have included some high-impact, high-profile bugs, such as:\n• 2012 Microsoft Azure outage: Miscalculation of a certificate expiration date caused service disruptions for up to 12 hours\n• 2012 TomTom GPS navigation bug: Caused many models to fail to identify their current location\n• 2010 Sony PlayStation Network outage: Caused by misidentification of 2010 as a leap year\n• 2008 bricking of all Microsoft Zune devices: Caused by a logic error on December 31\n• 2008 Microsoft Exchange management bug: Prevented administrators from doing much of anything on February 29\n• Lotus 1-2-3’s miscalculation of year 1900, which still impacts Microsoft Excel today, over 30 years later!\n\nThese are just the big stories that made news headlines. I’m sure thousands more occurred with varying degrees of impact and noticeability. Another lesser-known leap year bug from 1996 actually caused process control systems at aluminum smelting plants in New Zealand and Tasmania to shut down abruptly at the stroke of midnight on December 31 (the 366th day).\n\nThis resulted in millions of dollars in damage to equipment as temperatures of molten metal went unregulated. Stories from yesteryear like this one remind me of the real-world dangers of software glitches. Considering the recent widespread adoption of IOT and its intersection with cloud computing, we should all be on high alert.\n\nThe two most dangerous leap year bugs\n\n#1: Adding or subtracting years in C / C++\n\nIn C / C++ code that uses the Win32 API, the SYSTEMTIME structure is a common representation of civil time. It has distinct fields for each part of a date, separating the year, month, day values (and others). It is very common to see the following code:\n\nThis code will succeed without error. However, the risk is if the code is called on February 29, the resulting value will still be on February 29, but in a non-leap year. For example, , which does not exist!\n\nThis value might be passed around quite a bit before it ultimately ends up as a parameter to another function, such as SystemTimeToFileTime, where it will cause the function to fail with a return value of zero. Unfortunately, it is extremely common to find code that uses this method without checking the return value. This can lead to unpredictable results, such as leaving a value in its uninitialized state.\n• Always check the status result of Win32 functions, especially .\n• Correctly add a year to a by checking the validity of the result and adjusting when necessary:\n\nNote that a similar bug can also occur in standard C++ (non-Windows) code as well. The struct is used instead of , which has slightly different behavior. Months are 0-11 instead of 1-12, so February is month 1. Instead of , you might call to produce a structure. The key difference though is that instead of it failing, when passing February 29 in a non-leap year, it will produce a value that represents March 1. Your application may be expecting February 28, and if so it will need to adjust.\n\n#2: Declaring an array of values for each day of the year\n\nThe above C code could just as easily be rewritten in C# or another language, or use a string or some other data type instead of an integer. The key point is that we’re declaring a fixed-size array to hold data, and assuming that there will be a location in the array for every day of the year. The problem, of course, is that in a leap year, there will not be a place in the array for the 366th day, December 31.\n\nThe effects of this vary considerably by language. In C#, this will cause an . In C, unless the bounds checking compiler option is enabled, this will create a buffer overflow, the effects of which could be negligible, or considerable. JavaScript developers have less to worry about in this regard, as a 366th element will be added automatically.\n\nThere are other effects of leap year bugs that can affect data anywhere from February 28 the prior year, to March 1 of the following year. Usually these are in data filtering, where a range query doesn’t account for the extra day; either by assuming a year is always 365 days, or assuming February is always 28 days. Consider a SQL statement such as:\n\nThis query is fine, but consider what happens if is set to today, and is set to today minus 365 days. If the range happens to include the February 29 leap day, then it's not covering an entire year. The start date is one day short, and thus the values are incorrect, assuming the intent was indeed to represent one year's worth of data.\n\nWhen evaluating bugs like this one, ask yourself what the impact of the bug is. In this case, where are these values displayed? For example, if the average order amount is feeding a chart on a dashboard that gets updated every day, it might not be quite as important as when the total sales for the year is listed in a company's financial report such as an SEC filing. Of course, this assessment requires someone familiar with the application and it's usage; there is no one-size-fits-all rule to follow.\n\nIt may be tempting to solve this problem with an approach such as this:\n\nHowever, this is approach is flawed. One cannot determine the number of days to add just by evaluating the year alone. Consider that could be , and though 2016 is a leap year, there's only 365 days to subtract to reach . Instead, you have to consider whether or not the February 29 leap day is included in the range. This leads to some fairly complex code if you try to do it by hand, especially when you consider covering multiple years instead of just one.\n\nUltimately, it comes down to the fact that in .NET (and similar types in other languages) is a representation of absolute time, and both \"year\" and \"month\" are units of civil time. The absolute amount of time in a year or month is variable depending on which years or months you are describing. The same can actually be said for a \"day\" when you consider daylight saving time, though that's getting off-topic for this post.\n\nThe correct solution for .NET is:\n\nThe method correctly implements all of the necessary logic to determine how many days to move forward, or backwards in the case of a negative value.\n\nJavaScript developers really should be using moment.js for this, where it's as simple as:\n\nHowever, some folks still like to do things the hard way so you'll often see this:\n\nThe problem here is one I mentioned earlier. If today is February 29 of a leap year, then the resulting value will be March 1. That may or may not be acceptable to you. Consider that for every other date, the result is in the same month as the original value. Also consider that your application may be expecting an end-of-month date instead of a start-of-month date.\n\nHere is a function you can use to correctly add years in JavaScript without requiring a full library:\n\nThis implementation adds the years, and then checks to see if the rollover to March occurred or not, and compensates if it did. Again, do not try to implement this by figuring out exactly how many days to add; unless you really know what you're doing.\n\nThere are many other things developers get wrong related to the leap year, such as:\n• Messing up the leap year algorithm. It's not just every four years. It's every four years as long as the year is not divisible by 100, unless it's divisible by 400. 1900 was not a leap year. 2000 was a leap year. 2100 will not be a leap year.\n• Using an array of days in each month, where February has 28 days. When using such an array, you must account for the 29th day in a leap year. A better approach is to use a different array for leap years than for common years. Or better yet, use the APIs you have (when available) instead of trying to do the math yourself.\n• Branching the code for leap years, and then not testing all code paths. For example, the code from the Zune bug has an IsleapYear(year) branch at the top, which clearly was never tested.\n• Using separate year, month, and day values in without validating them. For example, you may have a UI with separate drop-down controls to pick each component. It's not enough to test that the day is valid within the month. You also have to consider the year.\n• Using the average length of a year, such as 365.25, or 365.2425 days in date math. While this may be scientifically accurate, it is never appropriate for actual manipulation of civil time. At least, not if you care about accurate values. It's fine if you only need an approximation, but the associated time-of-day will likely be off in the result.\n• Scrutinize your code carefully. Search for anything time related, and go over it with a fine-toothed comb.\n• Make sure you have lots of unit tests, and know how to \"mock the clock\" (described in the next section).\n• Test year-round, not just before leap years.\n\nI'm often asked about two other approaches:\n\nIt would be wonderful if there was just a set of tools you could run against your code that would point out where you had leap-year bugs. Unfortunately, I don't know of any. Simple string-search, or even regex search, can only get you so far.\n\nTruly what is needed for .NET is a comprehensive set of Roslyn Analyzers that can catch common date/time bugs including leap year, time zone, daylight saving time, parsing, and more. Unfortunately, I have not the time to create such analyzers myself. Maybe I'll get to that at some point in the future, but it doesn't exist today.\n\nIt would also be nice to have similar tools for C++, JavaScript, and other languages. Though I know of none.\n\nWhy not just move the clock forward and see what happens? That might actually work for some systems, but there's a few problems with this idea:\n• Your unit tests might still not catch everything. You probably won't catch data filtering errors unless you actually look (manually) at every screen and report of your entire application. This is error prone for sure.\n• You might develop a false sense of security, believing everything to be ok. Only when your customers call complaining on February 29 or March 1 will you realize how wrong you were.\n• Many systems have to authenticate with domain servers, or use other authentication schemes that are time sensitive. Recognize that the Kerberos protocol has strict time sync requirements, with a default tolerance of five minutes. Also consider SSL certificates, code signing certificates and other security-related things are clock dependent and will fail if you try to lie about what time it really is.\n\nSo, in general, I recommend against this approach. Or at least, be sure you take into account any dependencies on outside resources that might create false-positives or prevent certain code paths from being tested.\n\nHow do you test code that behaves differently on different dates? Mock the clock!\n\nThis is a common pattern found in many reliable systems (sometimes known by other names, such as “Virtual Clock”). The key point is that the system clock - you know, the thing that tells you what time it is - should not be used haphazardly. Application logic should never make a direct call to or or or or whatever the equivalent is in your language to get the current date and time.\n\nInstead, you should treat the clock as a service (in the DDD sense), and like any service, you should be able to mock it.\n\nFor example, in .NET, instead of directly calling (or similar APIs) from application logic:\n• Create an interface with a method that returns a .\n• Create a class that implements from , where calls .\n• Create a class that implements , which accepts a fixed value as a constructor parameter and where simply returns the fixed value.\n• In your application logic, only depend on the interface. Typically this is constructor injected.\n• Use a during testing, and wire up a at runtime.\n\nThis may sound like a lot of work, but once you go through the motions you'll see where it has advantages. This is truly the only way to ensure all of your code is tested when the current date and time are dependencies.\n\nI intentionally did not provide code for this here, as the pattern should be the same for many different languages. Also, there's already a really great implementation of this in Noda Time, which comes with and in the main assembly, and in the assembly. You'd do well to use Noda Time for this, and many other reasons.\n\nJavaScript developers should consider libraries like Sinon.JS or MockDate, or built-in mocking support from moment.js.\n\nLibraries for other languages may have similar features. Be sure to look for them before attempting a home-grown implementation.\n\nLeap year is here. It's not Y2K, or Y2038, but it is something we have to contend with on a regular basis. How much code did you write over the last four years? Are you sure it's all up to par? Take the time now to test and scan through your code. You will probably find a few things you didn't realize were lurking in the shadows.\n\nHave questions? Please leave a comment here and we will gladly respond.\n\nPart of this content originally published at codeofmatt.com and was reprinted with permission."
    },
    {
        "link": "https://codeofmatt.com/happy-new-leap-year",
        "document": "If you haven't realized it yet, 2016 is a leap year. For most people, this may just be an interesting oddity. An extra day to work or play. But for developers, the leap year can cause significant pain. It's January 1st as I'm writing this. If you are just now thinking about checking your code for leap year bugs, you better move quickly. In fact, you probably are already experiencing the effects, and may not even realize it!\n\n\"Meh,\" you say. \"My code is just fine. We have unit tests.\"\n\n\"Oh really\", I say. \"Do your tests properly mock the clock? Do they test edge cases including February 29th and December 31st? Have you tested any low-level C++ code you might have as well as the rest of your system? Do you even know what a leap year bug looks like?\" Most often, blank stares.\n\nThere's a lot to cover here, so let's start with the most important things first.\n• February 29th is not the only day affected by the leap year. Another very important date is December 31st, because it is the 366th day of the year and many applications mistakenly hard-code a year as 365 days.\n• Leap year bugs can be found anywhere, but are most dangerous in C / C++ code, where they can cause application crashes or buffer overflows (which are a security risk).\n• Past leap years have included some high-impact, high-profile bugs, such as: The 2012 Microsoft Azure outage - where miscalculation of a certificate expiration date caused service disruptions for up to 12 hours. The 2010 Sony PlayStation Network outage - caused by misidentification of 2010 as a leap year The 2008 bricking of all Microsoft Zune devices - caused by a logic error on December 31st. The 2008 Microsoft Exchange management bug, which prevented administrators from doing much of anything on February 29th. Lotus 1-2-3's miscalculation of year 1900, which still impacts Microsoft Excel today, over 30 years later!. These are just the big ones that made the news. I'm sure thousands more occurred with varying degrees of impact and noticeability.\n\nThe two most dangerous leap year bugs\n\n#1: Adding or subtracting years in C / C++\n\nIn C / C++ code that uses the Win32 API, the structure is a common representation of civil time. It has distinct fields for each part of a date, separating the year, month, day values (and others). It is very common to see the following code:\n\n\n\nThis code will succeed without error. However, the risk is that if the code is called on February 29th, the resulting value will still be on February 29th, but in a non-leap year. For example, , which does not exist!\n\nThis value might be passed around quite a bit before it ultimately ends up as a parameter to another function, such as , where it will cause the function to fail with a return value of zero. Unfortunately, it is extremely common to find code that uses this method without checking the return value. This can lead to unpredictable results, such as leaving a value in its uninitialized state.\n• Always check the status result of Win32 functions, especially .\n• Correctly add a year to a by checking the validity of the result and adjusting when necessary:\n\n\n\nNote that a similar bug can also occur in standard C++ (non-Windows) code as well. The struct is used instead of , which has slightly different behavior. Months are 0-11 instead of 1-12, so Februrary is month 1. Instead of , you might call to produce a structure. The key difference though is that instead of it failing, when passing February 29th in a non-leap year, it will produce a value that represents March 1st. Your application may be expecting February 28th, and if so it will need to adjust.\n\n#2: Declaring an array of values for each day of the year\n\n\n\nThe above C code could just as easily be rewritten in C# or another language, or use a string or some other data type instead of an integer. The key point is that we're declaring a fixed-size array to hold data, and assuming that there will be a location in the array for every day of the year. The problem, of course, is that in a leap year, there will not be a place in the array for the 366th day, December 31st.\n\nThe effects of this vary considerably by language. In C#, this will cause an . In C, unless the bounds checking compiler option is enabled, this will create a buffer overflow, the effects of which could be negligible, or considerable. JavaScript developers have less to worry about in this regard, as a 366th element will be added automatically.\n\nThere are other effects of leap year bugs that can affect data anywhere from February 28th of the prior year, to March 1st of the following year. Usually these are in data filtering, where a range query doesn't account for the extra day - either by assuming a year is always 365 days, or assuming February is always 28 days. Consider a SQL statement such as:\n\n\n\nThis query is fine, but consider what happens if is set to today, and is set to today minus 365 days. If the range happens to include the February 29th leap day, then it's not covering an entire year. The start date is one day short, and thus the values are incorrect, assuming the intent was indeed to represent one year's worth of data.\n\nWhen evaluating bugs like this one, ask yourself what the impact of the bug is. In this case, where are these values displayed? For example, if the average order amount is feeding a chart on a dashboard that gets updated every day, it might not be quite as important as when the total sales for the year is listed in a company's financial report such as an SEC filing. Of course, this assessment requires someone familiar with the application and it's usage; there is no one-size-fits-all rule to follow.\n\nIt may be tempting to solve this problem with an approach such as this:\n\n\n\nHowever, this is approach is flawed. One cannot determine the number of days to add just by evaluating the year alone. Consider that could be , and though 2016 is a leap year, there's only 365 days to subtract to reach . Instead, you have to consider whether or not the February 29th leap day is included in the range. This leads to some fairly complex code if you try to do it by hand, especially when you consider covering multiple years instead of just one.\n\nUltimately, it comes down to the fact that in .NET (and similar types in other languages) is a representation of absolute time, and both \"year\" and \"month\" are units of civil time. The absolute amount of time in a year or month is variable depending on which years or months you are describing. (The same can actually be said for a \"day\" when you consider daylight saving time, though that's getting off-topic for this post.)\n\nThe correct solution for .NET is:\n\n\n\nThe method correctly implements all of the necessary logic to determine how many days to move forward, or backwards in the case of a negative value.\n\nJavaScript developers really should be using moment.js for this, where it's as simple as:\n\n\n\nHowever, some folks still like to do things the hard way so you'll often see this:\n\n\n\nThe problem here is one I mentioned earlier. If today is February 29th of a leap year, then the resulting value will be March 1st. That may or may not be acceptable to you. Consider that for every other date, the result is in the same month as the original value. Also consider that your application may be expecting an end-of-month date instead of a start-of-month date.\n\nHere is a function you can use to correctly add years in JavaScript without requiring a full library:\n\n\n\nThis implementation adds the years, and then checks to see if the rollover to March occurred or not, and compensates if it did. Again, do not try to implement this by figuring out exactly how many days to add - unless you really know what you're doing.\n\nThere are many other things developers get wrong related to the leap year, such as:\n• Messing up the leap year algorithm. It's not just every four years. It's every four years as long as the year is not divisible by 100, unless it's divisible by 400. 1900 was not a leap year. 2000 was a leap year. 2100 will not be a leap year.\n• Using an array of days in each month, where February has 28 days. When using such an array, you must account for the 29th day in a leap year. A better approach is to use a different array for leap years than for common years. Or better yet - use the APIs you have (when available) instead of trying to do the math yourself.\n• Branching the code for leap years, and then not testing all code paths. For example, the code from the Zune bug has an branch at the top, which clearly was never tested.\n• Using separate year, month, and day values in without validating them. For example, you may have a UI with separate drop-down controls to pick each component. It's not enough to test that the day is valid within the month. You also have to consider the year.\n• Using the average length of a year, such as 365.25, or 365.2425 days in date math. While this may be scientifically accurate, it is never appropriate for actual manipulation of civil time. At least, not if you care about accurate values. It's fine if you only need an approximation, but the associated time-of-day will likely be off in the result.\n• Scrutinize your code carefully. Search for anything time related, and go over it with a fine-toothed comb.\n• Make sure you have lots of unit tests, and know how to \"mock the clock\" (described in the next section).\n• Test year-round, not just before leap years.\n\nI'm often asked about two other approaches:\n\nIt would be wonderful if there was just a set of tools you could run against your code that would point out where you had leap-year bugs. Unfortunately, I don't know of any. Simple string-search, or even regex search, can only get you so far.\n\nTruly what is needed for .NET is a comprehensive set of Roslyn Analyzers that can catch common date/time bugs including leap year, time zone, daylight saving time, parsing, and more. Unfortunately, I have not the time to create such analyzers myself. Maybe I'll get to that at some point in the future, but it doesn't exist today.\n\nIt would also be nice to have similar tools for C++, JavaScript, and other languages. Though I know of none.\n\nWhy not just move the clock forward and see what happens? That might actually work for some systems, but there's a few problems with this idea.\n• Your unit tests might still not catch everything. You probably won't catch data filtering errors unless you actually look (manually) at every screen and report of your entire application. This is error prone for sure.\n• You might develop a false sense of security, believing everything to be ok. Only when your customers call complaining on February 29th or March 1st will you realize how wrong you were.\n• Many systems have to authenticate with domain servers, or use other authentication schemes that are time sensitive. Recognize that the Kerberos protocol has strict time sync requirements, with a default tolerance of 5 minutes. Also consider that SSL certificates, code signing certificates, and other security-related things are clock dependent and will fail if you try to lie about what time it really is.\n\nSo, in general, I recommend against this approach.\n\nHow do you test code that behaves differently on different dates? Mock the clock!\n\nThis is a common pattern found in many reliable systems. The key point is that the system clock - you know, the thing that tells you what time it is - should not be used haphazardly. Application logic should never make a direct call to or or or or whatever the equivalent is in your language to get the current date and time.\n\nInstead, you should treat the clock as a service (in the DDD sense), and like any service, you should be able to mock it.\n\nFor example, in .NET, instead of directly calling (or similar APIs) from application logic:\n• Create an interface with a method that returns a .\n• Create a class that implements from , where calls .\n• Create a class that implements , which accepts a fixed value as a constructor parameter and where simply returns the fixed value.\n• In your application logic, only depend on the interface. Typically this is constructor injected.\n• Use a during testing, and wire up a at runtime.\n\nThis may sound like a lot of work, but once you go through the motions you'll see where it has advantages. This is truly the only way to ensure all of your code is tested when the current date and time are dependencies.\n\nI intentionally did not provide code for this here, as the pattern should be the same for many different languages. Also, there's already a really great implementation of this in Noda Time, which comes with and in the main assembly, and in the assembly. You'd do well to use Noda Time for this, and many other reasons.\n\nLeap year is here. It's not Y2K, or Y2038, but it is something we have to contend with on a regular basis. How much code did you write over the last four years? Are you sure it's all up to par? Take the time now to test and scan through your code. You will probably find a few things you didn't realize were lurking in the shadows."
    },
    {
        "link": "https://beta.boost.org/doc/libs/1_85_0/libs/locale/doc/html/dates_times_timezones.html",
        "document": "There are several important flaws in the standard C, C++ and Boost libraries that handle dates and time:\n• The biggest flaw of most libraries that provide operations over dates is the fact that they only support the Gregorian calendar. , , and standard functions like and , all assume the Gregorian calendar.\n• The information about local start of week is not provided. \n\n For example the standard C and C++ library has and , but they do not give user the information about the first day of week. This information is locale dependent. It is Monday in France and it is Sunday in United States.\n\nBoost.Locale provides generic date_time, and calendar classes that allow you to perform operations on dates and times for non-Gregorian calendars such as Hebrew, Islamic, Japanese and others.\n\nNon-ICU based backends support the Gregorian calendar only. Unlike , they are fully aware of the local first day of week. Thus, if the current day of week is Monday, then setting \"current day of week\" to Sunday would move the actual date 6 days forward in Russian or French locales and move one day backward in USA and Israeli locales.\n• boost::locale::calendar – represents generic information about the calendar, independent from a specific time point. For example, you can get the maximum number of days in a month for a specific calendar.\n• boost::locale::date_time – represents a time point. It is constructed from a calendar and allows manipulation of various time periods.\n• boost::locale::period – holds a list of functions that represent various periods, such as month, year, day, and hour, allowing manipulation of dates and times. You can add periods, multiply them by integers, get or set them, or add them to date_time objects.\n\nYou can calculate the difference between dates by dividing the difference by a period:\n\nYou can also use different syntax (less operator overloading)\n\ndate_time – provides the member functions minimum and maximum to get the information about smallest and largest possible values of a certain period for a specific time.\n\nFor example, for February the would be 28 (or 29 for a leap year), and for January it would be 31.\n\nWe recommend you to look at the example provided with this library to get an understanding of how to manipulate dates and times using these classes.\n\nTo convert between various calendar dates, you may get the current POSIX time via the time member function.\n\nNon-ICU based backends support the same date-time range as and C library functions.\n• Windows: dates from 1970. If the is 32 bits wide (mingw), then the upper limit is year 2038\n\nThe current operating system's time zone is used by default, however the time zone can be modified at several different levels:\n• Calendar level: you can specify a timezone when creating a new instance of boost::locale::calendar in its constructor.\n• iostream level: you can use as::time_zone manipulator to set a specific time zone to the iostream so all dates and times would be represented in this time zone\n• You can specify the default global time zone by calling: boost::locale::time_zone::global(std::string const &). This time zone would be the default one for newly created iostream object and calendar instances.\n\nNon-ICU based backends support only two kinds of time zones:\n• The current OS time zone, as it is handled by and the standard library functions - the default time zone\n• Simple time zone in format \"GMT+HH:MM\" - the time zone represented using fixed shift from the UTC without support of daylight saving time.\n• Writing POSIX time as number that is fetched by calling date_time::time() function.\n\nFor example this code:\n\nWould print something like this (using the default format):\n\nHowever if you need to change the default behavior (for example show only date), then you need to use specific iostream manipulators in order to display current date or time.\n\nWould print something like:\n\nThis is important to remember that object is always rendered and parsed in the context of the locale and time zone and not in the context of specific object.\n\nWhy should I use Boost.Locale over Boost.DateTime when I only need the Gregorian calendar?\n• Boost.DateTime is locale agnostic library and ignores the fact that the first day of week varies by the locale.\n• Boost.Locale provides a unified access to date and time in time zone aware way. It represents a time as universal scalar - the POSIX time and over that builds dates, local times and time-zones handling. \n\n For example, may be not equal to because of daylight savings time.\n\nWhy don't you use Boost.DateTime time zone support?\n\nBoost.DateTime's time zone support is broken. Time zones can not be represented with a simple table of rules where daylight saving depend only on certain n'th day of week in month. The daylight savings time may vary by year, political issues, and many other things.\n\nMost of the modern operating systems (Linux, *BSD, Mac OS X, OpenVMS) and many important software packages (ICU, Java, Python) use so called Olson database in order to handle daylight saving time correctly.\n\nIf you need full time zone database support, then you should use ICU library."
    }
]