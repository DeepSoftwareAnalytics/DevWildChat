[
    {
        "link": "https://stackoverflow.com/questions/38237789/conversion-from-shared-ptr-to-weak-ptr-polymorphism",
        "document": "I am having trouble getting around this one. Let's say I have this vector\n\nCar is an abstract class. I want to be able to return weak pointers of different types so I do the following.\n\nI get the following error though when I try to use the function with a class that inherits from Car. Error C2440 'initializing': cannot convert from 'std::shared_ptr<Car>' to 'std::weak_ptr<Saab>' There might not be a valid car when asked for it. I tried using boost::optional but it does not handle polymorphism . I might go with raw pointers if I can't get this to work."
    },
    {
        "link": "https://stackoverflow.com/questions/66768249/what-are-best-use-cases-of-shared-ptr-unique-ptr-and-weak-ptr",
        "document": "I assume you know what each of these smart pointers do so I am not going to explain them. Instead I will give you examples of how I have used them in my own code or from libraries I have used that need them.\n\nstd::unique_ptr: Can be returned from an API to indicate that the resource needs to be managed by the caller and that it is not safe to share the object. For example, gRPC creates instances like this. has sensitive lifetime and synchronization requirements. By returning it is clear that the caller is responsible for lifetime management and it makes it cumbersome to share the . It is still not impossible to share it (can get the raw pointer from the or use a reference to the , both of which are typically code smells).\n\nstd::shared_ptr/std::weak_ptr: Not the simplest use case, but here we go...\n\nIn this example, all instances on a thread need to have their audio mixed together using . So, each has a so that when the last instance holding the is destroyed, the mixer will be as well. The usage of just facilitates having a unique per thread. The storage of the should not prolong the life of the mixer as the lifetime of the is decided by the existence of instances (ie. no => no ) - this is why a is used. means that either no has been created on this thread or all previously existing players were deleted. means another exists on this thread and the current needs to get a to the same mixer. Note you have to be careful when using and from multiple threads as they are not thread safe. In this example, and the fact that is only created and destroyed within the same thread ensures it is safe.\n\nOf course, this could have all be done without the smart pointers but the smart pointers help communicate the intent of the code better."
    },
    {
        "link": "https://learncpp.com/cpp-tutorial/circular-dependency-issues-with-stdshared_ptr-and-stdweak_ptr",
        "document": "In the previous lesson, we saw how std::shared_ptr allowed us to have multiple smart pointers co-owning the same resource. However, in certain cases, this can become problematic. Consider the following case, where the shared pointers in two separate objects each point at the other object:\n\nIn the above example, we dynamically allocate two Persons, “Lucy” and “Ricky” using make_shared() (to ensure lucy and ricky are destroyed at the end of main()). Then we partner them up. This sets the std::shared_ptr inside “Lucy” to point at “Ricky”, and the std::shared_ptr inside “Ricky” to point at “Lucy”. Shared pointers are meant to be shared, so it’s fine that both the lucy shared pointer and Rick’s m_partner shared pointer both point at “Lucy” (and vice-versa).\n\nHowever, this program doesn’t execute as expected:\n\nAnd that’s it. No deallocations took place. Uh oh. What happened?\n\nAfter partnerUp() is called, there are two shared pointers pointing to “Ricky” (ricky, and Lucy’s m_partner) and two shared pointers pointing to “Lucy” (lucy, and Ricky’s m_partner).\n\nAt the end of main(), the ricky shared pointer goes out of scope first. When that happens, ricky checks if there are any other shared pointers that co-own the Person “Ricky”. There are (Lucy’s m_partner). Because of this, it doesn’t deallocate “Ricky” (if it did, then Lucy’s m_partner would end up as a dangling pointer). At this point, we now have one shared pointer to “Ricky” (Lucy’s m_partner) and two shared pointers to “Lucy” (lucy, and Ricky’s m_partner).\n\nNext the lucy shared pointer goes out of scope, and the same thing happens. The shared pointer lucy checks if there are any other shared pointers co-owning the Person “Lucy”. There are (Ricky’s m_partner), so “Lucy” isn’t deallocated. At this point, there is one shared pointer to “Lucy” (Ricky’s m_partner) and one shared pointer to “Ricky” (Lucy’s m_partner).\n\nThen the program ends -- and neither Person “Lucy” or “Ricky” have been deallocated! Essentially, “Lucy” ends up keeping “Ricky” from being destroyed, and “Ricky” ends up keeping “Lucy” from being destroyed.\n\nIt turns out that this can happen any time shared pointers form a circular reference.\n\nA Circular reference (also called a cyclical reference or a cycle) is a series of references where each object references the next, and the last object references back to the first, causing a referential loop. The references do not need to be actual C++ references -- they can be pointers, unique IDs, or any other means of identifying specific objects.\n\nIn the context of shared pointers, the references will be pointers.\n\nThis is exactly what we see in the case above: “Lucy” points at “Ricky”, and “Ricky” points at “Lucy”. With three pointers, you’d get the same thing when A points at B, B points at C, and C points at A. The practical effect of having shared pointers form a cycle is that each object ends up keeping the next object alive -- with the last object keeping the first object alive. Thus, no objects in the series can be deallocated because they all think some other object still needs it!\n\nIt turns out, this cyclical reference issue can even happen with a single std::shared_ptr -- a std::shared_ptr referencing the object that contains it is still a cycle (just a reductive one). Although it’s fairly unlikely that this would ever happen in practice, we’ll show you for additional comprehension:\n\nIn the above example, when ptr1 goes out of scope, the Resource is not deallocated because the Resource’s m_ptr is sharing the Resource. At that point, the only way for the Resource to be released would be to set m_ptr to something else (so nothing is sharing the Resource any longer). But we can’t access m_ptr because ptr1 is out of scope, so we no longer have a way to do this. The Resource has become a memory leak.\n\nSo what is std::weak_ptr for anyway?\n\nstd::weak_ptr was designed to solve the “cyclical ownership” problem described above. A std::weak_ptr is an observer -- it can observe and access the same object as a std::shared_ptr (or other std::weak_ptrs) but it is not considered an owner. Remember, when a std::shared pointer goes out of scope, it only considers whether other std::shared_ptr are co-owning the object. std::weak_ptr does not count!\n\nFunctionally, it works almost identically to the problematic example. However, now when ricky goes out of scope, it sees that there are no other std::shared_ptr pointing at “Ricky” (the std::weak_ptr from “Lucy” doesn’t count). Therefore, it will deallocate “Ricky”. The same occurs for lucy.\n\nOne downside of std::weak_ptr is that std::weak_ptr are not directly usable (they have no operator->). To use a std::weak_ptr, you must first convert it into a std::shared_ptr. Then you can use the std::shared_ptr. To convert a std::weak_ptr into a std::shared_ptr, you can use the lock() member function. Here’s the above example, updated to show this off:\n\nWe don’t have to worry about circular dependencies with std::shared_ptr variable “partner” since it’s just a local variable inside the function. It will eventually go out of scope at the end of the function and the reference count will be decremented by 1.\n\nConsider the case where a normal “dumb” pointer is holding the address of some object, and then that object is destroyed. Such a pointer is dangling, and dereferencing the pointer will lead to undefined behavior. And unfortunately, there is no way for us to determine whether a pointer holding a non-null address is dangling or not. This is a large part of the reason dumb pointers are dangerous.\n\nBecause std::weak_ptr won’t keep an owned resource alive, it’s similarly possible for a std::weak_ptr to be left pointing to a resource that has been deallocated by a std::shared_ptr. However, std::weak_ptr has a neat trick up its sleeve -- because it has access to the reference count for an object, it can determine if it is pointing to a valid object or not! If the reference count is non-zero, the resource is still valid. If the reference count is zero, then the resource has been destroyed.\n\nThe easiest way to test whether a std::weak_ptr is valid is to use the member function, which returns if the std::weak_ptr is pointing to an invalid object, and otherwise.\n\nHere’s a simple example showing this difference in behavior:\n\nBoth and use a smart pointer to allocate a Resource -- this smart pointer ensures that the allocated Resource will be destroyed at the end of the function. When returns a Resource*, it returns a dangling pointer (because std::unique_ptr destroyed the Resource at the end of the function). When returns a std::weak_ptr, that std::weak_ptr is similarly pointing to an invalid object (because std::shared_ptr destroyed the Resource at the end of the function).\n\nInside main(), we first test whether the returned dumb pointer is . Because the dumb pointer is still holding the address of the deallocated resource, this test fails. There is no way for to tell whether this pointer is dangling or not. In this case, because it is a dangling pointer, if we were to dereference this pointer, undefined behavior would result.\n\nNext, we test whether is . Because the reference count for the object being pointed to by is (because the object being pointed to was already destroyed), this resolves to . The code in can thus tell that is pointing to an invalid object, and we can conditionalize our code as appropriate!\n\nNote that if a std::weak_ptr is expired, then we shouldn’t call on it, because the object being pointed to has already been destroyed, so there is no object to share. If you do call on an expired std::weak_ptr, it will return a std::shared_ptr to .\n\nstd::shared_ptr can be used when you need multiple smart pointers that can co-own a resource. The resource will be deallocated when the last std::shared_ptr goes out of scope. std::weak_ptr can be used when you want a smart pointer that can see and use a shared resource, but does not participate in the ownership of that resource.\n• Fix the program presented in the section “A reductive case” so that the Resource is properly deallocated. Do not alter the code in .\n\nHere is the program again for ease of reference:"
    },
    {
        "link": "https://medium.com/@sylvain.tiset/the-secret-of-smart-pointers-in-c-4d3446b3796e",
        "document": "Some issues with pointers are listed here:\n• Memory Leaks: when memory is repeatly allocated but never freed.\n• Dangling Pointers: when the object is de-allocated from memory without modifying the value of the pointer.\n• Wild Pointers: when a pointer is declared and allocated memory but never initialized to point to any valid object or address.\n• Data Inconsistency: when some data is stored in memory but is not updated in a consistent manner.\n• Buffer Overflow: when a pointer is used to write data to a memory address that is outside of the allocated memory block.\n\nHere is a simple example were the memory is not freed, leading to a memory leak.\n\nA smart pointer is used to make sure that an object is deleted if it is no longer used (referenced). It’s a wrapper class over a pointer with an operator like * and -> overloaded.\n\nHere are some key differences between pointers and smart pointers\n\nLet’s review each of them.\n\nAuto_ptr is an object that stores a pointer to a single allocated object that ensures that the object to which it points gets destroyed automatically when control leaves a scope.\n\nStarting in C++11, use unique_ptr instead of auto_ptr. Auto_ptr was deprecated in C++11 and removed in C++17.\n\nThe main problem with auto_ptr is when we copy the auto_ptr then the source auto_ptr will lose the reference to the underlying object.\n\nUnique_ptr stores one pointer only. Different object can be assigned by removing the current object from the pointer.\n• A unique_ptr incorporates exclusive ownership of the object it points to.\n• When the std::unique_ptr is deleted and it is not empty, it automatically destroys the object it points to.\n• A unique_ptr can be moved using std::move.\n• It’s not possible to assign a pointer to a unique_ptr. A unique_ptr should rather be created by using std::make_unique.\n• A unique_ptr can be converted to a shared_ptr.\n\nShared_ptr can store more than one pointer to point to the same object. It manages the lifetime of an object using the reference count, using the method use_count().\n• When all the shared pointers (pointing to the same object) go out of scope, the reference count reaches 0, the object they were pointing to is deleted.\n• Don’t initialize both shared_ptr objects with the same raw pointer, or it will be deleted twice. Use std::make_shared instead.\n\nWeak_ptr is a smart pointer that holds a non-owning reference to an object. Like shared pointers, several pointers can point to the same object. However, no reference count is maintained. It allows locating an object if it’s still around, but doesn’t keep it around if nothing else needs it.\n• It must be converted to a shared_ptr in order to access the referenced object.\n• Lock and expired methods are used to ensure the validity of a pointer.\n• Is a good way to solve the dangling pointer problem.\n• Useful to break reference cycles formed by objects managed by shared pointers. One of the pointers in the cycle can be made weak.\n• Use unique_ptr when you want your object to live just as long as a single owning reference to it lives.\n• Use shared_ptr when you want to refer to your object from multiple places, and you don’t want your object to be de-allocated until all these references are themselves gone.\n• Use weak_ptr when you want to refer to your object from multiple places - for those references for which it's ok to ignore and deallocate.\n• Don’t use auto_ptr, it’s deprecated. Use a unique pointer instead.\n• Don’t use a shared pointer if a unique pointer is enough. A shared pointer is more memory intensive than a unique pointer. Moreover, a unique pointer can be converted to a shared pointer.\n• Don’t create cyclic shared pointer. Use a weak pointer to break the cycle.\n• Use the std::make_shared method to initialize a shared pointer instead of using new.\n\nFirst, for performance reason. When creating an object with new, and then creating a shared pointer, there are 2 dynamic memory allocations. One for the object itself (from the new), and another for the control block object created by the shared pointer constructor.\n\nThe other reason is for exception safety. Let’s look at this example:\n\nThe problem occurs if the method doSomethingThatThrow() throws, the new A object will be created in the first step but since no shared pointer contain it, the program will leak. This is because new allocates memory before the constructor of A is called, and if an exception is thrown during the construction of A, the shared pointer doesn't get a chance to take ownership of the allocated memory, and thus cannot properly release it."
    },
    {
        "link": "https://reddit.com/r/cpp_questions/comments/qxe9p5/why_use_stdweak_ptr_and_whats_the_difference",
        "document": "Create your account and connect with a world of communities.\n\nBy continuing, you agree to our\n\nand acknowledge that you understand the"
    },
    {
        "link": "https://stackoverflow.com/questions/10498292/c-why-is-const-cast-evil",
        "document": "The use of for any reason other than adapting to (old) libraries where the interfaces have non-const pointers/references but the implementations don't modify the arguments is wrong and dangerous.\n\nThe reason that it is wrong is because when your interface takes a reference or pointer to a constant object you are promising not to change the object. Other code might depend on you not modifying the object. Consider for example, a type that holds an expensive to copy member, and that together with that it holds some other invariants.\n\nConsider a and a precomputed average value, the *average is updated whenever a new element is added through the class interface as it is cheap to update then, and if it is requested often there is no need to recompute it from the data every time. Because the vector is expensive to copy, but read access might be needed the type could offer a cheap accessor that returns a for user code to check values already in the container. Now, if user code casts away the const-ness of the reference and updates the vector, the invariant that the class holds the average is broken and the behavior of your program becomes incorrect.\n\nIt is also dangerous because you have no guarantee that the object that you are passed is actually modifiable or not. Consider a simple function that takes a C null terminated string and converts that to uppercase, simple enough:\n\nNow lets assume that you decide to change the interface to take a , and the implementation to remove the . User code that worked with the older version will also work with the new version, but some code that would be flagged as an error in the old version will not be detected at compile time now. Consider that someone decided to do something as stupid as . Now the problem is that the result of is not just a constant reference to a modifiable object, but rather a reference to a constant object. The compiler is free to store the object in a read-only segment and the loader to load it in a read-only page of memory. Attempting to change it will crash your program.\n\nNote that in both cases, you cannot know from the context of the whether extra invariants are maintained (case 1) or even if the object is actually constant (case 2).\n\nOn the opposite end, the reason for to exist was adapting to old C code that did not support the keyword. For some time functions like would take a , even though it is known and documented that the function will not modify the object. In that case it is safe to use to adapt the type, not to change the const-ness. Note that C has support for for a very long time already, and has lesser proper uses."
    },
    {
        "link": "https://stackoverflow.com/questions/2673508/correct-usages-of-const-cast",
        "document": "As a common rule, it is very often considered a bad practice to use in C++ code as it reveals (most of the time) a flaw in the design.\n\nWhile I totally agree with this, I however wonder what are the cases were using is ok and the only solution.\n\nCould you guys please give me some examples you know/you encountered ?\n\nThank you very much."
    },
    {
        "link": "https://geeksforgeeks.org/const_cast-in-c-type-casting-operators",
        "document": "C++ supports following 4 types of casting operators:\n\n1. const_cast\n\n const_cast is used to cast away the constness of variables. Following are some interesting facts about const_cast.\n\n1) const_cast can be used to change non-const class members inside a const member function. Consider the following code snippet. Inside const member function fun(), ‘this’ is treated by the compiler as ‘const student* const this’, i.e. ‘this’ is a constant pointer to a constant object, thus compiler doesn’t allow to change the data members through ‘this’ pointer. const_cast changes the type of ‘this’ pointer to ‘student* const this’.\n\n\n\n 2) const_cast can be used to pass const data to a function that doesn’t receive const. For example, in the following program fun() receives a normal pointer, but a pointer to a const can be passed with the help of const_cast.\n\n\n\n 3) It is undefined behavior to modify a value which is initially declared as const. Consider the following program. The output of the program is undefined. The variable ‘val’ is a const variable and the call ‘fun(ptr1)’ tries to modify ‘val’ using const_cast.\n\nIt it fine to modify a value which is not initially declared as const. For example, in the above program, if we remove const from declaration of val, the program will produce 20 as output.\n\n\n\n 4) const_cast is considered safer than simple type casting. It’safer in the sense that the casting won’t happen if the type of cast is not same as original object. For example, the following program fails in compilation because ‘int *’ is being typecasted to ‘char *’\n\n\n\n 5) const_cast can also be used to cast away volatile attribute. For example, in the following program, the typeid of b1 is PVKi (pointer to a volatile and constant integer) and typeid of c1 is Pi (Pointer to integer)\n\n\n\n Exercise\n\n Predict the output of following programs. If there are compilation errors, then fix them."
    },
    {
        "link": "https://reddit.com/r/cpp/comments/1fkjasv/usage_of_const_cast_to_prevent_duplicating",
        "document": "During another post, a discussion regarding came up. In summary, it was noted that if is necessary, the code is most likely of bad structure. I want to present a situation I stumble over, some years ago, where I used in order to prevent copying and pasting functions.\n\nFirst, let's start with the conditions. There is a class, let's call it and this class summarizes several objects. However, for this example, it is sufficient to consider a single integer as part of it is important that not the integer itself is part of but a pointer (This cannot be changed):\n\nNow consider that should be accessible through a getter. In case, the object is constant, the getter should return a constant pointer. If is mutable, the getter should return a mutable pointer. Let's check that code:\n\nThose are the conditions. Now let's check how to do that. First, two functions are needed. One for the constant version and one for the mutable version:\n\n// Some stuff to that needs to be done in order to find the o, which should be returned is not needed for this minimal example, but in the original problem, it was needed. So it is important to note that it was not just able to access , but would have been searched for.\n\nNow there are two possibilities to define the mutable version of . First one is to simply copy the code from above:\n\nHowever, the problem with that is that the code searching for would have been duplicated, which is bad style. Because of that, I decided to go with the second solution:\n\nThis avoids duplicating // Some stuff to that needs to be done in order to find the o, which should be returned , however it might be a bit complicate to understand.\n\nNow that I presented you the problem and the solutions, I am very excited to hear what you guys think about the problem, and both solutions. Which solution would you prefer? Can you think of another solution?"
    },
    {
        "link": "https://linkedin.com/pulse/understanding-constcast-c-navigating-const-mahmoud-gamal-yekhf",
        "document": "C++ is a language rich in features. One such feature is the const qualifier, which guarantees that a value cannot be modified after initialization. This promise enhances code safety and readability. However, there are scenarios where you might need to bypass this immutability, and const_cast is the tool designed for this purpose. But with great power comes great responsibility. This article explores how to use const_cast responsibly, highlighting its valid use cases and pointing out practices to avoid.\n\nconst_cast is a type of casting operator in C++ that can add or remove the const qualifier from a variable. Unlike static, dynamic, or reinterpret casts, const_cast solely focuses on constness, making it unique in its purpose and use cases.\n\nThe primary legitimate use of const_cast is interfacing with code that requires non-const arguments but does not modify them. This scenario often arises when working with legacy code or libraries that were not designed with const correctness in mind.\n\n// A legacy function that requires a non-const char* argument but does not // modify the string void legacyPrint(char* str) { std::cout << str << std::endl; } int main() { const char* constString = \"Hello, World!\"; // Safely using const_cast to interface with legacy code legacyPrint(const_cast<char*>(constString)); return 0; }\n\nIn this example, const_cast allows us to call legacyPrint with a const string by temporarily removing its const qualifier. This is considered safe because the function does not alter the string.\n\nWhile const_cast can be a powerful tool, it should not be used to modify objects initially declared as const. Doing so leads to undefined behavior, which can manifest as runtime errors, crashes, or unpredictable behavior.\n• Use const_cast only when interfacing with non-const code that does not modify the object.\n• Avoid using const_cast to remove constness for the purpose of modification.\n• Consider redesign or refactoring if const_cast becomes a common tool in your codebase; it might indicate underlying design issues.\n\nconst_cast serves a specific purpose in C++ programming, allowing developers to interface with legacy code that lacks const correctness. However, its misuse can lead to severe issues, emphasizing the need for careful and informed application."
    }
]