[
    {
        "link": "https://geeksforgeeks.org/ipc-using-message-queues",
        "document": "A Message Queue is a linked list of messages stored within the kernel and identified by a message queue identifier. A new queue is created or an existing queue is opened by msgget(). New messages are added to the end of a queue by msgsnd(). Every message has a positive long integer type field, a non-negative length, and the actual data bytes (corresponding to the length), all of which are specified to msgsnd() when the message is added to a queue. Messages are fetched from a queue by msgrcv(). We don’t have to fetch the messages in a first-in, first-out order. Instead, we can fetch messages based on their type field.\n\nAll processes can exchange information through access to a common system message queue. The sending process places a message (via some (OS) message-passing module) onto a queue which can be read by another process. Each message is given an identification or type so that processes can select the appropriate message. Processes must share a common key to gain access to the queue in the first place.\n• ftok() : is use to generate a unique key.\n• msgget() : either returns the message queue identifier for a newly created message queue or returns the identifiers for a queue which exists with the same key value.\n• msgsnd() : Data is placed on to a message queue by calling msgsnd().\n• msgctl() : It performs various operations on a queue. Generally it is use to destroy message queue.\n\nThe Inter-Process Communication (IPC) is essential for the enabling processes to the communicate and synchronize with the each other in an operating system. Among the various IPC mechanisms message queues provide the robust and flexible method for the processes to exchange data in a queued orderly fashion. This article will explore how IPC is achieved using the message queues the functions of message queues their advantages and disadvantages and will conclude with the common FAQs.\n\nThe Message queues are powerful IPC tools that allow processes to send and receive messages in the FIFO (First In, First Out) order. Here are the primary functions of the message queues:\n\nA message queue stores messages sent by the one process until they are retrieved by the another process. Each message is placed in the queue and remains there until it is read by the receiving process.\n\nThe Message queues ensure that messages are delivered in the order they were sent. This ordered communication is vital in the scenarios where the sequence of the operations matters.\n\nWith message queues, processes do not need to be synchronized or directly connected. A sending process can place a message in the queue and receiving process can retrieve it later allowing for the asynchronous communication.\n\nThe Message queues allow processes to be decoupled meaning the sending and receiving processes do not need to be aware of the each other’s existence or state. They interact indirectly through the queue which can improve modularity and scalability.\n\nThe Some message queue implementations allow the messages to be prioritized where certain messages can be processed before others based on the priority levels.\n\nThe Message queues can be designed to handle errors such as retries for the failed message deliveries or logging of the undelivered messages for the troubleshooting.\n\nThe Message queues are an essential IPC mechanism that provides the reliable way for the processes to communicate asynchronously and in an orderly manner. They are particularly useful in the distributed systems where processes need to the communicate across different machines or in systems where processes need to exchange data without being tightly coupled. However, while message queues offer many benefits they also the introduce complexity in the terms of message management, error handling and potential performance overhead.\n\nWhat is a message queue in IPC?\n\nHow does a message queue differ from shared memory?"
    },
    {
        "link": "https://stackoverflow.com/questions/42247445/c-signal-usage-and-process-using-ipc-message-queues",
        "document": "I have a program that uses a signal (SIGUSR2) for setup a catch handler function to process high priority incoming messages.\n\nThe program receives incoming messages off an IPC message queue using msgrcv() in its main loop. When the sender of messages to the IPC message queue wants to notify the program that a high priority one is incoming, it sends SIGUSR2 to the process to have it stop processing any current message that may be being processed.\n\nIn the signal catch handler function I first upon entry do:\n\nto ignore any new signals for preemption to occur.\n\nthen the code processes the preemption request where it stores the currently being processed message back into the queue, housekeeping, etc. and then just before returning from the signal handler function it does:\n\nQuestion: If another flash processing signal is received just a nanosecond after the above signal call is issued, will the process re-dispatch to the signal handler function again? ie: if the code in the main loop where it does the sighold(SIGUSR2) and sigrelse(SIGUSR2) to stop / start the receipt of the preemption signal take precedence or is it just the above signal call that re-energizes the signal handler?"
    },
    {
        "link": "https://softprayog.in/programming/interprocess-communication-using-system-v-message-queues-in-linux",
        "document": "Message queues are one of the interprocess communication mechanisms available under Linux. Message queues, shared memory and semaphores are normally listed as the three interprocess communication mechanisms under Linux. Semaphores, though, are really for process synchronization. In practice, shared memory, aided by semaphores, makes an interprocess communication mechanism. Message queues is the other interprocess communication mechanism.\n\nThere are two varieties of message queues, System V message queues and POSIX message queues. Both provide almost the same functionality but system calls for the two are different. System V message queues have been around for a long time, since the UNIX systems of 1980s and are a mandatory requirement of Unix-certified systems. POSIX message queues (and the complete POSIX IPC calls) were introduced in 1993 and are still an optional requirement of Unix-certified systems. This tutorial is for System V message queues.\n\nThere are three system wide limits regarding the message queues. These are, MSGMNI, maximum number of queues in the system, MSGMAX, maximum size of a message in bytes and MSGMNB, which is the maximum size of a message queue. We can see these limits with the ipcs -l command.\n\nYou can query and, if required, modify the corresponding kernel parameters, kernel.msgmni, kernel.msgmax and kernel.msgmnb using the sysctl command.\n\nTo create a System V message queue, we need a System V IPC key. We can create the key with the ftok function.\n\nThe pathname must be an existing and accessible file. The contents of this file are immaterial. Only the lowest eight bits of proj_id are used, which must not be zero. A System V IPC key of type key_t is returned.\n\nEach instance of a System V IPC mechanism, the message queue, semaphore and shared memory, has an associated system-wide identifier. A process knowing this identifier, and having the relevant permission, can straightaway use that mechanism instance. For example, if a process knows the identifier of a certain message queue, it can send and receive messages from it provided it has the write and read permissions respectively. It does not need to do msgget, an operation analogous to open for files.\n\nThe msgget system call gets the message queue identifier for the given key. The key is obtained using the ftok function. The second parameter is msg_flags. If the IPC_CREAT flag is set in msg_flags, the queue is created, if it does not already exist. If IPC_EXCL is specified along with IPC_CREAT and the message queue exists, msgget returns -1, with errno set to EEXIST. Queue permissions are expressed as nine bits comprising of read, write and execute for owner, group and others. The execute permissions are not meaningful and are not used. If the queue is created, lower order 9 bits from msg_flags are used for permissions. On success, msgget returns the message queue identifier, which is a nonnegative integer.\n\nThere is a special key, IPC_PRIVATE. If the first parameter to msgget is IPC_PRIVATE, a new queue is created. The last nine bits of msg_flags are used for permissions and the other bits are ignored. Thus, it is not necessary to specify IPC_CREAT in msg_flags. This is particularly useful for clients. A client process can create a new queue with the key IPC_PRIVATE and send the queue id in the request message to the server. The server uses that queue id for sending the response message to the client.\n\nWith msgctl, we can do control operations on a message queue identified by msqid. The cmd parameter identifies the operation to be done. The value of cmd can be IPC_RMID, IPC_STAT and IPC_SET. When cmd is IPC_RMID, the message queue is removed. The cmd value IPC_STAT transfers the kernel information for the message queue in the msqid_ds structure pointed by buf. Similarly, the cmd value IPC_SET updates the message queue properties in the kernel for the queue from the msqid_ds structure pointed by buf. The queue properties updated are msg_qbytes, msg_perm.uid, msg_perm.gid and the last nine bits of msg_perm.mode. The value of msg_ctime for the queue is also updated.\n\nThe msgsnd system call is used to sending messages to a System V message queue. A process using msgsnd must have the write permission for the message queue. The message queue is identified by the msqid parameter in the msgsnd call. The next parameter points to the message to be sent. The structure of the message is of the form,\n\nA message comprises of message_type, a long integer greater than zero, followed by message_text. message_text can be an array or any structure. The size of message_text is the msgsz parameter in the msgsnd call. It is OK to have messages with zero length, which means that the message just contains the message type and that there is no message_text.\n\nIn most cases, the value of msgflg would be zero. However, the maximum queue size is governed by the msg_qbytes variable in the msqid_ds structure for a queue. When a queue is created, msg_qbytes is initialized to MSGMNB bytes. This can be changed using the msgctl call. If the queue is and adding another message would cause number of bytes in the queue to exceed msg_qbytes, msgsnd blocks till the time the message being sent can be accommodated in the queue. If you do not want msgsnd to block in such cases, you can specify msgflg as IPC_NOWAIT and msgsnd would return -1 in the case of queue being full with errno set to EAGAIN.\n\nThe msgrcv system call is for receiving messages from a System V message queue identified by msqid. The parameter msgp points to the buffer for incoming message and msgsz specifies the maximum space available for message_text member of the message. On success, msgrcv returns the number of bytes actually copied in the message_text member of the structure pointed by msgp. If the actual message to be delivered is bigger than msgsz and msgflg has MSG_NOERROR specified, the message is truncated and the first msgsz bytes of the message text are returned in mesage_text member. However, if MSG_NOERROR is not specified in msgflg, message is not taken off the queue and msgrcv returns -1 with errno set to E2BIG.\n\nThe message selected from the queue depends on the msgtyp parameter. If msgtyp is 0, the first message from the queue is read. This looks like a reasonable behavior and should suffice for most applications.\n\nIf msgtyp is greater than 0, and msgflg does not specify MSG_EXCEPT, the first message of that type is returned from the queue. Or, if MSG_EXCEPT is specified in msgflg, the first message not of that type in the queue is returned.\n\nIf msgtyp is less than zero, the first message of the lowest type, which is less than or equal to the absolute value of msgtyp, is returned.\n\nIf there is no message in the queue, msgrcv blocks till the time a message becomes available. However, if IPC_NOWAIT is specified in the msgflg argument, and there is no message in the queue, msgrcv returns -1 immediately with errno set to ENOMSG.\n\n6.0 An Example: Client Server Communication using System V message queues\n\nAs an example, we will develop a server and clients which communicate using the System V message queues. The server listens for requests from clients. The clients send a line of text to server. The server counts the number of characters in the received line, appends the count to the line and sends it back to the client. In real life, a server would provide a more useful service. But, our objective is to illustrate the communication between the server and clients using message queues and the server functionality takes a backseat. The software architecture looks like this.\n\nThe server has a message queue. Its details, the parameters to the ftok function, are known to clients. The clients use these parameters to get the server queue identifier for communicating with the server. The clients create their queue with the key IPC_PRIVATE and embed their queue identifier in the request message to the server. The server does its processing, takes the queue id from the received message and sends its response message to that queue.\n\nThe messages exchanged between the clients and server have the structure,\n\nThe message comprises of a long integer message_type as required by System V message queues. We will use the integer value 1 as the message_type. message_type is followed by message_text which contains the sender queue id and a buffer for the message. To keep things simple we use the same structure for messages both ways, from clients to the server and from the server to clients. Both the client and server put their queue id in the member qid before sending a message. The server uses the client’s queue id to send response message. The clients, of course, need to know the server’s queue id beforehand as they initiate communication with the server. Or, more precisely, clients need to know the parameters to the ftok function call from which they can figure out the queue id of the server.\n\nThe server process works with an infinite loop. It can be terminated with the kill -9 pid command. In real life, you would make it a service with scripts to start and stop it. If you kill the server, the queue is left behind, which can be removed with the ipcrm -q qid command. You can find the qid using the ipcs -q command.\n\nFirst, we create the server key file, /tmp/mqueue_server_key. Then, the server is run in background. After that, clients can be run. A sample program execution session looks like this."
    },
    {
        "link": "https://cs.kent.edu/~ruttan/sysprog/lectures/shmem/msqueues.html",
        "document": ""
    },
    {
        "link": "https://w3.cs.jmu.edu/kirkpams/OpenCSF/Books/csf/html/MQueues.html",
        "document": "Message queues allow processes to communicate by exchanging structured messages. As with pipes and FIFOs, processes can message queues follow a message passing IPC model for exchanging data in discrete messages. However, message queues differ from pipes in several important ways:\n\nIt is important to understand the difference between messages and byte streams. Assume that one process has made 100 calls to a function to transmit a single byte at a time. If pipes or FIFOs are used, all of this data can be retrieved with a single call to that requests 100 bytes. In the case of message queues, each byte is a distinct message that must be retrieved individually. There is no short-cut to retrieve all of the data at once. Now, assume that the sending process sent all 100 bytes with one function call. If the processes are using a pipe or FIFO and the receiver requests only 50 bytes with , that process will retrieve exactly 50 bytes. However, if message queues are used, the bytes would be converted into a single message; the size of the message is determined based on the parameters used to set up the message queue. For instance, the default message size for POSIX message queues in Linux is 8192 bytes. If the receiving process requests less than this (such as requesting only 50 bytes), it will receive nothing. Ignoring the difference between a message and a byte stream can lead to unexpected behavior that causes unanticipated failures.\n\nPOSIX message queues also provide a number of key features that are not available in other interfaces, such as System V:\n\nFigure 3.6.2 illustrates a key point about POSIX message queues. In this example, assume that the messages A, B, C, D, and E have been inserted (in that order). POSIX message queues use non-negative values for the priority, with 0 being lowest. As such, messages C and D are at the front of the queue because they have the highest priority. Within a single priority level, though, the queue uses a first-in, first-out ordering.\n\nThere are six functions typically used for setting up and using POSIX message queues. Get the attributes associated with a given message queue. Send the message pointed to by msg_ptr with priority msg_prio. Receive a message into a buffer pointed to by msg_ptr and get its priority msg_prio. As with other POSIX IPC open functions, includes both an and parameter. In addition, the fourth parameter ( ) is used to specify attributes about the message queue, such as the message size or the capacity of the queue. Note that calls to must have exactly 2 or 4 parameters. Both the and parameters must be included when creating a new message queue. When opening a connection to an existing message queue, both of these parameters are omitted. To use the system defaults when setting up a message queue, pass as the fourth parameter to . Code Listing 3.7 creates a message queue for writing and sends a simple message. /* Send \"HELLO\" as a message with priority 10, then close the queue. Note the size is 6 to include the null byte '\\0'. */ Code Listing 3.8 illustrates a standard approach for retrieving a message from the queue. The parameter for receiving messages requires special attention. The use of this parameter for is intuitive and matches the behavior of functions like and : specifies the maximum number of characters in the string identified by that will be sent. However, when receiving messages, must match the size of a message. As such, the standard approach is to use and access the field of the returned. /* Retrieve message from the queue and get its priority level */ /* Clean up the allocated memory and message queue */ In many instances, it is common practice to create a statically sized buffer as a local variable (such as ) and use the buffer size when reading data from some other source. However, the following line of code will not work with message queues: The reason for this is that the parameter does not exactly match the message queue’s message size (a common default is 8192, but it depends on the system). As such, the message queue will interpret this as a request to read less than a full message and will return nothing. Unlike pipes, message queues can be used to send instances, even if some of the fields contain the value 0. (Pipes treat a byte value of 0 as the null byte and stop at that point.) Consider the following trivial declaration: As shown in Code Listing 3.9, sending the message with POSIX message queues works almost exactly as shown previously with a array. The only differences are the casting of the pointer and that the parameter is based on the size of the . Similarly, the only difference with reading is the casting of the to the type. /* When reading, use a char* buffer and explicitly cast */ The default behavior for POSIX message queues is to perform blocking I/O when writing to a full queue (or reading from an empty one). If this behavior is undesirable, there are three alternatives that can be used. The first is to include the option in the bit mask to open the queue in non-blocking mode. If the queue is ever full, will return an error without blocking. The other option is to use and , which use an additional parameter ( ) to specify the maximum amount of time to wait when blocked. Finally, rather than attempting to retrieve a message that may not have been sent, a process can use to request an asynchronous notification that a message has been sent. Interested readers should consult the language documentation for more information on these functions. Try to send a message, but specify a maximum time limit (abs_timeout) for blocking. Try to receive a message, but specify a maximum time limit (abs_timeout) for blocking. Request asynchronous notification when a message is placed in the queue."
    },
    {
        "link": "https://geeksforgeeks.org/ipc-using-message-queues",
        "document": "A Message Queue is a linked list of messages stored within the kernel and identified by a message queue identifier. A new queue is created or an existing queue is opened by msgget(). New messages are added to the end of a queue by msgsnd(). Every message has a positive long integer type field, a non-negative length, and the actual data bytes (corresponding to the length), all of which are specified to msgsnd() when the message is added to a queue. Messages are fetched from a queue by msgrcv(). We don’t have to fetch the messages in a first-in, first-out order. Instead, we can fetch messages based on their type field.\n\nAll processes can exchange information through access to a common system message queue. The sending process places a message (via some (OS) message-passing module) onto a queue which can be read by another process. Each message is given an identification or type so that processes can select the appropriate message. Processes must share a common key to gain access to the queue in the first place.\n• ftok() : is use to generate a unique key.\n• msgget() : either returns the message queue identifier for a newly created message queue or returns the identifiers for a queue which exists with the same key value.\n• msgsnd() : Data is placed on to a message queue by calling msgsnd().\n• msgctl() : It performs various operations on a queue. Generally it is use to destroy message queue.\n\nThe Inter-Process Communication (IPC) is essential for the enabling processes to the communicate and synchronize with the each other in an operating system. Among the various IPC mechanisms message queues provide the robust and flexible method for the processes to exchange data in a queued orderly fashion. This article will explore how IPC is achieved using the message queues the functions of message queues their advantages and disadvantages and will conclude with the common FAQs.\n\nThe Message queues are powerful IPC tools that allow processes to send and receive messages in the FIFO (First In, First Out) order. Here are the primary functions of the message queues:\n\nA message queue stores messages sent by the one process until they are retrieved by the another process. Each message is placed in the queue and remains there until it is read by the receiving process.\n\nThe Message queues ensure that messages are delivered in the order they were sent. This ordered communication is vital in the scenarios where the sequence of the operations matters.\n\nWith message queues, processes do not need to be synchronized or directly connected. A sending process can place a message in the queue and receiving process can retrieve it later allowing for the asynchronous communication.\n\nThe Message queues allow processes to be decoupled meaning the sending and receiving processes do not need to be aware of the each other’s existence or state. They interact indirectly through the queue which can improve modularity and scalability.\n\nThe Some message queue implementations allow the messages to be prioritized where certain messages can be processed before others based on the priority levels.\n\nThe Message queues can be designed to handle errors such as retries for the failed message deliveries or logging of the undelivered messages for the troubleshooting.\n\nThe Message queues are an essential IPC mechanism that provides the reliable way for the processes to communicate asynchronously and in an orderly manner. They are particularly useful in the distributed systems where processes need to the communicate across different machines or in systems where processes need to exchange data without being tightly coupled. However, while message queues offer many benefits they also the introduce complexity in the terms of message management, error handling and potential performance overhead.\n\nWhat is a message queue in IPC?\n\nHow does a message queue differ from shared memory?"
    },
    {
        "link": "https://stackoverflow.com/questions/49570961/message-queue-msgget-msgsnd-msgrcv-linux-eidrm",
        "document": "Here's my problem : I'm trying to implement a message queue between a server and a client. For that, i have two files, and .\n\nI use the function to exit the server (it does when we ask him to read the message queue 3 times, one time per second, by example).\n\nAs usual, is set by the msgget function and buf is defined by .\n\nThe official msgctl doc says that errno is set to EIDRM (43) for the reader (the client) and I would like to display a custom error when it happens. But when I try to read a message from a closed server, the function returns the EINVAL error. I assume that msqid is guilty\n• On the server : I use flags\n• On the client : I use flags\n\nThank you for the help"
    },
    {
        "link": "https://cs.kent.edu/~ruttan/sysprog/lectures/shmem/msqueues.html",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/41988823/is-this-how-message-queues-are-supposed-to-work",
        "document": "I am trying to understand message queues. In the examples I saw, the strunct would have only one more attribute except of the first one (the type) which must be . So, it would be something like .\n\nI tried to add a new attribute, to see if I recieve both the text and the number and it worked.\n\nIs this how message queues are supposed to work? Can I have as many attributes as I want in my ?\n\nAnd, also, is it ok to call the and functions with the length parameter set to because I know that the sizeof a struct isn't always the same as the sum of the of each attribute? Thank you."
    },
    {
        "link": "https://ibm.com/docs/en/zos/2.4.0?topic=functions-msgget-get-message-queue",
        "document": "C or C++\n\nThe msgget() function returns the message queue identifier associated with the argument key.\n\nif one of the following is true:\n• The argument is equal to IPC_PRIVATE\n• The argument does not already have a message queue identifier associated with it, and the flag IPC_CREAT is on in . A message queue identifier, associated message queue and data structure (see ) are created for the argumentif one of the following is true:\n\ninclude any combination of the following constants defined in <sys/ipc.h> and <sys/modes.h>: Create a message queue if the specified does not already have an associated ID. IPC_CREAT is ignored when IPC_PRIVATE is specified Causes the msgget() function to fail if the specified has an associated ID. IPC_EXCL is ignored when IPC_CREAT is not specified or IPC_PRIVATE is specified Creates a message queue that can only be read from msgrcv() when Message_Type is the process ID of the invoker. This restriction does not apply if the msgrcv() invoker has the same effective UID as the message queue creator. Creates a message queue that can only be written to msgsnd() when MSG_TYPE is the process ID of the invoker. This restriction does not apply if the msgsnd() invoker has the same effective UID as the message queue creator. Permits read access when the effective user ID of the caller matches either or Permits write access when the effective user ID of the caller matches either or Permits read access when the effective group ID of the caller matches either or Permits write access when the effective group ID of the caller matches either or Valid values for the argumentinclude any combination of the following constants defined in\n\nWhen a message set associated with argument key already exists, setting IPC_EXCL and IPC_CREAT in argument msgflg will force msgget() to fail.\n\ndata structure associated with the new message queue identifier is initialized as follows:\n• The fields , , , and are set equal to the effective user ID and effective group ID, respectively, of the calling process.\n• The low-order 9 bits of are set equal to the low-order 9 bits of .\n• The fields , , , msg_stime, and are set to zero.\n• The field is set equal to the current time.\n• The field is set equal to the system limit. Upon creation, thedata structure associated with the new message queue identifier is initialized as follows:"
    }
]