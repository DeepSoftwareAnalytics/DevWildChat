[
    {
        "link": "https://gsap.com/docs/v3/Plugins/ScrollTrigger",
        "document": "ScrollTrigger enables anyone to create jaw-dropping scroll-based animations with minimal code. Infinitely flexible. Scrub, pin, snap, or just trigger anything scroll-related, even if it has nothing to do with animation.\n\nGet ahead of the game by also learning about the most common ScrollTrigger mistakes.\n\nYou don't need to put ScrollTriggers directly into animations (though that's probably the most common use case). Use the callbacks for anything...\n\ncan be used as either a shorthand for the (described below) or as a configuration object with any of the following properties:\n• None instance that should be controlled by the ScrollTrigger. Only one animation is controlled per ScrollTrigger, but you can wrap all your animations in a single Timeline (recommended) or create multiple ScrollTriggers if you prefer.\n• None - If you pin large sections/panels you may notice what looks like a slight delay in pinning when you scroll quickly. That's caused by the fact that most modern browsers handle scroll repaints on a separate thread, so at the moment of pinning the browser may have already painted the pre-pinned content, making it visible for perhaps 1/60th of a second. The only way to counteract that is to have ScrollTrigger monitor the scroll velocity and anticipate the pin, applying it slightly early to avoid that flash of unpinned content. A value of is typically fine, but you can reduce or increase that number to control how early it does the pinning. In many cases, however, you don't need any anticipatePin (the default is 0).\n• None Easily trigger animations inside 'horizontally' scrolling sections that are controlled by vertical scrolling A popular effect is to create horizontally-moving sections that are tied to vertical scrolling but since that horizontal movement isn't a native scroll, a regular ScrollTrigger can't know when, for example, an element comes into view horizontally, so you must tell ScrollTrigger to monitor the container's [horizontal] animation to know when to trigger, like . See the Pen Horizontal \"containerAnimation\" - ScrollTrigger by GreenSock (@GreenSock)on CodePen. Caveats: the container's animation must use a linear ease ( ). Also, pinning and snapping aren't available on containerAnimation-based ScrollTriggers. You should avoid animating the element horizontally or if you do, just offset the start/end values according to how far you're animating the trigger.\n• None - Determines the ending position of the ScrollTrigger. It can be any of the following:\n• String - Describes a place on the endTrigger (or trigger if one isn't defined) and a place on the scroller that must meet in order to end the ScrollTrigger. So, for example, means \"when the bottom of the endTrigger hits the center of the scroller\". means \"when the center of the endTrigger hits 100px down from the top of the scroller\" (assuming vertical scroll). You can use keywords like \"top\", \"bottom\", \"center\" (or \"left\" and \"right\" if ) or percentages like \"80%\" or pixel values like \"100px\". Percentages and pixels are always relative to the top/left of the element/viewport. You can also define a single relative value like \"+=300\" which means \"300px beyond where the start is\", or \"+=100%\" means \"the height of the scroller beyond where the start is\". is a special keyword indicating the maximum scroll position.\n• Number - An exact scroll value, so would trigger when the viewport/scroller scrolls by exactly 200 pixels.\n• Function - A function that gets called whenever the ScrollTrigger refreshes and calculates its positions (typically upon creation and any time the scroller resizes). It should return a String or Number, as described above. This makes it easy to dynamically calculate values. Like all callbacks, the function receives the ScrollTrigger instance itself as the only parameter. This is a static position that is calculated when the ScrollTrigger is created and when the scroller is resized, based on where things are in the normal document flow. It is not constantly recalculated, so for example if you animate the trigger/endTrigger, it won't constantly update the start/end values accordingly because ScrollTrigger is highly optimized for performance. You can call to force things to be recalculated. The default is . clamp() the value (version 3.12+)Wrap your end value in to tell ScrollTrigger to always keep the calculated value between 0 (the top of the page) and the maximum scroll position so that it'll never leak outside the page bounds. Practically-speaking, this ensures that any trigger elements toward the very bottom of the page won't end with partially-scrubbed animations. For example, - any normal string-based value can be inside the clamp(). Like . Here's a video explaining further:\n• None - The element (or selector text for the element) whose position in the normal document flow is used for calculating where the ScrollTrigger ends. You don't need to define an unless it's DIFFERENT than the element because that's the default.\n• None , it will force the current ScrollTrigger's animation to completion if you its trigger area faster than a certain velocity (default 2500px/s). This helps avoid overlapping animations when the user scrolls quickly. You can specify a number for the minimum velocity, so would only activate if the velocity exceeds 3000px/s. See a\n• None - By default, it assumes your setup uses vertical scrolling but simply set if your setup uses horizontal scrolling instead.\n• None - An arbitrary unique identifier for the ScrollTrigger instance which can be used with . This id is also added to the markers.\n• None , the animation associated with the ScrollTrigger will have its method called whenever a refresh() occurs (typically on resize). This flushes out any internally-recorded starting values.\n• None - Adds markers that are helpful during development/troubleshooting. adds them with the defaults (startColor: \"green\", endColor: \"red\", fontSize: \"16px\", fontWeight: \"normal\", indent: 0) but you can customize them by using an object like\n• None , the ScrollTrigger will kill() itself as soon as the end position is reached once. This causes it to stop listening for scroll events and it becomes eligible for garbage collection. This will only call onEnter a maximum of one time as well. It does kill the associated animation. It's perfect for times when you only want an animation to play once when scrolling forward and never get reset or replayed. It also sets the toggleActions to \"play none none none\".\n• None - A callback for when the scroll position moves forward past the \"start\" (typically when the trigger is scrolled into view). It receives one parameter - the ScrollTrigger instance itself which has properties/methods like\n• None - A callback for when the scroll position moves backward past the \"end\" (typically when the trigger is scrolled back into view). It receives one parameter - the ScrollTrigger instance itself which has properties/methods like\n• None - A callback for when the scroll position moves forward past the \"end\" (typically when the trigger is scrolled out of view). It receives one parameter - the ScrollTrigger instance itself which has properties/methods like\n• None - A callback for when the scroll position moves backward past the \"start\" (typically when the trigger is scrolled all the way backward past the start). It receives one parameter - the ScrollTrigger instance itself which has properties/methods like\n• None - A callback for when the a refresh occurs (typically a resize event) which forces the ScrollTrigger to recalculate all of its positioning. It receives one parameter - the ScrollTrigger instance itself which has properties/methods like\n• None Function - A callback that gets called every time the progress of the ScrollTrigger changes (meaning the scroll position changed). If you have a numeric applied, keep in mind that the associated animation will keep scrubbing for a little while after the scroll position stops, so if your goal is to update something whenever the animation updates, it's best to apply an to the animation itself rather than the ScrollTrigger. See a demo here. The onUpdate callback receives one parameter - the ScrollTrigger instance itself which has properties/methods like , , , and .\n• None - A callback for when a numerical scrub has completed. This is only useful when a numerical scrub (like ) is applied. The callback receives one parameter - the ScrollTrigger instance itself which has properties/methods like\n• None - A callback for when the snapping has completed. This only applies when there's a defined. A snap will be cancelled if/when the user (or anything else) interacts in any way with scrolling, so the onSnapComplete would not be triggered at all in that case. The callback receives one parameter - the ScrollTrigger instance itself which has properties/methods like\n• None - A callback for when the ScrollTrigger toggles from inactive to active the other way around. This is typically when the scroll position moves past the \"start\" or \"end\" in either direction, but if it shoots past BOTH on the same tick, like if the user scrolls extremely fast, onToggle won't fire because the state hasn't changed. You can often use this one callback in the place of onEnter, onLeave, onEnterBack, and onLeaveBack by just checking the isActive property for toggling things. It receives one parameter - the ScrollTrigger instance itself which has properties/methods like\n• None Boolean | String | Element - An element (or selector text for the element) that should be pinned during the time that the ScrollTrigger is active, meaning it will appear to \"stick\" in its starting position while the rest of the content continues scrolling underneath it. Only one pinned element is allowed, but it can contain as many elements as you want. Setting will cause it to pin the element. Warning don't animate the pinned element itself because that will throw off the measurements (ScrollTrigger is highly optimized for performance and pre-calculates as much as possible). Instead, you could nest things such that you're animating only elements INSIDE the pinned element. Note: if you are pinning something that is nested inside another element that also gets pinned, make sure you define a so that ScrollTrigger knows to offset the start/end positions accordingly. Using React? Make sure to do proper cleanup - read this article.\n• None Element | String - If your ScrollTrigger's / element is INSIDE an element that gets pinned by another ScrollTrigger (pretty uncommon), that would cause the start/end positions to be thrown off by however long that pin lasts, so you can set the to that parent/container element to have ScrollTrigger calculate those offsets accordingly. Again, this is very rarely needed. Important: nested pinning is not supported, so this feature is only for non-pinning ScrollTriggers\n• None , the pinned element will be reparented to the while it is actively pinned so that it can escape any ancestor containing blocks. If you notice odd behavior while pinning (like the pinned element suddenly shifting and then moving with the scroll), you probably have a on an ancestor element which behavior (it's a browser thing, not ScrollTrigger). It's best to set up your project to avoid those because reparenting can be expensive, but can bail you out if you can't avoid them. Only use this feature if you must. Warning: if you have CSS rules that rely on specific nesting that'd be affected by the reparenting, they'll break. For example, a CSS rule like wouldn't apply to the nested anymore if you pin the element with because during the pin, it would no longer be inside the , so make sure you write your CSS rules to accommodate the reparenting.\n• None internally to wrap around pinned elements but in the rare scenario where you're loading an iframe into the pinned element, it can cause the iframe to refresh when ScrollTrigger refreshes (like on window resize), so this feature allows you to specify an element that should be used as the spacer instead of the internally-created one. That way, ScrollTrigger won't remove/add it during its refresh, keeping iframe content intact.\n• None Boolean | String - By default, padding will be added to the bottom (or right for ) to push other elements down so that when the pinned element gets unpinned, the following content catches up perfectly. Otherwise, things may scroll UNDER the pinned element. You can tell ScrollTrigger not to add any padding by setting . If you'd rather it use margin instead of padding, you can set . Note: pinSpacing works in most cases, but it really depends on the way you set up your DOM and CSS. For example, if you pin something in a parent that has display: flex or position: absolute, the extra padding won't push other elements down/right so you may need to manually space things out. pinSpacing is just a convenience that works in most situations. Important: if the container is , is set to by default because that's typically what is desired since padding works differently in that context. This video on pinning that's part of SnorklTV's ScrollTrigger Express course may help your understanding.\n• None is used for pinning only if the scroller is the , otherwise transforms are used (because won't work in various nested scenarios), but you can . Typically this isn't necessary or helpful. Beware that if you set the CSS property , browsers treat it just like having a transform applied, breaking elements (this is unrelated to ScrollTrigger/GSAP).\n• None - this feature activates as a ScrollTrigger is about to trigger an animation; it finds preceding scrollTrigger-based animations and forces those previous animations to their end state – avoiding unsightly overlaps. if , it will affect all preceding ScrollTriggers. You can use an arbitrary string to limit their effect to only others with a matching string. So would only affect other ScrollTriggers with\n• None unlikely that you'd need to define a as long as you create your ScrollTriggers in the order they'd happen on the page (top-to-bottom or left-to-right)...which we recommend doing. Otherwise, use to influence the order in which ScrollTriggers get refreshed to ensure that the pinning distance gets added to the start/end values of subsequent ScrollTriggers further down the page (that's why order matters). See the will get refreshed earlier than one with (the default). You're welcome to use negative numbers too, and you can assign the same number to multiple ScrollTriggers.\n• None itself, but if you'd like to add a ScrollTrigger to a scrollable , for example, just define that as the scroller. You can use selector text like \"#elementID\" or the element itself.\n• None - Links the progress of the animation directly to the scrollbar so it acts like a scrubber. You can apply smoothing so that it takes a little time for the playhead to catch up with the scrollbar's position! It can be any of the following\n• Boolean - links the animation's progress directly to the ScrollTrigger's progress.\n• Number - The amount of time (in seconds) that the playhead should take to \"catch up\", so would cause the animation's playhead to take 0.5 seconds to catch up with the scrollbar's position. It's great for smoothing things out.\n• None - Allows you to snap to certain progress values (between 0 and 1) after the user stops scrolling. So would snap in increments of 0.1 (10%, 20%, 30%, etc.). would only let it come to rest on one of those specific progress values. It can be any of the following...\n• Number - snaps in increments of 0.1 (10%, 20%, 30%, etc.). If you have a certain number of sections, simply do .\n• Array - snaps to the closest progress value in the Array in the direction of the last scroll (unless you set ).\n• Function - feeds the natural destination value (based on velocity) into the function and uses whatever is returned as the final progress value (in this case increments of 0.2), so you can run whatever logic you want. These values should always be between 0 and 1 indicating the progress of the animation, so 0.5 would be in the middle.\n• \"labels\" - snaps to the closest label in the timeline (animation must be a timeline with labels, of course)\n• \"labelsDirectional\" - snaps to the closest label in the timeline that's in the direction of the most recent scroll. So if you scroll a little bit toward the next label (and stop), even if the current scroll position is technically closest to the current/last label, it'll snap to the next one in that direction instead. This can make it feel more intuitive for users.\n• Object - Like , fully customizable with any of the following properties (only \"snapTo\" is required):\n• snapTo [Number | Array | Function | \"labels\"] - determines the snapping logic (described above)\n• delay [Number] - the delay (in seconds) between the last scroll event and the start of the snapping animation. Default is half the scrub amount (or 0.1 if scrub isn't a number)\n• directional [Boolean] - by default (as of version 3.8.0), snapping is directional by default meaning it'll go in the direction the user last scrolled, but you can disable this by setting .\n• duration [Number | Object] - the duration of the snapping animation (in seconds). would always take 0.3 seconds, but you can also define a range as an object like to clamp it within the provided range, based on the velocity. That way, if the user stops scrolling close to a snapping point, it'd take less time to snap than if the natural stopping point is far from a snapping point.\n• ease [String | Function] - the ease that the snapping animation should use. The default is \"power3\".\n• inertia [Boolean] - to tell ScrollTrigger not to factor in the inertia, set\n• onStart [Function] - a function that should be called when snapping starts\n• onInterrupt [Function] - a function that should be called when snapping gets interrupted (like if the user starts scrolling mid-snap)\n• onComplete [Function] - a function that should be called when snapping completes\n• None - Determines the starting position of the ScrollTrigger. It can be any of the following:\n• String - Describes a place on the trigger and a place on the scroller that must meet in order to start the ScrollTrigger. So, for example, means \"when the top of the trigger hits the center of the scroller\" (and the scroller is the viewport by default). means \"when the bottom of the trigger hits 80% down from the top of the viewport\" (assuming vertical scroll). You can use keywords like \"top\", \"bottom\", \"center\" (or \"left\" and \"right\" if ) or percentages like \"80%\" or pixel values like \"100px\". Percentages and pixels are always relative to the top/left of the element/scroller. You can even use a complex relative value like which means \"when the top of the trigger hits 100px above the bottom of the viewport/scroller\"\n• Number - An exact scroll value, so would trigger when the viewport/scroller scrolls by exactly 200 pixels.\n• Function - A function that gets called whenever the ScrollTrigger calculates its positions (typically upon creation and any time the scroller resizes). It should return a String or Number, as described above. This makes it easy to dynamically calculate values. Like all callbacks, the function receives the ScrollTrigger instance itself as the only parameter, so you can, for example, base the position on the previous ScrollTrigger's end like This is a static position that is calculated when the ScrollTrigger is created and when the scroller is resized, based on where things are in the normal document flow. It is not constantly recalculated, so for example if you animate the trigger/endTrigger, it won't constantly update the start/end values accordingly because ScrollTrigger is highly optimized for performance. You can call to force things to be recalculated. The default is unless is set in which case the default value is . clamp() the value (version 3.12+)Wrap your start value in to tell ScrollTrigger to always keep the calculated value between 0 (the top of the page) and the maximum scroll position so that it'll never leak outside the page bounds. Practically-speaking, this ensures that any \"above the fold\" (triggers inside the viewport at the top of the page) won't start out with partially-scrubbed animations. For example, - any normal string-based value can be inside the clamp(). Like . Here's a video explaining further:\n• None - Determines how the linked animation is controlled at the 4 distinct toggle places - , in that order. The default is play none none none will play the animation when entering, pause it when leaving, resume it when entering again backwards, and reset (rewind back to the beginning) when scrolling all the way back past the beginning. You can use any of the following keywords for each action: \"play\", \"pause\", \"resume\", \"reset\", \"restart\", \"complete\", \"reverse\", and \"none\".\n• None - Adds/removes a class to an element (or multiple elements) when the ScrollTrigger toggles active/inactive. It can be either of the following:\n• String - The name of the class to add to the element, like\n• Object - To toggle a class for elements other than just the trigger, use the object syntax like . The \"targets\" can be selector text, a direct reference to an element, or an Array of elements. . To have toggle class names in a different way, use the callback functions (onEnter, onLeave, onLeaveBack, and onEnterBack).\n• None - The element (or selector text for the element) whose position in the normal document flow is used to calculate where the ScrollTrigger starts.\n\nCreates a coordinated group of ScrollTriggers (one for each target element) that batch their callbacks (onEnter, onLeave, etc.) within a certain interval, delivering a neat Array so that you can easily do something like create a staggered animation of all the elements that enter the viewport around the same time. Clears any recorded scroll positions in ScrollTrigger so that no scroll positions get restored after a refresh(). Normally, this isn't necessary but in some frameworks that handle routing in unconventional ways, it can be useful. Allows you to configure certain global behaviors of ScrollTrigger like Allows you to set the default values that apply to every ScrollTrigger upon creation, like , , etc. Disables the ScrollTrigger instance, immediately unpinning and restoring any pin-related changes made to the DOM by ScrollTrigger. Returns an Array of all ScrollTrigger instances Returns the ScrollTrigger that was assigned the corresponding Returns the tween (default) or the snapping tween ( ) Gets the scroll velocity in pixels-per-second Returns if the element is in the viewport. You can optionally specify a minimum proportion, like would only return if at least 20% of the element is in the viewport. Indicates whether or not any ScrollTrigger-related scroller is in the process of scrolling. Kills the ScrollTrigger instance, immediately unpinning and restoring any pin-related changes made to the DOM by ScrollTrigger and removing all scroll-related listeners, etc. so that the instance is eligible for garbage collection. If you only want to temporarily disable the ScrollTrigger, use the disable() method instead. Immediately calls on all ScrollTriggers (except the main ScrollSmoother one if it exists). Converts a timeline label into the associated scroll position (only applicable to ScrollTriggers whose \"animation\" is a timeline) [DEPRECATED] Allows you to set up ScrollTriggers that only apply to certain viewport sizes (using media queries). A utility function for getting the maximum scroll value for a particular element/scroller. For example, if the element/scroller is 500px tall and contains 800px of content, maxScroll() would return 300. Returns the next ScrollTrigger in the refresh order. Forces scrolling to be done on the JavaScript thread, ensuring screen updates are synchronized and the address bar doesn't show/hide on [most] mobile devices. Super-flexible, unified way to sense meaningful events across all (touch/mouse/pointer) devices without wrestling with all the implementation details. Trigger simple callbacks like onUp, onDown, onLeft, onRight, onChange, onHover, onDrag, etc. Functionally identical to Observer.create() Returns a normalized value representing the element's position in relation to the viewport where 0 is at the top of the viewport, 0.5 is in the center, and 1 is at the bottom. So, for example, if the top of the element is 80% down from the top of the viewport, the following code would return 0.8: Returns the previous ScrollTrigger in the refresh order. Forces the ScrollTrigger instance to re-calculate its start and end values (the scroll positions where it'll be activated). Internally records the current inline CSS styles for the given elements so that when ScrollTrigger reverts (typically for a refresh() or matchMedia() change) those elements will be reverted accordingly even if they had animations that added/changed inline styles. Think of it like taking a snapshot of the inline CSS and telling ScrollTrigger \"re-apply these inline styles only and dump all others when you revert internally\". Gets/Sets the scroll position of the associated scroller (numeric). Allows you to hijack the and/or getters/setters for a particular scroller element so that you can implement things like smooth scrolling or other custom effects. Returns a snapping function to which you can feed any value to snap, along with a direction where is forward (greater than) and is backward (less than). Sorts the internal Array of ScrollTrigger instances to control the order in which they refresh() (calculate their start/end values). Add a listener for any of the following events: \"scrollStart\", \"scrollEnd\", \"refreshInit\", \"revert\", \"matchMedia\", or\"refresh\" which get dispatched globally when any such ScrollTrigger-related event occurs (it is not tied to a particular instance). Recalculates the positioning of all of the ScrollTriggers on the page; this typically happens automatically when the window/scroller resizes but you can force it by calling Checks where the scrollbar is and updates all ScrollTrigger instances' and values accordingly, controls the animation (if necessary) and fires the appropriate callbacks.\n\nHow does ScrollTrigger work? Is it just like IntersectionObserver? ScrollTrigger does NOT constantly watch every element and check its positioning in the viewport on each tick. We're obsessed with performance and that'd be far too costly. Instead, ScrollTrigger does the processing up-front to figure out where the start/end points are in the natural document flow. In other words, \"this ScrollTrigger will be active when the scrollbar is between _ _ _ and _ _ _ _ \". Then, it debounces the \"scroll\" events and only updates things on the next requestAnimationFrame, perfectly synced with GSAP and screen refreshes. It ONLY watches the scroll position. Period. That means it's FAST. ScrollTrigger automatically listens for viewport/scroller \"resize\" events and recalculates all the start/end positions accordingly ( ). In fact, since resizing/refreshing is CPU-intensive, it waits until there's a 200ms gap in resize events before starting its work. Yeah, we looked for every opportunity to maximize performance. IntersectionObserver is a native feature in most modern browsers that's different in the following ways:\n• It constantly \"watches\" elements to sense when they enter/leave regardless of scrolling.\n• It's not helpful for tracking an element's position between two points, like for scrubbing an animation accordingly.\n• It does let you watch multiple elements and have a single callback triggered that could loop through and fire a staggered animation on just the elements that entered, for example. ScrollTrigger does not use IntersectionObserver under the hood because it lacks the necessary functionality and compatibility. You can certainly use IntersectionObserver and ScrollTrigger together. How does pinning work under the hood?\n• The pinned element gets immediately wrapped in a with a fixed width/height to match. A class of \"pin-spacer\" is added to that wrapper. Think of it like a proxy element that props open the space where the pinned element was in the DOM so that when it flips to things don't collapse.\n• By default, padding will be added to the bottom (or right for horizontal: true) of the pin-spacer so that [ in most cases ] things get pushed further down/right. When the pinned element gets unpinned, the content below/right will have caught up. So if, for example, the pinned element stays pinned for 300px, there would be padding of 300px added. This video on pinning that's part of SnorklTV's ScrollTrigger Express course may help your understanding.\n• When the ScrollTrigger is active (when the scroll position is between the start and end), it sets the pinned element to and positions it with fixed top/left/width/height values...unless the scroller isn't the viewport in which case it never uses because that'd break sub-scrolling, so it uses pure transforms. If is set to (we recommend avoiding that if you can), the pinned element will get reparented to the and styles will be moved inline to ensure appearance is maintained.\n• When the ScrollTrigger becomes inactive, the pinned element reverts to its original value and a transform is applied to place it correctly.\n• When the window/scroller gets resized, all ScrollTriggers re-calculate their start/end positions ( ). As a part of that process, the pin-spacer is removed from the DOM and the pinned element is swapped back in so that measurements are accurate with the original CSS. Then the pin-spacer is swapped back in as a wrapper. Why not just use transforms and avoid ? Many browsers don't render consistently using that technique. There are annoying visual glitches due to the fact that scroll repaints are handled on a different thread in most modern browsers. Surprisingly, seemed to deliver better performance overall. And performance is EXTREMELY important for scrolling. How does duration work with scrub: true? If you have a ScrollTrigger and that ScrollTrigger has a timeline or tween animation associated with it, the durations of tweens within that animation serve as proportions for the total amount of distance that the tween will play. The proportion of how much distance it's animated between is in regards to the total duration of the animation. It's easiest to understand with an example: Say you have a timeline with three sequenced tweens: a 1 second tween, a 3 second tween, and then another 1 second tween. And the ScrollTrigger applied to it will animate for a full viewport height's distance (perhaps the trigger uses the values of and ). If (or a number) is applied, then the first tween will be animated between when the center of the trigger element is between the 100% mark (from the top; the bottom of the viewport) and the 80% mark (from the top) of the viewport. The second tween will fire when the center of the element is at the 80% mark until the 20% mark. And the third tween will fire when the center of the element is between the 20% mark and the 0% mark. This is because the total duration of the timeline is 5 seconds. So ⅕ is 20% and ⅗ is 60%. If you change the duration of all the tweens to the same number, say 1, then the percentages would all be equal: 100% -> 66%, 66% -> 33%, 33% -> 0%. This is because the total duration is 3, so ⅓ is 33%. In other words, the duration values don't matter as much as the proportions of the duration of each tween compared to the total time of the timeline. If you want to make the animation take a longer distance of scroll to complete, affect the distance from start to end longer. For example you could set to make it take a lot of scrolling to complete.\n\nCheck out the collection of user-created ScrollTrigger pens or how-to ScrollTrigger pens on CodePen."
    },
    {
        "link": "https://gsap.com/community/forums/topic/36819-gsap-animation-on-scroll-trigger",
        "document": "We can't really offer too much in terms of creating animation for our users, that's beyond the scope of these free forums and we don't have the time resources for that.\n\nFor what I can see in the video this could be a mix of a parallax animation on a background, an SVG element with some paths changing or a series of PNG images fading in/out and some layered content being animated in.\n\nHere are a few examples:\n\nSee the Pen vYNNvMj by GreenSock (@GreenSock) on CodePen.\n\nSee the Pen PoOpobM by GreenSock (@GreenSock) on CodePen.\n\nSee the Pen KKpLdWW by GreenSock (@GreenSock) on CodePen."
    },
    {
        "link": "https://gsap.com/community/forums/topic/29214-issue-with-scrolltrigger-and-changing-routes-on-static-site-generators-frontend-frameworks",
        "document": "Hello,\n\n\n\n Lately I've been facing an issue which has been very hard for me to debug. I've been using Nuxt to build a static site and scrolltrigger for some of the animations. When changing routes, I face an issue of some reused components not having the right top/bottom trigger amount, and the site keeping its scroll position on a route change when it should go back to the top . Resizing fixes the first issue, but I cannot solve the second. \n\n\n\n I've noticed many cases of similar occuring on similar frameworks Anyways, I wanted to see if this is a known issue with the framework or GSAP? All my components kill their scrolltrigger instance on a route change, so garbage cleanup is fine. I've tried downgrading nuxt to no evail either, but it doesn't seem like a nuxt problem because it looks to be happening regardless of framework? The only thing that works for the wrong trigger amount is calling scrolltrigger.refresh() after an arbitary amount of time, but thats not really a fix. Anyways just look for any advice on what from those who have faced similar or to see if the issue is known.\n\nAre you using the latest version (3.7.1)? I'd definitely make sure you're on the latest version as step 1 - that will likely fix the scroll position thing. As for calling ScrollTrigger.refresh() after an arbitrary amount of time, that definitely sounds like a framework-related issue or something on your end - basically, you need to make sure ScrollTrigger.refresh() gets called when all your elements are loaded and done messing with the layout so that it can calculate start/end positions based on where everything is located. Perhaps you need to tap into a lifecycle method in your framework that signals when everything is finished loading and layout isn't shifting around. If you still need help, feel free to post a minimal demo - that always gives you the best chance of getting an accurate answer. Thanks for being a Club GreenSock member!\n\nJust seconding this - if you could create a minimal demo on codesandbox that would be hugely helpful. We get a lot of requests for help on this but no one's put together simplified demo that we can actually take a look at yet. Most of the time the issue is down to other complex things happening - hydration/image loading If you can show an example where a simple route change and is not working, that would be wonderful - it would be great to get to the bottom of the scroll position issue once and for all!\n\n\n\n However it is usually to do with calling before layout shifts/lazy loading/DOM renders have occurred. All frameworks have different ways of handling this so it's down to the developer to find that out and refresh accordingly!\n\n@OSUblake @GreenSock \n\n\n\n\n\n Been digging into this more lately. I setup a listener to see when the window.scrollTo() is invoked to see precisely what is happening. My Vue instance is scrolling to (0,0) as intended on a route change. When the route changes, the new ScrollTrigger instances are created as expected. However, all of these new instances immedietely call the window.scrollTo method, which shoots the page downward to a much lower position (in this case 0 , 9408). So the default vue scroll to top is being overriden by scrolltrigger scrolling way down when a new class is setup. I commented out the ability for scrolltrigger to call window.scrollTo in its source file. This has solved the issue temporarily, but is obviously not the best way haha. \n\n\n\n What is attached to Scrolltrigger that would cause it to invoke window.scrollTo when a new class is created?\n\nWhat is attached to Scrolltrigger that would cause it to invoke window.scrollTo when a new class is created? I'm not sure I follow your question - did you mean when a new ScrollTrigger instance is created? ScrollTrigger must record the scroll position in order to function properly. Let's say, for example, your page is natively 1000px tall but you set up a ScrollTrigger to pin an element for 2000px. That means that technically the page would become 3000px tall. When you refresh the browser window, ScrollTrigger must revert everything (remove all the pinning) so that things are back in their natural state so styles are applied properly and measurements are accurate. It all must flow from top to bottom measurement-wise. So let's say your viewport is 600px tall and you scroll down 800px and then refresh...note that's further than the native page even allows (1000px native - 600px viewport = 400px maximum scroll). You'd jump to a different position on refresh in that case if ScrollTrigger didn't remember (and revert) the scroll position. There are several other scenarios where that could happen. So yeah, this is an important feature. We added code in 3.7.1, though, so if you kill all you ScrollTrigger instances it will also flush the scroll position memory, so I'm a bit confused about why you're seeing that behavior. Again, it's super-duper tough to diagnose blind unfortunately. Oh, and you mentioned jQuery causing problems - GSAP works fantastically with jQuery. Zero conflicts whatsoever, at least I've never in my life seen any and I know for sure that hundreds of thousands of sites use them together. I wonder if you've got some kind of funky jQuery plugin that's interfering with the scroll stuff? I'm totally guessing there. You don't have scroll-behavior: smooth anywhere, do you? I've seen that cause problems.\n\nOn 9/2/2021 at 1:14 AM, GreenSock said: I'm not sure I follow your question - did you mean when a new ScrollTrigger instance is created? ScrollTrigger must record the scroll position in order to function properly. Let's say, for example, your page is natively 1000px tall but you set up a ScrollTrigger to pin an element for 2000px. That means that technically the page would become 3000px tall. When you refresh the browser window, ScrollTrigger must revert everything (remove all the pinning) so that things are back in their natural state so styles are applied properly and measurements are accurate. It all must flow from top to bottom measurement-wise. So let's say your viewport is 600px tall and you scroll down 800px and then refresh...note that's further than the native page even allows (1000px native - 600px viewport = 400px maximum scroll). You'd jump to a different position on refresh in that case if ScrollTrigger didn't remember (and revert) the scroll position. There are several other scenarios where that could happen. So yeah, this is an important feature. We added code in 3.7.1, though, so if you kill all you ScrollTrigger instances it will also flush the scroll position memory, so I'm a bit confused about why you're seeing that behavior. Again, it's super-duper tough to diagnose blind unfortunately. Oh, and you mentioned jQuery causing problems - GSAP works fantastically with jQuery. Zero conflicts whatsoever, at least I've never in my life seen any and I know for sure that hundreds of thousands of sites use them together. I wonder if you've got some kind of funky jQuery plugin that's interfering with the scroll stuff? I'm totally guessing there. You don't have scroll-behavior: smooth anywhere, do you? I've seen that cause problems. Hi Sorry for the late response.\n\n\n\n Thanks for the explanation (and apologies for not being able to get you a demo). Maybe something in Nuxt is causing things to go out of order? It's odd because the jump happens after the page url has changed. This is the part of code I commented out in ScrollTrigger.js that fixed the issue. It hasnt seemed to have caused issues anywhere else, so I suppose I'll leave it for the time being.\n\n\n\n \n\n Also no smooth scroll behavior or jquery for me."
    },
    {
        "link": "https://blog.pixelfreestudio.com/how-to-implement-scroll-triggered-animations-in-web-design",
        "document": "Scroll-triggered animations are a powerful tool in web design. They create dynamic interactions, enhance user experience, and make web pages more engaging. This guide will walk you through how to implement scroll-triggered animations effectively, ensuring your web designs stand out.\n\nScroll-triggered animations are visual effects that occur as users scroll down a webpage. These animations can include fading elements, sliding components, or even complex transformations.\n\nThe animations are triggered by the user’s scroll position, adding an interactive layer to the browsing experience.\n\nScroll-triggered animations can significantly enhance the user experience by providing visual feedback and making content more engaging. They help guide users’ attention to important sections, improve content flow, and add a professional touch to your web design.\n\nCSS is a straightforward way to create basic scroll-triggered animations. By using the property, you can create simple animations that stick elements to the viewport as the user scrolls.\n\nFor more complex animations, JavaScript provides greater control. Libraries like GSAP (GreenSock Animation Platform) offer powerful tools for creating sophisticated scroll-triggered animations.\n\nBefore implementing scroll-triggered animations, it’s important to plan them carefully. Consider the user journey and how animations can enhance the storytelling of your content.\n\nIdentify key elements that would benefit from animations and decide on the type of animation that would be most effective.\n\nSmooth transitions are crucial for creating a seamless user experience. Avoid abrupt or jarring animations that can distract users. Instead, use easing functions to create smooth, natural movements.\n\nPerformance is key when implementing animations. Heavy animations can slow down your website, leading to a poor user experience. Optimize animations by minimizing the number of animated elements and using hardware-accelerated properties like and .\n\nScroll indicators help guide users through long pages by showing their progress. An animated scroll indicator can make navigation more intuitive.\n\nParallax scrolling creates a 3D effect by moving background images at a different speed than the foreground content. This effect can add depth and dimension to your website.\n\nReveal animations gradually display elements as they enter the viewport. This technique can highlight important content and keep users engaged.\n\nCombining multiple animations can create complex and engaging effects. By synchronizing different animations, you can create a cohesive visual experience.\n\nThe Intersection Observer API provides a way to asynchronously observe changes in the intersection of a target element with an ancestor element or the viewport. This method is efficient and performs well.\n\nGSAP’s ScrollTrigger plugin makes it easy to create advanced scroll-triggered animations with powerful controls and options.\n\nParallax effects create a sense of depth by making background images move slower than the foreground content.\n\nScrollMagic is a JavaScript library for creating scroll-based animations. It works well with GSAP and provides extensive options for complex interactions.\n\nPerformance and accessibility are crucial when implementing scroll-triggered animations. Here are some tips to ensure your animations are smooth and inclusive.\n\nCreating interactive content sections that reveal information as the user scrolls can make long pages more engaging and easier to navigate.\n\nUsing scroll-triggered animations to highlight key features or sections of your website can draw users’ attention to important content and improve the overall user experience.\n\nDynamic navigation menus that respond to scrolling can improve usability and make navigation more intuitive.\n\nInteractive elements that respond to user actions can significantly enhance user engagement. Scroll-triggered animations can make these interactions feel more dynamic and responsive.\n\nCSS variables (custom properties) provide a flexible way to customize scroll-triggered animations. You can dynamically change these variables based on scroll position to create responsive animations.\n\nExample: Using CSS Variables for Dynamic Animations\n\nSequential animations trigger multiple animations in a specific order as the user scrolls. This technique can be used to guide users through a narrative or step-by-step process.\n\nReact makes it easy to implement scroll-triggered animations using hooks and libraries. Combining React with GSAP or other animation libraries can create highly interactive and responsive animations.\n\nExample: Scroll-Triggered Animations in React with GSAP\n\nVue.js also supports scroll-triggered animations. You can use Vue’s reactive data properties and lifecycle hooks to create dynamic animations.\n\nExample: Scroll-Triggered Animations in Vue with GSAP\n\nLottie is a library that renders After Effects animations in real time. It allows you to create complex animations and control them with scroll interactions.\n\nSVG animations are lightweight and scalable, making them ideal for creating engaging scroll-triggered effects. You can animate SVG elements using CSS, JavaScript, or libraries like GSAP.\n\nBackground animations can add depth and movement to your web design. Techniques like parallax scrolling can create a more immersive experience.\n\nScroll-triggered animations can enhance product showcases and highlight key features, making your e-commerce site more engaging and interactive.\n\nScroll-triggered animations can be used to create compelling narratives that guide users through a story, enhancing their engagement and connection with the content.\n\nScroll-triggered animations can also enhance navigation, providing visual cues and feedback as users scroll through the page.\n\nProper testing and debugging are crucial to ensure your scroll-triggered animations work smoothly across different devices and browsers.\n\nSingle Page Applications (SPAs) often use frameworks like React, Vue, and Angular to create dynamic web experiences. Integrating scroll-triggered animations in these environments can enhance user interactions and provide smooth, engaging experiences.\n\nAngular provides a robust framework for building SPAs. By using Angular’s lifecycle hooks and directives, you can easily implement scroll-triggered animations.\n\nFirst, create a new Angular project if you don’t have one:\n\nStep 4: Use the Directive in a Component\n\nUse the directive in a component to animate elements on scroll:\n\nVirtual scrolling is a technique used to improve performance by only rendering visible elements and removing elements from the DOM that are outside the viewport. This is particularly useful for pages with large datasets.\n\nAngular CDK provides a that you can use to implement virtual scrolling.\n\nServer-side rendering (SSR) can improve the performance and SEO of your web applications by rendering pages on the server and sending the fully rendered HTML to the client.\n\nExample: Using Next.js for SSR with Scroll Animations\n\nNext.js is a popular framework for React that supports SSR. Here’s how you can integrate scroll-triggered animations with Next.js.\n\nWebGL allows you to create 3D graphics in the browser, providing opportunities for highly immersive and interactive web experiences.\n\nThree.js is a popular library for creating 3D graphics with WebGL.\n\nCombining scroll-triggered animations with motion sensors can create unique, responsive experiences, especially on mobile devices.\n\nFinal Tips and Best Practices for Scroll-Triggered Animations\n\nFrequent DOM manipulation can significantly impact performance. Try to batch changes and use modern libraries like GSAP, which are optimized for performance.\n\nFor smoother animations, use for any JavaScript animations. This ensures that your animations are in sync with the browser’s refresh rate.\n\nUse the media query to respect users who prefer reduced motion. Provide alternatives or simpler animations for these users.\n\nMake sure that animations do not interfere with the readability and usability of your content. Avoid distracting or overly complex animations.\n\nTest your scroll-triggered animations across different browsers to ensure compatibility. Use tools like BrowserStack or CrossBrowserTesting for comprehensive testing.\n\nScroll-triggered animations can behave differently on mobile devices. Test your animations on various mobile devices to ensure they perform well and are user-friendly.\n\nCombine scroll-triggered animations with other user interactions like click events to create more interactive and engaging experiences.\n\nThe Intersection Observer API can also be used for lazy loading images and other resources, improving page load times and performance.\n\nKeep up with industry leaders and blogs such as CSS-Tricks, Smashing Magazine, and Awwwards. These resources regularly publish articles on new trends and techniques.\n\nDon’t be afraid to experiment with new ideas and push the boundaries of what’s possible with scroll-triggered animations. Innovation often comes from trying something new and learning from the process.\n\nStudy websites that effectively use scroll-triggered animations. Analyze how they implement these animations and think about how you can apply similar techniques to your projects.\n\nScroll-triggered animations are a powerful way to enhance web design, making pages more engaging and interactive. By using a combination of CSS, JavaScript, and libraries like GSAP, you can create dynamic effects that captivate users.\n\nTo ensure a smooth and inclusive user experience, always prioritize performance optimization and accessibility. Test your animations across different devices and browsers, and respect user preferences for reduced motion. Stay inspired by industry leaders, experiment with new techniques, and continuously push the boundaries of what’s possible.\n• How to Write Clean and Maintainable Code: Best Practices\n• Ultimate Guide to Code Quality and Maintainability in 2024\n• Best Practices for Code Reviews in Development Teams"
    },
    {
        "link": "https://gsap.com/community/forums/topic/38416-pinned-section-with-continuous-scrolling-items",
        "document": "I'm totally new to GSAP (and basically JS...) What i try to achieve is to scroll to the blue section. Then the blue section should stay pinned when completely visible, while the yellow items scroll on. Only after the last item scrolled by, it should scroll to the next section. How can i set the start and end to the itemcontainer, while pinning the section? See the Pen mdapKPq by dubcut (@dubcut) on CodePen.\n\nHi and welcome to the GreenSock forums. Thanks for the clear demo. It shows you're really trying. You did a good job of setting things up. However, getting this done right takes a bit of experience with the subtleties of the API. You'll need to really understand things like pinning, function-based values, dealing with responsive settings etc. I've done something similar in a recent lesson so I was able to quickly make some modifications. See the Pen JjwMBmm?editors=0110 by snorkltv (@snorkltv) on CodePen. Note: a big part of what you need is to figure out how far the yellow boxes need to move. I did this in the getScrollDistance() function. With invalidateOnRefresh set to true that function will re-run automatically on resize. Hopefully this demo is enough to give you something to experiment with. Be sure to study all the ScrollTrigger properties in the docs as that will help greatly. If you want to do more with ScrollTrigger and GSAP I encourage you to check out my GSAP course bundle, I cover all these things in detail.\n\nThank very much, you are a hero! When adding some animation I noticed that start/end gets thrown off for my yellow items when using \"// SCROLL PIN AT FULLPAGE\" function from before.\n\n Also it can not handle \"goto Section\" navigation.\n\n So it is disabled in this example to show the animation. Of course the goal is to make them all work together... I also added a \"// SCROLLJUMP TO SECTION\" function which does not seem to impact this issue but it is disabled for now. Regarding the animation issue, i guess i need to rescale/adapt the animation part of my items to the localspace of \"getScrollDistance(section)\" somehow, but not shure if thats the way to investigate..? See the Pen dywdGgY by dubcut (@dubcut) on CodePen. Any help is appreciated, thank you\n\nI'm sorry if i overcomplicated my words and example. (EDIT: i fixed it quite a bit, see EDIT below ) The thing to animate and the trigger are the same in my example ('.item'). it itself is not animated before. only it's parent ('.container'). it is basically still the same Scroll Pin you helped me a few posts above. Then @Rodrigo helped me to implement a loop to make the pin work for multiple sections. (it's the first part of the script) If i try to animate my yellow box ('.item') the start/end markers do not stick to the box where i expect them. See the Pen dywdGgY by dubcut (@dubcut) on CodePen. EDIT: i found out that if i set it works for the first section (having 5 items), but others have more items and therefore need a higher value. i'm pretty shure this has to be set as getScrollDistance(section). The height of the current section. i guess i cannot set it like that:\n\nHi @dubCUT, this was what @Carl tried to explain, and you have this in your tween and ScrollTrigger, which is a no go when using ScrollTrigger. The thing you antimate and the trigger of the ScrollTrigger can't be de same. // These cant be the same // These cant be the same The order in which ScrollTriggers get created is also importend, so you might want to look in to refreshPriority. Hope it helps and happy tweening! number - it's VERY unlikely that you'd need to define a refreshPriority as long as you create your ScrollTriggers in the order they'd happen on the page (top-to-bottom or left-to-right)...which we strongly recommend doing. Otherwise, use refreshPriority to influence the order in which ScrollTriggers get refreshed to ensure that the pinning distance gets added to the start/end values of subsequent ScrollTriggers further down the page (that's why order matters). See the sort() method for details. A ScrollTrigger with refreshPriority: 1 will get refreshed earlier than one with refreshPriority: 0 (the default). You're welcome to use negative numbers too, and you can assign the same number to multiple ScrollTriggers.\n\nUsing a combination of ScrollTrigger and the ScrollTo Plugin to scroll to a specific location, especially when you have pinned sections with ScrollTrigger is not as trivial as using the height of the elements, their offsetTop or other properties. Is always better to use ScrollTrigger in order to get the specific scroll distance using the start/end points. I checked your code for that quickly and it doesn't look like the best approach IMHO In this demo for example: See the Pen BaqbNzG by GreenSock (@GreenSock) on CodePen. The calculations are being made in line 195 in order to get the correct scroll position of each section. Granted this uses ScrollSmoother's scrollTo method, but using the ScrollTo plugin shouldn't be too different. The other issue here, as @Carl mentions, is the fact that you are animating the container of the yellow boxes on the Y axis and you are creating ScrollTrigger animations for the yellow boxes. So ScrollTrigger calculates the start and end values for those, when the parent of the yellow boxes hasn't moved yet, then you move that on the Y axis, so all the calculations are useless because the actual positions of the yellow boxes has shifted. Here is a super simple example (It should look better in a different tab): See the Pen QWzQMyv by GreenSock (@GreenSock) on CodePen.\n\nThis is actually a bit beyond being GSAP related. That is not an issue or an implementation problem, but a unique and custom requirement, and without being judgmental (even it could sound like that) a bit weird and that it doesn't make much sense. You want the overlay to be present until you leave the particular section where the boxes are, but at the same time you want to prevent the user from scrolling to the previous or next section, so only scroll within that particular section. What you could do is use the onLeave and onLeaveBack events in order to force the scroll position to either the start or end point of that section's ScrollTrigger, if the overlay element is open of course. But if I was you I'd leave the functionality you already have since blocking the scroll in a way that is not entirely intuitive sounds like terrible UX IMHO. If I can see the scroll bar, means that I should be able to scroll up and down, but if I'm not able to do that then I'd get confused and probably wouldn't use that site anymore, so my advice is to thread carefully in this subject."
    },
    {
        "link": "https://dev.to/aneeqakhan/animating-the-3d-cube-with-threejs-1i12",
        "document": "In today's digital world, web technology has become incredibly powerful. We've reached a point where you can experience captivating 3D graphics right in your web browser. Imagine this—no need for plugins or external tools; it's all within the realm of pure web content. And guess what's driving this exciting change? It's WebGL, a fantastic technology that makes rendering both 2D and 3D graphics possible. But hey, let's be real—it might seem a bit tricky, especially for those starting out. That's where Three.js comes in as a superhero! Three.js is like your trusty sidekick—it simplifies the complex bits and offers a much friendlier path into the enchanting world of 3D web graphics. In this article, let's embark on a journey to explore the basics of bringing 3D graphics to life using WebGL and the magical powers of Three.js.\n\nWebGL is a low-level, complex API. While it provides tremendous power and flexibility, it also comes with a steep learning curve. On the other hand, Three.js provides a higher-level abstraction, enabling developers to create 3D scenes without delving deep into the intricacies of WebGL.\n\nLet's animate a 3D cube using Three.js to illustrate how easy it is to get started.\n\nFirst, include the Three.js library in your project:\n\nWe need three main components: a scene, a camera, and a renderer.\n\nTo display a cube, we'll need a box geometry and a material to cover it.\n\nWe'll create an animation loop that rotates the cube.\n\nLastly, we need to position the camera slightly out so that it can view the cube:\n\nNow, you'll see a spinning cube on a blank canvas. The ease of setting up this scene demonstrates the power of Three.js.\n\nWith just a few lines of code, we've delved into the world of 3D graphics on the web. The combination of WebGL for rendering power and Three.js for abstraction makes it accessible for developers to create stunning visual content directly within the browser. As you explore deeper into this realm, you'll find that the possibilities—from intricate game worlds to detailed simulations—are nearly limitless. Happy coding!"
    },
    {
        "link": "https://threejs.org/docs/api/en/renderers/WebGLRenderer.html",
        "document": "The WebGL renderer displays your beautifully crafted scenes using [link:https://en.wikipedia.org/wiki/WebGL WebGL].\n\n[page:Object parameters] - (optional) object with properties defining the renderer's behavior. The constructor also accepts no parameters at all. In all cases, it will assume sane defaults when parameters are missing. The following are valid parameters:\n\n\n\n [page:DOMElement canvas] - A [link:https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas canvas] where the renderer draws its output. This corresponds to the [page:WebGLRenderer.domElement domElement] property below. If not passed in here, a new canvas element will be created.\n\n [page:WebGLRenderingContext context] - This can be used to attach the renderer to an existing [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext RenderingContext]. Default is null.\n\n [page:String precision] - Shader precision. Can be `\"highp\"`, `\"mediump\"` or `\"lowp\"`. Defaults to `\"highp\"` if supported by the device.\n\n [page:Boolean alpha] - controls the default clear alpha value. When set to `true`, the value is `0`. Otherwise it's `1`. Default is `false`.\n\n [page:Boolean premultipliedAlpha] - whether the renderer will assume that colors have [link:https://en.wikipedia.org/wiki/Glossary_of_computer_graphics#Premultiplied_alpha premultiplied alpha]. Default is `true`.\n\n [page:Boolean antialias] - whether to perform antialiasing. Default is `false`.\n\n [page:Boolean stencil] - whether the drawing buffer has a [link:https://en.wikipedia.org/wiki/Stencil_buffer stencil buffer] of at least 8 bits. Default is `false`.\n\n [page:Boolean preserveDrawingBuffer] - whether to preserve the buffers until manually cleared or overwritten. Default is `false`.\n\n [page:String powerPreference] - Provides a hint to the user agent indicating what configuration of GPU is suitable for this WebGL context. Can be `\"high-performance\"`, `\"low-power\"` or `\"default\"`. Default is `\"default\"`. See [link:https://www.khronos.org/registry/webgl/specs/latest/1.0/#5.2 WebGL spec] for details.\n\n [page:Boolean failIfMajorPerformanceCaveat] - whether the renderer creation will fail upon low performance is detected. Default is `false`. See [link:https://www.khronos.org/registry/webgl/specs/latest/1.0/#5.2 WebGL spec] for details.\n\n [page:Boolean depth] - whether the drawing buffer has a [link:https://en.wikipedia.org/wiki/Z-buffering depth buffer] of at least 16 bits. Default is `true`.\n\n [page:Boolean logarithmicDepthBuffer] - whether to use a logarithmic depth buffer. It may be necessary to use this if dealing with huge differences in scale in a single scene. Note that this setting uses gl_FragDepth if available which disables the [link:https://www.khronos.org/opengl/wiki/Early_Fragment_Test Early Fragment Test] optimization and can cause a decrease in performance. Default is `false`. See the [example:webgl_camera_logarithmicdepthbuffer camera / logarithmicdepthbuffer] example. [page:Boolean reverseDepthBuffer] - whether to use a reverse depth buffer. Requires the `EXT_clip_control` extension. This is a more faster and accurate version than logarithmic depth buffer. Default is `false`.\n\nDefines whether the renderer should automatically clear its output before rendering a frame. Default is `true`.\n\nIf [page:.autoClear autoClear] is true, defines whether the renderer should clear the color buffer. Default is `true`.\n\nIf [page:.autoClear autoClear] is true, defines whether the renderer should clear the depth buffer. Default is `true`.\n\nIf [page:.autoClear autoClear] is true, defines whether the renderer should clear the stencil buffer. Default is `true`.\n\nAn object containing details about the capabilities of the current [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext RenderingContext].\n\n - [page:Boolean floatFragmentTextures]: whether the context supports the [link:https://developer.mozilla.org/en-US/docs/Web/API/OES_texture_float OES_texture_float] extension.\n\n - [page:Boolean floatVertexTextures]: `true` if [page:Boolean floatFragmentTextures] and [page:Boolean vertexTextures] are both true.\n\n - [page:Method getMaxAnisotropy](): Returns the maximum available anisotropy.\n\n - [page:Method getMaxPrecision](): Returns the maximum available precision for vertex and fragment shaders. \n\n - [page:Boolean isWebGL2]: `true` if the context in use is a WebGL2RenderingContext object.\n\n - [page:Boolean logarithmicDepthBuffer]: `true` if the [page:parameter logarithmicDepthBuffer] was set to true in the constructor.\n\n - [page:Integer maxAttributes]: The value of `gl.MAX_VERTEX_ATTRIBS`.\n\n - [page:Integer maxCubemapSize]: The value of `gl.MAX_CUBE_MAP_TEXTURE_SIZE`. Maximum height * width of cube map textures that a shader can use.\n\n - [page:Integer maxFragmentUniforms]: The value of `gl.MAX_FRAGMENT_UNIFORM_VECTORS`. The number of uniforms that can be used by a fragment shader.\n\n - [page:Integer maxSamples]: The value of `gl.MAX_SAMPLES`. Maximum number of samples in context of Multisample anti-aliasing (MSAA).\n\n - [page:Integer maxTextureSize]: The value of `gl.MAX_TEXTURE_SIZE`. Maximum height * width of a texture that a shader use.\n\n - [page:Integer maxTextures]: The value of `gl.MAX_TEXTURE_IMAGE_UNITS`. The maximum number of textures that can be used by a shader.\n\n - [page:Integer maxVaryings]: The value of `gl.MAX_VARYING_VECTORS`. The number of varying vectors that can used by shaders.\n\n - [page:Integer maxVertexTextures]: The value of `gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS`. The number of textures that can be used in a vertex shader.\n\n - [page:Integer maxVertexUniforms]: The value of `gl.MAX_VERTEX_UNIFORM_VECTORS`. The maximum number of uniforms that can be used in a vertex shader.\n\n - [page:String precision]: The shader precision currently being used by the renderer.\n\n - [page:Boolean reverseDepthBuffer]: `true` if the [page:parameter reverseDepthBuffer] was set to `true` in the constructor and the context supports the [link:https://registry.khronos.org/webgl/extensions/EXT_clip_control/ EXT_clip_control] extension.\n\n - [page:Boolean vertexTextures]: `true` if [property:Integer maxVertexTextures] is greater than 0 (i.e. vertex textures can be used).\n\n\n\nUser-defined clipping planes specified as THREE.Plane objects in world space. These planes apply globally. Points in space whose dot product with the plane is negative are cut away. Default is [].\n\n- [page:Boolean checkShaderErrors]: If it is true, defines whether material shader programs are checked for errors during compilation and linkage process. It may be useful to disable this check in production for performance gain. It is strongly recommended to keep these checks enabled during development. If the shader does not compile and link - it will not work and associated material will not render. Default is `true`.\n\n - [page:Function onShaderError]( gl, program, glVertexShader, glFragmentShader ): A callback function that can be used for custom error reporting. The callback receives the WebGL context, an instance of WebGLProgram as well two instances of WebGLShader representing the vertex and fragment shader. Assigning a custom function disables the default error reporting. Default is `null`.\n\nA [link:https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas canvas] where the renderer draws its output.\n\n This is automatically created by the renderer in the constructor (if not provided already); you just need to add it to your page like so:\n\n\n\n- [page:Object get]( [param:String extensionName] ): Used to check whether various extensions are supported and returns an object with details of the extension if available. This method can check for the following extensions:\n\n\n\n- [page:Boolean has]( [param:String extensionName] ): `true` if the extension is supported.\n\nDefines the output color space of the renderer. Default is [page:Textures THREE.SRGBColorSpace].\n\nIf a render target has been set using [page:WebGLRenderer.setRenderTarget .setRenderTarget] then renderTarget.texture.colorSpace will be used instead.\n\nSee the [page:Textures texture constants] page for details of other formats.\n\nAn object with a series of statistical information about the graphics board memory and the rendering process. Useful for debugging or just for the sake of curiosity. The object contains the following fields:\n\nBy default these data are reset at each render call but when having multiple render passes per frame (e.g. when using post processing) it can be preferred to reset with a custom pattern. First, set `autoReset` to `false`. Call `reset()` whenever you have finished to render a single frame.\n\nDefines whether the renderer respects object-level clipping planes. Default is `false`.\n\nUsed internally by the renderer to keep track of various sub object properties.\n\nUsed internally to handle ordering of scene object rendering.\n\nThis contains the reference to the shadow map, if used.\n\n - [page:Boolean enabled]: If set, use shadow maps in the scene. Default is `false`.\n\n - [page:Boolean autoUpdate]: Enables automatic updates to the shadows in the scene. Default is `true`.\n\n If you do not require dynamic lighting / shadows, you may set this to `false` when the renderer is instantiated.\n\n - [page:Boolean needsUpdate]: When set to `true`, shadow maps in the scene will be updated in the next `render` call. Default is `false`.\n\n If you have disabled automatic updates to shadow maps (`shadowMap.autoUpdate = false`), you will need to set this to `true` and then make a render call to update the shadows in your scene.\n\n - [page:Integer type]: Defines shadow map type (unfiltered, percentage close filtering, percentage close filtering with bilinear filtering in shader). Options are:\n\nDefines whether the renderer should sort objects. Default is `true`.\n\n\n\n Note: Sorting is used to attempt to properly render objects that have some degree of transparency. By definition, sorting objects may not work in all cases. Depending on the needs of application, it may be necessary to turn off sorting and use other methods to deal with transparency rendering e.g. manually determining each object's rendering order.\n\nContains functions for setting various properties of the [page:WebGLRenderer.context] state.\n\nDefault is [page:Renderer NoToneMapping]. See the [page:Renderer Renderer constants] for other choices.\n\nThe normalized resolution scale for the transmission render target, measured in percentage of viewport dimensions. Lowering this value can result in significant improvements to [page:MeshPhysicalMaterial MeshPhysicalMaterial] transmission performance. Default is `1`.\n\nProvides access to the WebXR related [page:WebXRManager interface] of the renderer.\n\nTells the renderer to clear its color, depth or stencil drawing buffer(s). This method initializes the color buffer to the current clear color value.\n\n Arguments default to `true`.\n\nCompiles all materials in the scene with the camera. This is useful to precompile shaders before the first rendering. If you want to add a 3D object to an existing scene, use the third optional parameter for applying the target scene.\n\n Note that the (target) scene's lighting and environment should be configured before calling this method.\n\nAsynchronous version of [page:WebGLRenderer.compile .compile](). The method returns a Promise that resolves when the given scene can be rendered without unnecessary stalling due to shader compilation.\n\n\n\n This method makes use of the *KHR_parallel_shader_compile* WebGL extension.\n\nCopies pixels from the current WebGLFramebuffer into a 2D texture. Enables access to [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/copyTexImage2D WebGLRenderingContext.copyTexImage2D].\n\nCopies the pixels of a texture in the bounds '[page:Box3 srcRegion]' in the destination texture starting from the given position. 2D Texture, 3D Textures, or a mix of the two can be used as source and destination texture arguments for copying between layers of 3d textures. The `depthTexture` and `texture` property of render targets are supported as well.\n\n When using render target textures as `srcTexture` and `dstTexture`, you must make sure both render targets are initialized e.g. via [page:.initRenderTarget]().\n\nFrees the GPU-related resources allocated by this instance. Call this method whenever this instance is no longer used in your app.\n\nSimulate loss of the WebGL context. This requires support for the [link:https://developer.mozilla.org/en-US/docs/Web/API/WEBGL_lose_context WEBGL_lose_context] extensions.\n\nSimulate restore of the WebGL context. This requires support for the [link:https://developer.mozilla.org/en-US/docs/Web/API/WEBGL_lose_context WEBGL_lose_context] extensions.\n\nReturns a [page:Float float] with the current clear alpha. Ranges from `0` to `1`.\n\nReturns an object that describes the attributes set on the WebGL context when it was created.\n\nReturns the current [page:RenderTarget RenderTarget] if there are; returns `null` otherwise.\n\n[page:Vector4 target] — the result will be copied into this Vector4.\n\n\n\n Returns the current viewport.\n\n[page:Vector2 target] — the result will be copied into this Vector2.\n\n\n\n Returns the width and height of the renderer's drawing buffer, in pixels.\n\n[page:Vector4 target] — the result will be copied into this Vector4.\n\n\n\n Returns the scissor region.\n\nReturns `true` if scissor test is enabled; returns `false` otherwise.\n\n[page:Vector2 target] — the result will be copied into this Vector2.\n\n\n\n Returns the width and height of the renderer's output canvas, in pixels.\n\n[page:Vector4 target] — the result will be copied into this Vector4.\n\n\n\n Returns the viewport.\n\nInitializes the given texture. Useful for preloading a texture rather than waiting until first render (which can cause noticeable lags due to decode and GPU upload overhead).\n\nInitializes the given WebGLRenderTarget memory. Useful for initializing a render target so data can be copied into it using [page:WebGLRenderer.copyTextureToTexture .copyTextureToTexture] before it has been rendered to.\n\nReset the GL state to default. Called internally if the WebGL context is lost.\n\nbuffer - Uint8Array is the only destination type supported in all cases, other types are renderTarget and platform dependent. See [link:https://www.khronos.org/registry/webgl/specs/latest/1.0/#5.14.12 WebGL spec] for details.\n\nReads the pixel data from the renderTarget into the buffer you pass in. This is a wrapper around [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/readPixels WebGLRenderingContext.readPixels]().\n\nFor reading out a [page:WebGLCubeRenderTarget WebGLCubeRenderTarget] use the optional parameter activeCubeFaceIndex to determine which face should be read.\n\nAsynchronous, non-blocking version of [page:WebGLRenderer.readRenderTargetPixels .readRenderTargetPixels]. The returned promise resolves once the buffer data is ready to be used.\n\nSee the [example:webgl_interactive_cubes_gpu interactive / cubes / gpu] example.\n\nRender a [page:Scene scene] or another type of [page:Object3D object] using a [page:Camera camera].\n\n The render is done to a previously specified [page:WebGLRenderTarget renderTarget] set by calling [page:WebGLRenderer.setRenderTarget .setRenderTarget] or to the canvas as usual.\n\n By default render buffers are cleared before rendering but you can prevent this by setting the property [page:WebGLRenderer.autoClear autoClear] to false. If you want to prevent only certain buffers being cleared you can set either the [page:WebGLRenderer.autoClearColor autoClearColor], [page:WebGLRenderer.autoClearStencil autoClearStencil] or [page:WebGLRenderer.autoClearDepth autoClearDepth] properties to false. To forcibly clear one or more buffers call [page:WebGLRenderer.clear .clear].\n\nCan be used to reset the internal WebGL state. This method is mostly relevant for applications which share a single WebGL context across multiple WebGL libraries.\n\n[page:Function callback] — The function will be called every available frame. If `null` is passed it will stop any already ongoing animation.\n\nA built in function that can be used instead of [link:https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame requestAnimationFrame]. For WebXR projects this function must be used.\n\nSets the clear alpha. Valid input is a float between `0.0` and `1.0`.\n\nSets device pixel ratio. This is usually used for HiDPI device to prevent blurring output canvas.\n\nrenderTarget -- The [page:WebGLRenderTarget renderTarget] that needs to be activated. When `null` is given, the canvas is set as the active render target instead.\n\n activeCubeFace -- Specifies the active cube side (PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5) of [page:WebGLCubeRenderTarget]. When passing a [page:WebGLArrayRenderTarget] or [page:WebGL3DRenderTarget] this indicates the z layer to render in to (optional).\n\n activeMipmapLevel -- Specifies the active mipmap level (optional).\n\n\n\n This method sets the active rendertarget.\n\nThe x, y, width, and height parameters of the scissor region.\n\n Optionally, a 4-component vector specifying the parameters of the region.\n\n\n\n Sets the scissor region from (x, y) to (x + width, y + height).\n\n (x, y) is the lower-left corner of the scissor region.\n\nEnable or disable the scissor test. When this is enabled, only the pixels within the defined scissor area will be affected by further renderer actions.\n\nSets the custom opaque sort function for the WebGLRenderLists. Pass null to use the default painterSortStable function.\n\nSets the custom transparent sort function for the WebGLRenderLists. Pass null to use the default reversePainterSortStable function.\n\nResizes the output canvas to (width, height) with device pixel ratio taken into account, and also sets the viewport to fit that size, starting in (0, 0). Setting [page:Boolean updateStyle] to false prevents any style changes to the output canvas.\n\nThe x, y, width, and height parameters of the viewport.\n\n Optionally, a 4-component vector specifying the parameters of a viewport.\n\n\n\n Sets the viewport to render from (x, y) to (x + width, y + height).\n\n (x, y) is the lower-left corner of the region."
    },
    {
        "link": "https://tympanus.net/codrops/2021/07/21/creating-a-typography-motion-trail-effect-with-three-js",
        "document": "Framebuffers are a key feature in WebGL when it comes to creating advanced graphical effects such as depth-of-field, bloom, film grain or various types of anti-aliasing and have already been covered in-depth here on Codrops. They allow us to “post-process” our scenes, applying different effects on them once rendered. But how exactly do they work?\n\nBy default, WebGL (and also Three.js and all other libraries built on top of it) render to the default framebuffer, which is the device screen. If you have used Three.js or any other WebGL framework before, you know that you create your mesh with the correct geometry and material, render it, and voilà, it’s visible on your screen.\n\nHowever, we as developers can create new framebuffers besides the default one and explicitly instruct WebGL to render to them. By doing so, we render our scenes to image buffers in the video card’s memory instead of the device screen. Afterwards, we can treat these image buffers like regular textures and apply filters and effects before eventually rendering them to the device screen.\n\nHere is a video breaking down the post-processing and effects in Metal Gear Solid 5: Phantom Pain that really brings home the idea. Notice how it starts by footage from the actual game rendered to the default framebuffer (device screen) and then breaks down how each framebuffer looks like. All of these framebuffers are composited together on each frame and the result is the final picture you see when playing the game:\n\nSo with the theory out of the way, let’s create a cool typography motion trail effect by rendering to a framebuffer!\n\nLet’s render some 2D text to the default framebuffer, i.e. device screen, using . Here is our boilerplate:\n\nThis code simply initialises a scene, adds a 2D plane with a text texture to it and renders it to the default framebuffer (device screen). If we are execute it with included in our project, we will get this:\n\nSee the Pen Step 1: Render to default framebuffer by Georgi Nikoloff (@gbnikolov) on CodePen.\n\nAgain, we don’t explicitly specify otherwise, so we are rendering to the default framebuffer (device screen).\n\nNow that we managed to render our scene to the device screen, let’s add a framebuffer ( ) and render it to a texture in the video card memory.\n\nLet’s start by creating a new framebuffer when we initialise our app:\n\nNow that we have created it, we must explicitly instruct to render to it instead of the default framebuffer, i.e. device screen. We will do this in our program animation loop:\n\nAnd here is our result:\n\nSee the Pen Step 2: Render to a framebuffer by Georgi Nikoloff (@gbnikolov) on CodePen.\n\nAs you can see, we are getting an empty screen, yet our program contains no errors – so what happened? Well, we are no longer rendering to the device screen, but another framebuffer! Our scene is being rendered to a texture in the video card memory, so that’s why we see the empty screen.\n\nIn order to display this generated texture containing our scene back to the default framebuffer (device screen), we need to create another 2D plane that will cover the entire screen of our app and pass the texture as material input to it.\n\nFirst we will create a fullscreen 2D plane that will span the entire device screen:\n\nAs you can see, we are creating a new scene that will hold our fullscreen plane. After creating it, we need to augment our animation loop to render the generated texture from the previous step to the fullscreen plane on our screen:\n\nAfter including these snippets, we can see our scene once again rendered on the screen:\n\nSee the Pen Step 3: Display the generated framebuffer on the device screen by Georgi Nikoloff (@gbnikolov) on CodePen.\n\nLet’s recap the necessary steps needed to produce this image on our screen on each render loop:\n• Create framebuffer that will allow us to render to a separate texture in the users device video memory\n• Render the “ABC” plane mesh to instead of the device screen\n• Create a separate fullscreen plane mesh that expects a texture as an input to its material\n• Render the fullscreen plane mesh back to the default framebuffer (device screen) using the generated texture created by rendering the “ABC” mesh to\n\nAchieving the persistence effect by using two framebuffers\n\nWe don’t have much use of framebuffers if we are simply displaying them as they are to the device screen, as we do right now. Now that we have our setup ready, let’s actually do some cool post-processing.\n\nFirst, we actually want to create yet another framebuffer – , and make sure it and are variables, rather then s. That’s because we will actually swap them at the end of each render so we can achieve framebuffer ping-ponging.\n\n“Ping-ponging” in WebGl is a technique that alternates the use of a framebuffer as either input or output. It is a neat trick that allows for general purpose GPU computations and is used in effects such as gaussian blur, where in order to blur our scene we need to:\n• Render it to using a 2D plane and apply horizontal blur via the fragment shader\n• Render the result horizontally blurred image from step 1 to and apply vertical blur via the fragment shader\n• Keep repeating steps 1 to 3 and incrementally applying blur until desired gaussian blur radius is achieved.\n\nHere is a small chart illustrating the steps needed to achieve ping-pong:\n\nSo with that in mind, we will render the contents of into using the we created and apply some special effect via the fragment shader.\n\nLet’s kick things off by creating our :\n\nNext up, let’s augment our animation loop to actually do the ping-pong technique:\n\nIf we are to render our scene again with these updated snippets, we will see no visual difference, even though we do in fact alternate between the two framebuffers to render it. That’s because, as it is right now, we do not apply any special effects in the fragment shader of our .\n\nLet’s change our fragment shader like so:\n\nWith these changes in place, here is our updated program:\n\nSee the Pen Step 4: Create a second framebuffer and ping-pong between them by Georgi Nikoloff (@gbnikolov) on CodePen.\n\nLet’s break down one frame render of our updated example:\n• We render our “ABC” text to , compositing it on top of result in step 1 (we do not clear the contents of the canvas on new renders, because we set )\n• We pass the generated texture to , apply a small offset to its UVs when looking up the texture color and fade it out a bit by multiplying the result by\n• We render to the device screen\n\nFor each new frame render, we will repeat steps 1 to 5. This way, the previous target framebuffer we rendered to will be used as an input to the current render and so on. You can clearly see this effect visually in the last demo – notice how as the ping-ponging progresses, more and more offset is being applied to the UVs and more and more the opacity fades out.\n\nNow that we have implemented and can see the ping-pong technique working correctly, we can get creative and expand on it.\n\nInstead of simply adding an offset in our fragment shader as before:\n\nLet’s actually use simplex noise for more interesting visual result. We will also control the direction using our mouse position.\n\nHere is our updated fragment shader:\n\nWe also need to specify and as inputs to our material shader:\n\nFinally let’s make sure we attach a event listener to our page and pass the updated normalised mouse coordinates from Javascript to our GLSL fragment shader:\n\nWith these changes in place, here is our final result. Make sure to hover around it (you might have to wait a moment for everything to load):\n\nSee the Pen Step 5: Perlin Noise and mouse interaction by Georgi Nikoloff (@gbnikolov) on CodePen.\n\nFramebuffers are a powerful tool in WebGL that allows us to greatly enhance our scenes via post-processing and achieve all kinds of cool effects. Some techniques require more then one framebuffer as we saw and it is up to us as developers to mix and match them however we need to achieve our desired visuals.\n\nI encourage you to experiment with the provided examples, try to render more elements, alternate the “ABC” text color between each and swap to achieve different color mixing, etc.\n\nIn the first demo, you can see a specific example of how this typography effect could be used and the second demo is a playground for you to try some different settings (just open the controls in the top right corner).\n• How to use post-processing in threejs"
    },
    {
        "link": "https://stackoverflow.com/questions/55082573/use-webgl-texture-as-a-three-js-texture-map",
        "document": "I have a scene with plane which should use WebGL texture (created using ) as a map for material. Basically, it doesn't matter how this texture will be used, I just need to find a way to pass it to the with certain uniform. WebGL texture updates every frame.\n\nThe texture is rendered in context of other canvas element and can be used in that context like this:\n\nI've already tried this solution. But it seems like doesn't grab data from raw WebGL texture."
    },
    {
        "link": "https://blog.pixelfreestudio.com/how-to-create-3d-animations-with-three-js",
        "document": "Creating 3D animations can seem like a daunting task, but with the right tools, it becomes a lot simpler. One of the best tools out there for this purpose is Three.js. This JavaScript library makes it possible to create 3D graphics in the browser, using WebGL. In this guide, we will walk through the steps of creating 3D animations with Three.js in a simple, easy-to-follow manner.\n\nThree.js is a powerful JavaScript library that allows developers to create and display animated 3D graphics in a web browser. It uses WebGL to render these graphics, which means it leverages the power of your computer’s graphics card for smooth, high-performance animations.\n\nBefore we start, you need to set up your development environment. Here’s how you can do it:\n• Install Node.js and npm: These are required to manage your project and its dependencies. You can download them from the official Node.js website.\n• Create a new project directory: This is where all your project files will go. Open your terminal and create a new directory.\n• Install Three.js: In your project directory, run to install the Three.js library.\n\nTo get started with Three.js, you need to set up a basic scene. This includes a camera, a renderer, and a scene. Here’s a simple example:\n\nIn this code, we create a new scene, set up a camera, and create a WebGL renderer. The function ensures that our scene gets rendered in an animation loop.\n\nThree.js provides a variety of basic shapes that you can add to your scene. These include cubes, spheres, and more. Here’s how you can add a cube to your scene:\n\nIn this code, we create a cube using and , then add it to our scene.\n\nLighting is crucial for making your 3D objects look good. Three.js provides several types of lights, such as ambient light, point light, and directional light. Here’s how you can add a basic light to your scene:\n\nThis code adds a soft white ambient light to the scene, which lights up all objects equally.\n\nAnimating objects in Three.js is straightforward. You can modify the properties of objects inside the animation loop. For example, to rotate the cube we created earlier, you can do this:\n\nIn this code, we rotate the cube on its x and y axes slightly in each frame, creating a spinning effect.\n\nFor more complex animations, you can use a library like Tween.js. This library allows you to create smooth, interpolated animations. First, you need to install it:\n\nThen, you can use it to animate your objects smoothly. Here’s an example:\n\nIn this code, we create a tween that moves the cube to position (2, 2, 2) over 2000 milliseconds.\n\nFor more complex 3D objects, you might want to load models created in external programs like Blender. Three.js supports loading various model formats using loaders.\n\nHere’s how you can load a .glb file using the GLTFLoader:\n\nFirst, install the necessary loader:\n\nThen, you can load and add the model to your scene:\n\nIn this example, we load a .glb model and add it to the scene. The loader’s function takes three arguments: the model’s path, a function to execute when the model is loaded, and an error-handling function.\n\nTextures add realism to your 3D objects. You can apply textures to your objects using materials. Here’s how you can load and apply a texture to a cube:\n\nIn this code, we load a texture using and apply it to the cube’s material.\n\nParticle systems are great for effects like smoke, fire, or rain. Three.js allows you to create particle systems using and . Here’s a simple example of a particle system:\n\nIn this code, we create 1000 particles and add them to the scene with a basic white color.\n\nTo interact with your 3D scene, you can add controls. The OrbitControls library, for example, allows you to move the camera around the scene with the mouse. Here’s how to set it up:\n\nIn this code, we initialize and update it in the animation loop.\n\nShadows add depth to your scenes but can be performance-intensive. Here’s how you can add basic shadows:\n\nIn this code, we enable shadows on the renderer and configure the cube and light to cast and receive shadows.\n\nAdding interactivity to your animations can make them more engaging. Three.js allows you to handle user input such as mouse movements and clicks.\n\nHere’s an example of how to detect and respond to mouse clicks on objects in the scene:\n\nIn this code, we use a to detect which objects the mouse is pointing at and change the color of the clicked object.\n\nThree.js supports adding a graphical user interface (GUI) for tweaking parameters in real-time using the dat.GUI library. Here’s how to set it up:\n\nThis code adds a GUI that allows you to control the cube’s rotation along the x, y, and z axes.\n\nFor character animations, Three.js supports skeletal animations. You can rig models with bones and animate them. Here’s a brief overview:\n• Create or import a rigged model: Use a tool like Blender to rig your model.\n• Load the rigged model: Use the to load your rigged model.\n• Animate the bones: Modify the bones’ positions or rotations in your animation loop.\n\nIn this example, we load a rigged model, create a skeleton helper to visualize bones, and animate one of the bones.\n\nMorph targets allow you to animate the vertices of a geometry for facial animations or other deformations. Here’s an example of using morph targets:\n\nIn this example, we create a morph target that modifies the vertices of a box and animate it by changing the property.\n\nOnce you have your 3D animation, you might want to export it as a video. This involves capturing frames and combining them into a video file. Here’s a basic example using :\n\nThen, you can use it to capture frames:\n\nThis code captures the frames rendered by Three.js and saves them as a webm video.\n\nYou can also export your Three.js models and scenes for use in other applications. Three.js provides exporters for various formats. Here’s how you can export your scene to a GLTF file:\n\nIn this code, we use the to export the scene and log the result to the console.\n\nReact is a popular JavaScript library for building user interfaces. You can integrate Three.js with React using the library, which allows you to write Three.js code using React components.\n\nHere’s how to set it up:\n\nFirst, install the necessary libraries:\n\nIn this example, we create a component that renders a cube and use the component from to render the scene.\n\nVue.js is another popular JavaScript framework. You can integrate Three.js with Vue.js to create interactive 3D applications. Here’s a simple example:\n\nThen, create a Vue component that sets up a Three.js scene:\n\nIn this example, we create a Vue component that initializes a Three.js scene with a rotating cube.\n\nAngular is a popular framework for building web applications. Integrating Three.js with Angular involves creating a component that initializes a Three.js scene. Here’s an example:\n\nThen, create an Angular component that sets up a Three.js scene:\n\nIn this example, we create an Angular component that initializes a Three.js scene and renders a rotating cube.\n\nUsing Three.js with HTML and CSS\n\nThree.js can be integrated seamlessly with HTML and CSS to create interactive web applications. Here’s how you can overlay HTML elements on top of a Three.js scene:\n\nIn this example, we overlay an HTML element on top of the Three.js scene. The remains fixed while the cube rotates in the background.\n\nMaking your 3D scenes responsive ensures they look good on all devices. Here’s how you can make a Three.js scene responsive:\n\nIn this code, the function updates the camera’s aspect ratio and the renderer’s size when the window is resized.\n\nYou can enhance your Three.js applications by combining them with UI frameworks like Bootstrap or Materialize. This allows you to create rich, interactive interfaces around your 3D content.\n\nIn this example, we use Bootstrap to create a responsive container for our Three.js scene.\n\nThree.js provides a powerful post-processing system that allows you to add visual effects to your scenes. The class is used to manage multiple passes for post-processing.\n\nHere’s a basic example of using to add a bloom effect:\n\nIn this code, we set up the with a and a to add a bloom effect to the scene.\n\nCustom shader passes allow you to create unique visual effects. Here’s an example of adding a simple custom shader pass:\n\nIn this code, we define a custom shader that modifies the red channel of the rendered scene and add it to the .\n\nThree.js is an excellent tool for creating interactive data visualizations. You can visualize complex data sets in 3D to gain new insights. Here’s an example of a simple 3D scatter plot:\n\nIn this code, we create a 3D scatter plot by placing spheres at the data points.\n\nThree.js is widely used for architectural visualization, allowing clients to explore 3D models of buildings and spaces interactively. You can load architectural models and add lighting and materials to create realistic scenes.\n\nThree.js is also used in game development. You can create 3D games that run directly in the browser. Here’s a basic example of a simple 3D game loop:\n\nIn this code, we set up a game loop that updates game logic and renders the scene each frame.\n\nBest Practices for Developing with Three.js\n\nKeeping your code well-organized is crucial for maintaining and scaling your projects. Here are some tips for organizing your Three.js projects:\n\nDivide your code into modules to keep it manageable and reusable. For example, create separate files for your scene setup, animation logic, and utility functions.\n\nEncapsulate functionality in classes to create reusable components. For example, create a class for your 3D objects:\n\nOptimizing performance is crucial, especially for complex scenes. Here are some additional tips to improve performance:\n\nInstancing allows you to render multiple copies of the same geometry efficiently. This is useful for scenes with many identical objects, like trees or particles.\n\nUsing custom shaders allows you to optimize rendering by writing efficient GPU code. This can significantly improve performance for complex visual effects.\n\nEffective debugging and profiling are essential for identifying and fixing performance issues.\n\nChrome DevTools provides powerful tools for profiling and debugging your Three.js applications. You can use the Performance tab to profile your application and identify bottlenecks.\n\nThe Three.js Inspector is a browser extension that provides tools for inspecting and debugging Three.js scenes. It allows you to view and manipulate the scene graph, camera, and materials directly in the browser.\n\nThree.js has a vibrant community and a wealth of resources to help you learn and solve problems.\n\nThe official Three.js documentation is comprehensive and includes numerous examples that cover a wide range of use cases.\n\nJoin forums and Q&A sites like Stack Overflow, where you can ask questions and get help from the community.\n\nNumerous tutorials and courses are available online to help you learn Three.js. Websites like Udemy, Coursera, and YouTube offer courses ranging from beginner to advanced levels.\n\nFuture of 3D on the Web\n\nThe future of 3D on the web is exciting, with advancements in WebXR enabling virtual reality (VR) and augmented reality (AR) experiences directly in the browser.\n\nThree.js provides support for WebXR, allowing you to create immersive VR and AR applications.\n\nHere’s a basic example of setting up a WebXR scene with Three.js:\n\nIn this code, we enable WebXR on the renderer, add VR controllers, and set up an animation loop for rendering the VR scene.\n\nWebGPU is an emerging standard for web graphics that promises to deliver better performance and more advanced features than WebGL. Three.js has experimental support for WebGPU, allowing you to take advantage of these improvements.\n\nHere’s a basic example of setting up a WebGPU renderer with Three.js:\n\nIn this example, we set up a WebGPU renderer and create a basic scene with a rotating cube.\n\nTo get better at Three.js, explore a variety of learning resources. The official Three.js documentation is a great starting point, offering detailed explanations and examples. Tutorials on sites like YouTube and platforms like Udemy and Coursera provide structured learning paths.\n\nEngage with the Three.js community through forums and social media groups to get insights and help from other developers.\n\nThe key to mastering Three.js is hands-on experimentation. Try building small projects to practice different aspects of the library. Experiment with different geometries, materials, and animations to understand how they work together.\n\nDon’t hesitate to break things; it’s all part of the learning process.\n\nThree.js is continuously evolving with new features and improvements. Keep an eye on the official Three.js blog and GitHub repository for updates. Following influential Three.js developers and enthusiasts on social media can also keep you informed about the latest trends and best practices.\n\nCreating 3D animations with Three.js opens up a world of possibilities for web developers. This powerful JavaScript library makes it easier to build complex, interactive 3D graphics in the browser.\n\nFrom setting up a basic scene to adding advanced features like shaders, post-processing, and VR support, Three.js provides all the tools you need. By staying organized, optimizing performance, and continually experimenting, you can master Three.js and bring your creative visions to life.\n\nWhether for games, data visualizations, or architectural models, Three.js offers a versatile platform for stunning 3D web experiences.\n• How to Use Code Reviews to Improve Maintainability\n• How to Handle Technical Debt in Software Projects\n• How to Use Static Code Analysis for Better Code"
    }
]