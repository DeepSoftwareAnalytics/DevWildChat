[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/HTML/Element/marquee",
        "document": "Deprecated: This feature is no longer recommended. Though some browsers might still support it, it may have already been removed from the relevant web standards, may be in the process of being dropped, or may only be kept for compatibility purposes. Avoid using it, and update existing code if possible; see the compatibility table at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time.\n\nThe HTML element is used to insert a scrolling area of text. You can control what happens when the text reaches the edges of its content area using its attributes.\n\nThe HTML element is deprecated and its use is strongly discouraged. If you must create the effect of scrolling text or continuous elements, consider using CSS animations with CSS transforms instead of elements to smoothly animate content. Additionally, include the CSS query to stop the animation based on user preference, thereby improving user experience and accessibility."
    },
    {
        "link": "https://geeksforgeeks.org/html-marquee-bgcolor-attribute",
        "document": "The Marquee bgcolor attribute in HTML is used to set the backgroundcolor of marquee.\n\nNote: This attribute is no longer supported in HTML5.\nâ€¢ color name: Define the background color of the marquee."
    },
    {
        "link": "https://geeksforgeeks.org/html-marquee-height-attribute",
        "document": "The Marquee height attribute in HTML is used to set the height of marquee in pixels or percentage value.\n\nSyntax:\nâ€¢ px: Define the height value of marquee.\nâ€¢ %: Define the height value of marquee.\n\nNote : The <marquee> height attribute is not supported by HTML5.\n\nSupported Browsers: The browsers supported by HTML Marquee height attribute are listed below:"
    },
    {
        "link": "https://w3schools.in/html/marquee-tag",
        "document": "Marquee is one of the important tags introduced in HTML to support such scrollable texts and images within a web page. In this tutorial, you will learn about the Marquee tag and its different attributes for developing a well-groomed static website.\n\nThe tag is a container tag of HTML that is implemented for creating scrollable text or images within a web page from either left to right or vice versa, or top to bottom or vice versa. But this tag has been deprecated in the new version of HTML, i.e., HTML 5.\n\nThe different attributes of tag are:\n\nHere's are some example of how to use tag in HTML:\n\nThis is a sample scrolling text that has scrolls in the upper direction.\n\nThis is a sample scrolling text that has scrolls texts to down.\n\nThis is a sample scrolling text that has scrolls texts to the right.\n\nThis is a sample scrolling text that has scrolls texts to the left.\n\nMarquee speed can be changed using the \"scrollmount\" attribute. For example, if you are using , then it sets the marque to scroll very slowly, and as you increase the \"scrollmount,\" the scrolling speed will also increase.\n\nMarquee can also be implemented using CSS. Read the CSS Marquee chapter to learn more about it.\n\nThis is an example of blinking text using CSS within a marquee."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/HTMLMarqueeElement",
        "document": "Deprecated: This feature is no longer recommended. Though some browsers might still support it, it may have already been removed from the relevant web standards, may be in the process of being dropped, or may only be kept for compatibility purposes. Avoid using it, and update existing code if possible; see the compatibility table at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time. The interface provides methods to manipulate elements. It inherits properties and methods from the interface.\n\nSets how the text is scrolled within the marquee. Possible values are , and . If no value is specified, the default value is . Sets the background color through color name or hexadecimal value. Sets the direction of the scrolling within the marquee. Possible values are , , and . If no value is specified, the default value is . Sets the height in pixels or percentage value. Sets the number of times the marquee will scroll. If no value is specified, the default value is âˆ’1, which means the marquee will scroll continuously. Sets the amount of scrolling at each interval in pixels. The default value is 6. Sets the interval between each scroll movement in milliseconds. The default value is 85. Note that any value smaller than 60 is ignored and the value 60 is used instead, unless is . By default, values lower than 60 are ignored. If is , then those values are not ignored. Sets the width in pixels or percentage value.\n\nFires when the marquee has reached the end of its scroll position. It can only fire when the behavior attribute is set to . Fires when the marquee has finished the amount of scrolling that is set by the loop attribute. It can only fire when the loop attribute is set to some number that is greater than 0."
    },
    {
        "link": "https://medium.com/@FlangerHanger/create-your-own-css-pixel-art-with-two-divs-box-shadow-33653e3d3228",
        "document": "Yesterday I learnt how to create pixel images with the power of css and two divs. Thatâ€™s right, TWO divs! When I had seen these in the past, I imagined that the pixels would be made up of lots of little HTML divs and a lot of positioning but alas there is always another way.\n\nI am going to walk you through my process of creating Link (Zelda) and show you how to make your own pixel art.\n\nFirst things first, find an image either already in pixels or that you can easily convert as a reference. You will want to be able to count the number of pixels across and down so you can keep track of where you are. I chose this image of link because I could already see the pixels.\n\nSet up your files; I am using SCSS here but you can do it in CSS just as easily (just take out the colour variables for css). I usually use VS Code with the live viewer extension and the following command so I can see my changes in my browser every time I hit save in my SCSS file.\n\nYour HTML file should have a div within a div as below. Give both of these divs a css class; pixel-container and pixel (or whatever floats your boat ðŸ¤—).\n\nJump over to your style sheet. I have set up the styling for the classes in my SCSS file along with variables for colours so I can easily change a colour for another at a later date if I want to. You donâ€™t have to setup up the variables but you do need the classes.\n\nThe first class, pixel-container, is applied to the div container that holds the entire image. The size of this needs to be set to reflect the entire image size.\n\nThe second class, pixel, is applied to the div within the pixel-container and is going to make the pixel we will be working with. Set the size of the pixel to 1em x 1em. We are going to use the box-shadow property with multiple values on this pixel to create the pixel image.\n\nThe syntax for box-shadow is as follows:\n\nThe first em value in the box-shadow is the X axis, this value increases as you go across the image to the right. The second em is the Y axis, this value will increase as you go down the image. The last property is the colour of that shadow (in our case, the colour of a pixel).\n\nWe are basically going to move across the image, pixel by pixel, specifying what colour that pixel should be using the box-shadow. Once a line is complete, we then move down a line and repeat the process until the entire image is complete.\n\nThe background colour of my image is white so I have not set the box-shadow property for the background of the image as it will be white by default. If you look at the Codepen below, you should see one black pixel on the page.\n\nThe box-shadow property in my pixel class is as follows:\n\nI have gone straight to the 8th pixel along on the 1st row down and set the colour to be $outline which is black. In the first row of my image, this is the first pixel that is not background and is part of Linkâ€™s outline.\n\nThe next block of code shows the completion of the first row and then the second. After each pixel, just increase the first em value by one to move one pixel right and set the colour. When you have reached the end, increase the second em value by one to move down a line and start again at the beginning of the line. Now you will probably see why an image reference with pixels is helpful ðŸ˜‰.\n\nContinue to add box-shadow properties to create the entire image. Iâ€™m sure there are DRYer ways of creating pixel art but this works!\n\nI have posted the entire code here in code pen.\n\nThis is my first tutorial/article, let me know how I went ðŸ˜…\n\nI learnt how to make my first CSS pixel art using this great tutorial. Enjoy!"
    },
    {
        "link": "https://dev.to/jnschrag/creating-pixel-art-with-css-3451",
        "document": "I have always enjoyed looking at and creating pixel art. Before online pixel makers were a thing, I used to spend hours making my own pixel art in Photoshop with the pencil tool. This article will show you how using CSS (and a tiny bit of HTML), you can use code to make your own pixel art creations.\n\nWhile it is 100% possible to create pixel art by creating a bunch of s and changing their background color, that's a lot of s to keep track of and copy if you want to reuse your pixel in multiple places. I prefer to create pixel art with a single , which we can do thanks to the property.\n\nis commonly used to create a drop shadow effect behind an element, like in the example below.\n\nHow does that help us with creating the straight-edged pixel art? By removing the blur & spread parameters from the definition, we can straighten out the sides of the shadow.\n\nNext, we want to move the shadow so it is beside the block instead of being behind it. We can do this by adjusting the X- & Y-offset parameters according to the rules below.\n\nShadows inherit their dimensions from the element they're applied to. To move the shadow to the right of the block, we need to set the X-offset to be the same as the width of the block: . If we change the Y-offset to , the result looks like if we had two blocks sitting side-by-side.\n\nIt's starting to look like pixel art! But this only gives us two \"pixels\", and we're going to need a lot more than that. Thankfully, the property isn't limited to just one effect. By separating our effects with a comma, we can create multiple pixel-looking shadows.\n\nNow that we know how we can use , it's time to start making a real piece of pixel art.\n\nWe're going to be creating a pixel version of Pusheen. If you're new to making pixel art, I recommend searching for existing art so you have a reference for where your pixels should be placed. I'm going to be recreating this version of pixel Pusheen.\n\nIt is made up of 414 pixels (23 columns x 18 rows). To help me easily identify the individual pixels, I've used Photoshop to overlay a grid on the reference image.\n\nAlthough you could start drawing your pixel from anywhere, I'm going to start in the uppermost left corner so I don't have to worry about any negative offsets in my effects.\n\nI'm also going to use SASS instead of vanilla CSS to avoid writing 414 declarations by hand. By utilizing a custom SASS function and lists, we can automate calculating the offset positions and make our code more DRY.\n\nFirst, Iâ€™m going to make some modifications to our block. Instead of applying the to the block itself, Iâ€™m going to apply it to a pseudo element instead that is absolutely positioned relative to the block. Why? Because doesnâ€™t take up space, meaning if I were to put another element next to my cat block, it would sit on top of my shadows. If we make the size of the cat block the final size of our pixel art, we can avoid this problem, but we need the pseudo element to separately define the width/height of our pixels (remember, the size of the shadow is inherited from the element the box-shadow is applied to). This is what those changes look like:\n\n\n\nNext, letâ€™s set up some variables.\n\n\n\nNow weâ€™re going to create a list to track what color each pixel should be. Starting on the left, letâ€™s create a list for the first row.\n\n\n\nWe could create new variables for each of the subsequent rows ( , , etc.), but a better approach is to create a nested list, like so:\n\n\n\nThe nested list approach has the benefit of providing us with all the information we need to generate our effect for each of the cell: the X/Y positions to calculate our offset and the color of the shadow. We'll access that information with a custom \"pixelize\" function.\n\nOur \"pixelize\" function is going to do the heavy-lifting of turning our list of colors into usable definitions. I've provided line-by-line explanations of what this function does below.\nâ€¢ Line 1: The function takes two arguments: the list of and the that the pixels should be\nâ€¢ Line 2: Initializes our variable as a string. This is the variable the function will modify and return.\nâ€¢ Line 3: Returns the number of rows in the list using the built-in function\nâ€¢ Line 5: Starts a loop that iterates X times, where X is the number of rows in our list. The will increment by 1 on each loop.\nâ€¢ Line 6: Calculates the Y-offset of all cells in that row. SASS Lists are index-1 (not index-0), so we subtract 1 from the current index so the 1st row has a Y-offset of 0, 2nd has Y-offset of 1, etc.\nâ€¢ Lines 7 & 8: Returns the value of the current list item (the list of colors for the row) & calculates its length to determine the number of columns in the row\nâ€¢ Line 10: Starts a loop to iterate over each column in the row\nâ€¢ Line 11 & 12: Calculates the X-offset of that cell & returns the corresponding color\nâ€¢ Lines 14-17: Sets the separator for the effects, but removes it for the first cell to ensure a valid property value.\nâ€¢ Line 19: Updates the value to its existing value plus the new cell:\nâ€¢ Line 23 & 24: is a string, so we use the function to remove the containing quotes. Finally, return the result.\n\nPut it all together, and here is our final Pusheen pixel!\n\nPretty neat! With a little refactoring, the use of CSS Variables, & a smidge of JavaScript, we could even allow users to select their own colors for their cats.\n\nI hope this post has inspired you to make your own pixel art. Even if it hasn't, I hope you've learned how you can use the property to create some neat effects in your projects. If you're interested in seeing more pixel art, including examples of how to animate them, check out \"Fun Times with CSS Pixel Art\" by Geoff Graham on CSS-Tricks."
    },
    {
        "link": "https://stackoverflow.com/questions/31951282/why-is-marquee-deprecated-and-what-are-the-alternatives",
        "document": "You can find in MDN specification:\n\nObsolete This feature is obsolete. Although it may still work in some browsers, its use is discouraged since it could be removed at any time. Try to avoid using it.\n\nI searched several articles and found some mention about CSS relevant replacement. CSS attributes like:\n\nbut it seems, they don't work. They were a part of specification in year 2008, but they were excluded in year 2014\n\nOne way, proposed by W3 Consortium, is using CSS3 animations, but it seems for me much more complicated than easy-to-maintain .\n\nThere are also plenty of JS alternatives, with lots of source code that you can add to your projects and make them larger.\n\nI'm always reading things as: \"don't ever use marquee\", \"is obsolete\". And I don't get why.\n\nSo, can anybody explain to me, why is marquee deprecated, why is so \"dangerous\" using it and what can I use instead?\n\nI found an example, it looks nice. When you use all prefixes needed for good browser support, you have around 20-25 lines of CSS, with 2 values hardcoded (start and stop indent), depending on text length. This solution is not so flexible, and you can't create bottom-to-top effect with this."
    },
    {
        "link": "https://medium.com/@araltasher/create-pixel-art-using-css-part-2-2be8275ed73d",
        "document": "Weâ€™ll be using SCSS for styling so youâ€™ll need to compile your SCSS to a CSS file once youâ€™re done, or if youâ€™re following this on CodePen, just make sure to set your pre-processor to SCSS.\n\nAs starters, letâ€™s create our HTML mark up:\n\nThe is the container for our art, and the will be where our pixel art will live. The reason why Iâ€™m wrapping the pixel art around a container is purely personal preference; that way I can center the whole image with a simple trick.\n\nNow letâ€™s move on to our file. Weâ€™ll start by creating a color map for our art; these will be all of the colors that we will use to draw our heart, and for this example weâ€™ll only use red and transparent colors:\n\nFeel free to pick whatever color youâ€™d like, but make sure to include the transparent as a color, as weâ€™ll need that for the empty pixels.\n\nBefore we move on to creating our pixel art, letâ€™s style our container, so that we have a nice background color and the art is positioned right in the center of the page once we are done.\n\nNow that thatâ€™s out of the way, letâ€™s decide how big each pixel should look like, and then get on to creating our pixel matrix. The pixel matrix is essentially a 1-to-1 mapping of our art in matrix form. So if you recall our coordinate map from the previous tutorial, weâ€™ll basically create that in matrix form.\n\nFor every pixel thatâ€™s blank, weâ€™ll use , and for every red pixel we'll use from our color map.\n\nThe affects how big each pixel will be displayed on the screen. The reason why we set a variable for the size is because we will need to reference this size later on for multiple calculations. Moreover, keeping the size as a variable will allow us to change the size of our final-pixel art dynamically!\n\nIn the end, your heart matrix should look like above. If you look close, you can see that the â€™s are in the shape of our pixel-heart.\n\nThe Algorithm for Drawing the Pixel Art\n\nTo draw the pixel art, weâ€™ll be taking advantage of some powerful attributes of SCSS and create some functions. The function will take in our matrix and the variable we defined earlier --which is 20px, and draw the image.\n\nWeâ€™ll draw the image by simply going through each row in our matrix one by one, and append the colors from the map as a property. In order to do this, we take advantage of for-loops and use 2 nested loops to iterate through the rows, and each individual cell.\n\nThe outer loop will go through each row, whereas the inner loop will iterate through each cell in that row. As we hit each cell on the inner loop. Hereâ€™s a little animation I created to explain the process visually:\n\n// Read matrix and pixelize\n\n@function pixelize($matrix, $size) {\n\n // Empty string to append all the drop-shadow properties\n\n $sh: '';\n\n \n\n // We'll use the length of our matrix to determine how many rows we need to loop through\n\n // In this case, if we look at our pixel-heart matrix, we can see that \n\n // we have 6 rows for our heart\n\n $rows: length($matrix);\n\n\n\n // The outer for-loop will iterate through each row\n\n @for $row from 1 through $rows {\n\n $row-num: nth($matrix, $row);\n\n @for $col from 1 through length($row-num) {\n\n $dot: nth($row-num, $col);\n\n\n\n // Append the shadow-property for each cell\n\n // So for cell 1, 3 our drop shadow propery will be\n\n // 1x20 and 3x20px with the color #F1A9A0\n\n // Eg: \"20px 60px #F1A9A0\"\n\n $sh: $sh + ($size*$col) + ' ' + ($size*$row) + ' ' + map-get($colors, $dot);\n\n \n\n // Add a comma after each drop-shadow except the last one\n\n @if not ($col==length($row-num) and $row==$rows) {\n\n $sh: $sh + ',';\n\n }\n\n }\n\n }\n\n\n\n // We have to unquote our final list\n\n // so that it's not a string when the CSS is applied\n\n @return unquote($sh);\n\n}\n\nSo we wrote a small algorithm to loop through a given matrix â€” which is the mapping of our art, and a size to draw the pixel-art. Now letâ€™s style our art container, and apply this algorithm so that we can finally see our art on the page.\n\nLetâ€™s go back to our styling and add the for our art. is nested in the code since, on our HTML, the heart is a child of our container.\n\nOur art wonâ€™t display until we give it a height and width, so we use our matrix size to decide how tall and wide our art is going to be. So for our height, we use the length of the rows multiplied by the pixel size, which is 6*20px, and for the row, we pick the length of our first row, multiplied by the pixel size 9*20px .\n\nAfter calculating the height and width, we attach the box-shadow property by calling our function and passing on the matrix, and the predefined value on the pseudo-element.\n\nThis was a decently long and complex tutorial, and it might look like a lot of work to draw a simple heart. But once you understand the full code, you can draw a lot more complex images 10x faster than with pure CSS.\n\nI hope you guys enjoyed this tutorial, and I canâ€™t wait to see what kind of Pixel Art youâ€™ll create with what youâ€™ve learned here! If you do draw anything by following this tutorial make sure to use #araltasher on your Instagram posts, and Iâ€™ll make sure to check them out. Again all of the sample code is available on my CodePen .\n\nMake sure to check out my Darth Vader art if you donâ€™t believe me!"
    },
    {
        "link": "https://stackoverflow.com/questions/48786213/bootstrap-4-make-a-responsive-pixelart-div",
        "document": "I'm quite a beginner in Bootstrap 4, I've read the documentation carefully but I struggle since a while to make my project utterly responsive.\n\nSo my problem here is that I want my DIV, which contains all my colored squares, to keep its initial place on the page instead of disappearing when the screen is too small. I think it's partially responsive, but I have the feeling I'm missing something.\n\nCould you please give me a hint or explain me where's my mistake?"
    }
]