[
    {
        "link": "https://docs.python.org/3/library/re.html",
        "document": "This module provides regular expression matching operations similar to those found in Perl.\n\nBoth patterns and strings to be searched can be Unicode strings ( ) as well as 8-bit strings ( ). However, Unicode strings and 8-bit strings cannot be mixed: that is, you cannot match a Unicode string with a bytes pattern or vice-versa; similarly, when asking for a substitution, the replacement string must be of the same type as both the pattern and the search string.\n\nRegular expressions use the backslash character ( ) to indicate special forms or to allow special characters to be used without invoking their special meaning. This collides with Python’s usage of the same character for the same purpose in string literals; for example, to match a literal backslash, one might have to write as the pattern string, because the regular expression must be , and each backslash must be expressed as inside a regular Python string literal. Also, please note that any invalid escape sequences in Python’s usage of the backslash in string literals now generate a and in the future this will become a . This behaviour will happen even if it is a valid escape sequence for a regular expression.\n\nThe solution is to use Python’s raw string notation for regular expression patterns; backslashes are not handled in any special way in a string literal prefixed with . So is a two-character string containing and , while is a one-character string containing a newline. Usually patterns will be expressed in Python code using this raw string notation.\n\nIt is important to note that most regular expression operations are available as module-level functions and methods on compiled regular expressions. The functions are shortcuts that don’t require you to compile a regex object first, but miss some fine-tuning parameters.\n\nA regular expression (or RE) specifies a set of strings that matches it; the functions in this module let you check if a particular string matches a given regular expression (or if a given regular expression matches a particular string, which comes down to the same thing). Regular expressions can be concatenated to form new regular expressions; if A and B are both regular expressions, then AB is also a regular expression. In general, if a string p matches A and another string q matches B, the string pq will match AB. This holds unless A or B contain low precedence operations; boundary conditions between A and B; or have numbered group references. Thus, complex expressions can easily be constructed from simpler primitive expressions like the ones described here. For details of the theory and implementation of regular expressions, consult the Friedl book [Frie09], or almost any textbook about compiler construction. A brief explanation of the format of regular expressions follows. For further information and a gentler presentation, consult the Regular Expression HOWTO. Regular expressions can contain both special and ordinary characters. Most ordinary characters, like , , or , are the simplest regular expressions; they simply match themselves. You can concatenate ordinary characters, so matches the string . (In the rest of this section, we’ll write RE’s in , usually without quotes, and strings to be matched .) Some characters, like or , are special. Special characters either stand for classes of ordinary characters, or affect how the regular expressions around them are interpreted. Repetition operators or quantifiers ( , , , , etc) cannot be directly nested. This avoids ambiguity with the non-greedy modifier suffix , and with other modifiers in other implementations. To apply a second repetition to an inner repetition, parentheses may be used. For example, the expression matches any multiple of six characters. (Dot.) In the default mode, this matches any character except a newline. If the flag has been specified, this matches any character including a newline. matches any character regardless of flags. (Caret.) Matches the start of the string, and in mode also matches immediately after each newline. Matches the end of the string or just before the newline at the end of the string, and in mode also matches before a newline. matches both ‘foo’ and ‘foobar’, while the regular expression matches only ‘foo’. More interestingly, searching for in matches ‘foo2’ normally, but ‘foo1’ in mode; searching for a single in will find two (empty) matches: one just before the newline, and one at the end of the string. Causes the resulting RE to match 0 or more repetitions of the preceding RE, as many repetitions as are possible. will match ‘a’, ‘ab’, or ‘a’ followed by any number of ‘b’s. Causes the resulting RE to match 1 or more repetitions of the preceding RE. will match ‘a’ followed by any non-zero number of ‘b’s; it will not match just ‘a’. Causes the resulting RE to match 0 or 1 repetitions of the preceding RE. will match either ‘a’ or ‘ab’. The , , and quantifiers are all greedy; they match as much text as possible. Sometimes this behaviour isn’t desired; if the RE is matched against , it will match the entire string, and not just . Adding after the quantifier makes it perform the match in non-greedy or minimal fashion; as few characters as possible will be matched. Using the RE will match only . Like the , , and quantifiers, those where is appended also match as many times as possible. However, unlike the true greedy quantifiers, these do not allow back-tracking when the expression following it fails to match. These are known as possessive quantifiers. For example, will match because the will match all 4 s, but, when the final is encountered, the expression is backtracked so that in the end the ends up matching 3 s total, and the fourth is matched by the final . However, when is used to match , the will match all 4 , but when the final fails to find any more characters to match, the expression cannot be backtracked and will thus fail to match. , and are equivalent to , and correspondingly. Specifies that exactly m copies of the previous RE should be matched; fewer matches cause the entire RE not to match. For example, will match exactly six characters, but not five. Causes the resulting RE to match from m to n repetitions of the preceding RE, attempting to match as many repetitions as possible. For example, will match from 3 to 5 characters. Omitting m specifies a lower bound of zero, and omitting n specifies an infinite upper bound. As an example, will match or a thousand characters followed by a , but not . The comma may not be omitted or the modifier would be confused with the previously described form. Causes the resulting RE to match from m to n repetitions of the preceding RE, attempting to match as few repetitions as possible. This is the non-greedy version of the previous quantifier. For example, on the 6-character string , will match 5 characters, while will only match 3 characters. Causes the resulting RE to match from m to n repetitions of the preceding RE, attempting to match as many repetitions as possible without establishing any backtracking points. This is the possessive version of the quantifier above. For example, on the 6-character string , attempt to match 5 characters, then, requiring 2 more s, will need more characters than available and thus fail, while will match with capturing 5, then 4 s by backtracking and then the final 2 s are matched by the final in the pattern. is equivalent to . Either escapes special characters (permitting you to match characters like , , and so forth), or signals a special sequence; special sequences are discussed below. If you’re not using a raw string to express the pattern, remember that Python also uses the backslash as an escape sequence in string literals; if the escape sequence isn’t recognized by Python’s parser, the backslash and subsequent character are included in the resulting string. However, if Python would recognize the resulting sequence, the backslash should be repeated twice. This is complicated and hard to understand, so it’s highly recommended that you use raw strings for all but the simplest expressions. Used to indicate a set of characters. In a set:\n• None Characters can be listed individually, e.g. will match , , or .\n• None Ranges of characters can be indicated by giving two characters and separating them by a , for example will match any lowercase ASCII letter, will match all the two-digits numbers from to , and will match any hexadecimal digit. If is escaped (e.g. ) or if it’s placed as the first or last character (e.g. or ), it will match a literal .\n• None Special characters lose their special meaning inside sets. For example, will match any of the literal characters , , , or .\n• None Character classes such as or (defined below) are also accepted inside a set, although the characters they match depend on the flags used.\n• None Characters that are not within a range can be matched by complementing the set. If the first character of the set is , all the characters that are not in the set will be matched. For example, will match any character except , and will match any character except . has no special meaning if it’s not the first character in the set.\n• None To match a literal inside a set, precede it with a backslash, or place it at the beginning of the set. For example, both and will match a right bracket, as well as left bracket, braces, and parentheses.\n• None Support of nested sets and set operations as in Unicode Technical Standard #18 might be added in the future. This would change the syntax, so to facilitate this change a will be raised in ambiguous cases for the time being. That includes sets starting with a literal or containing literal character sequences , , , and . To avoid a warning escape them with a backslash. Changed in version 3.7: is raised if a character set contains constructs that will change semantically in the future. , where A and B can be arbitrary REs, creates a regular expression that will match either A or B. An arbitrary number of REs can be separated by the in this way. This can be used inside groups (see below) as well. As the target string is scanned, REs separated by are tried from left to right. When one pattern completely matches, that branch is accepted. This means that once A matches, B will not be tested further, even if it would produce a longer overall match. In other words, the operator is never greedy. To match a literal , use , or enclose it inside a character class, as in . Matches whatever regular expression is inside the parentheses, and indicates the start and end of a group; the contents of a group can be retrieved after a match has been performed, and can be matched later in the string with the special sequence, described below. To match the literals or , use or , or enclose them inside a character class: , . This is an extension notation (a following a is not meaningful otherwise). The first character after the determines what the meaning and further syntax of the construct is. Extensions usually do not create a new group; is the only exception to this rule. Following are the currently supported extensions. (One or more letters from the set , , , , , , .) The group matches the empty string; the letters set the corresponding flags for the entire regular expression: (The flags are described in Module Contents.) This is useful if you wish to include the flags as part of the regular expression, instead of passing a flag argument to the function. Flags should be used first in the expression string. Changed in version 3.11: This construction can only be used at the start of the expression. A non-capturing version of regular parentheses. Matches whatever regular expression is inside the parentheses, but the substring matched by the group cannot be retrieved after performing a match or referenced later in the pattern. (Zero or more letters from the set , , , , , , , optionally followed by followed by one or more letters from the , , , .) The letters set or remove the corresponding flags for the part of the expression: The letters , and are mutually exclusive when used as inline flags, so they can’t be combined or follow . Instead, when one of them appears in an inline group, it overrides the matching mode in the enclosing group. In Unicode patterns switches to ASCII-only matching, and switches to Unicode matching (default). In bytes patterns switches to locale dependent matching, and switches to ASCII-only matching (default). This override is only in effect for the narrow inline group, and the original matching mode is restored outside of the group. Changed in version 3.7: The letters , and also can be used in a group. Attempts to match as if it was a separate regular expression, and if successful, continues to match the rest of the pattern following it. If the subsequent pattern fails to match, the stack can only be unwound to a point before the because once exited, the expression, known as an atomic group, has thrown away all stack points within itself. Thus, would never match anything because first the would match all characters possible, then, having nothing left to match, the final would fail to match. Since there are no stack points saved in the Atomic Group, and there is no stack point before it, the entire expression would thus fail to match. Similar to regular parentheses, but the substring matched by the group is accessible via the symbolic group name name. Group names must be valid Python identifiers, and in patterns they can only contain bytes in the ASCII range. Each group name must be defined only once within a regular expression. A symbolic group is also a numbered group, just as if the group were not named. Named groups can be referenced in three contexts. If the pattern is (i.e. matching a string quoted with either single or double quotes): in the same pattern itself in a string passed to the repl argument of Changed in version 3.12: In patterns, group name can only contain bytes in the ASCII range ( - ). A backreference to a named group; it matches whatever text was matched by the earlier group named name. A comment; the contents of the parentheses are simply ignored. Matches if matches next, but doesn’t consume any of the string. This is called a lookahead assertion. For example, will match only if it’s followed by . Matches if doesn’t match next. This is a negative lookahead assertion. For example, will match only if it’s not followed by . Matches if the current position in the string is preceded by a match for that ends at the current position. This is called a positive lookbehind assertion. will find a match in , since the lookbehind will back up 3 characters and check if the contained pattern matches. The contained pattern must only match strings of some fixed length, meaning that or are allowed, but and are not. Note that patterns which start with positive lookbehind assertions will not match at the beginning of the string being searched; you will most likely want to use the function rather than the function: This example looks for a word following a hyphen: Changed in version 3.5: Added support for group references of fixed length. Matches if the current position in the string is not preceded by a match for . This is called a negative lookbehind assertion. Similar to positive lookbehind assertions, the contained pattern must only match strings of some fixed length. Patterns which start with negative lookbehind assertions may match at the beginning of the string being searched. Will try to match with if the group with given id or name exists, and with if it doesn’t. is optional and can be omitted. For example, is a poor email matching pattern, which will match with as well as , but not with nor . Changed in version 3.12: Group id can only contain ASCII digits. In patterns, group name can only contain bytes in the ASCII range ( - ). The special sequences consist of and a character from the list below. If the ordinary character is not an ASCII digit or an ASCII letter, then the resulting RE will match the second character. For example, matches the character . Matches the contents of the group of the same number. Groups are numbered starting from 1. For example, matches or , but not (note the space after the group). This special sequence can only be used to match one of the first 99 groups. If the first digit of number is 0, or number is 3 octal digits long, it will not be interpreted as a group match, but as the character with octal value number. Inside the and of a character class, all numeric escapes are treated as characters. Matches only at the start of the string. Matches the empty string, but only at the beginning or end of a word. A word is defined as a sequence of word characters. Note that formally, is defined as the boundary between a and a character (or vice versa), or between and the beginning or end of the string. This means that matches , , , and but not or . The default word characters in Unicode (str) patterns are Unicode alphanumerics and the underscore, but this can be changed by using the flag. Word boundaries are determined by the current locale if the flag is used. Inside a character range, represents the backspace character, for compatibility with Python’s string literals. Matches the empty string, but only when it is not at the beginning or end of a word. This means that matches , , , but not , , or . is the opposite of , so word characters in Unicode (str) patterns are Unicode alphanumerics or the underscore, although this can be changed by using the flag. Word boundaries are determined by the current locale if the flag is used. Note that does not match an empty string, which differs from RE implementations in other programming languages such as Perl. This behavior is kept for compatibility reasons. Matches any Unicode decimal digit (that is, any character in Unicode character category [Nd]). This includes , and also many other digit characters. Matches if the flag is used. Matches any decimal digit in the ASCII character set; this is equivalent to . Matches any character which is not a decimal digit. This is the opposite of . Matches if the flag is used. Matches Unicode whitespace characters (as defined by ). This includes , and also many other characters, for example the non-breaking spaces mandated by typography rules in many languages. Matches if the flag is used. Matches characters considered whitespace in the ASCII character set; this is equivalent to . Matches any character which is not a whitespace character. This is the opposite of . Matches if the flag is used. Matches Unicode word characters; this includes all Unicode alphanumeric characters (as defined by ), as well as the underscore ( ). Matches if the flag is used. Matches characters considered alphanumeric in the ASCII character set; this is equivalent to . If the flag is used, matches characters considered alphanumeric in the current locale and the underscore. Matches any character which is not a word character. This is the opposite of . By default, matches non-underscore ( ) characters for which returns . Matches if the flag is used. If the flag is used, matches characters which are neither alphanumeric in the current locale nor the underscore. Matches only at the end of the string. Most of the escape sequences supported by Python string literals are also accepted by the regular expression parser: , , and escape sequences are only recognized in Unicode (str) patterns. In bytes patterns they are errors. Unknown escapes of ASCII letters are reserved for future use and treated as errors. Octal escapes are included in a limited form. If the first digit is a 0, or if there are three octal digits, it is considered an octal escape. Otherwise, it is a group reference. As for string literals, octal escapes are always at most three digits in length. Changed in version 3.3: The and escape sequences have been added. Changed in version 3.6: Unknown escapes consisting of and an ASCII letter now are errors. Changed in version 3.8: The escape sequence has been added. As in string literals, it expands to the named Unicode character (e.g. ).\n\nThe module defines several functions, constants, and an exception. Some of the functions are simplified versions of the full featured methods for compiled regular expressions. Most non-trivial applications always use the compiled form. Changed in version 3.6: Flag constants are now instances of , which is a subclass of . An class containing the regex options listed below. Make , , , , , , and perform ASCII-only matching instead of full Unicode matching. This is only meaningful for Unicode (str) patterns, and is ignored for bytes patterns. The flag still exists for backward compatibility, but is redundant in Python 3 since matches are Unicode by default for patterns, and Unicode matching isn’t allowed for bytes patterns. and the inline flag are similarly redundant. Perform case-insensitive matching; expressions like will also match lowercase letters. Full Unicode matching (such as matching ) also works unless the flag is used to disable non-ASCII matches. The current locale does not change the effect of this flag unless the flag is also used. Note that when the Unicode patterns or are used in combination with the flag, they will match the 52 ASCII letters and 4 additional non-ASCII letters: ‘İ’ (U+0130, Latin capital letter I with dot above), ‘ı’ (U+0131, Latin small letter dotless i), ‘ſ’ (U+017F, Latin small letter long s) and ‘K’ (U+212A, Kelvin sign). If the flag is used, only letters ‘a’ to ‘z’ and ‘A’ to ‘Z’ are matched. Make , , , and case-insensitive matching dependent on the current locale. This flag can be used only with bytes patterns. This flag is discouraged; consider Unicode matching instead. The locale mechanism is very unreliable as it only handles one “culture” at a time and only works with 8-bit locales. Unicode matching is enabled by default for Unicode (str) patterns and it is able to handle different locales and languages. Changed in version 3.6: can be used only with bytes patterns and is not compatible with . Changed in version 3.7: Compiled regular expression objects with the flag no longer depend on the locale at compile time. Only the locale at matching time affects the result of matching. When specified, the pattern character matches at the beginning of the string and at the beginning of each line (immediately following each newline); and the pattern character matches at the end of the string and at the end of each line (immediately preceding each newline). By default, matches only at the beginning of the string, and only at the end of the string and immediately before the newline (if any) at the end of the string. Indicates no flag being applied, the value is . This flag may be used as a default value for a function keyword argument or as a base value that will be conditionally ORed with other flags. Example of use as a default value: Make the special character match any character at all, including a newline; without this flag, will match anything except a newline. In Python 3, Unicode characters are matched by default for patterns. This flag is therefore redundant with no effect and is only kept for backward compatibility. See to restrict matching to ASCII characters instead. This flag allows you to write regular expressions that look nicer and are more readable by allowing you to visually separate logical sections of the pattern and add comments. Whitespace within the pattern is ignored, except when in a character class, or when preceded by an unescaped backslash, or within tokens like , or . For example, and are not allowed. When a line contains a that is not in a character class and is not preceded by an unescaped backslash, all characters from the leftmost such through the end of the line are ignored. This means that the two following regular expression objects that match a decimal number are functionally equal: Compile a regular expression pattern into a regular expression object, which can be used for matching using its , and other methods, described below. The expression’s behaviour can be modified by specifying a flags value. Values can be any of the flags variables, combined using bitwise OR (the operator). but using and saving the resulting regular expression object for reuse is more efficient when the expression will be used several times in a single program. The compiled versions of the most recent patterns passed to and the module-level matching functions are cached, so programs that use only a few regular expressions at a time needn’t worry about compiling regular expressions. Scan through string looking for the first location where the regular expression pattern produces a match, and return a corresponding . Return if no position in the string matches the pattern; note that this is different from finding a zero-length match at some point in the string. The expression’s behaviour can be modified by specifying a flags value. Values can be any of the flags variables, combined using bitwise OR (the operator). If zero or more characters at the beginning of string match the regular expression pattern, return a corresponding . Return if the string does not match the pattern; note that this is different from a zero-length match. Note that even in mode, will only match at the beginning of the string and not at the beginning of each line. If you want to locate a match anywhere in string, use instead (see also search() vs. match()). The expression’s behaviour can be modified by specifying a flags value. Values can be any of the flags variables, combined using bitwise OR (the operator). If the whole string matches the regular expression pattern, return a corresponding . Return if the string does not match the pattern; note that this is different from a zero-length match. The expression’s behaviour can be modified by specifying a flags value. Values can be any of the flags variables, combined using bitwise OR (the operator). Split string by the occurrences of pattern. If capturing parentheses are used in pattern, then the text of all groups in the pattern are also returned as part of the resulting list. If maxsplit is nonzero, at most maxsplit splits occur, and the remainder of the string is returned as the final element of the list. If there are capturing groups in the separator and it matches at the start of the string, the result will start with an empty string. The same holds for the end of the string: That way, separator components are always found at the same relative indices within the result list. Empty matches for the pattern split the string only when not adjacent to a previous empty match. The expression’s behaviour can be modified by specifying a flags value. Values can be any of the flags variables, combined using bitwise OR (the operator). Changed in version 3.7: Added support of splitting on a pattern that could match an empty string. Deprecated since version 3.13: Passing maxsplit and flags as positional arguments is deprecated. In future Python versions they will be keyword-only parameters. Return all non-overlapping matches of pattern in string, as a list of strings or tuples. The string is scanned left-to-right, and matches are returned in the order found. Empty matches are included in the result. The result depends on the number of capturing groups in the pattern. If there are no groups, return a list of strings matching the whole pattern. If there is exactly one group, return a list of strings matching that group. If multiple groups are present, return a list of tuples of strings matching the groups. Non-capturing groups do not affect the form of the result. The expression’s behaviour can be modified by specifying a flags value. Values can be any of the flags variables, combined using bitwise OR (the operator). Changed in version 3.7: Non-empty matches can now start just after a previous empty match. Return an iterator yielding objects over all non-overlapping matches for the RE pattern in string. The string is scanned left-to-right, and matches are returned in the order found. Empty matches are included in the result. The expression’s behaviour can be modified by specifying a flags value. Values can be any of the flags variables, combined using bitwise OR (the operator). Changed in version 3.7: Non-empty matches can now start just after a previous empty match. Return the string obtained by replacing the leftmost non-overlapping occurrences of pattern in string by the replacement repl. If the pattern isn’t found, string is returned unchanged. repl can be a string or a function; if it is a string, any backslash escapes in it are processed. That is, is converted to a single newline character, is converted to a carriage return, and so forth. Unknown escapes of ASCII letters are reserved for future use and treated as errors. Other unknown escapes such as are left alone. Backreferences, such as , are replaced with the substring matched by group 6 in the pattern. For example: If repl is a function, it is called for every non-overlapping occurrence of pattern. The function takes a single argument, and returns the replacement string. For example: The pattern may be a string or a . The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. If omitted or zero, all occurrences will be replaced. Empty matches for the pattern are replaced only when not adjacent to a previous empty match, so returns . In string-type repl arguments, in addition to the character escapes and backreferences described above, will use the substring matched by the group named , as defined by the syntax. uses the corresponding group number; is therefore equivalent to , but isn’t ambiguous in a replacement such as . would be interpreted as a reference to group 20, not a reference to group 2 followed by the literal character . The backreference substitutes in the entire substring matched by the RE. The expression’s behaviour can be modified by specifying a flags value. Values can be any of the flags variables, combined using bitwise OR (the operator). Changed in version 3.5: Unmatched groups are replaced with an empty string. Changed in version 3.6: Unknown escapes in pattern consisting of and an ASCII letter now are errors. Changed in version 3.7: Unknown escapes in repl consisting of and an ASCII letter now are errors. Empty matches for the pattern are replaced when adjacent to a previous non-empty match. Changed in version 3.12: Group id can only contain ASCII digits. In replacement strings, group name can only contain bytes in the ASCII range ( - ). Deprecated since version 3.13: Passing count and flags as positional arguments is deprecated. In future Python versions they will be keyword-only parameters. Perform the same operation as , but return a tuple . The expression’s behaviour can be modified by specifying a flags value. Values can be any of the flags variables, combined using bitwise OR (the operator). Escape special characters in pattern. This is useful if you want to match an arbitrary literal string that may have regular expression metacharacters in it. For example: This function must not be used for the replacement string in and , only backslashes should be escaped. For example: Changed in version 3.3: The character is no longer escaped. Changed in version 3.7: Only characters that can have special meaning in a regular expression are escaped. As a result, , , , , , , , , , , , , and are no longer escaped. Exception raised when a string passed to one of the functions here is not a valid regular expression (for example, it might contain unmatched parentheses) or when some other error occurs during compilation or matching. It is never an error if a string contains no match for a pattern. The instance has the following additional attributes: The index in pattern where compilation failed (may be ). The line corresponding to pos (may be ). The column corresponding to pos (may be ). Changed in version 3.13: was originally named ; the latter is kept as an alias for backward compatibility.\n\nMatch objects always have a boolean value of . Since and return when there is no match, you can test whether there was a match with a simple statement: Changed in version 3.9: supports to indicate a Unicode (str) or bytes match. See Generic Alias Type. Return the string obtained by doing backslash substitution on the template string template, as done by the method. Escapes such as are converted to the appropriate characters, and numeric backreferences ( , ) and named backreferences ( , ) are replaced by the contents of the corresponding group. The backreference will be replaced by the entire match. Changed in version 3.5: Unmatched groups are replaced with an empty string. Returns one or more subgroups of the match. If there is a single argument, the result is a single string; if there are multiple arguments, the result is a tuple with one item per argument. Without arguments, group1 defaults to zero (the whole match is returned). If a groupN argument is zero, the corresponding return value is the entire matching string; if it is in the inclusive range [1..99], it is the string matching the corresponding parenthesized group. If a group number is negative or larger than the number of groups defined in the pattern, an exception is raised. If a group is contained in a part of the pattern that did not match, the corresponding result is . If a group is contained in a part of the pattern that matched multiple times, the last match is returned. If the regular expression uses the syntax, the groupN arguments may also be strings identifying groups by their group name. If a string argument is not used as a group name in the pattern, an exception is raised. Named groups can also be referred to by their index: If a group matches multiple times, only the last match is accessible: # Returns only the last match. This is identical to . This allows easier access to an individual group from a match: Named groups are supported as well: Return a tuple containing all the subgroups of the match, from 1 up to however many groups are in the pattern. The default argument is used for groups that did not participate in the match; it defaults to . If we make the decimal place and everything after it optional, not all groups might participate in the match. These groups will default to unless the default argument is given: # Second group defaults to None. # Now, the second group defaults to '0'. Return a dictionary containing all the named subgroups of the match, keyed by the subgroup name. The default argument is used for groups that did not participate in the match; it defaults to . For example: Return the indices of the start and end of the substring matched by group; group defaults to zero (meaning the whole matched substring). Return if group exists but did not contribute to the match. For a match object m, and a group g that did contribute to the match, the substring matched by group g (equivalent to ) is Note that will equal if group matched a null string. For example, after , is 1, is 2, and are both 2, and raises an exception. An example that will remove remove_this from email addresses: For a match m, return the 2-tuple . Note that if group did not contribute to the match, this is . group defaults to zero, the entire match. The value of pos which was passed to the or method of a regex object. This is the index into the string at which the RE engine started looking for a match. The value of endpos which was passed to the or method of a regex object. This is the index into the string beyond which the RE engine will not go. The integer index of the last matched capturing group, or if no group was matched at all. For example, the expressions , , and will have if applied to the string , while the expression will have , if applied to the same string. The name of the last matched capturing group, or if the group didn’t have a name, or if no group was matched at all. The regular expression object whose or method produced this match instance. The string passed to or . Changed in version 3.7: Added support of and . Match objects are considered atomic.\n\nIn this example, we’ll use the following helper function to display match objects a little more gracefully: Suppose you are writing a poker program where a player’s hand is represented as a 5-character string with each character representing a card, “a” for ace, “k” for king, “q” for queen, “j” for jack, “t” for 10, and “2” through “9” representing the card with that value. To see if a given string is a valid hand, one could do the following: That last hand, , contained a pair, or two of the same valued cards. To match this with a regular expression, one could use backreferences as such: To find out what card the pair consists of, one could use the method of the match object in the following manner: # Error because re.match() returns None, which doesn't have a group() method: File , line , in : Python does not currently have an equivalent to . Regular expressions are generally more powerful, though also more verbose, than format strings. The table below offers some more-or-less equivalent mappings between format tokens and regular expressions. To extract the filename and numbers from a string like you would use a format like The equivalent regular expression would be\n• None checks for a match only at the beginning of the string\n• None checks for a match anywhere in the string (this is what Perl does by default)\n• None checks for entire string to be a match Regular expressions beginning with can be used with to restrict the match at the beginning of the string: Note however that in mode only matches at the beginning of the string, whereas using with a regular expression beginning with will match at the beginning of each line. splits a string into a list delimited by the passed pattern. The method is invaluable for converting textual data into data structures that can be easily read and modified by Python as demonstrated in the following example that creates a phonebook. First, here is the input. Normally it may come from a file, here we are using triple-quoted string syntax The entries are separated by one or more newlines. Now we convert the string into a list with each nonempty line having its own entry: Finally, split each entry into a list with first name, last name, telephone number, and address. We use the parameter of because the address has spaces, our splitting pattern, in it: The pattern matches the colon after the last name, so that it does not occur in the result list. With a of , we could separate the house number from the street name: replaces every occurrence of a pattern with a string or the result of a function. This example demonstrates using with a function to “munge” text, or randomize the order of all the characters in each word of a sentence except for the first and last characters: matches all occurrences of a pattern, not just the first one as does. For example, if a writer wanted to find all of the adverbs in some text, they might use in the following manner: \"He was carefully disguised but captured quickly by police.\" Finding all Adverbs and their Positions¶ If one wants more information about all matches of a pattern than the matched text, is useful as it provides objects instead of strings. Continuing with the previous example, if a writer wanted to find all of the adverbs and their positions in some text, they would use in the following manner: \"He was carefully disguised but captured quickly by police.\" Raw string notation ( ) keeps regular expressions sane. Without it, every backslash ( ) in a regular expression would have to be prefixed with another one to escape it. For example, the two following lines of code are functionally identical: When one wants to match a literal backslash, it must be escaped in the regular expression. With raw string notation, this means . Without raw string notation, one must use , making the following lines of code functionally identical: A tokenizer or scanner analyzes a string to categorize groups of characters. This is a useful first step in writing a compiler or interpreter. The text categories are specified with regular expressions. The technique is to combine those into a single master regular expression and to loop over successive matches: The tokenizer produces the following output: Friedl, Jeffrey. Mastering Regular Expressions. 3rd ed., O’Reilly Media, 2009. The third edition of the book no longer covers Python at all, but the first edition covered writing good regular expression patterns in great detail."
    },
    {
        "link": "https://docs.python.org/3/howto/regex.html",
        "document": "Regular expressions (called REs, or regexes, or regex patterns) are essentially a tiny, highly specialized programming language embedded inside Python and made available through the module. Using this little language, you specify the rules for the set of possible strings that you want to match; this set might contain English sentences, or e-mail addresses, or TeX commands, or anything you like. You can then ask questions such as “Does this string match the pattern?”, or “Is there a match for the pattern anywhere in this string?”. You can also use REs to modify a string or to split it apart in various ways. Regular expression patterns are compiled into a series of bytecodes which are then executed by a matching engine written in C. For advanced use, it may be necessary to pay careful attention to how the engine will execute a given RE, and write the RE in a certain way in order to produce bytecode that runs faster. Optimization isn’t covered in this document, because it requires that you have a good understanding of the matching engine’s internals. The regular expression language is relatively small and restricted, so not all possible string processing tasks can be done using regular expressions. There are also tasks that can be done with regular expressions, but the expressions turn out to be very complicated. In these cases, you may be better off writing Python code to do the processing; while Python code will be slower than an elaborate regular expression, it will also probably be more understandable.\n\nWe’ll start by learning about the simplest possible regular expressions. Since regular expressions are used to operate on strings, we’ll begin with the most common task: matching characters. For a detailed explanation of the computer science underlying regular expressions (deterministic and non-deterministic finite automata), you can refer to almost any textbook on writing compilers. Most letters and characters will simply match themselves. For example, the regular expression will match the string exactly. (You can enable a case-insensitive mode that would let this RE match or as well; more about this later.) There are exceptions to this rule; some characters are special metacharacters, and don’t match themselves. Instead, they signal that some out-of-the-ordinary thing should be matched, or they affect other portions of the RE by repeating them or changing their meaning. Much of this document is devoted to discussing various metacharacters and what they do. Here’s a complete list of the metacharacters; their meanings will be discussed in the rest of this HOWTO. The first metacharacters we’ll look at are and . They’re used for specifying a character class, which is a set of characters that you wish to match. Characters can be listed individually, or a range of characters can be indicated by giving two characters and separating them by a . For example, will match any of the characters , , or ; this is the same as , which uses a range to express the same set of characters. If you wanted to match only lowercase letters, your RE would be . Metacharacters (except ) are not active inside classes. For example, will match any of the characters , , , or ; is usually a metacharacter, but inside a character class it’s stripped of its special nature. You can match the characters not listed within the class by complementing the set. This is indicated by including a as the first character of the class. For example, will match any character except . If the caret appears elsewhere in a character class, it does not have special meaning. For example: will match either a or a . Perhaps the most important metacharacter is the backslash, . As in Python string literals, the backslash can be followed by various characters to signal various special sequences. It’s also used to escape all the metacharacters so you can still match them in patterns; for example, if you need to match a or , you can precede them with a backslash to remove their special meaning: or . Some of the special sequences beginning with represent predefined sets of characters that are often useful, such as the set of digits, the set of letters, or the set of anything that isn’t whitespace. Let’s take an example: matches any alphanumeric character. If the regex pattern is expressed in bytes, this is equivalent to the class . If the regex pattern is a string, will match all the characters marked as letters in the Unicode database provided by the module. You can use the more restricted definition of in a string pattern by supplying the flag when compiling the regular expression. The following list of special sequences isn’t complete. For a complete list of sequences and expanded class definitions for Unicode string patterns, see the last part of Regular Expression Syntax in the Standard Library reference. In general, the Unicode versions match any character that’s in the appropriate category in the Unicode database. Matches any decimal digit; this is equivalent to the class . Matches any non-digit character; this is equivalent to the class . Matches any whitespace character; this is equivalent to the class . Matches any non-whitespace character; this is equivalent to the class . Matches any alphanumeric character; this is equivalent to the class . Matches any non-alphanumeric character; this is equivalent to the class . These sequences can be included inside a character class. For example, is a character class that will match any whitespace character, or or . The final metacharacter in this section is . It matches anything except a newline character, and there’s an alternate mode ( ) where it will match even a newline. is often used where you want to match “any character”. Being able to match varying sets of characters is the first thing regular expressions can do that isn’t already possible with the methods available on strings. However, if that was the only additional capability of regexes, they wouldn’t be much of an advance. Another capability is that you can specify that portions of the RE must be repeated a certain number of times. The first metacharacter for repeating things that we’ll look at is . doesn’t match the literal character ; instead, it specifies that the previous character can be matched zero or more times, instead of exactly once. For example, will match (0 characters), (1 ), (3 characters), and so forth. Repetitions such as are greedy; when repeating a RE, the matching engine will try to repeat it as many times as possible. If later portions of the pattern don’t match, the matching engine will then back up and try again with fewer repetitions. A step-by-step example will make this more obvious. Let’s consider the expression . This matches the letter , zero or more letters from the class , and finally ends with a . Now imagine matching this RE against the string . The engine matches , going as far as it can, which is to the end of the string. The engine tries to match , but the current position is at the end of the string, so it fails. Back up, so that matches one less character. Try again, but the current position is at the last character, which is a . Back up again, so that is only matching . Try again. This time the character at the current position is , so it succeeds. The end of the RE has now been reached, and it has matched . This demonstrates how the matching engine goes as far as it can at first, and if no match is found it will then progressively back up and retry the rest of the RE again and again. It will back up until it has tried zero matches for , and if that subsequently fails, the engine will conclude that the string doesn’t match the RE at all. Another repeating metacharacter is , which matches one or more times. Pay careful attention to the difference between and ; matches zero or more times, so whatever’s being repeated may not be present at all, while requires at least one occurrence. To use a similar example, will match (1 ), (3 s), but won’t match . There are two more repeating operators or quantifiers. The question mark character, , matches either once or zero times; you can think of it as marking something as being optional. For example, matches either or . The most complicated quantifier is , where m and n are decimal integers. This quantifier means there must be at least m repetitions, and at most n. For example, will match , , and . It won’t match , which has no slashes, or , which has four. You can omit either m or n; in that case, a reasonable value is assumed for the missing value. Omitting m is interpreted as a lower limit of 0, while omitting n results in an upper bound of infinity. The simplest case matches the preceding item exactly m times. For example, will only match . Readers of a reductionist bent may notice that the three other quantifiers can all be expressed using this notation. is the same as , is equivalent to , and is the same as . It’s better to use , , or when you can, simply because they’re shorter and easier to read.\n\nNow that we’ve looked at some simple regular expressions, how do we actually use them in Python? The module provides an interface to the regular expression engine, allowing you to compile REs into objects and then perform matches with them. Regular expressions are compiled into pattern objects, which have methods for various operations such as searching for pattern matches or performing string substitutions. also accepts an optional flags argument, used to enable various special features and syntax variations. We’ll go over the available settings later, but for now a single example will do: The RE is passed to as a string. REs are handled as strings because regular expressions aren’t part of the core Python language, and no special syntax was created for expressing them. (There are applications that don’t need REs at all, so there’s no need to bloat the language specification by including them.) Instead, the module is simply a C extension module included with Python, just like the or modules. Putting REs in strings keeps the Python language simpler, but has one disadvantage which is the topic of the next section. As stated earlier, regular expressions use the backslash character ( ) to indicate special forms or to allow special characters to be used without invoking their special meaning. This conflicts with Python’s usage of the same character for the same purpose in string literals. Let’s say you want to write a RE that matches the string , which might be found in a LaTeX file. To figure out what to write in the program code, start with the desired string to be matched. Next, you must escape any backslashes and other metacharacters by preceding them with a backslash, resulting in the string . The resulting string that must be passed to must be . However, to express this as a Python string literal, both backslashes must be escaped again. In short, to match a literal backslash, one has to write as the RE string, because the regular expression must be , and each backslash must be expressed as inside a regular Python string literal. In REs that feature backslashes repeatedly, this leads to lots of repeated backslashes and makes the resulting strings difficult to understand. The solution is to use Python’s raw string notation for regular expressions; backslashes are not handled in any special way in a string literal prefixed with , so is a two-character string containing and , while is a one-character string containing a newline. Regular expressions will often be written in Python code using this raw string notation. In addition, special escape sequences that are valid in regular expressions, but not valid as Python string literals, now result in a and will eventually become a , which means the sequences will be invalid if raw string notation or escaping the backslashes isn’t used. Once you have an object representing a compiled regular expression, what do you do with it? Pattern objects have several methods and attributes. Only the most significant ones will be covered here; consult the docs for a complete listing. Determine if the RE matches at the beginning of the string. Scan through a string, looking for any location where this RE matches. Find all substrings where the RE matches, and returns them as a list. Find all substrings where the RE matches, and returns them as an iterator. and return if no match can be found. If they’re successful, a match object instance is returned, containing information about the match: where it starts and ends, the substring it matched, and more. You can learn about this by interactively experimenting with the module. This HOWTO uses the standard Python interpreter for its examples. First, run the Python interpreter, import the module, and compile a RE: Now, you can try matching various strings against the RE . An empty string shouldn’t match at all, since means ‘one or more repetitions’. should return in this case, which will cause the interpreter to print no output. You can explicitly print the result of to make this clear. Now, let’s try it on a string that it should match, such as . In this case, will return a match object, so you should store the result in a variable for later use. Now you can query the match object for information about the matching string. Match object instances also have several methods and attributes; the most important ones are: Return the string matched by the RE Return the starting position of the match Return the ending position of the match Return a tuple containing the (start, end) positions of the match Trying these methods will soon clarify their meaning: returns the substring that was matched by the RE. and return the starting and ending index of the match. returns both start and end indexes in a single tuple. Since the method only checks if the RE matches at the start of a string, will always be zero. However, the method of patterns scans through the string, so the match may not start at zero in that case. In actual programs, the most common style is to store the match object in a variable, and then check if it was . This usually looks like: Two pattern methods return all of the matches for a pattern. returns a list of matching strings: The prefix, making the literal a raw string literal, is needed in this example because escape sequences in a normal “cooked” string literal that are not recognized by Python, as opposed to regular expressions, now result in a and will eventually become a . See The Backslash Plague. has to create the entire list before it can be returned as the result. The method returns a sequence of match object instances as an iterator: You don’t have to create a pattern object and call its methods; the module also provides top-level functions called , , , , and so forth. These functions take the same arguments as the corresponding pattern method with the RE string added as the first argument, and still return either or a match object instance. Under the hood, these functions simply create a pattern object for you and call the appropriate method on it. They also store the compiled object in a cache, so future calls using the same RE won’t need to parse the pattern again and again. Should you use these module-level functions, or should you get the pattern and call its methods yourself? If you’re accessing a regex within a loop, pre-compiling it will save a few function calls. Outside of loops, there’s not much difference thanks to the internal cache. Compilation flags let you modify some aspects of how regular expressions work. Flags are available in the module under two names, a long name such as and a short, one-letter form such as . (If you’re familiar with Perl’s pattern modifiers, the one-letter forms use the same letters; the short form of is , for example.) Multiple flags can be specified by bitwise OR-ing them; sets both the and flags, for example. Here’s a table of the available flags, followed by a more detailed explanation of each one. Makes several escapes like , , and match only on ASCII characters with the respective property. Enable verbose REs, which can be organized more cleanly and understandably. Perform case-insensitive matching; character class and literal strings will match letters by ignoring case. For example, will match lowercase letters, too. Full Unicode matching also works unless the flag is used to disable non-ASCII matches. When the Unicode patterns or are used in combination with the flag, they will match the 52 ASCII letters and 4 additional non-ASCII letters: ‘İ’ (U+0130, Latin capital letter I with dot above), ‘ı’ (U+0131, Latin small letter dotless i), ‘ſ’ (U+017F, Latin small letter long s) and ‘K’ (U+212A, Kelvin sign). will match , , , or (the latter is matched only in Unicode mode). This lowercasing doesn’t take the current locale into account; it will if you also set the flag. Make , , , and case-insensitive matching dependent on the current locale instead of the Unicode database. Locales are a feature of the C library intended to help in writing programs that take account of language differences. For example, if you’re processing encoded French text, you’d want to be able to write to match words, but only matches the character class in bytes patterns; it won’t match bytes corresponding to or . If your system is configured properly and a French locale is selected, certain C functions will tell the program that the byte corresponding to should also be considered a letter. Setting the flag when compiling a regular expression will cause the resulting compiled object to use these C functions for ; this is slower, but also enables to match French words as you’d expect. The use of this flag is discouraged in Python 3 as the locale mechanism is very unreliable, it only handles one “culture” at a time, and it only works with 8-bit locales. Unicode matching is already enabled by default in Python 3 for Unicode (str) patterns, and it is able to handle different locales/languages. Usually matches only at the beginning of the string, and matches only at the end of the string and immediately before the newline (if any) at the end of the string. When this flag is specified, matches at the beginning of the string and at the beginning of each line within the string, immediately following each newline. Similarly, the metacharacter matches either at the end of the string and at the end of each line (immediately preceding each newline). Makes the special character match any character at all, including a newline; without this flag, will match anything except a newline. Make , , , , and perform ASCII-only matching instead of full Unicode matching. This is only meaningful for Unicode patterns, and is ignored for byte patterns. This flag allows you to write regular expressions that are more readable by granting you more flexibility in how you can format them. When this flag has been specified, whitespace within the RE string is ignored, except when the whitespace is in a character class or preceded by an unescaped backslash; this lets you organize and indent the RE more clearly. This flag also lets you put comments within a RE that will be ignored by the engine; comments are marked by a that’s neither in a character class or preceded by an unescaped backslash. For example, here’s a RE that uses ; see how much easier it is to read? Without the verbose setting, the RE would look like this: In the above example, Python’s automatic concatenation of string literals has been used to break up the RE into smaller pieces, but it’s still more difficult to understand than the version using .\n\nSo far we’ve only covered a part of the features of regular expressions. In this section, we’ll cover some new metacharacters, and how to use groups to retrieve portions of the text that was matched. There are some metacharacters that we haven’t covered yet. Most of them will be covered in this section. Some of the remaining metacharacters to be discussed are zero-width assertions. They don’t cause the engine to advance through the string; instead, they consume no characters at all, and simply succeed or fail. For example, is an assertion that the current position is located at a word boundary; the position isn’t changed by the at all. This means that zero-width assertions should never be repeated, because if they match once at a given location, they can obviously be matched an infinite number of times. Alternation, or the “or” operator. If A and B are regular expressions, will match any string that matches either A or B. has very low precedence in order to make it work reasonably when you’re alternating multi-character strings. will match either or , not , a or an , and . To match a literal , use , or enclose it inside a character class, as in . Matches at the beginning of lines. Unless the flag has been set, this will only match at the beginning of the string. In mode, this also matches immediately after each newline within the string. For example, if you wish to match the word only at the beginning of a line, the RE to use is . Matches at the end of a line, which is defined as either the end of the string, or any location followed by a newline character. To match a literal , use or enclose it inside a character class, as in . Matches only at the start of the string. When not in mode, and are effectively the same. In mode, they’re different: still matches only at the beginning of the string, but may match at any location inside the string that follows a newline character. Matches only at the end of the string. Word boundary. This is a zero-width assertion that matches only at the beginning or end of a word. A word is defined as a sequence of alphanumeric characters, so the end of a word is indicated by whitespace or a non-alphanumeric character. The following example matches only when it’s a complete word; it won’t match when it’s contained inside another word. There are two subtleties you should remember when using this special sequence. First, this is the worst collision between Python’s string literals and regular expression sequences. In Python’s string literals, is the backspace character, ASCII value 8. If you’re not using raw strings, then Python will convert the to a backspace, and your RE won’t match as you expect it to. The following example looks the same as our previous RE, but omits the in front of the RE string. Second, inside a character class, where there’s no use for this assertion, represents the backspace character, for compatibility with Python’s string literals. Another zero-width assertion, this is the opposite of , only matching when the current position is not at a word boundary. Frequently you need to obtain more information than just whether the RE matched or not. Regular expressions are often used to dissect strings by writing a RE divided into several subgroups which match different components of interest. For example, an RFC-822 header line is divided into a header name and a value, separated by a , like this: This can be handled by writing a regular expression which matches an entire header line, and has one group which matches the header name, and another group which matches the header’s value. Groups are marked by the , metacharacters. and have much the same meaning as they do in mathematical expressions; they group together the expressions contained inside them, and you can repeat the contents of a group with a quantifier, such as , , , or . For example, will match zero or more repetitions of . Groups indicated with , also capture the starting and ending index of the text that they match; this can be retrieved by passing an argument to , , , and . Groups are numbered starting with 0. Group 0 is always present; it’s the whole RE, so match object methods all have group 0 as their default argument. Later we’ll see how to express groups that don’t capture the span of text that they match. Subgroups are numbered from left to right, from 1 upward. Groups can be nested; to determine the number, just count the opening parenthesis characters, going from left to right. can be passed multiple group numbers at a time, in which case it will return a tuple containing the corresponding values for those groups. The method returns a tuple containing the strings for all the subgroups, from 1 up to however many there are. Backreferences in a pattern allow you to specify that the contents of an earlier capturing group must also be found at the current location in the string. For example, will succeed if the exact contents of group 1 can be found at the current position, and fails otherwise. Remember that Python’s string literals also use a backslash followed by numbers to allow including arbitrary characters in a string, so be sure to use a raw string when incorporating backreferences in a RE. For example, the following RE detects doubled words in a string. 'Paris in the the spring' Backreferences like this aren’t often useful for just searching through a string — there are few text formats which repeat data in this way — but you’ll soon find out that they’re very useful when performing string substitutions. Elaborate REs may use many groups, both to capture substrings of interest, and to group and structure the RE itself. In complex REs, it becomes difficult to keep track of the group numbers. There are two features which help with this problem. Both of them use a common syntax for regular expression extensions, so we’ll look at that first. Perl 5 is well known for its powerful additions to standard regular expressions. For these new features the Perl developers couldn’t choose new single-keystroke metacharacters or new special sequences beginning with without making Perl’s regular expressions confusingly different from standard REs. If they chose as a new metacharacter, for example, old expressions would be assuming that was a regular character and wouldn’t have escaped it by writing or . The solution chosen by the Perl developers was to use as the extension syntax. immediately after a parenthesis was a syntax error because the would have nothing to repeat, so this didn’t introduce any compatibility problems. The characters immediately after the indicate what extension is being used, so is one thing (a positive lookahead assertion) and is something else (a non-capturing group containing the subexpression ). Python supports several of Perl’s extensions and adds an extension syntax to Perl’s extension syntax. If the first character after the question mark is a , you know that it’s an extension that’s specific to Python. Now that we’ve looked at the general extension syntax, we can return to the features that simplify working with groups in complex REs. Sometimes you’ll want to use a group to denote a part of a regular expression, but aren’t interested in retrieving the group’s contents. You can make this fact explicit by using a non-capturing group: , where you can replace the with any other regular expression. Except for the fact that you can’t retrieve the contents of what the group matched, a non-capturing group behaves exactly the same as a capturing group; you can put anything inside it, repeat it with a repetition metacharacter such as , and nest it within other groups (capturing or non-capturing). is particularly useful when modifying an existing pattern, since you can add new groups without changing how all the other groups are numbered. It should be mentioned that there’s no performance difference in searching between capturing and non-capturing groups; neither form is any faster than the other. A more significant feature is named groups: instead of referring to them by numbers, groups can be referenced by a name. The syntax for a named group is one of the Python-specific extensions: . name is, obviously, the name of the group. Named groups behave exactly like capturing groups, and additionally associate a name with a group. The match object methods that deal with capturing groups all accept either integers that refer to the group by number or strings that contain the desired group’s name. Named groups are still given numbers, so you can retrieve information about a group in two ways: Additionally, you can retrieve named groups as a dictionary with : Named groups are handy because they let you use easily remembered names, instead of having to remember numbers. Here’s an example RE from the module: It’s obviously much easier to retrieve , instead of having to remember to retrieve group 9. The syntax for backreferences in an expression such as refers to the number of the group. There’s naturally a variant that uses the group name instead of the number. This is another Python extension: indicates that the contents of the group called name should again be matched at the current point. The regular expression for finding doubled words, can also be written as : 'Paris in the the spring' Another zero-width assertion is the lookahead assertion. Lookahead assertions are available in both positive and negative form, and look like this: Positive lookahead assertion. This succeeds if the contained regular expression, represented here by , successfully matches at the current location, and fails otherwise. But, once the contained expression has been tried, the matching engine doesn’t advance at all; the rest of the pattern is tried right where the assertion started. Negative lookahead assertion. This is the opposite of the positive assertion; it succeeds if the contained expression doesn’t match at the current position in the string. To make this concrete, let’s look at a case where a lookahead is useful. Consider a simple pattern to match a filename and split it apart into a base name and an extension, separated by a . For example, in , is the base name, and is the filename’s extension. The pattern to match this is quite simple: Notice that the needs to be treated specially because it’s a metacharacter, so it’s inside a character class to only match that specific character. Also notice the trailing ; this is added to ensure that all the rest of the string must be included in the extension. This regular expression matches and and and . Now, consider complicating the problem a bit; what if you want to match filenames where the extension is not ? Some incorrect attempts: The first attempt above tries to exclude by requiring that the first character of the extension is not a . This is wrong, because the pattern also doesn’t match . The expression gets messier when you try to patch up the first solution by requiring one of the following cases to match: the first character of the extension isn’t ; the second character isn’t ; or the third character isn’t . This accepts and rejects , but it requires a three-letter extension and won’t accept a filename with a two-letter extension such as . We’ll complicate the pattern again in an effort to fix it. In the third attempt, the second and third letters are all made optional in order to allow matching extensions shorter than three characters, such as . The pattern’s getting really complicated now, which makes it hard to read and understand. Worse, if the problem changes and you want to exclude both and as extensions, the pattern would get even more complicated and confusing. A negative lookahead cuts through all this confusion: The negative lookahead means: if the expression doesn’t match at this point, try the rest of the pattern; if does match, the whole pattern will fail. The trailing is required to ensure that something like , where the extension only starts with , will be allowed. The makes sure that the pattern works when there are multiple dots in the filename. Excluding another filename extension is now easy; simply add it as an alternative inside the assertion. The following pattern excludes filenames that end in either or :\n\nUp to this point, we’ve simply performed searches against a static string. Regular expressions are also commonly used to modify strings in various ways, using the following pattern methods: Split the string into a list, splitting it wherever the RE matches Find all substrings where the RE matches, and replace them with a different string Does the same thing as , but returns the new string and the number of replacements The method of a pattern splits a string apart wherever the RE matches, returning a list of the pieces. It’s similar to the method of strings but provides much more generality in the delimiters that you can split by; string only supports splitting by whitespace or by a fixed string. As you’d expect, there’s a module-level function, too. Split string by the matches of the regular expression. If capturing parentheses are used in the RE, then their contents will also be returned as part of the resulting list. If maxsplit is nonzero, at most maxsplit splits are performed. You can limit the number of splits made, by passing a value for maxsplit. When maxsplit is nonzero, at most maxsplit splits will be made, and the remainder of the string is returned as the final element of the list. In the following example, the delimiter is any sequence of non-alphanumeric characters. 'This is a test, short and sweet, of split().' ['This', 'is', 'a', 'test', 'short', 'and', 'sweet', 'of', 'split', ''] 'This is a test, short and sweet, of split().' ['This', 'is', 'a', 'test, short and sweet, of split().'] Sometimes you’re not only interested in what the text between delimiters is, but also need to know what the delimiter was. If capturing parentheses are used in the RE, then their values are also returned as part of the list. Compare the following calls: The module-level function adds the RE to be used as the first argument, but is otherwise the same. Another common task is to find all the matches for a pattern, and replace them with a different string. The method takes a replacement value, which can be either a string or a function, and the string to be processed. Returns the string obtained by replacing the leftmost non-overlapping occurrences of the RE in string by the replacement replacement. If the pattern isn’t found, string is returned unchanged. The optional argument count is the maximum number of pattern occurrences to be replaced; count must be a non-negative integer. The default value of 0 means to replace all occurrences. Here’s a simple example of using the method. It replaces colour names with the word : The method does the same work, but returns a 2-tuple containing the new string value and the number of replacements that were performed: Empty matches are replaced only when they’re not adjacent to a previous empty match. If replacement is a string, any backslash escapes in it are processed. That is, is converted to a single newline character, is converted to a carriage return, and so forth. Unknown escapes such as are left alone. Backreferences, such as , are replaced with the substring matched by the corresponding group in the RE. This lets you incorporate portions of the original text in the resulting replacement string. This example matches the word followed by a string enclosed in , , and changes to : There’s also a syntax for referring to named groups as defined by the syntax. will use the substring matched by the group named , and uses the corresponding group number. is therefore equivalent to , but isn’t ambiguous in a replacement string such as . ( would be interpreted as a reference to group 20, not a reference to group 2 followed by the literal character .) The following substitutions are all equivalent, but use all three variations of the replacement string. replacement can also be a function, which gives you even more control. If replacement is a function, the function is called for every non-overlapping occurrence of pattern. On each call, the function is passed a match object argument for the match and can use this information to compute the desired replacement string and return it. In the following example, the replacement function translates decimals into hexadecimal: When using the module-level function, the pattern is passed as the first argument. The pattern may be provided as an object or as a string; if you need to specify regular expression flags, you must either use a pattern object as the first parameter, or use embedded modifiers in the pattern string, e.g. returns .\n\nRegular expressions are a powerful tool for some applications, but in some ways their behaviour isn’t intuitive and at times they don’t behave the way you may expect them to. This section will point out some of the most common pitfalls. Sometimes using the module is a mistake. If you’re matching a fixed string, or a single character class, and you’re not using any features such as the flag, then the full power of regular expressions may not be required. Strings have several methods for performing operations with fixed strings and they’re usually much faster, because the implementation is a single small C loop that’s been optimized for the purpose, instead of the large, more generalized regular expression engine. One example might be replacing a single fixed string with another one; for example, you might replace with . seems like the function to use for this, but consider the method. Note that will also replace inside words, turning into , but the naive RE would have done that, too. (To avoid performing the substitution on parts of words, the pattern would have to be , in order to require that have a word boundary on either side. This takes the job beyond ’s abilities.) Another common task is deleting every occurrence of a single character from a string or replacing it with another single character. You might do this with something like , but is capable of doing both tasks and will be faster than any regular expression operation can be. In short, before turning to the module, consider whether your problem can be solved with a faster and simpler string method. The function only checks if the RE matches at the beginning of the string while will scan forward through the string for a match. It’s important to keep this distinction in mind. Remember, will only report a successful match which will start at 0; if the match wouldn’t start at zero, will not report it. On the other hand, will scan forward through the string, reporting the first match it finds. Sometimes you’ll be tempted to keep using , and just add to the front of your RE. Resist this temptation and use instead. The regular expression compiler does some analysis of REs in order to speed up the process of looking for a match. One such analysis figures out what the first character of a match must be; for example, a pattern starting with must match starting with a . The analysis lets the engine quickly scan through the string looking for the starting character, only trying the full match if a is found. Adding defeats this optimization, requiring scanning to the end of the string and then backtracking to find a match for the rest of the RE. Use instead. When repeating a regular expression, as in , the resulting action is to consume as much of the pattern as possible. This fact often bites you when you’re trying to match a pair of balanced delimiters, such as the angle brackets surrounding an HTML tag. The naive pattern for matching a single HTML tag doesn’t work because of the greedy nature of . The RE matches the in , and the consumes the rest of the string. There’s still more left in the RE, though, and the can’t match at the end of the string, so the regular expression engine has to backtrack character by character until it finds a match for the . The final match extends from the in to the in , which isn’t what you want. In this case, the solution is to use the non-greedy quantifiers , , , or , which match as little text as possible. In the above example, the is tried immediately after the first matches, and when it fails, the engine advances a character at a time, retrying the at every step. This produces just the right result: By now you’ve probably noticed that regular expressions are a very compact notation, but they’re not terribly readable. REs of moderate complexity can become lengthy collections of backslashes, parentheses, and metacharacters, making them difficult to read and understand. For such REs, specifying the flag when compiling the regular expression can be helpful, because it allows you to format the regular expression more clearly. The flag has several effects. Whitespace in the regular expression that isn’t inside a character class is ignored. This means that an expression such as is equivalent to the less readable , but will still match the characters , , or a space. In addition, you can also put comments inside a RE; comments extend from a character to the next newline. When used with triple-quoted strings, this enables REs to be formatted more neatly: (?P<value>.*?) # The header's value -- *? used to This is far more readable than:"
    },
    {
        "link": "https://developers.google.com/edu/python/regular-expressions",
        "document": "Regular expressions are a powerful language for matching text patterns. This page gives a basic introduction to regular expressions themselves sufficient for our Python exercises and shows how regular expressions work in Python. The Python \"re\" module provides regular expression support.\n\nIn Python a regular expression search is typically written as:\n\nThe re.search() method takes a regular expression pattern and a string and searches for that pattern within the string. If the search is successful, search() returns a match object or None otherwise. Therefore, the search is usually immediately followed by an if-statement to test if the search succeeded, as shown in the following example which searches for the pattern 'word:' followed by a 3 letter word (details below):\n\nThe code stores the search result in a variable named \"match\". Then the if-statement tests the match -- if true the search succeeded and match.group() is the matching text (e.g. 'word:cat'). Otherwise if the match is false (None to be more specific), then the search did not succeed, and there is no matching text.\n\nThe 'r' at the start of the pattern string designates a python \"raw\" string which passes through backslashes without change which is very handy for regular expressions (Java needs this feature badly!). I recommend that you always write pattern strings with the 'r' just as a habit.\n\nThe power of regular expressions is that they can specify patterns, not just fixed characters. Here are the most basic patterns which match single chars:\n• a, X, 9, < -- ordinary characters just match themselves exactly. The meta-characters which do not match themselves because they have special meanings are: . ^ $ * + ? { [ ] \\ | ( ) (details below)\n• \\w -- (lowercase w) matches a \"word\" character: a letter or digit or underbar [a-zA-Z0-9_]. Note that although \"word\" is the mnemonic for this, it only matches a single word char, not a whole word. \\W (upper case W) matches any non-word character.\n• \\d -- decimal digit [0-9] (some older regex utilities do not support \\d, but they all support \\w and \\s)\n• ^ = start, $ = end -- match the start or end of the string\n• \\ -- inhibit the \"specialness\" of a character. So, for example, use \\. to match a period or \\\\ to match a slash. If you are unsure if a character has special meaning, such as '@', you can try putting a slash in front of it, \\@. If its not a valid escape sequence, like \\c, your python program will halt with an error.\n\nJoke: what do you call a pig with three eyes? piiig!\n\nThe basic rules of regular expression search for a pattern within a string are:\n• The search proceeds through the string from start to end, stopping at the first match found\n• All of the pattern must be matched, but not all of the string\n• If is successful, match is not None and in particular match.group() is the matching text\n\nThings get more interesting when you use + and * to specify repetition in the pattern\n• + -- 1 or more occurrences of the pattern to its left, e.g. 'i+' = one or more i's\n• * -- 0 or more occurrences of the pattern to its left\n• ? -- match 0 or 1 occurrences of the pattern to its left\n\nFirst the search finds the leftmost match for the pattern, and second it tries to use up as much of the string as possible -- i.e. + and * go as far as possible (the + and * are said to be \"greedy\").\n\nSuppose you want to find the email address inside the string 'xyz alice-b@google.com purple monkey'. We'll use this as a running example to demonstrate more regular expression features. Here's an attempt using the pattern r'\\w+@\\w+':\n\nThe search does not get the whole email address in this case because the \\w does not match the '-' or '.' in the address. We'll fix this using the regular expression features below.\n\nSquare brackets can be used to indicate a set of chars, so [abc] matches 'a' or 'b' or 'c'. The codes \\w, \\s etc. work inside square brackets too with the one exception that dot (.) just means a literal dot. For the emails problem, the square brackets are an easy way to add '.' and '-' to the set of chars which can appear around the @ with the pattern r'[\\w.-]+@[\\w.-]+' to get the whole email address:\n\n(More square-bracket features) You can also use a dash to indicate a range, so [a-z] matches all lowercase letters. To use a dash without indicating a range, put the dash last, e.g. [abc-]. An up-hat (^) at the start of a square-bracket set inverts it, so [^ab] means any char except 'a' or 'b'.\n\nThe \"group\" feature of a regular expression allows you to pick out parts of the matching text. Suppose for the emails problem that we want to extract the username and host separately. To do this, add parentheses ( ) around the username and host in the pattern, like this: r'([\\w.-]+)@([\\w.-]+)'. In this case, the parentheses do not change what the pattern will match, instead they establish logical \"groups\" inside of the match text. On a successful search, match.group(1) is the match text corresponding to the 1st left parentheses, and match.group(2) is the text corresponding to the 2nd left parentheses. The plain match.group() is still the whole match text as usual.\n\nA common workflow with regular expressions is that you write a pattern for the thing you are looking for, adding parentheses groups to extract the parts you want.\n\nfindall() is probably the single most powerful function in the re module. Above we used re.search() to find the first match for a pattern. findall() finds *all* the matches and returns them as a list of strings, with each string representing one match.\n\nFor files, you may be in the habit of writing a loop to iterate over the lines of the file, and you could then call findall() on each line. Instead, let findall() do the iteration for you -- much better! Just feed the whole file text into findall() and let it return a list of all the matches in a single step (recall that f.read() returns the whole text of a file in a single string):\n\nThe parentheses ( ) group mechanism can be combined with findall(). If the pattern includes 2 or more parentheses groups, then instead of returning a list of strings, findall() returns a list of *tuples*. Each tuple represents one match of the pattern, and inside the tuple is the group(1), group(2) .. data. So if 2 parentheses groups are added to the email pattern, then findall() returns a list of tuples, each length 2 containing the username and host, e.g. ('alice', 'google.com').\n\nOnce you have the list of tuples, you can loop over it to do some computation for each tuple. If the pattern includes no parentheses, then findall() returns a list of found strings as in earlier examples. If the pattern includes a single set of parentheses, then findall() returns a list of strings corresponding to that single group. (Obscure optional feature: Sometimes you have paren ( ) groupings in the pattern, but which you do not want to extract. In that case, write the parens with a ?: at the start, e.g. (?: ) and that left paren will not count as a group result.)\n\nRegular expression patterns pack a lot of meaning into just a few characters , but they are so dense, you can spend a lot of time debugging your patterns. Set up your runtime so you can run a pattern and print what it matches easily, for example by running it on a small test text and printing the result of findall(). If the pattern matches nothing, try weakening the pattern, removing parts of it so you get too many matches. When it's matching nothing, you can't make any progress since there's nothing concrete to look at. Once it's matching too much, then you can work on tightening it up incrementally to hit just what you want.\n\nThe re functions take options to modify the behavior of the pattern match. The option flag is added as an extra argument to the search() or findall() etc., e.g. re.search(pat, str, re.IGNORECASE).\n• IGNORECASE -- ignore upper/lowercase differences for matching, so 'a' matches both 'a' and 'A'.\n• DOTALL -- allow dot (.) to match newline -- normally it matches anything but newline. This can trip you up -- you think .* matches everything, but by default it does not go past the end of a line. Note that \\s (whitespace) includes newlines, so if you want to match a run of whitespace that may include a newline, you can just use \\s*\n• MULTILINE -- Within a string made of many lines, allow ^ and $ to match the start and end of each line. Normally ^/$ would just match the start and end of the whole string.\n\nThis is optional section which shows a more advanced regular expression technique not needed for the exercises.\n\nSuppose you have text with tags in it: <b>foo</b> and <i>so on</i>\n\nSuppose you are trying to match each tag with the pattern '(<.*>)' -- what does it match first?\n\nThe result is a little surprising, but the greedy aspect of the .* causes it to match the whole '<b>foo</b> and <i>so on</i>' as one big match. The problem is that the .* goes as far as is it can, instead of stopping at the first > (aka it is \"greedy\").\n\nThere is an extension to regular expression where you add a ? at the end, such as .*? or .+?, changing them to be non-greedy. Now they stop as soon as they can. So the pattern '(<.*?>)' will get just '<b>' as the first match, and '</b>' as the second match, and so on getting each <..> pair in turn. The style is typically that you use a .*? immediately followed by some concrete marker (> in this case) to which the .*? run is forced to extend.\n\nThe *? extension originated in Perl, and regular expressions that include Perl's extensions are known as Perl Compatible Regular Expressions -- pcre. Python includes pcre support. Many command line utils etc. have a flag where they accept pcre patterns.\n\nAn older but widely used technique to code this idea of \"all of these chars except stopping at X\" uses the square-bracket style. For the above you could write the pattern, but instead of .* to get all the chars, use [^>]* which skips over all characters which are not > (the leading ^ \"inverts\" the square bracket set, so it matches any char not in the brackets).\n\nThe re.sub(pat, replacement, str) function searches for all the instances of pattern in the given string, and replaces them. The replacement string can include '\\1', '\\2' which refer to the text from group(1), group(2), and so on from the original matching text.\n\nHere's an example which searches for all the email addresses, and changes them to keep the user (\\1) but have yo-yo-dyne.com as the host.\n\nTo practice regular expressions, see the Baby Names Exercise."
    },
    {
        "link": "https://w3schools.com/python/python_regex.asp",
        "document": "A RegEx, or Regular Expression, is a sequence of characters that forms a search pattern.\n\nRegEx can be used to check if a string contains the specified search pattern.\n\nPython has a built-in package called , which can be used to work with Regular Expressions.\n\nWhen you have imported the module, you can start using regular expressions:\n\nThe module offers a set of functions that allows us to search a string for a match:\n\nA special sequence is a followed by one of the characters in the list below, and has a special meaning:\n\nA set is a set of characters inside a pair of square brackets with a special meaning:\n\nThe function returns a list containing all matches.\n\nThe list contains the matches in the order they are found.\n\nIf no matches are found, an empty list is returned:\n\nThe function searches the string for a match, and returns a Match object if there is a match.\n\nIf there is more than one match, only the first occurrence of the match will be returned:\n\nIf no matches are found, the value is returned:\n\nThe function returns a list where the string has been split at each match:\n\nYou can control the number of occurrences by specifying the parameter:\n\nThe function replaces the matches with the text of your choice:\n\nYou can control the number of replacements by specifying the parameter:\n\nA Match Object is an object containing information about the search and the result.\n\nThe Match object has properties and methods used to retrieve information about the search, and the result:\n\nreturns a tuple containing the start-, and end positions of the match.\n\n returns the string passed into the function\n\n returns the part of the string where there was a match"
    },
    {
        "link": "https://pypi.org/project/regex",
        "document": "A required part of this site couldn’t load. This may be due to a browser extension, network issues, or browser settings. Please check your connection, disable any ad blockers, or try using a different browser."
    },
    {
        "link": "https://docs.sympy.org/latest/guides/solving/index.html",
        "document": "The Python package SymPy can symbolically solve equations, differential equations, linear equations, nonlinear equations, matrix problems, inequalities, Diophantine equations, and evaluate integrals. SymPy can also solve numerically.\n\nThe Solving Guidance page provides recommendations applicable to many types of solving tasks.\n\nLearn how to use SymPy computer algebra system to:\n• None SymPy has a function called which is designed to find the solutions of an equation or system of equations, or the roots of a function. SymPy may or may not be what you need for a particular problem, so we recommend you use the links on this page to learn how to “solve” your problem.\n• None While a common, colloquial expression is, for example, “solve an integral,” in SymPy’s terminology it would be “evaluate an integral.” This page does not provide guidance for such tasks. Please search the documentation for the type of expression you want to evaluate."
    },
    {
        "link": "https://docs.sympy.org/latest/modules/solvers/solvers.html",
        "document": "The solvers module in SymPy implements methods for solving equations.\n\nUse to solve algebraic equations. We suppose all equations are equaled to 0, so solving x**2 == 1 translates into the following code: The first argument for is an equation (equaled to zero) and the second argument is the symbol that we want to solve the equation for.\n• None a single Expr or Poly that must be zero\n• None iterable of one or more of the above symbols : (object(s) to solve for) specified as\n• None none given (other non-numeric objects will be used) Return list of symbols and set of tuple(s) of solution(s). Do not try to solve for any of the free symbols in exclude; if expressions are given, the free symbols in them will be extracted automatically. If False, do not do any testing of solutions. This can be useful if you want to include solutions that make any denominator zero. Do a fast numerical check if f has only one symbol. Show a warning if could not conclude. Simplify all but polynomials of order 3 or greater before returning them and (if check is not False) use the general simplify function on the solutions and the expression obtained when they are substituted into the function which should be zero. Make positive all symbols without assumptions regarding sign. Recast Floats as Rational; if this option is not used, the system containing Floats may fail to solve because of issues with polys. If rational=None, Floats will be recast as rationals but the answer will be recast as Floats. If the flag is False then nothing will be done to the Floats. Do not use the polys/matrix method to solve a system of equations, solve them one at a time as you might “manually.” Allows to return a solution for a pattern in terms of other functions that contain that pattern; this is only needed if the pattern is inside of some invertible function like cos, exp, ect. Instructs to try to find a particular solution to a linear system with as many zeros as possible; this is very expensive. quick=True (default is False; must be True) Selects a fast heuristic to find a solution with many zeros whereas a value of False uses the very slow method guaranteed to find the largest number of zeros possible. Return explicit solutions when cubic expressions are encountered. When False, quartics and quintics are disabled, too. Return explicit solutions when quartic expressions are encountered. When False, quintics are disabled, too. Return explicit solutions (if possible) when quintic expressions are encountered.\n• None piecewise combinations of the above The default output varies according to the input and might be a list (possibly empty), a dictionary, a list of dictionaries or tuples, or an expression involving relationals. For specifics regarding different forms of output that may appear, see Solve Output by Type. Let it suffice here to say that to obtain a uniform output from \\(solve\\) use or (see below). The expressions that are passed can be Expr, Equality, or Poly classes (or lists of the same); a Matrix is considered to be a list of all the elements of the matrix: If no symbols are indicated to be of interest and the equation is univariate, a list of values is returned; otherwise, the keys in a dictionary will indicate which (of all the variables used in the expression(s)) variables and solutions were found: If you pass symbols for which solutions are sought, the output will vary depending on the number of symbols you passed, whether you are passing a list of expressions or not, and whether a linear system was solved. Uniform output is attained by using or . #### *** feel free to skip to the stars below *** ####\n• None If any equation does not depend on the symbol(s) given, it will be eliminated from the equation set and an answer may be given implicitly in terms of variables that were not of interest: When you pass all but one of the free symbols, an attempt is made to find a single solution based on the method of undetermined coefficients. If it succeeds, a dictionary of values is returned. If you want an algebraic solutions for one or more of the symbols, pass the expression to be solved in a list: When there is no solution for any given symbol which will make all expressions zero, the empty list is returned (or an empty set in the tuple when ): When an object other than a Symbol is given as a symbol, it is isolated algebraically and an implicit solution may be obtained. This is mostly provided as a convenience to save you from replacing the object with a Symbol and solving for that Symbol. It will only work if the specified object can be replaced with a Symbol using the subs method:\n• None To solve for a function within a derivative, use . To solve for a symbol implicitly, use implicit=True: It is possible to solve for anything in an expression that can be replaced with a symbol using :\n• None Nothing heroic is done in this implicit solving so you may end up with a symbol still in the solution:\n• None If you attempt to solve for a number, remember that the number you have obtained does not necessarily mean that the value is equivalent to the expression obtained: with check=True (default) will run through the symbol tags to eliminate unwanted solutions. If no assumptions are included, all possible solutions will be returned: By setting the flag, only one solution will be returned: When the solutions are checked, those that make any denominator zero are automatically excluded. If you do not want to exclude such solutions, then use the check=False option: If , then a solution to the numerator being zero is found but the value of \\(x = 0\\) is a spurious solution since \\(\\sin(x)/x\\) has the well known limit (without discontinuity) of 1 at \\(x = 0\\): In the following case, however, the limit exists and is equal to the value of \\(x = 0\\) that is excluded when check=True: When one or more expressions passed to is a relational, a relational result is returned (and the and flags are ignored): Although checking of assumptions on symbols in relationals is not done, setting assumptions will affect how certain relationals might automatically simplify: There is currently no algorithm in SymPy that allows you to use relationships to resolve more than one variable. So the following does not determine that (and trying to solve for and will raise an error): You can directly call the routine that calls when it encounters a relational: . It treats Expr like Equality. If each relationship contains only one symbol of interest, the expressions can be processed for multiple symbols: But an error is raised if any relationship has more than one symbol of interest: inequality has more than one symbol of interest. When solving polynomial expressions, you might not want explicit solutions (which can be quite long). If the expression is univariate, instances will be returned instead: If the expression is multivariate, no solution might be returned: Sometimes solutions will be obtained even when a flag is False because the expression could be factored. In the following example, the equation can be factored as the product of a linear and a quadratic factor so explicit solutions (which did not require solving a cubic expression) are obtained: Because of SymPy’s use of the principle root, some solutions to radical equations will be missed unless check=False: In the above example, there is only a single solution to the equation. Other expressions will yield spurious roots which must be checked manually; roots which give a negative argument to odd-powered radicals will also need special checking: # this gives 2 solutions but misses a 3rd The first solution is negative so must be used to see that it satisfies the expression: If the roots of the equation are not real then more care will be necessary to find the roots, especially for higher order equations. Consider the following expression: We will construct a known value for this expression at x = 3 by selecting the 1-th root for each radical: The function is unable to find any exact roots to this equation: The function , however, can be used to get a form of the equation for which numerical roots can be found: Although or could have been used to find , the solution can only be verified with : Return a tuple derived from that is one of the following: , , , . meaning that is independent of the symbols in symbols that are not in exclude. meaning that there is no solution to the equation amongst the symbols given. If the first element of the tuple is not zero, then the function is guaranteed to be dependent on a symbol in symbols. where symbol appears linearly in the numerator of , is in symbols (if given), and is not in exclude (if given). No simplification is done to other than a expansion, so the solution will correspond strictly to a unique solution. where and are the numerator and denominator of when the numerator was not linear in any symbol of interest; will never be a symbol unless a solution for that symbol was found (in which case the second element is the solution, not the denominator). is independent of the symbols in symbols that are not in exclude: The variable appears as a linear variable in each of the following: When not linear in or then the numerator and denominator are returned: If the numerator of the expression is a symbol, then is returned if the solution for that symbol would have set any denominator to 0: But automatic rewriting may cause a symbol in the denominator to appear in the numerator so a solution will be returned: Use an unevaluated expression to avoid this: If is allowed to cancel in the following expression, then it appears to be linear in , but this sort of cancellation is not done by so the solution will always satisfy the original expression without causing a division by zero error. A list of symbols for which a solution is desired may be given: A list of symbols to ignore may also be given: Solve system of \\(N\\) linear equations with \\(M\\) variables, which means both under- and overdetermined systems are supported. The possible number of solutions is zero, one, or infinite. Respectively, this procedure will return None or a dictionary with solutions. In the case of underdetermined systems, all arbitrary parameters are skipped. This may cause a situation in which an empty dictionary is returned. In that case, all symbols can be assigned arbitrary values. Input to this function is a \\(N\\times M + 1\\) matrix, which means it has to be in augmented form. If you prefer to enter \\(N\\) equations and \\(M\\) unknowns then use instead. Note: a local copy of the matrix is made by this routine so the matrix that is passed will not be modified. The algorithm used here is fraction-free Gaussian elimination, which results, after elimination, in an upper-triangular matrix. Then solutions are found using back-substitution. This approach is more efficient and compact than the Gauss-Jordan method. Solves the augmented matrix system using and returns a dictionary in which solutions are keyed to the symbols of syms as ordered. The matrix must be invertible. Solve a system of equations in \\(k\\) parameters that is formed by matching coefficients in variables that are on factors dependent on the remaining variables (or those given explicitly by . The result of this function is a dictionary with symbolic values of those parameters with respect to coefficients in \\(q\\) – empty if there is no solution or coefficients do not appear in the equation – else None (if the system was not recognized). If there is more than one solution, the solutions are passed as a list. The output can be modified using the same semantics as for \\(solve\\) since the flags that are passed are sent directly to \\(solve\\) so, for example the flag will always return a list of solutions as dictionaries. This function accepts both Equality and Expr class instances. The solving process is most efficient when symbols are specified in addition to parameters to be determined, but an attempt to determine them (if absent) will be made. If an expected solution is not obtained (and symbols were not specified) try specifying them. The equation can be nonlinear in the symbols: And the system can be nonlinear in coefficients, too, but if there is only a single solution, it will be returned as a dictionary: Multiple solutions are always returned in a list: Using flag (in keeping with semantics in ) will force the result to always be a list with any solutions as elements in that list. is a vector function of symbolic expressions representing the system. args are the variables. If there is only one variable, this argument can be omitted. is a starting vector close to a solution. Use the modules keyword to specify which modules should be used to evaluate the function and the Jacobian matrix. Make sure to use a module that supports matrices. For more information on the syntax, please see the docstring of . If the keyword arguments contain (default is False) will return a list (perhaps empty) of solution mappings. This might be especially useful if you want to use as a fallback to solve since using the dict argument for both methods produces return values of consistent type structure. Please note: to keep this consistent with , the solution will be returned in a list even though (currently at least) only finds one solution at a time. For one-dimensional functions the syntax is simplified: To solve with higher precision than the default, use the prec argument: To solve for complex roots of real functions, a nonreal initial point must be specified: is used and you can find their more extensive documentation, especially concerning keyword parameters and available solvers. Note, however, that functions which are very steep near the root, the verification of the solution may fail. In this case you should use the flag and independently verify the solution. : Could not find root within given tolerance. (1.39267e+230 > 2.1684e-19) One might safely skip the verification if bounds of the root are known and a bisection method is used: Alternatively, a function may be better behaved when the denominator is ignored. Since this is not always the case, however, the decision of what function to use is left to the discretion of the user. : Could not find root within given tolerance. (10000 > 2.1684e-19) Try another starting point or tweak arguments. Checks whether sol is a solution of equation f == 0. Input can be either a single symbol and corresponding value or a dictionary of symbols and values. When given as a dictionary and flag , the values in the dictionary will be simplified. f can be a single equation or an iterable of equations. A solution must satisfy all equations in f to be considered valid; if a solution does not satisfy any equation, False is returned; if one or more checks are inconclusive (and none are False) then None is returned. To check if an expression is zero using , pass it as f and send an empty dictionary for symbol: None is returned if could not conclude. do a fast numerical check if has only one symbol. show a warning if checksol() could not conclude. simplify solution before substituting into function and simplify the function before trying specific simplifications make positive all symbols without assumptions regarding sign. Remove radicals with symbolic arguments and return (eq, cov), None, or raise an error. None is returned if there are no radicals to remove. NotImplementedError is raised if there are radicals and they cannot be removed or if the relationship between the original symbols and the change of variable needed to rewrite the system as a polynomial cannot be solved. Otherwise the tuple, , is returned where: eq is an equation without radicals (in the symbol(s) of interest) whose solutions are a superset of the solutions to the original expression. eq might be rewritten in terms of a new variable; the relationship to the original variables is given by which is a list containing and where is the power needed to clear the radical and is the radical now expressed as a polynomial in the symbols of interest. For example, for sqrt(2 - x) the tuple would be . The solutions of eq will contain solutions to the original equation (if there are any). An iterable of symbols which, if provided, will limit the focus of radical removal: only radicals with one or more of the symbols of interest will be cleared. All free symbols are used if syms is not set. flags are used internally for communication during recursive calls. Two options are also recognized: , when defined, is interpreted as a single-argument function that returns True if a given Pow should be handled. Radicals can be removed from an expression if:\n• None All bases of the radicals are the same; a change of variables is done in this case.\n• None If all radicals appear in one term of the expression.\n• None There are only four terms with sqrt() factors or there are less than four terms having sqrt() factors.\n• None There are only two terms with radicals.\n\nwhere \\(a_{i}(n)\\), for \\(i=0, \\ldots, k\\), are polynomials or rational functions in \\(n\\), and \\(f\\) is a hypergeometric function or a sum of a fixed number of pairwise dissimilar hypergeometric terms in \\(n\\), finds all solutions or returns , if none were found. Initial conditions can be given as a dictionary in two forms: or as a list of values: where , for \\(i=0, \\ldots, m\\), maps to \\(y(n_i)\\). Lets consider the following recurrence: Given linear recurrence operator \\(\\operatorname{L}\\) of order \\(k\\) with polynomial coefficients and inhomogeneous equation \\(\\operatorname{L} y = f\\), where \\(f\\) is a polynomial, we seek for all polynomial solutions over field \\(K\\) of characteristic zero.\n• None Find all polynomials of degree \\(N\\) or less of \\(\\operatorname{L} y = f\\). There are two methods for computing the polynomial solutions. If the degree bound is relatively small, i.e. it’s smaller than or equal to the order of the recurrence, then naive method of undetermined coefficients is being used. This gives a system of algebraic equations with \\(N+1\\) unknowns. In the other case, the algorithm performs transformation of the initial equation to an equivalent one for which the system of algebraic equations has only \\(r\\) indeterminates. This method is quite sophisticated (in comparison with the naive one) and was invented together by Abramov, Bronstein and Petkovsek. It is possible to generalize the algorithm implemented here to the case of linear q-difference and differential equations. Lets say that we would like to compute \\(m\\)-th Bernoulli polynomial up to a constant. For this we can use \\(b(n+1) - b(n) = m n^{m-1}\\) recurrence, which has solution \\(b(n) = B_m + C\\). For example: S. A. Abramov, M. Bronstein and M. Petkovsek, On polynomial solutions of linear operator equations, in: T. Levelt, ed., Proc. ISSAC ‘95, ACM Press, New York, 1995, 290-296. Given linear recurrence operator \\(\\operatorname{L}\\) of order \\(k\\) with polynomial coefficients and inhomogeneous equation \\(\\operatorname{L} y = f\\), where \\(f\\) is a polynomial, we seek for all rational solutions over field \\(K\\) of characteristic zero. This procedure accepts only polynomials, however if you are interested in solving recurrence with rational coefficients then use which will pre-process the given equation and run this procedure with polynomial arguments.\n• None Compute polynomial \\(v(n)\\) which can be used as universal denominator of any rational solution of equation \\(\\operatorname{L} y = f\\).\n• None Construct new linear difference equation by substitution \\(y(n) = u(n)/v(n)\\) and solve it for \\(u(n)\\) finding all its polynomial solutions. Return if none were found. The algorithm implemented here is a revised version of the original Abramov’s algorithm, developed in 1989. The new approach is much simpler to implement and has better overall efficiency. This method can be easily adapted to the q-difference equations case. Besides finding rational solutions alone, this functions is an important part of Hyper algorithm where it is used to find a particular solution for the inhomogeneous part of a recurrence. S. A. Abramov, Rational solutions of linear difference and q-difference equations with polynomial coefficients, in: T. Levelt, ed., Proc. ISSAC ‘95, ACM Press, New York, 1995, 285-289 Given linear recurrence operator \\(\\operatorname{L}\\) of order \\(k\\) with polynomial coefficients and inhomogeneous equation \\(\\operatorname{L} y = f\\) we seek for all hypergeometric solutions over field \\(K\\) of characteristic zero. The inhomogeneous part can be either hypergeometric or a sum of a fixed number of pairwise dissimilar hypergeometric terms.\n• None Group together similar hypergeometric terms in the inhomogeneous part of \\(\\operatorname{L} y = f\\), and find particular solution using Abramov’s algorithm.\n• None Compute generating set of \\(\\operatorname{L}\\) and find basis in it, so that all solutions are linearly independent.\n• None Form final solution with the number of arbitrary constants equal to dimension of basis of \\(\\operatorname{L}\\). Term \\(a(n)\\) is hypergeometric if it is annihilated by first order linear difference equations with polynomial coefficients or, in simpler words, if consecutive term ratio is a rational function. The output of this procedure is a linear combination of fixed number of hypergeometric terms. However the underlying method can generate larger class of solutions - D’Alembertian terms. Note also that this method not only computes the kernel of the inhomogeneous equation, but also reduces in to a basis so that solutions generated by this procedure are linearly independent\n\nreturn maximum of linear equation under linear constraints expressed using Ge, Le or Eq. All variables are unbounded unless constrained. Negative values for variables are permitted unless explicitly exluding: If a non-negative constraint is added for x, there is no possible solution: return minimum of linear equation under linear constraints expressed using Ge, Le or Eq. All variables are unbounded unless constrained. Negative values for variables are permitted unless explicitly exluding, so minimizing for is an unbounded problem while the following has a bounded solution: Without indicating that is nonnegative, there is no minimum for this objective: Return the minimization of with the given constraints and . Unless bounds are given, variables will have nonnegative values in the solution. If is not given, then the dimension of the system will be determined by the length of . By default, all variables will be nonnegative. If is given as a single tuple, , then all variables will be constrained to be between and . Use None for a or if it is unconstrained in the negative or positive direction, respectively, e.g. indicates nonpositive values. To set individual ranges, pass a list with length equal to the number of columns in , each element being a tuple; if only a few variables take on non-default values they can be passed as a dictionary with keys giving the corresponding column to which the variable is assigned, e.g. would limit the 3rd variable to have a value in range ."
    },
    {
        "link": "https://docs.sympy.org/latest/guides/solving/solve-system-of-equations-algebraically.html",
        "document": "Use SymPy to algebraically solve a system of equations, whether linear or nonlinear. For example, solving \\(x^2 + y = 2z, y = -4z\\) for x and y (assuming z is a constant or parameter) yields \\(\\{(x = -\\sqrt{6z}, y = -4z),\\) \\({(x = \\sqrt{6z}, y = -4z)\\}}\\).\n\nSolve and Use Results in a Dictionary¶ Solve Into a Solution Given as a Dictionary¶ You can solve a system of equations for some variables (for example, \\(x\\) and \\(y\\)) leaving another symbol as a constant or parameter (for example, \\(z\\)). You can specify the variables to solve for as multiple separate arguments, or as a list (or tuple): Use a Solution Given as a Dictionary¶ You can then extract solutions by indexing (specifying in brackets) the solution number, and then the symbol. For example gives the result for in the first solution:\n\nNot All Systems of Equations Can be Solved¶ Systems of Equations With no Solution¶ Some systems of equations have no solution. For example, the following two systems have no solution because they reduce to , so SymPy returns an empty list: The following system reduces to \\(z = 2z\\), so it has no general solution, but it could be satisfied if \\(z=0\\). Note that will not assume that \\(z=0\\), even though that is the only value of \\(z\\) that makes the system of equations consistent, because \\(z\\) is a parameter rather than an unknown. That is, does not treat \\(z\\) as an unknown because it is not in the list of symbols specified as unknowns ( ) and all such symbols are treated like parameters with arbitrary value. Whether a symbol is treated as a variable or a parameter is determined only by whether it is specified as a symbol to solve for in . There is no such distinction made when creating the symbol using (or importing from ). The following system is overconstrained, meaning there are more equations (three) than unknowns to be solved for (two, namely \\(x\\) and \\(y\\)). It has no solution: Note that some overconstrained systems do have solutions (for example, if an equation is a linear combination of the others), in which case SymPy can solve the overconstrained system. Systems of Equations With no Closed-Form Solution¶ Some systems of equations cannot be solved algebraically, for example those containing transcendental equations: So you can use to find a numerical solution: Equations Which Have a Closed-Form Solution, and SymPy Cannot Solve¶ It is also possible that there is an algebraic solution to your equation, and SymPy has not implemented an appropriate algorithm. If SymPy returns an empty set or list when you know there is a closed-form solution (indicating a bug in SymPy), please post it on the mailing list, or open an issue on SymPy’s GitHub page. Until the issue is resolved, you can use a different method listed in Alternatives to Consider."
    },
    {
        "link": "https://docs.sympy.org/latest/guides/solving/solve-numerically.html",
        "document": "Solve One or a System of Equations Numerically¶\n\nUse SymPy to numerically solve a system of one or more equations. For example, numerically solving \\(\\cos(x) = x \\) returns \\( x \\approx 0.739085133215161\\).\n\nSolving numerically is useful if:\n• None You only need a numeric solution, not a symbolic one\n• None A closed-form solution is not available or is overly complicated; refer to When You Might Prefer a Numeric Solution\n\nand will not try to find a numeric solution, only a mathematically-exact symbolic solution. So if you want a numeric solution, use .\n\nSymPy is designed for symbolic mathematics. If you do not need to do symbolic operations, then for numerical operations you can use another free and open-source package such as NumPy or SciPy which will be faster, work with arrays, and have more algorithms implemented. The main reasons to use SymPy (or its dependency mpmath) for numerical calculations are:\n• None to do a simple numerical calculation within the context of a symbolic calculation using SymPy\n• None if you need the arbitrary precision capabilities to get more digits of precision than you would get from float64.\n\nTo solve for complex roots of real functions, specify a nonreal (either purely imaginary, or complex) initial point: : Could not find root within given tolerance. (4.18466446988997098217 > 2.16840434497100886801e-19) Try another starting point or tweak arguments. Ensure the Root Found is in a Given Interval¶ It is not guaranteed that will find the root closest to the initial point. Here, even though the root is closer to the initial point of , finds the root : You can ensure the root found is in a given interval, if such a root exists, using by specifying the interval in a tuple. Here, specifying the interval ensures that the root is found: To solve a system of multidimensional functions, supply a tuple of You can increase the precision of the solution using : Create a Function That Can Be Solved With SciPy¶ As noted above, SymPy focuses on symbolic computation and is not optimized for numerical calculations. If you need to make many calls to a numerical solver, it can be much faster to use a solver optimized for numerical calculations such as SciPy’s . A recommended workflow is:\n• None use SymPy to generate (by symbolically simplifying or solving an equation) the mathematical expression\n• None convert it to a lambda function using\n• None use a numerical library such as SciPy to generate numerical solutions\n\nSubstitute the Result Into an Expression¶ The best practice is to use to substitute numerical values into expressions. The following code demonstrates that the numerical value is not an exact root because substituting it back into the expression produces a result slightly different from zero: Using can give an incorrect result due to precision errors, here effectively rounding to zero: When substituting in values, you can also leave some symbols as variables:\n\nNot all Equations Can be Solved¶ is a numerical solving function, so it can often provide a solution for equations which cannot be solved algebraically. Some equations have no solution, in which case SymPy may return an error. For example, the equation \\(e^x = 0\\) ( in SymPy) has no solution: : Could not find root within given tolerance. (5.4877893607115270300540019e-18 > 1.6543612251060553497428174e-24) Try another starting point or tweak arguments."
    },
    {
        "link": "https://geeksforgeeks.org/python-sympy-solve-method",
        "document": "With the help of method, we can solve the mathematical equations easily and it will return the roots of the equation that is provided as parameter using method.\n\nExample #1 :\n\n In this example we can see that by using method, we can solve the mathematical expressions and this will return the roots of that equation."
    }
]