[
    {
        "link": "https://pythonguis.com/pyqt5-tutorial",
        "document": "PyQt is a Python library for creating GUI applications using the Qt toolkit. Created by Riverbank Computing, PyQt is free software (GPL licensed) and has been in development since 1999. PyQt5 was released in 2016 and last updated in October 2021.\n\nThis complete PyQt5 tutorial takes you from first concepts to building fully-functional GUI applications in Python. It requires some basic Python knowledge, but no previous familiarity with GUI concepts. Everything will be introduced step by by step, using hands-on examples.\n\nPyQt5 is the Qt5-based edition of the Python GUI library PyQt from Riverbank Computing.\n\nThere are two major versions currently in use: PyQt5 based on Qt5 and PyQt6 based on Qt6. Both versions are almost completely compatible aside from imports. PyQt6 also makes some changes to how namespaces and flags work, but these are easily manageable.\n\nLooking for something else? I also have a PyQt6 tutorial, PySide2 tutorial and PySide6 tutorial.\n\nThis track consists of 36 tutorials. Keep checking back as I'm adding new tutorials regularly — last updated ."
    },
    {
        "link": "https://build-system.fman.io/pyqt5-tutorial",
        "document": "This PyQt5 tutorial shows how to use Python 3 and Qt to create a GUI on Windows, Mac or Linux. It even covers creating an installer for your app.\n\nPyQt is a library that lets you use the Qt GUI framework from Python. Qt itself is written in C++. By using it from Python, you can build applications much more quickly while not sacrificing much of the speed of C++.\n\nPyQt5 refers to the most recent version 5 of Qt. You may still find the occasional mention of (Py)Qt4 on the web, but it is old and no longer supported.\n\nAn interesting new competitor to PyQt is Qt for Python. Its API is virtually identical. Unlike PyQt, it is licensed under the LGPL and can thus be used for free in commercial projects. It's backed by the Qt company, and thus likely the future. We use PyQt here because it is more mature. Since the APIs are so similar, you can easily switch your apps to Qt for Python later.\n\nThe best way to manage dependencies in Python is via a virtual environment. A virtual environment is simply a local directory that contains the libraries for a specific project. This is unlike a system-wide installation of those libraries, which would affect all of your other projects as well.\n\nTo create a virtual environment in the current directory, execute the following command:\n\nThis creates the folder. To activate the virtual environment on Windows, run:\n\nOn Mac and Linux, use:\n\nYou can see that the virtual environment is active by the prefix in your shell:\n\nTo now install PyQt, issue the following command:\n\nTime to write our very first GUI app! With the virtual environment still active, start Python. We will execute the following commands:\n\nFirst, we tell Python to load PyQt via the import statement:\n\nNext, we create a with the command:\n\nThis is a requirement of Qt: Every GUI app must have exactly one instance of . Many parts of Qt don't work until you have executed the above line. You will therefore need it in virtually every (Py)Qt app you write.\n\nThe brackets in the above line represent the command line arguments passed to the application. Because our app doesn't use any parameters, we leave the brackets empty.\n\nNow, to actually see something, we create a simple label:\n\nThen, we tell Qt to show the label on the screen:\n\nDepending on your operating system, this already opens a tiny little window:\n\nThe last step is to hand control over to Qt and ask it to \"run the application until the user closes it\". This is done via the command:\n\nIf all this worked as expected then well done! You've just built your first GUI app with Python and Qt.\n\nEverything you see in a (Py)Qt app is a widget: Buttons, labels, windows, dialogs, progress bars etc. Like HTML elements, widgets are often nested. For example, a window can contain a button, which in turn contains a label.\n\nThe following screenshot shows the most common Qt widgets:\n\nYou can download the code for the app shown in the screenshot here, if you are interested.\n\nLike the example above, your GUI will most likely consist of multiple widgets. In this case, you need to tell Qt how to position them. For instance, you can use QVBoxLayout to stack widgets vertically:\n\nThe code for this screenshot is:\n\nAs before, we instantiate a . Then, we create a . We use the most basic type for it because it merely acts as a container and we don't want it to have any special behavior. Next, we create the and add two s to it. Finally, we tell the window to use this layout (and thus its contents). As in our first application, we end with calls to and .\n\nThere are of course many other kinds of layouts (eg. QHBoxLayout to lay out items in a row). See Qt's documentation for an overview.\n\nOne of Qt's strengths is its support for custom styles. There are many mechanisms that let you customize the look and feel of your application. This section outlines a few.\n\nThe coarsest way to change the appearance of your application is to set the global Style. Recall the widgets screenshot above:\n\nThis uses a style called . If you use the style instead, then it looks as follows:\n\nThe available styles depend on your platform but are usually , , (Windows only) and (Mac only).\n\nIf you like a style, but want to change its colors (eg. to a dark theme), then you can use QPalette and . For example:\n\nThis changes the text color in buttons to red:\n\nFor a dark theme of the Fusion style, see here.\n\nIn addition to the above, you can change the appearance of your application via style sheets. This is Qt's analogue of CSS. We can use this for example to add some spacing:\n\nFor more information about style sheets, please see Qt's documentation.\n\nQt uses a mechanism called signals to let you react to events such as the user clicking a button. The following example illustrates this. It contains a button that, when clicked, shows a message box:\n\nThe interesting line is highlighted above: is a signal, lets us install a so-called slot on it. This is simply a function that gets called when the signal occurs. In the above example, our slot shows a message box.\n\nThe term slot is important when using Qt from C++, because slots must be declared in a special way in C++. In Python however, any function can be a slot – we saw this above. For this reason, the distinction between slots and \"normal\" functions has little relevance for us.\n\nSignals are ubiquitous in Qt. And of course, you can also define your own. This however is beyond the scope of this tutorial.\n\nYou now have the basic knowledge for creating a GUI that responds to user input. Say you've written an app. It runs on your computer. How do you give it to other people, so they can run it as well?\n\nYou could ask the users of your app to install Python and PyQt like we did above, then give them your source code. But that is very tedious (and usually impractical). What we want instead is a standalone version of your app. That is, a binary executable that other people can run on their systems without having to install anything.\n\nIn the Python world, the process of turning source code into a self-contained executable is called freezing. Although there are many libraries that address this issue – such as PyInstaller, py2exe, cx_Freeze, bbfreze, py2app, ... – freezing PyQt apps has traditionally been a surprisingly hard problem.\n\nWe will use a new library called fbs that lets you create standalone executables for PyQt apps. To install it, enter the command:\n\nThen, execute the following:\n\nThis prompts you for a few values:\n\nWhen you type in the suggested command, an empty window should open:\n\nThis is a PyQt5 app just like the ones we have seen before. Its source code is in in your current directory. But here's the cool part: We can use fbs to turn it into a standalone executable!\n\nThis places a self-contained binary in the folder of your current directory. You can send it to your friends (with the same OS as yours) and they will be able to run your app!\n\n(Please note that the free version of fbs only supports Python 3.5 or 3.6. If you have a different version, please install one of these supported Python versions or buy fbs Pro).\n\nfbs also lets you create an installer for your app via the command :\n\nFor more information on how you can use fbs for your existing application, please see this article. Or fbs's tutorial.\n\nIf you have made it this far, then big congratulations. Hopefully, you now have a good idea of how PyQt (and its various parts) can be used to write a desktop application with Python. We also saw how fbs lets you create standalone executables and installers.\n\nDue to the popularity of this article, I wrote a PyQt6 book.\n\nThe book explains in more detail how you can create your own apps. Even Phil Thompson, the creator of PyQt, read the book and said it's \"very good\". So check it out!"
    },
    {
        "link": "https://wiki.python.org/moin/PyQt",
        "document": ""
    },
    {
        "link": "https://realpython.com/python-pyqt-gui-calculator",
        "document": "Even though web and mobile applications appear to have taken over the software development market, there’s still demand for traditional graphical user interface (GUI) desktop applications. If you’re interested in building these kinds of applications in Python, then you’ll find a wide variety of libraries to choose from. They include Tkinter, wxPython, PyQt, PySide, and a few others.\n\nIn this tutorial, you’ll learn the basics of building GUI desktop applications with Python and PyQt.\n\nIn this tutorial, you’ll learn how to:\n• Connect the user’s events on the app’s GUI with the app’s logic\n\nFor this tutorial, you’ll create a calculator app with Python and PyQt. This short project will help you grasp the fundamentals and get you up and running with this GUI library.\n\nYou can download the source code for the project and all examples in this tutorial by clicking on the link below:\n\nYou have several options for installing PyQt on your system or development environment. The recommended option is to use to use binary wheels. Wheels are the standard way to install Python packages from the Python package index, PyPI. In any case, you need to consider that wheels for PyQt6 are only available for Python 3.6.1 and later. There are wheels for Linux, macOS, and Windows (64-bit). All of these wheels include copies of the corresponding Qt libraries, so you won’t need to install them separately. Another installation option is to build PyQt from source. This can be a bit complicated, so you might want to avoid it if possible. If you really need to build from source, then check out what the library’s documentation recommends in those cases. Alternatively, you have the option of using package managers, such as APT on Linux or Homebrew on macOS, to install PyQt6. In the next few sections, you’ll go through some of the options for installing PyQt6 from different sources and on different platforms. Most of the time, you should create a Python virtual environment to install PyQt6 in an isolated way. To create a virtual environment and install PyQt6 in it, run the following on your command line: Here, you first create a virtual environment using the module from the standard library. Then you activate it, and finally you install PyQt6 in it using . Note that you must have Python 3.6.1 or later for the install command to work correctly. You’ll rarely need to install PyQt directly on your system Python environment. If you ever need to do this kind of installation, then run the following command on your command line or in your terminal window without activating any virtual environment: With this command, you’ll install PyQt6 in your system Python environment directly. You can start using the library immediately after the installation finishes. Depending on your operating system, you may need root or administrator privileges for this installation to work. Even though this is a fast way to install PyQt6 and start using it right away, it’s not the recommended approach. The recommended approach is to use a Python virtual environment, as you learned in the previous section. Several Linux distributions include binary packages for PyQt6 in their repositories. If this your case, then you can install the library using the distribution’s package manager. On Ubuntu, for example, you can use the following command: With this command, you’ll install PyQt6 and all of its dependencies in your base system, so you can use the library in any of your GUI projects. Note that root privileges are needed, which you invoke here with the command. If you’re a macOS user, then you can install PyQt6 using the Homebrew package manager. To do this, open a terminal and run the following command: After running this command, you’ll have PyQt6 installed on your Homebrew Python environment, and it’ll be ready for you to use. If you use a package manager on Linux or macOS, then there’s a chance you won’t get the latest version of PyQt6. A installation will be better if you want to ensure that you have the latest release.\n\nNow that you have a working PyQt installation, you’re ready to create your first GUI app. You’ll create a application with Python and PyQt. Here are the steps that you’ll follow:\n• Import and all the required widgets from . You can download the source code for the examples that you’ll code in this section by clicking the link below: Download Code: Click here to download the code that you’ll use to build a calculator in Python with PyQt in this tutorial. To kick things off, start by creating a new file called in your current working directory: \"\"\"Simple Hello, World example with PyQt6.\"\"\" # 1. Import QApplication and all the required widgets First, you import , which will allow you to handle the application’s termination and exit status through the function. Then you import , , and from , which is part of the package. With these imports, you’re done with step one. To complete step two, you just need to create an instance of . Do this as you would create an instance of any Python class: In this line of code, you create the instance of . You should create your instance before you create any GUI object in PyQt. Internally, the class deals with command-line arguments. That’s why you need to pass in a list of command-line arguments to the class constructor. In this example, you use an empty list because your app won’t be handling any command-line arguments. Note: You’ll often find that developers pass to the constructor of . This object contains the list of command-line arguments passed into a Python script. If your application needs to accept command-line arguments, then you should use to handle them. Otherwise, you can just use an empty list, like you did in the above example. Step three involves creating the application’s GUI. In this example, your GUI will be based on the class, which is the base class of all user interface objects in PyQt. Here’s how you can create the app’s GUI: In this code, is an instance of , which provides all the features that you’ll need to create the application’s window, or form. As its names suggests, sets the window’s title in your application. In this example, the app’s window will show as its title. Note: More precisely, this step requires you to create the app’s top-level or main window. The term application’s GUI is a bit generic. Typically, an application’s GUI consists of more than one window. You can use to define the window’s size and screen position. The first two arguments are the and screen coordinates where the window will be placed. The third and fourth arguments are the window’s and . Every GUI application needs widgets, or graphical components that make the app’s GUI. In this example, you use a widget, , to show the message on your application’s window. objects can display HTML-formatted text, so you can use the HTML element to provide the desired text as an header. Finally, you use to place at the coordinates on the application’s window. Note: In PyQt, you can use any widget—a subclass of —as a top-level window. The only condition is that the target widget must not have a widget. When you use a widget as your top-level window, PyQt automatically provides it with a title bar and turns it into a normal window. The parent-child relationship between widgets has two complementary purposes. A widget with no is considered a main or top-level window. In contrast, a widget with an explicit is a child widget, and it’s shown within its parent. This relationship is also known as ownership, with parents owning their children. The PyQt ownership model ensures that if you delete a parent widget, such as your top-level window, then all of its child widgets will automatically be deleted as well. To avoid memory leaks, you should always make sure that any object has a parent, with the sole exception of your top-level windows. You’re done with step three, so you can continue with the final two steps and get your PyQt GUI application ready to run: In this code snippet, you call on . The call to schedules a paint event, which is a request to paint the widgets that compose a GUI. This event is then added to the application’s event queue. You’ll learn more about PyQt’s event loop in a later section. Finally, you start the application’s event loop by calling . The call to is wrapped in a call to , which allows you to cleanly exit Python and release memory resources when the application terminates. You can run your first PyQt app with the following command: When you run this script, you’ll see a window that’ll look something like this: Your application shows a window based on . The window displays the message. To show the message, it uses a widget. And with that, you’ve written your first GUI desktop application using PyQt and Python! Isn’t that cool?\n\nYou’ll need to master the basic components of PyQt if you want to proficiently use this library to develop your GUI applications. Some of these components include: These elements are the building blocks of any PyQt GUI application. Most of them are represented as Python classes that live in the module. These elements are extremely important. You’ll learn more about them in the following few sections. Widgets are rectangular graphical components that you can place on your application’s windows to build the GUI. Widgets have several attributes and methods that allow you to tweak their appearance and behavior. They can also paint a representation of themselves on the screen. Widgets also detect mouse clicks, keypresses, and other events from the user, the window system, and other sources. Each time a widget catches an event, it emits a signal to announce its state change. PyQt has a rich and modern collection of widgets. Each of those widgets serves a different purpose. Some of the most common and useful PyQt widgets are: First up is the button. You can create a button by instantiating , a class that provides a classic command button. Typical buttons are , , , , , and . Here’s how they look on a Linux system: Buttons like these are perhaps the most commonly used widgets in any GUI. When someone clicks them, your app commands the computer to perform actions. This is how you can execute computations when a user clicks a button. Up next are labels, which you can create with . Labels let you display useful information as text or images: You’ll use labels like these to explain how to use your app’s GUI. You can tweak a label’s appearance in several ways. A label can even accept HTML-formatted text, as you saw earlier. You can also use labels to specify a keyboard shortcut to move the cursor focus to a given widget on your GUI. Another common widget is the line edit, also known as the input box. This widget allows you to enter a single line of text. You can create line edits with the class. Line edits are useful when you need to get the user’s input as plain text. Here’s how line edits look on a Linux system: Line edits like these automatically provide basic editing operations like copy, paste, undo, redo, drag, drop, and so on. In the above figure, you can also see that the objects on the first row show placeholder text to inform the user what kind of input is required. Combo boxes are another fundamental type of widget in GUI applications. You can create them by instantiating . A combo box will present your user with a dropdown list of options in a way that takes up minimal screen space. Here’s an example of a combo box that provides a dropdown list of popular programming languages: This combo box is read-only, which means that users can select one of several options but can’t add their own options. Combo boxes can also be editable, allowing users to add new options on the fly. Combo boxes can also contain pixmaps, strings, or both. The last widget that you’ll learn about is the radio button, which you can create with . A object is an option button that you can click to switch on. Radio buttons are useful when you need the user to select one of many options. All options in a radio button are visible on the screen at the same time: In this radio buttons group, only one button can be checked at a given time. If the user selects another radio button, then the previously selected button will switch off automatically. PyQt has a large collection of widgets. At the time of this writing, there are over forty available for you to use to create your application’s GUI. Here, you’ve studied only a small sample. However, that’s enough to show you the power and flexibility of PyQt. In the next section, you’ll learn how to lay out different widgets to build modern and fully functional GUIs for your applications. Now that you know about widgets and how they’re used to build GUIs, you need to know how to arrange a set of widgets so that your GUI is both coherent and functional. In PyQt, you’ll find a few techniques for laying out the widgets on a form or window. For instance, you can use the and methods to give widgets absolute sizes and positions. However, this technique can have some drawbacks. You’ll have to:\n• Do many manual calculations to determine the correct size and position of every widget\n• Do extra calculations to respond to window resize events\n• Redo most of your calculations when the window’s layout changes in any way Another technique involves using to calculate the widget’s size and position dynamically. In this case, you’ll have similar headaches as with the previous technique. The most effective and recommended technique is to use PyQt’s layout managers. They’ll increase your productivity, mitigate the risk of errors, and improve your code’s maintainability. Layout managers are classes that allow you to size and position your widgets on the application’s window or form. They automatically adapt to resize events and GUI changes, controlling the size and position of all their child widgets. Note: If you develop internationalized applications, then you’ve probably seen translated text get cut off mid-sentence. This is likely to happen when the target natural language is more verbose than the original one. Layout managers can help you prevent this common issue by automatically adjusting the widget size to the available space. However, this feature can sometimes fail with particularly wordy natural languages. The first layout manager class, , arranges widgets horizontally from left to right, like with the hypothetical widgets in the following figure: In the horizontal layout, the widgets will appear one next to the other, starting from the left. The code example below shows how to use to arrange three buttons horizontally: Here’s how this example creates a horizontal layout of buttons:\n• Lines 19 to 21 add three buttons to by calling the method.\n• Line 22 sets as your window’s layout with . When you run from your command line, you’ll get the following output: The above figure shows three buttons in a horizontal arrangement. The buttons are shown from left to right in the same order as you added them in your code. The next layout manager class is , which arranges widgets vertically from top to bottom, like in the following figure: Each new widget will appear beneath the previous one. This layout allows you to to construct vertical layouts and organize your widgets from top to bottom on your GUI. Here’s how you can create a object containing three buttons: On line 18, you create an instance of called . In the next three lines, you add three buttons to . Finally, you use the object to arrange the widget in a vertical layout through the method on line 22. When you run this sample application, you’ll get a window that looks something like this: This figure shows three buttons in a vertical arrangement, one below the other. The buttons appear in the same order as you added them to your code, from top to bottom. The third layout manager in your list is . This class arranges widgets in a grid of rows and columns. Every widget will have a relative position on the grid. You can define a widget’s position with a pair of coordinates like . Each coordinate must be an integer number. These pairs of coordinates define which cell on the grid a given widget will occupy. The grid layout will look something like this: takes the available space, divides it up into and , and puts each child widget into its own cell. Here’s how to create a grid layout arrangement in your GUI: In this example, you create an application that uses a object to organize its widgets on the screen. Note that, in this case, the second and third arguments that you pass to are integer numbers defining each widget’s position on the grid. On lines 26 to 28, you pass two more arguments to . These arguments are and , and they’re the fourth and fifth arguments passed to the function. You can use them to make a widget occupy more than one row or column, like you did in the example. If you run this code from your command line, then you’ll get a window that looks something like this: In this figure, you can see your widgets arranged in a grid of rows and columns. The last widget occupies two columns, as you specified on lines 26 to 28. The last layout manager that you’ll learn about is . This class arranges widgets in a two-column layout. The first column usually displays messages in labels. The second column generally contains widgets like , , , and so on. These allow the user to enter or edit data regarding the information in the first column. The following diagram shows how form layouts work in practice: The left column consists of labels, while the right column consists of input widgets. If you’re developing a database application, then this kind of layout can be a useful tool that’ll increase your productivity when creating input forms. The following example shows how to create an application that uses a object to arrange its widgets: Lines 18 to 23 do the hard work in this example. has a convenient method called . You can use this method to add a two-widget row to the layout. The first argument to should be a label or a string. Then, the second argument can be any widget that allows the user to enter or edit data. In this specific example, you’ve used line edits. If you run this code, then you’ll get a window that looks something like this: The above figure shows a window that uses a form layout. The first column contains labels to ask the user for some information. The second column shows widgets that allow the user to enter or edit the required information. With PyQt, you can develop two types of GUI desktop applications. Depending on the class that you use to create the main form or window, you’ll have one of the following: You’ll start with dialog-style applications first. In the next section, you’ll learn about main window–style applications. To develop a dialog-style application, you need to create a GUI class that inherits from , which is the base class of all dialog windows. A dialog window is a stand-alone window that you can use as the main window for your application. Note: Dialog windows are commonly used in main window–style applications for brief communication and interaction with the user. When you use dialog windows to communicate with the user, those dialogs can be:\n• Modal: Blocks input to any other visible windows in the same application. You can display a modal dialog by calling its method.\n• Modeless: Operates independently from other windows in the same application. You can display a modeless dialog by using its method. Dialog windows can also provide a return value and have default buttons, such as and . A dialog is always an independent window. If a dialog has a , then it’ll display centered on top of the parent widget. Dialogs with a parent will share the parent’s task bar entry. If you don’t set for a given dialog, then the dialog will get its own entry in the system’s task bar. Here’s an example of how you’d use to develop a dialog-style application: This application is a bit more elaborate. Here’s what this code does:\n• Line 16 defines a class for the app’s GUI by inheriting from .\n• Line 18 calls the parent class’s method using . This call allows you to properly initialize instances of this class. In this example, the argument is set to because this dialog will be your main window.\n• Line 26 calls on . This call embeds the form layout into the global dialog layout.\n• Line 27 defines a button box, which provides a convenient space to display the dialog’s buttons.\n• Lines 28 to 31 add two standard buttons, and , to the dialog.\n• Line 32 adds the button box to the dialog by calling . The construct wraps up the app’s main code. This kind of conditional statement is common in Python apps. It ensures that the indented code will only run if the containing file is executed as a program rather than imported as a module. For more about this construct, check out What Does if name == “main” Do in Python?. Note: On line 26 in the above example, you’ll note that layout managers can be nested inside one another. You can nest layouts by calling on the container layout with the nested layout as an argument. The above code example will show a window that looks something like this: This figure shows the GUI that you’ve created using a object to arrange the widgets and a layout for the application’s global layout. Most of the time, your GUI applications will be main window–style apps. This means that they’ll have a menu bar, some toolbars, a status bar, and a central widget that’ll be the GUI’s main element. It’s also common for your apps to have several dialogs to accomplish secondary actions that depend on a user’s input. You’ll inherit from to develop main window–style applications. An instance of a class that derives from is considered the app’s main window and should be unique. provides a framework for building your application’s GUI quickly. This class has its own built-in layout, which accepts the following graphical components: One or more toolbars Hold tool buttons and other widgets, such as , , and more Holds the window’s central widget, which can be of any type, including a composite widget One or more dock widgets You can’t create a main window without a central widget. You need a central widget even if it’s just a placeholder. When this is the case, you can use a object as your central widget. You can set the window’s central widget with the method. The main window’s layout will allow you to have only one central widget, but it can be a single or a composite widget. The following code example shows you how to use to create a main window–style application:\n• Line 17 calls the base class’s initializer. Again, the argument is set to because this is your app’s main window, so it must not have a parent.\n• Lines 20 to 22 call non-public methods to create different GUI elements:\n• Lines 24 to 26 create the main menubar with a drop-down menu called Menu. This menu will have a menu option to exit the app.\n• Lines 28 to 31 create the toolbar, which will have a toolbar button to exit the app. When you implement GUI components using their own methods, like you did with the menu bar, toolbar, and status bar in this example, you’re making your code more readable and more maintainable. Note: If you’re running this example on macOS, then you may have issues with the app’s main menu. macOS hides certain menu options, like Exit. Remember that macOS shows the Exit or Quit option under the app’s entry on the top of the screen. When you run the above sample application, you’ll get a window like the following: As you can confirm, your main window–style application has the following components:\n• One toolbar with an Exit tool button\n• One central widget consisting of a object with a text message\n• One status bar at the window’s bottom That’s it! You’ve learned how to build a main window–style application with Python and PyQt. Up to this point, you’ve learned about some of the more important graphical components in PyQt’s set of widgets. In the next few sections, you’ll study other important concepts related to building GUI applications with PyQt. is the most foundational class that you’ll use when developing PyQt GUI applications. This class is the core component of any PyQt application. It manages the application’s control flow as well as its main settings. In PyQt, any instance of is an application. Every PyQt GUI application must have one instance. Some of the responsibilities of this class include:\n• Providing access to global information, such as the application’s directory, screen size, and so on\n• Defining the application’s look and feel These are just some of the core responsibilities of . So, this is a fundamental class when it comes to developing PyQt GUI applications. One of the most important responsibilities of is to provide the event loop and the entire event handling mechanism. In the following section, you’ll take a closer look at what the event loop is and how it works. GUI applications are event-driven. This means that functions and methods are called in response to user actions, like clicking on a button, selecting an item from a combo box, entering or updating the text in a text edit, pressing a key on the keyboard, and so on. These user actions are commonly known as events. Events are handled by an event loop, also known as a main loop. An event loop is an infinite loop in which all events from the user, the window system, and any other sources are processed and dispatched. The event loop waits for an event to occur and then dispatches it to perform some task. The event loop continues to work until the application is terminated. All GUI applications have an event loop. When an event happens, then the loop checks if it’s a terminate event. In that case, the loop finishes, and the application exits. Otherwise, the event is sent to the application’s event queue for further processing, and the loop iterates again. In PyQt6, you can run the app’s event loop by calling on the object. For an event to trigger an action, you need to connect the event with the action that you want to execute. In PyQt, you can establish that connection with the signals and slots mechanism, which you’ll explore in the next section. PyQt widgets act as event-catchers. This means that every widget can catch specific events, like mouse clicks, keypresses, and so on. In response to these events, a widget emits a signal, which is a kind of message that announces a change in its state. The signal on its own doesn’t perform any action. If you want a signal to trigger an action, then you need to connect it to a slot. This is the function or method that’ll perform an action whenever its associated signal is emitted. You can use any Python callable as a slot. If a signal is connected to a slot, then the slot is called whenever the signal is emitted. If a signal isn’t connected to any slot, then nothing happens and the signal is ignored. Some of the most relevant features of signals and slots include the following:\n• A signal can be connected to one or many slots.\n• A signal may also be connected to another signal.\n• A slot may be connected to one or many signals. You can use the following syntax to connect a signal and a slot: This will connect to . From now on, whenever is emitted, will be called. The code below shows how to use the signals and slots mechanism in a PyQt application: On line 15, you create , which you’ll use as a slot. Then in line 27, you connect the button’s signal to . This way, whenever the user clicks the Greet button, the slot is called and the label object’s text alternates between and an empty string: When you click the Greet button, the message appears and disappears on your application’s main window. Note: Every widget has its own set of predefined signals. You can check them out on the widget’s documentation. If your slot function needs to receive extra arguments, then you can pass them using . For example, you can modify to take an argument, like in the following code: Now needs to receive an argument called . If you want to connect this new version of to the signal, then you can do something like this: For this code to work, you need to import from first. The call to returns a function object that behaves similarly to when called with . Now, when the user clicks on the button, the message will appear in the label just like before. Note: You can also use a function to connect a signal to a slot that requires extra arguments. As an exercise, try to code the above example using instead of . The signals and slots mechanism is what you’ll use to give life to your PyQt GUI applications. This mechanism will allow you to turn user events into concrete actions. You can dive deeper into signals and slots by checking out the PyQt6 documentation on the topic. Now you know the basics of several important concepts of PyQt. With this knowledge and the library’s documentation at hand, you’re ready to start developing your own GUI applications. In the next section, you’ll build your first fully functional GUI application.\n\nIn this section, you’ll develop a calculator GUI app using the Model-View-Controller (MVC) design pattern. This pattern has three layers of code, with each one having different roles:\n• The model takes care of your app’s business logic. It contains the core functionality and data. In your calculator app, the model will handle the input values and the calculations.\n• The view implements your app’s GUI. It hosts all the widgets that the end user would need to interact with the application. The view also receives a user’s actions and events. For your example, the view will be the calculator window on your screen.\n• The controller connects the model and the view to make the application work. Users’ events, or requests, are sent to the controller, which puts the model to work. When the model delivers the requested result, or data, in the right format, the controller forwards it to the view. In your calculator app, the controller will receive the target math expressions from the GUI, ask the model to perform calculations, and update the GUI with the result. Here’s a step-by-step description of how your GUI calculator app will work:\n• The user performs an action or request (event) on the view (GUI).\n• The view notifies the controller about the user’s action.\n• The controller gets the user’s request and queries the model for a response.\n• The model processes the controller’s query, performs the required computations, and returns the result.\n• The controller receives the model’s response and updates the view accordingly.\n• The user finally sees the requested result on the view. You’ll use this MVC design to build your calculator app with Python and PyQt. Creating the Skeleton for Your PyQt Calculator App To kick things off, you’ll start by implementing a minimal skeleton for your application in a file called . You can get this file and the rest of the source code for your calculator app by clicking the link below: Download Code: Click here to download the code that you’ll use to build a calculator in Python with PyQt in this tutorial. If you’d prefer to code the project on your own, then go ahead and create in your current working directory. Open the file in your favorite code editor or IDE and type the following code: \"\"\"PyCalc is a simple calculator built with Python and PyQt.\"\"\" This script implements all the boilerplate code that you’ll need to run a basic GUI application. You’ll use this skeleton to build your calculator app.\n• Line 5 imports . This module provides the function, which you’ll use to cleanly terminate the app.\n• Line 9 creates a Python constant to hold a fixed window size in pixels for your calculator app.\n• Line 11 creates the class to provide the app’s GUI. Note that this class inherits from .\n• Line 15 calls on the super class for initialization purposes.\n• Line 17 uses to give the window a fixed size. This ensures that the user won’t be able to resize the window during the app’s execution.\n• Lines 18 and 19 create a object and set it as the window’s central widget. This object will be the parent of all the required GUI components in your calculator app.\n• Line 21 defines your calculator’s main function. Having a function like this is a best practice in Python. This function provides the application’s entry point. Inside , your program does the following:\n• Line 24 creates an instance of the app’s window, .\n• Line 25 shows the GUI by calling on the window object. Finally, line 29 calls to execute your calculator app. When you run the above script, the following window appears on your screen: That’s it! You’ve successfully built a fully functional app skeleton for your GUI calculator app. Now you’re ready to continue building the project. The GUI that you have at this point doesn’t really look like a calculator. You need to finish this GUI by adding a display to show the target math operation and a keyboard of buttons representing numbers and basic math operators. You’ll also add buttons representing other required symbols and actions, like clearing the display. First, you need to update your imports like in the code below: You’ll use a layout manager for the calculator’s global layout. To arrange the buttons, you’ll use a object. The class will work as the calculator’s display and will provide the required buttons. Now you can update the initializer for : You’ve added the highlighted lines of code. You’ll use as the app’s general layout. In this layout, you’ll place the display at the top and the keyboard buttons in a grid layout at the bottom. The calls to and won’t work at this point, because you haven’t implemented those methods yet. To fix this issue, you’ll start by coding . Get back to your code editor and update like in the following code: In this code snippet, you first define a new constant to hold the display height in pixels. Then you define inside . To create the calculator’s display, you use a widget. Then you set a fixed height of thirty-five pixels for your display using the constant. The display will have its text right-aligned. Finally, the display will be read-only to prevent direct editing by the user. The last line of code adds the display to the calculator’s general layout. Next up, you’ll implement the method to create the required buttons for your calculator’s keyboard. These buttons will live in a grid layout, so you need a way to represent their coordinates on the grid. Each coordinate pair will consist of a row and a column. To represent a coordinate pair, you’ll use a list of lists. Each nested list will represent a row. Now go ahead and update the file with the following code: In this piece of code, you define a new constant called . You’ll use this constant to provide the size of your calculator’s buttons. In this specific example, all the buttons will have a square shape with forty pixels per side. With this initial setup, you can code the method. You’ll use a list of lists to hold the keys or buttons and their position on the calculator keyboard. A will allow you to arrange the buttons on the calculator’s window: You first create the empty dictionary to hold the calculator buttons. Then, you create a list of lists to store the key labels. Each row or nested list will represent a row in the grid layout, while the index of each key label will represent the corresponding column on the layout. Then you define two loops. The outer loop iterates over the rows and the inner loop iterates over the columns. Inside the inner loop, you create the buttons and add them to both and . Every button will have a fixed size of pixels, which you set with and the constant. Finally, you embed the grid layout into the calculator’s general layout by calling on the object. Note: When it comes to widget size, you’ll rarely find measurement units in the PyQt documentation. The measurement unit is assumed to be pixels, except when you’re working with class, which uses points. Now your calculator’s GUI will show the display and the buttons gracefully. However, you have no way to update the information shown on the display. You’ll fix this by adding a few extra methods to : These methods will provides the GUI’s public interface and complete the view class for your Python calculator app. Here’s a breakdown of what each method does:\n• uses to set and update the display’s text. It also uses to set the cursor’s focus on the display.\n• is a getter method that returns the display’s current text. When the user clicks the equal sign ( ) on the calculator’s keyboard, the app will use the return value of as the math expression to be evaluated.\n• sets the display’s text to an empty string ( ) so that the user can introduce a new math expression. This method will be triggered every time the user presses the C button on the calculator’s board. Now your calculator’s GUI is ready for use! When you run the application, you’ll get a window like the following: You’ve completed the calculator’s GUI, which looks pretty sleek! However, if you try to do some calculations, then the calculator won’t respond as expected. That’s because you haven’t implemented the model and the controller components. In the next section, you’ll write the calculator’s model. In the MVC pattern, the model is the layer of code that takes care of the business logic. In your calculator app, the business logic is all about basic math calculations. So, your model will evaluate the math expressions that your users introduced in the calculator’s GUI. The calculator’s model also needs to handle errors. To this end, you’ll define the following global constant: This constant is the message that the user will see on the calculator’s display if they introduce an invalid math expression. With the above change, you’re ready to code your app’s model, which will be a single function in this example: In , you use to evaluate a math expression that comes as a string. If the evaluation is successful, then you return . Otherwise, you return the predefined error message. Note that this function isn’t perfect. It has a couple of important issues:\n• The … block doesn’t catch a specific exception, so it’s using a practice that’s discouraged in Python.\n• The function uses , which can lead to some serious security issues. You’re free to rework the function to make it more reliable and secure. In this tutorial, you’ll use the function as is to keep the focus on implementing the GUI. Creating the Controller Class for Your Calculator In this section, you’re going to code the calculator’s controller class. This class will connect the view to the model that you just coded. You’ll use the controller class to make the calculator perform actions in response to user events. Your controller class needs to perform three main tasks:\n• Connect all the buttons’ signals with the appropriate slots. To perform all these actions, you’ll code a new class in a moment. Go ahead and update with the following code: At the top of , you import from . You’ll use this function to connect signals with methods that need to take extra arguments. Inside , you define the class initializer, which takes two arguments: the app’s model and its view. Then you store these arguments in appropriate instance attributes. Finally, you call to make all the required connections of signals and slots. In , you use to evaluate the math expression that the user has just typed into the calculator’s display. Then you call on the calculator’s view to update the display text with the computation result. As its name suggests, the method takes care of building the target math expression. To do this, the method concatenates the initial display value with every new value that the user enters on the calculator’s keyboard. Finally, the method connects all the buttons’ signals with the appropriate slots method in the controller class. That’s it! Your controller class is ready. However, for all this code to work as a real calculator, you need to update the app’s function like in the code below: This piece of code creates a new instance of . The argument to the class constructor holds a reference to the function, while the argument holds a reference to the object, which provides the app’s GUI. Now your PyQt calculator application is ready to run. Now that you’ve finished writing your calculator app with Python and PyQt, it’s time for a live test! If you run the application from your command line, then you’ll get something like this: To use PyCalc, enter a valid math expression with your mouse. Then, press or click the equal sign ( ) button to compute and show the expression result on the calculator’s display. That’s it! You’ve developed your first fully functional GUI desktop application with Python and PyQt!"
    },
    {
        "link": "https://stackoverflow.com/questions/60422323/where-is-the-pyqt5-documentation-for-classes-methods-and-modules",
        "document": "pyqt5 being a qt5 binding has almost all the functionalities (there are minimal known incompatibilities) so the qt5 documentation: https://doc.qt.io/ is valid for pyqt5 except for small exceptions.\n\nAlthough the target of the documentation is c++ the description of the classes and methods are generic, so they also validly apply for pyqt5, on the other hand many of the examples are written in c++ but the translation to python in many cases is trivial .\n\nSo to avoid doing a double task it seems that Riverbank Computing Limited only documents the exceptions indicated in the pyqt5 docs: https://www.riverbankcomputing.com/static/Docs/PyQt5/\n\nThe next part of my answer will propose tips to handle the Qt documentation.\n\nThe Qt documentation also has an easy to understand structure, for example let's analyze the QPushButton class (https://doc.qt.io/qt-5/qpushbutton.html):\n\nAt the top there is a table:\n\nThis table indicates how to include the class in a C++ project, how to add it to qmake, from which class it inherits, and which classes inherit from it. From the above, relevant information for PyQt5 can be extracted, such as to which sub-module the class belongs to: In this case we use that inform us that it belongs to the sub-module, in general if belongs to (camelcase)\n\nIf you want to know all the methods of the QPushButton class, you must use the \"List of all members, including inherited members\" link below the table, in this case the link will be https://doc.qt.io/qt-5/qpushbutton-members.html where is the complete list of all class methods, enumerations, etc.\n\nOther tips to understand the conversion between Qt/C++ and PyQt5/Python are:\n• None Some methods use pointers to receive information such as: those transformed to PyQt5 as:\n• None Some methods collide with reserved words such as , , , etc so to avoid incompatibilities, the underscore is added at the end: , , , etc\n• None In Qt, the Q_SLOT and Q_SIGNAL that are translated into python are used through the @pyqtSlot and @pyqtSignal decorators.\n\nIn conclusion, my recommendation is that you use the Qt and PyQt5 documentation at the same time to know all the functionalities, in addition there are many Q&A in SO about translations from one language to another so you could learn from there.\n\nThe Qt documentation can also be consulted using the Qt Assistant tool."
    },
    {
        "link": "https://docs.python.org/3/library/os.html",
        "document": "This module provides a portable way of using operating system dependent functionality. If you just want to read or write a file see , if you want to manipulate paths, see the module, and if you want to read all the lines in all the files on the command line see the module. For creating temporary files and directories see the module, and for high-level file and directory handling see the module.\n\nNotes on the availability of these functions:\n• None The design of all built-in operating system dependent modules of Python is such that as long as the same functionality is available, it uses the same interface; for example, the function returns stat information about path in the same format (which happens to have originated with the POSIX interface).\n• None Extensions peculiar to a particular operating system are also available through the module, but using them is of course a threat to portability.\n• None All functions accepting path or file names accept both bytes and string objects, and result in an object of the same type, if a path or file name is returned.\n• None On VxWorks, os.popen, os.fork, os.execv and os.spawn*p* are not supported.\n• None On WebAssembly platforms, Android and iOS, large parts of the module are not available or behave differently. APIs related to processes (e.g. , ) and resources (e.g. ) are not available. Others like and are emulated or stubs. WebAssembly platforms also lack support for signals (e.g. , )."
    },
    {
        "link": "https://geeksforgeeks.org/directory-traversal-tools-in-python",
        "document": "method of the OS module can be used for listing out all the directories. This method basically generates the file names in the directory tree either top-down or bottom-up. For each directory in the tree rooted at directory top (including top itself), it yields a 3-tuple (dirpath, dirnames, filenames).\n• dirpath: A string that is the path to the directory\n• dirnames: All the sub-directories from root.\n• filenames: All the files from root and directories.\n\nParameters:\n\n top: Starting directory for os.walk().\n\n topdown: If this optional argument is True then the directories are scanned from top-down otherwise from bottom-up. This is True by default.\n\n onerror: It is a function that handles errors that may occur.\n\n followlinks: This visits directories pointed to by symlinks, if set to True. Return Type: For each directory in the tree rooted at directory top (including top itself), it yields a 3-tuple (dirpath, dirnames, filenames).\n\nExample: Suppose the directory looks like this:\n\nWe want to list out all the subdirectories and file inside the directory Tree. Below is the implementation."
    },
    {
        "link": "https://docs.python.org/3/library/os.path.html",
        "document": "Source code: Lib/genericpath.py, Lib/posixpath.py (for POSIX) and Lib/ntpath.py (for Windows).\n\nThis module implements some useful functions on pathnames. To read or write files see , and for accessing the filesystem see the module. The path parameters can be passed as strings, or bytes, or any object implementing the protocol.\n\nUnlike a Unix shell, Python does not do any automatic path expansions. Functions such as and can be invoked explicitly when an application desires shell-like path expansion. (See also the module.)\n\nSince different operating systems have different path name conventions, there are several versions of this module in the standard library. The module is always the path module suitable for the operating system Python is running on, and therefore usable for local paths. However, you can also import and use the individual modules if you want to manipulate a path that is always in one of the different formats. They all have the same interface:\n\nOn Unix and Windows, return the argument with an initial component of or replaced by that user’s home directory. On Unix, an initial is replaced by the environment variable if it is set; otherwise the current user’s home directory is looked up in the password directory through the built-in module . An initial is looked up directly in the password directory. On Windows, will be used if set, otherwise a combination of and will be used. An initial is handled by checking that the last directory component of the current user’s home directory matches , and replacing it if so. If the expansion fails or if the path does not begin with a tilde, the path is returned unchanged. Changed in version 3.8: No longer uses on Windows.\n\nJoin one or more path segments intelligently. The return value is the concatenation of path and all members of *paths, with exactly one directory separator following each non-empty part, except the last. That is, the result will only end in a separator if the last part is either empty or ends in a separator. If a segment is an absolute path (which on Windows requires both a drive and a root), then all previous segments are ignored and joining continues from the absolute path segment. On Windows, the drive is not reset when a rooted path segment (e.g., ) is encountered. If a segment is on a different drive or is an absolute path, all previous segments are ignored and the drive is reset. Note that since there is a current directory for each drive, represents a path relative to the current directory on drive ( ), not . Changed in version 3.6: Accepts a path-like object for path and paths."
    },
    {
        "link": "https://qwiet.ai/preventing-directory-traversal-attacks-best-practices-for-file-handling",
        "document": "Directory Traversal Attacks: they’re like the pickpockets of the web, sneaking around your server’s file system, looking for something valuable to snatch. But don’t worry; we’ve got the tools and techniques to catch these digital thieves red-handed. So, let’s get into the nitty-gritty of securing your file handling operations and making your server a no-go zone for directory traversal mischief.\n\nIn a Directory Traversal Attack, an attacker manipulates file paths in a way that allows them to access files and directories that should be restricted. Imagine someone trying to sneak backstage at a concert by finding a hidden path; only, in this case, the backstage holds sensitive data and system files.\n\nBefore we dive into the solutions, let’s get the basics right. Understanding how file paths work is crucial for securing them. A file path like ../../etc/passwd can be a red flag, signaling an attempt to move up directories to access sensitive files.\n\nIn this Python snippet, we’re using os.path.join to construct a file path. The user provides a file name, which is then appended to the /app/data/ directory. This is a basic example and not secure as-is, because a crafty user could input something like ../../etc/passwd to access restricted files.\n\nThe first line of defense is always validating what the user has provided. Make sure the input matches a certain pattern or set of allowed values.\n\nWe’re using Python’s re module to check if the user-provided file name contains only alphanumeric characters and underscores. If it doesn’t, we flag it as invalid.\n\nMany programming languages offer built-in functions to normalize file paths, effectively resolving “..” and “.” references.\n\nIn this Python example, os.path.normpath is used to normalize the file path. We then check if the normalized path starts with the allowed directory /app/data/. If it does, access is allowed.\n\nRestrict the types of operations that can be performed. If a feature only requires reading files, there should be no option to delete or modify them.\n\nWe’re explicitly checking if the operation is “read” before proceeding. Any other operation is flagged as not allowed.\n\nAccess control mechanisms can be implemented at the application level to ensure only authorized users can access certain files.\n\nIn this snippet, we’re checking the user’s role before allowing access to a file. Only users with an “admin” role are granted access.\n\nKeep an eye on file access logs to detect any suspicious activity.\n\nHere, we’re using Python’s logging module to log file access, including the user ID and the file path. This can help in auditing and identifying suspicious behavior.\n\nDirectory Traversal Attacks are deceptive but can be countered with the right strategies and tools. To bolster your defenses and ensure against directory traversal attacks, it’s essential to stay vigilant and consistent in your security protocols. Want to see how a tool like Qwiet can help you secure your security posture? Book a demo with us today."
    },
    {
        "link": "https://pullrequest.com/blog/preventing-directory-traversal-attacks-techniques-and-tips-for-secure-file-access",
        "document": "Directory traversal attacks, also known as path traversal attacks, exploit web applications by accessing files and directories that are stored outside the web root folder. By manipulating variables that reference files with dot-dot-slash (../) sequences, attackers can access arbitrary files and directories stored on the file system, including application source code, data, and sensitive system files. This vulnerability can lead to unauthorized access, information disclosure, and even full system compromise. Therefore, securing your application against directory traversal attacks is paramount for maintaining its integrity and protecting sensitive information.\n\nA directory traversal attack occurs when an attacker manipulates file paths in a way that allows them to access directories and files they shouldn’t be able to. This is often possible due to insufficient input validation and sanitization when user input is used to construct file paths for file operations like open, read, and write.\n\nConsider a simple file retrieval feature in a web application that allows users to view files by specifying a filename in a query parameter, like so: . An attacker can exploit this feature by requesting a file outside the intended directory with a request like , aiming to access the system’s password file.\n\nInput validation is the first line of defense against directory traversal attacks. Ensure that your application validates user input strictly, rejecting any request containing illegal characters or patterns. For file access operations, specifically disallow characters such as “..” and “/”, or sequences that are known to be part of directory traversal payloads.\n\nSanitizing input by removing or encoding dangerous characters before processing can further reduce the risk. However, validation should always be your primary strategy, with sanitization serving as an additional layer of security.\n\nImplementing allow lists (previously known as whitelists) for file retrieval operations is an effective way to prevent directory traversal attacks. By explicitly specifying which files or directories are accessible, you can ensure that only intended resources can be accessed, regardless of any manipulation attempts by attackers.\n\nMany programming languages and frameworks offer built-in functions that automatically handle path normalization and can effectively mitigate directory traversal vulnerabilities. For example, using functions like in PHP or in .NET ensures that file paths are resolved to their absolute path, stripping out any potentially malicious sequences.\n\nIsolating your application’s execution environment using chroot jails (in Unix-like systems) or virtual directories (in web servers) can limit the scope of accessible directories for the application. This containment strategy ensures that even if an attacker manages to exploit a directory traversal vulnerability, they are confined to a controlled environment, significantly reducing the potential impact.\n\nKeeping your software and dependencies up-to-date is crucial in protecting against known vulnerabilities, including those that could be exploited for directory traversal. If one of your dependencies has a vulnerability, then your application has a vulnerability. Regularly applying patches and updates to your operating system, web server, application server, and any frameworks or libraries you are using makes your project a moving target for any would-be hackers.\n\nProper access control mechanisms can restrict the files and directories accessible to different users or processes. Implementing least privilege access principles ensures that even if an attacker bypasses other defenses, they cannot access sensitive files or directories without the necessary permissions.\n\nMonitoring and logging file access attempts can help in detecting and responding to potential directory traversal attacks. By keeping an eye on unusual patterns or repeated access attempts to sensitive files, you can identify malicious activity and take appropriate action before any significant damage occurs.\n\nTo illustrate some of these principles, let’s look at practical examples in a couple of popular programming languages.\n\nPython’s module offers utilities for safely constructing file paths. The function ensures that the resulting path is constructed correctly according to the operating system’s conventions, while can be used to resolve the absolute path, mitigating directory traversal attempts.\n\nPHP’s function is useful for resolving absolute pathnames and eliminating any “..” sequences. This can be used to check if the resolved path starts with an expected directory path.\n\nPreventing directory traversal attacks is critical for securing web applications from unauthorized access and data breaches. By applying a combination of input validation, allow lists, using built-in functions, employing chroot jails and virtual directories, and adhering to best practices for software maintenance and access control, developers can significantly mitigate the risk of these attacks. Regular monitoring and logging of file access can also aid in early detection of suspicious activities, enabling prompt response to potential security threats. Remember, security is an ongoing process, and staying informed about the latest threats and mitigation techniques is key to protecting your applications and users."
    }
]