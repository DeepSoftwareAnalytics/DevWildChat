[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/setHours",
        "document": "If you do not specify the , , and parameters, the same values as what are returned by , , and are used.\n\nIf a parameter you specify is outside of the expected range, other parameters and the date information in the object are updated accordingly. For example, if you specify 100 for , the minutes are incremented by 1 ( ), and 40 is used for seconds."
    },
    {
        "link": "https://w3schools.com/jsref/jsref_sethours.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
        "document": "A JavaScript date is fundamentally specified as the time in milliseconds that has elapsed since the epoch, which is defined as the midnight at the beginning of January 1, 1970, UTC (equivalent to the UNIX epoch). This timestamp is timezone-agnostic and uniquely defines an instant in history. Note: While the time value at the heart of a Date object is UTC, the basic methods to fetch the date and time or its components all work in the local (i.e. host system) time zone and offset. The maximum timestamp representable by a object is slightly smaller than the maximum safe integer ( , which is 9,007,199,254,740,991). A object can represent a maximum of ±8,640,000,000,000,000 milliseconds, or ±100,000,000 (one hundred million) days, relative to the epoch. This is the range from April 20, 271821 BC to September 13, 275760 AD. Any attempt to represent a time outside this range results in the object holding a timestamp value of , which is an \"Invalid Date\". There are various methods that allow you to interact with the timestamp stored in the date:\n• You can interact with the timestamp value directly using the and methods.\n• The and (when passed ) methods — which are automatically called in number coercion — return the timestamp, causing objects to behave like their timestamps when used in number contexts.\n• All static methods ( , , and ) return timestamps instead of objects.\n• The constructor can be called with a timestamp as the only argument.\n\nA date is represented internally as a single number, the timestamp. When interacting with it, the timestamp needs to be interpreted as a structured date-and-time representation. There are always two ways to interpret a timestamp: as a local time or as a Coordinated Universal Time (UTC), the global standard time defined by the World Time Standard. The local timezone is not stored in the date object, but is determined by the host environment (user's device). Note: UTC should not be confused with the Greenwich Mean Time (GMT), because they are not always equal — this is explained in more detail in the linked Wikipedia page. For example, the timestamp 0 represents a unique instant in history, but it can be interpreted in two ways:\n• As a UTC time, it is midnight at the beginning of January 1, 1970, UTC,\n• As a local time in New York (UTC-5), it is 19:00:00 on December 31, 1969. The method returns the difference between UTC and the local time in minutes. Note that the timezone offset does not only depend on the current timezone, but also on the time represented by the object, because of daylight saving time and historical changes. In essence, the timezone offset is the offset from UTC time, at the time represented by the object and at the location of the host environment. There are two groups of methods: one group gets and sets various date components by interpreting the timestamp as a local time, while the other uses UTC. The constructor can be called with two or more arguments, in which case they are interpreted as the year, month, day, hour, minute, second, and millisecond, respectively, in local time. works similarly, but it interprets the components as UTC time and also accepts a single argument representing the year. Note: Some methods, including the constructor, , and the deprecated / methods, interpret a two-digit year as a year in the 1900s. For example, is interpreted as June 24, 1999, not June 24, 99. See Interpretation of two-digit years for more information. When a segment overflows or underflows its expected range, it usually \"carries over to\" or \"borrows from\" the higher segment. For example, if the month is set to 12 (months are zero-based, so December is 11), it become the January of the next year. If the day of month is set to 0, it becomes the last day of the previous month. This also applies to dates specified with the date time string format.\n\nThere are many ways to format a date as a string. The JavaScript specification only specifies one format to be universally supported: the date time string format, a simplification of the ISO 8601 calendar date extended format. The format is as follows:\n• is the year, with four digits ( to ), or as an expanded year of or followed by six digits. The sign is required for expanded years. is explicitly disallowed as a valid year.\n• is the month, with two digits ( to ). Defaults to .\n• is the day of the month, with two digits ( to ). Defaults to .\n• is a literal character, which indicates the beginning of the time part of the string. The is required when specifying the time part.\n• is the hour, with two digits ( to ). As a special case, is allowed, and is interpreted as midnight at the beginning of the next day. Defaults to .\n• is the minute, with two digits ( to ). Defaults to .\n• is the second, with two digits ( to ). Defaults to .\n• is the millisecond, with three digits ( to ). Defaults to .\n• is the timezone offset, which can either be the literal character (indicating UTC), or or followed by , the offset in hours and minutes from UTC. Various components can be omitted, so the following are all valid:\n• Date-time form: one of the above date-only forms, followed by , followed by , , or . Each combination can be followed by a time zone offset. For example, (date-only form), (date-time form), or (date-time form with milliseconds and time zone) are all valid date time strings. When the time zone offset is absent, date-only forms are interpreted as a UTC time and date-time forms are interpreted as a local time. The interpretation as a UTC time is due to a historical spec error that was not consistent with ISO 8601 but could not be changed due to web compatibility. See Broken Parser – A Web Reality Issue. and the constructor both accept strings in the date time string format as input. Furthermore, implementations are allowed to support other date formats when the input fails to match this format. The method returns a string representation of the date in the date time string format, with the time zone offset always set to (UTC). Note: You are encouraged to make sure your input conforms to the date time string format above for maximum compatibility, because support for other formats is not guaranteed. However, there are some formats that are supported in all major implementations — like RFC 2822 format — in which case their usage can be acceptable. Always conduct cross-browser tests to ensure your code works in all target browsers. A library can help if many different formats are to be accommodated. Non-standard strings can be parsed in any way as desired by the implementation, including the time zone — most implementations use the local time zone by default. Implementations are not required to return invalid date for out-of-bounds date components, although they usually do. A string may have in-bounds date components (with the bounds defined above), but does not represent a date in reality (for example, \"February 30\"). Implementations behave inconsistently in this case. The page offers more examples about these non-standard cases.\n\nReturns the day of the month ( – ) for the specified date according to local time. Returns the day of the week ( – ) for the specified date according to local time. Returns the year (4 digits for 4-digit years) of the specified date according to local time. Returns the hour ( – ) in the specified date according to local time. Returns the milliseconds ( – ) in the specified date according to local time. Returns the minutes ( – ) in the specified date according to local time. Returns the month ( – ) in the specified date according to local time. Returns the seconds ( – ) in the specified date according to local time. Returns the numeric value of the specified date as the number of milliseconds since January 1, 1970 00:00:00 UTC. (Negative values are returned for prior times.) Returns the time-zone offset in minutes for the current locale. Returns the day (date) of the month ( – ) in the specified date according to universal time. Returns the day of the week ( – ) in the specified date according to universal time. Returns the year (4 digits for 4-digit years) in the specified date according to universal time. Returns the hours ( – ) in the specified date according to universal time. Returns the milliseconds ( – ) in the specified date according to universal time. Returns the minutes ( – ) in the specified date according to universal time. Returns the month ( – ) in the specified date according to universal time. Returns the seconds ( – ) in the specified date according to universal time. Returns the year (usually 2–3 digits) in the specified date according to local time. Use instead. Sets the day of the month for a specified date according to local time. Sets the full year (e.g. 4 digits for 4-digit years) for a specified date according to local time. Sets the hours for a specified date according to local time. Sets the milliseconds for a specified date according to local time. Sets the minutes for a specified date according to local time. Sets the month for a specified date according to local time. Sets the seconds for a specified date according to local time. Sets the object to the time represented by the number of milliseconds since January 1, 1970 00:00:00 UTC. Use negative numbers for times prior. Sets the day of the month for a specified date according to universal time. Sets the full year (e.g. 4 digits for 4-digit years) for a specified date according to universal time. Sets the hour for a specified date according to universal time. Sets the milliseconds for a specified date according to universal time. Sets the minutes for a specified date according to universal time. Sets the month for a specified date according to universal time. Sets the seconds for a specified date according to universal time. Sets the year (usually 2–3 digits) for a specified date according to local time. Use instead. Returns the \"date\" portion of the as a human-readable string like . Converts a date to a string following the ISO 8601 Extended Format. Returns a string representing the using . Intended to be implicitly called by . Returns a string with a locality sensitive representation of the date portion of this date based on system settings. Returns a string with a locality-sensitive representation of this date. Overrides the method. Returns a string with a locality-sensitive representation of the time portion of this date, based on system settings. Returns a string representing the specified object. Overrides the method. Returns a new object with the same value as this date's timestamp. Returns the \"time\" portion of the as a human-readable string. Converts a date to a string using the UTC timezone. Returns the primitive value of a object. Overrides the method. Converts this object to a primitive value.\n\nexhibits legacy undesirable, inconsistent behavior with two-digit year values; specifically, when a call is given a two-digit year value, that year value does not get treated as a literal year and used as-is but instead gets interpreted as a relative offset — in some cases as an offset from the year , but in other cases, as an offset from the year . let date = new Date(98, 1); // Sun Feb 01 1998 00:00:00 GMT+0000 (GMT) date = new Date(22, 1); // Wed Feb 01 1922 00:00:00 GMT+0000 (GMT) date = new Date(\"2/1/22\"); // Tue Feb 01 2022 00:00:00 GMT+0000 (GMT) // Legacy method; always interprets two-digit year values as relative to 1900 date.setYear(98); date.toString(); // Sun Feb 01 1998 00:00:00 GMT+0000 (GMT) date.setYear(22); date.toString(); // Wed Feb 01 1922 00:00:00 GMT+0000 (GMT) So, to create and get dates between the years and , instead use the preferred and methods:. // Preferred method; never interprets any value as being a relative offset, // but instead uses the year value as-is date.setFullYear(98); date.getFullYear(); // 98 (not 1998) date.setFullYear(22); date.getFullYear(); // 22 (not 1922, not 2022)\n\nThe following examples show how to determine the elapsed time between two JavaScript dates in milliseconds. Due to the differing lengths of days (due to daylight saving changeover), months, and years, expressing elapsed time in units greater than hours, minutes, and seconds requires addressing a number of issues, and should be thoroughly researched before being attempted. // Using Date objects const start = Date.now(); // The event to time goes here: doSomethingForALongTime(); const end = Date.now(); const elapsed = end - start; // elapsed time in milliseconds // Using built-in methods const start = new Date(); // The event to time goes here: doSomethingForALongTime(); const end = new Date(); const elapsed = end.getTime() - start.getTime(); // elapsed time in milliseconds // To test a function and get back its return function printElapsedTime(testFn) { const startTime = Date.now(); const result = testFn(); const endTime = Date.now(); console.log(`Elapsed time: ${String(endTime - startTime)} milliseconds`); return result; } const yourFunctionReturn = printElapsedTime(yourFunction); Note: In browsers that support the Performance API's high-resolution time feature, can provide more reliable and precise measurements of elapsed time than ."
    },
    {
        "link": "https://geeksforgeeks.org/javascript-date-sethours-method",
        "document": "The JavaScript date.setHours() method is used to set hours into a date object which is created using the Date() constructor.\n• hours_Value: This parameter holds the value of hour which is used to set in the Date() constructor.\n\nIt returns the new date with the updated hour which is set by the setHours() method.\n\nNote: DateObj is a valid Date object created using the Date() constructor in which we want to set the hours. More codes for the above method are as follows:\n\nExample 1: If in the Date() constructor we do not give an hour while creating the Date object, still setHours() method will set the new hour which is given as its parameter.\n\nExample 2: If nothing as a parameter is given in the Date() constructor, still setHours() method set hour but a month, year and date will be a current month, year, and date. Here 11 is the new hour, 2 is the current month i.e March, 30 is the current date and 2018 is the current year.\n\nExample 3: If the value of an hour as 26 is given in the parameter of setHours() method, It will set 2 as the hour because the hour range is from 0 to 23 and[Tex]26%24=2 [/Tex]. Here 2 is the new hour, 9 is the month i.e October, 14 is the date and the year is 1996. Here as we see that 13 was the original date but the output becomes 14 because 26 hours given as the parameter of the method converted to 2 hours of the next day that is why the date incremented by 1 i.e, from 13 to 14.\n\nWhat is the setHours() method in JavaScript?\n\nHow do you use the setHours() method?\n\nCan setHours() handle values outside the standard 0-23 hour range?\n\nWe have a complete list of Javascript Date Objects, to check those please go through this article."
    },
    {
        "link": "https://w3schools.com/js/js_date_methods_set.asp",
        "document": "Set Date methods let you set date values (years, months, days, hours, minutes, seconds, milliseconds) for a Date Object.\n\nSet Date methods are used for setting a part of a date:\n\nThe method sets the year of a date object. In this example to 2020:\n\nThe method can optionally set month and day:\n\nThe method sets the month of a date object (0-11):\n\nThe method sets the day of a date object (1-31):\n\nThe method can also be used to add days to a date:\n\nIf adding days shifts the month or year, the changes are handled automatically by the Date object.\n\nThe method sets the hours of a date object (0-23):\n\nThe method can also be used to set minutes and seconds.\n\nThe method sets the minutes of a date object (0-59):\n\nThe method sets the seconds of a date object (0-59):\n\nThe following example compares today's date with January 14, 2100:\n\nFor a complete Date reference, go to our: The reference contains descriptions and examples of all Date properties and methods."
    },
    {
        "link": "https://ursahealth.com/new-insights/dates-and-timezones-in-javascript",
        "document": ""
    },
    {
        "link": "https://toastui.medium.com/handling-time-zone-in-javascript-547e67aa842d",
        "document": "Recently, I worked on a task of adding a time zone feature to the TOAST UI Calendar, the JavaScript calendar library managed by my team. I pretty well knew that the time zone support in JavaScript is quite poor, but hoped that abstracting existing data objects would easily resolve many problems.\n\nHowever, my hope was false, and I found it really hard to handle time zone in JavaScript as I progressed more. Implementing time zone features beyond simple formatting of time and calculating time data with complex operations (e.g. calendar) was a truly daunting task. For this reason, I had a valuable and thrilling experience of solving a problem leading to cause more problems.\n\nThe purpose of this article is to discuss the issues and solutions related to the implementation of time zone features using JavaScript. As I was writing this rather lengthy article, I suddenly realized that the root of my problem lied in my poor understanding of the time zone domain. In this light, I will first discuss the definition and standards related to time zone in detail, and then talk about JavaScript.\n\nA time zone is a region that follows a uniform local time which is legally stated by the country. It’s common for many countries to have its unique time zone, and some large countries, such as the USA or Canada, even have multiple time zones. Interestingly, even though China is large enough to have multi time zones, she uses only one time zone. This sometimes results in such an awkward situation where the sun rises around 10:00 AM in the western part of China\n\nThe Korean local time is normally . GMT is an abbreviation for Greenwich Mean Time, which is the clock time at the Royal Observatory in Greenwich, U.K. located at longitude 0. The GMT system began spreading in Feb. 5, 1925 and became the world time standard until Jan. 1, 1972.\n\nMany consider GMT and UTC the same thing, and the two are used interchangeably in many cases, but they are actually different. UTC was established in 1972 to compensate for the slowing problem of the Earth’s rotation. This time system is based on International Atomic Time, which uses the cesium atomic frequency to set the time standard. In other words, UTC is the more accurate replacement system of GMT. Although the actual time difference between the two is tiny, UTC is whatsoever the more accurate choice for software developers.\n\nin means the local time is 9 hours ahead than the UTC standard time. This means that it’s 09:00 PM in Korea when it’s 12:00 PM in a UTC region. The difference of time between UTC standard time and the local time is called “offset”, which is expressed in this way: , , etc.\n\nIt’s common that countries name their time zone using their own unique names. For example, the time zone of Korea is called KST (Korea Standard Time), and has a certain offset value which is expressed as . However, the offset is also used by not only Korea but also Japan, Indonesia, and many others, which means the relation between offsets and time zone names are not 1:1 but 1:N. The list of countries in the offset can be found in UTC+09:00.\n\nSome offsets are not strictly on hourly basis. For example, North Korea uses as their standard time while Australia uses or depending on the region.\n\nAs I mentioned earlier, we use the names of time zones (KST, JST) interchangeably with offset without distinguishing them. But it’s not right to treat the time and offset of a certain region the same for the following reasons:\n\nAlthough this term might be unfamiliar to some countries, a lot of countries in the world adopted summer time. “Summer time” is a term mostly used in the U.K. and other European countries. Internationally, it is normally called Daylight Saving Time (DST). It means advancing clocks to one hour ahead of standard time during summer time.\n\nFor example, California in the USA uses PST (Pacific Standard Time) during winter time and use PDT (Pacific Daylight Time, ) during summer time. The regions that uses the two time zones are collectively called Pacific Time (PT), and this name is adopted by many regions of the USA and Canada.\n\nThen the next question is exactly when the summer begins and ends. In fact, the start and end dates of DST are all different, varying country by country. For example, in the U.S.A and Canada, DST used to be from the first Sunday of April at 02:00 AM to the last Sunday of October at 12:00 AM until 2006, but since 2007, DST has begun on the second Sunday of March at 02:00 AM till the first Sunday of November at 02:00 AM. In Europe, summer time is uniformly applied across the countries, while DST is applied progressively to each time zone in the states.\n\nAs I briefly mentioned earlier, each country has its own right to determine which time zone to use, which means its time zone can be changed due to any political and/or economic reasons. For example, in the states, the period of DST was changed in 2007 because President George Bush signed the energy policy in 2005. Egypt and Russia used to use DST, but they ceased to use it since 2011.\n\nIn some cases, a country can change not only its DST but also its standard time. For example, Samoa used to use the offset, but later changed to the offset to reduce the losses in trading caused by the time difference between Samoa and Australia & New Zealand. This decision caused the country to miss the whole day of Dec. 30, 2011 and it made to newspapers all over the world.\n\nNetherlands used to use offset, which is unnecessarily accurate since 1909, but changed it to offset in 1937, and then changed again to offset in 1940, sticking to it so far.\n\nTo summarize, a time zone can have one or more offsets. Which offset a country will use as its standard time at a certain moment can vary due to political and/or economic reasons.\n\nThis is not a big issue in everyday life, but it is when trying to systematize it based on rules. Let’s imagine that you want to set a standard time for your smartphone using an offset. If you live in a DST-applied region, your smartphone time should be adjusted whenever DST starts and ends. In this case, you would need a concept that brings standard time and DST together into one time zone (e.g. Pacific Time).\n\nBut this cannot be implemented with just a couple of simple rules. For example, as the states changed the dates DST starts and ends in 2007, May 31, 2006 should use PDT ( ) as the standard time while Mar 31, 2007 should use PST ( ) as the standard time. This means that to refer to a specific time zone, you must know all historical data of the standard time zones or the point in time when DST rules were changed.\n\nYou can’t simply say, “New York’s time zone is PST ( ).” You must be more specific by saying, for instance, “New York’s current time zone is PST.” However, we need a more accurate expression for the sake of the system implementation. Forget the word “time zone”. You need to say, “New York is currently using PST as its standard time”.\n\nThen what should we use other than offset to designate the time zone of a specific region? The answer is the name of the region. To be more specific, you should group regions where the changes in DST or standard time zone has been uniformly applied into one time zone and refer to it as appropriate. You might be able to use names like PT (Pacific Time), but such term only combines the current standard time and its DST, not necessarily all the historical changes. Furthermore, since PT is currently used only in the USA and Canada, you need more well established standards from trusted organizations in order to use software universally.\n\nTo tell you the truth, time zones are more of a database rather than a collection of rules because they must contain all relevant historical changes. There are several standard database designed to handle the time zone issues, and the most frequently used one is IANA Time Zone Database. Usually called tz database (or tzdata), IANA Timezone Database contains the historical data of local standard time around the globe and DST changes. This database is organized to contain all historical data currently verifiable to ensure the accuracy of time since the Unix time ( ). Although it also has data before 1970, the accuracy is not guaranteed.\n\nThe naming convention follows the Area/Location rule. Area usually refers to the name of a continent or an ocean (Asia, America, Pacific) while Location the name of major cities such as Seoul and New York rather than the name of countries (This is because the lifespan of a country is far shorter than that of a city). For example, the time zone of Korea is and that of Japan is . Although the two countries share the same , both countries have different histories regarding time zone. That is why the two countries are handled using separate time zones.\n\nIANA Time Zone Database is managed by numerous communities of developers and historians. Newly found historical facts and governmental policies are updated right away to the database, making it the most reliable source. Furthermore, many UNIX-based OSs, including Linux and macOS, and popular programming languages, including Java and PHP, internally use this database.\n\nAs I briefly mentioned earlier, the time zone feature of JavaScript is quite poor. Since it follows the time zone of the region by default (to be more specific, the time zone selected at the time of the OS installation), there is no way to change it to a new time zone. Also, its specifications for database standard are not even clear, which you will notice if you take a close look at the specification for ES2015. Only a couple of vague declarations are stated regarding local time zone and DST availability. For instance, DST is defined as follows: ECMAScript 2015 — Daylight Saving Time Adjustment\n\nIt looks like it is simply saying, “Hey, guys, give it a try and do your best to make it work.” This leaves a compatibility problem across browser vendors as well. You might think “That’s sloppy!”, but then you will notice another line right below:\n\nYes. The ECMA specifications toss the ball to you with this simple recommendation for IANA Time Zone Database, and JavaScript has no specific standard database prepared for you. As a result, different browsers use their own time zone operations for time zone calculation, and they are often not compatible with one another. ECMA specifications later added an option to use IANA time zone in ECMA-402 for international API. However, this option is still far less reliable than that for other programming languages.\n\nWe will assume a simple scenario in which time zone must be considered. Let’s say we’re going to develop a simple calendar app that will handle time information. When a user enters date and time in the field on the register page in the client environment, the data is transferred to the server and stored in the DB. Then the client receives the registered schedule data from the server to displays it on screen.\n\nThere is something to consider here though. What if some of the clients accessing the server are in different time zones? A schedule registered for Mar 11, 2017 11:30 AM in Seoul must be displayed as Mar 10, 2017 09:30 PM when the schedule is looked up in New York. For the server to support clients from various time zones, the schedule stored in the server must have absolute values that are not affected by time zones. Each server has a different way to store absolute values, and that is out of the scope of this article since it is all different depending on the server or database environment. However for this to work, the date and time transferred from the client to the server must be values based on the same offset (usually UTC) or values that also include the time zone data of the client environment.\n\nIt’s a common practice that this kind of data is transferred in the form of Unix time based on UTC or ISO-8601 containing the offset information. In the example above, if 11:30 AM on Mar 11, 2017 in Seoul is to be converted into Unix time, it will be an integer type of which value is . Under ISO-8601, it will be a string type of which value is .\n\nIf you’re working with this using JavaScript in a browser environment, you must convert the entered value as described above and then convert it back to fit the user’s time zone. The both of these two tasks have to be considered. In the sense of programming language, the former is called “parsing” and the latter “formatting”. Now let’s find out how these are handled in JavaScript.\n\nIn JavaScript, tasks involving date or time are handled using a object. It is a native object defined in ECMAScript, like or . which is mostly implemented in native code such as C++. Its API is well described in MDN Documents. It is greatly influenced by Java’s java.util.Date class. As a result, it inherits some undesirable traits, such as the characteristics of mutable data and beginning with 0.\n\nJavaScript’s object internally manages time data using absolute values, such as Unix time. However, constructors and methods such as function, , , etc. are affected by the client’s local time zone (the time zone of the OS running the browser, to be exact). Therefore, if you create a object directly using user input data, the data will directly reflect the client’s local time zone.\n\nLet’s go back to the first example. Assume that a user entered 11:30 AM, Mar 11, 2017 in a device which follows the time zone of Seoul. This data is stored in 5 integers of 2017, 2, 11, 11, and 30 — each representing the year, month, day, hour, and minute, respectively. (Since the month begins with 0, the value must be 3–1=2.) With a constructor, you can easily create a Date object using the numeric values.\n\nIf you look at the value returned by , then you will know that the created object’s absolute value is 11:30 AM, Mar 11, 2017 based on the offset (KST).\n\nYou can also use the constructor together with string data. If you use a string value to the object, it internally calls and calculate the proper value. This function supports the RFC2888 specifications and the ISO-8601 specifications. However, as described in the MDN’s Date.parse() Document, the return value of this method varies from browser to browser, and the format of the string type can affect the prediction of exact value. Thus, it is recommended not to use this method.\n\nFor example, a string like returns on Safari and Internet Explorer while the same string returns the local time zone on Chrome and Firefox. In some cases, it returns the value based on the UTC standard.\n\nLet’s now assume that you are going to receive data from the server. If the data is of the numerical Unix time value, you can simply use the constructor to create a object. Although I skipped the explanation earlier, when a constructor receives a single value as the only parameter, it is recognized as a Unix time value in millisecond. (Caution: JavaScript handles Unix time in milliseconds. This means that the second value must be multiplied by 1,000.) If you see the example below, the resultant value is the same as that of the previous example.\n\nThen what if a string type such as ISO-8601 is used instead of the Unix time? As I explained in the previous paragraph, the method is unreliable and better not be used. However since ECMAScript 5 or later versions specify the support of ISO-8601, you can use strings in the format specified by ISO-8601 for the constructor on Internet Explorer 9.0 or higher that supports ECMAScript 5 if carefully used.\n\n If you’re using a browser of not the latest version, make sure to keep the letter at the end. Without it, your old browser sometimes interprets it based on your local time instead of UTC. Below is an example of running it on Internet Explorer 10.\n\nAccording to the specifications, the resultant values of both cases should be the same. However, as you can see, the resultant values are different as and . On the latest browser, these two values will be the same. To prevent this kind of version problem, you should always add at the end of a string if there is no time zone data.\n\nCreating Data to be Transferred to Server\n\nNow use the object created earlier, and you can freely add or subtract time based on local time zones. But don’t forget to convert your data back to the previous format at the end of the processing before transferring it back to the server.\n\nIf it’s Unix time, you can simply use the method to perform this. (Note the use of millisecond.)\n\nWhat about strings of the ISO-8601 format? As explained earlier, Internet Explorer 9.0 or higher that supports ECMAScript 5 or higher supports the ISO-8601 format. You can create strings of the ISO-8601 format using the or method. ( can be used for recursive calls with or others.) The two methods yield the same results, except for the case in which it handles invalid data.\n\nYou can also use the or method to create strings in UTC. As they return a string that satisfies the RFC-1123 standard, you can leverage this as needed.\n\nDate objects include , , and their extension methods. However, since these are mainly used to return a string based on local time zone, and they return varying values depending on your browser and OS used, they are not really useful.\n\nYou can see now that JavaScript provides a bit of support for time zone. What if you want to change the local time zone setting within your application without following the time zone setting of your OS? Or what if you need to display a variety of time zones at the same time in a single application? Like I said several times, JavaScript does not allow manual change of local time zone. The only solution to this is adding or removing the value of the offset from the date provided that you already know the value of the time zone’s offset. Don’t get frustrated yet though. Let’s see if there is any solution to circumvent this.\n\nLet’s continue with the earlier example, assuming that the browser’s time zone is set to Seoul. The user enters 11:30 AM, Mar 11, 2017 based on the Seoul time and wants to see it in New York’s local time. The server transfers the Unix time data in milliseconds and notifies that New York’s offset value is . Then you can convert the data if you only know the offset of the local time zone.\n\nIn this scenario, you can use the method. This method is the only API in JavaScript that can be used to get the local time zone information. It returns the offset value of the current time zone in minutes.\n\nThe return value of means that the time zone is 540 minutes ahead of the target. Be warned that the minus sign in front of the value is opposite to Seoul’s plus sign ( ). I don’t know why, but this is how it is displayed. If we calculate the offset of New York using this method, we will get . Convert the difference of into milliseconds and create a new Date object. Then you can use that object’s methods to convert the value into a format of your choice. Let’s create a simple formatter function to compare the results.\n\nshows the correct date and time according to the time zone difference between Seoul and New York. It looks like we found a simple solution. Then can we convert it to the local time zone if we know the region’s offset? Unfortunately, the answer is “No.” Remember what I said earlier? That time zone data is a kind of database containing the history of all offset changes? To get the correct time zone value, you must know the value of the offset at the time of the date (not of the current date).\n\nIf you keep working with the example above a little more, you will soon face with a problem. The user wants to check the time in New York local time and then change the date from 10th to 15th. If you use the method of Date object, you can change the date while leaving other values unchanged.\n\nIt looks simple enough, but there is a hidden trap here. What would you do if you have to transfer this data back to the server? Since the data has been changed, you can’t use methods such as or . Therefore, you must revert the conversion before sending it back to the server.\n\nThe problem doesn’t stop here. There is another problem waiting where you won’t get wanted value by simply adding or subtracting offsets. Since Mar 12 is the starting date of DST in New York’s local time, the offset of Mar 15, 2017 should be not . So when you revert the conversion, you should add 780 minutes, which is 60 minutes less than before.\n\nSimply put, you can’t use the obtained offset alone to perform the precise operations based on the time zone of your choice. If you recollect what we have discussed in the earlier part of this document, you would easily know that there is still a hole in this conversion if you know the summer time rules. To get the exact value, you need a database that contains the entire history of offset changes, such as IANA timezone Database.\n\nTo solve this problem, one must store the entire time zone database and whenever date or time data is retrieved from the object, find the date and the corresponding offset, and then convert the value using the process above. In theory, this is possible. But in reality, this takes too much effort and testing the converted data’s integrity will also be tough. But don’t get disappointed yet. Until now, we discussed some problems of JavaScript and how to solve them. Now we’re ready to use a well built library.\n\nMoment is a well established JavaScript library that is almost the standard for processing date. Providing a variety of date and formatting APIs, it is recognized by so many users recently as stable and reliable. And there is Moment Timezone, an extension module, that solves all the problems discussed above. This extension module contains the data of IANA Time Zone Database to accurately calculate offsets, and provides a variety of APIs that can be used to change and format time zone.\n\nLet’s solve the problem shown in the picture by using Moment Timezone.\n\nIf you see the result, the offset of stays the same while the offset of has been changed from to . And if you use the function, you can get a string in the ISO-8601 format that accurately applied the offset. You will see how simple it is compared to what I explained earlier.\n\nSo far, we’ve discussed the time zone APIs supported by JavaScript and their issues. If you don’t need to manually change your local time zone, you can implement the necessary features even with basic APIs provided that you’re using Internet Explorer 9 or higher. However, if you need to manually change the local time zone, things get very complicated. In a region where there is no summer time and time zone policy hardly changes, you can partially implement it using to convert the data. But if you want full time zone support, do not implement it from scratch. Rather use a library like Moment Timezone.\n\nI tried to implement time zone myself, but I failed, which is not so surprising. The conclusion here after multiple failures is that it is better to “use a library.” When I first began writing this article, I didn’t know what conclusion I was going to write about, but here we go. As a conclusion, I would say that it’s not a recommended approach to blindly use external libraries without knowing what features they support in JavaScript and what kind of issues they have. As always, it’s important to choose the right tool for your own situation. I hope this article helped you in determining the right decision of your own."
    },
    {
        "link": "https://coreui.io/blog/how-to-manage-date-and-time-in-specific-timezones-using-javascript",
        "document": "How to Manage Date and Time in Specific Timezones Using JavaScript\n\nHandling date and time across different timezones is a common yet intricate task for JavaScript developers. Whether you’re working on global applications or time-sensitive services, precise date and time manipulation in specific timezones is essential. JavaScript provides native methods and modern APIs to simplify this task, but challenges like daylight saving time, timezone offsets, and formatting can still cause issues.\n\nSpeed up your responsive apps and websites with fully-featured, ready-to-use open-source admin panel templates—free to use and built for efficiency.\n\nIn this guide, you’ll learn how to set, convert, and format JavaScript dates in specific timezones effectively. We’ll explore best practices, modern solutions, and code examples to help you manage dates and times reliably.\n\nWhy Timezones Are Tricky in JavaScript\n\nJavaScript’s object is tied closely to the local timezone of the host system. By default, the constructor interprets and outputs time in the system’s local timezone or Coordinated Universal Time (UTC). This default behavior introduces several challenges:\n• Timezone Offsets: The difference between UTC and local time can vary due to daylight saving time (DST) changes.\n• Consistent Formatting: Applications often need to display dates and times in the user’s timezone or a specified timezone.\n• Cross-Timezone Calculations: Performing calculations involving dates in different timezones requires converting between offsets.\n• Localization: Formats vary by region, necessitating accurate localization for the desired timezone.\n\nWithout proper handling, these issues can lead to bugs and confusion for end users.\n\nThe API is a powerful tool for formatting dates and times in specific timezones. It supports IANA timezone identifiers, ensuring accurate formatting even with DST.\n\nThis approach is ideal for displaying formatted dates without manual timezone offset calculations.\n\nIf you’re working with complex calendar components, check out the CoreUI React Calendar or Bootstrap Calendar for prebuilt solutions.\n\nFor scenarios where formatting isn’t enough, you may need to manipulate date objects directly. JavaScript’s object provides methods like to calculate timezone differences.\n\nThis method requires careful handling of offsets and doesn’t account for daylight saving time automatically.\n\n3. Using Libraries for Advanced Needs\n\nLibraries like and simplify timezone management. They provide robust tools for creating and converting dates across different timezones.\n\nThese libraries handle complex cases like daylight saving transitions and support a wide range of timezone data.\n\nFor date input and selection in forms, explore the CoreUI React Date Picker or Bootstrap Date Picker for intuitive and customizable solutions.\n\nWhen building global applications, you often need to schedule events for users in different regions. JavaScript’s API can dynamically adjust for the user’s local timezone.\n\nThis approach ensures consistency regardless of timezone differences.\n\nDaylight saving time adjustments can complicate timezone handling. For example, the timezone offset in New York changes during DST transitions. Using APIs like or libraries ensures these adjustments are handled automatically.\n\nTimezone abbreviations (e.g., EST, PST) can cause confusion as they aren’t standardized globally. Relying on IANA timezone names (e.g., ) is recommended for accuracy.\n\nEffectively handling dates and times in specific timezones requires a mix of native JavaScript capabilities and third-party libraries. Here are the key strategies:\n• Use the API for formatting in specific timezones.\n• Rely on libraries like or for advanced timezone management.\n• Test your application thoroughly with diverse timezones and daylight saving transitions.\n\nTo deepen your understanding of timezone handling in JavaScript, consider exploring these resources:\n\nBy applying these best practices and leveraging modern tools, you can ensure accurate and user-friendly timezone handling in your JavaScript applications."
    },
    {
        "link": "https://reddit.com/r/javascript/comments/4mcxfe/best_practices_for_dealing_with_timezones",
        "document": "I was wondering what is the best approach to deal with timezones in a web application for global users.\n\nCurrently, I'm setting a unix timestamp on the client using something like a = Date.now();\n\nwhich gives me a bit integer like 1464961308293\n\nIn order to store the date in my Postgres table - i convert the timestamp to a valid format using the below. Postgres Datatype is TIMESTAMPTZ\n\nWhen i'm retrieving the value again from the table and sending it back to the client - do i again convert it into a unix timestamp and use something like Date.toString() to convert it into the users local time? Or is there a better way to go about handling this (example : do i even need to use the unix timestamp here?)"
    },
    {
        "link": "https://dd.engineering/blog/a-guide-to-handling-date-and-time-for-full-stack-javascript-developers",
        "document": "Time plays an essential role in our lives. Therefore, as developers we get to work with date and time quite frequently. Computer software is used by people from anywhere in the world and the time in one region can differ from the time in another region. And, generally in the software we build we capture and process the date and time of various data records and events. Therefore, it's important to understand various nuances around working with date and time.\n\nDate and time can be represented in many different formats. In Ukraine, the date is usually written in the format \"DD-MM-YYYY\" (the day is first), while in the United States the common format is \"MM-DD-YYYY\" (the month is first).\n\nDepending on the geographical area or a political unit (e.g., a country), the time zone can differ. For example, in the summer, while in Kyiv the time is 21:00, in New York the time is 14:00 (minus seven hours). Also, it's important to mention that the time zone choice/definition in a particular country/region may be affected by a political decision. A country can choose a UTC offset that differs from that country's actual georgraphical location's UTC offset.\n\nAll time zones are defined as offsets to Coordinated Universal Time (UTC), ranging from UTC-12:00 to UTC+14:00. The geographical reference point for UTC is the prime meridian (longitude = 0°), that runs through the Royal Observatory in Greenwich, London, United Kingdom.\n\nAdditionally, in various regions of the world people practice Daylight Saving Time (DST) or in other words - summer time. This is the practice of turning the clock forward one hour from standard time during the warmer months in order to get more daylight during the hours we're usually awake. For example, in Ukraine we turn the clock forward one hour on the last Sunday of March at 03:00 and we return back to the standard time (turning the clock backward one hour) in the last Sunday of October at 04:00. The date and time DST starts and ends depends on a country or a political unit (e.g., European Union.)\n\nAlso, a political region's time zone offset and/or the date and time when the DST starts and ends could have been changed at some point in history. Therefore, there is a number of databases where the information about the time zone changes is tracked. The most popular one is IANA - Time Zone Database, also known as tz or zoneinfo. Operating systems and other computer software use these databases for time zone processing and conversions.\n\nA common format to represent date and time values in computer programming is the Unix timestamp, which is a number of seconds between the Unix epoch (1 January 1970 00:00:00 UTC) and another date (e.g., 1620758838). Positive integers represent the dates after the Unix epoch, while negative integers represent the dates before the Unix epoch.\n\nThe Unix timestamp is one of the common formats for storing date and time in operating systems and databases.\n\nLearn more about the Unix timestamp on Wikipedia: Unix time.\n\nFundamentally, a JavaScript date is specified as the number of milliseconds from the 1 January 1970 00:00:00 UTC. This number looks similar to the Unix timestamp. The difference is that the Unix timestamp is the number of seconds since the Unix epoch while in JavaScript it is the number of milliseconds.\n\nIn JavaScript we use the Date object to work with date and time:\n\nThe Date object holds the current date and time in UTC internally. However, by default, when we output the date and time, the Date object converts the output to the local time zone, the time zone of the environment where the JavaScript code is running (e.g., a browser, Node.js, etc.)\n\nWhen instantiated without parameters, the date object holds the current date and time ( holds the current date).\n\nWe can set the date and time in the Date's constructor or after the instantiation:\n\nWhen we instantiate the Date class, the specified date is converted to and tracked in UTC internally. However, when we access the date using the basic methods (e.g., , , , etc) the date is returned in the local time zone:\n\nHere we instantiate the Date class specifying the date in UTC, but when we print the instantiated date object, we get the date in the local time zone, which for me is UTC+03:00 (Eastern European Summer Time). So, the date is stored in UTC internally, but when we access the date using the basic methods, it's converted to the local time zone.\n\nThe most popular methods of the Date object are:\n\nLearn more about the Date object on MDN Web Docs: Date\n\nHere, we create two date objects, 11 May 2021 and 12 May 2021. Then, we subtract 11 May 2021 ( ) from 12 May 2021 ( ) and get 24 hours of difference.\n\nWhen you work with date objects, take into account the time zones these date objects were instantiated with. Check another example:\n\nHere, the answer is -2, because the time zone of is UTC while the time zone of is UTC+3. Let's see what happens in more detail:\n• We set to 12 May 2021 00:00:00 UTC using the ISO 8601 format. We specify the UTC time zone using the character Z. We could specify the time zone using an offset as well, like this: 2021-05-12T00:00:00.000+00:00 (+00:00 is UTC).\n• We set to 12 May 2021 01:00:00 using another date and time format with the time zone offset UTC+3 (or UTC+03:00).\n• Then we subtract date1 from date2 ( ). When we use a mathematical operation on an object, JavaScript converts the object to a number using the object's valueOf() method if it's present. In the case of the Date object, the method returns the date and time as the number of milliseconds since the Unix epoch, which is a UTC-based date and time representation. So, has been set in UTC, while has been converted to UTC from UTC+3. So, actually, we subtract 12 May 2021 01:00:00 UTC ( ) from 11 May 2021 22:00:00 UTC ( ) and that's how we get -2 for the result.\n\nOne way to format a date is to use the getter functions like getFullYear, getMonth, getDate, etc. For example, to create the date and time string in local time in the format 'YYYY-MM-DD hh:mm:ss' we can do the following:\n\nIn order to get the date and time values according to UTC, we can use the UTC-based getter functions like getUTCFullYear, getUTCMonth, getUTCDate, etc.\n\nFurthermore, we can get the date and time string from the Date object formatted according to a given locale and various options using the Date's method:\n\nPlease note that if you don't specify the time zone in the options, will output the date in the local time zone:\n\nFirst, we instantiate the Date object with the local time zone and get the localized date and time string. When the Date is instatiated the date and time value is converted internally from the specified time zone (or the local time zone if the time zone is not specified) to UTC.\n\nThen, we instantiate another Date object with the local time zone. This time we set the option to \"Europe/Amsterdam\" (according to IANA Time Zone Database). Therefore, we get the localized date and time string based on the \"Europe/Amsterdam\" time zone. In more detail: my current time zone is UTC+3, so the Date object is instantiated with the date and time 2021-05-16 00:00:00 UTC+3 which is converted to UTC internally and becomes 2021-05-15 21:00:00. Then, the method converts this date from UTC to \"Europe/Amsterdam\" and the result is 5/15/2021, 11:00:00 PM GMT+2. The resulting offset is +2, because it's the Daylight Saving Time offset of the \"Europe/Amsterdam\" time zone.\n\nUsually, computer software (e.g., Node.js, databases, etc) by default uses the system date and time configuration. Therefore, make sure that all the servers that belong to your app use the same time zone. UTC is commonly used.\n\nIn Linux you can check the time zone using one of the following commands:\n\nTo change the system time zone you can use the following commands:\n\nTo check the time zone of the Node.js process:\n\nIn Node.js you can set the time zone using the environment variable:\n\nIf the variable is not set, Node.js will attempt to use the operating system's time zone.\n\nUsually, web applications are available from anywhere around the world. This means, that if we store dates in the database, we need to make sure that we store all dates in a single (consistent) time zone or at least track the time zone of the dates we store. Various databases have their specifics as to how they treat date and time values. So, in this section I'd like to briefly explain how to store the date and time values in different databases and mention some of those specifics.\n\nUsually, software (especially web apps) serves users from all over the world. Each user's local time depends on their location. For example, for the user from Kyiv the local time in the summer is 17:00 and at the same time for the user in Amsterdam the local time is 16:00.\n\nBasically, we should convert and store the dates in a unified time zone; usually developers store the dates in UTC. So, before storing a date we should convert it from local time to UTC. For example, a user from Amsterdam creates a reminder in a calendar app. The user selects the date and time of the reminder in local time (\"Europe/Amsterdam\" time zone - UTC+01:00 standard time and UTC+02:00 DST). Let's say the user sets the reminder date to 12 May 2021 17:00 using a calendar widget. Now, before we store this date in the database, we should convert it to UTC, and the date becomes: 12 May 2021 15:00 in UTC, because Daylight Saving Time in Amsterdam (UTC+02:00) became active on 28 March 2021 at 02:00:00. Luckily, we usually don't have to deal with the time zone conversion logic, because it's usually built into the programming language and software (e.g., a database) we use. For example, in JavaScript we can get the current date and time in UTC using the Date object:\n\nIn MySQL the dates are usually stored using the and column types.\n\nMySQL converts values from the current time zone (e.g., the global time zone or the client session time zone) to UTC for storage, and back from UTC to the current time zone for retrieval. MySQL doesn't do this with the other column types, like . So, values are converted to UTC for storage, but when they are retrieved, they are converted to the current time zone ( ). Please check this example:\n\nAs of MySQL 8.0.19 we can add the time zone offset when inserting and values into a table:\n\nLet's see what happens in this example:\n• We set the current time zone to UTC+2\n• We insert a date value with time zone offset UTC-1: 2021-05-12 21:00:00-01:00. MySQL converts this date and time value from UTC-1 to UTC for storage: 2021-05-12 22:00:00.\n• We select the rows from our table and MySQL converts the values from UTC to the current time zone (UTC+2) upon retrieval: 2021-05-13 00:00:00\n• Then, we set the time zone to UTC+3 and select the rows again, and because MySQL converts the values from UTC to the current time zone upon retrieval, we get the date we've inserted earlier in UTC+3 this time: 2021-05-13 01:00:00\n\nThe type has a range of 1970-01-01 00:00:01 UTC to 2038-01-19 03:14:07 UTC.\n\nMySQL is stored and retrieved as is:\n\nMySQL does not convert values from the current time zone to UTC and vice versa.\n\nHowever, something interesting happens when we insert a value with a time zone offset:\n\nIn the example above we can see that when we insert a value with a time zone offset, MySQL converts this date value to the current time zone for storage: 2021-05-12 21:00:00+00:00 + current time zone offset (+03:00) = 2021-05-13 00:00:00\n\nThe type has a range of 1000-01-01 00:00:00 to 9999-12-31 23:59:59.\n\nTo store a date and time value I'd convert the local date and time value to UTC in the application code and store this value in the DATETIME column. Basically, I'd handle the time zone conversion on the application side and store all dates in UTC. I'd use DATETIME instead of TIMESTAMP, because TIMESTAMP is actually a 32 bit integer and doesn't allow to store dates beyond 2038-01-19 03:14:07 UTC, while DATETIME allows us to store dates up to 9999-12-31 23:59:59.999999.\n\nIn PostgreSQL we usually store date and time values using the column types (or simply ) or (or simply ). Both types have a range of 4713 BC to 294276 AD.\n\nThe values are stored and retrieved as is:\n\nIn this example, we create a column called created_at. And, we can clearly see that the date and time value is stored and retrieved from this column as is. If we specify the time zone, the time zone is ignored.\n\nThe ( ) values are converted from the specified time zone to UTC. If you don't specify the time zone when inserting a value, PostgreSQL will assume that this date value is based on the current time zone ( ).\n\nWhat happens in this example is the following:\n• We create a table with a column called created_at which has type .\n• We set the current time zone for the session to UTC+3. Please note, that in PostgreSQL we can specify the current time zone using an integer offset or the time zone name (e.g., America/New_York). To get a list of supported time zone names query the pg_timezone_names table:\n• We ensure that the time zone offset has been set properly.\n• We insert a row with the created_at value of 2021-05-12 09:00:00 +01:00 into the new table. Because created_at column has type , PostgreSQL converts the date value from the specified time zone (+01:00 in our case) to UTC for storage. So, the value that has been actually stored is \"2021-05-12 08:00:00\".\n• We select the inserted row from the table and the date value is converted from UTC to the current time zone offset, which is UTC+3.\n• We insert another row into the table, but this time without specifying the time zone offset. If we don't include a time zone offset, PostgreSQL assumes that the date value we provide is based on the current time zone, which in our case is UTC+3. So, before storing this date value PostgreSQL will convert it from the current time zone (UTC+3 in our case) to UTC, and the following date value will be stored: 2021-05-12 06:00:00 UTC\n• Finally we select all rows from our table again and see that the date value we've just inserted is displayed in the current time zone: 2021-05-12 09:00:00+03\n\nTo store a date and time value in PostgreSQL I'd use the type. Basically, I'd choose timestamptz instead of timestamp, because of the reasons mentioned in the following article from the PostgreSQL Wiki: Don't Do This - Date/Time storage.\n\nYou can use the string and number data types to store dates and timestamps. We can use the string data type to store date and time values in ISO 8601 format (e.g., 2021-05-12, 2021-05-12T21:00:59.123Z). And we can use the number data type to store date and time values as UNIX timestamps (Epoch time) - a number of seconds since 1 January 1970 00:00:00 UTC. This will allow us to sort and query items by date and time.\n\nIn MongoDB, internally, dates are stored as 64-bit signed integers representing a number of milliseconds since the Unix epoch (1 January 1970 00:00:00 UTC). Negative values represent the dates before the Unix epoch.\n\nTo insert a date in the Mongo shell, we can use the Date object:\n\nYou can pass an ISO 8601 string or a number of milliseconds since the Unix epoch into the Date constructor:\n\nIf you specify a time zone offset, the date will be converted to UTC:\n\nTake care when working with date and time. Always check if the dates you store and work with are based on the time zone you expect. Ensure that the environments you use for running different parts of your app (e.g., a web server, a database, etc.) have the correct and consistent time zone configuration."
    }
]