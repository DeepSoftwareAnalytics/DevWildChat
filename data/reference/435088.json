[
    {
        "link": "https://w3schools.com/js/js_es6.asp",
        "document": "ES6 is fully supported in all modern browsers since June 2017:\n\nES6 is not supported in Internet Explorer.\n\nThe keyword allows you to declare a variable with block scope.\n\nRead more about in the chapter: JavaScript Let.\n\nThe keyword allows you to declare a constant (a JavaScript variable with a constant value).\n\nConstants are similar to let variables, except that the value cannot be changed.\n\nRead more about in the chapter: JavaScript Const.\n\nYou don't need the keyword, the keyword, and the curly brackets.\n\nArrow functions do not have their own . They are not well suited for defining object methods.\n\nArrow functions are not hoisted. They must be defined before they are used.\n\nUsing is safer than using , because a function expression is always a constant value.\n\nYou can only omit the keyword and the curly brackets if the function is a single statement. Because of this, it might be a good habit to always keep them:\n\nLearn more about Arrow Functions in the chapter: JavaScript Arrow Function.\n\nDestructuring assignment makes it easy to assign array values and object properties to variables.\n\nDestructuring assignment makes it easy to assign array values and object properties to variables.\n\nThe ... operator expands an iterable (like an array) into more elements:\n\nThe ... operator can be used to expand an iterable into more arguments for function calls:\n\nThe JavaScript statement loops through the values of an iterable objects.\n\nlets you loop over data structures that are iterable such as Arrays, Strings, Maps, NodeLists, and more.\n\nThe loop has the following syntax:\n\nvariable - For every iteration the value of the next property is assigned to the variable. Variable can be declared with , , or .\n\niterable - An object that has iterable properties.\n\nLearn more in the chapter: JavaScript Loop For/In/Of.\n\nLearn more about Map objects, and the difference between a Map and an Array, in the the chapter: JavaScript Maps.\n\nLearn more about Set objects in the the chapter: JavaScript Sets.\n\nUse the keyword to create a class.\n\nThe example above creates a class named \"Car\".\n\nThe class has two initial properties: \"name\" and \"year\".\n\nWhen you have a class, you can use the class to create objects:\n\nLearn more about classes in the the chapter: JavaScript Classes.\n\nA Promise is a JavaScript object that links \"Producing Code\" and \"Consuming Code\".\n\n\"Producing Code\" can take some time and \"Consuming Code\" must wait for the result.\n\nLearn more about Promises in the the chapter: JavaScript Promises.\n\nA JavaScript Symbol is a primitive data type just like Number, String, or Boolean.\n\nIt represents a unique \"hidden\" identifier that no other code can accidentally access.\n\nFor instance, if different coders want to add a person.id property to a person object belonging to a third-party code, they could mix each others values.\n\nUsing Symbol() to create a unique identifiers, solves this problem:\n\nES6 allows function parameters to have default values.\n\nThe rest parameter (...) allows a function to treat an indefinite number of arguments as an array:\n\nThe method returns if a string contains a specified value, otherwise :\n\nThe method returns if a string begins with a specified value, otherwise :\n\nThe method returns if a string ends with a specified value, otherwise :\n\nThe method returns an Array Iterator object with key/value pairs:\n\nThe method does not change the original array.\n\nThe method returns an Array object from any object with a length property or any iterable object.\n\nThe method returns an Array Iterator object with the keys of an array.\n\nThe method returns the value of the first array element that passes a test function.\n\nThis example finds (returns the value of ) the first element that is larger than 18:\n\nThe method returns the index of the first array element that passes a test function.\n\nThis example finds the index of the first element that is larger than 18:\n\nES6 added the following methods to the Math object:\n\nreturns if x is negative, null or positive:\n\nES6 added the following properties to the Number object:\n\nThe method returns if the argument is an integer.\n\nA safe integer is an integer that can be exactly represented as a double precision number.\n\nThe method returns if the argument is a safe integer.\n\nThe global method returns if the argument is or .\n\nThe global method returns if the argument is . Otherwise it returns :\n\nModules are imported in two different ways:\n\nLearn more about Modules in: JavaScript Modules."
    },
    {
        "link": "https://nodejs.org/en/learn/getting-started/ecmascript-2015-es6-and-beyond",
        "document": "Node.js is built against modern versions of V8. By keeping up-to-date with the latest releases of this engine, we ensure new features from the JavaScript ECMA-262 specification are brought to Node.js developers in a timely manner, as well as continued performance and stability improvements.\n\nAll ECMAScript 2015 (ES6) features are split into three groups for shipping, staged, and in progress features:\n• All shipping features, which V8 considers stable, are turned on by default on Node.js and do NOT require any kind of runtime flag.\n• Staged features, which are almost-completed features that are not considered stable by the V8 team, require a runtime flag: .\n• In progress features can be activated individually by their respective harmony flag, although this is highly discouraged unless for testing purposes. Note: these flags are exposed by V8 and will potentially change without any deprecation notice.\n\nWhich features ship with which Node.js version by default?\n\nThe website node.green provides an excellent overview over supported ECMAScript features in various versions of Node.js, based on kangax's compat-table.\n\nWhich features are in progress?\n\nNew features are constantly being added to the V8 engine. Generally speaking, expect them to land on a future Node.js release, although timing is unknown.\n\nYou may list all the in progress features available on each Node.js release by grepping through the argument. Please note that these are incomplete and possibly broken features of V8, so use them at your own risk:\n\nI have my infrastructure set up to leverage the --harmony flag. Should I remove it?\n\nThe current behavior of the flag on Node.js is to enable staged features only. After all, it is now a synonym of . As mentioned above, these are completed features that have not been considered stable yet. If you want to play safe, especially on production environments, consider removing this runtime flag until it ships by default on V8 and, consequently, on Node.js. If you keep this enabled, you should be prepared for further Node.js upgrades to break your code if V8 changes their semantics to more closely follow the standard.\n\nHow do I find which version of V8 ships with a particular version of Node.js?\n\nNode.js provides a simple way to list all dependencies and respective versions that ship with a specific binary through the global object. In case of the V8 engine, type the following in your terminal to retrieve its version:"
    },
    {
        "link": "https://explainthis.io/en/swe/es6",
        "document": "Your support will help us to continue to provide quality content. 👉 Buy Me a Coffee\n\nIn a previous article, What is ECMAScript? What is it to do with JavaScript?, we discussed the role of ECMAScript as the standard that defines new features and syntax for JavaScript.\n\nAdditionally, we mentioned that ES6, also known as ES2015, is a milestone version that introduced many long-awaited syntax improvements and new features. These additions significantly enhance developers' programming experience and efficiency.\n\nIn this article, we will focus on introducing some of the key new features of ES6 (ES2015).\n\nES6 introduced the and keywords to provide better ways to declare variables. allows you to declare block-scoped variables, meaning the variable is only accessible within the block it is defined. is used to declare constants, which are variables that cannot be reassigned after their initial assignment.\n• What Is the Difference Between var, let and const in JavaScript?\n\nArrow functions offer a more concise way to write functions and automatically bind the keyword to the surrounding context. This helps avoid common issues with the keyword in JavaScript.\n• What is an Arrow Function? How Does It Differ from Regular Functions?\n\nTemplate literals are enclosed by backticks (```) and allow for easier string concatenation and embedding of variables. They make the code more readable and maintainable.\n\nDestructuring assignment is a syntax that allows you to extract values from arrays or objects and assign them to variables in a more readable way.\n\nDefault parameters allow you to set default values for function parameters. This ensures that functions behave as expected even if some arguments are not provided.\n\nThe spread operator ( ) allows you to expand arrays or objects into individual elements. Rest parameters collect multiple arguments into a single array. These features make working with functions and data structures more flexible.\n\nFor more information, check out:\n\nES6 introduced the concept of classes, providing a clearer and more familiar syntax for creating objects and handling inheritance. While JavaScript classes are syntactic sugar over its existing prototype-based inheritance, they make the code more organized and easier to understand, especially for those coming from other object-oriented programming languages.\n• What is a class in ES6? How Does It Differ from Constructor Functions?\n\nES6 provides official support for modules, allowing you to import and export code between different files using the and keywords. This promotes better code organization and reuse.\n\nPromises are a mechanism for handling asynchronous operations in JavaScript. They help avoid \"callback hell\" by providing a more manageable and readable way to handle asynchronous code, making it easier to work with operations like data fetching or file reading.\n• What is a Promise? What Are Its Uses?"
    },
    {
        "link": "https://auth0.com/blog/a-rundown-of-es6-features",
        "document": "In this article we will go over the new features of JavaScript/ECMAScript 2015, a major update to the language. We will make special emphasis on how these features can help in the development of ever bigger systems and how they compare to the old way of doing things. We will also show you how to set up a modern project with ECMAScript 2015 plus async/await support. Read on!\n\nSince its inception, JavaScript had one way of declaring variables using the\n\nstatement, which obeys the rules ofdeclarations act as if the variables are declared at the top of the current execution context (function).\n\nVariable declarations in many other popular languages are restricted to the lexical scope of the enclosing block, so newcomers to JavaScript may completely ignore the semantics of\n\n. For big codebases variable hoisting can result in unexpected and sometimes suprising behavior.\n\nECMAScript 2015 introduces two new ways of declaring variables:\n\nand. The behavior of these statements is much more in line with what other languages do.\n\nstatement works exactly as thestatement but with a big difference:declarations are restricted to the enclosing scope and are only available from the point where the statement is located onwards. Variables declared usinginside a block are only valid within that block and only after thatstatement. This behavior is much more intuitive. Usingis encouraged in place ofin most cases.\n\nand a JavaScript object or primitive. This same name may later be rebound to a different object or primitive. In other words:\n\nstatement, in contrast to theandstatements, does not allow rebinding the name to a different object after the initial declaration:\n\nIt is important to note that\n\ndoes not affect writability in any way. This is in contrast to the notion offrom languages such as C and C++. Arguably, the choice ofas a name may have not been a good idea.\n\nPlacing stricter requirements on the way certain bindings can be manipulated can prevent coding mistakes. In this sense, both\n\nJavaScript makes use of many functional features with closures and anonymous functions being essential. Arrow functions introduce a new, shorter syntax for declaring them. Let's see:\n\nArrow functions behave differently when it comes to\n\n, and. All of these are local predefined declarations inside the scope of a function. Arrow functions inherit the values from the enclosing function rather than declaring their own version of these elements. This prevents mistakes and unclutters certain common coding patterns:\n\nIt is very easy to make a mistake like this. The old way of fixing this was rather cumbersome:\n\nWith ECMAScript 2015 things are simpler and obvious:\n\nSince its inception JavaScript has supported object-oriented programming. However the form of OOP implemented by JavaScript was not entirely familiar for many developers, especially those coming from the Java and C++ family of languages, which implement objects in the spirit of Simula 67. JavaScript, however, implements objects in the spirit of Self. This model of OOP is known as prototype based programming.\n\nPrototype-based programming can be unintuitive for developers coming from other object models, which resulted in many JavaScript libraries coming up with their own way of using objects. These ways are sometimes incompatible. Prototype-based programming is powerful enough to model a class-based programming model, and library writers have come up with many ways of doing so.\n\nThe lack of consensus on the way of doing this has caused fragmentation and coupling problems between libraries. ECMAScript 2015 attempts to fix this by providing a common way of doing class-based programming on top of prototypes. This has resulted in some controversy in the community as many view the prototype based approach as superior.\n\nClasses in ECMAScript 2015 are syntactic sugar for modeling classes on top of prototypes:\n\nWhich in a prototype based approach could look like:\n\nThe exact steps taken by the JavaScript interpreter to translate classes to a prototype chain are available in the JavaScript specification.\n\nThe actual usefulness of classes compared to lean prototypes for big projects is a matter of active discussion. Some people argue that class based designs are harder to extend as the codebase grows, or, to paraphrase, that class-based designs require more forethought. Class proponents, on the other hand, argue that classes are more easily understood by developers coming from other languages and tried and proved designs are readily available as proof of their usefulness.\n\nWhatever your thoughts on the matter, one thing is clear: if you prefer to stick to a class-based approach, there is now one officially sanctioned way of doing so. Otherwise, use prototypes to your heart's content.\n\nAnother feature born out of practicality are the improvements to object literal declarations. Take a look:\n\nFor contrast, the old way of doing things would require something like:\n\nAnything that aids in readability and keeps blocks of code that should belong together as close as possible helps to reduce the chances of making a mistake.\n\nThere comes a time in every project in which you will need to interpolate values into a string. The standard way of doing this in JavaScript was through repeated concatenations:\n\nNot very pretty, or maintainable for that matter. Imagine a much longer string with more values. Things can get out of hand rather quickly.\n\nFor this reason libraries such as\n\nMuch better, but very much like C's sprintf, perfect correlation between the format string and the values passed to sprintf is required. Remove an argument from the call and now you have a bug.\n\nECMAScript 2015 brings a much better solution to the table:\n\nSimple and harder to break! An additional feature of these new string literals is multiline support:\n\nOther additions with regards to strings are raw strings and tag functions. Raw strings can help to prevent mistakes related to escape sequences and quote characters:\n\nThe syntax may look odd if you don't grok string tags yet:\n\nTag functions are essentially functions that transform string literals in arbitrary ways. As you can imagine, they can be abused in ways that impair readability, so use them with care.\n\nOne of the biggest features in ECMAScript 2015. Promises attempt to bring some readability to the asynchronous nature of JavaScript. If you are a seasoned JavaScript developer you know callbacks and closures rule the day. You do know, as well, they are pretty flexible. That means everyone gets to choose how to use them. And in a dynamic language noone will hold your hand if mix two callback conventions unexpectedly.\n\nHere's what JavaScript looked like without promises:\n\nThis is deceptively simple. Why \"deceptively\"? Because it is actually a minefield for future coders (or yourself!). Let's go through it step by step. What we see first is\n\n. Presumably, this variable contains a statement or command in a database specific language. It could say something like \"take this value and update the database in the right place\". Butdoes not prevent rebindingto something else later, so if by chance someone writes:\n\nwhat you get is...a BUG!\n\nBut this has nothing to do with promises, let's move on:\n\nTake a closer look at this code. You can see here two types of callbacks, one nested in the other, with different conventions regarding how to handle errors and how to pass the results of a successful call. Inconsistency is a big factor when it comes to dumb mistakes. Not only that, the way they are nested prevents the exception handler from being the sole point of failure in the block, so\n\nneeds to be called twice with the exact same arguments. This is particularly dangerous. What if someone changes the code in the future to add a new failing branch. Will he or she remember to do the rollback? Will he or she even see it? Lastly, the logger is also called multiple times just to show the current error, and the argument passed to it is constructed using string concatenation, another source of dumb mistakes. In other words, this function leaves the door open to many bugs. Let's see how ECMAScript 2015 can help us prevent them:\n\nThis is beautiful. All of the conflict points outlined before are neutralized by ECMAScript 2015. It is much harder to make mistakes when presented with code like this, and it is much simpler to read. Win-win.\n\nIf you are asking yourself why we return the result from\n\nit is because promises can be chained. In other words, a promise can take the result of the next promise in the chain in case it succeeds, or it can perform the right action in case of failure. Let's see how that works in the example above.\n\nThe first promise is the one created by\n• You can do something with the data passed to your function (either the result or the error) and return a value, a promise or nothing.\n• You can throw an exception.\n\n. This is our outtermost promise and will be the one that tells us if everything went well or something failed. To do something in any of those cases, we can useor. It is not necessary to call any of these functions. You can call one, you can call both (as we do above) or you can disregard the results completely. Now, inside any of these handlers two things can happen:\n\nIn case an exception is thrown, both\n\nandknow how to handle that: as an error condition. In other words, the nextin the chain will get the exception. In our case, the outtermost catch gets all errors, both those generated by thepromise and those generated inside. It is important to note what happens with exceptions thrown inside the outtermost: they are stored inside the promise for a future call toor. If no call is performed (as happens in the example above), it will get ignored. Fortunately,does not throw any exceptions.\n\nIt is important to note that chaining promises is usually the right thing to do. In the example above, we could have ommitted the\n\nstatement in from of. The code would have worked the same in case no errors were caused by the database operation. However, the code would behave differently if an error were to occur: if the database operation were to fail, theblock below would not get called, as the promise would not be chained to the outtermost one.\n\nSo how can you create your own promises? Easy enough:\n\nPromises can be chained inside the promise constructor as well:\n\nHere the full power of promises can be seen: two HTTP requests are chained together into a single promise. Data resulting from the first request is processed and then used to construct the second request. All errors are handled internally by the promise logic.\n\nIn short, promises make asynchronous code more readable and reduce the chances of making mistakes. They also end the discussion of how promises should work, as before ECMAScript 2015 there were competing solutions with their own API.\n\nAnother big feature from ECMAScript 2015. If you come from Python you will get JavaScript generators right away as they are very similar. Take a look:\n\nIf you are not a Python developer then your brain will throw\n\na couple of times while parsing the code from above. Let's take a look at what's going on. The first thing that looks odd is the asterisk right beside thekeyboard. This is the new way of declaring a generator in ECMAScript 2015. After that there'sright inside the function.is a new keyword that signals the interpreter to temporarily halt the execution of the generator and return the value passed to it. In this case,will return whatever value is in. Repeated calls to the generator will resume execution from the point of the last yield, preserving all state.\n\nIf all of this sounds familiar to you it may be because there is a very similar concept in computer science called coroutine. But coroutines have an additional feature when compared to exceptions: they can accept new data from the outside after each call to\n\n. In fact, JavaScript supports this! So JavaScript generators are in fact coroutines.\n\nHowever, all of this may look superfluous at this point. Why add generators? In which way can they help to keep code tidier and error free? Generators were added to make it easier to bring the concept of iterators into the language. Now, iterators do come up quite a bit in most projects. So what was going on with iterators before ECMAScript 2015? Well, everybody was doing them their way:\n\nSo, in a way, generators attempt to bring a standard way of using iterators. In fact, iterators in JavaScript are nothing more than a protocol, that is, a sanctioned API for creating objects that can be used to iterate over iterables. The protocol is best described by an example:\n\nTake a special look at the object returned from the\n• The function returns an object containing either one or two members. If the member is true, then no other member is present. flags whether iteration has completed. The other member shall be and represent the current iteration value.\n\nfunction: it describes the protocol required by JavaScript iterators. In other words, an iterator is an object that:\n\nSo any object that adheres to this protocol can be called a JavaScript iterator. This is good, having an official way of doing this means mixing different libraries won't result in 6 different types of iterators being present (and having to use adapters between them if necessary!). Conventions and protocols are good for maintainability, because there are less chances of mixing things that look alike but aren't the same. A thing dangerously easy to do in JavaScript.\n\nSo, having to write iterators this way, although simple, can be cumbersome. What if JavaScript provided a way to create these objects easily? These are generators. Generator functions in fact return iterators. In other words, JavaScript generators are helpers to create iterators in a more convenient way. In particular, the use of generators and the\n\nkeyword helps in making it simpler to understand the way state is managed inside the iterator. For example, the example above could be written as simply:\n\nSimple, and much easier to read and understand, even for an inexperienced developer. Code clarity is crucial for maintainability.\n\nBut we are missing one key piece in the generator and iterators puzzle: there are many things that are iterable. In particular, collections are generally iterated over. Of course, the way elements are iterated over in a collection changes according to the collection in question, but the concept of iteration applies nonetheless. So ECMAScript 2015 provides two more pieces that complete the iterators and generators puzzle: the iterable protocol and\n\nIterables are objects that provide a convenient interface to construct iterators from them. In other words, iterables are objects that provide the following key:\n\nand theobject are new in ECMAScript 2015, so this looks very odd. We will go overlater on in this guide, but for now think of it as a way to create unique identifiers (symbols) that can be used to index other objects. Another odd thing here is the literal object syntax. We are usinginside an object literal to set its key. We've gone over this extension of object literals above. This is no different from the example we presented there:\n\nSo, in short, iterables are objects that provide a\n\nkey whose value is a generator function.\n\nSo now we have a new key inside objects that can be iterated over. Do we need to explicitly get the generator from them everytime we want to iterate over the elements managed by them? The answer is no! Seeing this is quite a common pattern (iterating over elements managed by a container), JavaScript now provides a new version of the\n\nYes! All iterable objects can be easily iterated over with the use of the new\n\nloop. And the good thing aboutis that existing collections have been adapted for use with it. So, arrays and the new collections () can all be used this way:\n\nNote the odd syntax in the last\n\nloop:. This is called destructuring and is another new feature of ECMAScript 2015. We will talk about it later.\n\nConsistency and simplicity can do wonders for readability and maintainability, and this is exactly what iterators, iterables, generators and the\n\nFunctions now support default arguments, simplifying the common pattern of checking whether an argument exists and then setting its value.\n\nAs the number of arguments grows, default arguments simplify the flow of the checks required at the start of the function. And simplicity is good when coding.\n\nDefault arguments also work with the\n\nvalue. In other words, when passingto a default argument, the argument will take its default value instead.\n\nThis, however, does not preclude proper API design. In the example above, users might be tempted to pass the third argument as the second one, in particular when using\n\n. So, although this can help to redeuce boilerplate inside functions, care must be taken when picking the right order of arguments and their default values.\n\noperator is a new operator inspired by the one from C, take a look:\n\nOf course, JavaScript did allow access to arguments not declared in the argument list of a function through\n• To remove the need to manually find the first argument that is not named in the argument list. This prevents silly off-by-one mistakes that usually happen when arguments are added or removed to a function.\n• To be able to use the variable containing non-declared arguments as a true JavaScript array. Since its inception, has always behaved like an array without actually being one. In contrast, the variable created with the rest operator is a true array, bringing consistency, which is always good.\n\n. So why use the rest operator? There are two good reasons:\n\nSince the variable declared through the rest operator is a true array, extensions such as\n\nand, present in, are not available.\n\nA way to quickly understand spread syntax is to think of it as the opposite to the rest operator. Spread syntax substitutes argument lists with the elements from an array (or any iterable, in fact). In other words:\n\nSpread syntax can be used in places other than function calls. This opens the possibility for interesting applications:\n\nSpread syntax removes one troublesome limitation from past versions of JavaScript: the\n\noperator could not be used withtakes a function object as a parameter, andis an operator. In other words, it was not possible to do something like:\n\nWe can now do:\n\nSpread syntax simplifies a number of common patterns. And simplicity is always good for readability and maintainability.\n\nDestructuring is an extension of JavaScript's syntax that allows for certain interesting ways of transforming a single variable into multiple variables bound to its internals. We have already seen one example of this above:\n\nIn this case, the variable\n\nis bound to a. This data structure conforms to the iterable protocol and provides to values per iteration: a key, and an associated value to that key. These two values are returned inside an array of two elements. The key if the first element, and the value is the second element.\n\nWithout destructuring, the above code would look like this:\n\nThe ability to map the internal structure of objects to variables using syntax that is identical to the original structure clarifies code. Let's see other examples:\n\nThat was simple array destructuring. What about objects?\n\nThis is getting interesting. Look at this example:\n\nIt is possible to pick different names for destructured elements:\n\nFailure to destructure and object correctly will result in variables with undefined values.\n\nDestructuring can be combined with default arguments (another new feature in ECMAScript 2015). This simplifies certain common coding patterns:\n\nProper care must be taken with default arguments and destructuring as ECMAScript 2015 does not allow the capture of any keys not declared in the destructuring expression. In other words, if the object passed as the second argument in the example above had a third key (let's say key\n\n), it would not be possible to access it (except by going through, which would be cumbersome and impair readability). This omission will be fixed in ECMAScript 2016.\n\nArrays do possess this ability in ECMAScript 2015:\n\nArray allow skipping items as well:\n\nArguably, destructuring is a new way rather than a better way of doing things. My personal advice is to keep things simple and readable. Do not overuse destructuring when a simple reference to an inner variable can be written as\n\n. Destructuring is of particular use when \"picking\" multiple elements from objects at different nest levels. In this case, readability can be improved. It is also useful in function arguments andloops to reduce the number of helper variables needed.\n\nModules are one of the most expected features from ECMAScript 2015, providing a standard way to extend JavaScript and separating code in different places in a convenient, portable, and performant way.\n\nAs JavaScript was conceived as a language for the web, it has always been associated to HTML files. HTML files tell browsers to load scripts placed in other files or inline. Previously loaded scripts can create global objects that are available for future scripts. Up to ECMAScript 2015 this was the only rudimentary way in which code from different JavaScript files could communicate with each other. This resulted in a plethora of different ways of handling this. Module \"bundlers\" were born out of necessity to bring some sanity to this situation.\n\nJavaScript interpreters for other environments (such as Node.js) adapted solutions such as Common.js. Other specifications such as Asynchronous Module Definition (AMD) also appeared. The lack of concensus in the community forced the ECMAScript working group to take a look at the situtation. The result is ECMAScript 2015 modules.\n\nECMAScript 2015 add a couple of keywords to the language:\n\nand. Thekeyword lets you bring elements from other modules into the current module. These elements can be renamed during import, or can be bulk imported. The export keyword does the oposite: it marks elements from the current module as available for import. Elements imported from other modules can be re-exported.\n\nAn interesting aspect of ECMAScript 2015 modules is that the semantics of\n\nallow for either parallel or sequential loading of modules. In other words, interpreters are free to choose what is more appropriate. This is in stark contrast with Common.js (sequential) and AMD modules (asynchronous).\n\nandare static in nature. In other words, effects from using these keywords must be fully computable before execution of the script. This opens up the possibility for static analyzers and module bundlers to do their magic. Module bundlers such as Webpack could construct a dependecy tree at packing-time that would be complete and deterministic. In other words, removing unneeded dependencies and other optimizations are possible and entirely supported by the specification. This is a big difference with regards to both Common.js and AMD.\n\nBut static modules do remove some flexibility that is handy in some scenarios. Unfortunately, the dynamic loader proposal did not make it into ECMAScript 2015. It is expected to be added in future versions. A proposal already exists in the form of\n\nCan we use modules now?\n\nYes, and you should! Although module loading is not implemented in browsers yet, bundlers, compilers and libraries such as Babel, Webpack and System.js have implemented ECMAScript 2015 modules. The benefit of adopting modules early is that they are already part of the spec! You know one way or the other, modules are set in stone and won't see major changes in future versions of JavaScript. Using Common.js or AMD today implies taking a step back and adopting solutions that will fade out in the future.\n\nAlthough JavaScript has the necessary power to implement many data structures, some of them are better implemented through optimizations only available to the interpreter. The ECMAScript 2015 working group decided to tackle this issue and came up with\n\nstores unique objects. Objects can be tested for presence in the set.uses special comparison semantics (which mostly resemble) to check for object equality.\n\nextendsto associate arbitrary values with unique keys. In other words,allows the use of arbitrary unique keys, in contrast with common JavaScript objects (which only allow strings as keys).\n\nbehaves like a set but does not take ownership of the objects stored in it. In other words, objects inside abecome invalid after no references to them are available from outside the set.only allows objects to be stored in it, primitive values are not allowed.\n\nis weak in the keys (like) and strong in the values it stores.\n\nJavaScript has always been lean in the data structures department. Sets and maps are one of the most used data structures, so integrating them in the language comes with a set of benefits:\n• Less code to test (if a map or set is implemented in-code, tests are required for their functionality)\n• Consistent API for one of the most common requirements\n\nUnfortunately, hash-based maps are still not available.\n\nAnother big addition to ECMAScript 2016. Object proxies let you customize the behavior of objects in interesting ways. JavaScript, by virtue of being a dynamic language, is very flexible when it comes to modifying objects. However, certain modifications are better expressed through the use of proxies. For example, let's see how we can modify all get operations of all properties of an object to add one in case the property is a number. Let's tackle this problem using ECMAScript 5 first.\n\nHere we make use of the prototype mechanism in JavaScript to shadow variables in an object that looks like the original one. The shadow object has a custom setters and getters that access the variables from the prototype object. It works, but it is a bit hard to follow. Let's see how ECMAScript 2015 improves this.\n\nThis is much clearer: no superfluous iteration of keys, no need to explicitly override the setter, no fiddling with the prototype chain. And as we have said before: clearer code is better code.\n\nAnother perk of proxies is that they can override operations that would be hard (or impossible) to override otherwise. For example, proxies can modify the behavior of constructors:\n\nProxies are a nice addition to the dynamic capabilities of JavaScript and the complement to them is reflection. For every operation that can be caught and overriden by a proxy, the\n\nobject allows access to that operation with the same consistent API. In other words, if proxies provide aoperation that overrides access to properties,provides aoperation that provides access to a property.\n\nThe objective of the reflection API is to bring consistency to certain operations that used to be performed in other ways. The utility of these functions is arguably not as important as the Proxy API, but still a welcome addition.\n\nSymbols are a new primitive data type in JavaScript. In contrast with existing data types, symbols have no real value. Their strength lies in their uniqueness. All symbols are unique and immutable. Symbols are primarily used as object keys. Symbol object keys are distinct from string keys and are not enumerated by\n\nnor seen by\n\nThe main use of symbols is to create special keys inside objects. ECMAScript 2015 uses the symbol facility to define certain very specific keys. For instance, iterable objects define their iterator using\n\nSymbols can help you to prevent polluting an object with keys that are better opaque. Symbols can carry a helper message to ease debugging. However, two symbols carrying the same message are still distinct.\n\nBy keeping the namespace of special object keys separate from common keys, ECMAScript 2015 makes debugging easier, object serialization simpler, and it reduces the chances of hitting bugs caused by key name collisions.\n\nOne of the pitfalls of JavaScript is the lack of proper numeric types. Most of the time, it is possible to get around this limitation somehow. However, efficient storage of big quantities of numeric values can't be achieved. This is solved with typed arrays.\n\nTyped arrays provide efficient storage for signed and unsigned integers of 8, 16 and 32 bits. There are also floating point versions for 32-bit and 64-bit values.\n\nAdding to the controversial nature of ECMAScript 2015 classes, most built-in objects can now be subclassed.\n\nSubclassing should be preferred to manipulating the prototype of built-ins, and proxies should be preferred over these two options. Ultimately it is up to you to pick the best option for your use case. In general terms, behavior reuse is better expressed through composition or proxies than subclassing, so use this feature with care.\n\nMany functional programming languages perform tail-call optimization. Tail-call optimization handles the conversion of certain recursive function calls into loops. This conversion avoids stack overflows. JavaScript brings many functional features to the table, but this one was sorely missing until ECMAScript 2015. Certain algorithms are better expressed through recursion rather than loops.\n\nTail-call optimization requires functions to be in tail-call position, that is, the branch that spawns the next call to the recursive function must be the last call of that branch, no pending operations should remain there. This is the reason the example above is a bit more convoluted than the straight implementation shown below.\n\nIn this example the last operation in one of the branches is the multiplication of\n\nby the recursive function. In other words, the recursive function is not in tail position and tail call optimization cannot be performed.\n\nSome language implementations are smart enough to convert this last example into the former, enabling tail call optimization. This is not required nor expected of ECMAScript 2015 implementations, so one should not depend on it.\n\nTail-call optimization is an interesting addition to the JavaScript toolbox. However, it should only be used when clarity is improved by it.\n\nAlthough JavaScript did support Unicode before ECMAScript 2015, there are some interesting additions. The new Unicode escape sequence is the most prominent of them:\n\nBefore ECMAScript 2015, to specify a character such as the above without putting it literally in the source, one would have to put the explicit surrogate-pair:\n\nRegular expressions now support embedded codepoints in the pattern via de\n\nBinary and octal literals are now available:\n\nECMAScript 2015 is a major update to JavaScript. Many of the improvements talked about for years are now available. These features make JavaScript much more suitable for big-scale development. Certain common patterns are simplified, clarity is improved and expressiveness is increased. Although ECMAScript 2015 support is a problem when targetting old browsers or environments, transpilers such as Babel and Traceur let you reap the benefits today. As most JavaScript projects nowadays make use of bundlers, the use of transpilers is simple and convenient. There is no reason you should not use ECMAScript 2015 and reap the benefits today!"
    },
    {
        "link": "https://262.ecma-international.org/6.0",
        "document": "Additions and Changes That Introduce Incompatibilities with Prior Editions 7.1.3.1: In ECMAScript 2015, ToNumber applied to a String value now recognizes and converts BinaryIntegerLiteral and OctalIntegerLIteral numeric strings. In previous editions such strings were converted to NaN, 6.2.3: In ECMAScript 2015, Function calls are not allowed to return a Reference value. 11.6: In ECMAScript 2015, the valid code points for an IdentifierName are specified in terms of the Unicode properties “ID_Start” and “ID_Continue”. In previous editions, the valid IdentifierName or Identifier code points were specified by enumerating various Unicode code point categories. 11.9.1: In ECMAScript 2015, Automatic Semicolon Insertion adds a semicolon at the end of a do-while statement if the semicolon is missing. This change aligns the specification with the actual behaviour of most existing implementations. 12.2.6.1: In ECMAScript 2015, it is no longer an early error to have duplicate property names in Object Initializers. 12.14.1: In ECMAScript 2015, strict mode code containing an assignment to an immutable binding such as the function name of a FunctionExpression does not produce an early error. Instead it produces a runtime error. 13.5: In ECMAScript 2015, a StatementListItem beginning with the token followed by the token is the start of a LexicalDeclaration. In previous editions such a sequence would be the start of an ExpressionStatement. 13.6.7: In ECMAScript 2015, the normal completion value of an IfStatement is never the value empty. If no Statement part is evaluated or if the evaluated Statement part produces a normal completion whose value is empty, the completion value of the IfStatement is undefined. 13.7: In ECMAScript 2015, if the token of a for statement is immediately followed by the token sequence then the is treated as the start of a LexicalDeclaration. In previous editions such a token sequence would be the start of an Expression. 13.7: In ECMAScript 2015, if the ( token of a for-in statement is immediately followed by the token sequence then the is treated as the start of a ForDeclaration. In previous editions such a token sequence would be the start of an LeftHandSideExpression. 13.7: Prior to ECMAScript 2015, an initialization expression could appear as part of the VariableDeclaration that precedes the keyword. The value of that expression was always discarded. In ECMAScript 2015, the ForBind in that same position does not allow the occurrence of such an initializer. 13.7: In ECMAScript 2015, the completion value of an IterationStatement is never the value empty. If the Statement part of an IterationStatement is not evaluated or if the final evaluation of the Statement part produces a completion whose value is empty, the completion value of the IterationStatement is undefined. 13.11.7: In ECMAScript 2015, the normal completion value of a WithStatement is never the value empty. If evaluation of the Statement part of a WithStatement produces a normal completion whose value is empty, the completion value of the WithStatement is undefined. 13.12.11: In ECMAScript 2015, the completion value of a SwitchStatement is never the value empty. If the CaseBlock part of a SwitchStatement produces a completion whose value is empty, the completion value of the SwitchStatement is undefined. 13.15: In ECMAScript 2015, it is an early error for a Catch clause to contained a declaration for the same Identifier that appears as the Catch clause parameter. In previous editions, such a variable declaration would be instantiated in the enclosing variable environment but the declaration’s Initializer value would be assigned to the Catch parameter. 13.15, 18.2.1.2: In ECMAScript 2015, a runtime SyntaxError is thrown if a Catch clause evaluates a non-strict direct whose eval code includes a or declaration that binds the same Identifier that appears as the Catch clause parameter. 13.15.8: In ECMAScript 2015, the completion value of a TryStatement is never the value empty. If the Block part of a TryStatement evaluates to a normal completion whose value is empty, the completion value of the TryStatement is undefined. If the Block part of a TryStatement evaluates to a throw completion and it has a Catch part that evaluates to a normal completion whose value is empty, the completion value of the TryStatement is undefined if there is no Finally clause or if its Finally clause evalulates to an empty normal completion. 14.3.9 In ECMAScript 2015, the function objects that are created as the values of the [[Get]] or [[Set]] attribute of accessor properties in an ObjectLiteral are not constructor functions and they do not have a own property. In the previous edition, they were constructors and had a property. 19.1.2.5: In ECMAScript 2015, if the argument to is not an object it is treated as if it was a non-extensible ordinary object with no own properties. In the previous edition, a non-object argument always causes a TypeError to be thrown. 19.1.2.6: In ECMAScript 2015, if the argument to is not an object an attempt is made to coerce the argument using ToObject. If the coercion is successful the result is used in place of the original argument value. In the previous edition, a non-object argument always causes a TypeError to be thrown. 19.1.2.7: In ECMAScript 2015, if the argument to is not an object an attempt is made to coerce the argument using ToObject. If the coercion is successful the result is used in place of the original argument value. In the previous edition, a non-object argument always causes a TypeError to be thrown. 19.1.2.9: In ECMAScript 2015, if the argument to is not an object an attempt is made to coerce the argument using ToObject. If the coercion is successful the result is used in place of the original argument value. In the previous edition, a non-object argument always causes a TypeError to be thrown. 19.1.2.11: In ECMAScript 2015, if the argument to is not an object it is treated as if it was a non-extensible ordinary object with no own properties. In the previous edition, a non-object argument always causes a TypeError to be thrown. 19.1.2.12: In ECMAScript 2015, if the argument to is not an object it is treated as if it was a non-extensible ordinary object with no own properties. In the previous edition, a non-object argument always causes a TypeError to be thrown. 19.1.2.13: In ECMAScript 2015, if the argument to is not an object it is treated as if it was a non-extensible ordinary object with no own properties. In the previous edition, a non-object argument always causes a TypeError to be thrown. 19.1.2.14: In ECMAScript 2015, if the argument to is not an object an attempt is made to coerce the argument using ToObject. If the coercion is successful the result is used in place of the original argument value. In the previous edition, a non-object argument always causes a TypeError to be thrown. 19.1.2.15: In ECMAScript 2015, if the argument to is not an object it is treated as if it was a non-extensible ordinary object with no own properties. In the previous edition, a non-object argument always causes a TypeError to be thrown. 19.1.2.17: In ECMAScript 2015, if the argument to is not an object it is treated as if it was a non-extensible ordinary object with no own properties. In the previous edition, a non-object argument always causes a TypeError to be thrown. 19.2.3.2: In ECMAScript 2015, the [[Prototype]] internal slot of a bound function is set to the [[GetPrototypeOf]] value of its target function. In the previous edition, [[Prototype]] was always set to %FunctionPrototype%. 19.2.4.1: In ECMAScript 2015, the property of function instances is configurable. In previous editions it was non-configurable. 19.3.3: In ECMAScript 2015, the Boolean prototype object is not a Boolean instance. In previous editions it was a Boolean instance whose Boolean value was false. 19.5.6.2: In ECMAScript 2015, the [[Prototype]] internal slot of a NativeError constructor is the Error constructor. In previous editions it was the Function prototype object. 20.1.3 In ECMAScript 2015, the Number prototype object is not a Number instance. In previous editions it was a Number instance whose number value was +0. 20.3.4 In ECMAScript 2015, the Date prototype object is not a Date instance. In previous editions it was a Date instance whose TimeValue was NaN. 21.1.3.10 In ECMAScript 2015, the function must treat Strings that are canonically equivalent according to the Unicode standard as being identical. In previous editions implementations were permitted to ignore canonical equivalence and could instead use a bit-wise comparison. 21.1.3 In ECMAScript 2015, the String prototype object is not a String instance. In previous editions it was a String instance whose String value was the empty string. 21.1.3.22 and 21.1.3.24 In ECMAScript 2015, lowercase/upper conversion processing operates on code points. In previous editions such the conversion processing was only applied to individual code units. The only affected code points are those in the Deseret block of Unicode 21.1.3.25 In ECMAScript 2015, the method is defined to recognize white space code points that may exists outside of the Unicode BMP. However, as of Unicode 7 no such code points are defined. In previous editions such code points would not have been recognized as white space. 21.2.3.1 In ECMAScript 2015, If the argument is a RegExp instance and the argument is not undefined, a new RegExp instance is created just like except that flags are replaced by the argument . In previous editions a TypeError exception was thrown when was a RegExp instance and was not undefined. 21.2.5 In ECMAScript 2015, the RegExp prototype object is not a RegExp instance. In previous editions it was a RegExp instance whose pattern is the empty string. 21.2.5 In ECMAScript 2015, , , , and are accessor properties defined on the RegExp prototype object. In previous editions they were data properties defined on RegExp instances"
    },
    {
        "link": "https://medium.com/@jcollado/how-to-migrate-your-es5-code-to-es2015-43e669f584ca",
        "document": "As a javascript programmer, I have been writing code without any transpilation step for quite a bit. This has been good enough for me because lately I’ve been writing mostly CLI tools for node.js, which already supports some of the es2015 new features. However, I was curious about how to integrate a transpiler into my workflow and give a try to other new features as I see the need for them.\n\nThis article is a summary of the steps I’ve followed to migrate the code of a few simple projects that I use to experiment with the language and tools ecosystem.\n\nThe kind of project I’m talking about makes use of:\n\nand what I’ve found I need to add is:\n\nThe final state after the migration steps is:\n• Source code is transpiled on the fly when test cases are executed\n• Test coverage report lines are mapped to the original source code\n• The uploaded package includes both the original and the transpiled code\n\nIf this feels similar to what you’re looking for, then let’s move on to the steps.\n\nInstead of start migrating our code directly, let’s first make sure that tests are es2015 aware, so that we get notified if something breaks. One way to do it is to compile code on the fly with the babel require hook, that is, install babel-register:\n\nand then update your npm test script to use babel-register:\n\nThe previous step will run babel over each file that is required in the code while running the test cases. However, that won’t magically apply any transform since babel needs to be configured. In my case, I don’t need to transpile exactly to es5, but to code that node 4 understands, so I use the es2015-node4 preset to skip the transforms that I don’t need:\n\nand update my package.json file (which I prefer over creating a separate .babelrc file):\n\nCode is expected to be transpiled before uploading the package to npm, so that in can be consumed later directly without the transpilation step. Hence, a few considerations need to be taken into account such as the location of the original code and the location of the transpiled code. I tend to write my code under lib, so what I usually do is:\n• Update import paths in test cases to still reference the original code\n\nDepending on your configuration you might want to have a look at:\n• The imports of any script in the binary section of package.json\n\nand make sure they reference the transpiled code not the original source code.\n\nOnce the code layout is ready, then I install babel-cli to have a babel binary that can be executed:\n\nand update npm scripts in package.json as follows:\n\nNote that the prepublish script could call babel directly, but I prefer to have a build script to save a few keystrokes when I want to manually check the transpiled output in the lib directory.\n\nWhen code is transpiled, it will show up as untracked files in the git status output. An update to .gitignore is recommended to avoid putting it under version control by mistake:\n\nUnfortunately, the new pattern will be ignored in both git and npm, unless there’s already an .npmignore file. Commonly there won’t be any, so it’s convenient to create one to ensure that transpiled files are included in the package uploaded to npm. In my case, the package is uploaded in a clean environment in travis and I like to include both the original and the transpiled files, so the only thing I really need to discard from the package are test coverage files:\n\nwhere the .nyc_output directory is for the output files of the nyc tool that is covered later.\n\nAt this point we are completely free to refactor the code using es2015 syntax while being covered by the safety net provided by the test cases we have written. Note that not only the library code can be updated, but also the test cases themselves. Go ahead and do any changes that you need.\n\nAs the code is migrated, you will notice that any coverage script that uses istanbul is not working anymore. In my case, I usually have something like:\n\nAt first this seems pretty easy to fix, because applying the same change as to the test script, that is, adding the babel require hook, should do the job. However, for some reason this doesn’t work for me and, despite the test cases run as expected, I get the following error: No coverage information was collected, exit without writing coverage information.\n\nFortunately, nyc, which is a wrapper around istanbul, works great at addressing this problem. Let’s install it:\n\nand update the coverage script to:\n\nThat’s it. nyc gathers coverage from spawned process automatically, so there’s no longer need to pay attention to the difference between mocha and _mocha binaries.\n\nAnother nice thing about nyc is that it also supports the babel require hook out of the box, so if you have a coverage report script such as:\n\nYou will be able to get your usual istanbul coverage report using the original source files.\n\nWe have gone through all the changes needed to migrate es5 to es2015 code in some library code for node.js. It turns out that it’s easy to do and the actual code migration can be done gradually once all the pieces fit together.\n\nAs a summary, the steps we have followed are:\n• Babel setup page: click on what best defines you environment and get a quick overview about how to install and setup babel.\n• How to Build and Publish ES6 npm Modules Today, with Babel, Alex Booker: I wish I knew about this article before I started my own investigation about babel. There’s significant overlap with what is explained here, so check it out to get a second take on the subject.\n• Setting up ES6, Axel Rauschmayer: this is a great resource to become aware of different scenarios that are also covered by babel."
    },
    {
        "link": "https://stackoverflow.com/questions/35198151/code-migration-from-es5-to-es2015-with-namespace",
        "document": "We have a cross-platform application based on Polymer and Chromium.\n\nCurrently all our JavaScript dependencies are maintained in by importing them in the right order! This approach will be a nightmare soon and writing test and to see the test coverage isn't a easy task.\n\nTo be future save we decided to jump on ES2015 with it's modularity approach.\n\nNow we need to redesign our JavaScript files to be able to maintain the dependencies between single JavaScript modules. So far so good. But how do we do that to preserve our namespaces, closures etc.?\n\nAs you can see from the code above the initialization is executed and assigned to . Due to simplicity, the code snippet doesn't show dependencies to other modules but we have those for sure!\n\nSo the questions are\n• How to use namespaces in ES2015\n• How to export functions of the modules but not in the global scope!\n\nUsing is exporting all functions inside in the global scope, right? How to bind the exported functions to the correct namespace? In this example to"
    },
    {
        "link": "https://medium.com/@atilafassina/es2015-modules-101-d9977dc4d4c7",
        "document": "To keep things simple, consider there are 4 ways of carrying data across your modules. We are going to classify those ways based on the effect they have on the module where they are imported.\n\nI see this as the most concise and common use of a module, this variable could carry actually any kind of information you wish to export from module.js. The export statement is also quite straightforward and simple, check it out:\n\nWhile we're on this, let's have it said that a single import/export statement can carry multiple variables. As in:\n• Default Exports (usually an anonymous function or a class)\n\nThis would be the second most used way, and probably the most necessary to keep your code organised and with its concerns separated. If by the import the difference isn't explicit, let's first check the export before going deeper on the why.\n\nAs you can see, there's another keyword on the statement. And that means there can be only one default export per module. You can combine this type of export with the one mentioned above, therefore you're able to import the same module in different ways along your code — as long as you use export default only ONCE per module. It would look something like the following:\n• The entire content of the file as an object\n\nThis code, brings the entire content (upper scoped variables, functions, etc) from the given module and encapsulates it in the Module object, in that way, the variable foo present in module.js would be accessible through as a property of this imported object (Module.foo)\n• Nothing. Only execute whatever code is in the file.\n\nIn this way, no content from our module.js will be available, though, when your import statement is evaluated, the code inside the file will run."
    },
    {
        "link": "https://typescriptlang.org/docs/handbook/migrating-from-javascript.html",
        "document": ""
    },
    {
        "link": "https://appdynamics.com/blog/engineering/7-ways-es2015-can-improve-your-javascript-programing",
        "document": ""
    }
]