[
    {
        "link": "https://blogs.oracle.com/javamagazine/post/exploring-joshua-blochs-builder-design-pattern-in-java",
        "document": ""
    },
    {
        "link": "https://refactoring.guru/design-patterns/builder",
        "document": "Imagine a complex object that requires laborious, step-by-step initialization of many fields and nested objects. Such initialization code is usually buried inside a monstrous constructor with lots of parameters. Or even worse: scattered all over the client code. You might make the program too complex by creating a subclass for every possible configuration of an object. For example, let’s think about how to create a object. To build a simple house, you need to construct four walls and a floor, install a door, fit a pair of windows, and build a roof. But what if you want a bigger, brighter house, with a backyard and other goodies (like a heating system, plumbing, and electrical wiring)? The simplest solution is to extend the base class and create a set of subclasses to cover all combinations of the parameters. But eventually you’ll end up with a considerable number of subclasses. Any new parameter, such as the porch style, will require growing this hierarchy even more. There’s another approach that doesn’t involve breeding subclasses. You can create a giant constructor right in the base class with all possible parameters that control the house object. While this approach indeed eliminates the need for subclasses, it creates another problem. The constructor with lots of parameters has its downside: not all the parameters are needed at all times. In most cases most of the parameters will be unused, making the constructor calls pretty ugly. For instance, only a fraction of houses have swimming pools, so the parameters related to swimming pools will be useless nine times out of ten.\n\nThe Builder pattern suggests that you extract the object construction code out of its own class and move it to separate objects called builders. The Builder pattern lets you construct complex objects step by step. The Builder doesn’t allow other objects to access the product while it’s being built. The pattern organizes object construction into a set of steps ( , , etc.). To create an object, you execute a series of these steps on a builder object. The important part is that you don’t need to call all of the steps. You can call only those steps that are necessary for producing a particular configuration of an object. Some of the construction steps might require different implementation when you need to build various representations of the product. For example, walls of a cabin may be built of wood, but the castle walls must be built with stone. In this case, you can create several different builder classes that implement the same set of building steps, but in a different manner. Then you can use these builders in the construction process (i.e., an ordered set of calls to the building steps) to produce different kinds of objects. Different builders execute the same task in various ways. For example, imagine a builder that builds everything from wood and glass, a second one that builds everything with stone and iron and a third one that uses gold and diamonds. By calling the same set of steps, you get a regular house from the first builder, a small castle from the second and a palace from the third. However, this would only work if the client code that calls the building steps is able to interact with builders using a common interface. You can go further and extract a series of calls to the builder steps you use to construct a product into a separate class called director. The director class defines the order in which to execute the building steps, while the builder provides the implementation for those steps. The director knows which building steps to execute to get a working product. Having a director class in your program isn’t strictly necessary. You can always call the building steps in a specific order directly from the client code. However, the director class might be a good place to put various construction routines so you can reuse them across your program. In addition, the director class completely hides the details of product construction from the client code. The client only needs to associate a builder with a director, launch the construction with the director, and get the result from the builder.\n\nThis example of the Builder pattern illustrates how you can reuse the same object construction code when building different types of products, such as cars, and create the corresponding manuals for them. The example of step-by-step construction of cars and the user guides that fit those car models. A car is a complex object that can be constructed in a hundred different ways. Instead of bloating the class with a huge constructor, we extracted the car assembly code into a separate car builder class. This class has a set of methods for configuring various parts of a car. If the client code needs to assemble a special, fine-tuned model of a car, it can work with the builder directly. On the other hand, the client can delegate the assembly to the director class, which knows how to use a builder to construct several of the most popular models of cars. You might be shocked, but every car needs a manual (seriously, who reads them?). The manual describes every feature of the car, so the details in the manuals vary across the different models. That’s why it makes sense to reuse an existing construction process for both real cars and their respective manuals. Of course, building a manual isn’t the same as building a car, and that’s why we must provide another builder class that specializes in composing manuals. This class implements the same building methods as its car-building sibling, but instead of crafting car parts, it describes them. By passing these builders to the same director object, we can construct either a car or a manual. The final part is fetching the resulting object. A metal car and a paper manual, although related, are still very different things. We can’t place a method for fetching results in the director without coupling the director to concrete product classes. Hence, we obtain the result of the construction from the builder which performed the job. // Using the Builder pattern makes sense only when your products // are quite complex and require extensive configuration. The // following two products are related, although they don't have // a common interface. class Car is // A car can have a GPS, trip computer and some number of // seats. Different models of cars (sports car, SUV, // cabriolet) might have different features installed or // enabled. class Manual is // Each car should have a user manual that corresponds to // the car's configuration and describes all its features. // The builder interface specifies methods for creating the // different parts of the product objects. interface Builder is method reset() method setSeats(...) method setEngine(...) method setTripComputer(...) method setGPS(...) // The concrete builder classes follow the builder interface and // provide specific implementations of the building steps. Your // program may have several variations of builders, each // implemented differently. class CarBuilder implements Builder is private field car:Car // A fresh builder instance should contain a blank product // object which it uses in further assembly. constructor CarBuilder() is this.reset() // The reset method clears the object being built. method reset() is this.car = new Car() // All production steps work with the same product instance. method setSeats(...) is // Set the number of seats in the car. method setEngine(...) is // Install a given engine. method setTripComputer(...) is // Install a trip computer. method setGPS(...) is // Install a global positioning system. // Concrete builders are supposed to provide their own // methods for retrieving results. That's because various // types of builders may create entirely different products // that don't all follow the same interface. Therefore such // methods can't be declared in the builder interface (at // least not in a statically-typed programming language). // // Usually, after returning the end result to the client, a // builder instance is expected to be ready to start // producing another product. That's why it's a usual // practice to call the reset method at the end of the // `getProduct` method body. However, this behavior isn't // mandatory, and you can make your builder wait for an // explicit reset call from the client code before disposing // of the previous result. method getProduct():Car is product = this.car this.reset() return product // Unlike other creational patterns, builder lets you construct // products that don't follow the common interface. class CarManualBuilder implements Builder is private field manual:Manual constructor CarManualBuilder() is this.reset() method reset() is this.manual = new Manual() method setSeats(...) is // Document car seat features. method setEngine(...) is // Add engine instructions. method setTripComputer(...) is // Add trip computer instructions. method setGPS(...) is // Add GPS instructions. method getProduct():Manual is // Return the manual and reset the builder. // The director is only responsible for executing the building // steps in a particular sequence. It's helpful when producing // products according to a specific order or configuration. // Strictly speaking, the director class is optional, since the // client can control builders directly. class Director is // The director works with any builder instance that the // client code passes to it. This way, the client code may // alter the final type of the newly assembled product. // The director can construct several product variations // using the same building steps. method constructSportsCar(builder: Builder) is builder.reset() builder.setSeats(2) builder.setEngine(new SportEngine()) builder.setTripComputer(true) builder.setGPS(true) method constructSUV(builder: Builder) is // ... // The client code creates a builder object, passes it to the // director and then initiates the construction process. The end // result is retrieved from the builder object. class Application is method makeCar() is director = new Director() CarBuilder builder = new CarBuilder() director.constructSportsCar(builder) Car car = builder.getProduct() CarManualBuilder builder = new CarManualBuilder() director.constructSportsCar(builder) // The final product is often retrieved from a builder // object since the director isn't aware of and not // dependent on concrete builders and products. Manual manual = builder.getProduct()\n\nUse the Builder pattern to get rid of a “telescoping constructor”. Say you have a constructor with ten optional parameters. Calling such a beast is very inconvenient; therefore, you overload the constructor and create several shorter versions with fewer parameters. These constructors still refer to the main one, passing some default values into any omitted parameters. Creating such a monster is only possible in languages that support method overloading, such as C# or Java. The Builder pattern lets you build objects step by step, using only those steps that you really need. After implementing the pattern, you don’t have to cram dozens of parameters into your constructors anymore. Use the Builder pattern when you want your code to be able to create different representations of some product (for example, stone and wooden houses). The Builder pattern can be applied when construction of various representations of the product involves similar steps that differ only in the details. The base builder interface defines all possible construction steps, and concrete builders implement these steps to construct particular representations of the product. Meanwhile, the director class guides the order of construction. Use the Builder to construct Composite trees or other complex objects. The Builder pattern lets you construct products step-by-step. You could defer execution of some steps without breaking the final product. You can even call steps recursively, which comes in handy when you need to build an object tree. A builder doesn’t expose the unfinished product while running construction steps. This prevents the client code from fetching an incomplete result."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/builder-design-pattern-in-java",
        "document": "Today we will look into Builder pattern in java. Builder design pattern is a creational design pattern like Factory Pattern and Abstract Factory Pattern.\n\nBuilder pattern was introduced to solve some of the problems with Factory and Abstract Factory design patterns when the Object contains a lot of attributes. There are three major issues with Factory and Abstract Factory design patterns when the Object contains a lot of attributes.\n• Too Many arguments to pass from client program to the Factory class that can be error prone because most of the time, the type of arguments are same and from client side its hard to maintain the order of the argument.\n• Some of the parameters might be optional but in Factory pattern, we are forced to send all the parameters and optional parameters need to send as NULL.\n• If the object is heavy and its creation is complex, then all that complexity will be part of Factory classes that is confusing.\n\nWe can solve the issues with large number of parameters by providing a constructor with required parameters and then different setter methods to set the optional parameters. The problem with this approach is that the Object state will be inconsistent until unless all the attributes are set explicitly. Builder pattern solves the issue with large number of optional parameters and inconsistent state by providing a way to build the object step-by-step and provide a method that will actually return the final Object.\n\nLet’s see how we can implement builder design pattern in java.\n• First of all you need to create a static nested class and then copy all the arguments from the outer class to the Builder class. We should follow the naming convention and if the class name is then builder class should be named as .\n• Java Builder class should have a public constructor with all the required attributes as parameters.\n• Java Builder class should have methods to set the optional parameters and it should return the same Builder object after setting the optional attribute.\n• The final step is to provide a method in the builder class that will return the Object needed by client program. For this we need to have a private constructor in the Class with Builder class as argument.\n\nHere is the sample builder pattern example code where we have a Computer class and ComputerBuilder class to build it.\n\nNotice that Computer class has only getter methods and no public constructor. So the only way to get a Computer object is through the ComputerBuilder class. Here is a builder pattern example test program showing how to use Builder class to get the object.\n\nRecently I uploaded a YouTube video for Builder Design Pattern. I have also explained why I think the builder pattern defined on WikiPedia using Director classes is not a very good Object Oriented approach, and how we can achieve the same level of abstraction using different approach and with one class. Note that this is my point of view, I feel design patterns are to guide us, but ultimately we have to decide if it’s really beneficial to implement it in our project or not. I am a firm believer of KISS principle. https://www.youtube.com/watch?v=D5NK5qMM14g If you like the video, please do share it, like it and subscribe to my channel. If you think I am mistaken or you have any comments or feedback so that I can improve my videos in future, please let me know through comments here or on YouTube video page.\n\nSome of the builder pattern example in Java classes are;\n\nThat’s all for builder design pattern in java.\n\nYou can download the example code from my GitHub Repository."
    },
    {
        "link": "https://stackoverflow.com/questions/328496/when-would-you-use-the-builder-pattern",
        "document": "Below are some reasons arguing for the use of the pattern and example code in Java, but it is an implementation of the Builder Pattern covered by the Gang of Four in Design Patterns. The reasons you would use it in Java are also applicable to other programming languages as well.\n\nWe've all at some point encountered a class with a list of constructors where each addition adds a new option parameter:\n\nThis is called the Telescoping Constructor Pattern. The problem with this pattern is that once constructors are 4 or 5 parameters long it becomes difficult to remember the required order of the parameters as well as what particular constructor you might want in a given situation.\n\nOne alternative you have to the Telescoping Constructor Pattern is the JavaBean Pattern where you call a constructor with the mandatory parameters and then call any optional setters after:\n\nThe problem here is that because the object is created over several calls it may be in an inconsistent state partway through its construction. This also requires a lot of extra effort to ensure thread safety.\n\nThe better alternative is to use the Builder Pattern.\n\nNote that Pizza is immutable and that parameter values are all in a single location. Because the Builder's setter methods return the Builder object they are able to be chained.\n\nThis results in code that is easy to write and very easy to read and understand. In this example, the build method could be modified to check parameters after they have been copied from the builder to the Pizza object and throw an IllegalStateException if an invalid parameter value has been supplied. This pattern is flexible and it is easy to add more parameters to it in the future. It is really only useful if you are going to have more than 4 or 5 parameters for a constructor. That said, it might be worthwhile in the first place if you suspect you may be adding more parameters in the future.\n\nI have borrowed heavily on this topic from the book Effective Java, 2nd Edition by Joshua Bloch. To learn more about this pattern and other effective Java practices I highly recommend it."
    },
    {
        "link": "https://en.wikipedia.org/wiki/Builder_pattern",
        "document": "The builder pattern is a design pattern that provides a flexible solution to various object creation problems in object-oriented programming. The builder pattern separates the construction of a complex object from its representation. It is one of the 23 classic design patterns described in the book Design Patterns and is sub-categorized as a creational pattern.\n• How can a class (the same construction process) create different representations of a complex object?\n• How can a class that includes creating a complex object be simplified?\n\nCreating and assembling the parts of a complex object directly within a class is inflexible. It commits the class to creating a particular representation of the complex object and makes it impossible to change the representation later independently from (without having to change) the class.\n\nThe builder design pattern describes how to solve such problems:\n• Encapsulate creating and assembling the parts of a complex object in a separate object.\n• A class delegates object creation to a object instead of creating the objects directly.\n\nA class (the same construction process) can delegate to different objects to create different representations of a complex object.\n\nThe intent of the builder design pattern is to separate the construction of a complex object from its representation. By doing so, the same construction process can create different representations.\n• Allows you to vary a product's internal representation.\n• Provides control over the steps of the construction process.\n• A distinct ConcreteBuilder must be created for each type of product.\n• In many null-safe languages, the builder pattern defers compile-time errors for unset fields to runtime.\n\nIn the above UML class diagram, the class doesn't create and assemble the and objects directly. Instead, the refers to the interface for building (creating and assembling) the parts of a complex object, which makes the independent of which concrete classes are instantiated (which representation is created). The class implements the interface by creating and assembling the and objects. \n\n The UML sequence diagram shows the run-time interactions: The object calls on the object, which creates and assembles the object. Thereafter, the calls on , which creates and assembles the object.\n\n// Director controls the stepwise creation of product and returns the result.\n\nThe Director assembles a bicycle instance in the example above, delegating the construction to a separate builder object that has been given to the Director by the Client."
    },
    {
        "link": "https://medium.com/@alxkm/builder-pattern-variations-and-best-practices-643b6631341f",
        "document": "Diversifying Design: Exploring Variations and Best Practices of the Builder Pattern\n\nIf you are not using Lombok for some reason, or you are interested Builder pattern in java, welcome here. This article could explore various variations and extensions of the Builder Pattern beyond the basic implementation. It could cover topics such as nested builders, step builders, telescoping builders, and the use of method chaining for fluent interfaces. It could also discuss best practices for designing builder classes and composing complex object hierarchies.\n\nThe Builder Pattern is a creational design pattern that provides a flexible solution for constructing complex objects. It allows us to separate the construction of an object from its representation, thereby enabling the creation of different object configurations using the same construction process. While the basic implementation of the Builder Pattern is straightforward, there are several variations and best practices that developers should be aware of to maximize its effectiveness. In this article, we will explore various Builder Pattern variations and discuss best practices for their use in Java.\n\nWith only two fields currently, employing the builder remains advantageous to avoid parameter-order confusion in constructors and to facilitate initializing one or both fields separately at different intervals. Consider the complexities when dealing with a lot of fields. To prevent field duplication in the builder class, a nested class is introduced. This inner class can access its parent class’s private fields directly and expose them. By making the inner class constructor private and removing the final modifier from the fields, we streamline the process.\n\nThe constructor of the builder is private to prevent the possibility of creating a builder and modifying the fields of an already existing object by accessing the Account instance. The build method merely returns a fully constructed object, allowing for validation of required fields before instantiation. The finishing step involves incorporating it into the method for creating a builder instance.\n\nConsider adding a new field or modifying the token field type in both scenarios. As the number of fields grows, the contrast in code size and readability will become more pronounced. Let’s contrast the example from the article I referenced earlier in this discussion (I’ve adjusted it to ensure the examples’ styles match).\n\nLet’s add different fields and another variant to organize builder code:\n\nAnd creation such object using such pattern looks better than using standard way:\n\nUsing of a builder pattern to address limitations when dealing with final fields and constructors in object creation.\n\nThe description suggests that due to the inability to use the final keyword with a builder, or to create constructors with a large number of parameters, the builder pattern offers a solution. It explains that the builder pattern allows for the creation of objects with mutable fields during the building process, but once the object is constructed, the fields become immutable.\n\nIn essence, the builder pattern provides flexibility during object construction by allowing for the setting of individual fields in a fluent manner, while still ensuring immutability once the object is fully constructed. This approach allows for cleaner, more maintainable code while adhering to principles of immutability where desired."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/builder-design-pattern-in-java",
        "document": "Today we will look into Builder pattern in java. Builder design pattern is a creational design pattern like Factory Pattern and Abstract Factory Pattern.\n\nBuilder pattern was introduced to solve some of the problems with Factory and Abstract Factory design patterns when the Object contains a lot of attributes. There are three major issues with Factory and Abstract Factory design patterns when the Object contains a lot of attributes.\n• Too Many arguments to pass from client program to the Factory class that can be error prone because most of the time, the type of arguments are same and from client side its hard to maintain the order of the argument.\n• Some of the parameters might be optional but in Factory pattern, we are forced to send all the parameters and optional parameters need to send as NULL.\n• If the object is heavy and its creation is complex, then all that complexity will be part of Factory classes that is confusing.\n\nWe can solve the issues with large number of parameters by providing a constructor with required parameters and then different setter methods to set the optional parameters. The problem with this approach is that the Object state will be inconsistent until unless all the attributes are set explicitly. Builder pattern solves the issue with large number of optional parameters and inconsistent state by providing a way to build the object step-by-step and provide a method that will actually return the final Object.\n\nLet’s see how we can implement builder design pattern in java.\n• First of all you need to create a static nested class and then copy all the arguments from the outer class to the Builder class. We should follow the naming convention and if the class name is then builder class should be named as .\n• Java Builder class should have a public constructor with all the required attributes as parameters.\n• Java Builder class should have methods to set the optional parameters and it should return the same Builder object after setting the optional attribute.\n• The final step is to provide a method in the builder class that will return the Object needed by client program. For this we need to have a private constructor in the Class with Builder class as argument.\n\nHere is the sample builder pattern example code where we have a Computer class and ComputerBuilder class to build it.\n\nNotice that Computer class has only getter methods and no public constructor. So the only way to get a Computer object is through the ComputerBuilder class. Here is a builder pattern example test program showing how to use Builder class to get the object.\n\nRecently I uploaded a YouTube video for Builder Design Pattern. I have also explained why I think the builder pattern defined on WikiPedia using Director classes is not a very good Object Oriented approach, and how we can achieve the same level of abstraction using different approach and with one class. Note that this is my point of view, I feel design patterns are to guide us, but ultimately we have to decide if it’s really beneficial to implement it in our project or not. I am a firm believer of KISS principle. https://www.youtube.com/watch?v=D5NK5qMM14g If you like the video, please do share it, like it and subscribe to my channel. If you think I am mistaken or you have any comments or feedback so that I can improve my videos in future, please let me know through comments here or on YouTube video page.\n\nSome of the builder pattern example in Java classes are;\n\nThat’s all for builder design pattern in java.\n\nYou can download the example code from my GitHub Repository."
    },
    {
        "link": "https://blogs.oracle.com/javamagazine/post/exploring-joshua-blochs-builder-design-pattern-in-java",
        "document": ""
    },
    {
        "link": "https://baeldung.com/java-builder-pattern",
        "document": "In our journey through software development, we often encounter scenarios where creating objects with numerous properties becomes intimidating. Cluttering our constructors is making our code less readable. This is precisely where the Builder Pattern shines. The Builder Pattern is a creational design pattern that separates the construction of complex objects from their representation, offering a cleaner and more flexible approach to object creation.\n\nBefore we dive into coding, let’s quickly recap the advantages of utilizing the Builder Pattern:\n• Flexibility – by decoupling the construction process from the actual object representation, the Builder Pattern allows us to create objects with varying configurations without cluttering our codebase with multiple constructors or setters\n• Readability – the Builder Pattern provides fluent interfaces, making our code more readable; this enables us and fellow developers to understand the construction process of complex objects at a glance.\n• Immutability – builders can enforce immutability by creating immutable objects once the construction is complete; this ensures thread safety and prevents unintended modification.\n\nNow, let’s roll up our sleeves and delve into the code.\n\nNow, we can use the Builder to create a new object:\n\nIn Java 8, lambda expressions and method references opened up new possibilities, including a more generic form of the Builder Pattern. Our implementation introduces a GenericBuilder class, which can construct various types of objects by leveraging generics:\n\nThis class follows a fluent interface, starting with the of() method to create the initial object instance. Then, the with() method sets object properties using lambda expressions or method references.\n\nThe GenericBuilder offers flexibility and readability, allowing us to construct every object concisely while ensuring type safety. This pattern showcases Java 8’s expressive power and is an elegant solution for complex construction tasks.\n\nHowever, a big drawback is that this solution is based on class setters. This implies that our attributes can no longer be final as in the previous example, thus losing the immutability offered by the Builder Pattern.\n\nFor our next example we’ll create a new GenericPost class consisting of a default no-args constructor, getters, and setters:\n\nNow, we can use our GenericBuilder to create a GenericPost:\n\nLombok is a library that simplifies Java code by automatically generating common methods such as getters, setters, equals, hashCode, and even constructors.\n\nOne of the most appreciated features of Lombok is its support for the Builder Pattern. By annotating a class with @Builder, Lombok generates a builder class with fluent methods for setting properties. This annotation eliminates the need for manual builder class implementation, significantly reducing verbosity\n\nTo use Lombok, we need to import the dependency from the Maven central repository:\n\nNow, we can create a new LombokPost class using the @Builder annotation:\n\nWe also used @Setter and @Getter annotations to avoid the boilerplate code. We can then use the builder pattern out of the box to create new objects:\n\nThe Builder Pattern in Java 8 offers streamlined object construction and improved code readability. With variants like Classic, Generic, and Lombok Builder Patterns, we can tailor our approach to our specific needs. By embracing this pattern and leveraging tools like Lombok, we can write cleaner, more efficient code, driving innovation and success in software development.\n\nAs always, the complete code snippets are available over on GitHub."
    },
    {
        "link": "https://stackoverflow.com/questions/23169505/java-best-way-to-implement-builder-pattern",
        "document": "Which of the following is the better approach to implement the builder pattern?\n\n1) Using the object to build instead of all its properties in the builder (and create it in the builder constructor):\n\n2) Using the properties of the object to build instead of the object directly in the builder (and create it in the build() method):\n\nI prefer the first way because i think that with lots of properties repeat them in the builder is redundant. Are there some disadvantages with the first approach?\n\nThanks in advance and sorry for my bad english."
    }
]