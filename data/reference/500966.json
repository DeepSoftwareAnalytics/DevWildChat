[
    {
        "link": "https://stackoverflow.com/questions/11287213/what-is-a-wide-character-string-in-c-language",
        "document": "The exact nature of wide characters is (purposefully) left implementation defined.\n\nWhen they first invented the concept of , ISO 10646 and Unicode were still competing with each other (whereas they now, mostly cooperate). Rather than try to decree that an international character would be one or the other (or possibly something else entirely) they simply provided a type (and some functions) that the implementation could define to support international character sets as they chose.\n\nDifferent implementations have exercised that potential for variation. For example, if you use Microsoft's compiler on Windows, will be a 16-bit type holding UTF-16 Unicode (originally it held UCS-2 Unicode, but that's now officially obsolete).\n\nOn Linux, will more often be a 32-bit type, holding UCS-4/UTF-32 encoded Unicode. Ports of gcc to at least some other operating systems do the same, though I've never tried to confirm that it's always the case.\n\nThere is, however, no guarantee of that. At least in theory an implementation on Linux could use 16 bits, or one on Windows could use 32 bits, or either one could decide to use 64 bits (though I'd be a little surprised to see that in reality).\n\nIn any case, the general idea of how things are intended to work, is that a single is sufficient to represent a code point. For I/O, the data is intended to be converted from the external representation (whatever it is) into s, which (is supposed to) make them relatively easy to manipulate. Then during output, they again get transformed into the encoding of your choice (which may be entirely different from the encoding you read)."
    },
    {
        "link": "https://spsanderson.com/steveondata/posts/2024-10-02",
        "document": "Programming, Character variables in C, C programming for beginners, Understanding strings in C, String manipulation in C, C character arrays, Null terminator in C, Initializing strings in C, Determining string length in C, Common string operations in C, C programming tips, Memory management in C, C programming best practices, Beginner C programming guide, Working with strings in C, C programming tutorials"
    },
    {
        "link": "https://stackoverflow.com/questions/77944010/win32-wide-character-string-alignment-requirements",
        "document": "I narrowed down a problem in my GUI code to silently failing if the new window title is not aligned to two bytes. In this case, returns (success) but does not set the new text.\n\nThe natural alignment of on MSVC is 2 bytes, so this was definitely my error. But just to be sure I tried to find the alignment rules for Win32 strings.\n\nI found no official documentation, just an old newsgroup thread mentioning a bug report for the Open Watcom compiler – which claims that Win32 and COM on Windows NT actually require 4-byte alignment! While this seemed outlandish to me, I noticed that MSVC does indeed align every literal to four bytes, not two. You can actually make MSVC pack constant strings more densely via . Heap granularity in Win32 is also >=8 bytes.\n\nIf Win32 required four-byte alignment for wide-character strings (like the source claims) and API calls silently fail on wrong data alignment (like does with 1-byte alignment), I feel like being in deep trouble.\n\nIs there any official documentation stating the definitive alignment requirements for wide-character strings in Win32/COM? Is it two or four bytes?"
    },
    {
        "link": "https://en.cppreference.com/w/c/string/wide/wmemset",
        "document": "Copies the wide character ch into each of the first count wide characters of the wide character array (or integer array of compatible type) pointed to by dest.\n\nIf overflow occurs, the behavior is undefined.\n\nIf count is zero, the function does nothing.\n\nThis function is not locale-sensitive and pays no attention to the values of the wchar_t objects it writes: nulls as well as invalid wide characters are written too."
    },
    {
        "link": "https://docs.oracle.com/database/121/LNOCI/oci22glb003.htm",
        "document": "Two types of data structures are supported for string manipulation: Multibyte strings are encoded in native Oracle character sets. Functions that operate on multibyte strings take the string as a whole unit with the length of the string calculated in bytes. Wide-character ( ) string functions provide more flexibility in string manipulation. They support character-based and string-based operations with the length of the string calculated in characters. The wide-character data type is Oracle-specific and should not be confused with the data type defined by the ANSI/ISO C standard. The Oracle wide-character data type is always 4 bytes in all operating systems, whereas the size of depends on the implementation and the operating system. The Oracle wide-character data type normalizes multibyte characters so that they have a fixed width for easy processing. This guarantees no data loss for round-trip conversion between the Oracle wide-character set and the native character set. String manipulation can be classified into the following categories:\n• Conversion of strings between multibyte and wide character\n• General string manipulation, such as comparison, concatenation, and searching Table 22-5 summarizes the OCI string manipulation functions, which are described in this section. Convert part of a multibyte string into the wide-character string Convert a multibyte string into the specified case and copies the result into the destination array Compare two multibyte strings by binary, linguistic, or case-insensitive comparison methods Copy a multibyte string into the destination array. It returns the number of bytes copied. Return the number of bytes in a multibyte string Append, at most, n bytes from a multibyte string to the destination string Compare two multibyte strings by binary, linguistic, or case-insensitive comparison methods. Each string is in the specified length Copy a specified number of bytes of a multibyte string into the destination array Return the number of display positions occupied by the multibyte string within the range of n bytes Convert part of a wide-character string to the multibyte string Determine the number of bytes required for a wide character in multibyte encoding Convert a wide-character string into the specified case and copies the result into the destination array Search for the first occurrence of a wide character in a string. Return a point to the wide character if the search is successful. Compare two wide-character strings by binary, linguistic, or case-insensitive comparison methods Copy a wide-character string into a destination array. Return the number of characters copied. Return the number of characters in a wide-character string Append, at most, n characters from a wide-character string to the destination string Compare two wide-character strings by binary, linguistic, or case-insensitive methods. Each string is a specified length. Copy, at most, n characters of a wide-character string into the destination array Search for the last occurrence of a character in a wide-character string Convert a specified wide character into the corresponding lowercase character Convert a specified wide character into the corresponding uppercase character"
    },
    {
        "link": "https://geeksforgeeks.org/towlower-function-in-c-c",
        "document": "The towlower() is a built-in function in C/C++ which converts the given wide character into lowercase. It is defined within the cwctype header file of C++.\n• It is a function in header file , so it is mandatory to use this header file if using this function\n• It is the wide-character equivalent of the towlower() function.\n\nParameter: The function accepts a single mandatory parameter ch which specifies the wide character which we have to convert into lowercase. Return Value: The function returns the lowercase equivalent to c, if such value exists, or c (unchanged) otherwise. The value is returned as a wint_t value that can be implicitly casted to wchar_t. Below programs illustrates the above function. Program 1:"
    },
    {
        "link": "https://stackoverflow.com/questions/27401231/understanding-and-writing-wchar-t-in-c",
        "document": "I'm currently rewriting (a part of) the function for a school project. Overall, we were required to reproduce the behaviour of the function with several flags, conversions, length modifiers ...\n\nThe only thing I have left to do and that gets me stuck are the flags / (or / ).\n\nSo far, I've gathered that is a type that can store characters on more than one byte, in order to accept more characters or symbols and therefore be compatible with pretty much every language, regardless of their alphabet and special characters.\n\nHowever, I wasn't able to find any concrete information on what a looks like for the machine, it's actual length (which apparently vary based on several factors including the compiler, the OS ...) or how to actually write them.\n\nThank you in advance\n\nNote that we are limited in the functions we are allowed to use. The only allowed functions are , , , and . We must be able to code any other required function ourselves.\n\nTo sum this up, what I'm asking here is some informations on how to interpret and write \"manually\" any character, with as little code as possible so that I can try to understand the whole process and code it myself."
    },
    {
        "link": "https://reddit.com/r/C_Programming/comments/1ikmkzl/can_wchar_t_functions_function_correctly_anywhere",
        "document": "Assuming I have a line like and specifies a POSIX_STANDARD newer than the one that specified .\n\nI wonder that if the locale is set correctly on the users machine, with iso8859-n, UTF-8, utf16 or utf32 if it will `just work', so that all I have to care about is the setlocale statement above. And if not, on which platforms are there constraints with regard to utf16 and utf32.\n\n-I think that it can work as long as is in use unicode wise, but I may be wrong.\n\nI'm asking this because I have only a Debian machine at the moment, and here it is and , -I could probably use and generate some UTF-16 and 32 files for myself and see how well that works out, but what I'm really after is the Windows platform. I think that even there it should work as long as doesn't return .\n\nAll I am about to do is get the current locale, and parse a file, word by word using the current user specified locale.\n\nIs that possible without further ado?"
    },
    {
        "link": "https://sites.ualberta.ca/dept/chemeng/AIX-43/share/man/info/C/a_doc_lib/aixprggd/genprogc/multi-byte_widechar_subr.htm",
        "document": "This section contains information about multibyte and wide character code subroutines. This section contains the following major subsections:\n\nThe internationalized environment of National Language Support blends multibyte and wide character subroutines. The decision of when to use wide character or multibyte subroutines can be made only after careful analysis.\n\nIf a program primarily uses multibyte subroutines, it may be necessary to convert the multibyte character codes to wide character codes before certain wide character subroutines can be used. If a program uses wide character subroutines, data may need to be converted to multibyte form when invoking subroutines. Both methods have drawbacks, depending on the program in use and the availability of standard subroutines to perform the required processing. For instance, the wide character display-column-width subroutine has no corresponding standard multibyte subroutine.\n\nIf a program can process its characters in multibyte form, this method should be used instead of converting the characters to wide character form.\n\nThe following subroutines are used when converting from multibyte code to wide character code:\n\nThe following subroutines are used when converting from wide character code to multibyte character code:\n• The following example uses the mbtowc subroutine to convert a character in multibyte character code to wide character code: main() { char *s; wchar_t wc; int n; (void)setlocale(LC_ALL,\"\"); /* ** s points to the character string that needs to be ** converted to a wide character to be stored in wc. */ n = mbtowc(&wc, s, MB_CUR_MAX); if (n == -1){ /* Error handle */ } if (n == 0){ /* case of name pointing to null */ } /* ** wc contains the process code for the multibyte character ** pointed to by s. */ }\n• The following example uses the wctomb subroutine to convert a character in wide character code to multibyte character code: #include <stdlib.h> #include <limits.h> /* for MB_LEN_MAX */ #include <stdlib.h> /* for wchar_t */ main() { char s[MB_LEN_MAX}; /* system wide maximum number of ** bytes in a multibyte character r. */ wchar_t wc; int n; (void)setlocale(LC_ALL,\"\"); /* ** wc is the wide character code to be converted to ** multibyte character code. */ n = wctomb(s, wc); if(n == -1){ /* pwcs does not point to a valid wide character */ } /* ** n has the number of bytes contained in the multibyte ** character stored in s. */ }\n• The following example uses the mblen subroutine to find the byte length of a character in multibyte character code: #include <stdlib.h> #include <locale.h> main { char *name = \"h\"; int n; (void)setlocale(LC_ALL,\"\"); n = mblen(name, MB_CUR_MAX); /* ** The count returned in n is the multibyte length. ** It is always less than or equal to the value of ** MB_CUR_MAX in stdlib.h */ if(n == -1){ /* Error Handling */ } }\n• The following example obtains a previous character position in a multibyte string. If you need to determine the previous character position, starting from a current character position (not just some random byte position), step through the buffer starting at the beginning. Use the mblen subroutine until the current character position is reached and save the previous character position to obtain the needed character position. char buf[]; /* contains the multibyte string */ char *cur, /* points to the current character position */ char *prev, /* points to previous multibyte character */ char *p; /* moving pointer */ /* initialize the buffer and pointers as needed */ /* loop through the buffer until the moving pointer reaches ** the current character position in the buffer, always ** saving the last character position in prev pointer */ p = prev = buf; /* cur points to a valid character somewhere in buf */ while(p< cur){ prev = p; if( (i=mblen(p, mbcurmax))<=0){ /* invalid multibyte character or null */ /* You can have a different error handling ** strategy */ p++; /* skip it */ }else { p += i; } } /* prev will point to the previous character position */ /* Note that if( prev == cur), then it means that there was ** no previous character. Also, if all bytes up to the ** current character are invalid, it will treat them as ** all valid single-byte characters and this may not be what ** you want. One may change this to handle another method of ** error recovery. */\n• The following example uses of the mbstowcs subroutine to convert a multibyte string to wide character string:\n• The following example illustrates the problems with using the mbstowcs subroutine on a large block of data for conversion to wide character form. When it encounters an invalid multibyte, the mbstowcs subroutine returns a value of but does not specify where the error occurred. Therefore, the mbtowc subroutine must be used repeatedly to convert one character at a time to wide character code. Note: Processing in this manner will considerably slow down program performance. During the conversion of single-byte code sets, there is no possibility for partial multibytes. However, during the conversion of multibyte code sets, partial multibytes are copied to a save buffer. During the next call to the read subroutine, the partial multibyte is prefixed to the rest of the byte sequence. Note: A null-terminated wide character string is obtained. Optional error handling can be done if an instance of an invalid byte sequence is found. #include <stdio.h> #include <locale.h> #include <stdlib.h> main(int argc, char *argv[]) { char *curp, *cure; int bytesread, bytestoconvert, leftover; int invalid_multibyte, mbcnt, wcnt; wchar_t *pwcs; wchar_t wbuf[BUFSIZ+1]; char buf[BUFSIZ+1]; char savebuf[MB_LEN_MAX]; size_t mb_cur_max; int fd; /* ** MB_LEN_MAX specifies the system wide constant for ** the maximum number of bytes in a multibyte character. */ (void)setlocale(LC_ALL, \"\"); mb_cur_max = MB_CUR_MAX; fd = open(argv[1], 0); if(fd < 0){ /* error handle */ } leftover = 0; if(mb_cur_max==1){ /* Single byte code sets case */ for(;;){ bytesread = read(fd, buf, BUSIZ); if(bytesread <= 0) break; mbstowcs(wbuf, buf, bytesread+1); /* Process using the wide character buffer */ } /* File processed ... */ exit(0); /* End of program */ }else{ /* Multibyte code sets */ leftover = 0; for(;;) { if(leftover) strncpy(buf, savebuf ,leftover); bytesread=read(fd,buf+leftover, BUFSIZ-leftover); if(bytesread <= 0) break; buf[leftover+bytesread] = '\\0'; /* Null terminate string */ invalid_multibyte = 0; bytestoconvert = leftover+bytesread; cure= buf+bytestoconvert; leftover=0; pwcs = wbuf; /* Stop processing when invalid mbyte found. */ curp= buf; for(;curp<cure;){ mbcnt = mbtowc(pwcs,curp, mb_cur_max); if(mbcnt>0){ curp += mbcnt; pwcs++; continue; }else{ /* More data needed on next read*/ if ( cure-curp<mb_cur_max){ leftover=cure-curp; strncpy(savebuf,curp,leftover); /* Null terminate before partial mbyte */ *curp=0; break; }else{ /*Invalid multibyte found */ invalid_multibyte =1; break; } } } if(invalid_multibyte){ /*error handle */ } /* Process the wide char buffer */ } } }\n• The following example uses the wcstombs and wcslen subroutines to convert a wide character string to multibyte form: #include <stdlib.h> #include <locale.h> main() { wchar_t *pwcs; /* Source wide character string */ char *s; /* Destination multibyte character string */ size_t n; size_t retval; (void)setlocale(LC_ALL, \"\"); /* ** Calculate the maximum number of bytes needed to ** store the wide character buffer in multibyte form in the ** current code page and malloc() the appropriate storage, ** including the terminating null. */ s = (char *) malloc( wcslen(pwcs) * MB_CUR_MAX + 1 ); retval= wcstombs( s, pwcs, n); if( retval == -1) { /* Error handle */ /* s points to the multibyte character string. */ }\n\nThe majority of wide character classification subroutines are similar to traditional character classification subroutines, except that wide character classification subroutines operate on a wchar_t data type argument passed as a wint_t data type argument.\n\nIn the internationalized environment of National Language Support, the ability to create new character class properties is essential. For example, several properties are defined for Japanese characters that are not applicable to the English language. As more languages are supported, a framework enabling applications to deal with a varying number of character properties is needed. The wctype and iswctype subroutines allow handling of character classes in a general fashion. These subroutines are used to allow for both user-defined and language-specific character classes.\n\nThe action of wide character classification subroutines is affected by the definitions in the LC_CTYPE category for the current locale.\n\nTo create new character classifications for use with the wctype and iswctype subroutines, create a new character class in the LC_CTYPE category and generate the locale using the localedef command. A user application obtains this locale data with the setlocale subroutine. The program can then access the new classification subroutines by using the wctype subroutine to get the wctype_t property handle. It then passes to the iswctype subroutine both the property handle and the wide character code of the character to be tested.\n\nThe isw* subroutines determine various aspects of a standard wide character classification. The isw* subroutines also work with single-byte code sets. The isw* subroutines should be used in preference to the wctype and iswctype subroutines. The wctype and iswctype subroutines should be used only for extended character class properties (for example, Japanese language properties).\n\nWhen using the wide character functions to convert the case in several blocks of data, the application must convert characters from multibyte to wide character code form. Since this may affect performance in single-byte code set locales, you should consider providing two conversion paths in your application. The traditional path for single-byte code set locales would convert case using the isupper,islower, toupper, and tolower subroutines. The alternate path for multibyte code set locales would convert multibyte characters to wide character code form and convert case using the iswupper, iswlower, towupper and towlower subroutines. When converting multibyte characters to wide character code form, an application needs to handle special cases where a multibyte character may split across successive blocks.\n\nThe following subroutines convert cases for wide characters. The action of wide character case conversion subroutines is affected by the definition in the LC_CTYPE category for the current locale.\n\nThe following example uses the wctype subroutine to test for the NEW_CLASS character classification:\n\nWhen characters are displayed or printed, the number of columns occupied by a character may differ. For example, a Kanji character (Japanese language) may occupy more than one column position. The number of display columns required by each character is part of the National Language Support locale database. The LC_CTYPE category defines the number of columns needed to display a character.\n\nThere are no standard multibyte display-column-width subroutines. For portability, convert multibyte codes to wide character codes and use the required wide character display-width subroutines. However, if the __max_disp_width macro (defined in the stdlib.h file) is set to 1 and a single-byte code set is in use, then the display-column widths of all characters (except tabs) in the code set are the same, and are equal to 1. In this case, the strlen (string) subroutine gives the display column width of the specified string. This is demonstrated in the following example:\n\nThe following subroutines find the display widths for wide character strings:\n• The following example uses the wcwidth subroutine to find the display column width of a wide character: #include <string.h> #include <locale.h> #include <stdlib.h> main() { wint_t wc; int retval; (void)setlocale(LC_ALL, \"\"); /* ** Let wc be the wide character whose display width is ** to be found. */ retval = wcwidth(wc); if(retval == -1){ /* ** Error handling. Invalid or nonprintable ** wide character in wc. */ } }\n• The following example uses the wcswidth subroutine to find the display column width of a wide character string: #include <string.h> #include <locale.h> #include <stdlib.h> main() { wchar_t *pwcs; int retval; size_t n; (void)setlocale(LC_ALL, \"\"); /* ** Let pwcs point to a wide character null ** terminated string. ** Let n be the number of wide characters ** whose display column width is to be determined. */ retval = wcswidth(pwcs, n); if(retval == -1){ /* ** Error handling. Invalid wide or nonprintable ** character ode encountered in the wide ** character string pwcs. */ } }\n\nStrings can be compared in two ways:\n• Using the ordinal (binary) values of the characters.\n• Using the weights associated with the characters for each locale, as determined by the LC_COLLATE category.\n\nNational Language Support (NLS) uses the second method.\n\nCollation is a locale-specific property of characters. A weight is assigned to each character to indicate its relative order for sorting. A character may be assigned more than one weight. Weights are prioritized as primary, secondary, tertiary, and so forth. The maximum number of weights assigned each character is system-defined.\n\nA process inherits the C locale or POSIX locale at its startup time. When the setlocale (LC_ALL, \" \") subroutine is called, a process obtains its locale based on the LC_* and LANG environment variables. The following subroutines are affected by the LC_COLLATE category and determine how two strings will be sorted in any given locale.\n• The following example uses the wcscoll subroutine to compare two wide character strings based on their collation weights: #include <stdio.h> #include <string.h> #include <locale.h> #include <stdlib.h> extern int errno; main() { wchar_t *pwcs1, *pwcs2; size_t n; (void)setlocale(LC_ALL, \"\"); /* set it to zero for checking errors on wcscoll */ errno = 0; /* ** Let pwcs1 and pwcs2 be two wide character strings to ** compare. */ n = wcscoll(pwcs1, pwcs2); /* ** If errno is set then it indicates some ** collation error. */ if(errno != 0){ /* error has occurred... handle error ...*/ } }\n• The following example uses the wcsxfrm subroutine to compare two wide character strings based on collation weights: Note: Determining the size n (where n is a number) of the transformed string, when using the wcsxfrm subroutine, can be accomplished in one of the following ways:\n• For each character in the wide character string, the number of bytes for possible collation values cannot exceed the COLL_WEIGHTS_MAX * sizeof(wchar_t) value. This value, multiplied by the number of wide character codes, gives the buffer length needed. To the buffer length add 1 for the terminating wide character null. This strategy may slow down performance.\n• Estimate the byte-length needed. If the previously obtained value is not enough, increase it. This may not satisfy all strings but gives maximum performance.\n• Call the wcsxfrm subroutine twice: once to find the value of n, and again to transform the string using this n value. This strategy slows down performance because the wcsxfrm subroutine is called twice. However, it yields a precise value for the buffer size needed to store the transformed string. Which method to choose depends on the characteristics of the strings used in the program and the performance objectives of the program. #include <stdio.h> #include <string.h> #include <locale.h> #include <stdlib.h> main() { wchar_t *pwcs1, *pwcs2, *pwcs3, *pwcs4; size_t n, retval; (void)setlocale(LC_ALL, \"\"); /* ** Let the string pointed to by pwcs1 and pwcs3 be the ** wide character arrays to store the transformed wide ** character strings. Let the strings pointed to by pwcs2 ** and pwcs4 be the wide character strings to compare based ** on the collation values of the wide characters in these ** strings. ** Let n be large enough (say,BUFSIZ) to transform the two ** wide character strings specified by pwcs2 and pwcs4. ** ** Note: ** In practice, it is best to call wcsxfrm if the wide ** character string is to be compared several times to ** different wide character strings. */ do { retval = wcsxfrm(pwcs1, pwcs2, n); if(retval == (size_t)-1){ /* error has occurred. */ /* Process the error if needed */ break; } if(retval >= n ){ /* ** Increase the value of n and use a bigger buffer pwcs1. */ } }while (retval >= n); do { retval = wcsxfrm(pwcs3, pwcs4, n); if (retval == (size_t)-1){ /* error has occurred. */ /* Process the error if needed */ break; if(retval >= n){ /*Increase the value of n and use a bigger buffer pwcs3.*/ } }while (retval >= n); retval = wcscmp(pwcs1, pwcs3); /* retval has the result */ }\n\nThe strcmp and strncmp subroutines determine if the contents of two multibyte strings are equivalent. If your application needs to know how the two strings differ lexically, use the multibyte and wide character string collation subroutines.\n\nThe following example uses the wcscmp subroutine to compare two wide character strings:\n\nThe following NLS subroutines convert wide character strings to double, long, and unsigned long integers:\n\nBefore calling the wcstod, wcstoul, or wcstol subroutine, the errno global variable must be set to 0. Any error that occurs as a result of calling these subroutines can then be handled correctly.\n• The following example uses the wcstod subroutine to convert a wide character string to a double-precision floating point: #include <stdlib.h> #include <locale.h> #include <errno.h> extern int errno; main() { wchar_t *pwcs, *endptr; double retval; (void)setlocale(LC_ALL, \"\"); /* ** Let pwcs point to a wide character null terminated ** string containing a floating point value. */ errno = 0; /* set errno to zero */ retval = wcstod(pwcs, &endptr); if(errno != 0){ /* errno has changed, so error has occurred */ if(errno == ERANGE){ /* correct value is outside range of ** representable values. Case of overflow ** error */ if((retval == HUGE_VAL) || (retval == -HUGE_VAL)){ /* Error case. Handle accordingly. */ }else if(retval == 0){ /* correct value causes underflow */ /* Handle appropriately */ } } } /* retval contains the double. */ }\n• The following example uses the wcstol subroutine to convert a wide character string to a signed long integer: #include <stdlib.h> #include <locale.h> #include <errno.h> #include <stdio.h> extern int errno; main() { wchar_t *pwcs, *endptr; long int retval; (void)setlocale(LC_ALL, \"\"); /* ** Let pwcs point to a wide character null terminated ** string containing a signed long integer value. */ errno = 0; /* set errno to zero */ retval = wcstol(pwcs, &endptr, 0); if(errno != 0){ /* errno has changed, so error has occurred */ if(errno == ERANGE){ /* correct value is outside range of ** representable values. Case of overflow ** error */ if((retval == LONG_MAX) || (retval == LONG_MIN)){ /* Error case. Handle accordingly. */ }else if(errno == EINVAL){ /* The value of base is not supported */ /* Handle appropriately */ } } } /* retval contains the long integer. */ }\n• The following example uses the wcstoul subroutine to convert a wide character string to an unsigned long integer: #include <stdlib.h> #include <locale.h> #include <errno.h> extern int errno; main() { wchar_t *pwcs, *endptr; unsigned long int retval; (void)setlocale(LC_ALL, \"\"); /* ** Let pwcs point to a wide character null terminated ** string containing an unsigned long integer value. */ errno = 0; /* set errno to zero */ retval = wcstoul(pwcs, &endptr, 0); if(errno != 0){ /* error has occurred */ if(retval == ULONG_MAX || errno == ERANGE){ /* ** Correct value is outside of ** representable value. Handle appropriately */ }else if(errno == EINVAL){ /* The value of base is not representable */ /* Handle appropriately */ } } /* retval contains the unsigned long integer. */ }\n\nThe following example uses the wcscpy subroutine to copy a wide character string into a wide character array:\n\nThe following NLS subroutines are used to search for wide character strings:\n• The following example uses the wcschr subroutine to locate the first occurrence of a wide character in a wide character string: #include <string.h> #include <locale.h> #include <stdlib.h> main() { wchar_t *pwcs1, wc, *pws; int retval; (void)setlocale(LC_ALL, \"\"); /* ** Let pwcs1 point to a wide character null terminated string. ** Let wc point to the wide character to search for. ** */ pws = wcschr(pwcs1, wc); if (pws == (wchar_t )NULL ){ /* wc does not occur in pwcs1 */ }else{ /* pws points to the location where wc is found */ } }\n• The following example uses the wcsrchr subroutine to locate the last occurrence of a wide character in a wide character string: #include <string.h> #include <locale.h> #include <stdlib.h> main() { wchar_t *pwcs1, wc, *pws; int retval; (void)setlocale(LC_ALL, \"\"); /* ** Let pwcs1 point to a wide character null terminated string. ** Let wc point to the wide character to search for. ** */ pws = wcsrchr(pwcs1, wc); if (pws == (wchar_t )NULL ){ /* wc does not occur in pwcs1 */ }else{ /* pws points to the location where wc is found */ } }\n• The following example uses the wcspbrk subroutine to locate the first occurrence of several wide characters in a wide character string: #include <string.h> #include <locale.h> #include <stdlib.h> main() { wchar_t *pwcs1, *pwcs2, *pws; (void)setlocale(LC_ALL, \"\"); /* ** Let pwcs1 point to a wide character null terminated string. ** Let pwcs2 be initialized to the wide character string ** that contains wide characters to search for. */ pws = wcspbrk(pwcs1, pwcs2); if (pws == (wchar_t )NULL ){ /* No wide character from pwcs2 is found in pwcs1 */ }else{ /* pws points to the location where a match is found */ } }\n• The following example uses the wcsspn subroutine to determine the number of wide characters in the initial segment of a wide character string segment: #include <string.h> #include <locale.h> #include <stdlib.h> main() { wchar_t *pwcs1, *pwcs2; size_t count; (void)setlocale(LC_ALL, \"\"); /* ** Let pwcs1 point to a wide character null terminated string. ** Let pwcs2 be initialized to the wide character string ** that contains wide characters to search for. */ count = wcsspn(pwcs1, pwcs2); /* ** count contains the length of the segment. */ }\n• The following example uses the wcscspn subroutine to determine the number of wide characters not in a wide character string segment: #include <string.h> #include <locale.h> #include <stdlib.h> main() { wchar_t *pwcs1, *pwcs2; size_t count; (void)setlocale(LC_ALL, \"\"); /* ** Let pwcs1 point to a wide character null terminated string. ** Let pwcs2 be initialized to the wide character string ** that contains wide characters to search for. */ count = wcscspn(pwcs1, pwcs2); /* ** count contains the length of the segment consisting ** of characters not in pwcs2. */ }\n• The following example uses the wcswcs subroutine to locate the first occurrence of a wide character string within another wide character string: #include <string.h> #include <locale.h> #include <stdlib.h> main() { wchar_t *pwcs1, *pwcs2, *pws; (void)setlocale(LC_ALL, \"\"); /* ** Let pwcs1 point to a wide character null terminated string. ** Let pwcs2 be initialized to the wide character string ** that contains wide characters sequence to locate. */ pws = wcswcs(pwcs1, pwcs2); if (pws == (wchar_t)NULL){ /* wide character sequence pwcs2 is not found in pwcs1 */ }else{ /* ** pws points to the first occurrence of the sequence ** specified by pwcs2 in pwcs1. */ } }\n• The following example uses the wcstok subroutine to tokenize a wide character string: #include <string.h> #include <locale.h> #include <stdlib.h> main() { wchar_t *pwcs1 = L\"?a???b,,,#c\"; wchar_t *pwcs; (void)setlocale(LC_ALL, \"\"); pwcs = wcstok(pwcs1, L\"?\"); /* pws points to the token: L\"a\" */ pwcs = wcstok((wchar_t *)NULL, L\",\"); /* pws points to the token: L\"??b\" */ pwcs = wcstok((wchar_t *)NULL, L\"#,\"); /* pws points to the token: L\"c\" */ }\n\nNLS provides subroutines for both formatted and unformatted I/O.\n\nAdditions to the printf and scanf family of subroutines allow for the formatting of wide characters. The printf and scanf subroutines have two additional format specifiers for wide character handling: %C and %S. The %C and %S format specifiers allow I/O on a wide character and a wide character string, respectively. They are similar to the %c and %s format specifiers, which allow I/O on a multibyte character and string.\n\nThe multibyte subroutines accept a multibyte array and output a multibyte array. To convert multibyte output from a multibyte subroutine to a wide character string, use the mbstowcs subroutine.\n\nUnformatted wide character I/O subroutines are used when a program requires code set-independent I/O for characters from multibyte code sets. For example, the fgetwc or getwc subroutine should be used to input a multibyte character. If the program uses the getc subroutine to input a multibyte character, the program must call the getc subroutine once for each byte in the multibyte character.\n\nWide character input subroutines read multibyte characters from a stream and convert them to wide characters. The conversion is done as if the subroutines call the mbtowc and mbstowcs subroutines.\n\nWide character output subroutines convert wide characters to multibyte characters and write the result to the stream. The conversion is done as if the subroutines call the wctomb and wcstombs subroutines.\n\nThe behavior of wide character I/O subroutines is affected by the LC_CTYPE category of the current locale.\n\nIf a program has to go through an entire file that must be handled in wide character code form, it can be done in one of the following ways:\n• In the case of multibyte characters, use either the read or fread subroutine to convert a block of text data into a buffer. Convert one character at a time in this buffer using the mbtowc subroutine. Handle special cases of multibyte characters crossing block boundaries. For multibyte code sets, do not use the mbstowcs subroutine on this buffer. On an invalid or a partial multibyte character sequence, the mbstowcs subroutine returns -1 without indicating how far it successfully converted the data. You can use the mbstowcs subroutine with single-byte code sets because you will not run into a partial-byte sequence problem with single-byte code sets.\n• Use the fgetws subroutine to obtain a line from the file. If the returned wide character string contains a wide character <new-line>, then a complete line is obtained. If there is no <new-line> wide character, it means that the line is longer than expected, and more calls to the fgetws subroutine are needed to obtain the complete line. If the program can efficiently process one line at a time, this approach is recommended.\n• If the fgets subroutine is used to read a multibyte file to obtain one line at a time, a split multibyte character may result. This condition needs to be handled just as in the case of the read subroutine breaking up a multibyte character across successive reads. If you can guarantee that the input line length is not more than a set limit, a buffer of that size (plus 1 for null) can be used, thereby avoiding the possibility of a split multibyte character. If the program can efficiently process one line at a time, this approach may be used. Because of the possibility of split bytes in the buffer, you should use the fgetws subroutine in preference to the fgets subroutine for multibyte characters.\n• Use the fgetwc subroutine on the file to read one wide character code at a time. If a file is large, the function call overhead becomes large and reduces the value of this method.\n\nThe decision of which one of these methods to use should be made on a per program basis. The second option is recommended, as it is capable of high performance and the program does not have to handle the special cases.\n\nA new data type, wint_t,is required to represent the wide character code value as well as the end-of-file (EOF) marker. For example, consider the case of the fgetwc subroutine, which returns a wide character code value:\n\nDue to these reasons, wint_t data type is needed to represent the fgetwc subroutine return value. The wint_t data type is defined in the wchar.h file.\n\nThe following subroutines are used for wide character input:\n\nThe following subroutines are used for wide character output:\n• The following example uses the fgetwc subroutine to read wide character codes from a file: #include <stdio.h> #include <locale.h> #include <stdlib.h> main() { wint_t retval; FILE *fp; wchar_t *pwcs; (void)setlocale(LC_ALL, \"\"); /* ** Open a stream. */ fp = fopen(\"file\", \"r\"); /* ** Error Handling if fopen was not successful. */ if(fp == NULL){ /* Error handler */ }else{ /* ** pwcs points to a wide character buffer of BUFSIZ. */ while((retval = fgetwc(fp)) != WEOF){ *pwcs++ = (wchar_t)retval; /* break when buffer is full */ } } /* Process the wide characters in the buffer */ }\n• The following example uses the getwchar subroutine to read wide characters from standard input: #include <stdio.h> #include <locale.h> #include <stdlib.h> main() { wint_t retval; FILE *fp; wchar_t *pwcs; (void)setlocale(LC_ALL, \"\"); index = 0; while((retval = getwchar()) != WEOF){ /* pwcs points to a wide character buffer of BUFSIZ. */ *pwcs++ = (wchar_t)retval; /* break on buffer full */ } /* Process the wide characters in the buffer */ }\n• The following example uses the ungetwc subroutine to push a wide character onto an input stream: #include <stdio.h> #include <locale.h> #include <stdlib.h> main() { wint_t retval; FILE *fp; (void)setlocale(LC_ALL, \"\"); /* ** Open a stream. */ fp = fopen(\"file\", \"r\"); /* ** Error Handling if fopen was not successful. */ if(fp == NULL){ /* Error handler */ else{ retval = fgetwc(fp); if(retval != WEOF){ /* ** Peek at the character and return it to the stream. */ retval = ungetwc(retval, fp); if(retval == EOF){ /* Error on ungetwc */ } } } }\n• The following example uses the fgetws subroutine to read a file one line at a time: #include <stdio.h> #include <locale.h> #include <stdlib.h> main() { FILE *fp; wchar_t *pwcs; (void)setlocale(LC_ALL, \"\"); /* ** Open a stream. */ fp = fopen(\"file\", \"r\"); /* ** Error Handling if fopen was not successful. */ if(fp == NULL){ /* Error handler */ }else{ /* pwcs points to wide character buffer of BUFSIZ. */ while(fgetws(pwcs, BUFSIZ, fp) != (wchar_t *)NULL){ /* ** pwcs contains wide characters with null ** termination. */ } } }\n• The following example uses the fputwc subroutine to write wide characters to an output stream: #include <stdio.h> #include <locale.h> #include <stdlib.h> main() { int index, len; wint_t retval; FILE *fp; wchar_t *pwcs; (void)setlocale(LC_ALL, \"\"); /* ** Open a stream. */ fp = fopen(\"file\", \"w\"); /* ** Error Handling if fopen was not successful. */ if(fp == NULL){ /* Error handler */ }else{ /* Let len indicate number of wide chars to output. ** pwcs points to a wide character buffer of BUFSIZ. */ for(index=0; index < len; index++){ retval = fputwc(*pwcs++, fp); if(retval == WEOF) break; /* write error occurred */ /* errno is set to indicate the error. */ } } }\n• The following example uses the fputws subroutine to write a wide character string to a file: #include <stdio.h> #include <locale.h> #include <stdlib.h> main() { int retval; FILE *fp; wchar_t *pwcs; (void)setlocale(LC_ALL, \"\"); /* ** Open a stream. */ fp = fopen(\"file\", \"w\"); /* ** Error Handling if fopen was not successful. */ if(fp == NULL){ /* Error handler */ }else{ /* ** pwcs points to a wide character string ** to output to fp. */ retval = fputws(pwcs, fp); if(retval == -1){ /* Write error occurred */ /* errno is set to indicate the error */ } } }\n\nUse the L constant for ASCII characters only. For ASCII characters, the L constant value is numerically the same as the code point value of the character. For example, is same as . The reason for using the L constant is to obtain the wchar_t value of an ASCII character for assignment purposes. A wide character constant is introduced by the L specifier. For example:\n\nA wide character code corresponding to the character is stored in . The C compiler converts the character using the mbtowc or mbstowcs subroutine as appropriate. This conversion to wide characters is based on the current locale setting at compile time. Because ASCII characters are part of all supported code sets and the wide character representation of all ASCII characters is the same in all locales, results in the same value across all code sets. However, if the character is non-ASCII, the program may not work when it is run on a different code set than used at compile time. This limitation impacts some programs that use switch statements using the wide character constant representation.\n\nSee a partial program example, compiled using the IBM-850 code set.\n\nIf this program is compiled and executed on an IBM-850 code set system, it will run correctly. However, if the same executable is run on an ISO8859-1 system, it may not work correctly. The characters a-umlaut and c-cedilla may have different process codes in IBM-850 and ISO8859-1 code sets.\n\nNational Language Support Subroutines Overview provides information about wide character and multibyte subroutines.\n\nFor general information about internationalizing programs, see National Language Support Overview for Programming and Locale Overview for Programming.\n\nThe LC_COLLATE category of the locale definition file in AIX Version 4.3 Files Reference.\n\nThe LC_CTYPE category of the locale definition file in AIX Version 4.3 Files Reference.\n\nThe List of Wide Character Subroutines and \n\nthe List of Multibyte Character Subroutines.\n\nThe getc subroutine, printf subroutines, in AIX Version 4.3 Technical Reference: Base Operating System and Extensions Volume 1; and read subroutine, scanf subroutines, setlocale subroutine, strlen subroutine in AIX Version 4.3 Technical Reference: Base Operating System and Extensions Volume 2."
    },
    {
        "link": "https://tutorialspoint.com/c_standard_library/c_function_towlower.htm",
        "document": "The C wctype library towlower() function is used to convert the given wide character to the lower case, if possible.\n\nThis function can be useful for case insensitive comparison, text normalization, or user input processing.\n\nFollowing is the C library syntax of towlower() function −\n• wc − It is a wide character of type 'wint_t' to be converted into lower case.\n\nThis function returns lowercase character if the wide character has changed to a lowercase character, otherwise unchanged character (if it is already lowercase or not an alphabetic character)\n\nThe following is the basic c example that demonstrate the use of towlower() function.\n\nFollowing is the output −\n\nWe create a c program to compare strings are equal or not. after converting to lowercase using the towlower(). If both strings are equal, it means case insensitive, otherwise sensitive.\n\nFollowing is the output −\n\nThe below example, normalized the wide character into a lowercase character.\n\nFollowing is the output −"
    }
]