[
    {
        "link": "https://kasodiyanirali.medium.com/list-generate-in-dart-mastering-this-flutter-technique-39a31d1912f3",
        "document": "In Dart programming, efficient management of lists is crucial, especially when developing Flutter applications that require dynamic and responsive user interfaces. The List class in Dart offers various methods to create and manipulate lists, with List.generate standing out as a powerful tool for generating lists based on dynamic criteria. This article explores the versatility of List.generate, its applications in Flutter development, and provides practical examples to illustrate its usage effectively.\n\nDart’s List.generate method simplifies the process of creating lists by generating elements based on a callback function. This approach is particularly useful when you need to populate a list with items that follow a specific pattern or when the number of items is known in advance. By leveraging List.generate, developers can streamline their code, improve readability, and maintain consistency across their applications.\n\nThe syntax of List.generate is straightforward:\n\nList.generate(int count, (int index) {\n\n\n\n // Generate and return each item based on the index\n\n\n\n});\n\nHere, count specifies the number of elements to generate, and the callback function (int index) is invoked count times to produce each element of the list.\n\nLet’s start with a simple example where we generate a list of numbers:\n\nIn this example, List.generate creates a list containing numbers that are double the index value, from 0 to 4.\n\nExample 2: Creating a List of Widgets in Flutter\n\nFlutter developers often use List.generate to generate lists of widgets dynamically. Consider a scenario where you need to create a list of ListTile widgets:\n\nIn this example, List.generate dynamically creates five ListTile widgets, each with different titles and descriptions, embedded within a ListView for display.\n\nList.generate can also be used to create grids of cards or similar widgets in Flutter:\n\nIn this example, List.generate creates a grid of 9 Card widgets with centered text displaying “Item 0” to “Item 8”.\n\nList.generate can also be used to populate dropdown menus dynamically:\n\nimport ‘package:flutter/material.dart’;\n\nvoid main() {\n\n\n\n runApp(MyApp());\n\n\n\n}\n\nclass MyApp extends StatelessWidget {\n\n\n\n final List dropdownItems = ;\n\n @override\n\n\n\n Widget build(BuildContext context) {\n\n\n\n List dropdownMenuItems =\n\n\n\n List.generate(dropdownItems.length, (index) {\n\n\n\n return DropdownMenuItem(\n\n\n\n value: dropdownItems,\n\n\n\n child: Text(dropdownItems),\n\n\n\n );\n\n\n\n });\n\n return MaterialApp(\n\n\n\n home: Scaffold(\n\n\n\n appBar: AppBar(title: Text(‘Dropdown Menu Example’)),\n\n\n\n body: Center(\n\n\n\n child: DropdownButton(\n\n\n\n items: dropdownMenuItems,\n\n\n\n onChanged: (String? value) {\n\n\n\n // Handle dropdown value change\n\n\n\n },\n\n\n\n ),\n\n\n\n ),\n\n\n\n ),\n\n\n\n );\n\n\n\n }\n\n\n\n}\n\nIn this example, List.generate dynamically creates DropdownMenuItem widgets based on a list of string options, enabling users to select from a dropdown menu.\n\nUsing List.generate offers several advantages for Dart and Flutter developers:\n\n- Concise and Readable Code: List.generate simplifies the process of generating lists, reducing boilerplate code and enhancing readability.\n\n\n\n- Dynamic List Generation: Developers can dynamically create lists based on specific criteria, such as index values or external data.\n\n\n\n- Improved Maintainability: By encapsulating list generation logic within a single method call, List.generate makes code maintenance easier and reduces the risk of errors.\n\n\n\n- Versatility: From simple numeric lists to complex UI components like grids and dropdown menus, List.generate adapts to various use cases in Flutter applications.\n\nIncorporating List.generate into your Dart and Flutter projects empowers you to build scalable and efficient user interfaces. By harnessing its capabilities, developers can enhance productivity, improve code quality, and deliver compelling user experiences. Whether you’re creating lists of data, grids of widgets, or dynamic UI components, List.generate proves invaluable for streamlining development processes and ensuring maintainable codebases.\n\nExplore more about Dart’s List class and List.generate method to unlock new possibilities in Flutter application development. Visit flutter.dev for comprehensive guides and resources on Flutter UI design and development techniques.\n\nStart optimizing your Dart projects today with List.generate and elevate your Flutter apps to the next level of performance and usability.\n\n- What’s New in Flutter: An Exciting Update from I/O 2024\n\n\n\n- Future.wait in Flutter: Streamline Your Asynchronous Code\n\n\n\n- Flutter.dev"
    },
    {
        "link": "https://api.flutter.dev/flutter/dart-core/List-class.html",
        "document": "An indexable collection of objects with a length.\n\nSubclasses of this class implement different kinds of lists. The most common kinds of lists are:\n• An error occurs when attempting to use operations that can change the length of the list.\n• Full implementation of the API defined in this class.\n\nThe default growable list, as created by , keeps an internal buffer, and grows that buffer when necessary. This guarantees that a sequence of add operations will each execute in amortized constant time. Setting the length directly may take time proportional to the new length, and may change the internal capacity so that a following add operation will need to immediately increase the buffer capacity. Other list implementations may have different performance behavior.\n\nTo add data to the growable list, use operator[]=, add or addAll.\n\nTo check whether, and where, the element is in the list, use indexOf or lastIndexOf.\n\nTo remove an element from the growable list, use remove, removeAt, removeLast, removeRange or removeWhere.\n\nTo insert an element at position in the list, use insert or insertAll.\n\nTo replace a range of elements in the list, use fillRange, replaceRange or setRange.\n\nTo sort the elements of the list, use sort.\n\nTo shuffle the elements of this list randomly, use shuffle.\n\nTo find the first element satisfying some predicate, or give a default value if none do, use firstWhere.\n\nThere are similar lastWhere and singleWhere methods.\n\nA list is an Iterable and supports all its methods, including where, map, whereType and toList.\n\nLists are Iterable. Iteration occurs over values in index order. Changing the values does not affect iteration, but changing the valid indices—that is, changing the list's length—between iteration steps causes a ConcurrentModificationError. This means that only growable lists can throw ConcurrentModificationError. If the length changes temporarily and is restored before continuing the iteration, the iterator might not detect it.\n\nIt is generally not allowed to modify the list's length (adding or removing elements) while an operation on the list is being performed, for example during a call to forEach or sort. Changing the list's length while it is being iterated, either by iterating it directly or through iterating an Iterable that is backed by the list, will break the iteration."
    },
    {
        "link": "https://api.dart.dev/dart-core/List-class.html",
        "document": "An indexable collection of objects with a length.\n\nSubclasses of this class implement different kinds of lists. The most common kinds of lists are:\n• An error occurs when attempting to use operations that can change the length of the list.\n• Full implementation of the API defined in this class.\n\nThe default growable list, as created by , keeps an internal buffer, and grows that buffer when necessary. This guarantees that a sequence of add operations will each execute in amortized constant time. Setting the length directly may take time proportional to the new length, and may change the internal capacity so that a following add operation will need to immediately increase the buffer capacity. Other list implementations may have different performance behavior.\n\nTo add data to the growable list, use operator[]=, add or addAll.\n\nTo check whether, and where, the element is in the list, use indexOf or lastIndexOf.\n\nTo remove an element from the growable list, use remove, removeAt, removeLast, removeRange or removeWhere.\n\nTo insert an element at position in the list, use insert or insertAll.\n\nTo replace a range of elements in the list, use fillRange, replaceRange or setRange.\n\nTo sort the elements of the list, use sort.\n\nTo shuffle the elements of this list randomly, use shuffle.\n\nTo find the first element satisfying some predicate, or give a default value if none do, use firstWhere.\n\nThere are similar lastWhere and singleWhere methods.\n\nA list is an Iterable and supports all its methods, including where, map, whereType and toList.\n\nLists are Iterable. Iteration occurs over values in index order. Changing the values does not affect iteration, but changing the valid indices—that is, changing the list's length—between iteration steps causes a ConcurrentModificationError. This means that only growable lists can throw ConcurrentModificationError. If the length changes temporarily and is restored before continuing the iteration, the iterator might not detect it.\n\nIt is generally not allowed to modify the list's length (adding or removing elements) while an operation on the list is being performed, for example during a call to forEach or sort. Changing the list's length while it is being iterated, either by iterating it directly or through iterating an Iterable that is backed by the list, will break the iteration."
    },
    {
        "link": "https://geeksforgeeks.org/generators-in-dart",
        "document": "Generators in Dart allows the user to produce a sequence of value easily. One can generate a sequence of values in dart with the help of two generator functions :\n\nThe synchronous generator returns an iterable object i.e. it returns the collection of values, or “elements”, that can be accessed sequentially. To implement synchronous generator function, mark the function body as sync*, and use yield statements to deliver value(s).\n\nThe asynchronous generator returns a stream object. A Stream provides a way to receive a sequence of events. Each event is either a data event, also called an element of the stream, or an error event, which is a notification that something has failed. To implement an asynchronous generator function, mark the function body as async*, and use yield statements to deliver value(s).\n\nExample: Implementing an asynchronous generator in Dart."
    },
    {
        "link": "https://docs.flutter.dev/cookbook/lists/mixed-list",
        "document": "You might need to create lists that display different types of content. For example, you might be working on a list that shows a heading followed by a few items related to the heading, followed by another heading, and so on.\n\nHere's how you can create such a structure with Flutter:\n• Create a data source with different types of items.\n• Convert the data source into a list of widgets.\n\nTo represent different types of items in a list, define a class for each type of item.\n\nIn this example, create an app that shows a header followed by five messages. Therefore, create three classes: , , and .\n\nMost of the time, you would fetch data from the internet or a local database and convert that data into a list of items.\n\nFor this example, generate a list of items to work with. The list contains a header followed by five messages. Each message has one of 3 types: , , or .\n\nTo convert each item into a widget, use the constructor.\n\nIn general, provide a builder function that checks for what type of item you're dealing with, and returns the appropriate widget for that type of item."
    },
    {
        "link": "https://medium.com/@vishalvnair124/maps-in-dart-navigating-key-value-pairs-70981bbcad35",
        "document": "Maps are key-value pairs that allow you to associate keys with values, providing a powerful way to organize and access data in Dart. In this blog post, we’ll explore the fundamentals of maps in Dart, including creation, manipulation, and common operations.\n\nDart provides multiple ways to create maps, including using map literals or the constructor.\n\nYou can access values in a map using their corresponding keys.\n\nDart provides methods to add and update entries in maps, such as and assignment.\n\nYou can remove entries from a map using the method.\n\nYou can iterate through the entries of a map using loops like or .\n\nDart provides various properties and methods for working with maps, such as , , , , and .\n\nMaps are versatile data structures in Dart, allowing you to associate keys with values and organize data efficiently. Whether you’re creating, accessing, or manipulating maps, understanding these operations will empower you to work effectively with key-value pairs in your Dart programs. Stay tuned for more Dart insights in upcoming medium blog posts. Happy coding!"
    },
    {
        "link": "https://stackoverflow.com/questions/52052241/how-to-get-map-keys-by-values-in-dart",
        "document": "If you will be doing this more than a few times on the same data, you should create an inverse map so that you can perform simple key lookup instead of repeated linear searches. Here's an example of reversing a map (there may be easier ways to do this):\n\nEdit: yes, reversing a map can simply be:\n\nTip of the hat to Joe Conway on gitter. Thanks."
    },
    {
        "link": "https://stackoverflow.com/questions/71017829/using-list-as-a-key-in-map-in-dart",
        "document": "Two list instances containing the same elements is not equal to each other in Dart. This is the reason your example does not work.\n\nIf you want to create a which works like your example, you can use from (basically the same when you are using ) to create an instance with its own definition of what it means for keys to be equal and how is calculated for a key.\n\nSo something like this if you want to have keys to be equal if the list contains the same elements in the same order. It should be noted it does not support nested lists:\n\nI should also add that this is really an inefficient way to do use maps and I am highly recommend to never use as keys in maps."
    },
    {
        "link": "https://dhiwise.com/post/dart-map-the-secret-weapon-for-efficient-data-handling",
        "document": "Writes code, blogs, and product docs. She loves a good meal, a great playlist, and a clean commit history. When she’s not debugging, she’s probably experimenting with a new recipe.\n\nIn programming, data structures play a vital role in organizing and storing data. One such data structure that has proven to be incredibly useful is the Map. In Dart programming language , the Map data structure is a collection of key-value pairs, where each key has exactly one value associated with it.\n\nThis blog post delves deep into the technical aspects of Dart Map, exploring its various features, methods, properties, and how we can effectively use it in our Dart programs. From understanding the concept of key-value pairs to creating and manipulating maps, we will cover it all.\n\nA Dart Map, often simply referred to as a 'map', is a collection of key-value pairs. In a map, there is a finite number of keys, and each key has exactly one value associated with it. This key-value pair system allows us to retrieve a value using its associated key.\n\nIn the above code snippet, we have created a new map where the keys are strings (fruit names) and the values are integers (quantities).\n\nDart map supports a variety of operations, including adding, updating, and removing key-value pairs. It also supports various methods to manipulate and interact with the map. For instance, we can use the forEach method to apply a function to each key-value pair in the map, or the containsKey method to check if a given key exists in the map.\n\nIn the first code snippet, we are using the forEach method to print all key-value pairs in the map. In the second code snippet, we are using the containsKey method to check if 'apple' exists as a key in the map.\n\nThe order of iteration in a map is defined by the individual type of map. For example, a HashMap is unordered (no order is guaranteed), a LinkedHashMap iterates in key insertion order, and a sorted map like SplayTreeMap iterates the keys in sorted order.\n\nIn a Dart map, data is stored in the form of key-value pairs. Each key in the map is associated with exactly one value, forming a key-value pair. The key acts as an identifier for the value, and it can be used to retrieve the associated value at any time.\n\nIn the above code snippet, we are using the key 'apple' to retrieve its associated value from the map.\n\nDefining Key and Value Types in Dart Map\n\nIn Dart, the type of both keys and values in a map can be explicitly defined. This is known as a key-value type map. For instance, we can have a map where the keys are of type String and the values are of type int.\n\nIn the above code snippet, we have defined a map where the keys are strings (fruit names) and the values are integers (quantities). This helps in ensuring that the map only contains the desired type of keys and values, thereby reducing the chances of runtime errors.\n\nDart provides several constructors to create a new map. The Map() constructor is used to create an empty map. We can also use the Map.from() constructor to create a new map with the same keys and values as another map.\n\nIn the above code snippet, we first create an empty map using the Map() constructor. Then, we create a new map with the same keys and values as map1 using the Map.from() constructor.\n\nMap literals are another way to create a new map in Dart. We can define a map literal by enclosing a comma-separated list of key-value pairs in curly braces .\n\nIn the above code snippet, we create a new map using map literals. The keys are strings (fruit names) and the values are integers (quantities).\n\nIn Dart, we can also initialize a map at the time of its creation. This can be done using the Map.fromIterables() constructor, which creates a map associating the given keys to the given values.\n\nIn the above code snippet, we first define two lists keys and values. Then, we initialize a map with these keys and values using the Map.fromIterables() constructor.\n\nIn Dart, we can access the value associated with a specific key in a map using the square brackets [] notation. If the map contains the given key, the associated value is returned. If the map does not contain the key, null is returned.\n\nIn the above code snippet, we are accessing the value associated with the key 'apple' in the map.\n\nWe can update the value associated with a specific key in a map using the square brackets [] notation. If the map already contains the key, the existing value is overwritten. If the map does not contain the key, a new key-value pair is added to the map.\n\nIn the above code snippet, we are updating the value associated with the key 'apple' in the map.\n\nWe can remove a key-value pair from a map using the remove() method. This method removes the key and its associated value from the map. If the map contains the key, the removed value is returned. If the map does not contain the key, null is returned.\n\nIn the above code snippet, we are removing the key-value pair with the key 'apple' from the map.\n\nDart Map provides several methods that operate on a given value.\n• Map.castFrom(): This method adapts the source map to be a map with a different type of keys and values.\n• Map.identity(): This method creates an identity map with the default implementation, LinkedHashMap.\n• Map.from(): This method creates a new map with the same keys and values as another map.\n• Map.fromEntries(): This method creates a new map and adds all entries from an iterable.\n• Map.unmodifiable(): This method creates an unmodifiable hash-based map containing the entries of another map.\n\nFor instance, the Map.castFrom() method adapts the source map to be a map with a different type of keys and values.\n\nIn the above code snippet, we are using the Map.castFrom() static method to create a new map map2 with the same keys as map1 but with values of type double.\n\nDart Map provides several properties that can be used to interact with the map.\n• entries: This property returns an iterable of all entries in the map.\n• keys: This property provides an iterable of all keys in the map.\n• values: This property returns an iterable of all values in the map.\n• length: This property gives the number of key-value pairs in the map.\n• isEmpty: This property checks whether the map is empty.\n• isNotEmpty: This property checks whether the map is not empty.\n\nFor instance, the length property returns the number of key-value pairs in the map, and the keys property returns an iterable of all keys in the map.\n\nIn the above code snippet, we are using the length and keys properties to get the number of key-value pairs and all keys in the map, respectively.\n\nWe can create an instance of a map in Dart using the Map() constructor or any other map constructor. Once the map instance is created, we can use various map methods and properties to manipulate and interact with the map.\n\nIn the above code snippet, we first create a map instance using the Map() constructor. Then, we add key-value pairs to the map using the square brackets [] notation.\n\nLevel Up Your Programming With Dart Map!\n\nIn this blog post, we delved deep into the technical aspects of Dart Map, a powerful and versatile data structure in Dart. We explored how Dart Map is a collection of key-value pairs, where each key has exactly one value associated with it. We also looked at how to create and initialize maps, access, update, and remove map values, and the various methods and properties provided by Dart Map.\n\nUnderstanding Dart Map and its functionalities is crucial for any Dart programmer, as it is a fundamental data structure used in many programming scenarios. With its ability to store data in key-value pairs, Dart Map provides an efficient way to organize and manipulate data.\n\nWe hope this blog post has provided you with a comprehensive understanding of Dart Map and its functionalities.\n\nShort on time? Speed things up with DhiWise!\n\nTired of manually designing screens, coding on weekends, and technical debt? Let DhiWise handle it for you!\n\nYou can build an e-commerce store, healthcare app, portfolio, blogging website, social media or admin panel right away. Use our library of 40+ pre-built free templates to create your first application using DhiWise."
    },
    {
        "link": "https://oreilly.com/library/view/flutter-and-dart/9781098119508/ch04.html",
        "document": "In this chapter, the fundamentals of data handling with Dart are outlined. The aim of this chapter is to cover Lists and Maps that are used to provide foundational data structures for information handling in Dart.\n\nIf you are lucky enough to be familiar with other languages, then many of the concepts presented should be familiar. However, in case this is your first time seeing these techniques, the example pieces of code are self-contained. You may find it helpful to run and experiment with the examples to gain a feel of the workings of the language.\n\nThe chapter begins by discussing Lists, which are indexable data structures used to hold objects. Lists are very common elements in Dart, as they can be used in a variety of scenarios.\n\nWe also discuss how to use Maps, which are useful for handling key/value pairs. A key/value pair is an associative relationship where the key is used as an index to access a value. For example, you may have a months of the year data structure in which the key is a number and the value is derived from the number, e.g., 1 generates the month January and 12 denotes December.\n\nOver the course of this chapter, you will learn how to utilize Maps and Lists within your application.\n\nYou want a way to use a list of values within a Dart application. Use a List to organize objects as an ordered collection. A List represents an array object that can hold information. It provides a simple construct that uses a zero-indexed grouping of elements. Hereâs an example of how to use a List in Dart: Lists are very versatile and can be used in a variety of circumstances. In the preceding example, a class is used to hold the months of the year, as shown in FigureÂ 4-1. The declaration is used to hold a , but it can actually hold a variety of data types, making this object extremely flexible. The class provides a number of helpful methods such as , , , , and . Each element within the List is directly addressable as well as being capable of being accessed via a method. A List is denoted by the use of square start and end brackets. Within the square brackets are the List elements, separated by commas. List items can be initialized at declaration or amended at a later time during processing. The length of the List is available as a method, and this is used to identify how many elements are currently available. Note the List is indexed from zero, so if you intend to manually access elements, you will need to use zero if you want the first element. Another nice feature of Lists is that they include a range of methods to handle processing information. In the example, the method is used to perform a of the elements contained in the List. As you become more confident with Dart, Lists will become one of the many tools that are essential in the applications you write.\n\nYou want to add new content to an existing List. Use the List method to incorporate new content into a List. Lists support the dynamic addition of new elements and can be expanded as required. Hereâs an example of how to add a List element in Dart: In the preceding example code, a List is initially defined with three elements. If you want to expand the number of elements, this can be done by using the List method. The method will append the new element at the end of the List. When you append a new element, as in FigureÂ 4-2, the class takes care of all the associated processing. The method knows how to append the information passed and will ensure the relevant class properties (e.g., ) are updated. Therefore, in the example, you would see the months output as âJanuary,â âFebruary,â âMarch,â âApril.â You will also see that the length of the List is amended to reflect that a fourth item has been added. The dynamic nature of a List makes it perfect for multiple situations where data structure manipulation is required. You will see Lists used across a number of situations to handle a variety of data types.\n\nYou want to make a List based on a combination of Strings and integers to create a new complex data type. Use Lists to organize the consolidation of other data types. Lists can be especially useful for handling other data structures such as Maps (see Recipe 4.4). Hereâs an example of how to use a List with complex data types in Dart: \"The Return of the Jedi\" In the example, film data is added to a Map that encloses title and year information, as shown in FigureÂ 4-3. Here we use a List to manage the individual Maps, so the individual elements can be combined. The resultant List provides a convenient data structure for accessing the information to be stored. Accessing the information within the List follows the same process as a normal List. To access the information, you need to dereference the variable. In this context, to dereference, use an index to tell Dart that you want to access the property value. The means to access the first element in the List. Once you have access to the List, the data type can then be accessed based on the associated data type. The example code uses a Map to allocate multiple values together. As each element is a Map, you now have the data associated with this. Use the dereferenced value to store in a new variable , which can be accessed directly or with a key. Using Lists can provide an elegant method to access complex data types in a consistent manner. If you need to coordinate data types, consider using a List to make this process more manageable.\n\nYou want to handle a key/value pair in a Dart application. Use a Map to handle key/value objects of any type. Map keys are required to be unique, as they act as the index to access Map values. Map values are not required to be unique and can be duplicated as needed. Hereâs an example of how to declare a Map in Dart: In the code example, a Map is used to define a collection of data based on month information. A construct of this type is very useful to enable pieces of information to be combined together that benefit from a key/value pairing, as shown in FigureÂ 4-4. The month Map structure builds a relationship between the key and the value, e.g., Month 0 is January and January is Month 0. The structure of a Map is very useful in terms of processing list information, such as JavaScript Object Notation (JSON). Declaration of the Map follows a standard variable format. Note: is actually a function call, so this requires the addition of braces. In our example, we indicate that the Map will be composed of an integer and a string, which means a number is used for the key (i.e., index). The string value field holds the reference to the month. You could also define the value as dynamic, which would allow the use of different variable types, providing additional flexibility. To be more specific, you could introduce the dynamic definition to explicitly replace the string. If you make this change, Dart will automatically infer the correct data type based on the variable assignment. To populate the Map, define a key (e.g., ) and then assign a value (e.g., ). The assignment of values can be made in any order; the important thing is to be careful not to duplicate the keys used. Adding an element to the Map requires both a key and a value. In the example, an additional Map structure called is created. Add the new month to the existing structure by calling the method with the parameter of the Map. To access the information within the class, use the Map methods and properties. A Map has a number of methods available that can be used to access the associated data items. To loop through each item, use the key to access the individual items. The example uses the Map method to access each data structure item. With access to the key, the information associated with the Map can be retrieved by combining these elements together. Regarding access to data, it is always worth checking the style guide information provided by the Dart team. In this instance, rather than use a , you could also use a loop. The guidance associated with access is defined in the Dart documentation. As the Dart language matures and guidelines are changed, it is good to be able to understand the reasoning behind them. The general tip to you the developer is to keep an awareness of these changes and look to respond to general guidance to avoid more complex refactoring in later development stages."
    }
]