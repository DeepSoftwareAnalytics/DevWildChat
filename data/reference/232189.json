[
    {
        "link": "https://tarekraafat.github.io/autoComplete.js",
        "document": ""
    },
    {
        "link": "https://github.com/TarekRaafat/autoComplete.js",
        "document": "autoComplete.js is a simple, pure vanilla Javascript library progressively designed for speed, high versatility, and seamless integration with a wide range of projects & systems.\n• Powerful Search Engine with two different modes\n• Works on anything ( , and elements)\n\nTechnical questions and support, please post your question on Stack Overflow using the below tag\n\nGeneral questions or new ideas for please start a discussion on Github using the below link"
    },
    {
        "link": "https://github.com/TarekRaafat/autoComplete.js/blob/master/README.md",
        "document": "autoComplete.js is a simple, pure vanilla Javascript library progressively designed for speed, high versatility, and seamless integration with a wide range of projects & systems.\n• Powerful Search Engine with two different modes\n• Works on anything ( , and elements)\n\nTechnical questions and support, please post your question on Stack Overflow using the below tag\n\nGeneral questions or new ideas for please start a discussion on Github using the below link"
    },
    {
        "link": "https://algolia.com/doc/ui-libraries/autocomplete/introduction/getting-started",
        "document": "Get started with Autocomplete by building an Algolia search experience.\n\nThis documentation offers a few ways to learn about the Autocomplete library:\n• Read the Core Concepts to learn more about underlying principles, like Sources and State.\n• Follow the Guides to understand how to build common UX patterns.\n• Refer to API reference for a comprehensive list of parameters and options.\n• Try out the Playground where you can fork a basic implementation and play around.\n\nKeep reading to see how to install Autocomplete and build a basic implementation with Algolia.\n\nThe recommended way to get started is with the package. It includes everything you need to render a JavaScript autocomplete experience.\n\nOtherwise, you can install the package if you want to build a renderer from scratch.\n\nAll Autocomplete packages are available on the npm registry.\n\nIf you don’t want to use a package manager, you can use a standalone endpoint:\n\nAlgolia recommends using jsDelivr but is also available through unpkg.\n\nThe Autocomplete library provides the package so that you can have sleek styling out of the box.\n\nIf you want a custom theme, use this classic theme and customize it with CSS variables. You can also create an entirely new theme using the classic theme as a starting point.\n\nThis example uses the out of the box classic theme. You can import it like any other Autocomplete package.\n\nThen import it in your project:\n\nIf you don’t use a package manager, you can link the style sheet in your HTML:\n\nAlgolia doesn’t provide support regarding third party services like jsDelivr or other CDNs.\n\nDefining where to put your autocomplete\n\nTo get started, you need a container for your autocomplete to go in. If you don’t have one already, you can insert one into your markup:\n\nThen, insert your autocomplete into it by calling the function and providing the . It can be a CSS selector or an Element.\n\nMake sure to provide a container (for example, a ), not an . Autocomplete generates a fully accessible search box for you.\n\nYou may have noticed two options: and . The option defines the text to show until users start typing in the input.\n\nAutocomplete is now plugged in. But you won’t see anything appear until you define your sources.\n\nSources define where to retrieve the items to display in your Autocomplete drop-down menu. You define your sources in the function by returning an array of source objects.\n\nEach source object needs to include a and a function that returns the items to display. Sources can be static or dynamic.\n\nThis example uses an Algolia index of ecommerce products as a source. The package provides a built-in function for just this purpose.\n\nThe function requires an Algolia search client initialized with an Algolia application ID and API key. It lets you search into your Algolia index using an array of , which defines one or more queries to send to the index.\n\nThis example makes just one query to the “autocomplete” index using the from . For now, it passes one additional parameter, to define how many items to display, but you could pass any other Algolia query parameters.\n\nAlthough you’ve now declared what items to display using , you still won’t see anything until you’ve defined how to display the items you’ve retrieved.\n\nSources also define how to display items in your Autocomplete using . Templates can return a string or anything that’s a valid Virtual DOM element. The example creates a Preact component called to use as the template for each item.\n\nThe CSS classes correspond to the classic theme imported earlier.\n\nThe component uses the component to only display part of the item’s name and description, if they go beyond a certain length. Each attribute’s allowed length and the characters to show when truncated are defined in the and Algolia query parameters in .\n\nThis is what the truncated JSON record looks like:\n\nCheck out how the template displays items by searching in the input below:\n\nWhen you’re building, styling, or debugging your autocomplete experience, you might want to inspect it in your web developer tools. You can set the option to to keep the panel open when inspecting it.\n\nYou should only use the option during development.\n\nTo send click and conversion events when users interact with your autocomplete experience, set the option to .\n\nAlgolia supports the last two versions of the major browsers: Chrome, Edge, Firefox, Safari.\n\nThis is all you need for a basic implementation. To go further, you can use the to add keyboard accessibility features. It lets users open items directly from the autocomplete menu.\n\nNow give it a try: go to one of the items using your keyboard and hit . This brings you to the product detail page on bestbuy.com.\n\nThis outlines a basic autocomplete implementation. There’s a lot more you can do like:\n• Define templates for headers, footers, or when there’s no results\n• Send Algolia Insights events when a user clicks on an item or adds it to their cart\n\nTo learn about customization options, read the Core Concepts or follow one of the Guides."
    },
    {
        "link": "https://npmjs.com/package/autocomplete.js?activeTab=readme",
        "document": "This JavaScript library adds a fast and fully-featured auto-completion menu to your search box displaying results \"as you type\". It can easily be combined with Algolia's realtime search engine. The library is available as a jQuery plugin, an Angular.js directive or a standalone library.\n• FAQ\n• How can I -click on results and have them open in a new tab?\n• Displays suggestions to end-users as they type\n• Supports custom templates to allow for UI flexibility\n• Works well with RTL languages and input method editors\n\nThe library must be included after jQuery, Zepto or Angular.js (with jQuery). Else, it will use the embedded Zepto.\n\nYou can find the built version in dist/.\n\nYou can require it and use Browserify:\n\nWarning: is not compatible with the latest version algoliasearch v4 out of the box, but you can create a compatibility source by yourself like this:\n\nWarning: is not compatible with the latest version algoliasearch v4, therefore we highly recommend you use algoliasearch v3 as specified in the code snippet below.\n• Add the , and the optional attribute to your search bar\n\nWarning: is not compatible with the latest version algoliasearch v4, therefore we highly recommend you use algoliasearch v3 as specified in the code snippet below.\n\nNote: You need to rely on , the lite version embedded in Angular.js won't work.\n\nBelow is a faux mustache template describing the DOM structure of an autocomplete dropdown menu. Keep in mind that , , , and come from the provided templates detailed here.\n\nWhen an end-user mouses or keys over a , the class will be added to it. You can use this class as a hook for styling the \"under cursor\" state of suggestions.\n\nAdd the following CSS rules to add a default style:\n\nHere is what the basic example looks like:\n\nWhen initializing an autocomplete, there are a number of global options you can configure.\n• – If , the first rendered suggestion in the dropdown will automatically have the class, and pressing will select it.\n• – If , when the input is blurred, the first rendered suggestion in the dropdown will automatically have the class, and pressing will select it. This option should be used on mobile, see #113\n• – If , pressing tab will select the first rendered suggestion in the dropdown. Defaults to .\n• – If , the autocomplete will not show a hint. Defaults to .\n• – If , the autocomplete will not close on . Defaults to .\n• – If , the autocomplete will empty the search box when a suggestion is selected. This is useful if you want to use this as a way to input tags using the event.\n• – If , the dropdown menu will open when the input is focused. Defaults to .\n• – If set with a DOM selector, doesn't wrap the input and appends the wrapper and dropdown menu to the first DOM element matching the selector. It automatically positions the wrapper under the input, and sets it to the same width as the input. Can't be used with , because requires the wrapper around the input.\n• – If set with a DOM selector, it overrides the container of the dropdown menu.\n• \n• – the dropdown menu template. The template should include all dataset placeholders.\n• – the header to prepend to the dropdown menu\n• – the footer to append to the dropdown menu\n• – the template to display when none of the datasets are returning results. The templating function is called with a context containing the underlying .\n• \n• – the CSS class prefix of all nested elements. Defaults to .\n• - set this to true if you wish to not use any prefix. Without this option, all nested elements classes will have a leading dash. Defaults to .\n• - Array of shortcut that will focus the input. For example if you want to bind and you can specify:\n• - An optional string that will populate the attribute.\n• – The minimum character length needed before suggestions start getting rendered. Defaults to .\n• – This option allow you to control the width of autocomplete wrapper. When the autocomplete wrapper will not have the width style attribute and you are be able to put your specific width property in your css to control the wrapper. Default value is .\n\nOne scenario for use this option. e.g. You have a css attribute in your and you need to width grows until fill the . In this scenario you put a in your autocomplete wrapper css class and the in your autocomplete dropdown class and all done.\n\nAn autocomplete is composed of one or more datasets. When an end-user modifies the value of the underlying input, each dataset will attempt to render suggestions for the new value.\n\nDatasets can be configured using the following options.\n• – The backing data source for suggestions. Expected to be a function with the signature . It is expected that the function will compute the suggestion set (i.e. an array of JavaScript objects) for and then invoke with said set. can be invoked synchronously or asynchronously.\n• – The name of the dataset. This will be appended to to form the class name of the containing DOM element. Must only consist of underscores, dashes, letters ( ), and numbers. Defaults to a random number.\n• – For a given suggestion object, determines the string representation of it. This will be used when setting the value of the input control after a suggestion is selected. Can be either a key string or a function that transforms a suggestion object into a string. Defaults to . Example function usage:\n• – A hash of templates to be used when rendering the dataset. Note a precompiled template is a function that takes a JavaScript object as its first argument and returns a HTML string.\n• – Rendered when suggestions are available for the given query. Can be either a HTML string or a precompiled template. The templating function is called with a context containing , , and any optional arguments that may have been forwarded by the source: .\n• – Rendered at the bottom of the dataset. Can be either a HTML string or a precompiled template. The templating function is called with a context containing , , and any optional arguments that may have been forwarded by the source: .\n• – Rendered at the top of the dataset. Can be either a HTML string or a precompiled template. The templating function is called with a context containing , , and any optional arguments that may have been forwarded by the source: .\n• – Used to render a single suggestion. The templating function is called with the , and any optional arguments that may have been forwarded by the source: . Defaults to the value of wrapped in a tag i.e. .\n• – If set, will postpone the source execution until after milliseconds have elapsed since the last time it was invoked.\n• - If set to , subsequent identical queries will always execute the source function for suggestions. Defaults to .\n\nA few helpers are provided by default to ease the creation of Algolia-based sources.\n\nTo build a source based on Algolia's array, just use:\n\nTo build an Amazon-like autocomplete menu, suggesting popular queries and for the most popular one displaying the associated categories, you can use the source:\n\nThe options can also take a function. It enables you to have more control of the results returned by Algolia search. The function takes 2 parameters\n• : the text typed in the autocomplete\n• : the callback to call at the end of your processing with the array of suggestions\n\nOr by reusing an existing source:\n\nMalicious users may attempt to engineer XSS attacks by storing HTML/JS in their data. It is important that user-generated data be properly escaped before using it in an autocomplete.js template.\n\nIn order to easily do that, autocomplete.js provides you with a helper function escaping all HTML code but the highlighting tags:\n\nIf you did specify custom highlighting pre/post tags, you can specify them as 2nd and 3rd parameter:\n\nHow can I -click on results and have them open in a new tab?\n\nYou'll need to update your suggestion templates to make them as links and not simple divs. -clicking on them will trigger the default browser behavior and open suggestions in a new tab.\n\nTo also support keyboard navigation, you'll need to listen to the event and change to the destination URL.\n\nNote that you might need to check the value of in first. If it's equal to , you should early, otherwise your main window will also follow the link.\n\nHere is an example of how it would look like:\n\nThe autocomplete component triggers the following custom events.\n• – Triggered when the dropdown menu of the autocomplete is opened.\n• – Triggered when the dropdown menu of the autocomplete is shown (opened and non-empty).\n• – Triggered when all datasets are empty.\n• – Triggered when the dropdown menu of the autocomplete is closed.\n• – Triggered when the dropdown menu cursor is moved to a different suggestion. The event handler will be invoked with 3 arguments: the jQuery event object, the suggestion object, and the name of the dataset the suggestion belongs to.\n• – Triggered when a suggestion from the dropdown menu is selected. The event handler will be invoked with the following arguments: the jQuery event object, the suggestion object, the name of the dataset the suggestion belongs to and a object. The contains a key that can be either , , or , depending how the suggestion was selected.\n• – Triggered when the cursor leaves the selections or its current index is lower than 0\n• – Triggered when the query is autocompleted. Autocompleted means the query was changed to the hint. The event handler will be invoked with 3 arguments: the jQuery event object, the suggestion object, and the name of the dataset the suggestion belongs to.\n• – Triggered when is used and the wrapper is resized/repositionned.\n\nAll custom events are triggered on the element initialized as the autocomplete.\n\nTurns any element into an auto-completion menu. is an options hash that's used to configure the autocomplete to your liking. Refer to Global Options for more info regarding the available configs. Subsequent arguments ( ), are individual option hashes for datasets. For more details regarding datasets, refer to Datasets.\n\nRemoves the autocomplete functionality and reverts the element back to its original state.\n\nOpens the dropdown menu of the autocomplete. Note that being open does not mean that the menu is visible. The menu is only visible when it is open and has content.\n\nCloses the dropdown menu of the autocomplete.\n\nReturns the current value of the autocomplete. The value is the text the user has entered into the element.\n\nSets the value of the autocomplete. This should be used in place of .\n\nReturns a reference to the autocomplete plugin and reverts to its previous value. Can be used to avoid naming collisions.\n\nThe standalone version API is similiar to jQuery's:\n\nYou can also pass a custom Typeahead instance in Autocomplete.js constructor:\n\nReturns a reference to the autocomplete plugin and reverts to its previous value. Can be used to avoid naming collisions.\n\nThis library has originally been forked from Twitter's typeahead.js library."
    },
    {
        "link": "https://stackoverflow.com/questions/59569855/trying-to-store-input-data-on-json-file-with-node-js",
        "document": "As I said on title I'm trying to store the inputs the user made on an HTML form using fs from node to store it on a JSON file.\n\nWhat I'm trying to save is a key value pair which would look like this:\n\nBut what I'm getting is:\n\nI got two files working with this, one which verify the inputs and makes an AJAX call if everything is fine and another one which handles the HTTP request and saves the data on the JSON file.\n\nAnd here the code which manages the HTTP request:\n\nI've also tried doing but I'm getting the same response.\n\nIf someone could help me I'll be really glad, I'm stuck with this and I don't know what to do."
    },
    {
        "link": "https://stackoverflow.com/questions/76242610/optimization-of-node-js-application-using-information-from-a-json-file",
        "document": "In my application, I would like to display the state of various chemical elements depending on a given value. There is a JSON file that contains all the information about the element\n\nFor example, there will be an input field where the user can enter a desired temperature and then will get a display of the elements, colored by their actual state. For this, I need to loop through the JSON file and then compare the values to the entered value. After the comparison, the value will be set to a corresponding position in an array and sent to an electronic display unit. For other properties than temperature (eg. density) a very similar function will be used The JSON-File is not changeable because it's generated externally.\n\nThis is functional, but I wonder if there is a better approach to doing this. Are there any recommendations for a better implementation?"
    },
    {
        "link": "https://medium.com/@nguynvithng_34102/making-a-simple-autocomplete-search-box-639b26a372cd",
        "document": "Autocomplete search box is a wonderful yet essential component for every website especially ecommerce websites. Despite how complex it sound, it’s pretty simple to implement your own autocomplete search box. I have had a chance to create my own autocomplete in my previous school project so in this article, I’m going to re-create it and share some lessions that I learnt during the time I implement it for my school project.\n\nWhat is an autocomplete search box?\n\nI assume that you already have some notion about the autocomplete search box, but if you somehow click on this article then autocomplete search box in a nutshell is a search box just like every other search box but usually combine with a dropdown suggestion box to suggest some possible inputs for user.\n\nMy complete setup for this demo is:\n• Express.js to setup a simple server and response data as we type. This is not required and you can setup any kind of server as long as they can response the JSON data back.\n• nodemon to automatically restart the server if something changed in the server code. This is also optional, you can restart the server manually if you like.\n• Atom , I’ll use atom to edit my code. You can use any other text editor if you want, I usually use vscode but I’m having a big project opened in it so, I switched to Atom.\n\nThe true mechanism behind this search box is dead simple. Here are the steps:\n• User type something in the search box\n• The search box send it to the server using Ajax\n• The server sort and filter the data according to the keyword then response it back\n• The client receive that response and render it bellow the search box\n\nTo begin with our coding, we must first create the HTML structure for our search box. Here is the final result of our search box for better visualization.\n\nAs you can see, our search box include a text box with rounded corners and bellow it is a list that also have some rounded corners. But most importantly, is that the list and the text box is stuck together therefor, the top corners of the list is not rounded and the bottom corners of the text box is not rounded.\n\nBy having a wrapper outside, we can eliminate the sharp corners of both the text box and the list by setting the css property of the wrapper to . By using that way, we can keep the sharp corners at top of the list and at the bottom of the text box.\n\nWith a few minutes smashing the keyboard, this is the HTML structure that we need:\n\nAs you can see, our HTML structure consists of 3 parts:\n• The wrapper — the tag with the class\n• The text box — the tag with the class\n• The result list — the tag with the class\n\nNow, let’s add some makeup for our search box:\n\nLet’s step back from the client side for a bit and look into our server. As I said before, we’re going to use express.js to create our server and response back the JSON data.\n\nTo setup our express.js server, we must first install it, using:\n\nAfter that, to test our server, we can make it to response the html file that we created before using these code:\n\nHmm…But what does this line do?\n\nBecause express only response to what has been configured, our script and style files being included inside the html file can’t be loaded. For example, when the browser interpret our html file to this line:\n\nIt automatically send a request to which will be denied by express because we didn’t configure it in our server code.\n\nFor that reason, I setup the path and tell express to return files in the current directory if those file is requested through that path. Thus, we must change our code to:\n\nThe first step in creating our search API is to setup a path (endpoint) for our API.\n\nThe meaning of the code above is that, every request being sent to our server to the endpoint, we will take the paramater or the query . Then pass it to the function and response the result from that function in JSON format using the function of express.js .\n\nSo how the function work?\n\nJust like every other autocomplete search box, we need to sort our data according to the similarity to the keyword, higher similarity means closer to the #1 position on our list.\n\nIn this example, our data will be list of EDM producers\n\nSo how do we sort them according to the similarity to the keyword? The answer is we will use a built in function of JS array called sort to sort our data.\n\nBecause we want the data with the higher similarity to go on top, we will need to sort them in a descending order, which is why I take the similarity of the second parameter of the sort function minus the first one.\n\nBut how do we get the similarity between our data with the keyword? Or more precise, between 2 strings?\n\nThere’s a simple way to do that by substracting the length of the string with the length of the string after being removed all the parts that contains the keyword.\n\nAlthough this is probably not the best solution but, for the sake of simlicity, I’ll use this solution. I’ll leave some methods that can be used to complete this task at the end of the article.\n\nYou can now communicate with the server by navigating to this endpoint\n\nWhen you navigate to that end point you should expect a list of producers to show up like this:\n\nBy changing your keyword, you can see that our data is changing as we expected\n\nAha! We can now write a simple script to pass the input from the search box to the API using Jquery like this:"
    },
    {
        "link": "https://medium.com/weekly-webtips/js-implementing-auto-complete-f4c5a5d5c009",
        "document": "Have you always wondered, how auto completion works, well it is super complex in real life with machine learning and a whole bunch of stuff happening in the backend which I obviously cannot build all by myself! 😛\n\nSo, I decided to build a pretty similar working prototype which searches an English word dictionary of about 102k words (because that’s all I could find 😥) to produce auto-completion suggestions..\n\nYou might be seeing that, there is no correlation among the words obviously because there is no machine learning being used, but the main goal here to be able to complete the unfinished word (independently i.e irrespective of what was typed before).\n\nWell, more than completion I was more curious about how the back-text (the transparent ghost text that completes your query) worked and how would I blend my word suggestion into the input box itself.\n\nList of words from here. Repository consisting of the words here.\n\nIn order to get better suggestions, I have used a popularity measure based on the frequency of usage of English words found here. (repository here). The only problem is, it hosts only about 10k words, which is not very bad!\n\nPrerequisites before proceeding ahead to the code section:\n• Knowledge about debounce. If not read here.\n\nNow, we’re good to go ahead and code this out!\n\nWhich data structure do we choose and why? Considering our corpus of words can be really huge (only about 102k for now) a linear search for prefixes won’t be feasible and would disrupt the user experience of your application.\n\nA well-known data structure used for searching and matching strings is a Trie Tree. An important thing to note here would be to monitor the space constraint because in the worst-case considering our words only have lowercase to character can consume about :\n\n[depending on the implementation of your trie]\n\nBut, the upside is the time complexity can be fairly low — equal to the length of the query string itself.\n\nWe shall create class consisting of methods to new words and produce suggestions.\n\nLet’s look at the method to add new words:\n\nLet’s look at the structure more closely:\n\nConsider the words & added to the tree, this is how it’ll look :\n\nNext, we need a method to find a word in the tree:\n\nNext, we shall use the above function in-order to produce suggestions:\n\nWe need to traverse the search space where our suggestions lie and recursively build the word. We can use a depth-first search to simply traverse over each node and keep concatenating the letters.\n\nWe can keep a control on the number of child nodes to traverse on the first node using the argument, to prevent from traversing a very large space as the search space could be very large for huge word corpuses.\n\nThat’s all about coding our data structure, let us now use it display suggestions!\n\nLet us use this basic HTML to render the input box:\n\nI haven’t included the styles here (you can see the fiddle here to view the entire source code).\n\nThe filenames in the above are not be taken literally, we only have 2 files — and all the JS code goes in this file itself.\n\nNow, in our file which also contains our class, we shall add event listeners to handle input into our search bar.\n\nMoving on, assuming you are aware of what debounce is (in short — our function is called when the user isn’t typing for ).\n\nReason for adding a debounce to our method:\n\nThe method is responsible for pulling out the suggestions every time there is a change in the search bar text, but the user would only want the suggestion to appear when the user waits for the short (200–250ms) time while typing. This not only improves the user experience but also reduces unnecessary functions calls to the method.\n\nLet’s look at the function:\n\nHere, popularity is a measure of the frequency of the words in general for example the word usually has more frequency than right?\n\nSo, the method just loops through the suggestions and picks the word with the highest frequency.\n\nLets us understand the code with a diagram:\n\nYou can see here, which is the suggestion is nothing but a element placed at the distance equal to the content width of your query!\n\nHow do you get the width used by the content?\n\nHave another with is invisible somewhere in the DOM into which you can write the content of the query and measure the !\n\nSimple right! Now just place the ghost at the right position…\n\nSince, the ghost needs to look similar to the text input in the div, we need to mimic few of the CSS properties of div and to get the CSS properties of the div we can do this :\n\nNow, to set the of the we just do :\n\nJust one thing left to do now! Fill in the input bar if the user wants to use the given suggestion, i.e if the user presses the RIGHT ARROW key."
    },
    {
        "link": "https://intellij-support.jetbrains.com/hc/en-us/community/posts/115000020844-Writing-Node-JS-code-that-is-autocomplete-friendly",
        "document": "I'm trying to get more information about writing NodeJS code that will work better with webstorm's indexing engine.\n\nEven my simplest projects don't get indexed properly.\n\nCould you please shed some light on what is the preferred coding style that the indexing engine would index properly? does the indexing engine evaluate some of the statement to associate values together? example - if I have two objects with constants contained in them and i merge them with lodash _.merge/object.assign - will it get evaluated by webstorm?\n\nAnother fresh example - context not identified:\n\nWebstorm says that mapObject is an unresolved variable. even if i remove the ',this' context and use .bind(this) - still unresolved.\n\nI would appreciate if someone can please provide some best practices on how to write code that would be better crawled through and what we can expect from the indexing engine. I only found this in the context:\n\nHowever it doesn't really say which are the better practices to get the code identified by the crawler - just that for external libraries I should download TypeScript community stubs. does this also mean that in order to get my code better identified I should also start writing TS stubs?\n\nAny info would be appreciated!"
    }
]