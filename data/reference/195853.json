[
    {
        "link": "https://stackoverflow.com/questions/9326299/android-scrollview-and-buttons-at-bottom-of-the-screen",
        "document": "I want to implement this: A ScrollView that contains many elements (ImageViews, TextViews, EditTexts etc) and then after the ScrollView some buttons (which are custom ImageViews) that appear always exactly at the bottom of the screen.\n\nIf I use the android:fillViewport=\"true\" attribute, then if the elements of the ScrollView are too big to fit in the screen size the buttons get invisible . If I use the android:Weight=1 attribute then the ScrollView gets only 50% of the Screen when the screen is big and it can fit (I want the buttons to take a small percentage, about 10%). If I set the android:Weight to bigger values then the buttons appear very small.\n\nPlease help! Maybe it is something simple that I overlooked but I’ve been banging my head for hours!"
    },
    {
        "link": "https://stackoverflow.com/questions/28245127/android-scrollview-and-button-positioning",
        "document": "I am trying to implement scrollview in my main layout, which consists of a grid of buttons. Everything works fine except i can't seem to place any buttons off the screen so they can be seen when the user scrolls, they just overlap the bottom buttons. Ive played around with this and the best i can come up with so far is the following below, so if anyone could help be much appreciated!!"
    },
    {
        "link": "https://abhiandroid.com/ui/scrollview",
        "document": "ScrollView And Horizontal ScrollView Tutorial With Example In Android\n\nIn android ScrollView can hold only one direct child. This means that, if you have complex layout with more views(Buttons, TextViews or any other view) then you must enclose them inside another standard layout like Table Layout, Relative Layout or Linear Layout. You can specify layout_width and layout_height to adjust width and height of screen. You can specify height and width in dp(density pixel) or px(pixel). Then after enclosing them in a standard layout, enclose the whole layout in ScrollView to make all the element or views scrollable.\n\nIt is present inside Containers >> ScrollView or HorizontalScrollView\n\nIn android default ScrollView is used to scroll the items in vertical direction and if you want to scroll the items horizontally then you need to implement horizontal ScrollView.\n\nHere is how Scroll View looks in Android:\n\nIn android, You can scroll the elements or views in both vertical and horizontal directions. To scroll in Vertical we simply use ScrollView as we shown in the previous code of this article and to scroll in horizontal direction we need to use HorizontalScrollview.\n\nScrollView and HorizontalScrollView has same attributes, the only difference is scrollView scroll the child items in vertical direction while horizontal scroll view scroll the child items in horizontal direction.\n\nNow let’s we discuss about the attributes that helps us to configure a ScrollView and its child controls. Some of the most important attributes you will use with ScrollView include:\n\nIn android, id attribute is used to uniquely identify a ScrollView.\n\nBelow is id attribute’s example code with explanation included.\n\nIn android, scrollbars attribute is used to show the scrollbars in horizontal or vertical direction. The possible Value of scrollbars is vertical, horizontal or none. By default scrollbars is shown in vertical direction in scrollView and in horizontal direction in HorizontalScrollView.\n\nBelow is scrollbars attribute’s example code in which we set the scrollbars in vertical direction.\n\nExample of ScrollView In Android Studio:\n\nIn this example we will use 10 button and scroll them using ScrollView in vertical direction. Below is the code and final Output we will create:\n\nSelect File -> New -> New Project -> Android Application Project (or) Android Project. Fill the forms and click “Finish” button.\n\nStep 2: Open res -> layout -> activity_main.xml (or) main.xml and add below code. Here we are creating a Relative Layout having 10 buttons which are nested in Linear Layout and then in ScrollView.\n\nRemember ScrollView can hold only one direct child. So we have to jointly put 10 buttons inside Linear Layout to make it one child. And then we put it inside ScrollView.\n\nStep 3: Now Open src -> package -> MainActivity.java and paste the below code\n\nStep 4: Now open manifest.xml and paste the below code\n\nStep 5: Lastly open res ->values -> strings.xml and paste the below code\n\nNow run the App in Emulator / AVD or in real device. You will see the 10 buttons which can be scrollable in vertical direction.\n\nIn this example we will scroll the buttons in horizontal direction. Below is the complete code and final output:\n\nSelect File -> New -> New Project and Fill the forms and click “Finish” button.\n\nStep 2: Now open res -> layout -> activity_mail.xml (or) main.xml and add below code. Here we are creating same buttons in HorizontalScrollView.\n\nStep 3: Now open app -> java -> MainActivity.java in package and paste the below code:\n\nStep 5: Now open AndroidManifest.xml inside manifests and paste the below code:\n\nStep 6: Open res ->values -> strings.xml and paste the below code:\n\nNow run the App in Emulator /AVD or real device and you will see the 10 buttons can now be scrollable in Horizontal direction."
    },
    {
        "link": "https://developer.android.com/develop/ui/views/layout/responsive-adaptive-design-with-views",
        "document": "Responsive/adaptive layouts provide an optimized user experience regardless of screen size. Implement responsive/adaptive layouts to enable your view‑based app to support all display sizes, orientations, and configurations, including resizable configurations such as multi-window mode.\n\nThe first step in supporting a variety of device form factors is to create a layout that is responsive to variations in the amount of display space available to your app.\n\nThe best way to create a responsive layout is to use as the base layout for your UI. enables you to specify the position and size of each view according to spatial relationships with other views in the layout. All the views can then move and resize together as the display space changes.\n\nThe easiest way to build a layout with is to use the Layout Editor in Android Studio. Layout Editor enables you to drag new views to the layout, apply constraints relative to parent and sibling views, and set view properties—all without editing any XML by hand.\n\nFor more information, see Build a Responsive UI With ConstraintLayout.\n\nTo ensure your layout is responsive to different display sizes, use , , or for the width and height of view components instead of hard‑coded values:\n• : The view sets its size to fit the content the view contains.\n• : The view expands as much as possible within the parent view.\n• : In a , similar to . The view takes all the available space within the view's constraints.\n\nFigure 4 shows how the width and height of the adjust as the display width changes with device orientation.\n\nThe sets its width to fill all available space ( ) and its height to exactly as much space is required by the height of the contained text ( ), which enables the view to adapt to different display dimensions and different amounts of text.\n\nIf you're using a , you can also expand the child views based on layout weight so the views proportionally fill the available space. However, using weights in a nested requires the system to perform multiple layout passes to determine the size for each view, slowing UI performance.\n\ncan create nearly all of the layouts possible with without the performance impact, so convert your nested to . Then you can define weighted layouts with constraint chains.\n\nYour app's layout should always be responsive to different display sizes. However, even a responsive layout can't provide the best user experience on every device or multi‑window mode display. For example, the UI you designed for a phone, probably doesn't provide an optimal user experience on a tablet. Adaptive design provides alternative layouts optimized for different display dimensions.\n\nA list-detail UI typically provides a different user experience on different‑size screens. On large screens, the list and detail panes are usually side by side. When an item in the list is selected, item information is displayed in the detail pane without changing the UI—the two panes remain side by side. However, on small screens, the two panes are displayed separately, each pane occupying the entire display area. When an item in the list pane is selected, the detail pane (containing the selected item's information) replaces the list pane. Back navigation replaces the detail pane with the list.\n\nmanages the logic for determining which of the two user experiences is appropriate for the current window size:\n\nThe and attributes of the two views contained in determine the behavior. In the example, if the window is large enough (at least 580dp wide) to display both views, the panes are displayed side by side. But, if the window width is smaller than 580dp, the panes slide over one another to individually occupy the entire app window.\n\nIf the window width is larger than the total specified minimum width (580dp), values can be used to size the two panes proportionally. In the example, the list pane is always 280dp wide because it does not have a weight. The detail pane however, always fills any horizontal space beyond 580dp because of the view's setting.\n\nTo adapt your UI design to widely varying display sizes, use alternative layouts identified by resource qualifiers.\n\nYou can provide adaptive, screen‑specific layouts by creating additional directories in your app's source code. Create a directory for each screen configuration that requires a different layout. Then append a screen configuration qualifier to the directory name (for example, for screens that have 600dp of available width).\n\nThe configuration qualifiers represent the visible display space available for your app UI. The system takes into account any system decorations (such as the navigation bar) and window configuration changes (such as multi‑window mode) when selecting the layout for your app.\n\nTo create alternative layouts in Android Studio, see Use layout variants to optimize for different screens in Develop a UI with Views.\n\nThe smallest width screen size qualifier enables you to provide alternative layouts for displays that have a minimum width measured in density-independent pixels (dp).\n\nBy describing the screen size as a measure of dp, Android enables you to create layouts that are designed for specific display dimensions without concern for different pixel densities.\n\nFor example, you can create a layout named that's optimized for phones and tablets by creating different versions of the file in different directories:\n\nThe smallest width qualifier specifies the smallest of the display's two sides, regardless of the device's current orientation, so it's a way to specify the overall display size available for your layout.\n\nHere's how other smallest width values correspond to typical screen sizes:\n\nThe following figure gives a more detailed view of how different screen dp widths correspond to different screen sizes and orientations.\n\nValues for the smallest width qualifier are dp, because what matters is the amount of display space available after the system accounts for pixel density (not the raw pixel resolution).\n\nThe sizes you specify using resource qualifiers like smallest width are not the actual screen sizes. Rather, the sizes specify the width or height in dp units that are available to your app's window. The Android system might use some of the screen for system UI (such as the system bar at the bottom of the screen or the status bar at the top), so some of the screen might not be available for your layout. If your app is used in multi‑window mode, the app only has access to the size of the window that contains the app. When the window is resized, it triggers a configuration change with the new window size, which enables the system to select an appropriate layout file. So, the resource qualifier sizes you declare should specify only the space needed by your app. The system accounts for any space used by system UI when providing space for your layout.\n\nInstead of changing the layout based on the smallest width of the display, you might want to change your layout based on how much width or height is available. For example, you might want to use a two‑pane layout whenever the screen provides at least 600dp of width, which might change depending on whether the device is in landscape or portrait orientation. In that case, you should use the available width qualifier as follows:\n\nIf available height is a concern for your app, you can use the available height qualifier. For example, for screens with at least 600dp of screen height.\n\nEven though you may be able to support all size variations using only combinations of the smallest width and available width qualifiers, you might also want to change the user experience when the user switches between portrait and landscape orientations.\n\nFor that, you can add the or qualifiers to your layout directory names. Just be sure the orientation qualifiers come after the size qualifiers. For example:\n\nFor more information about all the screen configuration qualifiers, see App resources overview.\n\nWindow size classes are viewport breakpoints that help you create adaptive layouts. The breakpoints identify the display area available to your app as compact, medium, or expanded. Width and height are specified separately, so your app always has a window size class for width and a window size class for height.\n\nTo programmatically apply adaptive layouts, do the following:\n• Compute your app's width and height window size classes using the function from the Jetpack WindowManager library\n• Inflate the layout resource for the current window size classes\n\nFor more information, see Window size classes.\n\nWhen designing your app for multiple display sizes, use fragments to extract your UI logic into separate components to make sure you aren't needlessly duplicating UI behavior across activities. Then you can combine fragments to create multi‑pane layouts on large screens, or you can place fragments in separate activities on small screens.\n\nFor example, the list‑detail pattern (see SlidingPaneLayout above) could be implemented with one fragment containing the list and another fragment containing the list item details. On large screens, the fragments could be displayed side by side; on small screens, individually, filling the screen.\n\nTo learn more, see the Fragments overview.\n\nIf your app consists of multiple activities, activity embedding enables you to easily create an adaptive UI.\n\nActivity embedding displays multiple activities or multiple instances of the same activity simultaneously in an application's task window. On large screens, activities can be displayed side by side; on small screens, stacked one on top of the other.\n\nYou determine how your app displays its activities by creating an XML configuration file which the system uses to determine the appropriate presentation based on display size. Alternatively, you can make Jetpack WindowManager API calls.\n\nActivity embedding supports device orientation changes and foldable devices, stacking and unstacking activities as the device rotates or folds and unfolds.\n\nFor more information, see Activity embedding.\n\nTest your app on a variety of screen sizes and aspect ratios to ensure your UI scales correctly.\n\nAndroid 10 (API level 29) and higher support a wide range of aspect ratios. Foldable form factors can vary from tall, narrow screens, such as 21:9 when folded, to a square aspect ratio of 1:1 when unfolded.\n\nTo ensure compatibility with as many devices as possible, test your apps for as many of the following screen aspect ratios as you can:\n\nIf you don't have access to devices for all the different screen sizes you want to test, you can use the Android Emulator to emulate almost any screen size.\n\nIf you would rather test on a real device but don't have the device, you can use the Firebase Test Lab to access devices in a Google data center."
    },
    {
        "link": "https://developer.android.com/develop/ui/views/layout/relative",
        "document": "is a view group that displays child views in relative positions. The position of each view can be specified as relative to sibling elements (such as to the left-of or below another view) or in positions relative to the parent area (such as aligned to the bottom, left or center).\n\nNote: For better performance and tooling support, you should instead build your layout with ConstraintLayout.\n\nA is a very powerful utility for designing a user interface because it can eliminate nested view groups and keep your layout hierarchy flat, which improves performance. If you find yourself using several nested groups, you may be able to replace them with a single .\n\nlets child views specify their position relative to the parent view or to each other (specified by ID). So you can align two elements by right border, or make one below another, centered in the screen, centered left, and so on. By default, all child views are drawn at the top-left of the layout, so you must define the position of each view using the various layout properties available from .\n\nSome of the many layout properties available to views in a include:\n\nThese are just a few examples. All layout attributes are documented at .\n\nThe value for each layout property is either a boolean to enable a layout position relative to the parent or an ID that references another view in the layout against which the view should be positioned.\n\nIn your XML layout, dependencies against other views in the layout can be declared in any order. For example, you can declare that \"view1\" be positioned below \"view2\" even if \"view2\" is the last view declared in the hierarchy. The example below demonstrates such a scenario.\n\nEach of the attributes that control the relative position of each view are emphasized.\n\nFor details about all the layout attributes available to each child view of a , see ."
    },
    {
        "link": "https://developer.android.com/develop/ui/views/layout/recyclerview",
        "document": "Save and categorize content based on your preferences.\n\nRecyclerView makes it easy to efficiently display large sets of data. You supply the data and define how each item looks, and the RecyclerView library dynamically creates the elements when they're needed.\n\nAs the name implies, RecyclerView recycles those individual elements. When an item scrolls off the screen, RecyclerView doesn't destroy its view. Instead, RecyclerView reuses the view for new items that have scrolled onscreen. RecyclerView improves performance and your app's responsiveness, and it reduces power consumption.\n\nSeveral classes work together to build your dynamic list.\n• None is the that contains the views corresponding to your data. It's a view itself, so you add to your layout the way you would add any other UI element.\n• None Each individual element in the list is defined by a view holder object. When the view holder is created, it doesn't have any data associated with it. After the view holder is created, the binds it to its data. You define the view holder by extending .\n• None The requests views, and binds the views to their data, by calling methods in the adapter. You define the adapter by extending .\n• None The layout manager arranges the individual elements in your list. You can use one of the layout managers provided by the RecyclerView library, or you can define your own. Layout managers are all based on the library's abstract class.\n\nYou can see how all the pieces fit together in the RecyclerView sample app (Kotlin) or RecyclerView sample app (Java).\n\nIf you're going to use RecyclerView, there are a few things you need to do. They are explained in detail in the following sections.\n• None Decide how the list or grid looks. Ordinarily, you can use one of the RecyclerView library's standard layout managers.\n• None Design how each element in the list looks and behaves. Based on this design, extend the class. Your version of provides all the functionality for your list items. Your view holder is a wrapper around a , and that view is managed by .\n• None Define the that associates your data with the views.\n\nThere are also advanced customization options that let you tailor your RecyclerView to your exact needs.\n\nThe items in your RecyclerView are arranged by a class. The RecyclerView library provides three layout managers, which handle the most common layout situations:\n• arranges the items in a two-dimensional grid:\n• If the grid is arranged vertically, tries to make all the elements in each row have the same width and height, but different rows can have different heights.\n• If the grid is arranged horizontally, tries to make all the elements in each column have the same width and height, but different columns can have different widths.\n• is similar to , but it does not require that items in a row have the same height (for vertical grids) or items in the same column have the same width (for horizontal grids). The result is that the items in a row or column can end up offset from each other.\n\nYou also need to design the layout of the individual items. You need this layout when you design the view holder, as described in the next section.\n\nOnce you determine your layout, you need to implement your and . These two classes work together to define how your data is displayed. The is a wrapper around a that contains the layout for an individual item in the list. The creates objects as needed and also sets the data for those views. The process of associating views to their data is called binding.\n\nWhen you define your adapter, you override three key methods:\n• None : calls this method whenever it needs to create a new . The method creates and initializes the and its associated , but does not fill in the view's contents—the has not yet been bound to specific data.\n• None : calls this method to associate a with data. The method fetches the appropriate data and uses the data to fill in the view holder's layout. For example, if the displays a list of names, the method might find the appropriate name in the list and fill in the view holder's widget.\n• None : calls this method to get the size of the dataset. For example, in an address book app, this might be the total number of addresses. RecyclerView uses this to determine when there are no more items that can be displayed.\n\nHere's a typical example of a simple adapter with a nested that displays a list of data. In this case, the RecyclerView displays a simple list of text elements. The adapter is passed an array of strings containing the text for the elements.\n\n> * Provide a reference to the type of views that you are using // Create new views (invoked by the layout manager) // Create a new view, which defines the UI of the list item // Replace the contents of a view (invoked by the layout manager) // Get element from your dataset at this position and replace the // contents of the view with that element // Return the size of your dataset (invoked by the layout manager) > * Provide a reference to the type of views that you are using * Initialize the dataset of the Adapter * @param dataSet String[] containing the data to populate views to be used // Create new views (invoked by the layout manager) // Create a new view, which defines the UI of the list item // Replace the contents of a view (invoked by the layout manager) // Get element from your dataset at this position and replace the // contents of the view with that element // Return the size of your dataset (invoked by the layout manager)\n\nThe layout for the each view item is defined in an XML layout file, as usual. In this case, the app has a file like this:\n\nThe following code snippet shows how you can use the .\n\nThe library also offers many ways to customize your implementation. For more information, see Advanced RecyclerView customization.\n\nFollow these steps to enable an edge-to-edge display for a :\n• If the list items initially overlap the system bars, apply insets on the . You can do this by setting to or by using .\n• Allow the list items to draw under the system bars while scrolling by setting to on the .\n\nThe following video shows a with edge-to-edge display disabled (left) and enabled (right):\n\nFor more information about testing on Android, consult the following resources."
    },
    {
        "link": "https://developer.android.com/develop/ui/views/layout/declaring-layout",
        "document": "Save and categorize content based on your preferences.\n\nA layout defines the structure for a user interface in your app, such as in an activity. All elements in the layout are built using a hierarchy of and objects. A usually draws something the user can see and interact with. A is an invisible container that defines the layout structure for and other objects, as shown in figure 1.\n\nobjects are often called widgets and can be one of many subclasses, such as or . The objects are usually called layouts and can be one of many types that provide a different layout structure, such as or .\n\nYou can declare a layout in two ways:\n• Declare UI elements in XML. Android provides a straightforward XML vocabulary that corresponds to the classes and subclasses, such as those for widgets and layouts. You can also use Android Studio's Layout Editor to build your XML layout using a drag-and-drop interface.\n• Instantiate layout elements at runtime. Your app can create and objects and manipulate their properties programmatically.\n\nDeclaring your UI in XML lets you separate the presentation of your app from the code that controls its behavior. Using XML files also makes it easier to provide different layouts for different screen sizes and orientations. This is discussed further in Support different screen sizes.\n\nThe Android framework gives you the flexibility to use either or both of these methods to build your app's UI. For example, you can declare your app's default layouts in XML, and then modify the layout at runtime.\n\nUsing Android's XML vocabulary, you can quickly design UI layouts and the screen elements they contain, in the same way that you create web pages in HTML with a series of nested elements.\n\nEach layout file must contain exactly one root element, which must be a or object. After you define the root element, you can add additional layout objects or widgets as child elements to gradually build a hierarchy that defines your layout. For example, here's an XML layout that uses a vertical to hold a and a :\n\nAfter you declare your layout in XML, save the file with the extension in your Android project's directory so it properly compiles.\n\nFor more information about the syntax for a layout XML file, see Layout resource.\n\nWhen you compile your app, each XML layout file is compiled into a resource. Load the layout resource in your app's callback implementation. Do so by calling , passing it the reference to your layout resource in the form: . For example, if your XML layout is saved as , load it for your as follows:\n\nThe Android framework calls the callback method in your when the launches. For more information about activity lifecycles, see Introduction to activities.\n\nEvery and object supports its own variety of XML attributes. Some attributes are specific to a object. For example, supports the attribute. However, these attributes are also inherited by any objects that extend this class. Some are common to all objects, because they are inherited from the root class, like the attribute. Other attributes are considered layout parameters, which are attributes that describe certain layout orientations of the object, as defined by that object's parent object.\n\nAny object can have an integer ID associated with it to uniquely identify the within the tree. When the app is compiled, this ID is referenced as an integer, but the ID is typically assigned in the layout XML file as a string in the attribute. This is an XML attribute common to all objects, and it is defined by the class. You use it very often. The syntax for an ID inside an XML tag is the following:\n\nThe at symbol (@) at the beginning of the string indicates that the XML parser parses and expands the rest of the ID string and identifies it as an ID resource. The plus symbol (+) means this is a new resource name that must be created and added to your resources in the file.\n\nThe Android framework offers many other ID resources. When referencing an Android resource ID, you don't need the plus symbol, but you must add the package namespace as follows:\n\nThe package namespace indicates that you're referencing an ID from the resources class, rather than the local resources class.\n\nTo create views and reference them from your app, you can use a common pattern as follows:\n• Define a view in the layout file and assign it a unique ID, as in the following example:\n• Create an instance of the view object and capture it from the layout, typically in the method, as shown in the following example:\n\nDefining IDs for view objects is important when creating a . In a relative layout, sibling views can define their layout relative to another sibling view, which is referenced by the unique ID.\n\nAn ID doesn't need to be unique throughout the entire tree, but it must be unique within the part of the tree you search. It might often be the entire tree, so it's best to make it unique when possible.\n\nXML layout attributes named define layout parameters for the that are appropriate for the it resides in.\n\nEvery class implements a nested class that extends . This subclass contains property types that define the size and position of each child view, as appropriate for the view group. As shown in figure 2, the parent view group defines layout parameters for each child view, including the child view group.\n\nEvery subclass has its own syntax for setting values. Each child element must define a that is appropriate for its parent, though it might also define a different for its own children.\n\nAll view groups include a width and height, using and , and each view is required to define them. Many include optional margins and borders.\n\nYou can specify width and height with exact measurements, but you might not want to do this often. More often, you use one of these constants to set the width or height:\n• : tells your view to size itself to the dimensions required by its content.\n• : tells your view to become as big as its parent view group allows.\n\nIn general, we don't recommend specifying a layout width and height using absolute units such as pixels. A better approach is using relative measurements, such as density-independent pixel units (dp), , or , because it helps your app display properly across a variety of device screen sizes. The accepted measurement types are defined in Layout resource.\n\nA view has rectangular geometry. It has a location, expressed as a pair of left and top coordinates, and two dimensions, expressed as a width and height. The unit for location and dimensions is the pixel.\n\nYou can retrieve the location of a view by invoking the methods and . The former returns the left (x) coordinate of the rectangle representing the view. The latter returns the top (y) coordinate of the rectangle representing the view. These methods return the location of the view relative to its parent. For example, when returns 20, this means the view is located 20 pixels to the right of the left edge of its direct parent.\n\nIn addition, there are convenience methods to avoid unnecessary computations: namely and . These methods return the coordinates of the right and bottom edges of the rectangle representing the view. For example, calling is similar to the following computation: .\n\nThe size of a view is expressed with a width and height. A view has two pairs of width and height values.\n\nThe first pair is known as measured width and measured height. These dimensions define how big a view wants to be within its parent. You can obtain the measured dimensions by calling and .\n\nThe second pair is known as width and height, or sometimes drawing width and drawing height. These dimensions define the actual size of the view on screen, at drawing time and after layout. These values might, but don't have to, differ from the measured width and height. You can obtain the width and height by calling and .\n\nTo measure its dimensions, a view takes into account its padding. The padding is expressed in pixels for the left, top, right and bottom parts of the view. You can use padding to offset the content of the view by a specific number of pixels. For instance, a left padding of two pushes the view's content two pixels to the right of the left edge. You can set padding using the method and query it by calling , , , and .\n\nAlthough a view can define a padding, it doesn't support margins. However, view groups do support margins. See and for more information.\n\nFor more information about dimensions, see Dimension.\n\nBesides setting margins and padding programmatically, you can also set them in your XML layouts, as shown in the following example:\n\nThe preceding example shows margin and padding being applied. The has uniform margins and padding applied all around, and the shows how you can apply them independently to different edges.\n\nEach subclass of the class provides a unique way to display the views you nest within it. The most flexible layout type, and the one that provides the best tools for keeping your layout hierarchy shallow, is .\n\nThe following are some of the common layout types built into the Android platform.\n\nWhen the content for your layout is dynamic or not pre-determined, you can use or a subclass of . is generally the better option, because it uses memory more efficiently than .\n\nCommon layouts possible with and include the following:\n\noffers more possibilities and the option to create a custom layout manager.\n\nYou can populate an such as or by binding the instance to an , which retrieves data from an external source and creates a that represents each data entry.\n\nAndroid provides several subclasses of that are useful for retrieving different kinds of data and building views for an . The two most common adapters are:\n\nIf during the course of your app's life you change the underlying data that is read by your adapter, call . This notifies the attached view that the data has been changed and it refreshes itself.\n\nYou can respond to click events on each item in an by implementing the interface. For example:\n\nSee how layouts are used in the Sunflower demo app on GitHub."
    },
    {
        "link": "https://stackoverflow.com/questions/40584424/simple-android-recyclerview-example",
        "document": "The following is a minimal example that will look like the following image.\n\nStart with an empty activity. You will perform the following tasks to add the RecyclerView. All you need to do is copy and paste the code in each section. Later you can customize it to fit your needs.\n• Add the xml layout files for the activity and for the RecyclerView row\n• Initialize the RecyclerView in your activity\n\nMake sure the following dependencies are in your app file:\n\nYou can update the version numbers to whatever is the most current. Use rather than if you are still using Android Studio 2.x.\n\nAdd the to your xml layout.\n\nEach row in our is only going to have a single . Create a new layout resource file.\n\nThe needs an adapter to populate the views in each row with your data. Create a new java file.\n• Although not strictly necessary, I included the functionality for listening for click events on the rows. This was available in the old and is a common need. You can remove this code if you don't need it.\n\nAdd the following code to your main activity.\n• Notice that the activity implements the that we defined in our adapter. This allows us to handle row click events in .\n\nThat's it. You should be able to run your project now and get something similar to the image at the top.\n\nYou can add a simple divider like this\n\nIf you want something a little more complex, see the following answers:\n• How to add dividers and spaces between items in RecyclerView?\n• How to indent the divider in a linear layout RecyclerView (ie, add padding, margin, or an inset only to the ItemDecoration)\n\nSee this answer for how to change the background color and add the Ripple Effect when a row is clicked.\n\nSee this answer for how to add, remove, and update rows."
    },
    {
        "link": "https://geeksforgeeks.org/android-recyclerview",
        "document": "RecyclerView is a ViewGroup added to the android studio as a successor of the GridView and ListView. It is an improvement on both of them and can be found in the latest v-7 support packages. It has been created to make possible construction of any lists with XML layouts as an item which can be customized vastly while improving on the efficiency of ListViews and GridViews. This improvement is achieved by recycling the views which are out of the visibility of the user.\n\nLet us check, Android RecyclerView with a simple example.\n\nExample: An Android Application showing the Exam Schedule\n\nTo implement a basic RecyclerView three sub-parts are needed to be constructed which offer the users the degree of control they require in making varying designs of their choice.\n• The Card Layout: The card layout is an XML layout which will be treated as an item for the list created by the RecyclerView.\n• The ViewHolder: The ViewHolder is a java class that stores the reference to the card layout views that have to be dynamically modified during the execution of the program by a list of data obtained either by online databases or added in some other way.\n• The Data Class: The Data class is a custom java class that acts as a structure for holding the information for every item of the RecyclerView.\n• None Click on File, then New => New Project.\n• None Select the minimum SDK(According to the application needs).\n\nLayouts are important part of the Android Applications. This Application will need two main layouts as mentioned below:\n\nexam_card.xml: (This is the Layout of the element to be inserted in RecyclerView)\n\nStep 2: Defining the Elements to be Inserted in Card\n\nWe have two layouts now, but the elements to be placed in the exam_card.xml needs to be defined. So, create a new file named ExamItem file. Properties like name, date, message, image1 and image2.\n\nThe Adapter: The adapter is the main code responsible for RecyclerView. It holds all the important methods dealing with the implementation of RecylcerView. The basic methods for a successful implementation are:\n• onCreateViewHolder: which deals with the inflation of the card layout as an item for the RecyclerView.\n• onBindViewHolder: which deals with the setting of different data and methods related to clicks on particular items of the RecyclerView.\n• getItemCount: which Returns the length of the RecyclerView.\n• onAttachedToRecyclerView: which attaches the adapter to the RecyclerView.\n\nAfter, defining the whole application properties and providing the functionality to the layouts, we will wrap all of them into MainActivity file. OnCreate Method is defined in this file.\n\nKeep in mind, that the drawable mentioned in the XML layouts have to be added to the drawable folder under res of the Android Studio Project and support package v7 should be added as an implementation in the Gradle file of the project for the code to run. The above code uses ScrollView as a parent to RecyclerView and disables the scrolling of the RecyclerView hence making the whole page scroll instead of just the RecyclerView contents."
    },
    {
        "link": "https://guides.codepath.com/android/using-the-recyclerview",
        "document": "The is a that renders any adapter-based view in a similar way. It is supposed to be the successor of ListView and GridView. One of the reasons is that has a more extensible framework, especially since it provides the ability to implement both horizontal and vertical layouts. Use the widget when you have data collections whose elements change at runtime based on user action or network events.\n\nIf you want to use a , you will need to work with the following:\n• - To handle the data collection and bind it to the view\n• - Helps with animating the items for common operations such as Addition or Removal of item\n\nFurthermore, it provides animation support for items whenever they are added or removed, which had been extremely difficult to do with . also begins to enforce the ViewHolder pattern too, which was already a recommended practice but now deeply integrated with this new framework.\n\nFor more details, see this detailed overview.\n\ndiffers from its predecessor primarily because of the following features:\n• Required ViewHolder in Adapters - adapters do not require the use of the ViewHolder pattern to improve performance. In contrast, implementing an adapter for requires the use of the ViewHolder pattern for which it uses .\n• Customizable Item Layouts - can only layout items in a vertical linear arrangement and this cannot be customized. In contrast, the has a that allows any item layouts including horizontal lists or staggered grids.\n• Easy Item Animations - contains no special provisions through which one can animate the addition or deletion of items. In contrast, the has the class for handling item animations.\n• Manual Data Source - had adapters for different sources such as and for arrays and database results respectively. In contrast, the requires a custom implementation to supply the data to the adapter.\n• Manual Item Decoration - has the property for easy dividers between items in the list. In contrast, requires the use of a object to setup much more manual divider decorations.\n• Manual Click Detection - has a interface for binding to the click events for individual items in the list. In contrast, only has support for which manages individual touch events but has no built-in click handling.\n\nA needs to have a layout manager and an adapter to be instantiated. A layout manager positions item views inside a and determines when to reuse item views that are no longer visible to the user.\n\nHere is Dave Smith's talk on the custom layout manager\n\nincludes a new kind of adapter. It’s a similar approach to the ones you already used, but with some peculiarities, such as a required . You will have to override two main methods: one to inflate the view and its view holder, and another one to bind data to the view. The good thing about this is that the first method is called only when we really need to create a new view. No need to check if it’s being recycled.\n\nwill animate modifications such as add/delete/select that are notified to the adapter. can be used for basic default animations and works quite well. See the section of this guide for more information.\n\nUsing a has the following key steps:\n• Define a model class to use as the data source\n• Add a to your activity to display the items\n• Create a and to render the item\n• Bind the adapter to the data source to populate the\n\nThe steps are explained in more detail below.\n\nEvery RecyclerView is backed by a source for data. In this case, we will define a class which represents the data model being displayed by the RecyclerView:\n\nInside the desired activity layout XML file in , let's add the from the support library:\n\nIn the layout, preview we can see the within the activity:\n\nNow the is embedded within our activity layout file. Next, we can define the layout for each item within our list.\n\nBefore we create the adapter, let's define the XML layout file that will be used for each row within the list. This item layout for now should contain a horizontal linear layout with a textview for the name and a button to message the person:\n\nThis layout file can be created in and will be rendered for each item row. Note that you should be using for the . See this link for more context.\n\nWith the custom item layout complete, let's create the adapter to populate the data into the recycler view.\n\nHere we need to create the adapter which will actually populate the data into the RecyclerView. The adapter's role is to convert an object at a position into a list row item to be inserted.\n\nHowever, with a the adapter requires the existence of a \"ViewHolder\" object which describes and provides access to all the views within each item row. We can create the basic empty adapter and holder together in as follows:\n\nNow that we've defined the basic adapter and , we need to begin filling in our adapter. First, let's store a member variable for the list of contacts and pass the list in through our constructor:\n\nEvery adapter has three primary methods: to inflate the item layout and create the holder, to set the view attributes based on the data and to determine the number of items. We need to implement all three to finish the adapter:\n\nWith the adapter completed, all that is remaining is to bind the data from the adapter into the RecyclerView.\n\nBinding the Adapter to the RecyclerView\n\nIn our activity, we will populate a set of sample users which should be displayed in the .\n\nFinally, compile and run the app and you should see something like the screenshot below. If you create enough items and scroll through the list, the views will be recycled and far smoother by default than the widget:\n\nUnlike ListView, there is no way to add or remove items directly through the adapter. You need to make changes to the data source directly and notify the adapter of any changes. Also, whenever adding or removing elements, always make changes to the existing list. For instance, reinitializing the list of Contacts such as the following will not affect the adapter, since it has a memory reference to the old list:\n\nInstead, you need to act directly on the existing reference:\n\nThere are many methods available to use when notifying the adapter of different changes:\n\nWe can use these from the activity or fragment:\n\nEvery time we want to add or remove items from the RecyclerView, we will need to explicitly inform the adapter of the event. Unlike the ListView adapter, a RecyclerView adapter should not rely on since the more granular actions should be used. See the API documentation for more details.\n\nAlso, if you are intending to update an existing list, make sure to get the current count of items before making any changes. For instance, a on the adapter should be called to record the first index that will be changed.\n\nOften times there are cases when changes to your list are more complex (i.e. sorting an existing list) and it cannot be easily determined whether each row changed. In this cases, you would normally have to call on the entire adapter to update the entire screen, which eliminates the ability to perform animation sequences to showcase what changed.\n\nThe ListAdapter class simplifies detecting whether an item was inserted, updated, or deleted. You can find more details in this blog post. Note the blog post refers to Support Library v23 that was replaced with AndroidX library. Use this Migration guide to ensure compatibility with the rest of the examples.\n\nFirst, change your adapter to inherit from a to a .\n\nNote that a requires an extra generic parameter, which is the type of data managed by this adapter. We also need to declare an item callback:\n\nYou may notice an error that says \"There is no default constructor available in \". The reason is that you will declare an empty constructor and your adapter will also need to invoke this callback method:\n\nInstead of overriding , remove it since the size of the list will be managed by the class:\n\nWe will also add a helper function to add more contacts. Anytime we wish to add more contacts, will use this method instead. A function provided by the ListAdapter will trigger the comparison.\n\nFinally, we need to modify the to use the method instead.\n\nThe is built on top of the class but requires less boilerplate code. You can see below what the steps are needed to in order to accomplish the same goal. You do not need to follow the steps below if you already using .\n\nThe class, which was added in the v24.2.0 of the support library, helps compute the difference between the old and new list. This class uses the same algorithm used for computing line changes in source code (the diff utility program), so it usually fairly fast. It is recommended however for larger lists that you execute this computation in a background thread.\n\nTo use the class, you need to first implement a class that implements the that accepts the old and new list:\n\nNext, you would implement a method on your adapter to perform the diff and then invoke to notify the adapter whether the element was inserted, removed, moved, or changed:\n\nFor a working example, see this sample code.\n\nIf we are inserting elements to the front of the list and wish to maintain the position at the top, we can set the scroll position to the 1st element:\n\nIf we are adding items to the end and wish to scroll to the bottom as items are added, we can notify the adapter that an additional element has been added and can call on the RecyclerView:\n\nTo implement fetching more data and appending to the end of the list as the user scrolls towards the bottom, use the from the and add an method leveraging the EndlessScrollViewScrollListener document in the guide.\n\nThe is quite flexible and customizable. Several of the options available are shown below.\n\nWe can also enable optimizations if the items are static and will not change for significantly smoother scrolling:\n\nThe positioning of the items is configured using the layout manager. By default, we can choose between , , and . Linear displays items either vertically or horizontally:\n\nFor example, a staggered grid might look like:\n\nWe can build our own custom layout managers as outlined there.\n\nWe can decorate the items using various decorators attached to the recyclerview such as the DividerItemDecoration:\n\nThis decorator displays dividers between each item within the list as illustrated below:\n\nDecorators can also be used for adding consistent spacing around items displayed in a grid layout or staggered grid. Copy over this SpacesItemDecoration.java decorator into your project and apply to a using the method. Refer to this staggered grid tutorial for a more detailed outline.\n\nRecyclerView supports custom animations for items as they enter, move, or get deleted using ItemAnimator. The default animation effects is defined by DefaultItemAnimator, and the complex implementation (see source code) shows that the logic necessary to ensure that animation effects are performed in a specific sequence (remove, move, and add).\n\nCurrently, the fastest way to implement animations with RecyclerView is to use third-party libraries. The third-party recyclerview-animators library contains a lot of animations that you can use without needing to build your own. Simply edit your :\n\nNext, we can use any of the defined animators to change the behavior of our RecyclerView:\n\nFor example, here's scrolling through a list after customizing the animation:\n\nFor a further look into defining custom item animators, check out this custom RecyclerView item animation post.\n\nThere is also a new interface for the ItemAnimator interface. The old interface has now been deprecated to . This library adds a ItemHolderInfo class, which appears to be similar to the MoveInfo class defined by but used more generically to pass state information between animation transition states. It is likely that the next version of will be simplified to use this new class and revised interface.\n\nSee this guide if you want to inflate multiple types of rows inside a single :\n\nThis is useful for feeds which contain various different types of items within a single list.\n\nRecyclerView allows us to handle touch events with:\n\nIn certain cases, we might want a horizontal that allows the user to scroll through a list of items. As the user scrolls, we might want items to \"snap to center\" as they are revealed. Such as in this example:\n\nTo achieve this snapping to center effect as the user scrolls we can use the built-in LinearSnapHelper as follows:\n\nFor more sophisticated snapping behavior, read more about customizing these helpers and review related sample code here.\n\nFor a more manual approach, we can create a custom extension to called which will snap items to center as the user scrolls:\n• Copy over the code from SnappyRecyclerView.java to your project.\n• Configure your new with a horizontal :\n• Attach your adapter to the to populate the data into the horizontal list as normal.\n• You can access the currently \"snapped\" item position with .\n\nThat's all, you should be set for a snap-to-center horizontal scrolling list!\n\nIf you'd like to perform an action whenever a user clicks on any item in your RecyclerView, you'll need to perform that action within a handler.\n\nBelow are three ways you can attach a handler to listen to clicks on a RecyclerView. Note that this can be used to recognize clicks on items, but not for recognizing clicks on individual buttons or other elements within your items...\n\nThe easiest solution for handling a click on an item in a RecyclerView is to add a decorator class such as this clever decorator and then implement the following code in your Activity or Fragment code:\n\nThis technique was originally outlined in this article. Under the covers, this is wrapping the interface pattern described in detail below.\n\nSo, if you apply this code above, you do not need the Simple Click Handler within ViewHolder described below.\n\nAnother solution for setting up item click handlers within a is to add code to your Adapter instead...\n\nUnlike which has the method, does not have special provisions for attaching click handlers to items. So, to achieve a similar effect manually (instead of using the decorator utility above), we can attach click events within the inside our adapter:\n\nIf we want the item to show a \"selected\" effect when pressed, we can set the of the root layout for the row to :\n\nThis creates the following effect:\n\nIn certain cases, you'd want to setup click handlers for views within the but define the click logic within the containing or (i.e bubble up events from the adapter). To achieve this, create a custom listener within the adapter and then fire the events upwards to an interface implementation defined within the parent:\n\nThen we can attach a click handler to the adapter with:\n\nSee this detailed stackoverflow post which describes how to setup item-level click handlers when using .\n\nThe should be used to refresh the contents of a via a vertical swipe gesture. See our detailed RecyclerView with SwipeRefreshLayout guide for a step-by-step tutorial on implementing pull to refresh.\n\nRecyclerView has an method that can be used to implement custom fling behavior. Download this RecyclerViewSwipeListener and you can handle custom swipe detection by adding this class to your RecyclerView:"
    }
]