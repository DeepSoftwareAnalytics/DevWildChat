[
    {
        "link": "https://learn.microsoft.com/en-us/azure/devops/pipelines/tasks/reference/nuget-command-v2?view=azure-pipelines",
        "document": "- Feeds to use\n\n Input alias: . . Required when . Allowed values: (Feed(s) I select here), (Feeds in my NuGet.config). Default value: .\n\n Specifies a feed from Azure Artifacts and/or NuGet.org for the task to use with the value. Alternatively, you can commit a file to your source code repository and set its path as the value using the value. \n\n\n\nAll tasks have control options in addition to their task inputs. For more information, see Control options and common task properties.\n\nUse this task to install and update NuGet package dependencies, or package and publish NuGet packages. Uses NuGet.exe and works with .NET Framework apps. For .NET Core and .NET Standard apps, use the .NET Core task.\n\nIf your code depends on NuGet packages, make sure to add this step before your Visual Studio Build task. Also make sure to clear the deprecated Restore NuGet Packages checkbox in that task.\n\nIf you are working with .NET Core or .NET Standard, use the .NET Core task, which has full support for all package scenarios and is currently supported by dotnet.\n\nFor byPrereleaseNumber, the version will be set to the values you choose for the major version, the minor version, and the patch, plus the date and time, in the format .\n\nFor byEnvVar, the version will be set to the value of the environment variable that has the name specified by the versionEnvVar parameter, e.g. (no $, just the environment variable name). Make sure the environment variable is set to a proper SemVer, such as or .\n\nFor byBuildNumber, the version will be set using the pipeline run's build number. This is the value specified for the pipeline's property, which gets saved to the environment variable). Ensure that the build number being used contains a proper SemVer, such as . When using byBuildNumber, the task will extract the dotted version, , from the build number string, and use only that portion. The rest of the string will be dropped. If you want to use the build number as is, you can use byEnvVar as described above, and set versionEnvVar to .\n\nand are deprecated, and you should replace them in your pipeline with .\n\nIf you were using with , configure the following inputs when using .\n\nIf you were using with , configure the following inputs when using .\n\nIf you were using , configure the following inputs when using .\n\nSimilar to using or the option, has inputs to set the feed, decide between or , specify the path to the file, and use packages from nuget.org.\n\nFor more information, see the following examples.\n\nStarting with Ubuntu 24.04, Microsft-hosted agents will not ship with mono which is required to run the underlying NuGet client that powers . Users of this task on Ubuntu should migrate to the long term supported cross-platform task with .NET CLI.\n\nThe NuGet Authenticate task will handle injecting credentials into the needed places for client tools to authenticate as your pipeline identity. Please see the linked documentation for instructions, FAQs, and examples for using with dotnet.\n\nIf dotnet CLI commands do not support your scenario, please report this to the .NET CLI team as an issue. You may continue to pin your agent image to Ubuntu 22.04 or earlier. Ubuntu 22.04 support will continue until Ubuntu 26.04 is made generally available, no earlier than 2026.\n\nRestore all your solutions with packages from a selected feed.\n• None Push/Publish a package to a feed defined in your NuGet.config.\n\nRun any other NuGet command besides the default ones: pack, push, and restore."
    },
    {
        "link": "https://learn.microsoft.com/en-us/azure/devops/pipelines/packages/nuget-restore?view=azure-devops",
        "document": "With NuGet Package Restore you can install all your project's dependency without needing to store them in source control. This allows for a cleaner development environment and a smaller repository size. You can restore your NuGet packages using the NuGet restore task, the NuGet CLI, or the .NET Core CLI. This article will guide you through restoring your NuGet packages using both Classic and YAML Pipelines.\n• None Create an Azure DevOps organization and a project if you haven't already.\n• None Create a new feed if you don't have one already.\n• None If you're using a self-hosted agent, make sure that it has the .NET Core SDK (2.1.400+) and NuGet (4.8.0.5385+) installed.\n\nIf you're using Ubuntu 24.04 or higher, you must use the task with the .NET CLI instead of the nuget.exe. See Support for newer Ubuntu hosted images for more details.\n\nRestore NuGet packages from a feed in the same organization\n• None Sign in to your Azure DevOps organization, and then navigate to your project.\n• None Select Pipelines, and then select your pipeline definition.\n• None Select Edit, and then add the following snippet to your YAML pipeline.\n• None Sign in to your Azure DevOps organization, and then navigate to your project.\n• None Select Pipelines, select your pipeline definition, and then select Edit.\n• None Select + to add a new task. Add the NuGet tool installer, NuGet Authenticate, and Command line tasks to your pipeline. Leave the NuGet tool installer and NuGet Authenticate tasks with their default settings and configure the Command line task as follows:\n\nMake sure that The NuGet Gallery upstream is enabled in your feed. See Enable upstream sources in an existing feed for details.\n\nRestore NuGet packages from a feed in another organization\n\nTo restore NuGet packages from a feed in a different Azure DevOps organization, you must first create a personal access token then use it to set up a NuGet service connection.\n• None Navigate to your Azure DevOps organization, and then select User settings > Personal Access Tokens.\n• None Create a new personal access token with Packaging* > Read scope. Copy your PAT as you'll need it in the following section.\n• None Sign in to the Azure DevOps organization where your pipeline will run, and then navigate to your project.\n• None Select New service connection, select NuGet, and then select Next.\n• None Select External Azure DevOps Server as the Authentication method, and then enter your target Feed URL. Paste the Personal Access Token you created earlier, provide a name for your service connection, and check Grant access permission to all pipelines if applicable to your scenario."
    },
    {
        "link": "https://learn.microsoft.com/en-us/nuget/consume-packages/package-restore",
        "document": "NuGet Package Restore restores all of a project's dependencies that are listed in either a project file or a packages.config file. You can restore packages manually with , , , or through Visual Studio. The and commands automatically restore packages, and you can configure Visual Studio to restore packages automatically when it builds a project.\n\nTo promote a cleaner development environment and to reduce repository size, Package Restore makes all of a project's dependencies available without having to store them in source control. To configure your source control repository to exclude package binaries, see Packages and source control.\n\nPackage Restore tries to install all package dependencies to the state that matches the s in a project file, such as .csproj, or s in a packages.config file. Package Restore first installs the direct dependencies of a project as needed, then installs any dependencies of those packages throughout the entire dependency graph.\n\nIf a needed package isn't already installed, NuGet first attempts to retrieve it from the local global packages or HTTP cache folders. If the package isn't in the local folders, NuGet tries to download it from all sources configured in Visual Studio at Tools > Options > NuGet Package Manager > Package Sources.\n\nDuring restore, NuGet ignores the order of package sources, and uses the package from the first source that responds to requests. If restore fails, NuGet doesn't indicate the failure until after it checks all sources. NuGet then reports a failure for only the last source in the list. The error implies that the package wasn't present on any of the sources, even though it doesn't list the other failures individually.\n\nFor more information about NuGet behavior, see Common NuGet configurations.\n\nIf the package references in your project file or packages.config file are correct, use your preferred tool to restore packages:\n• For projects that use , the package is present in the local global-packages folder, and the project obj/project.assets.json file is recreated.\n• For projects that use packages.config, the package appears in the project's packages folder.\n• The project should now build successfully.\n\nIf the package references in your project file or your packages.config file are incorrect and don't match your desired state, install or update the correct packages instead of using Package Restore.\n\nIf you have missing packages or package-related errors after you run Package Restore, such as error icons in Solution Explorer, follow the instructions in Troubleshooting Package Restore errors, or reinstall or update the packages. In Visual Studio, the Package Manager Console provides several options for reinstalling packages. For more information, see Use Package-Update.\n\nIn Visual Studio on Windows, you can restore packages automatically or manually. First, configure Package Restore through Tools > Options > NuGet Package Manager.\n\nConfigure the following Package Restore options at Tools > Options > NuGet Package Manager > General.\n\nSelect Allow NuGet to download missing packages to enable package restore and the Restore NuGet Packages command. This selection sets the setting to in the packageRestore section of the global NuGet.Config file, at %AppData%\\Roaming\\NuGet on Windows or ~/.nuget/NuGet/ on Mac or Linux.\n\nTo enable or disable Package Restore for all users on a computer, you can add the configuration settings to the global NuGet.Config file in Windows at %ProgramData%\\NuGet\\Config, sometimes under a specific <IDE>\\<Version>\\<SKU> Visual Studio folder, or in Mac/Linux at ~/.local/share. Individual users can then selectively enable restore as needed on a project level. For more details on how NuGet prioritizes multiple config files, see Common NuGet configurations.\n\nSelect Automatically check for missing packages during build in Visual Studio to automatically restore any missing packages when you run a build from Visual Studio. This setting doesn't affect builds run from the MSBuild command line. This selection sets the setting to in the section of the NuGet.Config file.\n\nYou must select Allow NuGet to download missing packages as well as Automatically check for missing packages during build in Visual Studio in Options to enable package restore during build.\n\nNuGet has two package management formats, PackageReference and packages.config. Select the format you want to use from the dropdown list under Package Management. You can also select whether to allow format selection on first package install.\n\nAfter you enable package restore in Options, you can right-click the solution in Solution Explorer and select Restore NuGet Packages to restore packages anytime.\n\nIf you enabled automatic restore in Options, Package Restore happens automatically when you create a project from a template or build a project. For NuGet 4.0+, restore also happens automatically when you make changes to a SDK-style project.\n\nFor projects that use , you can see the package references in Visual Studio Solution Explorer under Dependencies > Packages. Packages that don't install properly when you manually restore or run a build display error icons in Solution Explorer. Right-click the project, select Manage NuGet Packages, and use the NuGet Package Manager to uninstall and reinstall the affected packages. For more information, see Reinstall and update packages.\n\nIf you see the error This project references NuGet package(s) that are missing on this computer, or One or more NuGet packages need to be restored but couldn't be because consent has not been granted, make sure you enabled automatic restore. For older projects, see Migrate to automatic package restore. Also see Troubleshooting package restore errors.\n\nRestore by using the dotnet CLI\n\nThe dotnet restore command restores packages that the project file lists with . For more information, see PackageReference in project files.\n\n.NET Core 2.0 and later and commands restore packages automatically. As of NuGet 4.0, runs the same code as .\n• Open a command line and switch to the directory that contains your project file.\n\nRestore by using the NuGet CLI\n\nThe NuGet CLI restore command downloads and installs any missing packages. The command works on projects that use either PackageReference or packages.config for package references.\n\nLike , the command only adds packages to disk, but doesn't modify the project file or packages.config. To add project dependencies, use the Visual Studio Package Manager UI or Console.\n\nTo restore packages, run the following command:\n\nThe command uses a solution file or a package.config file in the specified project path.\n\nFor example, to restore all packages for MySolution.sln in the current directory, run:\n\nYou can use msbuild -t:restore to restore packages in NuGet 4.x+ and MSBuild 15.1+, which are included with Visual Studio 2017 and higher.\n\nThis command restores packages in projects that use PackageReference for package references. Starting with MSBuild 16.5+, the command also supports packages.config package references, when used with .\n• None Open a Developer Command Prompt by searching for developer command prompt and starting the prompt from the Windows Start menu, which configures all the necessary paths for MSBuild.\n• None Switch to the project folder, and enter .\n• None After the restore completes, enter to rebuild the project. Make sure the MSBuild output indicates that the build completed successfully.\n\nWhen you create a build definition in Azure Pipelines, you can include the NuGet CLI restore or dotnet CLI restore task in the definition before any build tasks. Some build templates include the restore task by default.\n\nAzure DevOps Server and TFS 2013 and later automatically restore packages during build, if you use a TFS 2013 or later Team Build template. You can also include a build step to run a command-line restore option, or optionally migrate the build template to a later version. For more information, see Set up package restore with Team Foundation Build.\n\nNuGet restore through any method honors any version constraints you specify in packages.config or the project file.\n• None In packages.config, you can specify an range in the dependency. For more information, see Constraints on upgrade versions. For example:\n• None In a project file, you can specify the version range in the property of the dependency. For example:\n\nIn both cases, use the notation described in Package versioning.\n\nBy default, NuGet restore operations use packages from the local global-packages and http-cache folders, as described in Manage the global packages and cache folders. To avoid using these local packages, use the following options.\n• In Visual Studio, select the Clear All NuGet Cache(s) button at Tools > Options > NuGet Package Manager > General.\n• In the dotnet CLI, use .\n• In the NuGet CLI, use .\n\nTo avoid using the packages in the global-packages folder:\n• Clear the folder by using or .\n• Temporarily set the NUGET_PACKAGES environment variable to a different folder.\n• Create a NuGet.Config file that sets for , or for packages.config, to a different folder. For more information, see configuration settings.\n• For MSBuild only, specify a different folder with the property.\n\nTo avoid using packages in the HTTP cache:\n• Clear the cache by using or .\n• Temporarily set the NUGET_HTTP_CACHE_PATH environment variable to a different folder.\n• For , use the option, or for , use the option. These options don't affect restore operations through the Visual Studio Package Manager or Console.\n\nEarlier versions of NuGet supported an MSBuild-integrated package restore. Projects that use the deprecated MSBuild-integrated package restore should migrate to automatic package restore.\n\nThese projects typically contain a .nuget folder with three files: NuGet.config, nuget.exe, and NuGet.targets. The NuGet.targets file causes NuGet to use the MSBuild-integrated approach, so it must be removed.\n• For each project file, remove the element, and remove any references to NuGet.targets.\n• Remove the packages folder from the solution.\n• Open the solution in Visual Studio and start a build. Automatic package restore should download and install each dependency package, without adding it to source control."
    },
    {
        "link": "https://stackoverflow.com/questions/67892603/azure-devops-build-pipeline-seems-to-restore-nuget-packages-twice",
        "document": "I have a build pipeline, where I have a Nuget restore step using NuGetCommand which works fine.\n\nBut the next step where the build is performed fails on missing nuget packages.\n\nIt seems the build step tries to restore the nuget packages a second time, which does not work (It doesn't have the credentials to do so)\n\nThe yaml file for the build definition is as follows:\n\nI also have a nuGet.config file which looks like this:\n\nI don't understand why the build step needs to restore the nuget packages again.\n\nIs there a way to point the DotNetCoreCli to the already restored packages?\n\nAs suggested by @Ibrahim I added the --no-restore to the DotNetCoreCLI task. I then received the following error message:\n\nC:\\Program Files\\dotnet\\sdk\\5.0.300\\Sdks\\Microsoft.NET.Sdk\\targets\\Microsoft.PackageDependencyResolution.targets(241,5): error NETSDK1047: Assets file 'D:\\a\\1\\s\\ServiceHosts\\TestProject\\obj\\project.assets.json' doesn't have a target for 'netcoreapp3.1/win-x64'. Ensure that restore has run and that you have included 'netcoreapp3.1' in the TargetFrameworks for your project. You may also need to include 'win-x64' in your project's RuntimeIdentifiers.\n\nThis was mitigated by adding a task to the yaml file to install the newest version of nuget using\n\nAnd adding RuntimeIdentifier win-x64 to the csproj files."
    },
    {
        "link": "https://stackoverflow.com/questions/70353371/azure-pipelines-nuget-restore-failing-msb4226",
        "document": "The problem is actually unrelated to NuGet, it's just that NuGet is the first thing in your pipeline that tries to evaluate MSBuild files. If you look carefully at the error:\n\nYou can see that the error is that MSBuild can't find . What does this mean? I'm not 100% confident, but I do have high confidence that this means you're using a \"self hosted\" CI agent, not a Microsoft hosted agent, and whoever set up the machine installed Visual Studio 2019 without installing the ASP.NET workload. Therefore, whoever sets up your CI agents should install the \"ASP.NET and web development\" workload.\n\nIf you look at VS's release and build history, you see for every version, under \"Links to Installer\", there's a \"BuildTools\" link. This is a subset of Visual Studio without all the GUI stuff, meant for CI agents specifically. I don't think the BuildTools SKU has workload options, it just installs all the build tools necessary for all workloads.\n\nOnly in rare circumstances is the \"full\" Visual Studio required on a CI agent, so unless you know you're in that circumstance, I suggest installing the BuildTools on your CI agent instead of Enterprise or Professional.\n\nThere's two reasons. Firstly, is a task that uses NuGet.exe. The problem with NuGet.exe is that when you're using , rather than , is that there are times when NuGet and the build tools (msbuild's props/targets) change file format for the temporary files. If you don't keep the version of NuGet.exe aligned with the version of MSBuild/Visual Studio, you might get build errors. So, it's much better to use , or if you can't use the dotnet cli, then use . This way you're always using the exact version of NuGet that is designed for the version of dotnet/msbuild installed, and you'll never have to think about NuGet-MSBuild version problems again.\n\nSecondly, someone from the Azure DevOps team told my team that they want to deprecate these \"heavy\" tasks, and suggest customers call commands directly in a script task. In particular, the way they implemented these features will break NuGet's new Package Source Mapping feature.\n\nIf your solution contains only SDK style projects, then I suggest you use:\n\nIf your solution contains any \"legacy\" (non-SDK style) projects, then instead of using the dotnet CLI, use .\n\nYou're using the task to run your build. This is a task that uses to build the project. While devenv does have command line parameters to build from the command line, is the \"official\" tool to do command line builds. Again, unless you know you're in a special circumstance that really needs to be built via , I suggest you use the CLI or instead. As previously mentioned, the Azure DevOps team apparently want to deprecate the \"heavy\" tasks, so I suggest you use a script and call or directly."
    },
    {
        "link": "https://learn.microsoft.com/en-us/azure/devops/pipelines/tasks/reference?view=azure-pipelines",
        "document": "A task performs an action in a pipeline. For example, a task can build an app, interact with Azure resources, install a tool, or run a test. Tasks are the building blocks for defining automation in a pipeline.\n\nThe articles in this section describe the built-in tasks for Azure Pipelines and specify the semantics for attributes that hold special meaning for each task.\n\nPlease refer to the YAML Reference for steps.task for details on the general attributes supported by tasks.\n\nFor how-tos and tutorials about authoring pipelines using tasks, including creating custom tasks, custom extensions, and finding tasks on the Visual Studio Marketplace, see Tasks concepts and Azure Pipelines documentation.\n\nThese tasks are open source on GitHub. Feedback and contributions are welcome. See Pipeline task changelog for a list of task changes, including a historical record of task updates.\n\nInputs to a task are identified by a , , and may include one or more optional . The following example is an excerpt from the source code for the Known Hosts Entry input of the InstallSSHKey@0 task.\n\nBefore YAML pipelines were introduced in 2019, pipelines were created and edited using a UI based pipeline editor, and only the was used by pipeline authors to reference a task input.\n\nWhen YAML pipelines were introduced in 2019, pipeline authors using YAML started using the task input to refer to a task input. In some cases, the task input names weren't descriptive, so were added to provide additional descriptive names for task inputs.\n\nFor example, the task has a Known Hosts Entry input named that expects an entry from a known_hosts file. The Known Hosts Entry label in the classic pipeline designer makes this clear, but it isn't as clear when using the name in a YAML pipeline. Task input aliases were introduced to allow task authors to provide decriptive names for their previously authored tasks, and for the task, a alias was added, while keeping the original name for compatibility with existing pipelines using that name.\n\nAny items in a task input's are interchangeable with the in a YAML pipeline. The following two YAML snippets are functionally identical, with the first example using the alias and the second example using .\n\nStarting with Azure DevOps Server 2019.1, the YAML pipeline editor was introduced, which provides an intellisense type functionality.\n\nThe YAML pipeline editor uses the Yamlschema - Get REST API to retrieve the schema used for validation in the editor. If a task input has an alias, the schema promotes the alias to the primary YAML name for the task input, and the alias is suggested by the intellisense.\n\nThe following example is the Known Hosts Entry task input for the task from the YAML schema, with listed in the name position and in the collection.\n\nBecause the intellisense in the YAML pipeline editor displays , and the YAML generated by the task assistant uses in the generated YAML, the task reference displays the from the task source code as the YAML name for a task input. If a task has more than one alias (there are a few that have two aliases), the first alias is used as the name.\n\nWhy did the task reference change?\n\nThe Azure Pipelines tasks reference documentation moved to its current location to support the following improvements.\n• Task articles are generated using the task source code from the Azure Pipelines tasks open source repository.\n• Task input names and aliases are generated from the task source so they are always up to date.\n• YAML syntax blocks are generated from the task source so they are up to date.\n• Supports community contributions with integrated user content such as enhanced task input descriptions, remarks and examples.\n• Provides task coverage for all supported Azure DevOps versions.\n• Updated every sprint to cover the latest updates.\n\nTo contribute, see Contributing to the tasks content.\n\nWhere can I learn step-by-step how to build my app?\n\nCan I add my own build tasks?\n\nTo learn more about tool installer tasks, see Tool installers."
    },
    {
        "link": "https://stackoverflow.com/questions/69389278/copy-files-from-one-project-to-another-using-yaml",
        "document": "Copying an existing pipeline and using it as a starting point is one method for developing a pipeline. The procedure is as simple as copying the YAML from one pipeline to another for YAML pipelines. The process varies depending on whether the pipeline to clone is in the same project as the new pipeline for pipelines produced with the old editor.\n\nYou can clone a pipeline if it is in the same project, or you can export it from a different project and import it into your project if it is in a different project.\n\nWhen cloning a YAML pipeline, the YAML from the source pipeline is copied and used as the foundation for the new pipeline.\n• None Click on edit of your pipeline.\n• None The YAML for your new pipeline should have the pipeline YAML copied from the editor and pasted there.\n• None To modify the pipeline you recently cloned, see Customize your pipeline.\n\nBy exporting an existing pipeline and importing it again, you can construct a new traditional pipeline. This is helpful when a new pipeline needs to be built as part of a different project.\n\nExporting from one project and importing it into another is the same as cloning in a YAML pipeline. To use the pipeline YAML in your new pipeline, simply copy it from the editor and paste it there and for this, follow the above 3 points:"
    },
    {
        "link": "https://learn.microsoft.com/en-us/azure/devops/pipelines/tasks/reference/copy-files-v2?view=azure-pipelines",
        "document": "Optional. The folder that contains the files you want to copy. If the folder is empty, then the task copies files from the root folder of the repo as though was specified. If your build produces artifacts outside of the sources directory, specify to copy files from the directory created for the pipeline. \n\n\n\nThe file paths to include as part of the copy. This string supports multiple lines of match patterns.\n• copies all files in the specified source folder.\n• copies all files in the specified source folder and all files in all sub-folders.\n• copies all files recursively from any bin folder. The pattern is used to match only file paths, not folder paths. Specify patterns, such as instead of . Use the path separator that matches your build agent type. For example, must be used for Linux agents. More examples are shown below. \n\n\n\n- Ignore errors during creation of target folder.\n\n . Default value: .\n\n Ignores errors that occur during the creation of the target folder. This string is useful for avoiding issues with the parallel execution of tasks by several agents within one target folder. \n\n\n\nAll tasks have control options in addition to their task inputs. For more information, see Control options and common task properties.\n\nIf no files match, the task will still report success.\n• If is and a matched file already exists in the target folder, the task will not report failure but log that the file already exists and skip it.\n• If is and a matched file already exists in the target folder, the matched file will be overwritten.\n\nYou want to copy just the readme and the files needed to run this C# console app:\n\nOn the Variables tab, is set to .\n\nThese files are copied to the staging directory:\n\nCopy everything from the source directory except the .git folder\n• How do I use this task to publish artifacts\n• Learn how to use verbose logs for troubleshooting."
    },
    {
        "link": "https://stackoverflow.com/questions/55694545/how-to-share-files-between-yaml-stages-in-azure-devops",
        "document": "In general - creating artifacts is typically done by Build Pipeline while deploying artifacts is done in a Release Pipeline. There is definitely the opportunity to perform both actions in a single build pipeline depending on your usage. Combining especially makes sense when you are just getting started with Azure Pipelines as the ecosystem can be overwhelming with the amount of capabilities available. There is publicized work on merging the release capabilities into the build capabilities to simplify onboarding.\n\nSeparating the pipelines does give you the benefit of retrying deploy if the deployment failed the first time - it really depends how quick your build time is. Also supporting deployment of the same bits across environments is easier if you want to manually trigger environment or ringed release propagation. The list for separating build/deploy grows exponentially once you dig into some of the power-user features of release stages.\n\nFor your approach to work - you could leverage the YAML element to link the subsequent jobs to have an output dependency.\n\nDevops recently released download task to consume files across CI/CD boundaries. Pipeline Artifacts can also be used to share files across stages now."
    },
    {
        "link": "https://marcusfelling.com/blog/2017/vsts-yaml-builds",
        "document": "Last week Microsoft announced “Pipeline as code (YAML)” giving us the ability to store our builds in source control. This allows us to take advantage of Configuration as Code as well as other benefits not available through the Visual Designer builds:\n• The YAML files follow the same branching structure as your code. This gives us multiple versions of the build, preventing breaking changes to the build process.\n• Validate changes through code reviews in pull requests and branch build policies.\n• If the build breaks, changes can be easily identified in version control.\n• Working with code is preferable to using the Web interface.\n\nI’ll let you read the getting started guide which walks you through the basics. In this post I wanted to go through the process I used to convert some of my builds and some gotchas I found on the way.\n\nWhere is the export button?\n\nEdit: This is no longer necessary. You can now click “View YAML”.\n\nUnfortunately Microsoft hasn’t created an easy way to export an existing build definition. This means we’ll need to use the API to get the JSON from a build definition, convert it to YAML, tweak the syntax, and update the tasks that are referenced.\n• Use the API to get a definition:\n• Copy/paste the JSON into a JSON to YAML converter. Example: https://www.json2yaml.com/\n• Use the guide to tweak the syntax.\n• Replace the refName key values with task names and version. Built in tasks can be found here (look in task.json file) https://github.com/Microsoft/vsts-tasks/tree/master/Tasks All the tasks in your account can be found here:\n• Replace all tabs with spaces in case you accidentally added them (YAML syntax).\n\nThe YAML builds provide the ability to separate steps by phases. The phases can be run in parallel and even fanned in and out across agents.\n\nTake advantage of this anywhere that steps can run in parallel. Keep in mind that when you fan out across agents, each phase will have it’s own working, staging, and artifact directories.\n\n– Task Groups cannot be referenced as tasks. Same process above can be used to convert these using the API.\n\n – When adding service endpoints you will need to re-save the build definition in order to authenticate.\n\nHere is an example YAML file I created that has 5 phases. The first 4 fan out and run in parallel and the last phase waits for all of them to complete before beginning. I removed endpoints and all company specific data."
    }
]