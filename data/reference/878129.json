[
    {
        "link": "https://forum.multitheftauto.com/topic/49388-ai",
        "document": "I ask only the experienced ones here:\n\nCould there be a way to make an AI with this LUA library?\n\nit says it's grid based, but only for 2D games\n\nAnd why can't we use the single-player AI? I know there is reason, but what exactly?\n\nWill there ever be a way to use the original functionalities? And not just AI, mini-games, missions etc. also."
    },
    {
        "link": "https://yeschat.ai/gpts-9t563ROgzNQ-MTA-Helper",
        "document": "MTA Helper is a specialized AI designed to provide comprehensive assistance and support for all aspects of Multi Theft Auto (MTA). Its primary functions are tailored towards assisting users with scripting, server configuration, Lua code optimization, simulated code testing, server management, marketing and branding strategies for MTA servers, database management, and DX (Design Experience) design. MTA Helper is equipped with extensive knowledge of MTA mechanics, Lua scripting language, server administration, and community best practices. Its design purpose is to serve as a versatile and knowledgeable resource for MTA enthusiasts, developers, server owners, and administrators. Powered by ChatGPT-4o。\n• None Assisting users in writing efficient and functional scripts for MTA servers. For instance, helping users create custom game modes, vehicle spawns, NPC behavior, or server-side mods. A server owner wants to develop a new game mode for their MTA server. MTA Helper guides them through the process of scripting game mechanics, handling player interactions, and optimizing performance.\n• None Providing guidance on configuring server settings, plugins, and resource management for optimal server performance and stability. A server administrator needs to optimize their MTA server for high player capacity and low latency. MTA Helper advises on configuring server properties, adjusting resource usage, and installing performance-enhancing plugins.\n• None Offering expertise in Lua programming language, including understanding functions, events, and best coding practices for MTA scripting. A script developer encounters an error in their Lua script for MTA. MTA Helper helps identify and resolve syntax errors, logic bugs, or performance bottlenecks, ensuring the script functions correctly.\n• None Facilitating simulated testing environments for scripts and server configurations, allowing users to debug and refine their code before deploying it to live servers. A script developer wants to test their new features in a controlled environment without affecting the live server. MTA Helper assists in setting up a local testing environment and provides tools for debugging and monitoring script behavior.\n• None Offering tools and advice for effective server administration, including player management, moderation, anti-cheat measures, and troubleshooting server issues. A server owner needs to enforce rules and maintain order on their MTA server. MTA Helper recommends moderation plugins, anti-cheat scripts, and provides guidance on handling player reports and server maintenance tasks.\n• None Assisting server owners in promoting their MTA servers, attracting new players, and establishing a unique brand identity within the MTA community. A server owner wants to increase player engagement and attract more users to their MTA server. MTA Helper advises on social media marketing, server branding, and community engagement strategies to enhance server visibility and appeal.\n• None Providing guidance on setting up and managing databases for storing player data, server logs, and other essential information related to MTA servers. A server administrator wants to implement a database system for their MTA server to store player statistics and progress. MTA Helper assists in selecting a suitable database solution, setting up database tables, and integrating database functionality into server scripts.\n• None Offering support for creating visually appealing user interfaces (UI) and custom graphical elements using the MTA's DirectX (DX) interface library. A server developer wants to design a sleek and user-friendly UI for their MTA server's menu system. MTA Helper provides guidance on using DX functions, designing UI layouts, and integrating custom graphics to enhance the user experience.\n• None MTA enthusiasts and developers who are passionate about customizing and enhancing their MTA gaming experience. They benefit from MTA Helper's expertise in scripting, server management, and Lua programming, enabling them to create unique game modes, mods, and server features.\n• None MTA server owners and administrators who operate gaming communities or host multiplayer servers. They rely on MTA Helper for assistance in configuring server settings, managing player interactions, implementing anti-cheat measures, and promoting their servers to attract and retain players.\n• None Community managers and moderators responsible for maintaining order, enforcing rules, and fostering a positive community atmosphere within MTA servers. They utilize MTA Helper's tools and advice for effective server moderation, player management, and community engagement.\n• None Visit yeschat.ai for a free trial without login, also no need for ChatGPT Plus. YesChat.ai offers a hassle-free trial of MTA Helper without requiring a login or ChatGPT Plus subscription.\n• None Enter your query or question related to Multi Theft Auto (MTA). Type your MTA-related query or question into the chat interface on YesChat.ai to initiate assistance from MTA Helper.\n• None MTA Helper will provide comprehensive and accurate information tailored to your query, ensuring a thorough understanding of the topic.\n• None Engage in a conversation with MTA Helper to delve deeper into specific aspects of MTA or explore related subjects for a more holistic understanding.\n• None Take advantage of supplementary tools, such as script creation assistance, Lua code support, server management guidance, and more, to enhance your MTA experience.\n• None What is MTA Helper and how does it work? MTA Helper is an AI-powered tool designed to assist users with various aspects of Multi Theft Auto (MTA). It works by analyzing user queries and providing detailed, relevant information on MTA scripting, server management, Lua code assistance, and more.\n• None Can MTA Helper help me with Lua scripting? Yes, MTA Helper offers support for Lua scripting in MTA. Whether you're a beginner seeking guidance on basic syntax or an experienced developer looking for advanced scripting techniques, MTA Helper can assist you with Lua code-related queries.\n• None MTA Helper can provide recommendations and best practices to optimize server performance in Multi Theft Auto. This includes advice on resource management, server configuration, performance tuning, and troubleshooting common server issues.\n• None Yes, MTA Helper can provide insights and strategies for marketing and branding MTA servers effectively. This includes tips on community engagement, server promotion, social media marketing, and attracting players to your server.\n• None Absolutely, MTA Helper can offer assistance with database management tasks related to Multi Theft Auto servers. Whether you need help setting up databases, optimizing database performance, or troubleshooting database issues, MTA Helper has you covered."
    },
    {
        "link": "https://github.com/gta191977649/MTASA-Traffic-NPC/blob/master/npchlc_traffic/generate.lua",
        "document": ""
    },
    {
        "link": "https://docsbot.ai/prompts/programming/mta-traffic-script",
        "document": ""
    },
    {
        "link": "https://wiki.multitheftauto.com/wiki/Scripting_Introduction",
        "document": "Resources are a key part of MTA. A resource is essentially a folder or zip file that contains a collection of files, plus a \"meta\" file that describes to the server how the resource should be loaded and what files it does contain. A resource can be seen as being partly equivalent to a program running in an operating system - it can be started and stopped, and multiple resources can run at once.\n\nEverything that has to do with scripting happens in resources, what a resource does defines if it is a gamemode, a map, or anything else. MTA comes with resources that you can optionally use in your gamemodes, such as map limits to keep playings within a playing area or death-pickups to create weapon pickups.\n\nWe will first learn how to make a basic script that lets the player walk around in the city, step by step.\n\nWhere are all the scripts?\n\nLet's take a look at the script's file structure. Go to your MTA Server folder, and follow the path below:\n\nYou will see a lot of .zip files, which are the packaged sample scripts shipped with MTA. Each file is a \"resource\", and they will all be unzipped and loaded by the server when it starts. To create your own resource, simply make a folder with your preferred name. We'll use \"myserver\" for this tutorial.\n\nNow you should be under this directory:\n\nIn order to let the server know what's in the resource, a meta.xml file must be created to list the resource's content. It must be located in the resource's root directory, which is the \"myserver\" folder in our case. So create a text file and name it \"meta.xml\", and open it with notepad.\n\nEnter the following codes in the meta.xml file:\n\nIn the <info /> tag, there's a \"type\" field which indicates that the resource is a gamemode instead of a regular include or a map, which will be explained later. A gamemode is what you need to make a stand-alone server.\n\nThe <script /> tag indicates the script files contained in the resource, which we will create next.\n\nNote that in the <script /> tag above, the .lua file is not under another directory. Therefore we'll create the file in the same folder as meta.xml. Now you can copy and paste the following code into script.lua:\n\nThe script will spawn you at the coordinate (x, y, z) specified above when you join the game. Note that the fadeCamera function must be used or the screen will be black. Also, in releases after DP2, you need to set the camera target (otherwise all the players will see is the blue sky).\n\nThe source variable indicates who triggered the event. Since a player has joined when the code is triggered, you use this variable to look which has joined. So it'll spawn that player instead of everyone or a random person.\n\nIf we have a closer look on addEventHandler, you can see 3 things: 'onPlayerJoin', which indicates when it's triggered. getRootElement(), which shows by what/who it can be triggered. (getRootElement() is everything/everyone) And joinHandler, which indicates the function that has to be triggered after the event is triggered. Other details will be explained later in another example, now let's just run the server and try it out!\n\nTo get the server started, simply run the executable under the server/ directory. A list of server stats will be shown first; note the port number, which you'll need when joining the game. Then the server loads all the resources under the mods/deathmatch/resources/ directory, and then \"ready to accept connections!\"\n\nBefore you connect to the server, you must run the gamemode. Type \"start myserver\" and press Enter. The server will start the gamemode you just created, and will also show any errors and warnings from this point on. Now you can start the MTA client, and \"Quick Connect\" using the IP address of your server and the port number you saw earlier. If all goes well, after a few seconds your character will be walking on the streets of Los Santos.\n\nNext, we'll add a command to your script that players can use to spawn a vehicle beside their position. You may skip it and check out more advanced scripting with the Map Manager, which continues this tutorial. Another branch from this tutorial is Introduction to Scripting GUI, you may follow it to see how the Graphical User Interface in MTA is drawn and scripted.\n\nLet's go back to the content of the script.lua file. As mentioned above, we want to provide a command to create a vehicle beside your current position in the game. Firstly we need to create a function we want to call and a command handler that creates the command the player will be able to enter in the console.\n\nNote: Function names are clickable in code examples on the wiki and linked to the functions' documentation.\n\nThe first argument of addCommandHandler is the name of the command the player will be able to enter, the second argument is the function this will call, in this case createVehicleForPlayer.\n\nIf you have already experienced in scripting, you will know that you call a function like this:\n\nIf we have a closer look on the lower example above, we can see argument1 is thePlayer and argument2 the commandName. thePlayer is simply the one who typed the command, so whatever you call it, the variable will contain the player who activated the command. commandName is simply the command they typed. So if they typed \"/greet\", this argument will contain \"greet\". Argument 3 is something extra the player typed, you'll learn it a little bit further in the tutorial. Never forget that the first 2 arguments are standard arguments, but you can name them to anything you want.\n\nWe called the addCommandHandler function this way already and since createVehicleForPlayer is a function too, it can be called that way as well. But we are using a command handler for that, which calls it in a similar manner, internally.\n\nFor example someone types \"createvehicle 468\" in-game in the console to spawn a Sanchez, the command handler calls the createVehicleForPlayer function, as if we would have this line of code in the script:\n\nAs we can see, it provides several parameters: the player who called the command, the command he entered, and whatever text he had after that, in this case, \"468\" as vehicle id for the Sanchez. The first two parameters are the same with all command handlers, which you can read on the addEventHandler page. For this fact, you always have to define at least those two parameters to use any after that (for example to process text that was entered after the command, like in our example the vehicle model id).\n\nNote: You have to add the command handler AFTER you defined the handler function, else it can't find it. The order of execution matters.\n\nIn order to fill the function we created, we need to think about what we have to do:\n• Get the players position, so we know where to spawn the vehicle (we want it to appear right beside the player)\n• Calculate the position we want to spawn the vehicle at (we don't want it to appear in the player)\n• Check if it has been spawned successfully, or output a message\n\nIn order to achieve our goals, we have to use several functions. To find the function we need to use, we should visit the Server Functions List. First, we need a function to get the player's position. Since players are Elements, we first jump to the Element functions where we find the getElementPosition function. By clicking on the function name in the list, you get to the function description. There we can see the syntax, what it returns, and usually an example. The syntax shows us what arguments we can or have to submit.\n\nFor getElementPosition, the syntax is:\n\nThe three float in front of the function name is the return type. In this case, it means the function returns three floating-point numbers. (x, y, and z) Within the parentheses, you can see what arguments you have to submit. In this case, only the element whose position you want to get, which is the player in our example.\n\nNext, we want to ensure that the vehicle won't spawn directly in the player, so we add a few units to the x variable, which will make it spawn east from the player.\n\nNow we need another function, one to spawn a vehicle. We once again search for it on the Server Functions List, this time - since we are talking about vehicles - in the Vehicle functions section, where we will choose createVehicle. In this function's syntax, we only have one return type (which is more common), a vehicle element that points to the vehicle we just created. Also, we see that some arguments are enclosed within [ ] which means that those are optional.\n\nWe already have all arguments we need for createVehicle in our function: The position we just calculated in the x,y,z variables and the model id that we provided through the command (\"createvehicle 468\") and can access in the function as vehicleModel variable.\n\nOf course, this code can be improved in many ways, but at least we want to add a check whether the vehicle was created successfully or not. As we can read on the createVehicle page under Returns, the function returns false when it was unable to create the vehicle. Thus, we check the value of the createVehicle variable.\n\nNow we have our complete script:\n\nAs you can see, we introduced another function with outputChatBox. By now, you should be able to explore the function's documentation page yourself. For more advanced scripting, please check out the Map Manager.\n\nWhat you need to know\n\nYou already read some things about resources, command handlers, and finding functions in the documentation in the first paragraph, but there is much more to learn. This section will give you a rather short overview over some of these things while linking to related pages if possible.\n\nYou may have already noticed these or similar terms (Server/Client) somewhere on this wiki, mostly in conjunction with functions. MTA not only supports scripts that run on the server and provide commands (like the one we wrote above) or other features but also scripts that run on the MTA client the players use to connect to the server. The reason for this is, that some features MTA provides have to be clientside (like a GUI - Graphical User Interface), others should be because they work better and still, others are better off to be serverside or just don't work clientside.\n\nMost scripts you will make (gamemodes, maps) will probably be serverside, like the one we wrote in the first section. If you run into something that can't be solved serverside, you will probably have to make it clientside. For a clientside script, for example, you would create an ordinary script file (for example called client.lua) and specify it in the meta.xml, like this:\n\nThe type attribute defaults to 'server', so you only need to specify it for client-side scripts. When you do this, the clientside script will be downloaded to the player's computer once he connects to the server. Read more about Client side scripts.\n\nThe previous section showed briefly how to add clientside scripts to the resource, but there is also much more possible. As mentioned at the very top of this page, resources can be pretty much everything. Their purpose is defined by what they do. Let's have some theoretical resources, by looking at the files it contains, the meta.xml and what they might do:\n• The commands.lua provides some admin commands, like banning a player, muting or something else that can be used to admin the server\n• The client.lua provides a GUI to be able to perform the mentioned actions easily\n\nThis example might be running all the time (maybe even auto-started when the server starts) as it's useful during the whole gaming experience and also won't interfere with the gameplay, unless an admin decides to take some action of course.\n• The counterstrike.lua contains similar to the following features:\n• Let players choose their team and spawn them\n• Provide them with weapons, targets, and instructions (maybe read from a Map, see below)\n• Define the game's rules, e.g. when does the round end, what happens when a player dies\n• .. and maybe some more\n• The buymenu.lua is a clientside script and creates a menu to buy weapons\n\nThis example can be called a gamemode, since it not only interferes with the gameplay but actually defines the rules of it. The type attribute indicates that this example works with the Map manager, yet another resource that was written by the QA Team to manage gamemodes and map loading. It is highly recommended that you base your gamemodes on the techniques it provides.\n\nThis also means that the gamemode probably won't run without a map. Gamemodes should always be as generic as possible. An example of a map is stated in the next example.\n• The airport.map in an XML file that provides information about the map to the gamemode, these may include:\n• Where the players should spawn, with what weapons, what teams there are\n• What the targets are\n• The airport.lua might contain map-specific features, that may include:\n• Opening some door/make something explode when something specific happens\n• Create or move some custom objects, or manipulate objects that are created through the .map file\n• .. anything else map-specific you can think of\n\nAs you can see, the type attribute changed to 'map', telling the Map manager that this resource is a map, while the gamemodes attribute tells it for which gamemodes this map is valid, in this case, the gamemode from the above example. What may come as a surprise is that there is also a script in the Map resource. Of course, this is not necessarily needed in a map but opens a wide range of possibilities for map makers to create their own world within the rules of the gamemode they create it for.\n\nThe airport.map file might look similiar to this:\n\nWhen a gamemode is started with a map, the map resources are automatically started by the map-manager and the information it contains can be read by the gamemode resource. When the map changes, the current map resource is stopped and the next map resource is started. For a more in-depth explanation and examples of how map resources are utilized in the main script, please visit the Writing Gamemodes page.\n\nEvents are the way MTA tells scripts about things that happen. For example, when a player dies, the onPlayerWasted event is triggered. In order to perform any actions when a player dies, you have to prepare yourself similar to adding a command handler, as shown in the first chapter.\n\nThis example will output a message with the name of the player who died:\n\nInstead of showing what arguments are needed, the documentation page for Events shows what parameters are passed to the handler function, similar to the way a command handler does, just that it is different from event to event. Another important point is the source variable, that exists in handler functions. It doesn't have to be added to the parameter list of the function, but it still exists. It has a different value from event to event, for player events (as in the example above) it is the player element. As another example, you can take a look at the basic spawning player script in the first section to get an idea of how source is used.\n\nWhere to go from here\n\nYou should now be familiar with the most basic aspects of MTA scripting and also a bit with the documentation. The Main Page provides you with links to more information, Tutorials, and References that allow a deeper look into the topics you desire to learn about."
    },
    {
        "link": "https://forum.multitheftauto.com/topic/27029-hardcore-lua-tutorials",
        "document": "Since I've learned almost everything about \"general\" coding, and LUA is still my favorite and most used language, I would like to know the utmost from LUA.\n\nI recently found out myself what unpack() does, but I want to know much more in less time. I only know this function now since I had no other efficient way to achieve what I wanted.\n\nI hope someone knows some great references for me, about every native LUA function with explanation, and how to get the best speed of my code. Tnx in advance"
    },
    {
        "link": "https://forum.multitheftauto.com/topic/86710-tut-lua-tips-tricks",
        "document": "Hello guys, I am creating this thread so that members of the community can share useful tips and tricks they have learned during their time of scripting. I don't know if it's already created before or not but i think it's something useful to help beginners to learn Lua language plus i think Tutorials board is the best place.\n\nto begin with, here a few tricks I have picked up:\n\nYou can do this:\n\nBut it's faster if you do it like this:\n\nWhen assigning a variable you don't want to be nil you could do this:\n\nBut it can be done a lot faster:\n\nYou can just use this:\n\nThere are a lot more cool things you can do with lua, if you have something you wish to share feel free to post below."
    },
    {
        "link": "https://socccd.edu/sites/default/files/2022-12/Board%20Agenda%2009%2024%202007.pdf",
        "document": ""
    },
    {
        "link": "https://wmata.com/about/records/public_docs/upload/Approved_FY2011_Annual_Budget.pdf",
        "document": ""
    },
    {
        "link": "https://default.sfplanning.org/plans-and-programs/planning-for-the-city/health-care-services-master-plan/HCSMP_2019_final_plan.pdf",
        "document": ""
    },
    {
        "link": "https://wiki.multitheftauto.com/wiki/SetElementData",
        "document": "This function stores element data under a certain key, attached to an element. Element data set using this is then synced with all clients and the server. The data can contain server-created elements, but you should avoid passing data that is not able to be synced such as xmlnodes, acls, aclgroups etc.\n\nAs element data is synced to all clients, it can generate a lot of network traffic and be heavy on performance. Events are much more efficient for sending data from a client to the server only, or from the server to a specific client. \n\n Usage of element data should be discouraged where your goal can be achieved with events like above, and tables for storing and retrieving data.\n\nA subscription mode has been introduced for setElementData serverside. When setting data in subscription mode, only clients that are added through addElementDataSubscriber will receive the data, which is good for performance. Note this mode only works when setting element data serverside. Setting data clientside still sends the update to all clients if 'synchronize' is set to true.\n• theElement: The element you wish to attach the data to.\n• key: The key you wish to store the data under. (Maximum 128 characters.)\n• value: The value you wish to store. See element data for a list of acceptable datatypes.\n• synchronize: Determines whether or not the data will be synchronized with the clients (server-side variation) or server (client-side variation)\n\nReturns true if the data was set successfully, false otherwise.\n\nThis example allows a player to add a custom tag onto their nickname, and also reverts it back to normal if they wish. function addPlayerCustomTag ( thePlayer, command, newTag ) --Let's make sure the newTag param has been entered... if ( newTag ) then --Grab their current playername for saving. local sPlayerNickname = getPlayerName ( thePlayer ) --Create their new nickname with their tag local sNewPlayerNickname = newTag .. \" \" .. sPlayerNickname --Let's first load the element data, see if it's there already --The reason for this is that if a player were to do /addtag twice, --the tag would be prepended a second time local sOldNick = getElementData( thePlayer, \"tempdata.originalnick\" ) if ( sOldNick == false ) then --Save their orignal nickname in their element data setElementData ( thePlayer, \"tempdata.originalnick\", sPlayerNickname ) end --Set their new nickname globally setPlayerName ( thePlayer, sNewPlayerNickname ) --Tell them it's done outputChatBox ( \"Your new nickname has been set, to put it back to its original state you can use /deltag\", thePlayer ) else --The newTag param was not entered, give an error message outputChatBox ( \"/addtag - Incorrect syntax, Correct: /addtag <newtag>\", thePlayer ) end end addCommandHandler ( \"addtag\", addPlayerCustomTag ) function removePlayerCustomTag ( thePlayer, command ) --We first need to check that they have already used /addtag, let's do that now local sOldNick = getElementData( thePlayer, \"tempdata.originalnick\" ) if ( sOldNick ) then --Great, they have a tag added, let's reset them --First we will want to reset the element data back to its default (that being false) setElementData ( thePlayer, \"tempdata.originalnick\", false ) --Now set the client name back setPlayerName( thePlayer, sOldNick ) --Notify them outputChatBox ( \"Your old nickname has been set\", thePlayer ) end end addCommandHandler ( \"deltag\", removePlayerCustomTag )"
    },
    {
        "link": "https://forum.multitheftauto.com/topic/62833-setelementdata-and-getelementdata-problem",
        "document": "I've tried(my first try) to setElementData for new players and regular players(who at least joined once) i don't know how to do this exactly. how would i check if serial of player has got element data ,etc.. its confusing me. i have 2 kind of codes(same script file), both return errors. function setPlayerState(thePlayer) local elementdata = getElementData(thePlayer) if (elementdata == \"data.joindataold\") then return else setElementData(thePlayer, \"data.joindatanew\") end end addEventHandler(\"onPlayerJoin\",root,setPlayerState) function checkPlayerState(thePlayer) local check = getPlayerSerial(player) local playername = getPlayerName(thePlayer) if getElementData(thePlayer, \"data.joindataold\") then outputChatBox(playername.. \"has joined the game [Regular Player]\",0,190,90) elseif getElementData(thePlayer, \"data.joindatanew\") then outputChatBox(playername.. \"has joined the game [New Player]\",0,190,90) end end addEventHandler(\"onPlayerJoin\",root,checkPlayerState) function savePlayerData(thePlayer) setElementData(thePlayer,check) end addEventHandler(\"onPlayerJoin\",root,savePlayerData) function setPlayerState() local elementdata = getElementData(source) if (elementdata == \"data.joindataold\") then return else setElementData(source, \"data.joindatanew\") end end addEventHandler(\"onPlayerJoin\",root,setPlayerState) function checkPlayerState() local check = getPlayerSerial(source) local playername = getPlayerName(source) if getElementData(source, \"data.joindataold\") then outputChatBox(playername.. \"has joined the game [Regular Player]\",0,190,90) elseif getElementData(source, \"data.joindatanew\") then outputChatBox(playername.. \"has joined the game [New Player]\",0,190,90) end end addEventHandler(\"onPlayerJoin\",root,checkPlayerState) function savePlayerData() setElementData(source,check) end addEventHandler(\"onPlayerJoin\",root,savePlayerData) [15:37:07] WARNING: customjq\\script.lua:2: Bad argument @ 'getElementData' [Expected string at argument 2, got nil] [15:37:07] WARNING: customjq\\script.lua:6: Bad argument @ 'setElementData' [Expected argument at argument 3, got none] please help me, i dont understand how to fix/make this as im new to this\n\nokay so,now my code is like this. function setPlayerState() local elementdata = getElementData(source,\"data.joindataold\") if (elementdata) then return else setElementData(source, \"data.joindatanew\", \"player.newplayer\") end end addEventHandler(\"onPlayerJoin\",root,setPlayerState) function checkPlayerState() local check = getPlayerSerial(source) local playername = getPlayerName(source) if getElementData(source, \"data.joindataold\") then outputChatBox(playername.. \"has joined the game [Regular Player]\",0,190,90) elseif getElementData(source, \"data.joindatanew\") then outputChatBox(playername.. \"has joined the game [New Player]\",source,0,190,90) end end addEventHandler(\"onPlayerJoin\",root,checkPlayerState) function savePlayerData() setElementData(source,\"player.serial\",check) end addEventHandler(\"onPlayerJoin\",root,savePlayerData) it always considers me as new player,and the funny thing is that 1st outputChatBox is same as 2nd one,only text is different but it gave an error that it got '0' as 2nd argument. i just dont know what the fuck is this i had to put 'source' in that 2nd outputChatBox and now nobody else can see when new player joins the game as it outputs the message only to the source(new joined player) please help me,this is confusing me too much edit: in order to fix this new player and regular player thing i've added few lines of code so now i got a problem with this error,and outputchatbox(2nd one)\n\nAlright, first things first. When using outputChatBox, the second argument tells you who the chat is visible to. If you want the chat to be visible to everyone, you need to use getRootElement() as argument. Look at serverside example #2 here: You've also got three functions that are all triggered when a player joins. If you are not using these functions for anything else you can merge them into one function. I think you will achieve the same thing when you use just one key. function setPlayerState() local playername = getPlayerName(source) if (getElementData(source, \"regularPlayer\")) then -- if this is not defined it will return false outputChatBox(playername.. \"has joined the game [Regular Player]\",getRootElement(),0,190,90) else setElementData(source,\"regularPlayer\",true) -- now the data corresponding to key 'regularPlayer' is defined and will return true the next time this player logs in outputChatBox(playername.. \"has joined the game [New Player]\",getRootElement(),0,190,90) end end addEventHandler(\"onPlayerJoin\",root,setPlayerState) Didn't test this, but this should achieve a similar goal\n\nAlso take note that Guest Accounts are also destroyed upon the player leaving the server. You'd be better off to check if the player is a guest, if true, save their Serial to either a XML or text file. You can also use SQL, which might be the preferred way by most. Read through said file every time a guest joins. There are of course other ways of doing this.\n\nThis will save all player serials in a table. Every time someone joins it will check their serials against the ones in the table. Every time you restart your server the table will be cleared, and everyone will be new again. If you want something more permanent you'll need to the things mentioned above. playerSerials = {} -- create a table that will contain all the player serials function setPlayerState() local playerSerial = getPlayerSerial(source) local playerName = getPlayerName(source) for index,theSerial in ipairs(playerSerials) do -- go through the table if (playerSerial == theSerial) then -- if one of the serials matches the current player outputChatBox(playerName.. \" has joined the game [Regular Player]\",getRootElement(),0,190,90) -- the player is regular return --and we can stop end end outputChatBox(playerName.. \"has joined the game [New Player]\",getRootElement(),0,190,90) -- if no serial matches, the player is new table.insert(playerSerials,playerSerial) --add them to the table so they won't be new next time end addEventHandler(\"onPlayerJoin\",root,setPlayerState)"
    }
]