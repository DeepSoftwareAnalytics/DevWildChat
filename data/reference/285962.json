[
    {
        "link": "https://vuejs.org/guide/components/v-model.html",
        "document": "can be used on a component to implement a two-way binding.\n\nStarting in Vue 3.4, the recommended approach to achieve this is using the macro: The parent can then bind a value with : The value returned by is a ref. It can be accessed and mutated like any other ref, except that it acts as a two-way binding between a parent value and a local one:\n• Its is synced with the value bound by the parent ;\n• When it is mutated by the child, it causes the parent bound value to be updated as well. This means you can also bind this ref to a native input element with , making it straightforward to wrap native input elements while providing the same usage: is a convenience macro. The compiler expands it to the following:\n• A prop named , which the local ref's value is synced with;\n• An event named , which is emitted when the local ref's value is mutated. This is how you would implement the same child component shown above prior to 3.4: Then, in the parent component will be compiled to: As you can see, it is quite a bit more verbose. However, it is helpful to understand what is happening under the hood. Because declares a prop, you can therefore declare the underlying prop's options by passing it to : If you have a value for prop and you don't provide any value for this prop from the parent component, it can cause a de-synchronization between parent and child components. In the example below, the parent's is undefined, but the child's is 1:\n\nFirst let's revisit how is used on a native element: Under the hood, the template compiler expands to the more verbose equivalent for us. So the above code does the same as the following: When used on a component, instead expands to this: For this to actually work though, the component must do two things:\n• Bind the attribute of a native element to the prop\n• When a native event is triggered, emit an custom event with the new value Now should work perfectly with this component: Another way of implementing within this component is to use a writable property with both a getter and a setter. The method should return the property and the method should emit the corresponding event:\n\non a component can also accept an argument:\n\nBy leveraging the ability to target a particular prop and event as we learned before with arguments, we can now create multiple bindings on a single component instance.\n\nEach will sync to a different prop, without the need for extra options in the component:\n\nWhen we were learning about form input bindings, we saw that has built-in modifiers - , and . In some cases, you might also want the on your custom input component to support custom modifiers.\n\nLet's create an example custom modifier, , that capitalizes the first letter of the string provided by the binding:\n\nModifiers added to a component can be accessed in the child component by destructuring the return value like this: To conditionally adjust how the value should be read / written based on modifiers, we can pass and options to . These two options receive the value on get / set of the model ref and should return a transformed value. This is how we can use the option to implement the modifier:\n\nModifiers added to a component will be provided to the component via the prop. In the below example, we have created a component that contains a prop that defaults to an empty object: Notice the component's prop contains and its value is - due to it being set on the binding . Now that we have our prop set up, we can check the object keys and write a handler to change the emitted value. In the code below we will capitalize the string whenever the element fires an event.\n\nHere's another example of using modifiers with multiple with different arguments:"
    },
    {
        "link": "https://pipo.blog/articles/20220714-vue3-v-model-binding",
        "document": "Vue is a directive that creates a two-way data binding between a value in our template and a value in our data properties, while only binds data one way. A common use case for using v-model is when designing forms and inputs.\n\nWhile the core concept of is quite straightforward, you might struggle with it when building advanced custom form components. Personally, this was my main pain point when learning Vue, especially since there are so many different ways this can be handled and tutorials diverge quite a bit.\n\nVue's official Components In-Depth > Events > Usage with documentation only covers the most basic usage without providing any advanced examples. So I put together some use cases for you to learn more about . The main question is: How can I make that custom component reusable so that it can be used as a form component with two-way data binding?\n\nVue's directive does the following under the hood:\n\nBy default, the following applies to :\n\nThis prop and event name will then be available in your child component.\n\nSo, in every custom component which should support two-way data binding you need to implement the following:\n• emit event when the input changes\n\nLet's dive into a selection of 3 use cases which all use the recommended Vue 3 Composition API syntax.\n\nIn this example, we are building a form component that wraps the native HTML element. It could then be used like this from our parent component:\n\nOur child component (basic form component) looks like this:\n\nIn this example, the data we are binding to our event is which is the actual value of this input field.\n\nRemember: Native HTML elements always fire Events, so you'll never get a primitive (like e.g. a or a ) as . That's why you need to retrieve the effective input element's value with in this case.\n\nLet's create a slightly more sophisticated custom Switch (Toggle) form component, using Headless UI component. Please note that the official Headless UI documentation provides us with a basic example where they use an ref to store the current state:\n\nThis extra ref is not needed inside our custom component, as the component itself fires an event with a primitive that represents the current on/off state (see Component API documentation, where supports a ). So, is simply the and we can pass it directly to our parent component with .\n\nSide-note: In the example below, we are going to use the newer syntax without depending on the \"magic\" variable, so this is exactly the same in Vue 3 (see Component Events > Usage with ):\n\nSo our fully working (and minimally styled) component looks like this:\n\nPlease note, in this example, we use the prop directly for the current state of the Switch/Toggle. The Headless UI component would offer a slot prop for that as well, but this would only be available inside the component tag and not in e.g. any direct property of the tag itself (e.g. , where we would still depend on either or some other ref that represents the current state). The following could be done, but just makes our example more complex, as we would use slot prop in addition to the actual :\n\nAnd why can't we directly bind the to the component using inside our component? Read this: Props: One-Way Data Flow\n\nSo, never try to mutate a property in your custom component! Always work around it by only reading the prop value and firing events to pass the changed value back to the parent component, as we did in above example.\n\nLet's dive into another slightly more complex example of two-way data binding, using Headless UI component. We can use this component to build custom, accessible select menus.\n\nOptions are passed in an object notation as prop to our custom component:\n\nIn our component, on the top level component, we store the current option in a ref, using . As the current option is an object (e.g. ), we need to extract the id from it and only pass this to the parent component.\n\nSo, in below example, we need to store the currently selected option anyway in a new ref . Like this, we can make use of on component and then watch that ref for changes. On every change event, we emit the event and only extract the from the selected option. Here's our fully working (yet unstyled) component:\n\nI hope these examples gave you a better feeling for .\n\nNow, enjoy the power of magic reactivity by two-way data binding. Happy coding!"
    },
    {
        "link": "https://vueschool.io/articles/vuejs-tutorials/v-model-and-definemodel-a-comprehensive-guide-to-two-way-binding-in-vue-js-3",
        "document": "Are you ready to master two-way binding in Vue js 3 using ? In this comprehensive guide, we'll explore how to implement seamless data flow between components using this powerful composition API Macro. By the end, you'll have a clear understanding of how to use the classic directive and leverage for efficient two-way binding in your Vue.js applications.\n\nAnd guess what? It works the other way around too! If you programmatically change the data in your Vue.js application, the component's template will instantly reflect the update. This seamless synchronization keeps your application reactive and responsive to user interactions, resulting in a unique user experience.\n\nImagine you have a parent component named with a form where users can enter information. You want any edits they make to be instantly reflected in a variable called . Likewise, if you update in your code, the form should show the new value. This effortless back-and-forth exchange is the power of two-way binding! Let’s have a look at the following script setup with composition API example:\n\nUsing v-model with basic input fields is a piece of cake. But what if you want to create custom components with their own data and behaviors? This is where Single-File Components (SFCs) come in! Let's explore how to achieve two-way binding magic with SFCs.\n\nLet's break down two-way binding with a simple example using . Imagine we have a parent component with a custom component called . This component will display a text input field. We want any changes made in the input to be reflected in the parent component's data.\n\nSo far, this is a one-way street, as the parent tells the child what to show. To achieve two-way binding, we need to inform the parent about any changes in the input field. We do this by listening to the event and emitting an update event to the parent. But there's a twist! We need to emit an update specifically for .\n\nWe define an function that captures the new value from the input event and emits an event with the new data. Because on the child is expecting this specific event ( ), it automatically updates the parent's with the new value we emitted.\n\nBy following these steps, we create a two-way data flow between the parent and child component using . Any changes in the will be reflected in the parent's data, keeping everything in sync!"
    },
    {
        "link": "https://v3-migration.vuejs.org/breaking-changes/v-model",
        "document": "In terms of what has changed, at a high level:\n• BREAKING: When used on custom components, prop and event default names are changed:\n• BREAKING: 's modifier and component option are removed and replaced with an argument on ;\n• NEW: Multiple bindings on the same component are possible now;\n• NEW: Added the ability to create custom modifiers.\n\nFor more information, read on!\n\nWhen Vue 2.0 was released, the directive required developers to always use the prop. And if developers required different props for different purposes, they would have to resort to using . In addition, this hard-coded relationship between and led to issues with how native elements and custom elements were handled.\n\nIn 2.2 we introduced the component option that allows the component to customize the prop and event to use for . However, this still only allowed a single to be used on the component.\n\nWith Vue 3, the API for two-way data binding is being standardized in order to reduce confusion and to allow developers more flexibility with the directive.\n\nIn 2.x, using a on a component was an equivalent of passing a prop and emitting an event:\n\nIf we wanted to change prop or event names to something different, we would need to add a option to component:\n\nSo, in this case would be a shorthand to\n\nIn some cases, we might need \"two-way binding\" for a prop (sometimes in addition to existing for the different prop). To do so, we recommended emitting events in the pattern of . For example, for from the previous example with the prop, we could communicate the intent of assigning a new value with:\n\nThen the parent could listen to that event and update a local data property, if it wants to. For example:\n\nFor convenience, we had a shorthand for this pattern with the modifier:\n\nIn 3.x on the custom component is an equivalent of passing a prop and emitting an event:\n\nTo change a model name, instead of a component option, now we can pass an argument to :\n\nThis also serves as a replacement to modifier and allows us to have multiple s on the custom component.\n\nIn addition to 2.x hard-coded modifiers like , now 3.x supports custom modifiers:\n\nRead more about custom modifiers on components.\n• None checking your codebase for usage and replace it with : <!-- to be replaced with -->\n• None for all s without arguments, make sure to change props and events name to and respectively\n\nFor more information on the new syntax, see:"
    },
    {
        "link": "https://medium.com/@johnidouglasmarangon/my-journey-to-read-the-vue-js-3-official-documentation-0d2dd50f965c",
        "document": "What is Vue.js and Why You Should Use It\n\nVue.js 3 is a JavaScript framework designed to build user interfaces and single-page applications with a declarative, component-based approach. It extends standard HTML, CSS, and JavaScript by providing a flexible and efficient way to manage state, handle user interactions, and create reusable components.\n\nWhy Consider Learning and Using Vue.js 3?\n• Simplicity and Ease of Use: Vue.js has a gentle learning curve, making it accessible even to developers who are new to JavaScript frameworks.\n• Reactivity System: Vue's reactivity system automatically updates the DOM when the underlying data changes, minimizing the need for manual DOM manipulation.\n• Component-Based Architecture: Encourages code reusability and better organization by encapsulating functionality within components.\n• Performance Improvements: Vue.js 3 boasts significant performance enhancements over its predecessor, thanks to the new reactivity system and compiler optimizations.\n• TypeScript Support: Enhanced TypeScript integration for better type checking and tooling support.\n• Strong Community and Ecosystem: A rich collection of libraries, tools, and a supportive community make developing with Vue.js a delightful experience.\n\nWhether you’re building a small application or scaling a large enterprise solution, Vue.js 3 provides the tools and flexibility to meet your needs.\n\nTo get started with a new Vue.js 3 project, you can use Vite, a build tool that provides a fast and lean development experience.\n\nEnsure you have Node.js installed on your machine. Open you terminal and run:\n\nNavigate to the project directory, install dependencies, and run the development server:\n\nYour application will be accessible at .\n\nThe Composition API is a new way of building components in Vue.js 3, introduced as an alternative to the traditional Options API. Take a look at Composition API FAQ section to gain detailed understanding of the differences between both.\n\nHere is a basic example of using Composition API:\n• Function-based Syntax: Instead of defining methods, data, and lifecycle hooks in separate properties, the Composition API uses functions to organize logic.\n• Better Code Structure: It encourages a more modular and composable approach to building components.\n• Reusability: Functions can be extracted into reusable units called composables, making it easier to share logic across multiple components.\n\nAt the heart of Vue.js is its reactivity system, which allows the UI to automatically update when the underlying state changes. The Reactive API in Vue.js 3 provides functions to create reactive state:\n• : Used to make an entire object reactive.\n• : Used for primitive values or when you need a mutable reference to a single values.\n• : Creates a reactive value that automatically updates when its dependencies change.\n\nThese functions are used to respond to changes in reactive state. immediately executes and re-executes whenever its dependencies change. is more configurable, allowing you to specify exactly which data you’re watching and what to do when it changes.\n\nBoth and are reactivity APIs used to respond to reactive state changes. However, they work differently and have distinct use cases.\n\nSingle-File Components (SFCs) are files that encapsulate the template, logic, and styles of a component in a single file. This encapsulation promotes better organization and reusability.\n\nHere’s an example of an SFC in Composition API:\n• : Contains the HTML structure of the component.\n\nAS you can see, Vue Single-File Components (a.k.a. *.vue files) extend the classic trio combination of HTML, CSS, and Java Script.\n\nVue.js uses an HTML-based template syntax that allows you to declaratively bind data to the DOM. Vue.js template syntax is a declarative way to bind data to the DOM using a special syntax within HTML templates. It allows you to dynamically render content, handle events, and apply directives to manipulate the DOM efficiently.\n\nYou can embed dynamic content within double curly braces (mustache syntax) .\n\nDirective are special attributes with the prefix to apply dynamic behavior. Built-in directives include: , , , , , , , , , , , .\n\nCustom directives provide a way to directly manipulate the DOM when needed by adding specific behaviors to elements.\n\nComponents are the building blocks of Vue.js applications. They allow you to break down complex UIs into smaller, reusable pieces.\n\nHere’s an example of a Single File Component (SFC) Approach (Recommended)\n\nIf you want to register a component globally, it allows you to use anywhere in your app without explicitly importing it.\n• Reusability: Components can be reused across multiple parts of your application.\n• Modularity: They make your code more organized and easier to maintain.\n• Testability: Individual components can be tested in isolation.\n\nComposable components allow you to reuse logic across different components by creating custom composable functions. Example of a composable component for manage a counter:\n\nHow Components Can Communicate with Each Other?\n\nCommunication between components is essential in any application. Vue.js provides several mechanisms for passing data and events between components.\n\nProps are custom attributes you can register on a component. When a value is passed to a prop, it becomes a property on that component instance.\n\nChild components can emit events to send information back to the parent.\n\nThe directive can create a two-way data binding between parent and child components.\n\nThese functions allow ancestor components to provide data or methods that descendant components can inject, no matter how deep the component tree.\n\nVue.js provides for two-way data binding in forms making it easier work with form inputs.\n\nLet’s create an example of fetching data from an external API using the API and display a list of todos.\n\nVue.js 3 allows you to create simple routing without external libraries. We can create a simple router using dynamic components to render different components based on the URL hash.\n\nEmbarking on my journey through the Vue.js 3 official documentation was incredible. Whether you're new to JavaScript frameworks or looking to expand your toolkit, Vue.js 3 offers a blend of simplicity and sophistication features that caters to projects of any scale.\n\nVue.js 3 has robust features, flexibility, and intuitive API make it a powerful tool for building modern web applications. It’s a powerful and versatile framework well worth exploring.\n\nI encourage you to dive into the official documentation and explore the endless possibilities Vue.js 3 has to offer. Hopefully, this post has inspired you to embark on your own Vue.js 3 learning adventure!"
    },
    {
        "link": "https://stackoverflow.com/questions/53366395/how-to-use-v-model-with-checkbox-in-vue-js",
        "document": "In vue2 js, I want to use a checkbox with a v-model.\n\nI want the value of the checkbox to be , however I want the 2 way binding with the prop called which is a boolean. However the above only does 1 way binding. How can I fix this?"
    },
    {
        "link": "https://marcoarruda.medium.com/vue-v-model-with-checkboxes-in-528ab9481aae",
        "document": "Vue’s is a powerful directive that simplifies two-way data binding, making form inputs easy to manage. When dealing with checkboxes, however, things can get a bit tricky—especially when working with multiple selections or custom implementations.\n\nIn this post, we’ll break down how works with checkboxes, covering both single and multiple selections, common pitfalls, and best practices to keep your Vue components clean and efficient. Whether you're a beginner or looking to refine your Vue skills, this guide will help you leverage effectively in checkbox scenarios.\n\nFor a single checkbox, binds the state to a Boolean value in the component’s data. Here’s an example:\n\n️You can easily test it in Vue playground\n\n🐛 test here\n\nFurthermore, you can give to the checkbox the ability to set different values to the ref variable, rather than just or , by setting the attributes and in the input element:\n\nIf you need to bind multiple checkboxes to a list, can be used with an array. When a checkbox is checked, its value is added to the array. When unchecked, the value is removed.\n\nNow, if the user checks “Option 3” and “Option 1”, will look like this:\n\n️You can easily test it in Vue playground\n\n🐛 test here\n\nWhile v-model simplifies checkbox handling in Vue, there are some common pitfalls to watch out for:\n• Forgetting to initialize data properly — ensure that or data properties are properly initialized in the variable\n• Incorrectly using non-boolean values for single checkboxes — If using custom and , ensure they are set correctly to avoid unexpected behaviors\n• Expecting v-model to work on dynamic elements without a — When rendering checkboxes dynamically with , ensure each has a to prevent unexpected state issues\n\nUsing with checkboxes in Vue is straightforward, whether you are working with single checkboxes, groups of checkboxes, or custom values. By understanding these patterns, you can create more interactive and dynamic forms in your Vue applications."
    },
    {
        "link": "https://vuejs.org/guide/essentials/forms",
        "document": "When dealing with forms on the frontend, we often need to sync the state of form input elements with corresponding state in JavaScript. It can be cumbersome to manually wire up value bindings and change event listeners:\n\nThe directive helps us simplify the above to:\n\nIn addition, can be used on inputs of different types, , and elements. It automatically expands to different DOM property and event pairs based on the element it is used on:\n• with text types and elements use property and event;\n• and use property and event;\n• uses as a prop and as an event.\n\nNote that interpolation inside won't work. Use instead.\n\nWe can also bind multiple checkboxes to the same array or Set value:\n\nIn this case, the array will always contain the values from the currently checked boxes.\n\nIf the initial value of your expression does not match any of the options, the element will render in an \"unselected\" state. On iOS this will cause the user not being able to select the first item because iOS does not fire a change event in this case. It is therefore recommended to provide a disabled option with an empty value, as demonstrated in the example above.\n\nSelect options can be dynamically rendered with :\n\nFor radio, checkbox and select options, the binding values are usually static strings (or booleans for checkbox):\n\nBut sometimes we may want to bind the value to a dynamic property on the current active instance. We can use to achieve that. In addition, using allows us to bind the input value to non-string values.\n\nand are Vue-specific attributes that only work with . Here the property's value will be set to when the box is checked, and set to when unchecked. You can also bind them to dynamic values using :\n\nwill be set to the value of when the first radio input is checked, and set to the value of when the second one is checked.\n\nsupports value bindings of non-string values as well! In the above example, when the option is selected, will be set to the object literal value of .\n\nBy default, syncs the input with the data after each event (with the exception of IME composition as stated above). You can add the modifier to instead sync after events:\n\nIf you want user input to be automatically typecast as a number, you can add the modifier to your managed inputs:\n\nIf the value cannot be parsed with , then the original (string) value is used instead. In particular, if the input is empty (for instance after the user clearing the input field), an empty string is returned. This behavior differs from the DOM property .\n\nThe modifier is applied automatically if the input has .\n\nIf you want whitespace from user input to be trimmed automatically, you can add the modifier to your -managed inputs:\n\nHTML's built-in input types won't always meet your needs. Fortunately, Vue components allow you to build reusable inputs with completely customized behavior. These inputs even work with ! To learn more, read about Usage with in the Components guide."
    },
    {
        "link": "https://stackoverflow.com/questions/58187290/vue-binding-with-v-model-in-custom-checkbox-component-doesnt-work",
        "document": "When you do\n\nSo it just assigns the value of the last checkbox you clicked to . If you want to keep all checked items in , you need to do the following:\n• add property to component to have access to the current value of . is default property name for this goal (see vue guide).\n• in your method copy the current value to the variable, because it's not good to mutate property directly\n• if your checkbox is checked, push the correspondent value to the array. If the checkbox is not checked, delete to correspondent value from the array\n• emit event with the resulting array as value\n\nI don't know if you need to set checkbox state programmatically, i.e. when you change the state of checkboxes changes correspondently. If you do, you need to watch property in your component: set the state of the check box in dependance of if its value is in array. Do the same also in hook if you want to initialize the state of checkboxes by"
    },
    {
        "link": "https://reddit.com/r/vuejs/comments/t61b9k/vmodel_and_checkboxes_assistance_request",
        "document": "Hi all, hoping for some assistance...\n\nBeen struggling and googling all day but can't seem to find a good example so I'm asking here.\n\nWhat is the proper way to use v-model for multiple checkboxes with a single file component and the composition API e.g. <script setup> ? I'm declaring it as a variable with ref like this..\n\nbut it's not picking up the data so I think I must be missing something.\n\nTrying to access the checked options in the 'moveItem' function."
    }
]