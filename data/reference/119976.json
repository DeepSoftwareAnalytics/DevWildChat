[
    {
        "link": "https://stackoverflow.com/questions/23016057/web-api-best-approach-for-returning-httpresponsemessage",
        "document": "Although this is not directly answering the question, I wanted to provide some information I found usefull. http://weblogs.asp.net/dwahlin/archive/2013/11/11/new-features-in-asp-net-web-api-2-part-i.aspx\n\nThe HttpResponseMessage has been more or less replaced with IHttpActionResult. It is much cleaner an easier to use.\n\nThen you can encapsulate to create custom ones. How to set custom headers when using IHttpActionResult?\n\nI haven't found a need yet for implementing a custom result yet but when I do, I will be going this route.\n\nIts probably very similar to do using the old one as well.\n\nTo expand further on this and provide a bit more info. You can also include messages with some of the requests. For instance.\n\nYou can't do this with many of the other ones but helps for common messages you want to send back."
    },
    {
        "link": "https://stackoverflow.com/questions/54136488/correct-way-to-return-httpresponsemessage-as-iactionresult-in-net-core-2-2",
        "document": "In .Net Core 2.2. I am creating a API Controller that routes the request to another Http endpoint based on payload.\n\nbased on SO post i can do this\n\nHowever i am not sure sending as is correct way.\n\nI also want to make sure content negotiation will work."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.net.http.httpresponsemessage?view=net-9.0",
        "document": "The preceding code example uses an entry point. That feature requires C# 7.1 or later.\n\nA common way to get an HttpResponseMessage is from one of the HttpClient.SendAsync(HttpRequestMessage) methods.\n\nInitializes a new instance of the HttpResponseMessage class. Initializes a new instance of the HttpResponseMessage class with a specific StatusCode. Gets or sets the content of a HTTP response message. Gets the collection of HTTP response headers. Gets a value that indicates if the HTTP response was successful. Gets or sets the reason phrase which typically is sent by servers together with the status code. Gets or sets the request message which led to this response message. Gets or sets the status code of the HTTP response. Gets the collection of trailing headers included in an HTTP response. Gets or sets the HTTP message version. Releases the unmanaged resources and disposes of unmanaged resources used by the HttpResponseMessage. Releases the unmanaged resources used by the HttpResponseMessage and optionally disposes of the managed resources. Throws an exception if the IsSuccessStatusCode property for the HTTP response is . Determines whether the specified object is equal to the current object. (Inherited from Object) Gets the Type of the current instance. (Inherited from Object)"
    },
    {
        "link": "https://learn.microsoft.com/en-us/aspnet/web-api/overview/getting-started-with-aspnet-web-api/action-results",
        "document": "Consider using ASP.NET Core web API. It has the following advantages over ASP.NET 4.x Web API:\n• ASP.NET Core is an open-source, cross-platform framework for building modern, cloud-based web apps on Windows, macOS, and Linux.\n• The ASP.NET Core MVC controllers and web API controllers are unified.\n• Ability to develop and run on Windows, macOS, and Linux.\n• Ability to host on Kestrel, IIS, HTTP.sys, Nginx, Apache, and Docker.\n\nThis topic describes how ASP.NET Web API converts the return value from a controller action into an HTTP response message.\n\nA Web API controller action can return any of the following:\n\nDepending on which of these is returned, Web API uses a different mechanism to create the HTTP response.\n\nThe rest of this topic describes each option in more detail.\n\nIf the return type is , Web API simply returns an empty HTTP response with status code 204 (No Content).\n\nIf the action returns an HttpResponseMessage, Web API converts the return value directly into an HTTP response message, using the properties of the HttpResponseMessage object to populate the response.\n\nThis option gives you a lot of control over the response message. For example, the following controller action sets the Cache-Control header.\n\nIf you pass a domain model to the CreateResponse method, Web API uses a media formatter to write the serialized model into the response body.\n\nWeb API uses the Accept header in the request to choose the formatter. For more information, see Content Negotiation.\n\nThe IHttpActionResult interface was introduced in Web API 2. Essentially, it defines an HttpResponseMessage factory. Here are some advantages of using the IHttpActionResult interface:\n• Makes the intent of the controller action clearer, by hiding the low-level details of constructing the response.\n\nIHttpActionResult contains a single method, ExecuteAsync, which asynchronously creates an HttpResponseMessage instance.\n\nIf a controller action returns an IHttpActionResult, Web API calls the ExecuteAsync method to create an HttpResponseMessage. Then it converts the HttpResponseMessage into an HTTP response message.\n\nHere is a simple implementation of IHttpActionResult that creates a plain text response:\n\nMore often, you use the IHttpActionResult implementations defined in the System.Web.Http.Results namespace. The ApiController class defines helper methods that return these built-in action results.\n\nIn the following example, if the request does not match an existing product ID, the controller calls ApiController.NotFound to create a 404 (Not Found) response. Otherwise, the controller calls ApiController.OK, which creates a 200 (OK) response that contains the product.\n\nFor all other return types, Web API uses a media formatter to serialize the return value. Web API writes the serialized value into the response body. The response status code is 200 (OK).\n\nA disadvantage of this approach is that you cannot directly return an error code, such as 404. However, you can throw an HttpResponseException for error codes. For more information, see Exception Handling in ASP.NET Web API.\n\nWeb API uses the Accept header in the request to choose the formatter. For more information, see Content Negotiation."
    },
    {
        "link": "https://sharpencode.com/article/WebApi/ihttpactionresult-and-httpresponsemessage",
        "document": "In order to understand the difference and similarities between HttpResponseMessage and IHttpActionResult , you first need to understand why does these return types even exist, In .Net to return an integer you have int dataType, to return float or double or decimal, you have all these primitive dataType , if you want to return collection of object then you have IEnummerable, List , Array and a lot of things, then why the heck do you need one more return type?\n\nSince we can return primitive types or complex types to the user, why HttpResponseMessage?\n\nLet's consider a scenario where we want to return all Employees or an Employee by his Id. we can simply create methods like shown below.\n\nAnd when, we run the application and issue get request from browser , we get below results.\n\nYou can see, we are getting the desired output, then what's the problem , why don't we use IEnumberable or Employee (Complex type) directly ,to return data in web API?\n\nThis is because, we use web API to create Rest services, and Rest services means respecting the Http, And respecting the Http means return everything a Http needs to carry message appropriately.\n\nLet's see what are we missing.\n\ncase 1.what if List of employee gets null.(we must return http status code 204 (No content) with no employee found message)\n\ncase 2.what if any run time error occurs.(we must return 500 internal server error).\n\ncase 3.what if there is no employee of specified Id exist.( we must return 204 status code, with no employee with specified Id exist message. )\n\nIn short ,No we are not following rest principles completely. Rest means respect the http protocol and utilize it as much as you can.\n\nTo check what is the problem , issue a get request for employee who doesn't exist like employee with id=90 ,with fiddler or postman and check the response header.\n\nAs you can see, even if there is no employee with such Id and we are getting null response but Response header contains Http Status Code 200 Ok, which is manipulating.\n\nLets modify the above code to get the desired outcome and fulfill the rest principles completely.\n\nNow ,Run the application and request employee who doesn't exist like employee with id 90. you will get below representation.\n\nNow, everything is great, we are respecting the Http protocol completely.\n\nI think now you got the point , why does HttpResponseMessage exist? yes , it is used to return data along with the Http Status code and additional error Messages.\n\nNow Let's come to IHttpActionResult , the purpose of IHttpActionResult is exactly the same , it also serves the same purpose of returning data with http status code and additional error messages if there is any.\n\nNow, you might be thinking then why did Microsoft introduce a new return type in the form of IHttpActionResult when we already had HttpResponseMessage to serve the same purpose?\n\nIHttpActionResult was first introduced introduced in Web API 2 that works as a return type for Action methods , this means Instead of returning HttpResponseMessage from a controller action, we can now return IHttpActionResult.Using the IHttpActionResult interface over HttpResponseMessage have many adavantages, some of them are \n\n 1. The code becomes cleaner and easier to read, which leads to better maintainability. \n\n 2. Unit testing controller action methods also becomes much simpler.\n\nConsider the above EmployeeController. Notice both the Get() methods return HttpResponseMessage. To create the HttpResponseMessage, we often use CreateResponse() method of the Request objectand send the necessary data or we use CreateErrorResponse() method of the Request object to send an error response. these makes the code lengthy and could be replaced by IHttpActionResult.\n\nLet's rewrite the above example with the help of IhttpActionResult and the helper methods, for this replace all instances of HttpResponseMessage with IhttpActionResult and to create Response, use Ok() helper method which accepts the object we want to return and create HttpResponseMessage internally it also set the status code to 200 Ok automatically.\n\nWeb API provides us several helper methods other than Ok() or NotFound(),as listed below. All these methods are used to return different types of HttpResponseMessages and all of them implements IHttpActionResult."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/microsoft.xrm.sdk.client.organizationserviceproxy?view=dataverse-sdk-latest",
        "document": "To call the Microsoft Dynamics 365 web service using the IOrganizationService interface, cast the proxy instance to an IOrganizationService type.\n\nThis class is not thread safe. Dataverse authentication using the Microsoft Online Services environment identity provider, including Microsoft Office 365, is supported.\n\nInitializes a new instance of the OrganizationServiceProxy class using a service configuration and client credentials. Initializes a new instance of the OrganizationServiceProxy class using a service configuration and a security token response. Initializes a new instance of the OrganizationServiceProxy class using a service configuration and client credentials. Initializes a new instance of the OrganizationServiceProxy class using a service management and a security token response. Initializes a new instance of the OrganizationServiceProxy class using a organization service URI, home realm URI, and client and device credentials.\n\nGets or sets the ID of the user for whom SDK calls are made on behalf of. Gets the login credentials of the client. (Inherited from ServiceProxy<TService>) Gets the Windows Live credentials of a registered device. (Inherited from ServiceProxy<TService>) Gets or sets a value that enables automatic switching from the organization’s current endpoint to an alternate endpoint. (Inherited from ServiceProxy<TService>) Gets the endpoint switch information from the web service configuration. (Inherited from ServiceProxy<TService>) Gets the security token response of the home realm. (Inherited from ServiceProxy<TService>) Gets a value indicating if the WCF channel has been authenticated. (Inherited from ServiceProxy<TService>) Gets or sets the version of the client. Gets the communication channel used to access a Microsoft Dynamics 365 service. (Inherited from ServiceProxy<TService>) Gets or sets the maximum amount of time a single channel operation has to complete before a timeout fault is raised on a service channel binding. (Inherited from ServiceProxy<TService>) Gets or sets the UPN that is an Internet-style login name for a user based on the Internet standard RFC 822. (Inherited from ServiceProxy<TService>)\n\nOccurs when a failover recovery has completed and the organization’s current endpoint has been switched to an alternate endpoint. (Inherited from ServiceProxy<TService>) Occurs when a failover has occurred and a switch from the organization’s current endpoint to an alternate endpoint is required. (Inherited from ServiceProxy<TService>)"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dynamics365/customerengagement/on-premises/developer/integration-dev/sample-enable-document-management-entities?view=op-9-1",
        "document": "This sample code is for Dynamics 365 for Customer Engagement. Download the sample: With SharePoint Integration.\n\nInternet connection is required to download the sample project and to restore the NuGet packages used in the sample project.\n\nFor more information about the requirements for running the sample code provided here, see Run a simple program using Customer Engagement web services and How to run Dataverse samples?.\n\nThe following sample shows how to enable document management for entities in Dynamics 365 for Customer Engagement. In this sample code, document management is enabled for the entity using the UpdateEntityRequest message. By default, the setting for the entity isn’t enabled in a new installation of Dynamics 365 for Customer Engagement.\n\nIntegrate SharePoint with Microsoft Dynamics 365 Customer Engagement (on-premises)\n\n Enable SharePoint Integration\n\n Sample: Create, Retrieve, Update, and Delete a SharePoint Location Record\n\n Sample: Create, Retrieve, Update, and Delete (CRUD) a SharePoint Location Record"
    },
    {
        "link": "https://community.dynamics.com/forums/thread/details?threadid=05cbefba-cd33-4a89-ab13-ef34f1bef66a",
        "document": "Recently we got our CRM online instance upgraded to Dynamics 365. Now my .net code which was working in creating New Account is no longer working and throwing below error;\n\nError while connecting to CRM The server was unable to process the request due to an internal error. For more information about the error, either turn on IncludeExceptionDetailInFaults (either from ServiceBehaviorAttribute or from the <serviceDebug> configuration behavior) on the server in order to send the exception information back to the client, or turn on tracing as per the Microsoft .NET Framework SDK documentation and inspect the server trace logs.\n\npublic static void ConnectToMSCRM(string UserName, string Password, string SoapOrgServiceUri)\n\n {\n\n try\n\n {\n\n ClientCredentials credentials = new ClientCredentials();\n\n credentials.UserName.UserName = UserName;\n\n credentials.UserName.Password = Password;\n\n ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls12;\n\n Uri serviceUri = new Uri(SoapOrgServiceUri);\n\n OrganizationServiceProxy proxy = new OrganizationServiceProxy(serviceUri, null, credentials, null);\n\n proxy.EnableProxyTypes();\n\n _service = (IOrganizationService)proxy;\n\n\n\n Entity account = new Entity(\"account\");\n\n\n\n // Set the required attributes. For account, only the name is required. \n\n // See the metadata to determine \n\n // which attributes must be set for each entity.\n\n account[\"name\"] = \"Dummy_Account_Test1\";\n\n\n\n // Create an account record named Fourth Coffee.\n\n System.Guid _accountId = _service.Create(account);\n\n\n\n }\n\n catch (Exception ex)\n\n {\n\n Console.WriteLine(\"Error while connecting to CRM \" + ex.Message);\n\n Console.ReadKey();\n\n }"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dynamics365/customerengagement/on-premises/developer/introduction-entities?view=op-9-1",
        "document": "The entities are used to model and manage business data in Dynamics 365 Customer Engagement (on-premises). For example, entities such as account, campaign, and incident (case) can be used to track and support sales, marketing, and service activities. An entity has a set of attributes and each attribute represents a data item of a particular type. For example, the account entity has , , and attributes. Conceptually, an entity is like a database table, and the entity attributes correspond to the table columns. Creating an entity record (or, simply a record) in Dynamics 365 Customer Engagement (on-premises) is like adding a row in a database table. The entities are divided into three categories: system, business, and custom. As a developer working with business data, you will use business and custom entities. System entities are used by Dynamics 365 Customer Engagement (on-premises) to handle all internal processes, such as workflows and asynchronous jobs. You cannot delete or customize system entities.\n\nBusiness entities are part of the Dynamics 365 Customer Engagement (on-premises) default installation and they appear in the customization user interface. An account, contact, and letter are examples of business entities. After installation, you can add custom entities to Dynamics 365 Customer Engagement (on-premises) to address specific business needs of the organization. In a Dynamics 365 Customer Engagement (on-premises) Solution, you can set business and custom entities and attributes to be either customizable or non-customizable. You can modify a customizable entity by renaming it, adding new attributes, or changing various settings, such as duplicate detection or queue support settings. You cannot modify a non-customizable entity. For more information about customization, unmanaged and managed solutions, and managed properties, see Package and Distribute Extensions with Dynamics 365 Customer Engagement (on-premises) Solutions.\n\nIf you are using the early-bound programming model, an entity is represented by a class, such as the class that represents the account entity. Entity attributes are represented by class properties. This class is generated by the CrmSvcUtil tool. For more information, see WCF Early Bound (strong typed) Programming. Alternatively, you can write programs that work with entity data by using a dynamic approach. For more information, see WCF Late Bound (loosely typed) Programming.\n\nThe metadata for a Dynamics 365 Customer Engagement (on-premises) organization contains the definitions for the entities, attributes, and the relationships between the entities. For more information, see The Metadata and Data Models in Dynamics 365 Customer Engagement (on-premises). As a developer there are many cases where it is useful to be able to find all the metadata for an organization. There are a number of ways you can find and reference the metadata:\n• None You can use the Entity Metadata Browser to view entities and their properties in Dynamics 365 Customer Engagement (on-premises). For details, see Browse the Metadata for Your Organization.\n• None You can generate the metadata for your organization using these samples: You can create the following types of the relationships between entities: one-to-many, many-to-one, and many-to-many. The records for a many-to-many relationships are stored in an intersect entity. After a relationship is defined, use the AssociateRequest message or the Associate method to create a link between the specified records, and use the DisassociateRequest message or the Disassociate method to remove a link between the specified records. In the one-to-many and many-to-one relationships, some actions on the parent entity record affect the child entity records. The actions that have cascading behavior include: Assign, Delete, Merge, Share, Unshare and Reparent. For more information, see Entity Relationship Behavior.\n\nEntities, attributes, and relationships have several different names. The following table lists the various names that are used in the metadata.\n\nEach entity supports several different actions, for example create or delete a record, or assign a record to another user or team. Not all actions are allowed on all entity types or attributes. For each attribute, the metadata defines whether a given action is supported. For example, an attribute’s properties, such as , and tell you if you can create, retrieve or update the attribute. More information: Valid operations on attributes.\n\nTo perform an action, you call one of the methods inIOrganizationService. For example, to create a record in Dynamics 365 Customer Engagement (on-premises), you can use the IOrganizationService.Create method or the IOrganizationService.Execute method with the corresponding CreateRequest message. You must have the necessary privileges and access rights to perform these actions. For more information, see The Security Model of Dynamics 365 Customer Engagement (on-premises).\n\nThe following table lists the actions that are allowed on business and custom entity records and the methods and messages that you can use to perform these actions.\n\nTo perform this action, the caller must have Create Privileges. Access rights do not apply to the Create action, but they do apply to the record after it has been created.\n\nTo own a record or to retrieve the newly created record, a user or team must also have read privileges and access rights on the new record. For example, if you have create privileges for accounts, you can create an account record and assign it to another user or team. However, unless you also have read privilege for accounts, and access rights on the new record, you cannot create an account and be the owner of that new account.\n\nTo perform this action, the caller must have Update Privileges and access rights on the entity records that are being updated.\n\nWhen you update a record, only the attributes for which you specify data or for which you specify null are updated. All other values remain the same. Also, if you specify data for attributes that are not valid for update, they are ignored.\n\nTo perform this action, the caller must have Delete Privileges and access rights on the entity records being deleted.\n\nThe cascading rules determine whether related records are deleted at the same time. For more information, see Entity Relationship Behavior.\n\nTypically, you should only delete records that you entered by mistake. For some record types, you can deactivate or close the record instead of deleting it. Not all record types can be deleted.\n\nTo perform this action, the caller must have Retrieve Privileges and access rights on the entity records retrieved.\n\nTo perform this action, the caller must have Retrieve Privileges and access rights on the entity records retrieved.\n\nTo retrieve a collection of records based on the query parameters, you can either use a query expression or FetchXML query language. Query expressions let you build a query tree by using a class hierarchy. The methods that use a query expression return a collection of strongly typed records. FetchXML lets you build a query by using an XML language. FetchXML returns an XML string. Therefore, you must do more data manipulation to use the query results. For more information, see Creating Queries to Retrieve Data.\n\nFor user-owned or team-owned entities, you assign a record to a new owner. For more information, see Entity Ownership. To perform this action, the caller must have Assign privileges and access rights on the entity records.\n\nThe cascading rules determine whether related records are assigned to another user at the same time. For more information, see Entity Relationship Behavior.\n\nWhen a record is assigned to another user or team, the previous owner still has access to this record if the attribute is set to . However, the previous owner will no longer have ownership of the record.\n\nFor user-owned or team-owned entities, you can share a record with other users or teams. To perform this action, the caller must have GrantAccess, ModifyAccess, and RevokeAccess Privileges and access rights on the entity records.\n\nThe cascading rules determine whether related records are shared at the same time. For more information, see Entity Relationship Behavior\n\nSharing is the way Dynamics 365 Customer Engagement (on-premises) users can give other users access to customer information as needed. For example, a salesperson might decide to share an opportunity with another salesperson so that they can both track the progress of an important sale.\n\nUse the GrantAccessRequest to share a record. Use the ModifyAccessRequest to change how a record is shared. Use the RevokeAccessRequest to remove all sharing for the record.\n\nA user must have share rights to share customer-related records, such as contacts, accounts, opportunities, cases, and orders, with any other user in Dynamics 365 Customer Engagement (on-premises). When a record is shared, you can specify the rights to grant for the shared record.\n\nThe following list describes the rules for sharing records:\n• None Anyone with share privileges on a record can share it with additional users or teams.\n• None Anyone with share privileges on a record can set access rights for that record. These access rights control how a user who shares a record can access that record.\n• None Access on a shared record can be set to any access right, for example, read or write.\n• None Access rights on a shared record can be different for each user that the record is shared with.\n• None A record can be shared with the same security principal only one time. A user can share a record if they have share privileges on that record.\n• None Anyone with share privileges on a business record can modify the access rights for users who have the record shared.\n• None Anyone with share privileges on a business record can remove sharing for a specified user who has the record shared.\n• None Anyone with share privileges on a business record can remove sharing for all users with whom the record was previously shared.\n\nTo perform this action, the caller must have Associate Privileges and access rights on the records that are being updated.\n\nAssociate creates multiple associations in one transaction between the specified record and each record in the specified collection for the relationship specified.\n\nFor a one-to-many relationship, this method sets the ReferencingAttribute in the related record to the ID of the specified record.\n\nFor a many-to-many relationship, this method creates a record in the intersect table for the relationship, which contains the ID of both the referenced and referencing records. The intersect table name is defined in the IntersectEntityName property for the relationship.\n\nTo perform this action, the caller must have Disassociate Privileges and access rights on the records that are being updated.\n\nDisassociate reverses the associate operation, by updating the referenced and referencing records and deleting the intersect record where appropriate. For more information, see Associate.\n\nTo perform this action, the caller must have SetState Privileges and access rights on the records that are being updated. The SetStateRequest message updates the and attributes of the entity record.\n\nThere are several types of entity ownership. Most entities, including custom entities, are either owned by the organization or by a user or team. There are some business entities that do not have an owner, such as discount type (discount list), where the ownership is defined by its parent entity discount. Ownership type is configured at the time of entity (table) creation and changing ownership type later is not supported. The type of ownership defines some of the operations that can be performed on a record. Ownership for an entity is defined in the metadata property OwnershipType. The following table lists the ownership properties.\n\nYou can use the AssignRequest message to change the ownership of a record. For more information, see Assign. You can use the ReassignObjectsOwnerRequest or ReassignObjectsSystemUserRequest message to do bulk reassignment of all records for an owner.\n\nMost business entities have two properties to track the state of a record. These are , which is called Status in the Web application and , which is called Status Reason in the Web application. The and attribute values are linked. The attribute is used internally to represent the status of the entity. The attribute is used to display this value to the end user. The set of valid state codes for an entity is not customizable, but the status codes are customizable. For the case entity and custom entities, you can define additional criteria for valid transitions between statuses. For more information, see Customize Entity Attribute Metadata and Define custom state model transitions.\n\nCertain system entities have image attributes. You can add image attributes to custom entities. When an entity has an image attribute, you can set the PrimaryImageAttribute property to control whether the image will be shown in the application. When the image is shown in the application users of the web application can upload pictures for the entity record. The following system entities have image attributes. Those marked with an asterisk are enabled by default to show them in the application.\n\nAdministration and security entities\n\n Generate entity relationship diagrams\n\n Define custom state model transitions\n\n Model Your Business Data With Dynamics 365 Customer Engagement (on-premises)\n\n Entity Relationship Metadata\n\n Entity Relationship Behavior\n\n The Metadata and Data Models in Dynamics 365 Customer Engagement (on-premises)\n\n Extend the Metadata Model for Dynamics 365 Customer Engagement (on-premises)\n\n Package and Distribute Extensions with Dynamics 365 Customer Engagement (on-premises) Solutions\n\n IOrganizationService Entities\n\n The Security Model of Dynamics 365 Customer Engagement (on-premises)\n\n Sample: Set and retrieve entity images\n\n Sample: Assign a Record to a Team\n\n Sample: Share Records Using GrantAccess, ModifyAccess and RevokeAccess Messages\n\n Sample: Merge Two Records\n\n Sample: Validate Record State and Set State of the Record\n\n Sample: Rollup records related to a specific record"
    },
    {
        "link": "https://stackoverflow.com/questions/39433902/creating-multiple-entities-in-single-request-in-microsoft-dynamics-crm-odata",
        "document": "I know how to create a single entity in single request. However, one requirement wants me to create multiple entities (in my case it's multiple entries in ). I tried putting array to\n\nHowever this does not work and I could not find any documentation explaining me ways to achieve this. Any help would be greatly appreciated."
    }
]