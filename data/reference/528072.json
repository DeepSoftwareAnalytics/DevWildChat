[
    {
        "link": "https://docs.aiogram.dev",
        "document": "# Bot token can be obtained via https://t.me/BotFather # All handlers should be attached to the Router (or Dispatcher) # Most event objects have aliases for API methods that can be called in events' context # For example if you want to answer to incoming message you can use `message.answer(...)` alias # and the target chat will be passed to :ref:`aiogram.methods.send_message.SendMessage` Handler will forward receive a message back to the sender By default, message handler will handle all message types (like a text, photo, sticker etc.) # But not all the types is supported to be copied so need to handle it # Initialize Bot instance with default bot properties which will be passed to all API calls"
    },
    {
        "link": "https://docs.aiogram.dev/en/v2.25.1",
        "document": "aiogram is a pretty simple and fully asynchronous framework for Telegram Bot API written in Python 3.7 with asyncio and aiohttp. It helps you to make your bots faster and simpler.\n• None Can reply into webhook. (In other words make requests in response to updates)"
    },
    {
        "link": "https://restack.io/p/aiogram-tutorial-answer-best-telegram-bot-frameworks-for-ai-cat-ai",
        "document": "Before you start setting up Aiogram, ensure your development environment meets the following requirements:\n• Python 3.8+: Download and install Python from Python's official website.\n• Preferred IDE: Use Visual Studio Code or PyCharm for a better development experience.\n\nHomebrew is a package manager for MacOS that simplifies the installation of software. To install Homebrew, run the following command in your terminal:\n\nPyEnv allows you to easily switch between multiple versions of Python. Install it using Homebrew:\n\nNow, install Python 3.10 (or any version 3.8+):\n\nPoetry is a dependency management tool for Python. Install it with:\n\nFollow the prompts to set up your project details. After initialization, install the dependencies:\n\nTo install Aiogram, use the following command within your Poetry environment:\n\nOnce Aiogram is installed, you can create a simple bot to test your setup. Here’s a basic example:\n\nReplace with your actual bot token. Run the script to start your bot and test if it responds to the command. This confirms that your Aiogram setup is successful and you are ready to develop your bot further."
    },
    {
        "link": "https://github.com/aiogram/aiogram",
        "document": "aiogram is a modern and fully asynchronous framework for Telegram Bot API written in Python 3.8+ using asyncio and aiohttp.\n\nMake your bots faster and more powerful!\n• Has type hints (PEP 484) and can be used with mypy\n• Supports Telegram Bot API 8.3 and gets fast updates to the latest versions of the Bot API\n• Telegram Bot API integration code was autogenerated and can be easily re-generated when API gets updated\n\nIt is strongly advised that you have prior experience working with asyncio before beginning to use aiogram. If you have any questions, you can visit our community chats on Telegram:"
    },
    {
        "link": "https://restack.io/p/aiogram-3-answer-best-telegram-bot-frameworks-ai-cat-ai",
        "document": "To create a simple Aiogram 3 bot, we will follow a structured approach that includes setting up the bot, handling commands, and responding to user messages. This guide assumes you have basic knowledge of Python and the Aiogram framework.\n\nFirst, ensure you have Python installed on your machine. You can download it from python.org. Next, install the Aiogram library using pip:\n\nOnce you have Aiogram installed, you need to create a new bot on Telegram. Start by chatting with the BotFather to create a new bot and obtain your bot token. This token is essential for your bot to communicate with the Telegram API.\n\nHere’s a simple example of how to set up your bot:\n\nThis code initializes the bot and sets up a command handler for the and commands. When a user sends either command, the bot responds with a welcome message.\n\nTo make your bot interactive, you can add more handlers to respond to user messages. For example, you can create a handler for text messages:\n\nThis handler will echo back any text message sent to the bot. You can expand this functionality by adding more complex logic based on user input.\n\nWith this basic setup, you have a functional Aiogram 3 bot that can respond to commands and messages. You can further enhance your bot by integrating it with external APIs, adding more commands, and implementing state management using Aiogram's built-in features. For more detailed information, refer to the official Aiogram documentation."
    },
    {
        "link": "https://labex.io/tutorials/python-what-is-the-best-way-to-handle-date-and-time-calculations-in-python-395117",
        "document": "Python provides a powerful set of tools for working with dates and times, which are essential for a wide range of applications. In this section, we'll explore the fundamental concepts and usage of these tools.\n\nIn Python, the module is the primary way to work with dates and times. This module provides several classes, including , , , and , which allow you to represent and manipulate date and time information.\n\nThe class is the most commonly used, as it combines both date and time information into a single object. Here's an example of creating a object:\n\nThe and classes can be used to represent only the date or time components, respectively. The class is used to represent a duration or a difference between two dates or times.\n\nTime zones are an important aspect of working with dates and times, especially when dealing with data from different geographical locations. Python's module provides support for time zones through the library.\n\nHere's an example of working with time zones:\n\nIn this example, we create a object in the 'America/New_York' time zone, and then convert it to the UTC time zone.\n\nWhen working with dates and times, you often need to parse and format them for input and output purposes. Python's module provides several methods and functions for this purpose.\n\nHere's an example of parsing and formatting a date and time string:\n\nIn this example, we use the function to parse a date and time string, and the function to format a object as a string.\n\nBy understanding these fundamental concepts and techniques, you'll be well on your way to effectively handling dates and times in your Python applications."
    },
    {
        "link": "https://algocademy.com/blog/mastering-python-datetime-a-comprehensive-guide-to-date-and-time-handling-in-python",
        "document": "In programming, knowing how to work with dates and times is super important. Python has a special tool called the datetime module that makes it easy to handle all sorts of date and time tasks. This guide will help you understand how to use this module effectively, whether you’re scheduling events or analyzing data over time.\n• The datetime module is essential for managing dates and times in Python.\n• You can create date and time objects easily using built-in classes.\n• Formatting and parsing dates is straightforward with the datetime module.\n• Handling time zones can be done efficiently using additional libraries like pytz.\n\nThe datetime module in Python is a built-in library that helps you work with dates and times. It provides several classes, including Date, Time, Datetime, and Timedelta, each designed for specific tasks. To start using this module, you need to import it into your Python script. You can do this with the following command:\n\nThe datetime module is essential for handling various date and time operations. Here are some key points about it:\n• It allows you to create and manipulate date and time objects.\n• You can perform arithmetic operations on dates and times.\n\nTo use the datetime module, you can import it in two ways:\n\nThe main classes in the datetime module include:\n\nTo create a Date object, you can use the constructor from the module. This constructor requires three arguments: year, month, and day. Here’s how you can do it:\n\nOnce you have a Date object, you can easily access its components. Here are some attributes you can use:\n• : Gets the year of the date.\n• : Gets the month of the date.\n• : Gets the day of the date.\n\nYou can compare Date objects using standard comparison operators. Here’s how:\n• : Checks if one date is after another.\n• : Checks if one date is before another.\n• : Checks if two dates are the same.\n\nTo create a time object in Python, you can use the constructor from the module. This constructor takes up to four arguments: hour, minute, second, and microsecond. Here’s how you can do it:\n\nOnce you have a time object, you can easily access its components. Here are the main attributes you can use:\n\nYou can format time objects into readable strings using the method. This method allows you to specify how you want the time to be displayed. Here’s a simple example:\n\nIn summary, working with time objects in Python is straightforward. You can create them, extract their components, and format them for display. This makes handling time in your programs much easier!\n\nTo create a Datetime object, you can use the constructor from the datetime module. This constructor requires six arguments: year, month, day, hour, minute, and second. Here’s how you can do it:\n\nOnce you have a Datetime object, you can easily manipulate it. Here are some common operations:\n• Accessing components: You can get the year, month, day, hour, minute, and second from a Datetime object.\n• Comparing objects: You can compare two Datetime objects to see which one is earlier or later.\n• Arithmetic operations: You can add or subtract time using Timedelta objects.\n\nDatetime arithmetic allows you to perform calculations with dates and times. For example, you can add or subtract days, hours, or minutes. Here’s a simple example:\n\nBy understanding how to create and manipulate Datetime objects, you can effectively handle various date and time operations in your Python programs.\n\nThe class in Python’s datetime module represents a duration, which is the difference between two dates or times. You can create a object by specifying the duration in days, seconds, and other time units. Here’s how you can do it:\n\nYou can easily add or subtract time using . Here are some examples:\n• Adding time: To add 1 hour and 30 minutes to a specific time:\n• Subtracting time: To find the difference between two times:\n• Recurring events: You can also create recurring events by adding a in a loop.\n\nTo find the total seconds in a , you can use the method. For example:\n\nThe class is essential for anyone working with dates and times in Python. It helps in:\n\nBy mastering , you can handle time-related tasks with confidence and ease. Keep exploring the datetime module to unlock its full potential!\n\nIn Python, you can convert datetime objects into formatted strings using the method. This method allows you to specify format codes that represent different parts of the date and time. Here are some common format codes:\n\nFor example, to format a datetime object:\n\nTo convert a string into a datetime object, you can use the method. This method takes two arguments: the string to parse and the format of the string. For example:\n\nWhen working with dates and times, you might face some challenges:\n• Different string formats: Strings can come in various formats, making parsing tricky.\n• Leap years: Some dates only exist in leap years, which can cause errors.\n\nTime zones are regions of the Earth that have the same standard time. Handling time zones is crucial when working with datetime objects in Python. Without proper management, you might end up with incorrect time calculations.\n\nTo convert datetime objects between different time zones, you can use the library. Here’s how:\n• Create a timezone-aware datetime object: Use the method to assign a time zone to a naive datetime object.\n• Convert to another time zone: Use the method to change the time zone of your datetime object.\n\nDaylight Saving Time (DST) can affect time calculations. Here are some key points to remember:\n• DST changes can cause time to shift forward or backward.\n• Always check if a date falls within DST when performing calculations.\n\nBy understanding and managing time zones effectively, you can ensure accurate date and time handling in your Python applications.\n\nCreating a series of dates can be useful for various applications. You can generate date ranges using a simple loop or by utilizing libraries like . Here’s how you can do it:\n\nFinding the Day of the Week\n\nTo determine the day of the week for a specific date, you can use the method. This method returns an integer where Monday is 0 and Sunday is 6. Here’s a quick example:\n\nSometimes, you may need to convert between a object and a timestamp (the number of seconds since January 1, 1970). Here’s how:\n\nParsing dates from strings can be tricky due to different formats. Here are some common formats:\n\nTo handle these variations, you can use the function from the datetime module. This function helps convert a string into a datetime object, making it easier to work with dates.\n\nWhen working with dates and times, timezone differences can lead to confusion. Here are some tips to manage them:\n• Convert to local time only when displaying to users.\n• Use libraries like for accurate timezone handling.\n\nLeap years and leap seconds can complicate date calculations. Here’s how to manage them:\n• Leap Years: Use the module to check if a year is a leap year.\n• Leap Seconds: Be aware that they are rare and usually handled by the system clock.\n\nWorking with Dates in Different Calendars\n\nThe datetime module in Python mainly supports the Gregorian calendar. This is the calendar most commonly used worldwide. However, if you need to work with other calendars, you can use external libraries. Here are a few options:\n\nUsing External Libraries for Other Calendars\n\nTo work with different calendars, you can install libraries using pip. Here’s how:\n\nThese libraries allow you to create and manipulate dates in their respective formats easily.\n\nWhen working with various calendars, you may face some challenges:\n• Different month lengths: Not all calendars have the same number of days in a month.\n• Leap years: Some calendars have different rules for leap years.\n• Cultural differences: Some dates may have different significance in different cultures.\n\nIn summary, while Python’s datetime module is great for the Gregorian calendar, using external libraries can help you handle other calendars. This flexibility is essential for applications that require date handling across different cultures and systems. For example, you can create a list of dates within a date range in Python using the date and timedelta class and also using the pandas date_range() function.\n\nUsing Python’s datetime module, you can easily schedule tasks. Here are some common applications:\n\nPython’s datetime capabilities are essential for data analysis, especially in time-series data. You can:\n• Calculate averages and other statistics based on time intervals.\n\nTimestamping is crucial for tracking when events occur. You can:\n• Record the exact time an event happens.\n• Use timestamps for data integrity in databases.\n\nPython’s datetime module is super useful for many real-life tasks. You can use it to track time, manage dates, and even calculate how long something takes. If you’re curious about how to make the most of this tool, check out our website for more tips and tricks!\n\nIn this guide, we learned a lot about handling dates and times in Python. We explored how to create and change date and time objects using the datetime module. We also looked at some advanced tasks, like making date ranges and figuring out time differences. Plus, we talked about common problems, such as dealing with different time zones and leap years. With this knowledge, you can confidently manage dates and times in your Python projects. Remember, practice makes perfect, so keep experimenting with the examples and features of the datetime module. Happy coding!\n\nWhat is the Python datetime module?\n\nThe Python datetime module is a built-in tool that helps you work with dates and times. It allows you to create, manipulate, and format date and time objects easily.\n\nHow do I create a date object in Python?\n\nYou can create a date object by using the `date` class from the datetime module. For example, you can use `datetime.date(2023, 10, 5)` to create a date for October 5, 2023.\n\nYes, you can compare date objects in Python. You can use comparison operators like `==`, `!=`, `<`, `>`, and so on to see which date comes first.\n\nHow can I format a date in Python?\n\nYou can format a date using the `strftime` method. For example, `date_object.strftime(‘%Y-%m-%d’)` will give you a string like ‘2023-10-05’.\n\nWhat is a timedelta in Python?\n\nA timedelta is a class in the datetime module that represents a duration, or the difference between two dates or times. You can use it to add or subtract time.\n\nHow do I work with time zones in Python?\n\nYou can handle time zones using the `pytz` library. This library allows you to convert between different time zones and manage daylight saving time.\n\nWhat are some common challenges when working with dates and times?\n\nSome common challenges include parsing dates from strings, handling different time formats, and managing leap years or leap seconds.\n\nHow can I find the current date and time in Python?\n\nYou can find the current date and time by using `datetime.datetime.now()`. This will give you a datetime object representing now."
    },
    {
        "link": "https://realpython.com/python-datetime",
        "document": "Working with dates and times is one of the biggest challenges in programming. Between dealing with time zones, daylight saving time, and different written date formats, it can be tough to keep track of which days and times you’re referencing. Fortunately, the built-in Python module can help you manage the complex nature of dates and times.\n• Why programming with dates and times is such a challenge\n• Which functions are available in the Python module\n• How to print or read a date and time in a specific format\n• How to do arithmetic with dates and times\n\nPlus, you’re going to develop a neat application to count down the time remaining until the next PyCon US!\n\nAs you can see, working with dates and times in programming can be complicated. Fortunately, you rarely need to implement complicated features from scratch these days since many open-source libraries are available to help out. This is definitely the case in Python, which includes three separate modules in the standard library to work with dates and times:\n• outputs calendars and provides functions using an idealized Gregorian calendar.\n• provides time-related functions where dates are not needed. In this tutorial, you’ll focus on using the Python module. The main focus of is to make it less complicated to access attributes of the object related to dates, times, and time zones. Since these objects are so useful, also returns instances of classes from . is less powerful and more complicated to use than . Many functions in return a special instance. This object has a named tuple interface for accessing stored data, making it similar to an instance of . However, it doesn’t support all of the features of , especially the ability to perform arithmetic with time values. provides three classes that make up the high-level interface that most people will use:\n• is an idealized date that assumes the Gregorian calendar extends infinitely into the future and past. This object stores the , , and as attributes.\n• is an idealized time that assumes there are 86,400 seconds per day with no leap seconds. This object stores the , , , , and (time zone information).\n• is a combination of a and a . It has all the attributes of both classes. The three classes that represent dates and times in have similar initializers. They can be instantiated by passing keyword arguments for each of the attributes, such as , , or . You can try the code below to get a sense of how each object is created: In this code, you import the three main classes from and instantiate each of them by passing arguments to the constructor. You can see that this code is somewhat verbose, and if you don’t have the information you need as integers, these techniques can’t be used to create instances. Fortunately, provides several other convenient ways to create instances. These methods don’t require you to use integers to specify each attribute, but instead allow you to use some other information:\n• creates a instance with the current local date and time.\n• combines instances of and into a single instance. These three ways of creating instances are helpful when you don’t know in advance what information you need to pass into the basic initializers. You can try out this code to see how the alternate initializers work: In this code, you use , , and to create instances of , , and objects. Each instance is stored in a different variable:\n• is a instance that has only the year, month, and day.\n• is a instance that has the year, month, day, hour, minute, second, and microseconds.\n• is a instance that has the hour, minute, and second set to the same values as . On the last line, you combine the date information in with the time information in to produce a new instance. Warning: also provides , which returns an instance of at the current UTC. However, the Python documentation recommends against using this method because it doesn’t include any time zone information in the resulting instance. Using may produce some surprising results when doing arithmetic or comparisons between instances. In a later section, you’ll see how to assign time zone information to instances. Another way to create instances is to use . To use this method, you provide a string with the date in the ISO 8601 format that you learned about earlier. For instance, you might provide a string with the year, month, and date specified: This string represents the date January 31, 2020, according to the ISO 8601 format. You can create a instance with the following example: In this code, you use to create a instance for January 31, 2020. This method is very useful because it’s based on the ISO 8601 standard. But what if you have a string that represents a date and time but isn’t in the ISO 8601 format? Fortunately, Python provides a method called to handle this situation. This method uses a special mini-language to tell Python which parts of the string are associated with the attributes. To construct a from a string using , you have to tell Python what each of the parts of the string represents using formatting codes from the mini-language. You can try this example to see how works: On line 1, you create , which represents the date and time January 31, 2020, at 2:45:37 PM. On line 2, you create , which uses the mini-language to specify how the parts of will be turned into attributes. In , you include several formatting codes and all of the dashes ( ), colons ( ), and spaces exactly as they appear in . To process the date and time in , you include the following formatting codes: A complete listing of all of the options in the mini-language is outside the scope of this tutorial, but you can find several good references on the web, including in Python’s documentation and on a website called strftime.org. Now that and are defined, you can use them to create a instance. Here’s an example of how works: In this code, you import on line 3 and use with and on line 4. Finally, line 5 shows the values of the attributes in the instance created by . You can see that they match the values shown in the table above. Note: There are more advanced ways to create instances, but they involve using third-party libraries that must be installed. One particularly neat library is called , which allows you to provide natural language string inputs. The input is even supported in a number of languages: In this code, you use to create two instances by passing two different string representations of time. On line 1, you import . Then, on line 2, you use with the argument to create a instance twenty-four hours in the past. At the time of writing, this was March 13, 2020, at 2:39 PM. On line 3, you use with the argument . Morgen is the German word for tomorrow, so creates a instance twenty-four hours in the future. At the time of writing, this was March 15 at 2:39 PM.\n\nNow you have enough information to start working on a countdown clock for next year’s PyCon US! PyCon US 2021 will start on May 12, 2021 in Pittsburgh, PA. With the 2020 event having been canceled, many Pythonistas are extra excited for next year’s gathering. This is a great way to keep track of how long you’ll need to wait and boost your skills at the same time! To get started, create a file called and add this code: In this code, you import from and define a constant, , that stores the date of the next PyCon US. You don’t expect the date of PyCon to change, so you name the variable in all caps to indicate that it’s a constant. Next, you compute the difference between , which is the current time, and . Taking the difference between two instances returns a instance. instances represent the change in time between two instances. The delta in the name is a reference to the Greek letter delta, which is used in science and engineering to mean a change. You’ll learn more later about how to use for more general arithmetic operations. Finally the printed output, as of April 9, 2020 at a little before 9:30 PM is: Only 397 days until PyCon US 2021! This output is a little clunky, so later on you’ll see how you can improve the formatting. If you run this script on a different day, you’ll get a different output. If you run the script after May 12, 2021 at 8:00 AM, you’ll get a negative amount of time remaining!\n\nAs you saw earlier, storing the time zone in which a date occurs is an important aspect of ensuring your code is correct. Python provides , which is an abstract base class that allows and to include time zone information, including an idea of daylight saving time. However, does not provide a direct way to interact with the IANA time zone database. The Python documentation recommends using a third-party package called . You can install with : Note that the name of the package that you install from PyPI, , is different from the name that you use to import the package, which is just . One reason that is so useful is that it includes an interface to the IANA time zone database. This takes the hassle out of assigning time zones to your instances. Try out this example to see how to set a instance to have your local time zone: In this example, you import from and from . You then create a instance set to the current time using . You also pass the keyword to and set equal to . In , returns a concrete instance of . This means that it can represent all the necessary time zone offset and daylight saving time information that needs. You also print the name of the time zone using , which prints . This is the output for Windows, but on macOS or Linux, your output might read if you’re in the US Eastern time zone during the winter. You can also create time zones that are not the same as the time zone reported by your computer. To do this, you’ll use and pass the official IANA name for the time zone you’re interested in. Here’s an example of how to use : In this example, you use to retrieve the time zone information for London, United Kingdom and store it in . You then retrieve the current time, setting the time zone to . On Windows, this gives the attribute the value . On macOS or Linux, the attribute will look something like , but it might be slightly different depending on where pulls the time zone data from. You also use to print the name of the time zone, which is now , meaning Greenwich Mean Time. This output is the same on Windows, macOS, and Linux. In an earlier section, you learned that you shouldn’t use to create a instance at the current UTC. Now you know how to use to supply a time zone to the instance. Here’s an example modified from the recommendation in the Python documentation: In this code, you use to set the time zone of to the UTC time zone. This method is recommended over using because returns a naive instance, whereas the method demonstrated here returns an aware instance. Next, you’ll take a small detour to learn about naive vs aware instances. If you already know all about this, then you can skip ahead to improve your PyCon countdown with time zone information. Python instances support two types of operation, naive and aware. The basic difference between them is that naive instances don’t contain time zone information, whereas aware instances do. More formally, to quote the Python documentation: An aware object represents a specific moment in time that is not open to interpretation. A naive object does not contain enough information to unambiguously locate itself relative to other date/time objects. (Source) This is an important distinction for working with Python . An aware instance can compare itself unambiguously to other aware instances and will always return the correct time interval when used in arithmetic operations. Naive instances, on the other hand, may be ambiguous. One example of this ambiguity relates to daylight saving time. Areas that practice daylight saving time turn the clocks forward one hour in the spring and backward one hour in the fall. This typically happens at 2:00 AM local time. In the spring, the hour from 2:00 AM to 2:59 AM never happens, and in the fall, the hour from 1:00 AM to 1:59 AM happens twice! Practically, what happens is that the offset from UTC in these time zones changes throughout the year. IANA tracks these changes and catalogs them in the different database files that your computer has installed. Using a library like , which uses the IANA database under the hood, is a great way to make sure that your code properly handles arithmetic with time. Note: In Python, the difference between naive and aware instances is determined by the attribute. An aware instance has the attribute equal to a subclass of the abstract base class. Python 3.8 and below provide one concrete implementation of called . However, is limited to expressing fixed offsets from UTC that cannot change throughout the year, so it isn’t that useful when you need to account for changes such as daylight saving time. Python 3.9 includes a new module called that provides a concrete implementation of that tracks the IANA database, so it includes changes like daylight saving time. However, until Python 3.9 becomes widely used, it probably makes sense to rely on if you need to support multiple Python versions. also provides several concrete implementations of in the module that you used earlier. You can check out the documentation for more information. This doesn’t mean that you always need to use aware instances. But aware instances are crucial if you’re comparing times with each other, especially if you’re comparing times in different parts of the world.\n\nNow that you know how to add time zone information to a Python instance, you can improve your PyCon countdown code. Earlier, you used the standard constructor to pass the year, month, day, and hour that PyCon will start. You can update your code to use the module, which provides a more natural interface for creating instances: In this code, you import and from and from . Next, you use to read the date of the next PyCon US from a string. This is much more readable than the plain constructor. returns a naive instance, so you use to change the to the time zone. PyCon US 2021 will take place in Pittsburgh, Pennsylvania, which is in the US Eastern time zone. The canonical name for that time zone is since New York City is the largest city in the time zone. is an aware instance with the time zone set to US Eastern time. Since May 12 is after daylight saving time takes effect, the time zone name is , or . Next, you create to represent the current instant of time and give it your local time zone. Last, you find the between and and print the result. If you’re in a locale that does not adjust the clocks for daylight saving time, then you may see the number of hours remaining until PyCon change by an hour.\n\nPython instances support several types of arithmetic. As you saw earlier, this relies on using instances to represent time intervals. is very useful because it’s built into the Python standard library. Here’s an example of how to work with : In this code, you create , which stores the current time, and , which is a of days. Next, you add and to produce a instance one day in the future. Note that working with naive instances, as you are here, means that the attribute of the increments by one and does not account for any repeated or skipped time intervals. instances also support negative values as the input to the arguments: In this example, you provide as the input to , so when you add and , the result is a decrease by one in the attribute. instances support addition and subtraction as well as positive and negative integers for all arguments. You can even provide a mix of positive and negative arguments. For instance, you might want to add three days and subtract four hours: In this example, you add three days and subtract four hours, so the new is at January 29 at 5:37 AM. is very useful in this way, but it’s somewhat limited because it cannot add or subtract intervals larger than a day, such as a month or a year. Fortunately, provides a more powerful replacement called . The basic syntax of is very similar to . You can provide keyword arguments that produce changes of any number of years, months, days, hours, seconds, or microseconds. You can reproduce the first example with this code: In this example, you use instead of to find the corresponding to tomorrow. Now you can try adding five years, one month, and three days to while subtracting four hours and thirty minutes: Notice in this example that the date ends up as March 1, 2025. This is because adding three days to would be January 29, and adding one month to that would be February 29, which only exists in a leap year. Since 2025 is not a leap year, the date rolls over to the next month. You can also use to calculate the difference between two instances. Earlier, you used the subtraction operator to find the difference between two Python instances, and . With , instead of using the subtraction operator, you need to pass the two instances as arguments : In this example, you create a new instance for by incrementing the field by one. Then, you use and pass and as the two arguments. then takes the difference between these two instances and returns the result as a instance. In this case, the difference is days, since happens before . objects have countless other uses. You can use them to find complex calendar information, such as the next year in which October the 13th falls on a Friday or what the date will be on the last Friday of the current month. You can even use them to replace attributes of a instance and create, for example, a one week in the future at 10:00 AM. You can read all about these other uses in the documentation.\n\nYou now have enough tools in your belt to finish your PyCon 2021 countdown clock and provide a nice interface to use as well. In this section, you’ll use to calculate the time remaining until PyCon, develop a function to print the time remaining in a nice format, and show the date of PyCon to the user. Using in Your PyCon Countdown First, replace the plain subtraction operator with . With the subtraction operator, your object couldn’t count intervals of time larger than a day. However, allows you to show the years, months, and days remaining: The only change that you made in this code was to replace line 11 with . The output from this script should tell you that PyCon US 2021 will happen in about one year and one month, depending on when you run the script. However, that output isn’t very pretty since it looks like the signature of . You can build up some prettier output by replacing line 11 in the previous code with the code below: This code requires Python 3.8 because it uses the new walrus operator. You can make this script work on older versions of Python by using a traditional loop in place of line 17. In this code, you define , which takes two arguments, the unit of time and the instance from which the time units should be retrieved. If the amount of time is not equal to zero, then returns a string with the amount of time and the time unit. Otherwise, it returns an empty string. You use in the comprehension on line 17. That line creates a generator storing the non-empty strings returned from . It uses the walrus operator to assign the return value of to and includes only if it is . Finally, line 18 prints the final output using on the generator. Next, you’ll take a look at including the PyCon date in the output from your script. Earlier, you learned about creating instances using . This method uses a special mini-language within Python to specify how the date string is formatted. Python has an additional method called that allows you to format a instance to a string. In a sense, it’s the reverse operation of parsing using . You can differentiate between the two methods by remembering that the in stands for parse, and the in stands for format. In your PyCon countdown, you can use to print output to let the user know the date on which PyCon US will start. Remember, you can find the formatting codes that you want to use on strftime.org. Now add this code on line 18 of your PyCon countdown script: \"PyCon US 2021 will start on:\" In this code, line 18 uses to create a string representing the starting date of PyCon US 2021. The output includes the weekday, month, day, year, hour, minute, AM or PM, and time zone: Wednesday, May 12, 2021 at 08:00 AM EDT On line 19, you print this string for the user to see with some explanatory text. The last line prints the amount of time remaining until the PyCon start date. Next, you’ll finish your script to make it easier for other people to reuse. The final step that you’ll want take is to follow Python best practices and put the code that produces output into a function. You can check out the full, final code after applying all these changes: \"PyCon US 2021 will start on:\" In this code, you move and the code used for the generator into . On line 23, you use the guard clause to make sure that only runs when this file is executed as a script. This allows other people to import your code and reuse , for instance, if they’d like. Now you can modify this script as much as you want. One neat thing to do might be to allow the user to change the time zone associated with by passing a command-line argument. You could also change the to something closer to home, say PyCon Africa or EuroPython. To get even more excited about PyCon, check out Real Python at PyCon US 2019 and How to Get the Most Out of PyCon!"
    },
    {
        "link": "https://dataquest.io/blog/python-datetime-tutorial",
        "document": "Dealing with dates and times in Python can be a hassle. Thankfully, there’s a built-in way of making it easier: the Python datetime module.\n\nhelps us identify and process time-related elements like dates, hours, minutes, seconds, days of the week, months, years, etc. It offers various services like managing time zones and daylight savings time. It can work with timestamp data. It can extract the day of the week, day of the month, and other date and time formats from strings.\n\nIn short, it’s a really powerful way of handling anything date and time related in Python. So let’s get into it!\n\nIn this tutorial, we’ll learn about python datetime functions in detail, including:\n• Getting year and month from the date\n• Getting month day and Weekday from date\n• Getting hour and minutes from the date\n• Getting Week number of the year from date\n• Getting the difference between two dates and times\n• Working with Pandas datetime objects\n• Getting weekday and day of year\n\nAs you work through this tutorial, we’d encourage you to run the code on your own machine. Alternatively, if you’d like to run code in your browser and learn in an interactive fashion with answer-checking to be sure you’re getting it right, our Python intermediate course has a lesson on datetime in Python that we recommend. You can start learning by signing up for a free user account.\n\nBefore jumping into writing code, it’s worth looking at the five main object classes that are used in the module. Depending on what we’re trying to do, we’ll likely need to make use of one or more of these distinct classes:\n• datetime – Allows us to manipulate times and dates together (month, day, year, hour, second, microsecond).\n• date – Allows us to manipulate dates independent of time (month, day, year).\n• time – Allows us to manipulate time independent of date (hour, minute, second, microsecond).\n• timedelta— A duration of time used for manipulating dates and measuring.\n• tzinfo— An abstract class for dealing with time zones.\n\nIf those distinctions don’t make sense yet, don’t worry! Let’s dive into and start working with it to better understand how these are applied.\n\nFirst, let’s take a closer look at a object. Since is both a module and a class within that module, we’ll start by importing the class from the module.\n\nThen, we’ll print the current date and time to take a closer look at what’s contained in a object. We can do this using ‘s function. We’ll print our datetime object, and then also print its type using so we can take a closer look.\n\nWe can see from the results above that is indeed a object of the class. This includes the year, month, day, hour, minute, second, and microsecond.\n\nExtract Year and Month from the Date\n\nNow we’ve seen what makes up a object, we can probably guess how and objects look, because we know that objects are just like without the time data, and objects are just like without the date data.\n\nWe can also antipate some problems. For example, in most data sets, date and time information is stored in string format! Also, we may not want all of this date and time data — if we’re doing something like a monthly sales analysis, breaking things down by microsecond isn’t going to be very useful.\n\nSo now, let’s start digging into a common task in data science: extracting only the elements that we actually want from a string using .\n\nTo do this, we need to do a few things.\n\nHandling Date and Time Strings with strptime() and strftime()\n\nThankfully, includes two methods, and , for converting objects from strings to objects and vice versa. can read strings with date and time information and convert them to objects, and converts datetime objects back into strings.\n\nOf course, isn’t magic — it can’t turn any string into a date and time, and it will need a little help from us to interpret what it’s seeing! But it’s capable of reading most conventional string formats for date and time data (see the documentation for more details). Let’s give it a date string in YYYY-MM-DD format and see what it can do!\n\nNote that took two arguments: the string ( ) and \" A full list of these patterns is available in the documentation, and we’ll go into these methods in more depth later in this tutorial. You may also have noticed that a time of has been added to the date. That’s because we created a object, which must include a date and a time. is the default time that will be assigned if no time is designated in the string we’re inputting. Anyway, we were hoping to separate out specific elements of the date for our analysis. One way can do that using the built-in class attributes of a datetime object, like or : Getting Day of the Month and Day of the Week from a Date Let’s do some more extraction, because that’s a really common task. This time, we’ll try to get the day of the month and the day of the week from . Datetime will give us the day of the week as a number using its function, but we can convert this to a text format (i.e. Monday, Tuesday, Wednesday…) using the module and a method called . We’ll start by importing , and then using and on . From there, we can get the day of the week in text format like so: import calendar print('Day of Month:', my_date.day) print('Day of Week (number): ', my_date.weekday()) print('Day of Week (name): ', calendar.day_name[my_date.weekday()]) Day of Month: 31 Day of Week (number): 3 Day of Week (name): Thursday Wait a minute, that looks a bit odd! The third day of the week should be Wednesday, not Thursday, right? Let’s take a closer look at that variable using a for loop: Now we can see that Python starts weeks on Monday and counts from the index 0 rather than starting at 1. So it makes sense that the number 3 is converted to “Thursday” as we saw above. Getting Hours and Minutes From a Python Datetime Object Now let’s dig into time and extract the hours and minutes from datetime object. Much like what we did above with month and year, we can use class attributes and to get the hours and minutes of the day. Let’s set a new date and time using the function. As of this writing, it’s October 25, 2019 at 10:25 AM. You’ll get different results depending on when you choose to run this code, of course! Getting Week of the Year from a Datetime Object We can also do fancier things with . For example, what if we want to know what week of the year it is? We can get the year, week of the year, and day of the week from a object with the function. Specifically, returns a tuple with ISO year, week number and weekday. The ISO calendar is a widely-used standard calendar based on the Gregorian calendar. You can read about it in more detail at that link, but for our purposes, all we need to know is that it works as a regular calendar, starting each week on Monday. Note that in the ISO calendar, the week starts counting from 1, so here 5 represents the correct day of the week: Friday. We can see from the above that this is the 43rd week of the year, but if we wanted to isolate that number, we could do so with indexing just as we might for any other Python list or tuple: In programming, it’s not uncommon to encounter time and date data that’s stored as a timestamp, or to want to store your own data in Unix timestamp format. We can do that using datetime’s built-in function, which takes a object as an argument and returns that date and time in timestamp format: from datetime import datetime now = datetime.now() timestamp = datetime.timestamp(now) print(\"Date and Time :\", now) print(\"Timestamp:\", timestamp) Similarly, we can do the reverse conversion using . This is a function that takes a timestamp (in float format) as an argument and returns a object, as below: Often, we may want to measure a span of time, or a duration, using Python datetime. We can do this with its built-in class. A object represents the amount of time between two dates or times. We can use this to measure time spans, or manipulate dates or times by adding and subtracting from them, etc. By default a timedelta object has all parameters set to zero. Let’s create a new timedelta object that’s two weeks long and see how that looks: Note that we can get our time duration in days by using the class attribute . As we can see in its documentation, we can also get this time duration in seconds or microseconds. Let’s create another timedelta duration to get a bit more practice: Now let’s start doing using timedelta objects together with datetime objects to do some math! Specifically, let’s add a few diffeent time durations to the current time and date to see what date it will be after 15 days, what date it was two weeks ago. To do this, we can use the or operators to add or subtract the timedelta object to/from a datetime object. The result will be the datetime object plus or minus the duration of time specified in our timedelta object. Cool, right? (Note: in the code below, it’s October 25 at 11:12 AM; your results will differ depending on when you run the code since we’re getting our object using the function). from datetime import datetime, timedelta now = datetime.now() print (\"Today's date: \", str(now)) future_date_after_15days = now + timedelta(days = 15) print('Date after 15 days: ', future_date_after_15days) two_weeks_ago = now - timedelta(weeks = 2) print('Date two weeks ago: ', two_weeks_ago) print('two_weeks_ago object type: ', type(two_weeks_ago)) Note that the output of these mathematical operations is still a object. Find the Difference Between Two Dates and Times Similar to what we did above, we can also subtract one date from another date to find the timespan between them using datetime. Because the result of this math is a duration, the object produced when we subtract one date from another will be a object. Here, we’ll create two objects (remeber, these work the same as objects, they just don’t include time data) and subtract one from the other to find the duration: Above, we used only dates for the sake of clarity, but we can do the same thing with objects to get a more precise measurement that includes hours, minutes, and seconds as well: Formatting Dates: More on strftime() and strptime() We touched briefly on and earlier, but let’s take a closer look at these methods, as they’re often important for data analysis work in Python. is the method we used before, and you’ll recall that it can turn a date and time that’s formatted as a text string into a datetime object, in the following format: Note that it takes two arguments:\n• string − the time in string format that we want to convert\n• format − the specific formatting of the time in the string, so that strptime() can parse it correctly Let’s try converting a different kind of date string this time. This site is a really useful reference for finding the formatting codes needed to help interpret our string input. Now let’s do something a bit more advanced to practice everything we’ve learned so far! We’ll start with a date in string format, convert it to a datetime object, and look at a couple different ways of formatting it (dd/mm and mm/dd). Then, sticking with the mm/dd formatting, we’ll convert it into a Unix timestamp. Then we’ll convert it back into a object, and convert that back into strings using a few different strftime patterns to control the output: Here’s an image you can save with a cheat sheet for common, useful strptime and strftime patterns: Let’s get a little more practice using these: Working with dates and times in Pythin can get even more complicated when timezones get involved. Thankfully, the module exists to help us deal with cross-timezone conversions. It also handles the daylight savings time in locations that use that. We can use the function to add a time zone location to a Python datetime object. Then we can use the function to convert the existing local time zone into any other time zone we specify (it takes the time zone we want to convert into as an argument). This module can help make life simpler when working with data sets that include multiple different time zones. Data scientists love for many reasons. One of them is that it contains extensive capabilities and features for working with time series data. Much like itself, pandas has both and objects for specifying dates and times and durations, respectively. We can convert date, time, and duration text strings into pandas Datetime objects using these functions:\n• to_timedelta(): Finds differences in times in terms of days, hours, minutes, and seconds. And as we’ll see, these functions are actually quite good at converting strings to Python datetime objects by detecting their format automatically, without needing us to define it using strftime patterns. Let’s look at a quick example: Note that even though we gave it a string with some complicating factors like a “th” and “sep” rather than “Sep.” or “September”, pandas was able to correctly parse the string and return a formatted date. We can also use pandas (and some of its affiliated numpy functionality) to create date ranges automatically as pandas Series. Below, for example, we create a series of twelve dates starting from the day we defined above. Then we create a different series of dates starting from a predefined date using : We can easily get year, month, day, hour, or minute from dates in a column of a pandas dataframe using attributes for all columns. For example, we can use to extract only the year from a pandas column that includes the full date. To explore this, let’s make a quick DataFrame using one of the Series we created above: Now, let’s create separate columns for each element of the date by using the relevant Python datetime (accessed with ) attributes: Get Weekday and Day of Year Pandas is also capable of getting other elements, like the day of the week and the day of the year, from its datetime objects. Again, we can use attributes to do this. Note that here, as in Python generally, the week starts on Monday at index 0, so day of the week 5 is Saturday. We can also use pandas to make a datetime column into the index of our DataFrame. This can be very helpful for tasks like exploratory data visualization, because matplotlib will recognize that the DataFrame index is a time series and plot the data accordingly. To do this, all we have to do is redefine : In this tutorial, we’ve taken a deep dive into Python datetime, and also done some work with pandas and the calendar module. We’ve covered a lot, but remember: the best way to learn something is by actually writing code yourself! If you’d like to practice writing code with interactive answer-checking, check out our Python intermediate course for a lesson on datetime in Python with interactive answer-checking and in-browser code-running."
    },
    {
        "link": "https://medium.com/@AlexanderObregon/how-to-work-with-dates-and-times-in-python-for-beginners-858f8b9d36d0",
        "document": "Python’s module is a powerful library for handling dates and times. It allows developers to perform a variety of operations like formatting, comparing, and arithmetic operations. In this beginner-friendly article, we'll explore the fundamentals of working with dates and times in Python using the module, providing examples to demonstrate its functionality.\n\nThe Basics of the datetime Module\n\nThe module provides classes for working with dates and times. These include , which represents a calendar date; , which represents a specific time of day; , which combines date and time; and , which represents the difference between two dates or times.\n\nTo start using the module, you first need to import it:\n\nThis line of code gives you access to all the classes and methods in the module, enabling you to work with dates and times effectively.\n\nThe module allows you to create objects that represent specific dates, times, or a combination of both.\n• : This creates a date object for November 10, 2024. The format is .\n• : This creates a time object for 2:30:45 PM. The format is .\n• : This combines a date and a time into a single object. The format is .\n\nThese objects are helpful when you need to represent or manipulate specific points in time.\n\nGetting the Current Date and Time\n\nTo get the current date and time, you can use the or methods provided by the module.\n• : This method returns the current date and time as a object. It's useful for timestamping events or logging.\n• : This method returns the current date as a date object without the time component. It’s commonly used when only the date is needed without any associated time.\n\nFormatting, Comparing, and Performing Arithmetic with Dates and Times\n\nThe module in Python provides a comprehensive set of tools for working with date and time formatting, comparisons, and arithmetic. Understanding how to utilize these features allows for flexible manipulation of date and time data.\n\nThe method allows you to format date and time objects into custom string representations. This makes dates and times more readable or compatible with other systems. It uses format codes to customize the output.\n\nThe method converts a object into a string using format codes.\n• generates the full date and time in a readable “Year-Month-Day Hour:Minute:Second” format.\n• outputs the full name of the day of the week (e.g., \"Sunday\").\n• provides the abbreviated month name (e.g., \"Nov\").\n\nEach format code specifies a part of the date or time, allowing you to customize the output to fit your needs.\n\nThe method is used to convert a string representation of a date and time into a object. This is helpful for working with data from external sources, like logs or user input.\n\nThe method takes a date-time string and a format string to convert it into a object.\n• The method identifies each component (year, month, day, etc.) from the input string and creates a object.\n\nThis method is especially useful when dealing with timestamps in text format, enabling you to manipulate them as Python objects.\n\nYou can compare two objects to check which one occurs earlier, later, or if they are the same. The module supports direct comparison using standard operators like , , , , , and .\n• Here, and are objects representing specific calendar dates.\n• Using the , , and operators, the code determines whether occurs earlier, later, or is equal to .\n\nThis is particularly useful in tasks like scheduling, validating deadlines, or comparing historical events.\n\nobjects, which include both date and time, can also be compared using the same operators. This is especially helpful when you need precision down to the minute or second.\n• The comparison checks if (2:30 PM) occurs before (4:45 PM) on the same day.\n• Since objects include both date and time, the comparison takes both components into account.\n\nThis functionality is ideal for applications that require precision, such as event logging, activity tracking, or validating time-sensitive processes.\n\nThe class in the module is used to represent a duration, making it possible to perform arithmetic operations on dates and times. You can add or subtract days, hours, or other time units to/from a date or time object.\n\nUsing the class, you can add or subtract durations (like days) to/from a date.\n\nThis is helpful in scenarios like calculating due dates or determining past events.\n\nIn addition to days, the class can represent finer time adjustments such as hours, minutes, and seconds, enabling precise modifications of objects.\n\ncan include hours, minutes, and seconds for more precise adjustments.\n• Adding shifts the time forward by 2 hours and 45 minutes.\n\nThese adjustments are particularly useful in time-sensitive applications, like scheduling events or modifying log timestamps.\n\nThe difference between two dates or times results in a object, which can be used to find the duration in days, seconds, or a combination of both.\n\nThe difference between two dates is calculated as a object.\n• The subtraction of two dates results in a object.\n• The attribute extracts the number of days between and (45 in this case).\n\nThis is commonly used in applications like project tracking or calculating time spans between events.\n\nFor more precise differences, you can use the method of a object and break it down into hours, minutes, or seconds.\n\nThe object provides the total duration between two datetime objects in seconds.\n• The method returns the duration in seconds, allowing for finer granularity.\n• Integer division ( ) calculates the full hours, while modulo ( ) computes the remaining minutes.\n\nThis approach is useful for analyzing shorter durations, such as meeting lengths or work hours.\n\nThe module in Python provides a straightforward way to handle dates and times. From creating and formatting to comparing and performing arithmetic, it covers a wide range of needs. By understanding its features, you can effectively work with date and time data in your applications.\n\nThank you for reading! If you find this article helpful, please consider highlighting, clapping, responding or connecting with me on Twitter/X as it’s very appreciated and helps keeps content like this free!"
    }
]