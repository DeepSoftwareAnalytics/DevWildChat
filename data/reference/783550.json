[
    {
        "link": "https://api.jquery.com",
        "document": "Selects all the elements that are the nth-child of their parent in relation to siblings with the same element name, counting from the last element to the first."
    },
    {
        "link": "https://stackoverflow.com/questions/4671852/how-to-bind-to-localstorage-change-event-using-jquery-for-all-browsers",
        "document": "It turns out that this is actually working correctly and I have misinterpreted the specification\n\nWhen the setItem(), removeItem(), and clear() methods are called on a Storage object x that is associated with a local storage area, if the methods did something, then in every Document object whose Window object's localStorage attribute's Storage object is associated with the same storage area, other than x, a storage event must be fired\n\nIn other words, a storage event is fired on every window/tab except for the one that updated the object and caused the event.\n\nSo the event was not fired because I only had one window/tab open. If I place the above code in a page and open the page in two tabs I would see the event fired in the second tab.\n\nThis answer on the problem contains more details."
    },
    {
        "link": "https://api.jquery.com/category/version/3.6",
        "document": "All the aspects of the API that were added, or had a new signature added, in the corresponding version of jQuery.\n\nReturning JSON even for JSONP erroneous responses is working again, a few focus fixes.\n\nFor more information, see the Release Notes/Changelog."
    },
    {
        "link": "https://stackoverflow.com/questions/40791207/setting-and-getting-localstorage-with-jquery",
        "document": "You said you are attempting to get the text from a div and store it on local storage.\n\nPlease Note: Text and Html are different. In the question you mentioned text. will return Html content like . if you want to get Text content then you have to use instead of then the result will be instead of . Anyway, I am using your terminology let it be Text.\n\nStep 1: get the text from div.\n\nwhat you did is not get the text from div but set the text to a div.\n\nis actually setting text to div and the output will be a jQuery object. That is why it sets it as .\n\nTo get the text you have to write like this\n\n\n\nThis will return a string not an object so the result will be in your case.\n\nYour approach is correct and you can write it as\n\nBut the preferred approach is\n\nkey and value must be strings.\n\nso in your context code will become\n\nBut I don't find any meaning in your code. Because you want to get the text from div and store it on local storage. And again you are reading the same from local storage and set to div. just like\n\nIf you are facing any other problems please update your question accordingly."
    },
    {
        "link": "https://clouddevs.com/jquery/local-storage",
        "document": "jQuery and Google Maps: Adding Maps to Your Website"
    },
    {
        "link": "https://stackoverflow.com/questions/49153200/using-localstorage-to-pass-data-between-different-pages",
        "document": "I have a shopping basket where i want a user to be able to click on a button that takes them to a separate page whilst capturing their shopping basket contents (item names, quantities, prices, etc). At the moment i'm using localStorage to send just the item names to my new page however the only item that ever prints is the last item to be placed in a basket (i'm not sure how to stop localStorage overwriting data like it does).\n\nThis is the itemName section on the basket page.\n\nThis is a script i have on my basket page.\n\nThis is the script on a new page\n\nI'm getting the following output which is the last item in the basket (there's 4 items in the basket).\n\nI should be getting.\n\nBelow is my shopping cart"
    },
    {
        "link": "https://rxdb.info/articles/localstorage.html",
        "document": "When it comes to client-side storage in web applications, the localStorage API stands out as a simple and widely supported solution. It allows developers to store key-value pairs directly in a user's browser. In this article, we will explore the various aspects of the localStorage API, its advantages, limitations, and alternative storage options available for modern applications.\n\nThe localStorage API is a built-in feature of web browsers that enables web developers to store small amounts of data persistently on a user's device. It operates on a simple key-value basis, allowing developers to save strings, numbers, and other simple data types. This data remains available even after the user closes the browser or navigates away from the page. The API provides a convenient way to maintain state and store user preferences without relying on server-side storage.\n\nLet's dive into some hands-on code examples to better understand how to leverage the power of localStorage. The API offers several methods for interaction, including setItem, getItem, removeItem, and clear. Consider the following code snippet:\n\nWhile js localStorage excels at handling simple key-value pairs, it also supports more intricate data storage through JSON serialization. By utilizing JSON.stringify and JSON.parse, you can store and retrieve structured data like objects and arrays. Here's an example of storing a document:\n\nDespite its convenience, localStorage does come with a set of limitations that developers should be aware of:\n• Non-Async Blocking API: One significant drawback is that js localStorage operates as a non-async blocking API. This means that any operations performed on localStorage can potentially block the main thread, leading to slower application performance and a less responsive user experience.\n• Limited Data Structure: Unlike more advanced databases, localStorage is limited to a simple key-value store. This restriction makes it unsuitable for storing complex data structures or managing relationships between data elements.\n• Stringification Overhead: Storing JSON data in localStorage requires stringifying the data before storage and parsing it when retrieved. This process introduces performance overhead, potentially slowing down operations by up to 10 times.\n• Lack of Indexing: localStorage lacks indexing capabilities, making it challenging to perform efficient searches or iterate over data based on specific criteria. This limitation can hinder applications that rely on complex data retrieval.\n• Tab Blocking: In a multi-tab environment, one tab's localStorage operations can impact the performance of other tabs by monopolizing CPU resources. You can reproduce this behavior by opening this test file in two browser windows and trigger localstorage inserts in one of them. You will observe that the indication spinner will stuck in both windows.\n• Storage Limit: Browsers typically impose a storage limit of around 5 MiB for each origin's localStorage.\n\nContrary to concerns about performance, the localStorage API in JavaScript is surprisingly fast when compared to alternative storage solutions like IndexedDB or OPFS. It excels in handling small key-value assignments efficiently. Due to its simplicity and direct integration with browsers, accessing and modifying localStorage data incur minimal overhead. For scenarios where quick and straightforward data storage is required, localStorage remains a viable option. For example RxDB uses localStorage in the localStorage meta optimizer to manage simple key values pairs while storing the \"normal\" documents inside of another storage like IndexedDB.\n\nWhile localStorage offers convenience, it may not be suitable for every use case. Consider the following situations where alternatives might be more appropriate:\n• Data Must Be Queryable: If your application relies heavily on querying data based on specific criteria, localStorage might not provide the necessary querying capabilities. Complex data retrieval might lead to inefficient code and slow performance.\n• Big JSON Documents: Storing large JSON documents in localStorage can consume a significant amount of memory and degrade performance. It's essential to assess the size of the data you intend to store and consider more robust solutions for handling substantial datasets.\n• Many Read/Write Operations: Excessive read and write operations on localStorage can lead to performance bottlenecks. Other storage solutions might offer better performance and scalability for applications that require frequent data manipulation.\n• Lack of Persistence: If your application can function without persistent data across sessions, consider using in-memory data structures like or . These options offer speed and efficiency for transient data.\n\nWhile localStorage serves as a reliable storage solution for simpler data needs, it's essential to explore alternatives like IndexedDB when dealing with more complex requirements. IndexedDB is designed to store not only key-value pairs but also JSON documents. Unlike localStorage, which usually has a storage limit of around 5-10MB per domain, IndexedDB can handle significantly larger datasets. IndexDB with its support for indexing facilitates efficient querying, making range queries possible. However, it's worth noting that IndexedDB lacks observability, which is a feature unique to localStorage through the event. Also, complex queries can pose a challenge with IndexedDB, and while its performance is acceptable, IndexedDB can be too slow for some use cases.\n\nFor those looking to harness the full power of IndexedDB with added capabilities, using wrapper libraries like RxDB is recommended. These libraries augment IndexedDB with features such as complex queries and observability, enhancing its usability for modern applications by providing a real database instead of only a key-value store.\n\nIn summary when you compare IndexedDB vs localStorage, IndexedDB will win at any case where much data is handled while localStorage has better performance on small key-value datasets.\n\nAnother intriguing option is the OPFS (File System API). This API provides direct access to an origin-based, sandboxed filesystem which is highly optimized for performance and offers in-place write access to its content. OPFS offers impressive performance benefits. However, working with the OPFS API can be complex, and it's only accessible within a WebWorker. To simplify its usage and extend its capabilities, consider using a wrapper library like RxDB's OPFS RxStorage, which builds a comprehensive database on top of the OPFS API. This abstraction allows you to harness the power of the OPFS API without the intricacies of direct usage.\n\nCookies, once a primary method of client-side data storage, have fallen out of favor in modern web development due to their limitations. While they can store data, they are about 100 times slower when compared to the localStorage API. Additionally, cookies are included in the HTTP header, which can impact network performance. As a result, cookies are not recommended for data storage purposes in contemporary web applications.\n\nWebSQL, despite offering a SQL-based interface for client-side data storage, is a deprecated technology and should be avoided. Its API has been phased out of modern browsers, and it lacks the robustness of alternatives like IndexedDB. Moreover, WebSQL tends to be around 10 times slower than IndexedDB, making it a suboptimal choice for applications that demand efficient data manipulation and retrieval.\n\nIn scenarios where data persistence beyond a session is unnecessary, developers often turn to sessionStorage. This storage mechanism retains data only for the duration of a tab or browser session. It survives page reloads and restores, providing a handy solution for temporary data needs. However, it's important to note that sessionStorage is limited in scope and may not suit all use cases.\n\nFor React Native developers, the AsyncStorage API is the go-to solution, mirroring the behavior of localStorage but with asynchronous support. Since not all JavaScript runtimes support localStorage, AsyncStorage offers a seamless alternative for data persistence in React Native applications.\n\nBecause native localStorage is absent in the Node.js JavaScript runtime, you will get the error in Node.js or node based runtimes like Next.js. The node-localstorage npm package bridges the gap. This package replicates the browser's localStorage API within the Node.js environment, ensuring consistent and compatible data storage capabilities.\n\nWhile browser extensions for chrome and firefox support the localStorage API, it is not recommended to use it in that context to store extension-related data. The browser will clear the data in many scenarios like when the users clear their browsing history.\n\nInstead the Extension Storage API should be used for browser extensions. In contrast to localStorage, the storage API works and all operations return a Promise. Also it provides automatic sync to replicate data between all instances of that browser that the user is logged into. The storage API is even able to storage JSON-ifiable objects instead of plain strings.\n\nThe Deno JavaScript runtime has a working localStorage API so running and the other methods, will just work and the locally stored data is persisted across multiple runs.\n\nBun does not support the localStorage JavaScript API. Trying to use will error with . To store data locally in Bun, you could use the module instead or directly use a in-JavaScript database with Bun support like RxDB.\n\nIn the world of modern web development, localStorage serves as a valuable tool for lightweight data storage. Its simplicity and speed make it an excellent choice for small key-value assignments. However, as application complexity grows, developers must assess their storage needs carefully. For scenarios that demand advanced querying, complex data structures, or high-volume operations, alternatives like IndexedDB, wrapper libraries with additional features like RxDB, or platform-specific APIs offer more robust solutions. By understanding the strengths and limitations of various storage options, developers can make informed decisions that pave the way for efficient and scalable applications.\n• Learn how to store and query data with RxDB in the RxDB Quickstart\n• Why IndexedDB is slow and how to fix it"
    },
    {
        "link": "https://blog.logrocket.com/localstorage-javascript-complete-guide",
        "document": "Editor’s note: This post was updated by Muhmmed Ali on 28 February 2024 to include advanced data management techniques in . Check out our guide to storing and retrieving JavaScript objects in for more information.\n\nIt can be infuriating to accidentally close a webpage while filling out a form. You lose all the data already filled and have to start over. In this article, you’ll learn how to use in JavaScript to save your data beyond a single browsing session. We’ll show you how to use this mechanism and the property, and review the basics of web storage in JavaScript.\n\nWhat is in JavaScript?\n\nis a property that allows JavaScript sites and apps to save key-value pairs in a web browser with no expiration date. This means the data stored persists even after the user closes the browser or restarts the computer.\n\nis a object property, which makes it a global object that can interact with and manipulate the browser window. It can also be used in combination with other properties and methods.\n\nThe mechanism is available via the property. is part of the interface in JavaScript, which represents a window containing a DOM document.\n\nThe interface features a wide range of functions, constructors, objects, and namespaces. is a read-only property that returns a reference to the local storage object used to store data that is only accessible to the origin that created it.\n\nWhen to use\n\nPut simply, is used for storing and retrieving data. While you can store small amounts of data with , it’s not suitable for large datasets. is accessible to anyone who uses the device, so you shouldn’t use it to store sensitive information. You can use it to store user preferences, like language or theme. You can also use it to cache data if you use it frequently. can store form data that won’t be lost if the user closes the browser.\n\nIf you have an application that requires you to log in, can be used to keep your session data. You can remain logged in even after closing and reopening the browser. We’ll demonstrate this later in this tutorial using a simple to-do app.\n\nIn the meantime, for a refresher on how to use in JavaScript, check out the video tutorial below:\n\nIn Google Chrome, web storage data is saved in an SQLite file in a subfolder in the user’s profile. The subfolder is located at on Windows machines and on macOS. Firefox saves storage objects in an SQLite file called , which is also located in the user’s profile folder.\n\nis one of two mechanisms for the Web Storage API, the other being . The Web Storage API is a set of mechanisms that enables browsers to store key-value pairs. It is designed to be much more intuitive than using cookies.\n\nThe key-value pairs represent storage objects, which are similar to objects, except they remain intact during page loads and are always strings. You can access these values like an object or using the method (more on that later).\n\nBoth and maintain a separate storage area for each available origin for the duration of the page session. The main difference between them is that only maintains a storage area. At the same time, the browser is open (including when the page reloads or restores) while continues to store data after the browser is closed.\n\nstores data that won’t expire, while only stores data for a single session. It’s important to note that data loaded in an incognito browsing session will be cleared once the last private tab is closed. ‘s method is useful when temporary data storage is required, and it should be used in situations where data persistence beyond the current session is not required.\n\nTypically, has a smaller storage limit compared to , often limited to a few megabytes per origin. This makes it suitable for storing temporary data during a user’s session without consuming excessive browser resources.\n\n, on the other hand, provides a larger storage capacity, often ranging from 5-10 MB per origin. It is suited for storing larger amounts of data that need to persist across multiple sessions.\n\nin JavaScript is an important tool for storing client-side data. However, it has several advantages and disadvantages you should consider.\n\nThe first advantage of is one we’ve mentioned a few times already, and it is that stored data doesn’t expire. You can still access the data offline, and caches data that can be used without an internet connection.\n\nStoring data with is more secure than storing with cookies, and you have more control of your data. Lastly, has a larger storage capacity compared to cookies. While cookies can only store four kilobytes of data, can store up to five megabytes of data.\n\nis synchronous, meaning each operation only executes one after the other. This poses minimal issues for smaller datasets but as your data grows, this can become a larger issue.\n\nAlthough is more secure than cookies, you still shouldn’t use it to store sensitive data. Anyone with access to the user’s device can access the data stored with . Additionally, can only store strings, so if you want to store other data types, you’ll have to convert them to strings. And finally, storing too much data with can slow down your application.\n\nYou’ve heard it repeatedly by now — stores data. And, if you’re storing data, it means you may need to retrieve it later. In this section, we’ll explore exactly how works. Here’s a rundown of how it works:\n• : Adds key and value to\n• : Passes a number to retrieve the key of a\n\nThe method allows you to store values in . It takes two parameters: a key and a value. The key can be referenced later to fetch the value attached to it. Here’s how it should look:\n\nIn the code above, you can see that is the key and is the value. As we’ve already noted, can only store strings. To store arrays or objects in , you would have to convert them to strings.\n\nTo do this, we use the method before passing to , like so:\n\nallows you to access the data stored in the browser’s object. This method accepts only one parameter, the , and returns the as a string:\n\nThis returns a string with a value of . If the specified key doesn’t exist in , it’ll return . In the case of the array, we make use of the method, which converts a JSON string into a JavaScript object:\n\nUsing the array we created above, here’s how to retrieve it from :\n\nThis method will return the array . You can inspect the webpage, and find it in the console, like this:\n\nThis image is from Firefox, so it’ll look a little different on other browsers. Let’s compare it with another array that’s not stored with :\n\nNow, we have two arrays on the console, as shown below:\n\nNormally, if you comment them out in your code editor, they should disappear from the console. But anything stored with will remain. Here’s an example:\n\nTo delete an item from , you’ll use the method. When passing a key , the method removes the existing key from the storage. If no item is associated with the given key, this method will do nothing. Here’s the code:\n\nHow to delete all items in :\n\nTo delete all items in , you will use the method. This method, when invoked, clears the entire storage of all records for that domain. It does not receive any parameters. Use the following code:\n\nHow to get the name of a key:\n\nThe method comes in handy when you need to loop through keys but still be able to pass a number or index to to retrieve the name of the . Here’s what that looks like:\n\nThe parameter represents the zero-based index of the you want to retrieve the name for.\n\nStoring data in the browser with\n\nWe’ve reviewed all the methods; now we’ll look at them more practically. Here’s a to-do app built with :\n\nSee the Pen \n\n To-do App by Oscar-Jite (@oscar-jite)\n\n on CodePen.\n\nThe app has a very simple HTML markup:\n\nIn the code above, we’ve added two functions, and , that we’ll use later in the JavaScript. The CSS is also simple; you can style it however you like. The important part is the JavaScript. You’ll start by selecting the list where the tasks will be added and the field, as shown below:\n\nNext, you load any pre-existing items in . If there aren’t any, you create an empty , as shown below:\n\nNow, we’ll create a function that adds a task, which would be a , into the empty :\n\nNow, we add functionality to the buttons. The button stores the items in , and the button deletes every item. Here’s the code:\n\nThe function gets the items from the field, . It then adds them to the and saves them to while simultaneously adding them to the list. The function clears all items from , removes them from the list, and resets the .\n\nBoth and cookies are used to store client-side data. As we mentioned before, cookies can only store a maximum of four kilobytes of data, which is significantly less than ‘s five megabytes of storage capacity.\n\nCookies are automatically sent to the server with every HTTP request, but stays local within the user’s device. This can improve web performance and doesn’t increase network traffic because it doesn’t share data with the server.\n\nAs we’ve seen, the data you store with doesn’t expire; it stays indefinitely until you delete it manually. On the other hand, cookies can be set to expire after some time or as soon as you close the browser. Cookies usually store data like user preferences and login/authentication information. This data is accessible across all tabs and windows of the browser. However, only stores data that is accessible within a specific protocol or domain.\n\n, as a type of web storage, is an HTML5 specification. It is supported by major browsers, including Internet Explorer v8. You can use the following snippet to check if the browser supports :\n\nNow, we’ll explore some advanced techniques for managing data in . We will work on how to efficiently remove keys, employ best practices for storing and setting objects, and use JSON parsing and stringification for complex data.\n\nEfficiently removing keys from objects stored in is necessary to optimize storage space, especially if you are building an application where data is frequently updated or deleted. Deleting unnecessary keys helps prevent from becoming clustered with useless data.\n\nTo effectively remove a key from an object in , you can retrieve the object using the key, remove the desired property, and then set the updated object back into . This minimizes unnecessary data manipulation and storage overhead:\n\nJSON parsing and stringification are powerful techniques for handling complex data structures when storing and retrieving data in . They allow for easy conversion between JavaScript objects and JSON strings, enabling efficient data management and manipulation.\n\nWhen storing complex data structures like objects or arrays in , it’s essential to stringify them using before setting them into . This converts the JavaScript object into a JSON string, which can then be stored as a key-value pair:\n\nWhen dealing with nested objects or arrays, ensure that all nested objects are also stringified and parsed to maintain the integrity of the data structure:\n\nIn this article, we explored the capabilities of in JavaScript as a simple and efficient way to store and retrieve data without relying on cookies. We covered how and when to use , as well as how to save, retrieve, and delete items in . Through the example of a to-do app, we demonstrated in action, comparing it to cookies.\n\nIn this post, you learned how and when to use . We covered how to save, retrieve, and delete items in . We also created a to-do app to see how works in a practical scenario. Finally, we compared it to cookies.\n\nSo, you’ve learned about a great tool that’s easy to use with broad browser support. How will you implement in your next project? Happy coding!"
    },
    {
        "link": "https://stackoverflow.com/questions/16144906/is-it-possible-to-use-html5-local-storage-to-share-data-between-pages-from-diffe/16146420",
        "document": "Best trick I know is to use iframes and API do get access to localStorage from external domain.\n\nThis technique is quite simple:\n• on you page you must create iframe to a domain from which you want to get data\n• None your data domain need listen to event:\n• None handler will be responsible for accessing and posting its content to source domain\n• your source domain may call function on data domain with API https://developer.mozilla.org/en-US/docs/DOM/window.postMessage\n\nFor security of your data you can use HTTP header X-Frame-Options ALLOW-FROM uri https://developer.mozilla.org/en-US/docs/HTTP/X-Frame-Options?redirectlocale=en-US&redirectslug=The_X-FRAME-OPTIONS_response_header\n\nHope it will help."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Client-side_APIs/Client-side_storage",
        "document": "Elsewhere in the MDN learning area, we talked about the difference between static sites and dynamic sites. Most major modern websites are dynamic — they store data on the server using some kind of database (server-side storage), then run server-side code to retrieve needed data, insert it into static page templates, and serve the resulting HTML to the client to be displayed by the user's browser. Client-side storage works on similar principles, but has different uses. It consists of JavaScript APIs that allow you to store data on the client (i.e. on the user's machine) and then retrieve it when needed. This has many distinct uses, such as:\n• Persisting previous site activity (e.g. storing the contents of a shopping cart from a previous session, remembering if a user was previously logged in).\n• Saving data and assets locally so a site will be quicker (and potentially less expensive) to download, or be usable without a network connection. Often client-side and server-side storage are used together. For example, you could download a batch of music files (perhaps used by a web game or music player application), store them inside a client-side database, and play them as needed. The user would only have to download the music files once — on subsequent visits they would be retrieved from the database instead. Note: There are limits to the amount of data you can store using client-side storage APIs (possibly both per individual API and cumulatively); the exact limit varies depending on the browser and possibly based on user settings. See Browser storage quotas and eviction criteria for more information.\n\nLet's apply this new-found knowledge by writing a working example to give you an idea of how web storage can be used. Our example will allow you to enter a name, after which the page will update to give you a personalized greeting. This state will also persist across page/browser reloads, because the name is stored in web storage. You can find the example HTML at personal-greeting.html — this contains a website with a header, content, and footer, and a form for entering your name. Let's build up the example, so you can understand how it works.\n• First, make a local copy of our personal-greeting.html file in a new directory on your computer.\n• Next, note how our HTML references a JavaScript file called , with a line like . We need to create this and write our JavaScript code into it. Create an file in the same directory as your HTML file.\n• We'll start off by creating references to all the HTML features we need to manipulate in this example — we'll create them all as constants, as these references do not need to change in the lifecycle of the app. Add the following lines to your JavaScript file:\n• Next up, we need to include a small event listener to stop the form from actually submitting itself when the submit button is pressed, as this is not the behavior we want. Add this snippet below your previous code: // Stop the form from submitting when a button is pressed form.addEventListener(\"submit\", (e) => e.preventDefault());\n• Now we need to add an event listener, the handler function of which will run when the \"Say hello\" button is clicked. The comments explain in detail what each bit does, but in essence here we are taking the name the user has entered into the text input box and saving it in web storage using , then running a function called that will handle updating the actual website text. Add this to the bottom of your code: // run function when the 'Say hello' button is clicked submitBtn.addEventListener(\"click\", () => { // store the entered name in web storage localStorage.setItem(\"name\", nameInput.value); // run nameDisplayCheck() to sort out displaying the personalized greetings and updating the form display nameDisplayCheck(); });\n• At this point we also need an event handler to run a function when the \"Forget\" button is clicked — this is only displayed after the \"Say hello\" button has been clicked (the two form states toggle back and forth). In this function we remove the item from web storage using , then again run to update the display. Add this to the bottom: // run function when the 'Forget' button is clicked forgetBtn.addEventListener(\"click\", () => { // Remove the stored name from web storage localStorage.removeItem(\"name\"); // run nameDisplayCheck() to sort out displaying the generic greeting again and updating the form display nameDisplayCheck(); });\n• It is now time to define the function itself. Here we check whether the name item has been stored in web storage by using as a conditional test. If the name has been stored, this call will evaluate to ; if not, the call will evaluate to . If the call evaluates to , we display a personalized greeting, display the \"forget\" part of the form, and hide the \"Say hello\" part of the form. If the call evaluates to , we display a generic greeting and do the opposite. Again, put the following code at the bottom: // define the nameDisplayCheck() function function nameDisplayCheck() { // check whether the 'name' data item is stored in web Storage if (localStorage.getItem(\"name\")) { // If it is, display personalized greeting const name = localStorage.getItem(\"name\"); h1.textContent = `Welcome, ${name}`; personalGreeting.textContent = `Welcome to our website, ${name}! We hope you have fun while you are here.`; // hide the 'remember' part of the form and show the 'forget' part forgetDiv.style.display = \"block\"; rememberDiv.style.display = \"none\"; } else { // if not, display generic greeting h1.textContent = \"Welcome to our website \"; personalGreeting.textContent = \"Welcome to our website. We hope you have fun while you are here.\"; // hide the 'forget' part of the form and show the 'remember' part forgetDiv.style.display = \"none\"; rememberDiv.style.display = \"block\"; } }\n• Last but not least, we need to run the function when the page is loaded. If we don't do this, then the personalized greeting will not persist across page reloads. Add the following to the bottom of your code: Your example is finished — well done! All that remains now is to save your code and test your HTML page in a browser. You can see our finished version running live here. Note: There is another, slightly more complex example to explore at Using the Web Storage API. Note: In the line of the source for our finished version, the attribute specifies that the contents of the element will not execute until the page has finished loading.\n\nNow let's look at what we have to do in the first place, to actually set up a database.\n• Below the constant declarations, add the following lines: // Create an instance of a db object for us to store the open database in let db; Here we are declaring a variable called — this will later be used to store an object representing our database. We will use this in a few places, so we've declared it globally here to make things easier.\n• // Open our database; it is created if it doesn't already exist // (see the upgradeneeded handler below) const openRequest = window.indexedDB.open(\"notes_db\", 1); This line creates a request to open version of a database called . If this doesn't already exist, it will be created for you by subsequent code. You will see this request pattern used very often throughout IndexedDB. Database operations take time. You don't want to hang the browser while you wait for the results, so database operations are asynchronous, meaning that instead of happening immediately, they will happen at some point in the future, and you get notified when they're done. To handle this in IndexedDB, you create a request object (which can be called anything you like — we called it here, so it is obvious what it is for). You then use event handlers to run code when the request completes, fails, etc., which you'll see in use below. Note: The version number is important. If you want to upgrade your database (for example, by changing the table structure), you have to run your code again with an increased version number, different schema specified inside the handler (see below), etc. We won't cover upgrading databases in this tutorial.\n• Now add the following event handlers just below your previous addition: // error handler signifies that the database didn't open successfully openRequest.addEventListener(\"error\", () => console.error(\"Database failed to open\"), ); // success handler signifies that the database opened successfully openRequest.addEventListener(\"success\", () => { console.log(\"Database opened successfully\"); // Store the opened database object in the db variable. This is used a lot below db = openRequest.result; // Run the displayData() function to display the notes already in the IDB displayData(); }); The event handler will run if the system comes back saying that the request failed. This allows you to respond to this problem. In our example, we just print a message to the JavaScript console. The event handler will run if the request returns successfully, meaning the database was successfully opened. If this is the case, an object representing the opened database becomes available in the property, allowing us to manipulate the database. We store this in the variable we created earlier for later use. We also run a function called , which displays the data in the database inside the . We run it now so that the notes already in the database are displayed as soon as the page loads. You'll see defined later on.\n• Finally for this section, we'll add probably the most important event handler for setting up the database: . This handler runs if the database has not already been set up, or if the database is opened with a bigger version number than the existing stored database (when performing an upgrade). Add the following code, below your previous handler: // Set up the database tables if this has not already been done openRequest.addEventListener(\"upgradeneeded\", (e) => { // Grab a reference to the opened database db = e.target.result; // Create an objectStore in our database to store notes and an auto-incrementing key // An objectStore is similar to a 'table' in a relational database const objectStore = db.createObjectStore(\"notes_os\", { keyPath: \"id\", autoIncrement: true, }); // Define what data items the objectStore will contain objectStore.createIndex(\"title\", \"title\", { unique: false }); objectStore.createIndex(\"body\", \"body\", { unique: false }); console.log(\"Database setup complete\"); }); This is where we define the schema (structure) of our database; that is, the set of columns (or fields) it contains. Here we first grab a reference to the existing database from the property of the event's target ( ), which is the object. This is equivalent to the line inside the event handler, but we need to do this separately here because the event handler (if needed) will run before the event handler, meaning that the value wouldn't be available if we didn't do this. We then use to create a new object store inside our opened database called . This is equivalent to a single table in a conventional database system. We've given it the name notes, and also specified an key field called — in each new record this will automatically be given an incremented value — the developer doesn't need to set this explicitly. Being the key, the field will be used to uniquely identify records, such as when deleting or displaying a record. We also create two other indexes (fields) using the method: (which will contain a title for each note), and (which will contain the body text of the note). So with this database schema set up, when we start adding records to the database, each one will be represented as an object along these lines: { \"title\": \"Buy milk\", \"body\": \"Need both cows milk and soy.\", \"id\": 8 }\n\nAs we mentioned above, IndexedDB can be used to store more than just text strings. You can store just about anything you want, including complex objects such as video or image blobs. And it isn't much more difficult to achieve than any other type of data. To demonstrate how to do it, we've written another example called IndexedDB video store (see it running live here also). When you first run the example, it downloads all the videos from the network, stores them in an IndexedDB database, and then displays the videos in the UI inside elements. The second time you run it, it finds the videos in the database and gets them from there instead before displaying them — this makes subsequent loads much quicker and less bandwidth-hungry. Let's walk through the most interesting parts of the example. We won't look at it all — a lot of it is similar to the previous example, and the code is well-commented.\n• For this example, we've stored the names of the videos to fetch in an array of objects: const videos = [ { name: \"crystal\" }, { name: \"elf\" }, { name: \"frog\" }, { name: \"monster\" }, { name: \"pig\" }, { name: \"rabbit\" }, ];\n• To start with, once the database is successfully opened we run an function. This loops through the different video names, trying to load a record identified by each name from the database. If each video is found in the database (checked by seeing whether evaluates to — if the record is not present, it will be ), its video files (stored as blobs) and the video name are passed straight to the function to place them in the UI. If not, the video name is passed to the function to, you guessed it, fetch the video from the network. function init() { // Loop through the video names one by one for (const video of videos) { // Open transaction, get object store, and get() each video by name const objectStore = db.transaction(\"videos_os\").objectStore(\"videos_os\"); const request = objectStore.get(video.name); request.addEventListener(\"success\", () => { // If the result exists in the database (is not undefined) if (request.result) { // Grab the videos from IDB and display them using displayVideo() console.log(\"taking videos from IDB\"); displayVideo( request.result.mp4, request.result.webm, request.result.name, ); } else { // Fetch the videos from the network fetchVideoFromNetwork(video); } }); } }\n• The following snippet is taken from inside — here we fetch MP4 and WebM versions of the video using two separate requests. We then use the method to extract each response's body as a blob, giving us an object representation of the videos that can be stored and displayed later on. We have a problem here though — these two requests are both asynchronous, but we only want to try to display or store the video when both promises have fulfilled. Fortunately there is a built-in method that handles such a problem — . This takes one argument — references to all the individual promises you want to check for fulfillment placed in an array — and returns a promise which is fulfilled when all the individual promises are fulfilled. Inside the handler for this promise, we call the function like we did before to display the videos in the UI, then we also call the function to store those videos inside the database. // Fetch the MP4 and WebM versions of the video using the fetch() function, // then expose their response bodies as blobs const mp4Blob = fetch(`videos/${video.name}.mp4`).then((response) => response.blob(), ); const webmBlob = fetch(`videos/${video.name}.webm`).then((response) => response.blob(), ); // Only run the next code when both promises have fulfilled Promise.all([mp4Blob, webmBlob]).then((values) => { // display the video fetched from the network with displayVideo() displayVideo(values[0], values[1], video.name); // store it in the IDB using storeVideo() storeVideo(values[0], values[1], video.name); });\n• Let's look at first. This is very similar to the pattern you saw in the previous example for adding data to the database — we open a transaction and get a reference to our object store, create an object representing the record to add to the database, then add it using . // Define the storeVideo() function function storeVideo(mp4, webm, name) { // Open transaction, get object store; make it a readwrite so we can write to the IDB const objectStore = db .transaction([\"videos_os\"], \"readwrite\") .objectStore(\"videos_os\"); // Add the record to the IDB using add() const request = objectStore.add({ mp4, webm, name }); request.addEventListener(\"success\", () => console.log(\"Record addition attempt finished\"), ); request.addEventListener(\"error\", () => console.error(request.error)); }\n• Finally, we have , which creates the DOM elements needed to insert the video in the UI and then appends them to the page. The most interesting parts of this are those shown below — to actually display our video blobs in a element, we need to create object URLs (internal URLs that point to the video blobs stored in memory) using the method. Once that is done, we can set the object URLs to be the values of our element's attributes, and it works fine. // Define the displayVideo() function function displayVideo(mp4Blob, webmBlob, title) { // Create object URLs out of the blobs const mp4URL = URL.createObjectURL(mp4Blob); const webmURL = URL.createObjectURL(webmBlob); // Create DOM elements to embed video in the page const article = document.createElement(\"article\"); const h2 = document.createElement(\"h2\"); h2.textContent = title; const video = document.createElement(\"video\"); video.controls = true; const source1 = document.createElement(\"source\"); source1.src = mp4URL; source1.type = \"video/mp4\"; const source2 = document.createElement(\"source\"); source2.src = webmURL; source2.type = \"video/webm\"; // Embed DOM elements into page section.appendChild(article); article.appendChild(h2); article.appendChild(video); video.appendChild(source1); video.appendChild(source2); }\n\nLet's look at an example, to give you a bit of an idea of what this might look like. We have created another version of the video store example we saw in the previous section — this functions identically, except that it also saves the HTML, CSS, and JavaScript in the Cache API via a service worker, allowing the example to run offline! See IndexedDB video store with service worker running live, and also see the source code. The first thing to note is that there's an extra bit of code placed in the main JavaScript file (see index.js). First, we do a feature detection test to see if the member is available in the object. If this returns true, then we know that at least the basics of service workers are supported. Inside here we use the method to register a service worker contained in the file against the origin it resides at, so it can control pages in the same directory as it, or subdirectories. When its promise fulfills, the service worker is deemed registered. // Register service worker to control making site work offline if (\"serviceWorker\" in navigator) { navigator.serviceWorker .register( \"/learning-area/javascript/apis/client-side-storage/cache-sw/video-store-offline/sw.js\", ) .then(() => console.log(\"Service Worker Registered\")); } Note: The given path to the file is relative to the site origin, not the JavaScript file that contains the code. The service worker is at . The origin is , and therefore the given path has to be . If you wanted to host this example on your own server, you'd have to change this accordingly. This is rather confusing, but it has to work this way for security reasons. The next time any page under the service worker's control is accessed (e.g. when the example is reloaded), the service worker is installed against that page, meaning that it will start controlling it. When this occurs, an event is fired against the service worker; you can write code inside the service worker itself that will respond to the installation. Let's look at an example, in the sw.js file (the service worker). You'll see that the install listener is registered against . This keyword is a way to refer to the global scope of the service worker from inside the service worker file. Inside the handler, we use the method, available on the event object, to signal that the browser shouldn't complete installation of the service worker until after the promise inside it has fulfilled successfully. Here is where we see the Cache API in action. We use the method to open a new cache object in which responses can be stored (similar to an IndexedDB object store). This promise fulfills with a object representing the cache. We then use the method to fetch a series of assets and add their responses to the cache. That's it for now, installation done. With the service worker registered and installed against our HTML page, and the relevant assets all added to our cache, we are nearly ready to go. There is only one more thing to do: write some code to respond to further network requests. This is what the second bit of code in does. We add another listener to the service worker global scope, which runs the handler function when the event is raised. This happens whenever the browser makes a request for an asset in the directory the service worker is registered against. Inside the handler, we first log the URL of the requested asset. We then provide a custom response to the request, using the method. Inside this block, we use to check whether a matching request (i.e. matches the URL) can be found in any cache. This promise fulfills with the matching response if a match is found, or if it isn't. If a match is found, we return it as the custom response. If not, we fetch() the response from the network and return that instead. And that is it for our service worker. There is a whole load more you can do with them — for a lot more detail, see the service worker cookbook. Many thanks to Paul Kinlan for his article Adding a Service Worker and Offline into your Web App, which inspired this example. To test our service worker example, you'll need to load it a couple of times to make sure it is installed. Once this is done, you can:\n• Try unplugging your network/turning your Wi-Fi off.\n• Select File > Work Offline if you are using Firefox.\n• Go to the devtools, then choose Application > Service Workers, then check the Offline checkbox if you are using Chrome. If you refresh your example page again, you should still see it load just fine. Everything is stored offline — the page assets in a cache, and the videos in an IndexedDB database."
    }
]