[
    {
        "link": "https://w3schools.com/python/ref_string_replace.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://programiz.com/python-programming/methods/string/replace",
        "document": "The method can take a maximum of three arguments:\n• old - the old substring we want to replace\n• new - new substring which will replace the old substring\n• count (optional) - the number of times you want to replace the substring with the string\n\nNote: If is not specified, the method replaces all occurrences of the substring with the string.\n\nThe method returns a copy of the string where the substring is replaced with the string. The original string remains unchanged.\n\nIf the substring is not found, it returns a copy of the original string."
    },
    {
        "link": "https://geeksforgeeks.org/python-string-replace",
        "document": "The replace() method replaces all occurrences of a specified substring in a string and returns a new string without modifying the original string.\n\nLet’s look at a simple example of replace() method.\n\nExplanation: Here, “Hello” is replaced by “Hi” throughout the string, resulting in “Hi World! Hi Python!“.\n\nNote: Since replace() creates a new string, the original string remains unchanged.\n• old: The substring we want to replace.\n• new: The new substring that we want to replace with old substring.\n• count (optional): Specifies the maximum number of replacements to perform. If omitted, all occurrences are replaced.\n• None Returns a new string with the specified replacements made. The original string remains unchanged since strings in Python are immutable.\n\nBy using the optional count parameter, we can limit the number of replacements made. This can be helpful when only a specific number of replacements are desired.\n\nExplanation: replace() method only replaces the first instance of “apple” because we specified count=1.\n\nThe replace() method is case-sensitive, it treats uppercase and lowercase characters as distinct. If we want to replace both cases then we have to use additional logic."
    },
    {
        "link": "https://codecademy.com/resources/docs/python/strings/replace",
        "document": "The string method takes in three parameters:\n• : The substring to search for. (Required)\n• : A number specifying how many occurrences of the old value to replace. Default is all occurrences.\n\ncan be called either directly on a string:\n\nOr on a variable assigned to a string:\n\nBecause is a method, it returns a new string and does not modify the original string. Therefore:\n\nBy default, will replace all occurrences in the string. However, you can add an integer to specify how many strings should be replaced.\n\nThe method can be used to remove sections of a string entirely:\n\nIt can also be called multiple times on the same string:\n\nIf there are many words that need to be removed, consider using a loop:"
    },
    {
        "link": "https://docs.python.org/3/library/string.html",
        "document": "A string containing all ASCII characters that are considered whitespace. This includes the characters space, tab, linefeed, return, formfeed, and vertical tab.\n\nBy design, string.printable.isprintable() returns False . In particular, string.printable is not printable in the POSIX sense (see LC_CTYPE ).\n\nString of ASCII characters which are considered printable by Python. This is a combination of digits , ascii_letters , punctuation , and whitespace .\n\nString of ASCII characters which are considered punctuation characters in the C locale: !\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~ .\n\nThe uppercase letters 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' . This value is not locale-dependent and will not change.\n\nThe lowercase letters 'abcdefghijklmnopqrstuvwxyz' . This value is not locale-dependent and will not change.\n\nThe concatenation of the ascii_lowercase and ascii_uppercase constants described below. This value is not locale-dependent.\n\nConverts the value (returned by get_field() ) given a conversion type (as in the tuple returned by the parse() method). The default version understands ‘s’ (str), ‘r’ (repr) and ‘a’ (ascii) conversion types.\n\nformat_field() simply calls the global format() built-in. The method is provided so that subclasses can override it.\n\nImplement checking for unused arguments if desired. The arguments to this function is the set of all argument keys that were actually referred to in the format string (integers for positional arguments, and strings for named arguments), and a reference to the args and kwargs that was passed to vformat. The set of unused args can be calculated from these parameters. check_unused_args() is assumed to raise an exception if the check fails.\n\nIf the index or keyword refers to an item that does not exist, then an IndexError or KeyError should be raised.\n\nSo for example, the field expression ‘0.name’ would cause get_value() to be called with a key argument of 0. The name attribute will be looked up after get_value() returns by calling the built-in getattr() function.\n\nFor compound field names, these functions are only called for the first component of the field name; subsequent components are handled through normal attribute and indexing operations.\n\nThe args parameter is set to the list of positional arguments to vformat() , and the kwargs parameter is set to the dictionary of keyword arguments.\n\nRetrieve a given field value. The key argument will be either an integer or a string. If it is an integer, it represents the index of the positional argument in args; if it is a string, then it represents a named argument in kwargs.\n\nGiven field_name as returned by parse() (see above), convert it to an object to be formatted. Returns a tuple (obj, used_key). The default version takes strings of the form defined in PEP 3101 , such as “0[name]” or “label.title”. args and kwargs are as passed in to vformat() . The return value used_key has the same meaning as the key parameter to get_value() .\n\nThe values in the tuple conceptually represent a span of literal text followed by a single replacement field. If there is no literal text (which can happen if two replacement fields occur consecutively), then literal_text will be a zero-length string. If there is no replacement field, then the values of field_name, format_spec and conversion will be None .\n\nLoop over the format_string and return an iterable of tuples (literal_text, field_name, format_spec, conversion). This is used by vformat() to break the string into either literal text, or replacement fields.\n\nIn addition, the Formatter defines a number of methods that are intended to be replaced by subclasses:\n\nThis function does the actual work of formatting. It is exposed as a separate function for cases where you want to pass in a predefined dictionary of arguments, rather than unpacking and repacking the dictionary as individual arguments using the *args and **kwargs syntax. vformat() does the work of breaking up the format string into character data and replacement fields. It calls the various methods described below.\n\nThe primary API method. It takes a format string and an arbitrary set of positional and keyword arguments. It is just a wrapper that calls vformat() .\n\nThe built-in string class provides the ability to do complex variable substitutions and value formatting via the format() method described in PEP 3101 . The Formatter class in the string module allows you to create and customize your own string formatting behaviors using the same implementation as the built-in format() method.\n\nThe method and the class share the same syntax for format strings (although in the case of , subclasses can define their own format string syntax). The syntax is related to that of formatted string literals, but it is less sophisticated and, in particular, does not support arbitrary expressions.\n\nFormat strings contain “replacement fields” surrounded by curly braces . Anything that is not contained in braces is considered literal text, which is copied unchanged to the output. If you need to include a brace character in the literal text, it can be escaped by doubling: and .\n\nThe grammar for a replacement field is as follows:\n\nIn less formal terms, the replacement field can start with a field_name that specifies the object whose value is to be formatted and inserted into the output instead of the replacement field. The field_name is optionally followed by a conversion field, which is preceded by an exclamation point , and a format_spec, which is preceded by a colon . These specify a non-default format for the replacement value.\n\nSee also the Format Specification Mini-Language section.\n\nThe field_name itself begins with an arg_name that is either a number or a keyword. If it’s a number, it refers to a positional argument, and if it’s a keyword, it refers to a named keyword argument. An arg_name is treated as a number if a call to on the string would return true. If the numerical arg_names in a format string are 0, 1, 2, … in sequence, they can all be omitted (not just some) and the numbers 0, 1, 2, … will be automatically inserted in that order. Because arg_name is not quote-delimited, it is not possible to specify arbitrary dictionary keys (e.g., the strings or ) within a format string. The arg_name can be followed by any number of index or attribute expressions. An expression of the form selects the named attribute using , while an expression of the form does an index lookup using .\n\nThe conversion field causes a type coercion before formatting. Normally, the job of formatting a value is done by the method of the value itself. However, in some cases it is desirable to force a type to be formatted as a string, overriding its own definition of formatting. By converting the value to a string before calling , the normal formatting logic is bypassed.\n\nThree conversion flags are currently supported: which calls on the value, which calls and which calls .\n\nThe format_spec field contains a specification of how the value should be presented, including such details as field width, alignment, padding, decimal precision and so on. Each value type can define its own “formatting mini-language” or interpretation of the format_spec.\n\nMost built-in types support a common formatting mini-language, which is described in the next section.\n\nA format_spec field can also include nested replacement fields within it. These nested replacement fields may contain a field name, conversion flag and format specification, but deeper nesting is not allowed. The replacement fields within the format_spec are substituted before the format_spec string is interpreted. This allows the formatting of a value to be dynamically specified.\n\nSee the Format examples section for some examples.\n\n“Format specifications” are used within replacement fields contained within a format string to define how individual values are presented (see Format String Syntax and f-strings). They can also be passed directly to the built-in function. Each formattable type may define how the format specification is to be interpreted. Most built-in types implement the following options for format specifications, although some of the formatting options are only supported by the numeric types. A general convention is that an empty format specification produces the same result as if you had called on the value. A non-empty format specification typically modifies the result. The general form of a standard format specifier is: If a valid align value is specified, it can be preceded by a fill character that can be any character and defaults to a space if omitted. It is not possible to use a literal curly brace (” ” or “ ”) as the fill character in a formatted string literal or when using the method. However, it is possible to insert a curly brace with a nested replacement field. This limitation doesn’t affect the function. The meaning of the various alignment options is as follows: Forces the field to be left-aligned within the available space (this is the default for most objects). Forces the field to be right-aligned within the available space (this is the default for numbers). Forces the padding to be placed after the sign (if any) but before the digits. This is used for printing fields in the form ‘+000000120’. This alignment option is only valid for numeric types, excluding . It becomes the default for numbers when ‘0’ immediately precedes the field width. Forces the field to be centered within the available space. Note that unless a minimum field width is defined, the field width will always be the same size as the data to fill it, so that the alignment option has no meaning in this case. The sign option is only valid for number types, and can be one of the following: indicates that a sign should be used for both positive as well as negative numbers. indicates that a sign should be used only for negative numbers (this is the default behavior). indicates that a leading space should be used on positive numbers, and a minus sign on negative numbers. The option coerces negative zero floating-point values to positive zero after rounding to the format precision. This option is only valid for floating-point presentation types. Changed in version 3.11: Added the option (see also PEP 682). The option causes the “alternate form” to be used for the conversion. The alternate form is defined differently for different types. This option is only valid for integer, float and complex types. For integers, when binary, octal, or hexadecimal output is used, this option adds the respective prefix , , , or to the output value. For float and complex the alternate form causes the result of the conversion to always contain a decimal-point character, even if no digits follow it. Normally, a decimal-point character appears in the result of these conversions only if a digit follows it. In addition, for and conversions, trailing zeros are not removed from the result. The option signals the use of a comma for a thousands separator for floating-point presentation types and for integer presentation type . For other presentation types, this option is an error. For a locale aware separator, use the integer presentation type instead. Changed in version 3.1: Added the option (see also PEP 378). The option signals the use of an underscore for a thousands separator for floating-point presentation types and for integer presentation type . For integer presentation types , , , and , underscores will be inserted every 4 digits. For other presentation types, specifying this option is an error. Changed in version 3.6: Added the option (see also PEP 515). width is a decimal integer defining the minimum total field width, including any prefixes, separators, and other formatting characters. If not specified, then the field width will be determined by the content. When no explicit alignment is given, preceding the width field by a zero ( ) character enables sign-aware zero-padding for numeric types, excluding . This is equivalent to a fill character of with an alignment type of . Changed in version 3.10: Preceding the width field by no longer affects the default alignment for strings. The precision is a decimal integer indicating how many digits should be displayed after the decimal point for presentation types and , or before and after the decimal point for presentation types or . For string presentation types the field indicates the maximum field size - in other words, how many characters will be used from the field content. The precision is not allowed for integer presentation types. Finally, the type determines how the data should be presented. The available string presentation types are: String format. This is the default type for strings and may be omitted. The available integer presentation types are: Character. Converts the integer to the corresponding unicode character before printing. Hex format. Outputs the number in base 16, using lower-case letters for the digits above 9. Hex format. Outputs the number in base 16, using upper-case letters for the digits above 9. In case is specified, the prefix will be upper-cased to as well. Number. This is the same as , except that it uses the current locale setting to insert the appropriate number separator characters. In addition to the above presentation types, integers can be formatted with the floating-point presentation types listed below (except and ). When doing so, is used to convert the integer to a floating-point number before formatting. The available presentation types for and values are: Scientific notation. For a given precision , formats the number in scientific notation with the letter ‘e’ separating the coefficient from the exponent. The coefficient has one digit before and digits after the decimal point, for a total of significant digits. With no precision given, uses a precision of digits after the decimal point for , and shows all coefficient digits for . If , the decimal point is omitted unless the option is used. Scientific notation. Same as except it uses an upper case ‘E’ as the separator character. Fixed-point notation. For a given precision , formats the number as a decimal number with exactly digits following the decimal point. With no precision given, uses a precision of digits after the decimal point for , and uses a precision large enough to show all coefficient digits for . If , the decimal point is omitted unless the option is used. Fixed-point notation. Same as , but converts to and to . General format. For a given precision , this rounds the number to significant digits and then formats the result in either fixed-point format or in scientific notation, depending on its magnitude. A precision of is treated as equivalent to a precision of . The precise rules are as follows: suppose that the result formatted with presentation type and precision would have exponent . Then, if , where is -4 for floats and -6 for , the number is formatted with presentation type and precision . Otherwise, the number is formatted with presentation type and precision . In both cases insignificant trailing zeros are removed from the significand, and the decimal point is also removed if there are no remaining digits following it, unless the option is used. With no precision given, uses a precision of significant digits for . For , the coefficient of the result is formed from the coefficient digits of the value; scientific notation is used for values smaller than in absolute value and values where the place value of the least significant digit is larger than 1, and fixed-point notation is used otherwise. Positive and negative infinity, positive and negative zero, and nans, are formatted as , , , and respectively, regardless of the precision. General format. Same as except switches to if the number gets too large. The representations of infinity and NaN are uppercased, too. Number. This is the same as , except that it uses the current locale setting to insert the appropriate number separator characters. Percentage. Multiplies the number by 100 and displays in fixed ( ) format, followed by a percent sign. For this is like the type, except that when fixed-point notation is used to format the result, it always includes at least one digit past the decimal point, and switches to the scientific notation when . When the precision is not specified, the latter will be as large as needed to represent the given value faithfully. For , this is the same as either or depending on the value of for the current decimal context. The overall effect is to match the output of as altered by the other format modifiers. The result should be correctly rounded to a given precision of digits after the decimal point. The rounding mode for matches that of the builtin. For , the rounding mode of the current context will be used. The available presentation types for are the same as those for ( is not allowed). Both the real and imaginary components of a complex number are formatted as floating-point numbers, according to the specified presentation type. They are separated by the mandatory sign of the imaginary part, the latter being terminated by a suffix. If the presentation type is missing, the result will match the output of (complex numbers with a non-zero real part are also surrounded by parentheses), possibly altered by other format modifiers.\n\nThis section contains examples of the syntax and comparison with the old -formatting. In most of the cases the syntax is similar to the old -formatting, with the addition of the and with used instead of . For example, can be translated to . The new format syntax also supports new and different options, shown in the following examples. is formed from the real part 'The complex number (3-5j) is formed from the real part 3.0 and the imaginary part -5.0.' Aligning the text and specifying a width: Replacing , , and and specifying a sign: # show only the minus -- same as '{:f}; {:f}' Replacing and and converting the value to different bases: # with 0x, 0o, or 0b as prefix: Using the comma as a thousands separator:"
    },
    {
        "link": "https://geeksforgeeks.org/taking-input-in-python",
        "document": "Developers often have a need to interact with users, either to get data or to provide some sort of result. Most programs today use a dialog box as a way of asking the user to provide some type of input. While Python provides us with two inbuilt functions to read the input from the keyboard.\n\n\n\ninput () function first takes the input from the user and converts it into a string. The type of the returned object always will be <class ‘str’>. It does not evaluate the expression it just returns the complete statement as String.\n\nFor example, Python provides a built-in function called input which takes the input from the user. When the input function is called it stops the program and waits for the user’s input. When the user presses enter, the program resumes and returns what the user typed.\n\nHow the input function works in Python :\n• None When input() function executes program flow will be stopped until the user has given input.\n• None The text or message displayed on the output screen to ask a user to enter an input value is optional i.e. the prompt, which will be printed on the screen is optional.\n• None Whatever you enter as input, the input function converts it into a string. if you enter an integer value still input() function converts it into a string. You need to explicitly convert it into an integer in your code using\n\nNote: input() function takes all the input as a string only\n\nThere are various function that are used to take as desired input few of them are : –\n\nHow to input a number in Python?\n\nHow to take character input in Python?\n\nHow to check input type in Python?\n\nHow to print input value in Python?\n\nHow to input time in Python?"
    },
    {
        "link": "https://stackoverflow.com/questions/55886209/take-input-from-user-and-execute-the-python-script-at-the-same-time",
        "document": "i have a python script name as neural_net.py . It classify the mnist dataset. What i want to do is to run it via command line by taking input from user. The following snippet is taking input from user\n\nin command prompt i have to run it as following\n\nexecute the above line and then give the input\n\nand it return me the output. What i want is to do the both of above things as a single command such as"
    },
    {
        "link": "https://w3schools.com/python/python_user_input.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://stackoverflow.com/questions/12495218/using-user-input-to-call-functions",
        "document": "I was trying to make a \"game\" in Python where the user inputs a command. However, I do not know whether you can take that input to be a function name. This is my current effort:\n\nHere, the input was move, as I wanted to try and call that function (as a potential end user might). However, I get the following error:\n\nI was wondering if there was any way that I could allow a user to 'move' in the game, which the program achieves by calling the \"move\" function."
    },
    {
        "link": "https://libguides.ntu.edu.sg/python/input",
        "document": "Programs usually request for some user input to serve its function (e.g. calculators asking for what numbers to use, to add/subtract etc.). In Python, we request user input using the input() function.\n\n \n\n Syntax\n\nThis set of code is requesting for user input, and will store it in the message variable.\n\nNote: Inputs are automatically saved as strings. Therefore, always convert to integers before doing any math operators like addition / subtraction. \n\n \n\n Example"
    }
]