[
    {
        "link": "https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Runtime.html",
        "document": "\n• Returns the runtime object associated with the current Java application. Most of the methods of class are instance methods and must be invoked with respect to the current runtime object. the object associated with the current Java application.\n• Terminates the currently running Java virtual machine by initiating its shutdown sequence. This method never returns normally. The argument serves as a status code; by convention, a nonzero status code indicates abnormal termination. All registered shutdown hooks, if any, are started in some unspecified order and allowed to run concurrently until they finish. Once this is done the virtual machine halts. If this method is invoked after all shutdown hooks have already been run and the status is nonzero then this method halts the virtual machine with the given status code. Otherwise, this method blocks indefinitely. The method is the conventional and convenient means of invoking this method. - If a security manager is present and its method does not permit exiting with the specified status\n• The Java virtual machine shuts down in response to two kinds of events:\n• The program exits normally, when the last non-daemon thread exits or when the (equivalently, ) method is invoked, or\n• The virtual machine is terminated in response to a user interrupt, such as typing , or a system-wide event, such as user logoff or system shutdown. A shutdown hook is simply an initialized but unstarted thread. When the virtual machine begins its shutdown sequence it will start all registered shutdown hooks in some unspecified order and let them run concurrently. When all the hooks have finished it will then halt. Note that daemon threads will continue to run during the shutdown sequence, as will non-daemon threads if shutdown was initiated by invoking the method. Once the shutdown sequence has begun it can be stopped only by invoking the method, which forcibly terminates the virtual machine. Once the shutdown sequence has begun it is impossible to register a new shutdown hook or de-register a previously-registered hook. Attempting either of these operations will cause an to be thrown. Shutdown hooks run at a delicate time in the life cycle of a virtual machine and should therefore be coded defensively. They should, in particular, be written to be thread-safe and to avoid deadlocks insofar as possible. They should also not rely blindly upon services that may have registered their own shutdown hooks and therefore may themselves in the process of shutting down. Attempts to use other thread-based services such as the AWT event-dispatch thread, for example, may lead to deadlocks. Shutdown hooks should also finish their work quickly. When a program invokes the expectation is that the virtual machine will promptly shut down and exit. When the virtual machine is terminated due to user logoff or system shutdown the underlying operating system may only allow a fixed amount of time in which to shut down and exit. It is therefore inadvisable to attempt any user interaction or to perform a long-running computation in a shutdown hook. Uncaught exceptions are handled in shutdown hooks just as in any other thread, by invoking the method of the thread's object. The default implementation of this method prints the exception's stack trace to and terminates the thread; it does not cause the virtual machine to exit or halt. In rare circumstances the virtual machine may abort, that is, stop running without shutting down cleanly. This occurs when the virtual machine is terminated externally, for example with the signal on Unix or the call on Microsoft Windows. The virtual machine may also abort if a native method goes awry by, for example, corrupting internal data structures or attempting to access nonexistent memory. If the virtual machine aborts then no guarantee can be made about whether or not any shutdown hooks will be run. - If the specified hook has already been registered, or if it can be determined that the hook is already running or has already been run - If the virtual machine is already in the process of shutting down - If a security manager is present and it denies (\"shutdownHooks\")\n• if the specified hook had previously been registered and was successfully de-registered, otherwise. - If the virtual machine is already in the process of shutting down - If a security manager is present and it denies (\"shutdownHooks\")\n• Forcibly terminates the currently running Java virtual machine. This method never returns normally. This method should be used with extreme caution. Unlike the method, this method does not cause shutdown hooks to be started. If the shutdown sequence has already been initiated then this method does not wait for any running shutdown hooks to finish their work. - Termination status. By convention, a nonzero status code indicates abnormal termination. If the (equivalently, ) method has already been invoked then this status code will override the status code passed to that method. - If a security manager is present and its method does not permit an exit with the specified status\n• Executes the specified string command in a separate process. This is a convenience method. An invocation of the form behaves in exactly the same way as the invocation . A new object for managing the subprocess - If a security manager exists and its method doesn't allow creation of the subprocess\n• Executes the specified string command in a separate process with the specified environment. This is a convenience method. An invocation of the form behaves in exactly the same way as the invocation . - array of strings, each element of which has environment variable settings in the format name=value, or if the subprocess should inherit the environment of the current process. A new object for managing the subprocess - If a security manager exists and its method doesn't allow creation of the subprocess - If is , or one of the elements of is\n• Executes the specified string command in a separate process with the specified environment and working directory. This is a convenience method. An invocation of the form behaves in exactly the same way as the invocation , where is an array of all the tokens in . More precisely, the string is broken into tokens using a created by the call with no further modification of the character categories. The tokens produced by the tokenizer are then placed in the new string array , in the same order. - array of strings, each element of which has environment variable settings in the format name=value, or if the subprocess should inherit the environment of the current process. - the working directory of the subprocess, or if the subprocess should inherit the working directory of the current process. A new object for managing the subprocess - If a security manager exists and its method doesn't allow creation of the subprocess - If is , or one of the elements of is\n• Executes the specified command and arguments in a separate process. This is a convenience method. An invocation of the form behaves in exactly the same way as the invocation . - array containing the command to call and its arguments. A new object for managing the subprocess - If a security manager exists and its method doesn't allow creation of the subprocess - If is , or one of the elements of is - If is an empty array (has length )\n• Executes the specified command and arguments in a separate process with the specified environment. This is a convenience method. An invocation of the form behaves in exactly the same way as the invocation . - array containing the command to call and its arguments. - array of strings, each element of which has environment variable settings in the format name=value, or if the subprocess should inherit the environment of the current process. A new object for managing the subprocess - If a security manager exists and its method doesn't allow creation of the subprocess - If is , or one of the elements of is , or one of the elements of is - If is an empty array (has length )\n• Executes the specified command and arguments in a separate process with the specified environment and working directory. Given an array of strings , representing the tokens of a command line, and an array of strings , representing \"environment\" variable settings, this method creates a new process in which to execute the specified command. This method checks that is a valid operating system command. Which commands are valid is system-dependent, but at the very least the command must be a non-empty list of non-null strings. If is , the subprocess inherits the environment settings of the current process. A minimal set of system dependent environment variables may be required to start a process on some operating systems. As a result, the subprocess may inherit additional environment variable settings beyond those in the specified environment. is now the preferred way to start a process with a modified environment. The working directory of the new subprocess is specified by . If is , the subprocess inherits the current working directory of the current process. If a security manager exists, its method is invoked with the first component of the array as its argument. This may result in a being thrown. Starting an operating system process is highly system-dependent. Among the many things that can go wrong are:\n• The operating system program file was not found.\n• Access to the program file was denied.\n• The working directory does not exist. In such cases an exception will be thrown. The exact nature of the exception is system-dependent, but it will always be a subclass of . If the operating system does not support the creation of processes, an will be thrown. - array containing the command to call and its arguments. - array of strings, each element of which has environment variable settings in the format name=value, or if the subprocess should inherit the environment of the current process. - the working directory of the subprocess, or if the subprocess should inherit the working directory of the current process. A new object for managing the subprocess - If a security manager exists and its method doesn't allow creation of the subprocess - If the operating system does not support the creation of processes. - If is , or one of the elements of is , or one of the elements of is - If is an empty array (has length )\n• Returns the number of processors available to the Java virtual machine. This value may change during a particular invocation of the virtual machine. Applications that are sensitive to the number of available processors should therefore occasionally poll this property and adjust their resource usage appropriately. the maximum number of processors available to the virtual machine; never smaller than one\n• Returns the amount of free memory in the Java Virtual Machine. Calling the method may result in increasing the value returned by an approximation to the total amount of memory currently available for future allocated objects, measured in bytes.\n• Returns the total amount of memory in the Java virtual machine. The value returned by this method may vary over time, depending on the host environment. Note that the amount of memory required to hold an object of any given type may be implementation-dependent. the total amount of memory currently available for current and future objects, measured in bytes.\n• Returns the maximum amount of memory that the Java virtual machine will attempt to use. If there is no inherent limit then the value will be returned. the maximum amount of memory that the virtual machine will attempt to use, measured in bytes\n• Runs the garbage collector. Calling this method suggests that the Java virtual machine expend effort toward recycling unused objects in order to make the memory they currently occupy available for quick reuse. When control returns from the method call, the virtual machine has made its best effort to recycle all discarded objects. The name stands for \"garbage collector\". The virtual machine performs this recycling process automatically as needed, in a separate thread, even if the method is not invoked explicitly. The method is the conventional and convenient means of invoking this method.\n• methods of objects that have been found to be discarded but whose methods have not yet been run. When control returns from the method call, the virtual machine has made a best effort to complete all outstanding finalizations. Runs the finalization methods of any objects pending finalization. Calling this method suggests that the Java virtual machine expend effort toward running themethods of objects that have been found to be discarded but whosemethods have not yet been run. When control returns from the method call, the virtual machine has made a best effort to complete all outstanding finalizations. The virtual machine performs the finalization process automatically as needed, in a separate thread, if the method is not invoked explicitly. The method is the conventional and convenient means of invoking this method.\n• Deprecated, for removal: This API element is subject to removal in a future version. Not implemented, does nothing.\n• Deprecated, for removal: This API element is subject to removal in a future version. Not implemented, does nothing.\n• ). If the filename argument, when stripped of any platform-specific library prefix, path, and file extension, indicates a library whose name is, for example, L, and a native library called L is statically linked with the VM, then the JNI_OnLoad_L function exported by the library is invoked rather than attempting to load a dynamic library. A filename matching the argument does not have to exist in the file system. See the Loads the native library specified by the filename argument. The filename argument must be an absolute path name. (for example). If the filename argument, when stripped of any platform-specific library prefix, path, and file extension, indicates a library whose name is, for example, L, and a native library called L is statically linked with the VM, then the JNI_OnLoad_L function exported by the library is invoked rather than attempting to load a dynamic library. A filename matching the argument does not have to exist in the file system. See the JNI Specification for more details. Otherwise, the filename argument is mapped to a native library image in an implementation-dependent manner. First, if there is a security manager, its method is called with the as its argument. This may result in a security exception. This is similar to the method , but it accepts a general file name as an argument rather than just a library name, allowing any file of native code to be loaded. The method is the conventional and convenient means of invoking this method. - if a security manager exists and its method doesn't allow loading of the specified dynamic library - if either the filename is not an absolute path name, the native library is not statically linked with the VM, or the library cannot be mapped to a native library image by the host system.\n• argument. The argument must not contain any platform specific prefix, file extension or path. If a native library called is statically linked with the VM, then the JNI_OnLoad_ function exported by the library is invoked. See the Loads the native library specified by theargument. Theargument must not contain any platform specific prefix, file extension or path. If a native library calledis statically linked with the VM, then the JNI_OnLoad_function exported by the library is invoked. See the JNI Specification for more details. Otherwise, the libname argument is loaded from a system library location and mapped to a native library image in an implementation- dependent manner. First, if there is a security manager, its method is called with the as its argument. This may result in a security exception. The method is the conventional and convenient means of invoking this method. If native methods are to be used in the implementation of a class, a standard strategy is to put the native code in a library file (call it ) and then to put a static initializer: within the class declaration. When the class is loaded and initialized, the necessary native code implementation for the native methods will then be loaded as well. within the class declaration. When the class is loaded and initialized, the necessary native code implementation for the native methods will then be loaded as well. If this method is called more than once with the same library name, the second and subsequent calls are ignored. - the name of the library. - if a security manager exists and its method doesn't allow loading of the specified dynamic library - if either the libname argument contains a file path, the native library is not statically linked with the VM, or the library cannot be mapped to a native library image by the host system.\n• Returns the version of the Java Runtime Environment as a the of the Java Runtime Environment"
    },
    {
        "link": "https://docs.oracle.com/en/java/javase/11/docs/api//java.base/java/lang/Process.html",
        "document": "provides control of native processes started by ProcessBuilder.start and Runtime.exec. The class provides methods for performing input from the process, performing output to the process, waiting for the process to complete, checking the exit status of the process, and destroying (killing) the process. The and methods create a native process and return an instance of a subclass ofthat can be used to control the process and obtain information about it.\n\nThe methods that create processes may not work well for special processes on certain native platforms, such as native windowing processes, daemon processes, Win16/DOS processes on Microsoft Windows, or shell scripts.\n\nBy default, the created process does not have its own terminal or console. All its standard I/O (i.e. stdin, stdout, stderr) operations will be redirected to the parent process, where they can be accessed via the streams obtained using the methods , , and . The parent process uses these streams to feed input to and get output from the process. Because some native platforms only provide limited buffer size for standard input and output streams, failure to promptly write the input stream or read the output stream of the process may cause the process to block, or even deadlock.\n\nWhere desired, process I/O can also be redirected using methods of the class.\n\nThe process is not killed when there are no more references to the object, but rather the process continues executing asynchronously.\n\nThere is no requirement that the process represented by a object execute asynchronously or concurrently with respect to the Java process that owns the object.\n\nAs of 1.5, is the preferred way to create a .\n\nSubclasses of Process should override the and methods to provide a fully functional Process including the process id, information about the process, direct children, and direct children plus descendants of those children of the process. Delegating to the underlying Process or ProcessHandle is typically easiest and most efficient."
    },
    {
        "link": "https://geeksforgeeks.org/java-runtime-exec-method",
        "document": "The Runtime class's exec() method is your key to making your Java application interact with the operating system, if you've ever wanted it to. In this post, we'll examine the exec() method in great detail, dissect its fundamental ideas, and highlight all of its different applications.\n\nImagine you're running a Java program, and you need to execute a system command. This could be anything from launching an external program to managing system processes. The exec() method is your gateway to this world of possibilities.\n\nHere's a simple way to think about it: You're the conductor of a Java orchestra, and the exec() method is your baton. With it, you can instruct the OS to perform tasks outside the realm of Java, seamlessly integrating your application with the underlying system. So let's get into the details.\n\nBefore we jump into the practical examples, let's cover some essential concepts related to the exec() method:\n• Runtime Object: The exec() method belongs to the Runtime class, which represents the runtime environment of the application. You can obtain a Runtime object using the getRuntime() method.\n• Process: When you call exec(), it spawns a new native process. This process runs independently of your Java application and allows you to execute system commands.\n• ProcessBuilder: Under the hood, exec() uses a ProcessBuilder to start the native process. The ProcessBuilder class provides more control over the process configuration and is recommended for complex interactions.\n\nThe exec() method has six variants, each tailored to different scenarios:\n• exec(String command) : This variant takes a single string command as input and executes it. For example, you can use it to open a text editor:\n• exec(String[] cmdarray) : Use this variant to execute a command and its arguments as separate strings in an array. Here's how you can list files in a directory:\n• exec(String[] cmdarray, String[] envp) : In this version, you can also specify environment variables (envp) for the process. This is useful for customizing the execution environment.\n• exec(String[] cmdarray, String[] envp, File dir) : You can set the working directory for the process using this variant (dir). It's handy when your command relies on relative paths.\n• exec(String command, String[] envp) : Here, you can pass the command as a single string and also provide environment variables. It's a convenient way to execute a command with a customized environment.\n• exec(String command, String[] envp, File dir) : This is a combination of variants 1, 3, and 4. You can specify the command, environment variables, and the working directory.\n\nLet's Dive into Examples : Now, let's get our hands dirty with some interactive examples:\n\nThe exec() function in Java's Runtime class provides various options for communicating with the operating system. Once you understand this, you can easily integrate system commands into your Java programs. Remember to choose the option that best suits your needs. You can then explore process execution possibilities with confidence."
    },
    {
        "link": "https://javadoc.scijava.org/Java11/java.base/java/lang/Process.html",
        "document": "provides control of native processes started by ProcessBuilder.start and Runtime.exec. The class provides methods for performing input from the process, performing output to the process, waiting for the process to complete, checking the exit status of the process, and destroying (killing) the process. The and methods create a native process and return an instance of a subclass ofthat can be used to control the process and obtain information about it.\n\nThe methods that create processes may not work well for special processes on certain native platforms, such as native windowing processes, daemon processes, Win16/DOS processes on Microsoft Windows, or shell scripts.\n\nBy default, the created process does not have its own terminal or console. All its standard I/O (i.e. stdin, stdout, stderr) operations will be redirected to the parent process, where they can be accessed via the streams obtained using the methods , , and . The parent process uses these streams to feed input to and get output from the process. Because some native platforms only provide limited buffer size for standard input and output streams, failure to promptly write the input stream or read the output stream of the process may cause the process to block, or even deadlock.\n\nWhere desired, process I/O can also be redirected using methods of the class.\n\nThe process is not killed when there are no more references to the object, but rather the process continues executing asynchronously.\n\nThere is no requirement that the process represented by a object execute asynchronously or concurrently with respect to the Java process that owns the object.\n\nAs of 1.5, is the preferred way to create a .\n\nSubclasses of Process should override the and methods to provide a fully functional Process including the process id, information about the process, direct children, and direct children plus descendants of those children of the process. Delegating to the underlying Process or ProcessHandle is typically easiest and most efficient."
    },
    {
        "link": "https://stackoverflow.com/questions/39178125/call-a-java-method-using-runtime-exec",
        "document": "That would mean starting a whole new JVM just to make a method call. If you are already \"within\" class A; what prevents you from calling doSomething() directly? Probably: only your lack of skills. If so, then work on your skills; and don't go for the next best solution you heard somebody mention how things might be done!\n\nIn essence: a self-claimed geek should always understand each and any concept he is using in his programs. If you want to use reflection, then study what reflection is about.\n\nAnd please note: letting your users pass in arbitrary strings to have them executed, is a huge security NO GO. You should have mentioned in your question that you want to do this on purpose; and that you are fully aware of the potential consequences of doing so!\n\nIn this case, a solution could be as simple as:\n\nA) you write a new class, like\n\nor if doSomething isn't static, you will need\n\nB) Compile that, and then you can simply send a command like\n\ninto your existing application. Of course, you have to work out the details; like providing a valid classpath to that call to java (that classpath has to include the location where Invoker.class lives; and of course A.class; and all of the dependencies that A has).\n\nBut keep in mind: doSomething() is executed in the scope of a different JVM. That means that most likely, it will not at all affect class A in that JVM where you trigger the call to exec!"
    },
    {
        "link": "https://leejjon.medium.com/handling-exceptions-and-error-responses-in-java-rest-services-afda273c9d2f",
        "document": "I often see presentations about best practices to detect bugs early on and prevent them. Obviously preventing is better than fixing. However, things can always go wrong. Even if your code is perfect the following things can happen:\n• The client can do invalid requests\n• The database might have incorrect data\n\nIn this post I will talk about handling errors. Handling errors nicely will inform users that something went wrong and that they should try again or wait until things have been fixed. If the errors are properly logged the developers can investigate and fix the problems faster.\n\nIf you know a bit of Java you’ll probably think of try-catch statements to handle exceptions. It’s important to know that Java has Checked and Unchecked exceptions. You can read more about Java Exceptions in the Oracle docs on Exceptions.\n\nHere is a bit of Java code where I run two methods from the main thread. One can possibly throw a checked SQLException, while the other can throw a UncheckedException (in this code, the chance for it to happen is 50%):\n\nAs you can see the checked exception needs a throws declaration, while the unchecked exception doesn’t. I used to like checked exceptions when I started to learn Java as it gave me information on what could go wrong in my code. While there are situations where this is useful, most Java REST services nowadays only use unchecked exceptions. I hope to make clear why in the next section.\n\nIt’s only useful to catch an Exception in a method if the method can still fulfill its purpose. Let’s say we have a system like the design below:\n\nThe database service tries to execute an SQL query but it fails. This happens a lot in the real world. The query could have a syntax error, or attempt to retrieve data from a table that no longer exists.\n\nWe could put a try catch statement in the database service, but what needs to happen to nicely handle this error? Probably the controller needs to decide to send an HTTP 500 response. The database service is not able to do that, and neither does the business logic. So let’s put the try catch statement in the controller.\n\nHere is how that looks in some simplified example code:\n\nGetting rid of the checked exception\n\nSee how the BusinessLogic class now has a “throws SQLException” declaration on the doBusinessLogic method? It does nothing with this SQLException, it just gets thrown to the controller. Yet it still makes the code depend on the java.sql package.\n\nYour business logic ultimately shouldn’t care if you use a SQL database, NoSQL database or another REST API to fetch the data from. So it’s definitely not nice that this checked SQLException causes the Business logic to know about the java.sql package.\n\nWe can solve this by using the @SneakyThrows annotation from the Lombok library:\n\nWhen the executeQuery method is annotated with @SneakyThrows, it is no longer forced by the compiler to put throws SQLException behind the consuming methods.\n\nLuckily, @SneakyThrows is only needed in very few places. If you use the Spring framework (like 90% of the Java backends use), you will most likely use the JdbcTemplate instead of the original JDBC classes. The JdbcTemplate already catches all SqlExceptions and rethrows them as unchecked exceptions.\n\nThe above examples are not real “controllers”. Here is an example of catching Exceptions in a RestController using Spring:\n\nNow we are catching any exception at the system boundary right? Great! Well this is usually not how Exception handling in Spring works.\n\nSee this this Spring boot example code from Baeldung:\n\nThey have no ResponseEntity objects in the return types, and they don’t have have try catch statements in the controller either. We could add the try catch, but with the return type Book we can’t return a ResponseEntity object with an INTERNAL_ERROR (500) HTTP status.\n\nWe can modify our Spring example to leave out the ResponseEntity class, and throw a ResponseStatusException (available since Spring 5) to make Spring respond with a 500 response:\n\nHowever this still clutters your controller code. Especially if your controller has 10 methods that all have this try catch pattern. Instead we can define a method just for handling Exceptions and annotate it with the @ExceptionHandler annotation.\n\nSuch a method handles exceptions that occur in all GET/POST/PUT (or any other) mappings in the controller. You could even define a global one that applies to all controllers.\n\nMy previous code snippets already gave it away, we should put logging in the Exception handler. I’m using the @Slf4j annotation from Lombok for logging:\n\nIf you now run your project with you should see exceptions in your logs.\n\nWhy logging on the boundaries sometimes isn’t enough…\n\nI know I just talked you into catching and logging the exceptions on the system boundaries. But sometimes to troubleshoot you need more. You might want to log the values of certain query parameters when a database query fails. If we try to log at the system boundary (the controller), we don’t have these parameters anymore! So we must do this in the database service itself.\n\nHere is my DatabaseService.java that uses the JdbcTemplate of the Spring framework. This query will fail in my project simply because there is no “records” table.\n\nWhen running this you’ll see that actually a SQLSyntaxErrorException (extends SQLException and thus is a checked exception) is happening. The spring JDBC wraps it in a BadSqlGrammarException, which is a runtime exception so we don’t have to put @SneakyThrows above the runQuery method.\n\nLet’s alter the code to log the error and the parameter:\n\nBut wait, if you test with this code, the error is logged twice! Once in the DatabaseService and once in the Controller. That is confusing. We can fix that by creating an AlreadyLoggedException class to wrap around the exception.\n\nMake sure to wrap the DataAccessException into this AlreadyLoggedException when rethrowing:\n\nAnd finally add an extra @ExceptionHandler method in the controller to handle all AlreadyLoggedExceptions:\n\nDone, no more duplicate error logging.\n\nTracing back client errors to the correct Exception and Stack trace in the logs\n\nIn all companies I’ve worked for, it was normal to respond with a HTTP 500 status in case of exceptions. But how do you troubleshoot this when such things happen on production? Imagine the following situation:\n\nLet’s say you’re the backend guy. The support desk tells you users are complaining that the button on the frontend gives generic errors.\n\nWhat typically happens is that you’re going to ask one user the moment he got the error. If this user bothers to reply, he might give an inaccurate timestamp. If your log is full different of errors, it might be hard to find out what’s happening.\n\nAt the last few companies I’ve worked I have advocated to generate an ID for every exception and add it to the logs (along with the stacktrace). In the HTTP response, return this ID. That way your frontend can display it to the end user. When the end user complains to your customer service, the customer service can ask for this ID and pass it to the developer. With that ID, the developer can do a simple search in the logs to find the exact log message that caused the user’s problem.\n\nImplementing logging id’s and putting them in the HTTP response\n\nWe can generate a unique identifier (UUID) in Java to make sure we generate something that is hopefully unique within our logs:\n\nLet’s add it to our exception handler method.\n\nTo make this work for the exceptions that are caught on other places in the code such as the DatabaseService, we need to alter our AlreadyLoggedException so it can bring the UUID to the controller.\n\nNow we can update our DatabaseService to pass the UUID to the AlreadyLoggedException.\n\nIf you have to do this on many places, you might want to create a utility method to log the error and generate a UUID in there.\n\nFinally, we can update the AlreadyLoggedException handler in the controller and make it pass the UUID to the HTTP response.\n\nHere is what is looks like when you run the code:\n\nIn my example, I’ve not defined a whole API spec to keep it simple. If you have an API based on an OpenAPI spec, you want to define the JSON of the error responses and include this error UUID.\n\nWhen I wanted to implement passing a UUID back to the frontend at work I noticed that our project already used Sleuth for tracing. Sleuth provides autoconfiguration for distributed tracing. Distributed tracing is way beyond the scope of this article, but it does automatically add an id to every log message in your code. This id is unique for every incoming request.\n\nTo get this behavior, all you need to do is add this dependency to your spring boot application:\n\nYou might also need to add this to your dependencyManagement if you haven’t already:\n\nYou can easily auto wire the Sleuth “tracer” in any Spring component to get the uuid and put it in your HTTP response:\n\nYou could also add a filter to add a header with the trace ID in any response. That way you can track any request, not just the ones that give an error:\n\nWhen you run the application again with you should see the response header being added.\n\nIn the GET request of my examples there is no validation. If you add POST or PUT requests you might need to add it. When we add a POST call to our RestController, we can put the @Valid annotation before the SomePost parameter to make Spring validate it:\n\nWe need to define the SomePost class with some validation annotations to tell Spring how to validate it:\n\nIf we now run our application with and execute a curl command with an invalid e-mail in the request body:\n\nWhen Spring attempts to validate this request it will fail the validation and throw a MethodArgumentNotValidException. Our exception handler logs the stacktrace below and throws a 500:\n\nApart from this stacktrace not being useful as our application is not doing anything wrong, the service should respond with 400 (BAD_REQUEST).\n\nNow the curl command will get a 400 response with the following body:\n• Catch all exceptions at the system boundaries. In a REST service this means the controller.\n• Return the generated UUID to the consumer of your service. If they complain that something doesn’t work, ask for this UUID so you can find to the related exception in your logs.\n• Don’t log validation failures. Provide good API documentation so the consumer of your API can figure out what to do if they get 400’s back from your service.\n\nThe full code can be found on GitHub. There might be a 100 ways to improve this. If you think I might be missing something essential, let me know!"
    },
    {
        "link": "https://j-labs.pl/en/tech-blog/java-exception-handling-strategies-and-best-practices",
        "document": "Exception handling is a critical aspect of Java programming that allows developers to manage errors and unexpected situations gracefully. Proper exception handling enhances the reliability and maintainability of the code. In this article, we will delve into best practices and strategies for effective exception handling in Java.\n\nException handling is the process of dealing with runtime errors, ensuring that applications can gracefully recover from unexpected scenarios. Java’s exception handling mechanism involves try-catch blocks, where the code that might throw an exception is enclosed in a try block, and a possible exception handling code is placed in corresponding catch blocks.\n\nIn Java, exceptions are categorized into three main types based on their origin and behavior: checked exceptions, unchecked exceptions, and errors. This categorization helps developers understand the nature of exceptions and how they should be handled in the code.\n\nThe exception hierarchy in Java is organized into a class hierarchy that inherits from the Throwable class. Here’s a simplified diagram of the exception hierarchy in Java:\n\nHere’s a brief explanation of each level of the hierarchy:\n• Throwable: This is the root class of the exception hierarchy. Both errors and exceptions inherit from this class. It provides methods like getMessage() and printStackTrace().\n• Error: These exceptions are typically thrown by the JVM itself to indicate serious problems that usually cannot be handled by the application code. Examples include OutOfMemoryError and StackOverflowError.\n• Exception: These exceptions are more specific and can be either checked or unchecked. Checked exceptions must be caught or declared using the throws clause in the method signature.\n• Unchecked (RuntimeException): These are exceptions that often arise due to programming errors or unexpected conditions. They are not required to be caught or declared.\n• Checked: These are a subset of exceptions that the compiler requires us to either catch and handle using a try-catch block or declare to be thrown using the throws clause in the method signature. Checked exceptions are typically used to represent exceptional conditions that are recoverable and that the programmer can reasonably anticipate and handle.\n\nThis hierarchy helps in categorizing and organizing exceptions based on their nature and behavior. It’s essential to understand this hierarchy when handling exceptions in Java, as it guides you on how exceptions are related and when they need to be caught or declared.\n\nChecked exceptions are exceptions that are checked at compile-time, meaning the compiler ensures that these exceptions are either caught using a try-catch block or declared to be thrown using the throws keyword in the method signature. These exceptions usually represent conditions that are beyond the control of the programmer and are typically related to external factors, such as I/O operations or network issues.\n• IOException: Raised when there’s an issue with input or output operations, such as reading or writing to files.\n• ClassNotFoundException: Raised when a class is not found during runtime.\n\nUnchecked exceptions, also known as runtime exceptions, do not need to be declared explicitly in the method signature or caught using a try-catch block. They occur due to programming errors and are often preventable through better coding practices. Unchecked exceptions propagate up the call stack until they are caught or the program terminates.\n• NullPointerException: Raised when trying to access an object or method on a null reference.\n• ArrayIndexOutOfBoundsException: Raised when trying to access an array element with an invalid index.\n• IllegalArgumentException: Raised when a method is passed an inappropriate or invalid argument.\n• ArithmeticException: Raised when an arithmetic operation is attempted with illegal or undefined values.\n\nErrors represent exceptional conditions that are beyond the control of the application and typically indicate serious problems that may lead to an abnormal termination of the program. Unlike exceptions, errors are not intended to be caught or handled by the application code.\n• OutOfMemoryError: Raised when the JVM runs out of memory.\n• StackOverflowError: Raised when the call stack of a program exceeds its limit.\n• NoClassDefFoundError: Raised when the JVM cannot find a class definition.\n\nIt’s important to understand these categories of exceptions to write robust and maintainable Java code. Checked exceptions should be handled or declared as appropriate, while unchecked exceptions are usually addressed through better programming practices. Errors are typically not handled by the application code and may require corrective actions at the system level.\n• Use Specific Exception Classes: Handle exceptions at a granular level by catching specific exception classes rather than generic ones.\n• Handle Exceptions at the Right Level: Catch exceptions at the level where they can be effectively dealt with.\n• Avoid Catching Generic Exceptions: Avoid using catch (Exception e) as it might hide underlying issues.\n• Use a Finally Block Sparingly: Use finally only for essential cleanup operations.\n• Logging and Reporting Exceptions: Always log exceptions for troubleshooting and debugging purposes.\n• Avoid Empty Catch Blocks: Empty catch blocks can lead to silent failures; at least log the exception.\n• Fail Fast: Detect issues as early as possible in the development process.\n• Graceful Degradation: Design applications to continue functioning even when exceptions occur.\n• Exception Propagation: Allow exceptions to propagate up the call stack if they cannot be handled locally.\n\nIn this example, we have three methods: method1(), method2(), and method3(). Each method calls the next method in the sequence. In method3(), we intentionally cause an ArithmeticException by dividing an integer by zero.\n\nThe exception propagates from method3() to method2(), then from method2() to method1(), and finally from method1() to the main method. The exception is caught in the main method’s try-catch block, and the program doesn’t terminate abnormally.\n\nThis example demonstrates how exceptions travel up the call stack until they are caught or the program terminates. It also highlights the importance of handling exceptions appropriately to ensure the robustness of your code.\n• Custom Exception Classes: Create custom exception classes for domain-specific errors. Custom exception classes allow you to define your own exception types to represent specific errors or exceptional situations in your application.\n\nIn this example, we have defined a custom exception class InsufficientBalanceException that extends the built-in Exception class. This exception is designed to represent situations where there’s not enough balance in a bank account for a withdrawal.\n\nThe BankAccount class has a withdraw method that throws the InsufficientBalanceException if the withdrawal amount exceeds the account balance.\n\nIn the main method, we create an instance of BankAccount and attempt to withdraw an amount greater than the account balance. Since the withdrawal would lead to an insufficient balance, the InsufficientBalanceException is thrown. We catch this exception and display an error message.\n\nCustom exception classes allow you to encapsulate domain-specific errors and provide meaningful error messages for easier debugging and error handling in your application.\n• Try-With-Resources: Use try-with-resources to automatically close resources like files and connections.\n\nBest Practices for Exception Messages in Java\n\nException messages play a crucial role in understanding and debugging errors in your code. Well-crafted exception messages can significantly improve the clarity and maintainability of your software. Here are some best practices for creating effective exception messages:\n\nException messages should clearly convey what went wrong and why. Use plain language to describe the error in a way that is easy for developers to understand.\n\nInclude context-relevant details in the message. This might include the values of variables, inputs, or conditions that caused the exception. However, avoid exposing sensitive data.\n\nFollow a consistent format for exception messages throughout your codebase. This makes it easier for developers to recognize and handle different types of errors.\n\nPhrase exception messages in the active voice to clearly indicate the cause of the error. For example, “File not found” is more informative than “File was not found.”\n\nWhile you want to provide meaningful information, avoid using technical jargon that might confuse other developers or stakeholders who read the error messages.\n\nSpell out terms instead of using abbreviations or acronyms. This ensures that everyone can understand the message, even those who are not familiar with the abbreviations.\n\nIf possible, suggest potential solutions or actions that the developer can take to resolve the issue. This can help in the troubleshooting process.\n\nException messages are part of your application’s user interface, so use proper punctuation, capitalization, and formatting to make them readable and professional.\n\n9. Keep It Short and Precise\n\nException messages should be concise and to the point. Avoid lengthy messages that might overwhelm the developer or clutter the log.\n\nIf your software is used in different locales, consider providing localized exception messages to cater to users who speak different languages.\n\nWhen logging exceptions, include the stack trace to provide developers with a detailed view of where the exception occurred in the code. This aids in diagnosing the issue.\n\nWhile it’s important to indicate errors, avoid blaming the user directly in the message. Instead, focus on explaining the issue and providing a solution.\n\nRemember that the goal of exception messages is to help developers identify and fix issues quickly. By following these best practices, you can make your error messages more informative, user-friendly, and conducive to effective troubleshooting and debugging.\n\nIn functional programming, the approach to handling exceptions is slightly different from traditional imperative programming. Functional programming emphasizes immutability, pure functions, and avoiding side effects. While exceptions are still used to handle errors, they are typically managed in a way that aligns with the functional programming principles. Here’s how you can handle exceptions in functional programming using Java:\n\nInstead of throwing exceptions, functional programming often uses option types (like Optional in Java). These constructs allow you to represent success or failure explicitly and safely.\n\nFunctional programming promotes composing functions to transform data. When dealing with exceptions, you can chain functions that handle different error cases.\n\nIn functional programming, functions should be side-effect free. This means that functions should not modify the external state. Instead of directly modifying the external state, return updated copies of data.\n\nEffective exception handling is a cornerstone of robust Java applications. By following best practices and adopting appropriate exception handling strategies, developers can build applications that gracefully handle errors, provide meaningful feedback to users, and maintain a high level of reliability.\n\nIn this article, we have discussed essential best practices, strategies, and real-world examples that empower Java developers to master the art of exception handling, enhancing the overall quality of their software projects."
    },
    {
        "link": "https://stackoverflow.com/questions/32545270/best-practice-for-java-exception-handling",
        "document": "First of all the problem with \"best practice\" advice is that it tends to over-simplify the question and the answer. Then someone (like yourself) comes along and notices that it is contradictory1.\n\nIMO, best practice is to take \"best practice\" advice and people who regularly use that phrase with a healthy level of suspicion. Try to understand the real issues yourself, and reach your own conclusions ... rather than just relying someone else to tell you what is \"best practice\".\n\n1 - Or worse ... they don't notice the contradictions, edge-cases, etc, and blindly follow the so-called \"best practice\". And occasionally, they find themselves in a dark place, because the \"best practice\" recommendation was inappropriate.\n\nSo what's the problem here? It is this statement:\n\nIn fact, it is not normally good coding practice to catch generic exceptions like . But it is the right thing to do in some circumstances. And your example is one where it is appropriate.\n\nWell lets look a case where catching is a bad idea:\n\nWhy is that a bad idea? Because that is going to catch and handle unexpected exceptions; i.e. exceptions that you (the developer) did not think were possible, or that you did not even consider. That's OK ... but then the code logs the exception, and continues running as if nothing happened.\n\nThat's the real problem ... attempting to recover from an unexpected exception.\n\nThe (so-called) \"best practice\" advice to \"never catch generic exceptions\" deals with the issue, but in a crude way that doesn't deal with the edge cases. One of the edge cases is that catching (and logging) a generic exception is OK if you then immediately shut the application down ... like you are doing.\n\nNow contrast that with the (supposedly) good practice version in your question. What is the difference?\n• Your version produces more user friendly / less alarming diagnostics ... up to a point.\n• Your version is significantly more code.\n• Your version is unhelpful to someone trying to diagnose the problem because the stacktraces are not recorded.\n\nAnd the counterpoints to 1 and 2 are:\n• You can spend limitless time honing the \"user friendly\" diagnostics for an application, and still fail to help the kind of user who can't or won't understand ...\n• It also depends on who the typical user is.\n\nAs you can see, this is far more nuanced than \"catching generic exceptions is bad practice\"."
    },
    {
        "link": "https://geeksforgeeks.org/exceptions-in-java",
        "document": "Exception handling in Java allows developers to manage runtime errors effectively by using mechanisms like try-catch block, finally block, throwing Exceptions, Custom Exception handling, etc.\n\nAn Exception is an unwanted or unexpected event that occurs during the execution of a program (i.e., at runtime) and disrupts the normal flow of the program’s instructions. It occurs when something unexpected things happen, like accessing an invalid index, dividing by zero, or trying to open a file that does not exist.\n\nException in Java is an error condition that occurs when something wrong happens during the program execution.\n\nExample: Showing an Arithmetic Exception or you can say divide by zero exception.\n\nException handling in Java is an effective mechanism for managing runtime errors to ensure the application’s regular flow is maintained. Some Common examples of exceptions include ClassNotFoundException, IOException, SQLException, RemoteException, etc. By handling these exceptions, Java enables developers to create robust and fault-tolerant applications.\n\nExample: The below Java program modifies the previous example to handle an ArithmeticException using try-catch, and finally blocks and keep the program running.\n\nThe summary is depicted via visual aid below as follows:\n\nAll exception and error types are subclasses of the class Throwable, which is the base class of the hierarchy. One branch is headed by Exception. This class is used for exceptional conditions that user programs should catch. NullPointerException is an example of such an exception. Another branch, Error is used by the Java run-time system(JVM) to indicate errors having to do with the run-time environment itself(JRE). StackOverflowError is an example of such an error.\n\nThe below figure demonstrates the exception hierarchy in Java:\n\nExceptions can occur due several reasons, such as:\n\nErrors represent irrecoverable conditions such as Java virtual machine (JVM) running out of memory, memory leaks, stack overflow errors, library incompatibility, infinite recursion, etc. Errors are usually beyond the control of the programmer, and we should not try to handle errors.\n\nTo know more differences about Exception and Errors, refer to this article: Exception vs Errors in Java.\n\nJava defines several types of exceptions that relate to its various class libraries. Java also allows users to define their own exceptions.\n\nExceptions can be categorized in two ways:\n\nBuild-in Exception are pre-defined exception classes provided by Java to handle common errors during program execution.\n\nChecked exceptions are called compile-time exceptions because these exceptions are checked at compile-time by the compiler. Examples of Checked Exception are listed below:\n• ClassNotFoundException: Throws when the program tries to load a class at runtime but the class is not found because its not present in the correct location or it is missing from the project.\n• InterruptedException: Thrown when a thread is paused and another thread interrupts it.\n• InstantiationException: Thrown when the program tries to create an object of a class but fails because the class is abstract, an interface, or has no default constructor.\n• SQLException: Throws when there’s an error with the database.\n• FileNotFoundException: Thrown when the program tries to open a file that doesn’t exist\n\nThe unchecked exceptions are just opposite to the checked exceptions. The compiler will not check these exceptions at compile time. In simple words, if a program throws an unchecked exception, and even if we didn’t handle or declare it, the program would not give a compilation error. Examples of Unchecked Exception are listed below:\n• ArithmeticException: It is thrown when there’s an illegal math operation.\n• ClassCastException: It is thrown when you try to cast an object to a class it does not belongs to.\n• NullPointerException: It is thrown when you try to use a null object (e.g. accessing its methods or fields)\n• ArrayIndexOutOfBoundsException: It occurs when we try to access an array element with an invalid index.\n• ArrayStoreException: h appens when you store an object of the wrong type in an array.\n• IllegalThreadStateException: It is thrown when a thread operation is not allowed in its current state\n\nSometimes, the built-in exceptions in Java are not able to describe a certain situation. In such cases, users can also create exceptions, which are called “user-defined Exceptions“.\n\nA try-catch block in Java is a mechanism to handle exception. The try block contains code that might thrown an exception and the catch block is used to handles the exceptions if it occurs.\n\nThe finally Block is used to execute important code regardless of whether an exception occurs or not.\n\nNote: finally block is always executes after the try-catch block. It is also used for resource cleanup.\n\nWe can handle multiple type of exceptions in Java by using multiple catch blocks, each catching a different type of exception.\n\nHow Does JVM Handle an Exception?\n\nDefault Exception Handling: When an Exception occurs, the JVM Creates an exception object containing the error name, description, and program state. Creating the Exception Object and handling it in the run-time system is called throwing an Exception. There might be a list of the methods that had been called to get to the method where an exception occurred. This ordered list of methods is called Call Stack. Now the following procedure will happen.\n• None The run-time system searches the call stack for an Exception handler\n• None It starts searching from the method where the exception occurred and proceeds backward through the call stack.\n• None If a handler is found, the exception is passed to it.\n• None If no handler is found, the default exception handler terminates the program and prints the stack trace.\n\nLook at the below diagram to understand the flow of the call stack.\n\nLet us see an example that illustrates how a run-time system searches for appropriate exception handling code on the call stack.\n\nCustomized Exception Handling: Java exception handling uses five keywords: try, catch, throw and throws, and finally. Code that might cause an exception goes in the try block. If an exception occurs, it is caught using catch. We can throw exceptions manually with throw, and methods must declare exceptions they can throw using throws. The finally block is used for code that must run after try, whether an exception occurs or not.\n\nConsider the below program in order to get a better understanding of the try-catch clause.\n\nExplanation: In the above example, an array is defined with size i.e. we can access elements only from index 0 to 3. But we trying to access the elements at index 4 (by mistake) that is why it is throwing an exception. In this case, JVM terminates the program abnormally. The statement System.out.println(“Hi, I want to execute”); will never execute. To execute it, we must handle the exception using try-catch. Hence to continue the normal flow of the program, we need a try-catch clause."
    },
    {
        "link": "https://reddit.com/r/rust/comments/jdvtu4/javas_error_handling_system_is_better_than_that",
        "document": "I realize that this is a controversial statement, but hear me out. I really like most things in Rust, but the error handling leaves a lot to be desired.\n\nRust's error handling system is often praised for its explicitness — the possible error types from a method are right there in the signature, and you can see how the control flow in the program handles it just by reading the function (see an example of this argument here). Yet, this system isn't without flaw: one needs to deal with complicated and verbose custom error types (and also complicated macros to make these types — at least compared to Java's system), and one needs to spam their code with , , and other error handling boilerplate. Furthermore, if an error propagates through several libraries, it's underlying type can be obscured since each time it can be wrapped.\n\nJava accomplishes the same explicitness and compile-time-correctness-enforcement (mostly, since exists, and polymorphism can make it much less explicit), but without these problems. To understand this, consider a toy function that reads a file and returns an ArrayList of lines. In Java, it might look something like this:\n\nIn this example, is part of the method signature, so a user of this method can trivially determine what exceptions, if any, it can throw. If a function that does not have a in its declaration attempts to call any other function that does claim to throw that exception will result in a compiler error, just as one would expect from a good language (and the kind of behavior that Rust rightly tries to do). This example, though, only shows that Java ensures correctness as Rust does — it isn't really any better than how this would work in Rust, where with the unary operator could be used.\n\nThe first place where Java's error system really shines is when multiple types of errors can take place. Consider a toy example that will make an HTTP request and then parse JSON from it. In this case, there are fictitious functions (assumed to be from libraries): , , each doing what one would expect. The HTTP request and parse function may look like this:\n\nThat's it. That's the entire function, with all error handling laid out there. There is no complicated and verbose error chain type squirreled away in some module, no complicated and non-standard macro to generate that type in a highly implicit manner, and no additional dependencies. Clearly, it's much nicer than Rust to write this function.\n\nBut what if the author of this function didn't want the user of their function to have to worry about HTTP status codes? No problem, that's easily handled:\n\nNow, the user only has to worry about IOException as one . This is a bit nicer than Rust's system of using pattern matching for the error since in the 's main body one can see the normal error-free control flow of the function, and at the bottom with each (Java allows multiple catches with a single try) one can see what happens in each scenario where it goes wrong. In Java, one sometimes needs to have some additional control flow here to properly handle it, but Rust's pattern matching in the blocks would greatly reduce this to nearly nothing. For example, with this system, it's also possible for a user of the function to care about the status code if they so desire:\n\nThe last advantage of Java's system is that the errors, when printed (either because throws some exception type(s), or because was called), are both more informative and easier to read. Consider this example stack trace (taken from here):\n\nIt gives a lot of information: the thread that the exception took place in, the exact exception, a human-readable message to go with it (Java can bundle machine readable information in an exception type too), a full stack trace giving a lot of detail of where the exception took place, and a very useful line, with its own stack trace, that can help one drill down to the root cause of an exception. Compare this to Rust, which, in the best case may look like this: (in the case of a unit-type-like struct being used for errors), or, in the best case like this: MyProjectFooBarError{cause: ArithmeticException(\"The denominator must not be zero\"), message: \"The number of FooBars cannot be zero\"} . Sure, there's probably enough information there, but it's all packed in on a mostly-machine-readable single line as opposed to Java where it's more for humans (this message is generated from a machine-readable data structure that code can easily query — all of that information is accessible to code too), aside from the extra information of course.\n\nNow, one may object and claim that Rust's system is superior becuase it has clearer control flow — there are no apparantly magical jumps from one method to 10 methods up the call stack where the corresponding catch is. To this, I have four things to say:\n• It's not magical. There are well-defined rules for how this works, and a debugger can instantly tell you where the catch is taking place.\n• It's not really any better in Rust if an error type is passed several methods up the call chain before its handled, except a debugger can't instantly tell you where that handling is taking place.\n• When looking at a function in Rust, the only clue that implicit error handling is taking place is , which isn't very informative and is easily missed. Furthermore, in Java the exact list of exceptions that can be thrown from this particular method is listed in the method header. Whereas in Rust, at best you need to dig through to find the error type for that crate (not very hard with a goto feature in an IDE), and at worst you don't know which error enum variations from that crate's type can actually result from this method, since most to all erroring functions in a crate are likely to share one type.\n• If you're writing your Java code correctly, this won't matter (very much), since at the throwing end all you need to worry about is that something erroneous happened, and at the recieving end all you need to worry about is that the function that you just called had an error of the particular exception type.\n\nLastly, one may object and claim that many to all of Java's advantages are negated by polymorphism — where a function says that it throws some very broad base class of many different concrete exeptions (in the worst case , which means that the caller needs to handle literally any error), and/or by which tells the compiler to ignore any enforcement of handling. For Rust, these two flaws should not be present, although it is arguable in Java, so, essentially, on these specific points, I agree with the criticism."
    }
]