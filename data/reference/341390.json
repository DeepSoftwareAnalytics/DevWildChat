[
    {
        "link": "https://typescriptlang.org/docs/handbook/2/objects.html",
        "document": "In JavaScript, the fundamental way that we group and pass around data is through objects. In TypeScript, we represent those through object types.\n\nAs we’ve seen, they can be anonymous:\n\nor they can be named by using either an interface:\n\nIn all three examples above, we’ve written functions that take objects that contain the property (which must be a ) and (which must be a ).\n\nWe have cheat-sheets available for both and , if you want a quick look at the important every-day syntax at a glance.\n\nEach property in an object type can specify a couple of things: the type, whether the property is optional, and whether the property can be written to.\n\nMuch of the time, we’ll find ourselves dealing with objects that might have a property set. In those cases, we can mark those properties as optional by adding a question mark ( ) to the end of their names.\n\nIn this example, both and are considered optional. We can choose to provide either of them, so every call above to is valid. All optionality really says is that if the property is set, it better have a specific type.\n\nWe can also read from those properties - but when we do under , TypeScript will tell us they’re potentially .\n\nIn JavaScript, even if the property has never been set, we can still access it - it’s just going to give us the value . We can just handle specially by checking for it.\n\nNote that this pattern of setting defaults for unspecified values is so common that JavaScript has syntax to support it.\n\nHere we used a destructuring pattern for ’s parameter, and provided default values for and . Now and are both definitely present within the body of , but optional for any callers to .\n\nProperties can also be marked as for TypeScript. While it won’t change any behavior at runtime, a property marked as can’t be written to during type-checking.\n\nUsing the modifier doesn’t necessarily imply that a value is totally immutable - or in other words, that its internal contents can’t be changed. It just means the property itself can’t be re-written to.\n\nIt’s important to manage expectations of what implies. It’s useful to signal intent during development time for TypeScript on how an object should be used. TypeScript doesn’t factor in whether properties on two types are when checking whether those types are compatible, so properties can also change via aliasing.\n\nUsing mapping modifiers, you can remove attributes.\n\nSometimes you don’t know all the names of a type’s properties ahead of time, but you do know the shape of the values.\n\nIn those cases you can use an index signature to describe the types of possible values, for example:\n\nAbove, we have a interface which has an index signature. This index signature states that when a is indexed with a , it will return a .\n\nOnly some types are allowed for index signature properties: , , , template string patterns, and union types consisting only of these.\n\nWhile string index signatures are a powerful way to describe the “dictionary” pattern, they also enforce that all properties match their return type. This is because a string index declares that is also available as . In the following example, ’s type does not match the string index’s type, and the type checker gives an error:\n\nHowever, properties of different types are acceptable if the index signature is a union of the property types:\n\nFinally, you can make index signatures in order to prevent assignment to their indices:\n\nYou can’t set because the index signature is .\n\nWhere and how an object is assigned a type can make a difference in the type system. One of the key examples of this is in excess property checking, which validates the object more thoroughly when it is created and assigned to an object type during creation.\n\nNotice the given argument to is spelled instead of . In plain JavaScript, this sort of thing fails silently.\n\nYou could argue that this program is correctly typed, since the properties are compatible, there’s no property present, and the extra property is insignificant.\n\nHowever, TypeScript takes the stance that there’s probably a bug in this code. Object literals get special treatment and undergo excess property checking when assigning them to other variables, or passing them as arguments. If an object literal has any properties that the “target type” doesn’t have, you’ll get an error:\n\nGetting around these checks is actually really simple. The easiest method is to just use a type assertion:\n\nHowever, a better approach might be to add a string index signature if you’re sure that the object can have some extra properties that are used in some special way. If can have and properties with the above types, but could also have any number of other properties, then we could define it like so:\n\nHere we’re saying that can have any number of properties, and as long as they aren’t or , their types don’t matter.\n\nOne final way to get around these checks, which might be a bit surprising, is to assign the object to another variable: Since assigning won’t undergo excess property checks, the compiler won’t give you an error:\n\nThe above workaround will work as long as you have a common property between and . In this example, it was the property . It will however, fail if the variable does not have any common object property. For example:\n\nKeep in mind that for simple code like above, you probably shouldn’t be trying to “get around” these checks. For more complex object literals that have methods and hold state, you might need to keep these techniques in mind, but a majority of excess property errors are actually bugs.\n\nThat means if you’re running into excess property checking problems for something like option bags, you might need to revise some of your type declarations. In this instance, if it’s okay to pass an object with both a or property to , you should fix up the definition of to reflect that.\n\nIt’s pretty common to have types that might be more specific versions of other types. For example, we might have a type that describes the fields necessary for sending letters and packages in the U.S.\n\nIn some situations that’s enough, but addresses often have a unit number associated with them if the building at an address has multiple units. We can then describe an .\n\nThis does the job, but the downside here is that we had to repeat all the other fields from when our changes were purely additive. Instead, we can extend the original type and just add the new fields that are unique to .\n\nThe keyword on an allows us to effectively copy members from other named types, and add whatever new members we want. This can be useful for cutting down the amount of type declaration boilerplate we have to write, and for signaling intent that several different declarations of the same property might be related. For example, didn’t need to repeat the property, and because originates from , a reader will know that those two types are related in some way.\n\ns can also extend from multiple types.\n\ns allowed us to build up new types from other types by extending them. TypeScript provides another construct called intersection types that is mainly used to combine existing object types.\n\nAn intersection type is defined using the operator.\n\nHere, we’ve intersected and to produce a new type that has all the members of and .\n\nWe just looked at two ways to combine types which are similar, but are actually subtly different. With interfaces, we could use an clause to extend from other types, and we were able to do something similar with intersections and name the result with a type alias. The principal difference between the two is how conflicts are handled, and that difference is typically one of the main reasons why you’d pick one over the other between an interface and a type alias of an intersection type.\n\nIf interfaces are defined with the same name, TypeScript will attempt to merge them if the properties are compatible. If the properties are not compatible (i.e., they have the same property name but different types), TypeScript will raise an error.\n\nIn the case of intersection types, properties with different types will be merged automatically. When the type is used later, TypeScript will expect the property to satisfy both types simultaneously, which may produce unexpected results.\n\nFor example, the following code will throw an error because the properties are incompatible:\n\nIn contrast, the following code will compile, but it results in a type:\n\nIn this case, Staff would require the name property to be both a string and a number, which results in property being of type .\n\nLet’s imagine a type that can contain any value - s, s, s, whatever.\n\nRight now, the property is typed as , which works, but can lead to accidents down the line.\n\nWe could instead use , but that would mean that in cases where we already know the type of , we’d need to do precautionary checks, or use error-prone type assertions.\n\nOne type safe approach would be to instead scaffold out different types for every type of .\n\nBut that means we’ll have to create different functions, or overloads of functions, to operate on these types.\n\nThat’s a lot of boilerplate. Moreover, we might later need to introduce new types and overloads. This is frustrating, since our box types and overloads are all effectively the same.\n\nInstead, we can make a generic type which declares a type parameter.\n\nYou might read this as “A of is something whose have type ”. Later on, when we refer to , we have to give a type argument in place of .\n\nThink of as a template for a real type, where is a placeholder that will get replaced with some other type. When TypeScript sees , it will replace every instance of in with , and end up working with something like . In other words, and our earlier work identically.\n\nis reusable in that can be substituted with anything. That means that when we need a box for a new type, we don’t need to declare a new type at all (though we certainly could if we wanted to).\n\nThis also means that we can avoid overloads entirely by instead using generic functions.\n\nIt is worth noting that type aliases can also be generic. We could have defined our new interface, which was:\n\nby using a type alias instead:\n\nSince type aliases, unlike interfaces, can describe more than just object types, we can also use them to write other kinds of generic helper types.\n\nWe’ll circle back to type aliases in just a little bit.\n\nGeneric object types are often some sort of container type that work independently of the type of elements they contain. It’s ideal for data structures to work this way so that they’re re-usable across different data types.\n\nIt turns out we’ve been working with a type just like that throughout this handbook: the type. Whenever we write out types like or , that’s really just a shorthand for and .\n\nMuch like the type above, itself is a generic type.\n\nModern JavaScript also provides other data structures which are generic, like , , and . All this really means is that because of how , , and behave, they can work with any sets of types.\n\nThe is a special type that describes arrays that shouldn’t be changed.\n\nMuch like the modifier for properties, it’s mainly a tool we can use for intent. When we see a function that returns s, it tells us we’re not meant to change the contents at all, and when we see a function that consumes s, it tells us that we can pass any array into that function without worrying that it will change its contents.\n\nUnlike , there isn’t a constructor that we can use.\n\nInstead, we can assign regular s to s.\n\nJust as TypeScript provides a shorthand syntax for with , it also provides a shorthand syntax for with .\n\nOne last thing to note is that unlike the property modifier, assignability isn’t bidirectional between regular s and s.\n\nA tuple type is another sort of type that knows exactly how many elements it contains, and exactly which types it contains at specific positions.\n\nHere, is a tuple type of and . Like , it has no representation at runtime, but is significant to TypeScript. To the type system, describes arrays whose index contains a and whose index contains a .\n\nIf we try to index past the number of elements, we’ll get an error.\n\nWe can also destructure tuples using JavaScript’s array destructuring.\n\nOther than those length checks, simple tuple types like these are equivalent to types which are versions of s that declare properties for specific indexes, and that declare with a numeric literal type.\n\nAnother thing you may be interested in is that tuples can have optional properties by writing out a question mark ( after an element’s type). Optional tuple elements can only come at the end, and also affect the type of .\n\nTuples can also have rest elements, which have to be an array/tuple type.\n• describes a tuple whose first two elements are and respectively, but which may have any number of s following.\n• describes a tuple whose first element is and then any number of s and ending with a .\n• describes a tuple whose starting elements are any number of s and ending with a then a .\n\nA tuple with a rest element has no set “length” - it only has a set of well-known elements in different positions.\n\nWhy might optional and rest elements be useful? Well, it allows TypeScript to correspond tuples with parameter lists. Tuples types can be used in rest parameters and arguments, so that the following:\n\nThis is handy when you want to take a variable number of arguments with a rest parameter, and you need a minimum number of elements, but you don’t want to introduce intermediate variables.\n\nOne final note about tuple types - tuple types have variants, and can be specified by sticking a modifier in front of them - just like with array shorthand syntax.\n\nAs you might expect, writing to any property of a tuple isn’t allowed in TypeScript.\n\nTuples tend to be created and left un-modified in most code, so annotating types as tuples when possible is a good default. This is also important given that array literals with assertions will be inferred with tuple types.\n\nHere, never modifies its elements, but expects a mutable tuple. Since ’s type was inferred as , it won’t be compatible with since that type can’t guarantee ’s elements won’t be mutated."
    },
    {
        "link": "https://reddit.com/r/typescript/comments/qc6u5d/whats_the_best_practice_for_when_to_use_interface",
        "document": "So I'm just getting into TypeScript, and it seems like there are multiple ways to handle types. You've got interfaces:\n\nIs there a good rule of thumb for when you would want to use one of these vs. another?"
    },
    {
        "link": "https://typescriptlang.org/docs/handbook/interfaces.html",
        "document": ""
    },
    {
        "link": "https://blog.logrocket.com/types-vs-interfaces-typescript",
        "document": "Editor’s note: This article was last updated on 5 September 2024 by Vijit Ail to reflect the latest updates on primitive types, union types, and advanced function types in TypeScript .\n\nWe have two options for defining types in TypeScript: types and interfaces. One of the most frequently asked questions about TypeScript is whether we should use interfaces or types.\n\nThe answer to this question, like many programming questions, is that it depends. In some cases, one has a clear advantage over the other, but in many cases, they are interchangeable.\n\nIn this article, I will discuss the key differences and similarities between types and interfaces and explore when it is appropriate to use each one.\n\nLet’s start with the basics of types and interfaces.\n\nis a keyword in TypeScript that we can use to define the shape of data. The basic types in TypeScript include:\n\nEach has unique features and purposes, allowing developers to choose the appropriate one for their particular use case.\n\nType aliases in TypeScript mean “a name for any type.” They provide a way of creating new names for existing types. Type aliases don’t define new types; instead, they provide an alternative name for an existing type.\n\n Type aliases can be created using the keyword, referring to any valid TypeScript type, including primitive types.\n\nIn the above example, we create two type aliases: and . We can use as shorthand for a number type and use to represent the type definition of a user.\n\nWhen we say “types versus interfaces,” we refer to “type versus interfaces.” For example, you can create the following aliases:\n\nThe two type aliases above represent alternative names for the same union type: . While the underlying type is the same, the different names express different intents, which makes the code more readable.\n\nIn TypeScript, an interface defines a contract that an object must adhere to. Below is an example:\n\nWe can express the same contract definition using type annotations:\n\nFor the above case, we can use either or . But there are some scenarios in which using instead of makes a difference.\n\nPrimitive types are inbuilt types in TypeScripts. They include , , , , and types.\n\n We can use define a type alias for a primitive type as below:\n\nWe often combine primitive type with union type to define a type alias, to make the code more readable:\n\nBut, we can’t use an interface to alias a primitive type. The interface can only be used for an object type.\n\n Therefore, when we need to define a primitive type alias, we use .\n\nUnion types allow us to describe values that can be one of several types and create unions of various primitive, literal, or complex types:\n\nUnion type can only be defined using type. There is no equivalent to a union type in an interface. But, it is possible to create a new union type from two interfaces, like so:\n\nIn TypeScript, a function type represents a function’s type signature. Using the type alias, we need to specify the parameters and the return type to define a function type:\n\nWe can also use an interface to represent the function type:\n\nBoth type and interface similarly define function types, except for a subtle syntax difference of interface using vs. when using type. Type is preferred in this case because it’s shorter and thus easier to read.\n\nAnother reason to use type for defining a function type is its capabilities that the interface lacks. When the function becomes more complex, we can take advantage of the advanced type features such as conditional types, mapped types, etc. Here’s an example:\n\nHere, we define a type with conditional type and union type. It provides a unified function signature for and handlers in a type-safe manner. We can’t achieve the same with the interface as it doesn’t have the equivalent of conditional and union types.\n\nDeclaration merging is a feature that is exclusive to interfaces. With declaration merging, we can define an interface multiple times, and the TypeScript compiler will automatically merge these definitions into a single interface definition.\n\nIn the following example, the two interface definitions are merged into one by the TypeScript compiler, and we have two properties when using the interface:\n\nType aliases can’t be merged in the same way. If you try to define the type more than once, as in the above example, an error will be thrown:\n\nWhen used in the right places, declaration merging can be very useful. One common use case for declaration merging is to extend a third-party library’s type definition to fit the needs of a particular project.\n\nIf you need to merge declarations, interfaces are the way to go.\n\nAn interface can extend one or multiple interfaces. Using the keyword, a new interface can inherit all the properties and methods of an existing interface while also adding new properties.\n\nFor example, we can create a interface by extending the interface:\n\nTo achieve a similar result for types, we need to use an intersection operator:\n\nYou can also extend an interface from a type alias with statically known members:\n\nThe exception is union types. If you try to extend an interface from a union type, you’ll receive the following error:\n\nThis error occurs because the union type is not statically known. The interface definition needs to be statically known at compile time.\n\nType aliases can extend interfaces using the intersection, as below:\n\nIn a nutshell, both interfaces and type aliases can be extended. An interface can extend a statically known type alias, while a type alias can extend an interface using an intersection operator.\n\nAnother difference between types and interfaces is how conflicts are handled when you try to extend from one with the same property name.\n\nWhen extending interfaces, the same property key isn’t allowed, as in the example below:\n\nAn error is thrown because a conflict is detected.\n\nType aliases handle conflicts differently. In the case of a type alias extending another type with the same property key, it will automatically merge all properties instead of throwing errors.\n\nIn the following example, the intersection operator merges the method signature of the two declarations, and a operator is used to narrow down the union type parameter so that we can get the return value in a type-safe way:\n\nIt is important to note that the type intersection of two properties may produce unexpected results. In the example below, the property for the extended type becomes , since it can’t be both and at the same time:\n\nIn summary, interfaces will detect property or method name conflicts at compile time and generate an error, whereas type intersections will merge the properties or methods without throwing errors. Therefore, if we need to overload functions, type aliases should be used.\n\nOften, when using an interface, Typescript will generally do a better job displaying the shape of the interface in error messages, tooltips and IDEs. It is also much easier to read, no matter how many types you combine or extend.\n\nCompare that to the type alias that uses the intersection of two or more types like , and you then type to use that alias in another intersection like , TypeScript can struggle to display the structure of the combined type, making it harder to understand the shape of the type from the error messages.\n\nTypescript caches the results of the evaluated relationship between interfaces, like whether one interface extends another or if two interfaces are compatible. This approach improves the overall performance when the same relationship is referenced in the future.\n\nIn contrast, when working with intersections, TypeScript does not cache these relationships. Every time a type intersection is used, TypeScript has to re-evaluate the entire intersection which can lead to efficiency concerns.\n\nFor these reasons, it is advisable to use interface extends instead of relying on type intersections.\n\nIn TypeScript, we can implement a class using either an interface or a type alias:\n\nAs shown above, both interfaces and type aliases can be used to implement a class similarly; the only difference is that we can’t implement a union type.\n\nIn the above example, the TypeScript compiler throws an error because a class represents a specific data shape, but a union type can be one of several data types.\n\nIn TypeScript, the tuple type allows us to express an array with a fixed number of elements, where each element has its data type. It can be useful when you need to work with arrays of data with a fixed structure:\n\nInterfaces don’t have direct support for tuple types. Although we can create some workarounds like in the example below, it is not as concise or readable as using the tuple type:\n\nUnlike tuples, this interface extends the generic type, which enables it to have any number of elements beyond the first three. This is because arrays in TypeScript are dynamic, and you can access or assign values to indices beyond the ones explicitly defined in the interface:\n\nTypeScript provides a wide range of advanced type features that can’t be found in interfaces. Some of the unique features in TypeScript include:\n• Type inferences: Can infer the type of variables and functions based on their usage. This reduces the amount of code and improves readability\n• Conditional types: Allow us to create complex type expressions with conditional behaviors that depend on other types\n• Type guards: Used to write sophisticated control flow based on the type of a variable\n• Mapped types: Transforms an existing object type into a new type\n• Utility types: A set of out-of-the-box utilities that help to manipulate types\n\nTypeScript’s typing system constantly evolves with every new release, making it a complex and powerful toolbox. The impressive typing system is one of the main reasons many developers prefer to use TypeScript.\n\nWhen to use types vs. interfaces\n\nType aliases and interfaces are similar but have subtle differences, as shown in the previous section.\n\nWhile almost all interface features are available in types or have equivalents, one exception is declaration merging. Interfaces should generally be used when declaration merging is necessary, such as extending an existing library or authoring a new one. Additionally, if you prefer the object-oriented inheritance style, using the keyword with an interface is often more readable than using the intersection with type aliases.\n\nInterfaces with enables the compiler to be more performant, compared to type aliases with intersections.\n\nHowever, many of the features in types are difficult or impossible to achieve with interfaces. For example, TypeScript provides rich features like conditional types, generic types, type guards, advanced types, and more. You can use them to build a well-constrained type system to make your app strongly typed. The interface can’t achieve this.\n\nIn many cases, they can be used interchangeably depending on personal preference. But, we should use type aliases in the following use cases:\n• To create a new name for a primitive type\n• To define a union type, tuple type, function type, or another more complex type\n• To use mapped types, conditional types, type guards, or other advanced type features\n\nCompared with interfaces, types are more expressive. Many advanced type features are unavailable in interfaces, and those features continue to grow as TypeScript evolves.\n\n Below is an example of the advanced type feature that the interface can’t achieve.\n\nUsing mapped type, template literal types, and operator, we created a type that automatically generates getter methods for any object type.\n\nIn addition, many developers prefer to use types because they match the functional programming paradigm well. The rich type expression makes it easier to achieve functional composition, immutability, and other functional programming capabilities in a type-safe manner.\n\nIn this article, we discussed type aliases and interfaces and their differences. While there are some scenarios in which one is preferred over the other, in most cases, the choice between them boils down to personal preference.\n\n I lean towards using types simply because of the amazing type system. What are your preferences? You are welcome to share your opinions in the comments section below."
    },
    {
        "link": "https://prismic.io/blog/typescript-interfaces",
        "document": "When working with TypeScript, there are several core principles you’ll use a lot. One of those is interfaces, so it pays to have a solid understanding and grasp of them. In this post, we’re going to do a deep dive into interfaces, their benefits as well as their various use cases. If you’d like to follow along with this and experiment with using interfaces yourself, you can use the TypeScript Playground here.\n\nLet’s start by looking at what exactly interfaces are. Interfaces are a feature of TypeScript that allows us to define the structure or shape of an object and specify the properties and methods that an object has or should have. Their primary function is type checking and aiding developers in catching type-related errors during development. Here, you can see a small example of how we can define an interface and apply it to an object.\n\nAs you can see in the above code block, we access a property that is defined in the interface with no issues by running . We also can see an example of us trying to access a property that doesn’t exist in the interface by running , therefore throwing a type error.\n\nNow that we understand a bit more about interfaces, what they look like, and how to use them, let’s take a closer look at their benefits to us. The first benefit of interfaces is the most obvious one: they highlight any possible type errors and issues in our code to prevent us from accessing any properties that might not exist. This, in turn, helps us reduce runtime errors and prevent bugs from being created. Another benefit of interfaces is that they define and create clear contracts for the functions and code that consume them. They prevent us from consuming methods and properties that don’t exist and help ensure we stay within the established structure defined for the object that the interface is describing. Because interfaces define the properties and methods that exist on an object as well as their types, they act as a form of documentation that enhances the code readability and helps developers reading the code understand how it works and how the code fits together. Since interfaces can always be extended and reused in various places, they promote code reusability and help reduce duplication. By defining central, common interfaces that can be reused and extended throughout an application, you can ensure consistency in your code and logic. IDEs that integrate with TypeScript can read the interfaces you define and offer autocompletion suggestions from them, as well as help with code navigation to make you a more productive and efficient developer. Finally, interfaces help make refactoring easier because you’re able to update the implementation of a piece of code or logic, and as long as it adheres to the same interface, other code that depends on the changed logic shouldn’t be impacted.\n\nI hope, at this point, you’re convinced of the benefits of interfaces and why we should be using them. So, now, let’s look at how we can use them in our TypeScript code. In addition to defining the types of objects, we can also use interfaces to type functions, their return values, and their arguments. For example, we can do something like this.\n\nIn this example, we have an interface called and use the keyword to say the class will have all of the types defined in . Because this isn’t true and the field is missing in the class, an error is thrown. When working with objects in TypeScript, it’s quite common to have properties that might only be defined some of the time. In these instances, we can define optional properties like so.\n\nWhat this interface says is if we index an object that is typed using the interface with a , we’ll have a returned to us. You’re not limited to just types, either. It could also be another type or interface if you wish, which is great for times when you don’t know all of the properties but know their shape. Also, if you want to combine index signatures and normal interface definitions, you can do so. However, if you do this, the index signature needs to be updated to contain all of the potential return types.\n\nIt’s worth noting that while index signatures can make your life easier, where possible and feasible, you should always reach for actually typing properties on an object as that’ll give you better type safety. Sometimes, you want to extend an existing interface and add new fields to it without changing the original one. This can be achieved by using the keyword. This allows you to take an existing interface and create a copy of it while also adding new fields to it. For example, we could do something like this.\n\nIn this example, we took the original interface and extended it with the property to create a new interface called . So, at this point, we have two interfaces, and , with them being identical apart from the latter having the property added to it. If you want to, you can also combine multiple existing interfaces to create a new one without adding any new properties to it, which can be done like so.\n\nDiscriminating unions are a way we can define a new type from multiple interfaces and use a common property present on all of the interfaces (the “discriminator”) to distinguish between the types in our logic. For example, we can define two interfaces for two different shapes ( and ), and we can then use a property present on both of them ( ) to dictate which interface we are dealing with at that moment."
    },
    {
        "link": "https://typescriptlang.org/docs/handbook/dom-manipulation.html",
        "document": ""
    },
    {
        "link": "https://github.com/microsoft/TypeScript-Website/blob/v2/packages/documentation/copy/en/tutorials/DOM%20Manipulation.md",
        "document": "In the 20+ years since its standardization, JavaScript has come a very long way. While in 2020, JavaScript can be used on servers, in data science, and even on IoT devices, it is important to remember its most popular use case: web browsers.\n\nWebsites are made up of HTML and/or XML documents. These documents are static, they do not change. The Document Object Model (DOM) is a programming interface implemented by browsers to make static websites functional. The DOM API can be used to change the document structure, style, and content. The API is so powerful that countless frontend frameworks (jQuery, React, Angular, etc.) have been developed around it to make dynamic websites even easier to develop.\n\nTypeScript is a typed superset of JavaScript, and it ships type definitions for the DOM API. These definitions are readily available in any default TypeScript project. Of the 20,000+ lines of definitions in lib.dom.d.ts, one stands out among the rest: . This type is the backbone for DOM manipulation with TypeScript.\n\nLet's explore a TypeScript script that adds a element to the element.\n\nAfter compiling and running the index.html page, the resulting HTML will be:\n\nThe first line of the TypeScript code uses a global variable . Inspecting the variable shows it is defined by the interface from the lib.dom.d.ts file. The code snippet contains calls to two methods, and .\n\nThe definition for this method is as follows:\n\nPass it an element id string and it will return either or . This method introduces one of the most important types, . It serves as the base interface for every other element interface. For example, the variable in the code example is of type . Also, take note that this method can return . This is because the method can't be certain pre-runtime if it will be able to actually find the specified element or not. In the last line of the code snippet, the new optional chaining operator is used to call .\n\nThe definition for this method is (I have omitted the deprecated definition):\n\nThis is an overloaded function definition. The second overload is simplest and works a lot like the method does. Pass it any and it will return a standard HTMLElement. This definition is what enables developers to create unique HTML element tags.\n\nFor example returns a element, clearly not an element that is specified by the HTML specification.\n\nFor the first definition of , it is using some advanced generic patterns. It is best understood broken down into chunks, starting with the generic expression: . This expression defines a generic parameter that is constrained to the keys of the interface . The map interface contains every specified HTML tag name and its corresponding type interface. For example here are the first 5 mapped values:\n\nSome elements do not exhibit unique properties and so they just return , but other types do have unique properties and methods so they return their specific interface (which will extend from or implement ).\n\nNow, for the remainder of the definition: . The first argument is defined as the generic parameter . The TypeScript interpreter is smart enough to infer the generic parameter from this argument. This means that the developer does not have to specify the generic parameter when using the method; whatever value is passed to the argument will be inferred as and thus can be used throughout the remainder of the definition. This is exactly what happens; the return value takes the argument and uses it to return the corresponding type. This definition is how the variable from the code snippet gets a type of . And if the code was , then it would be an element of type .\n\nThe function returns an . interface extends the interface which extends the interface. This prototypal extension allows for all to utilize a subset of standard methods. In the code snippet, we use a property defined on the interface to append the new element to the website.\n\nThe last line of the code snippet is . The previous, , section detailed that the optional chaining operator is used here because can potentially be null at runtime. The method is defined by:\n\nThis method works similarly to the method as the generic parameter is inferred from the argument. is constrained to another base interface .\n\nPreviously, this document details the interface extends from which extends from . In the DOM API there is a concept of children elements. For example in the following HTML, the tags are children of the element\n\nAfter capturing the element, the prop will return an list containing the . The property will return a similar list of nodes. Each tag will still be of type , but the can contain additional HTML nodes that the list cannot.\n\nModify the HTML by removing one of the tags, but keep the text.\n\nSee how both lists change. now only contains the element, and the contains a node rather than two nodes. The part of the is the literal containing the text . The list does not contain this because it is not considered an .\n\nBoth of these methods are great tools for getting lists of dom elements that fit a more unique set of constraints. They are defined in lib.dom.d.ts as:\n\nThe definition is similar to , except it returns a new type: . This return type is essentially a custom implementation of the standard JavaScript list element. Arguably, replacing with would result in a very similar user experience. only implements the following properties and methods: , , , and numeric indexing. Additionally, this method returns a list of elements, not nodes, which is what was returning from the method. While this may appear as a discrepancy, take note that interface extends from .\n\nTo see these methods in action modify the existing code to:\n\nThe best part about the lib.dom.d.ts type definitions is that they are reflective of the types annotated in the Mozilla Developer Network (MDN) documentation site. For example, the interface is documented by this HTMLElement page on MDN. These pages list all available properties, methods, and sometimes even examples. Another great aspect of the pages is that they provide links to the corresponding standard documents. Here is the link to the W3C Recommendation for HTMLElement."
    },
    {
        "link": "https://svijaykoushik.github.io/blog/2019/09/27/typescript-dom-manipulation",
        "document": "Every TypeScript example and tutorial I have found thus far is about language features, Static typing, Visual Studio, etc. I cannot find anything to tell me how I should be using it with reference to JavaScript and the DOM. My understanding it you can use TypeScript for the DOM. But, I never see anyone using it for that.\n\nSaid johnny in a question on stackoverflow.com. A while back I had the same question. Can We Use Typescript to manipulate the DOM?\n\nHello world! I’ve been learning Typescript for a week now. I got into typescript when I wanted to learn the new Angular. Since it is based on Typescript, I decided to learn Typescript. During learning, I found it odd that none of the learning aids I used included examples of using the language with HTML. Every example I saw in those learning aids and some other tutorials I then looked up involved only node.js. More googling landed me on StackOverflow where johnny, as I mentioned before, had the same question. using this as an opportunity to make a post after almost a year, I’ve made this post, the missing piece of the puzzle, in hopes that it would land first instead of johnny’s question on StackOverflow.\n\nUsing the DOM or Dom manipulation in typescript is simple. All I needed to do was to use the types defined specifically for DOM access that is available in Typescript. The rest was the same as in JavaScript. But… these “DOM types” are not available out of the box with Typescript. I needed to explicitly configure the typescript compiler to include the “dom” library in the section in the configuration file[2] to access the DOM types in my project. “Why didn’t they include by default?. Maybe the creators didn’t intend to use it primarily for front end development” I thought to myself.\n\nSome other configuration changes I made were: I enabled mode for strict type checking and I changed the from “common JS” to “es5”, so the compiler can output JS for browsers and not for node.js. I also added the “es2015” library so that I could use functionalities like arrays and Math functions for my example.\n\nIn this article, I’m going to write a hello world program to demonstrate the use of DOM in typescript. Because it’s my first post on typescript. I’ll be covering the basics of using the DOM types and a problem a beginner like me would face while doing this the first time. I’m not covering DOM events here. I’ll be covering them in another article coming soon.\n\nI’ll begin with the basics where I change the inner text value of an existing element. I started by creating an HTML file with a simple html5 boilerplate with a element with id greeter saying “hello” inside the body.\n\nThen, I opened a new typescript file and added the following code\n\nIn the code, I created a variable greeter and I assigned the type to it. The type which is defined in the “dom” library we added to the configuration, tells the compiler that the greeter variable expects an Html heading element and nothing else. And, I assigned the greeter to the value returned by the function which returns the element with the ID provided. Then I assigned the string “hello world” to the property of the greeter element.\n\nWhen I compiled the code with the command\n\nIt threw the following error\n\nBummer! My first attempt failed. On the bright side, Typescript is doing its job and the configurations I set up works. The error means that, I tried to assign greeter which is of type with an object of type that the method returned. in the error message means that the method’s return value can be either of type or . The special operator is called the union operator. I won’t be explaining “union types” in this article. You can learn about them here.\n\ntype is just a common interface for all the html elements[1] but the compiler expects a . I thought of changing the greeter variable’s type to but I didn’t. Because, it’s not right. If I had changed it to , it means greeter could accept any HTML element from the DOM. I wanted it to accept only a heading element. So, I used type assertion feature of typescript (Learn about type assertion here) to tell the compiler that the element returned from the getElementById is indeed a heading element and it doesn’t have to worry about it. Here’s the fixed code:\n\nNow, the compilation was a success. I included the script.js file generated by the compiler in the Html document and opened it on a browser. It looked like this:\n\nNow that I’ve made sure that everything works as intended, It was time to decorate the page. I wanted a font style that is not formal looking. After browsing through google fonts, I chose Rock Salt. I imported it in my stylesheet along with Dancing Script as a secondary font using CSS imports. I then proceeded by adding a few more elements to the Html document. I centered all the text using CSS flexbox, added a nice background from UI gradients, and adjusted positions of some elements to arrange them properly. The page now looked beautiful.\n\nNext, to place the cherry on top, I wanted to add a pretty background animation of orbs rising to the top like bubbles to the page. To make the orbs I decided to use elements. Since I wanted several of these orbs with different sizes, I split the task into two so the work could be simplified. One, I created a common style for all the orbs and created a custom animation for the orbs in CSS. And two, I created the orbs dynamically with the help of typescript by creating a set number of elements, assigning them the style created beforehand and randomizing their sizes, positions, and animation-delay to make them look more natural.\n\nFinally, I added the orbs to the dom like this and thereby kickstarting the animation\n\nAnd the link to the repo containing the complete code\n\nDuring writing this article and the example, I realized the involvement of advanced concepts like type assertion and union types. I now understand why the authors of those tutorials didn’t include them. If included, it would have confused beginners outright. I think it’s best to learn typescript well before starting to use DOM in your projects.\n\nIn my example, I skipped the null checking when I fixed the type mismatch error as it seemed unnecessary for the example but you should check for nulls when necessary to avoid breaking your app at runtime. I also skipped the part where I added animations using the animate.css plugin for the text as it felt trivial explaining it.\n\nFinally, I need to thank Ivan Petrov for suggesting me to read a book when learning a new tech in a comment on my previous post on https://dev.to. Thanks, Ivan 👍🏽. The exercises in the book helped me.\n\nThanks for your time. :)\n• Stop tracking and start ignoring: A tip to delete files from a repository and stop tracking them while keeping them locally - https://svijaykoushik.github.io/blog/2019/02/17/start-ignoring/"
    },
    {
        "link": "https://stackoverflow.com/questions/66718083/how-to-manipulate-dom-elements-in-typescript",
        "document": "Whenever you use or you are not guaranteed to find a matching element. That's why the Typescript return type is .\n\nWhen you use the type assertion you are insisting that you will always have an and not . You aren't checking if you have an element, you are asserting that you do.\n\nIt turns out that your assertion was incorrect. You actually had and not an . So you get a runtime error when trying to set on .\n\nAs for why you can't find a matching element when one seems to exist in your app -- that I cannot answer from just what you've posted here.\n\nBut I can help with properly handling the possibility of in your Typescript code."
    },
    {
        "link": "https://stackoverflow.com/questions/35801420/angular2typescript-how-to-manipulate-dom-element",
        "document": "Update in 2017: ViewChild will be the best way to access Dom element.\n\nI have tried the following two methods, only method 2 works. But I don't want the repeated code: document.getElementById() in each method. I prefer method 1, but why method 1 doesn't work?\n\nAre there any better ways to manipulate DOM in Angular2?"
    }
]