[
    {
        "link": "https://freecodecamp.org/news/dom-manipulation-in-javascript",
        "document": "JavaScript, the language of the web, empowers developers to create dynamic and interactive web pages. One of the key features that enables this interactivity is Document Object Model (DOM) manipulation.\n\nDOM manipulation allows developers to interact with and modify the structure, style, and content of web pages. In this article, we'll explore the fundamentals of DOM manipulation in JavaScript, breaking down complex concepts into easy-to-understand snippets.\n\nWhat is the DOM?\n\nThe Document Object Model (DOM) is a programming interface for web documents. It represents the structure of a document as a tree of objects, where each object corresponds to a part of the document, such as elements, attributes, and text. JavaScript can manipulate this tree structure, allowing developers to dynamically alter the content and appearance of a webpage.\n\nTo manipulate the DOM, we need to access its elements. This is commonly done using the object, which represents the entire HTML document. Let's look at a simple example:\n\nIn the code snippet above, we use , , and to retrieve specific elements. The returned values can then be stored in variables for further manipulation.\n\nOnce we have access to an element, we can modify its content using the property:\n\nIn the example above, we changed the content of the to . This is a simple yet powerful way to update the text within an element.\n\nEvents are actions or occurrences that happen in the browser, such as a user clicking a button or resizing the window. JavaScript allows us to handle these events and execute code in response. Event handling is a crucial aspect of creating interactive web pages.\n\nTo respond to events, we can use event listeners. These are functions that \"listen\" for a specific event on a particular element. Let's consider a button click event as an example:\n\nIn this example, when the button with the ID is clicked, an alert saying will pop up. Event listeners provide a way to execute custom code based on user interactions.\n\nDOM manipulation also extends to modifying the styles of elements, allowing us to create visually appealing and dynamic web pages.\n\nWe can use the property of an element to change its appearance. Let's take an example of changing the color of a paragraph when a button is clicked:\n\nIn this example, when the button with the ID is clicked, the text color of the paragraph with the ID is changed to blue.\n\nHow to Create and Modify Elements\n\nIn addition to modifying existing elements, JavaScript allows us to create new elements and add them to the DOM.\n\nHow to create new elements\n\nThe method is used to create a new HTML element. Let's create a new paragraph element and append (add) it to the body of the document:\n\nIn this example, we create a new (paragraph) element, set its text content, and then append it to the body of the document.\n\nWe can also modify the attributes of existing elements. Let's consider changing the source of an image dynamically:\n\nHere, we access an image element with the ID and change its attribute to , dynamically updating the displayed image.\n\nLet's consider a scenario where you want to update the value of a text input based on user interaction:\n\nIn this example, as the user types in the text input with the ID , a paragraph with the ID is dynamically updated to reflect the input value.\n\nYou can toggle the visibility of an element by using the style property. Let's create a button that toggles the visibility of a paragraph:\n\nHere, the paragraph with the ID is initially visible. Clicking the button with the ID toggles its visibility.\n\nWhile DOM manipulation is a powerful tool for creating dynamic web pages, beginners often encounter common pitfalls that can lead to unexpected behavior or errors. Let's explore some of these pitfalls and provide tips on how to avoid them.\n\nManipulating the DOM before it's ready\n\nWe may sometimes attempt to manipulate the DOM before it has fully loaded. This can lead to JavaScript trying to access elements that haven't been rendered yet. To avoid this, it's crucial to wait for the DOM to be fully loaded before executing any JavaScript code:\n\nBy wrapping your DOM manipulation code inside the event listener, you ensure that it runs only when the DOM is ready.\n\nNot checking if an element exists\n\nWhen attempting to access an element using methods like , we might assume the element exists and proceed with manipulation. However, if the element is not present on the page, it can lead to errors.\n\nAlways check if an element exists before manipulating it:\n\nThis simple check prevents errors when working with elements that may or may not be present.\n\nWhen handling events, forgetting to prevent the default action can result in unexpected page behavior. For instance, if a form is submitted without preventing the default action, the page might reload, causing loss of data:\n\nBy calling , you stop the default behavior associated with the event, giving you full control over how the event is handled.\n\nPerforming inefficient DOM queries, especially within loops, can degrade performance. Each query involves traversing the DOM, and unnecessary queries can slow down your webpage.\n\nInstead of repeatedly querying the DOM, cache references to elements:\n\nBy querying the DOM once and reusing the reference, you optimize your code.\n\nDifferent browsers may interpret JavaScript and DOM manipulation slightly differently. Failing to account for cross-browser compatibility can lead to inconsistent behavior.\n\nUse feature detection and consider using libraries like jQuery or modern frameworks to handle cross-browser inconsistencies:\n\nBy checking for features before using them, you ensure your code works across various browsers.\n\nHow to Use Frameworks for DOM Manipulation\n\nWhile JavaScript allows for direct DOM manipulation, modern web development often involves using frameworks like React or Vue.js. These frameworks provide a more structured way to build and manage user interfaces.\n\nIn this React example, a component is created to handle a button click event, demonstrating a more declarative approach to UI development.\n\nHere, a Vue.js instance is created to manage data and methods, showcasing the reactivity and component-based structure of Vue.js.\n\nIn this comprehensive guide, we've delved into the world of DOM manipulation in JavaScript. From accessing elements to handling events, and from modifying styles to creating new elements, we've covered the essential concepts in a straightforward manner.\n\nRemember, DOM manipulation is at the core of creating dynamic and interactive web pages. By mastering these fundamental techniques, you'll be well-equipped to build engaging and user-friendly web applications. As you continue your journey with JavaScript, practice and experimentation will deepen your understanding of these concepts, paving the way for your success as a web developer."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Scripting/DOM_scripting",
        "document": "When writing web pages and apps, one of the most common things you'll want to do is change the document structure in some way. This is usually done by manipulating the Document Object Model (DOM) via a set of built-in browser APIs for controlling HTML and styling information. In this article we'll introduce you to DOM scripting. An understanding of HTML and the fundamentals of CSS, familiarity with JavaScript basics as covered in previous lessons.\n• What the DOM is — the browser's internal representation of the document's HTML structure as a hierarchy of objects.\n• The important parts of a web browser as represented in JavaScript — , , and .\n• How DOM nodes exist relative to each other in the DOM tree — root, parent, child, sibling, and descendant.\n• Getting references to DOM nodes, creating new nodes, adding and removing nodes and attributes.\n\nWeb browsers are very complicated pieces of software with a lot of moving parts, many of which can't be controlled or manipulated by a web developer using JavaScript. You might think that such limitations are a bad thing, but browsers are locked down for good reasons, mostly centering around security. Imagine if a website could get access to your stored passwords or other sensitive information, and log into websites as if it were you? Despite the limitations, Web APIs still give us access to a lot of functionality that enable us to do a great many things with web pages. There are a few really obvious bits you'll reference regularly in your code — consider the following diagram, which represents the main parts of a browser directly involved in viewing web pages:\n• The window is the browser tab that a web page is loaded into; this is represented in JavaScript by the object. Using methods available on this object you can do things like return the window's size (see and ), manipulate the document loaded into that window, store data specific to that document on the client-side (for example using a local database or other storage mechanism), attach an event handler to the current window, and more.\n• The navigator represents the state and identity of the browser (i.e. the user-agent) as it exists on the web. In JavaScript, this is represented by the object. You can use this object to retrieve things like the user's preferred language, a media stream from the user's webcam, etc.\n• The document (represented by the DOM in browsers) is the actual page loaded into the window, and is represented in JavaScript by the object. You can use this object to return and manipulate information on the HTML and CSS that comprises the document, for example get a reference to an element in the DOM, change its text content, apply new styles to it, create new elements and add them to the current element as children, or even delete it altogether. In this article we'll focus mostly on manipulating the document, but we'll show a few other useful bits besides.\n\nLet's provide a brief recap on the Document Object Model (DOM), which we also looked at earlier in the course. The document currently loaded in each one of your browser tabs is represented by a DOM. This is a \"tree structure\" representation created by the browser that enables the HTML structure to be easily accessed by programming languages — for example the browser itself uses it to apply styling and other information to the correct elements as it renders a page, and developers like you can manipulate the DOM with JavaScript after the page has been rendered. We have created an example page at dom-example.html (see it live also). Try opening this up in your browser — it is a very simple page containing a element inside which you can find an image, and a paragraph with a link inside. The HTML source code looks like this: <!doctype html> <html lang=\"en-US\"> <head> <meta charset=\"utf-8\" /> <title>Simple DOM example</title> </head> <body> <section> <img src=\"dinosaur.png\" alt=\"A red Tyrannosaurus Rex: A two legged dinosaur standing upright like a human, with small arms, and a large head with lots of sharp teeth.\" /> <p> Here we will add a link to the <a href=\"https://www.mozilla.org/\">Mozilla homepage</a> </p> </section> </body> </html> The DOM on the other hand looks like this: Note: This DOM tree diagram was created using Ian Hickson's Live DOM viewer. Each entry in the tree is called a node. You can see in the diagram above that some nodes represent elements (identified as , , and so on) and others represent text (identified as ). There are other types of nodes as well, but these are the main ones you'll encounter. Nodes are also referred to by their position in the tree relative to other nodes:\n• Root node: The top node in the tree, which in the case of HTML is always the node (other markup vocabularies like SVG and custom XML will have different root elements).\n• Child node: A node directly inside another node. For example, is a child of in the above example.\n• Descendant node: A node anywhere inside another node. For example, is a child of in the above example, and it is also a descendant. is not a child of , as it is two levels below it in the tree, but it is a descendant of .\n• Parent node: A node which has another node inside it. For example, is the parent node of in the above example.\n• Sibling nodes: Nodes that sit on the same level under the same parent node in the DOM tree. For example, and are siblings in the above example. It is useful to familiarize yourself with this terminology before working with the DOM, as a number of the code terms you'll come across make use of them. You'll also come across them in CSS (e.g. descendant selector, child selector).\n\nTo start learning about DOM manipulation, let's begin with a practical example.\n• Take a local copy of the dom-example.html page and the image that goes along with it.\n• Add a element just above the closing tag.\n• To manipulate an element inside the DOM, you first need to select it and store a reference to it inside a variable. Inside your script element, add the following line:\n• Now we have the element reference stored in a variable, we can start to manipulate it using properties and methods available to it (these are defined on interfaces like in the case of element, its more general parent interface , and — which represents all nodes in a DOM). First of all, let's change the text inside the link by updating the value of the property. Add the following line below the previous one:\n• We should also change the URL the link is pointing to, so that it doesn't go to the wrong place when it is clicked on. Add the following line, again at the bottom: Note that, as with many things in JavaScript, there are many ways to select an element and store a reference to it in a variable. is the recommended modern approach. It is convenient because it allows you to select elements using CSS selectors. The above call will match the first element that appears in the document. If you wanted to match and do things to multiple elements, you could use , which matches every element in the document that matches the selector, and stores references to them in an array-like object called a . There are older methods available for grabbing element references, such as:\n• , which selects an element with a given attribute value, e.g. . The ID is passed to the function as a parameter, i.e. .\n• , which returns an array-like object containing all the elements on the page of a given type, for example s, s, etc. The element type is passed to the function as a parameter, i.e. . These two work better in older browsers than the modern methods like , but are not as convenient. Have a look and see what others you can find!\n\nThe above has given you a little taste of what you can do, but let's go further and look at how we can create new elements.\n• Going back to the current example, let's start by grabbing a reference to our element — add the following code at the bottom of your existing script (do the same with the other lines too):\n• Now let's create a new paragraph using and give it some text content in the same way as before: const para = document.createElement(\"p\"); para.textContent = \"We hope you enjoyed the ride.\";\n• You can now append the new paragraph at the end of the section using :\n• Finally for this part, let's add a text node to the paragraph the link sits inside, to round off the sentence nicely. First we will create the text node using :\n• Now we'll grab a reference to the paragraph the link is inside, and append the text node to it: That's most of what you need for adding nodes to the DOM — you'll make a lot of use of these methods when building dynamic interfaces (we'll look at some examples later).\n\nThere may be times when you want to move nodes, or delete them from the DOM altogether. This is perfectly possible. If we wanted to move the paragraph with the link inside it to the bottom of the section, we could do this: This moves the paragraph down to the bottom of the section. You might have thought it would make a second copy of it, but this is not the case — is a reference to the one and only copy of that paragraph. If you wanted to make a copy and add that as well, you'd need to use instead. Removing a node is pretty simple as well, at least when you have a reference to the node to be removed and its parent. In our current case, we just use , like this: When you want to remove a node based only on a reference to itself, which is fairly common, you can use : This method is not supported in older browsers. They have no method to tell a node to remove itself, so you'd have to do the following: Have a go at adding the above lines to your code.\n\nIt is possible to manipulate CSS styles via JavaScript in a variety of ways. To start with, you can get a list of all the stylesheets attached to a document using , which returns an array-like object with objects. You can then add/remove styles as wished. However, we're not going to expand on those features because they are a somewhat archaic and difficult way to manipulate style. There are much easier ways. The first way is to add inline styles directly onto elements you want to dynamically style. This is done with the property, which contains inline styling information for each element in the document. You can set properties of this object to directly update element styles.\n• As an example, try adding these lines to our ongoing example:\n• Reload the page and you'll see that the styles have been applied to the paragraph. If you look at that paragraph in your browser's Page Inspector/DOM inspector, you'll see that these lines are indeed adding inline styles to the document: <p style=\"color: white; background-color: black; padding: 10px; width: 250px; text-align: center;\"> We hope you enjoyed the ride. </p> Note: Notice how the JavaScript property versions of the CSS styles are written in lower camel case whereas the CSS versions are hyphenated (kebab-case) (e.g. versus ). Make sure you don't get these mixed up, otherwise it won't work. There is another common way to dynamically manipulate styles on your document, which we'll look at now.\n• Delete the previous five lines you added to the JavaScript.\n• Add the following inside your HTML :\n• Now we'll turn to a very useful method for general HTML manipulation — — this takes two arguments, the attribute you want to set on the element, and the value you want to set it to. In this case we will set a class name of highlight on our paragraph:\n• Refresh your page, and you'll see no change — the CSS is still applied to the paragraph, but this time by giving it a class that is selected by our CSS rule, not as inline CSS styles. Which method you choose is up to you; both have their advantages and disadvantages. The first method takes less setup and is good for simple uses, whereas the second method is more purist (no mixing CSS and JavaScript, no inline styles, which are seen as a bad practice). As you start building larger and more involved apps, you will probably start using the second method more, but it is really up to you. At this point, we haven't really done anything useful! There is no point using JavaScript to create static content — you might as well just write it into your HTML and not use JavaScript. It is more complex than HTML, and creating your content with JavaScript also has other issues attached to it (such as not being readable by search engines). In the next section we will look at a more practical use of DOM APIs. Note: You can find our finished version of the dom-example.html demo on GitHub (see it live also)."
    },
    {
        "link": "https://stackoverflow.com/questions/66257947/dom-javascript-form-elements-accessing",
        "document": "I have started javascript DOM manipulation, I come across an error maybe. Whenever I input in name field like jaykumar and press click me button .In demo, jaykumar comes and with in few microseconds go."
    },
    {
        "link": "https://medium.com/hackernoon/javascript-dom-and-how-to-navigate-it-with-a-form-example-part-2-collecting-form-values-7d881120bc5e",
        "document": "In Part 1, I did a quick review of the DOM and some CSS selectors that are helpful with collecting values from an HTML form.\n\nIn this portion, I’m looking at different ways to capture those values when you don’t have an index.html that is particularly straightforward to work with, such as when you can’t just use getElementByID(). This will include things to think about like scope, event listeners, more on CSS selectors, and some tricks I use to check my code as I’m writing.\n\nScope in JavaScript determines the accessibility of different variables that have been assigned. Variables can have either a local or global scope. Global variables are accessible anywhere throughout your filed, whereas local variables are accessible only within a function.\n\nYou can see this tested out in the console in Chrome Dev Tools, which is a great place to try out some JavaScript you’re writing.\n\nRelatedly, pay attention to when you are calling values\n\nLet’s say I have an HTML form with a name field, the code looking something like this\n\nAnd I’m writing a bit of JavaScript to capture the value of that input field. Here are some things I know going in.\n• I can’t use getElementByID(). Some sort of query selector is probably the best option\n• I want the value of the field to be updated based on some certain event\n• I want to make sure I don’t get back an undefined value or error\n• Before I did anything, I console logged “I’m connected”, and checked this to make sure that my JavaScript file and my index.html are communicating. I console log every step of the way because there is nothing like assuming that since something is simple everything is working smoothly, and then 2 hours later you have a dumb bug you can’t track down and it’s really just because a variable you declared 200 lines of code ago was not defined how you expected\n• I used an on change for the input value. There are other event listeners that could work here, maybe something tied to a form submit, but I find this one simple to test in the console. It updates the value as the user is typing. I also like to have each of my functions manage a minimal amount of processes. Rather that having one giant function that gathers values for every form field and then submits, I’d rather break things down into one function for each field, with a suitable event listener and CSS selectors, and then have one function for managing submission.\n• I declared the form variable outside of the event listener, so that I can use it throughout my file. However, I define the variable within the event listener, meaning it only becomes defined once there is a value in the input field.\n\nMake sure you’re using the right event listener\n\nThis may seem obvious, but double check the event listener you’re using. If you write with additional JavaScript frameworks or libraries that have different conventions or ways to call an event listener, just take a minute to look it up.\n\nIf you’re using .onchange, you want to write\n\nAn example in action\n\nMake sure you’re getting a value that’s helpful\n\nIf you have a form field that is a checkbox or a radio button, using .value is probably not your best option. With a checkbox, if you use .value with an on change event, the return value is “on” whether the checkbox is selected or deselected. A boolean value would be much more useful, and using .checked returns a boolean.\n\nOnce you have form data, there are two possible steps, either rendering it to the page as a preview or submitting it to the backend.\n\nWhy use an object\n\nAdding data from a form and rendering it to the page before the user decides to submit is a great way to preview information. Essentially, all you need to do is write a function that gathers the information from the form and creates new elements and renders the text to the page on an “add” event (probably a button onclick). Using an object also makes things simpler for sending information to a database. You can create the object once and use it for multiple purposes.\n\nHere is an example of a very straightforward object creation, and rendering a string of that object’s data to the document body.\n\nHere, I’ve done a few things. I’ve selected the add button on my form and added an event listener to it — remembering to use the right syntax — , grabbed the information from my form, created a new object with it, and then rendered the information to the DOM using .appendChild().\n\nIn Part 3, I’ll write about full CRUD functionality for data on the page, rendering information strategically (rather than just document.body, which tacks it onto the end) and preparing JSON to be sent to the backend."
    },
    {
        "link": "https://stackoverflow.com/questions/22837446/javascript-changing-dom-elements-based-on-form-values",
        "document": "I'm still pretty new to JavaScript programming and I'm having an issue.\n\nWhat I'm trying to do is, have a combobox list of items with a button. When you click the button, I need to change parts of the HTML to values that I've set in variables at the start.\n\nThe code, as it stands, works in JSFiddle. But, as soon as I un-comment the variable declaration, 'stats', it messes up, which really confuses me. Also, please excuse all the undisciplined stuff, like inline styles :) This was just for debugging test.\n\nOne more thing while I'm here- is there a way to shorthand the first line in the changeSelection() function? I've seen many examples, but they are all different."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/how-to-use-the-javascript-fetch-api-to-get-data",
        "document": "There was a time when was used to make API requests. It didn’t include Promises, and it didn’t make for clean JavaScript code. Using jQuery, you could use the cleaner syntax of .\n\nNow, JavaScript has its own built-in way to make API requests. This is the Fetch API, a new standard to make server requests with Promises, but which also includes additional features.\n\nIn this tutorial, you will create both GET and POST requests using the Fetch API.\n\nTo complete this tutorial, you will need the following:\n• A local development environment for Node.js. Follow How to Install Node.js and Create a Local Development Environment.\n• A basic understanding of coding in JavaScript, which you can learn more about from the How to Code in JavaScript series.\n• An understanding of Promises in JavaScript. Read the Promises section of this article on the event loop, callbacks, Promises, and async/await in JavaScript.\n\nOne approach to using the Fetch API is by passing the URL of the API as a parameter:\n\nThe method returns a Promise. After the method, include the Promise method :\n\nIf the Promise returned is , the function within the method is executed. That function contains the code for handling the data received from the API.\n\nAfter the method, include the method:\n\nThe API you call using may be down or other errors may occur. If this happens, the promise will be returned. The method is used to handle . The code within will be executed if an error occurs when calling the API of your choice.\n\nWith an understanding of the syntax for using the Fetch API, you can now move on to using on a real API.\n\nStep 2 — Using Fetch to get Data from an API\n\nThe following code samples will be based on the JSONPlaceholder API. Using the API, you will get ten users and display them on the page using JavaScript. This tutorial will retrieve data from the JSONPlaceholder API and display it in list items inside the author’s list.\n\nBegin by creating an HTML file and adding a heading and unordered list with the of :\n\nNow add tags to the bottom of your HTML file and use a DOM selector to grab the . Use with as the argument:\n\nRemember, is the for the previously created .\n\nNext, create a that is a :\n\nAll the appended list items will be added to . A is not part of the active document tree structure. This has the benefit of not causing performance-affecting redraws when the Document Object Model is changed.\n\nCreate a constant variable called which will hold the API URL that will return ten random users:\n\nNow using the Fetch API, call the JSONPlaceholder API using with as the argument:\n\nYou are calling the Fetch API and passing in the URL to the JSONPlaceholder API. Then a response is received. However, the response you get is not JSON, but an object with a series of methods that can be used depending on what you want to do with the information. To convert the object returned into JSON, use the method.\n\nAdd the method which will contain a function with a parameter called :\n\nThe parameter takes the value of the object returned from . Use the method to convert into JSON data:\n\nThe JSON data still needs to be processed. Add another statement with a function that has an argument called :\n\nWithin this function, create a variable called that is set equal to :\n\nFor each author in , you will want to create a list item that displays their name. The method is suited for this pattern:\n\nWithin your function, create a variable called that will be set equal to with (the HTML element) as the argument. Also, create an for and a for :\n\nThe element will contain the of the . The element will contain the email of the . The property and string interpolation will allow you to do this:\n\nNext, connect these DOM elements with :\n\nNote that each list item is being appended to the . Once the is complete, the is appended to the unordered list element.\n\nWith both functions completed, you can now add the function. This function will log the potential error to the console:\n\nThis is the full code of the request you created:\n\nYou just successfully performed a GET request using the JSONPlaceholder API and the Fetch API. In the next step, you will perform POST requests.\n\nFetch defaults to GET requests, but you can use all other types of requests, change the headers, and send data. Let’s create a POST request.\n\nFirst, include a constant variable that holds the link to the JSONPlaceholder API:\n\nNext, you need to set your object and pass it as the second argument of the fetch function. This will be an object called with the key and value (or your name):\n\nSince this is a POST request, you will need to state that explicitly. Create an object called :\n\nThis object needs to include three keys: , , and :\n\nThe key will have the value . will be set equal to the format of the object that was just created. will have the value of .\n\nThe interface is a property of the Fetch API, which allows you to perform actions on HTTP request and response headers. This article called How To Define Routes and HTTP Request Methods in Express can provide you with more information.\n\nWith this code in place, the POST request can be made using the Fetch API. You will include and as arguments for your POST request:\n\nThe function will include code that handles the response received from the JSONPlaceholder API:\n\nThis is the full code of the request you created:\n\nWith this approach, can be used as the sole argument for , replacing and .\n\nNow you know two methods for creating and executing POST requests with the Fetch API.\n\nThe Fetch API is a modern and flexible interface for making network requests in JavaScript. It is promise-based, making it easier to handle asynchronous operations efficiently. However, it is not the only option for making network requests in JavaScript.\n\nAxios is a popular library for making HTTP requests in JavaScript. It is promise-based and has a simple and clean API. It also provides the ability to intercept requests and responses, transform data, and cancel requests.\n\nMany JavaScript frameworks, such as React, Vue.js, and Angular, have their own built-in methods for making network requests. These methods are often based on the Fetch API or Axios, but they may have additional features or be more tightly integrated with the framework’s ecosystem.\n\nIf you’re working on a simple project and prefer a lightweight, native solution, use Fetch API. However, for projects requiring automatic JSON parsing, interceptors, and better error handling, Axios is the better choice.\n\nYou can check out How to Use Vue.js and Axios to Display Data from an API for an Axios-based approach.\n\nReact applications often use Fetch API inside useEffect() to fetch data when a component mounts:\n\nFor better performance in React, consider using JavaScript Performance API.\n\nIn Vue.js, Fetch API is commonly used inside the lifecycle hook:\n\nAlternatively, many Vue.js projects prefer using Axios for its simplicity, as shown in How to Use Vue.js and Axios to Display Data from an API.\n\nIn Angular, Fetch API can be used within services using , but if using native Fetch API, you can implement it inside a component:\n\nFor large applications, Angular’s built-in is recommended for better scalability.\n\n1. What does Fetch API do in JavaScript?\n\nThe Fetch API provides a modern and flexible interface for making network requests in JavaScript. It allows you to fetch resources like JSON data, HTML, images, and more from a server. Unlike older methods like XMLHttpRequest, Fetch API is promise-based, making it easier to handle asynchronous operations efficiently.\n\n2. What is an example of Fetch API?\n\nA simple example of using Fetch API to request JSON data from an API:\n\nThis fetches a sample post from a placeholder API and logs it to the console. You can also check out How to Use Vue.js and Axios to Display Data from an API for another way to retrieve and display API data.\n\n3. How to fetch JSON data from an API in JavaScript?\n\nThis converts the response to JSON using and then processes the data. If you’re working with performance optimizations, you may also find JavaScript Performance API useful.\n\n4. How to fetch data from an API with JavaScript?\n\no fetch data asynchronously, use inside an function with :\n\nThis ensures cleaner code and better error handling. For advanced API integrations, consider learning about GraphQL API as an alternative to REST APIs.\n\n5. What is the difference between REST API and Fetch API?\n\nIn simpler terms, Fetch API is a tool used to interact with a REST API or any other data source available over the web.\n\nWhile the Fetch API is not yet supported by all the browsers, it is a great alternative to .\n\nThis tutorial provides a step-by-step guide on using Fetch API in JavaScript. However, if you’re working on a larger project, you may want to explore Axios for better error handling or GraphQL for more efficient data fetching.\n• Learn how to optimize API performance with JavaScript Performance API.\n• Explore GraphQL for an alternative to REST APIs.\n• Read How to Use Vue.js and Axios to Display Data from an API for a comparison with Axios.\n\nBy integrating these concepts, you can efficiently fetch and manage data in any JavaScript project.\n\nIf you would like to learn how to call Web APIs using React, check out this article on this very topic."
    },
    {
        "link": "https://stackoverflow.com/questions/35549547/fetch-api-vs-xmlhttprequest",
        "document": "fetch, according to the specs, will throw a TypeError if the URL to be fetched contains credentials (\"Request cannot be constructed from a URL that includes credentials\").\n\nThis may sound reasonable (for security) and neglectable, because an additional \"Authorization\" header could be used if needed.\n\nHowever, there's a problem if fetch inside a page shall load data relative to the base url of the page and if that page's URL has credentials itself. The browser will construct an URL for that contains credentials taken from the page and throw an error.\n\nTo me this appears like a browser bug - it's building the URL and could simply leave out credentials (what it does every other time anyway replacing it magically by \"Authorisation\" header). However, as it happens on both Chrome and Firefox, this may be intentional (although, IMO, the specs may leave room for another interpretation as well).\n\nXMLHttpRequest, on the other hand, would load the requested resource happily even with credentials (see network tab in developer tools).\n\nHence, under certain circumstances, the behaviour of the page will change or even lead to an error - which we had to learn the hard way. We ended up building an absolute URL by using data."
    },
    {
        "link": "https://stackoverflow.com/questions/73961096/send-data-from-frontend-to-backend-with-fetch-and-post",
        "document": "I want to send data from a select to a PHP using fetch. Then I will use this data in a SQL statement. I'm trying with this code (note: the option of the select are created dynamically with another script):\n\non the console I got this: Response {type: 'basic', url: 'http://localhost/progetti/test/php/batteries_search.php', redirected: false, status: 200, ok: true, …}\n\nNow, printing the data I have a correct value, for example: {ID: '7'} .\n\nOn the backend I'm trying to receive the data with\n\nbut it says Warning: Undefined array key \"data\".\n\nWhere is the mistake? Thanks for your help"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch",
        "document": "The Fetch API provides a JavaScript interface for making HTTP requests and processing the responses. Fetch is the modern replacement for : unlike , which uses callbacks, Fetch is promise-based and is integrated with features of the modern web such as service workers and Cross-Origin Resource Sharing (CORS). With the Fetch API, you make a request by calling , which is available as a global function in both and contexts. You pass it a object or a string containing the URL to fetch, along with an optional argument to configure the request. The function returns a which is fulfilled with a object representing the server's response. You can then check the request status and extract the body of the response in various formats, including text and JSON, by calling the appropriate method on the response. Here's a minimal function that uses to retrieve some JSON data from a server: async function getData() { const url = \"https://example.org/products.json\"; try { const response = await fetch(url); if (!response.ok) { throw new Error(`Response status: ${response.status}`); } const json = await response.json(); console.log(json); } catch (error) { console.error(error.message); } } We declare a string containing the URL and then call , passing the URL with no extra options. The function will reject the promise on some errors, but not if the server responds with an error status like : so we also check the response status and throw if it is not OK. Otherwise, we fetch the response body content as JSON by calling the method of , and log one of its values. Note that like itself, is asynchronous, as are all the other methods to access the response body content. In the rest of this page we'll look in more detail at the different stages of this process.\n\nThe request body is the payload of the request: it's the thing the client is sending to the server. You cannot include a body with requests, but it's useful for requests that send content to the server, such as or requests. For example, if you want to upload a file to the server, you might make a request and include the file as the request body. To set a request body, pass it as the option: You can supply the body as an instance of any of the following types: Other objects are converted to strings using their method. For example, you can use a object to encode form data (see setting headers for more information): const response = await fetch(\"https://example.org/post\", { method: \"POST\", headers: { \"Content-Type\": \"application/x-www-form-urlencoded\", }, // Automatically converted to \"username=example&password=password\" body: new URLSearchParams({ username: \"example\", password: \"password\" }), // ... }); Note that just like response bodies, request bodies are streams, and making the request reads the stream, so if a request contains a body, you can't make it twice: const request = new Request(\"https://example.org/post\", { method: \"POST\", body: JSON.stringify({ username: \"example\" }), }); const response1 = await fetch(request); console.log(response1.status); // Will throw: \"Body has already been consumed.\" const response2 = await fetch(request); console.log(response2.status); Instead, you would need to create a clone of the request before sending it: See Locked and disturbed streams for more information.\n\nCredentials are cookies, TLS client certificates, or authentication headers containing a username and password. To control whether or not the browser sends credentials, as well as whether the browser respects any response headers, set the option, which can take one of the following three values:\n• : never send credentials in the request or include credentials in the response.\n• (the default): only send and include credentials for same-origin requests. Note that if a cookie's attribute is set to or , then the cookie will not be sent cross-site, even if is set to . Including credentials in cross-origin requests can make a site vulnerable to CSRF attacks, so even if is set to , the server must also agree to their inclusion by including the header in its response. Additionally, in this situation the server must explicitly specify the client's origin in the response header (that is, is not allowed). This means that if is set to and the request is cross-origin, then:\n• If the request is a simple request, then the request will be sent with credentials, but the server must set the and response headers, or the browser will return a network error to the caller. If the server does set the correct headers, then the response, including credentials, will be delivered to the caller.\n• If the request is not a simple request, then the browser will send a preflighted request without credentials, and the server must set the and response headers, or the browser will return a network error to the caller. If the server does set the correct headers, then the browser will follow up with the real request, including credentials, and will deliver the real response, including credentials, to the caller.\n\nRequest and response bodies are actually objects, and whenever you read them, you're streaming the content. This is good for memory efficiency, because the browser doesn't have to buffer the entire response in memory before the caller retrieves it using a method like . This also means that the caller can process the content incrementally as it is received. For example, consider a request that fetches a large text file and processes it in some way, or displays it to the user: const url = \"https://www.example.org/a-large-file.txt\"; async function fetchText(url) { try { const response = await fetch(url); if (!response.ok) { throw new Error(`Response status: ${response.status}`); } const text = await response.text(); console.log(text); } catch (e) { console.error(e); } } If we use , as above, we must wait until the whole file has been received before we can process any of it. If we stream the response instead, we can process chunks of the body as they are received from the network: const url = \"https://www.example.org/a-large-file.txt\"; async function fetchTextAsStream(url) { try { const response = await fetch(url); if (!response.ok) { throw new Error(`Response status: ${response.status}`); } const stream = response.body.pipeThrough(new TextDecoderStream()); for await (const value of stream) { console.log(value); } } catch (e) { console.error(e); } } In this example, we iterate asynchronously over the stream, processing each chunk as it arrives. Note that when you access the body directly like this, you get the raw bytes of the response and must transform it yourself. In this case we call to pipe the response through a , which decodes the UTF-8-encoded body data as text."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Scripting/Network_requests",
        "document": "Another very common task in modern websites and applications is making network requests to retrieve individual data items from the server to update sections of a webpage without having to load an entire new page. This seemingly small detail has had a huge impact on the performance and behavior of sites, so in this article, we'll explain the concept and look at technologies that make it possible: in particular, the Fetch API. An understanding of HTML and the fundamentals of CSS, familiarity with JavaScript basics as covered in previous lessons.\n• Asynchronous network requests, which is by far the most common asynchronous JavaScript use case on the web.\n• Common types of resources that are fetched from the network: JSON, media assets, data from RESTful APIs.\n• How to use to implement asynchronous network requests.\n\nWhat is the problem here? A web page consists of an HTML page and (usually) various other files, such as stylesheets, scripts, and images. The basic model of page loading on the Web is that your browser makes one or more HTTP requests to the server for the files needed to display the page, and the server responds with the requested files. If you visit another page, the browser requests the new files, and the server responds with them. This model works perfectly well for many sites. But consider a website that's very data-driven. For example, a library website like the Vancouver Public Library. Among other things you could think of a site like this as a user interface to a database. It might let you search for a particular genre of book, or might show you recommendations for books you might like, based on books you've previously borrowed. When you do this, it needs to update the page with the new set of books to display. But note that most of the page content — including items like the page header, sidebar, and footer — stays the same. The trouble with the traditional model here is that we'd have to fetch and load the entire page, even when we only need to update one part of it. This is inefficient and can result in a poor user experience. So instead of the traditional model, many websites use JavaScript APIs to request data from the server and update the page content without a page load. So when the user searches for a new product, the browser only requests the data which is needed to update the page — the set of new books to display, for instance. The main API here is the Fetch API. This enables JavaScript running in a page to make an HTTP request to a server to retrieve specific resources. When the server provides them, the JavaScript can use the data to update the page, typically by using DOM manipulation APIs. The data requested is often JSON, which is a good format for transferring structured data, but can also be HTML or just text. This is a common pattern for data-driven sites such as Amazon, YouTube, eBay, and so on. With this model:\n• Page updates are a lot quicker and you don't have to wait for the page to refresh, meaning that the site feels faster and more responsive.\n• Less data is downloaded on each update, meaning less wasted bandwidth. This may not be such a big issue on a desktop on a broadband connection, but it's a major issue on mobile devices and in countries that don't have ubiquitous fast internet service. Note: In the early days, this general technique was known as Asynchronous JavaScript and XML (AJAX), because it tended to request XML data. This is normally not the case these days (you'd be more likely to request JSON), but the result is still the same, and the term \"AJAX\" is still often used to describe the technique. To speed things up even further, some sites also store assets and data on the user's computer when they are first requested, meaning that on subsequent visits they use the local versions instead of downloading fresh copies every time the page is first loaded. The content is only reloaded from the server when it has been updated.\n\nFor this example, we'll request data out of a few different text files and use them to populate a content area. This series of files will act as our fake database; in a real application, we'd be more likely to use a server-side language like PHP, Python, or Node to request our data from a database. Here, however, we want to keep it simple and concentrate on the client-side part of this. To begin this example, make a local copy of fetch-start.html and the four text files — verse1.txt, verse2.txt, verse3.txt, and verse4.txt — in a new directory on your computer. In this example, we will fetch a different verse of the poem (which you may well recognize) when it's selected in the drop-down menu. Just inside the element, add the following code. This stores references to the and elements and adds a listener to the element, so that when the user selects a new value, the new value is passed to the function named as a parameter. Let's define our function. First of all, put the following beneath your previous code block — this is the empty shell of the function. We'll start our function by constructing a relative URL pointing to the text file we want to load, as we'll need it later. The value of the element at any time is the same as the text inside the selected (unless you specify a different value in a value attribute) — so for example \"Verse 1\". The corresponding verse text file is \"verse1.txt\", and is in the same directory as the HTML file, therefore just the file name will do. However, web servers tend to be case-sensitive, and the file name doesn't have a space in it. To convert \"Verse 1\" to \"verse1.txt\" we need to convert the 'V' to lower case, remove the space, and add \".txt\" on the end. This can be done with , , and template literal. Add the following lines inside your function: Finally we're ready to use the Fetch API: // Call `fetch()`, passing in the URL. fetch(url) // fetch() returns a promise. When we have received a response from the server, // the promise's `then()` handler is called with the response. .then((response) => { // Our handler throws an error if the request did not succeed. if (!response.ok) { throw new Error(`HTTP error: ${response.status}`); } // Otherwise (if the response succeeded), our handler fetches the response // as text by calling response.text(), and immediately returns the promise // returned by `response.text()`. return response.text(); }) // When response.text() has succeeded, the `then()` handler is called with // the text, and we copy it into the `poemDisplay` box. .then((text) => { poemDisplay.textContent = text; }) // Catch any errors that might happen, and display a message // in the `poemDisplay` box. .catch((error) => { poemDisplay.textContent = `Could not fetch verse: ${error}`; }); There's quite a lot to unpack in here. First, the entry point to the Fetch API is a global function called , that takes the URL as a parameter (it takes another optional parameter for custom settings, but we're not using that here). Next, is an asynchronous API which returns a . If you don't know what that is, read the module on asynchronous JavaScript, and in particular the lesson on promises, then come back here. You'll find that article also talks about the API! So because returns a promise, we pass a function into the method of the returned promise. This method will be called when the HTTP request has received a response from the server. In the handler, we check that the request succeeded, and throw an error if it didn't. Otherwise, we call , to get the response body as text. It turns out that is also asynchronous, so we return the promise it returns, and pass a function into the method of this new promise. This function will be called when the response text is ready, and inside it we will update our block with the text. Finally, we chain a handler at the end, to catch any errors thrown in either of the asynchronous functions we called or their handlers. One problem with the example as it stands is that it won't show any of the poem when it first loads. To fix this, add the following two lines at the bottom of your code (just above the closing tag) to load verse 1 by default, and make sure the element always shows the correct value: Serving your example from a server Modern browsers will not run HTTP requests if you just run the example from a local file. This is because of security restrictions (for more on web security, read Website security). To get around this, we need to test the example by running it through a local web server. To find out how to do this, see How do you set up a local testing server?.\n\nIn this example we have created a sample site called The Can Store — it's a fictional supermarket that only sells canned goods. You can find this example live on GitHub, and see the source code. By default, the site displays all the products, but you can use the form controls in the left-hand column to filter them by category, or search term, or both. There is quite a lot of complex code that deals with filtering the products by category and search terms, manipulating strings so the data displays correctly in the UI, etc. We won't discuss all of it in the article, but you can find extensive comments in the code (see can-script.js). We will, however, explain the Fetch code. The first block that uses Fetch can be found at the start of the JavaScript: The function returns a promise. If this completes successfully, the function inside the first block contains the returned from the network.\n• check that the server didn't return an error (such as ). If it did, we throw the error.\n• call on the response. This will retrieve the data as a JSON object. We return the promise returned by . Next we pass a function into the method of that returned promise. This function will be passed an object containing the response data as JSON, which we pass into the function. It is which starts the process of displaying all the products in the user interface. To handle errors, we chain a block onto the end of the chain. This runs if the promise fails for some reason. Inside it, we include a function that is passed as a parameter, an object. This object can be used to report the nature of the error that has occurred, in this case we do it with a simple . However, a complete website would handle this error more gracefully by displaying a message on the user's screen and perhaps offering options to remedy the situation, but we don't need anything more than a simple . You can test the failure case yourself:\n• Make a local copy of the example files.\n• Run the code through a web server (as described above, in Serving your example from a server).\n• Modify the path to the file being fetched, to something like 'produc.json' (make sure it is misspelled).\n• Now load the index file in your browser (via ) and look in your browser developer console. You'll see a message similar to \"Fetch problem: HTTP error: 404\". The second Fetch block can be found inside the function: This works in much the same way as the previous one, except that instead of using , we use . In this case we want to return our response as an image file, and the data format we use for that is Blob (the term is an abbreviation of \"Binary Large Object\" and can basically be used to represent large file-like objects, such as images or video files). Once we've successfully received our blob, we pass it into our function, which displays it."
    }
]