[
    {
        "link": "https://react.dev/reference/react/useEffect",
        "document": "In this example, a cleanup function is not needed because the class manages only the DOM node that was passed to it. After the React component is removed from the tree, both the DOM node and the class instance will be automatically garbage-collected by the browser JavaScript engine. You can use an Effect to fetch data for your component. Note that if you use a framework, using your framework’s data fetching mechanism will be a lot more efficient than writing Effects manually. If you want to fetch data from an Effect manually, your code might look like this: Note the variable which is initialized to , and is set to during cleanup. This ensures your code doesn’t suffer from “race conditions”: network responses may arrive in a different order than you sent them.\n\nWriting data fetching directly in Effects gets repetitive and makes it difficult to add optimizations like caching and server rendering later. It’s easier to use a custom Hook—either your own or maintained by the community. What are good alternatives to data fetching in Effects? Writing calls inside Effects is a popular way to fetch data, especially in fully client-side apps. This is, however, a very manual approach and it has significant downsides:\n• Effects don’t run on the server. This means that the initial server-rendered HTML will only include a loading state with no data. The client computer will have to download all JavaScript and render your app only to discover that now it needs to load the data. This is not very efficient.\n• Fetching directly in Effects makes it easy to create “network waterfalls”. You render the parent component, it fetches some data, renders the child components, and then they start fetching their data. If the network is not very fast, this is significantly slower than fetching all data in parallel.\n• Fetching directly in Effects usually means you don’t preload or cache data. For example, if the component unmounts and then mounts again, it would have to fetch the data again.\n• It’s not very ergonomic. There’s quite a bit of boilerplate code involved when writing calls in a way that doesn’t suffer from bugs like race conditions. This list of downsides is not specific to React. It applies to fetching data on mount with any library. Like with routing, data fetching is not trivial to do well, so we recommend the following approaches:\n• If you use a framework, use its built-in data fetching mechanism. Modern React frameworks have integrated data fetching mechanisms that are efficient and don’t suffer from the above pitfalls.\n• Otherwise, consider using or building a client-side cache. Popular open source solutions include React Query, useSWR, and React Router 6.4+. You can build your own solution too, in which case you would use Effects under the hood but also add logic for deduplicating requests, caching responses, and avoiding network waterfalls (by preloading data or hoisting data requirements to routes). You can continue fetching data directly in Effects if neither of these approaches suit you. Notice that you can’t “choose” the dependencies of your Effect. Every reactive value used by your Effect’s code must be declared as a dependency. Your Effect’s dependency list is determined by the surrounding code: If either or change, your Effect will reconnect to the chat using the new values. Reactive values include props and all variables and functions declared directly inside of your component. Since and are reactive values, you can’t remove them from the dependencies. If you try to omit them and your linter is correctly configured for React, the linter will flag this as a mistake you need to fix: To remove a dependency, you need to “prove” to the linter that it doesn’t need to be a dependency. For example, you can move out of your component to prove that it’s not reactive and won’t change on re-renders: Now that is not a reactive value (and can’t change on a re-render), it doesn’t need to be a dependency. If your Effect’s code doesn’t use any reactive values, its dependency list should be empty ( ): An Effect with empty dependencies doesn’t re-run when any of your component’s props or state change. If you have an existing codebase, you might have some Effects that suppress the linter like this: When dependencies don’t match the code, there is a high risk of introducing bugs. By suppressing the linter, you “lie” to React about the values your Effect depends on. Instead, prove they’re unnecessary.\n\nNow that you create the object inside the Effect, the Effect itself only depends on the string. With this fix, typing into the input doesn’t reconnect the chat. Unlike an object which gets re-created, a string like doesn’t change unless you set it to another value. Read more about removing dependencies. If your Effect depends on an object or a function created during rendering, it might run too often. For example, this Effect re-connects after every render because the function is different for every render: By itself, creating a function from scratch on every re-render is not a problem. You don’t need to optimize that. However, if you use it as a dependency of your Effect, it will cause your Effect to re-run after every re-render. Avoid using a function created during rendering as a dependency. Instead, declare it inside the Effect:"
    },
    {
        "link": "https://legacy.reactjs.org/docs/hooks-reference.html",
        "document": "Hooks are a new addition in React 16.8. They let you use state and other React features without writing a class.\n\nThis page describes the APIs for the built-in Hooks in React.\n\nIf you’re new to Hooks, you might want to check out the overview first. You may also find useful information in the frequently asked questions section.\n\nReturns a stateful value, and a function to update it.\n\nDuring the initial render, the returned state ( ) is the same as the value passed as the first argument ( ).\n\nThe function is used to update the state. It accepts a new state value and enqueues a re-render of the component.\n\nDuring subsequent re-renders, the first value returned by will always be the most recent state after applying updates.\n\nIf the new state is computed using the previous state, you can pass a function to . The function will receive the previous value, and return an updated value. Here’s an example of a counter component that uses both forms of :\n\nThe ”+” and ”-” buttons use the functional form, because the updated value is based on the previous value. But the “Reset” button uses the normal form, because it always sets the count back to the initial value.\n\nIf your update function returns the exact same value as the current state, the subsequent rerender will be skipped completely.\n\nThe argument is the state used during the initial render. In subsequent renders, it is disregarded. If the initial state is the result of an expensive computation, you may provide a function instead, which will be executed only on the initial render:\n\nIf you update a State Hook to the same value as the current state, React will bail out without rendering the children or firing effects. (React uses the comparison algorithm.)\n\nNote that React may still need to render that specific component again before bailing out. That shouldn’t be a concern because React won’t unnecessarily go “deeper” into the tree. If you’re doing expensive calculations while rendering, you can optimize them with .\n\nReact may group several state updates into a single re-render to improve performance. Normally, this improves performance and shouldn’t affect your application’s behavior.\n\nBefore React 18, only updates inside React event handlers were batched. Starting with React 18, batching is enabled for all updates by default. Note that React makes sure that updates from several different user-initiated events — for example, clicking a button twice — are always processed separately and do not get batched. This prevents logical mistakes.\n\nIn the rare case that you need to force the DOM update to be applied synchronously, you may wrap it in . However, this can hurt performance so do this only where needed.\n\nMutations, subscriptions, timers, logging, and other side effects are not allowed inside the main body of a function component (referred to as React’s render phase). Doing so will lead to confusing bugs and inconsistencies in the UI.\n\nInstead, use . The function passed to will run after the render is committed to the screen. Think of effects as an escape hatch from React’s purely functional world into the imperative world.\n\nBy default, effects run after every completed render, but you can choose to fire them only when certain values have changed.\n\nOften, effects create resources that need to be cleaned up before the component leaves the screen, such as a subscription or timer ID. To do this, the function passed to may return a clean-up function. For example, to create a subscription:\n\nThe clean-up function runs before the component is removed from the UI to prevent memory leaks. Additionally, if a component renders multiple times (as they typically do), the previous effect is cleaned up before executing the next effect. In our example, this means a new subscription is created on every update. To avoid firing an effect on every update, refer to the next section.\n\nUnlike and , the function passed to fires after layout and paint, during a deferred event. This makes it suitable for the many common side effects, like setting up subscriptions and event handlers, because most types of work shouldn’t block the browser from updating the screen.\n\nHowever, not all effects can be deferred. For example, a DOM mutation that is visible to the user must fire synchronously before the next paint so that the user does not perceive a visual inconsistency. (The distinction is conceptually similar to passive versus active event listeners.) For these types of effects, React provides one additional Hook called . It has the same signature as , and only differs in when it is fired.\n\nAdditionally, starting in React 18, the function passed to will fire synchronously before layout and paint when it’s the result of a discrete user input such as a click, or when it’s the result of an update wrapped in . This behavior allows the result of the effect to be observed by the event system, or by the caller of .\n\nEven in cases where is deferred until after the browser has painted, it’s guaranteed to fire before any new renders. React will always flush a previous render’s effects before starting a new update.\n\nThe default behavior for effects is to fire the effect after every completed render. That way an effect is always recreated if one of its dependencies changes.\n\nHowever, this may be overkill in some cases, like the subscription example from the previous section. We don’t need to create a new subscription on every update, only if the prop has changed.\n\nTo implement this, pass a second argument to that is the array of values that the effect depends on. Our updated example now looks like this:\n\nNow the subscription will only be recreated when changes.\n\nThe array of dependencies is not passed as arguments to the effect function. Conceptually, though, that’s what they represent: every value referenced inside the effect function should also appear in the dependencies array. In the future, a sufficiently advanced compiler could create this array automatically.\n\nAccepts a context object (the value returned from ) and returns the current context value for that context. The current context value is determined by the prop of the nearest above the calling component in the tree.\n\nWhen the nearest above the component updates, this Hook will trigger a rerender with the latest context passed to that provider. Even if an ancestor uses or , a rerender will still happen starting at the component itself using .\n\nDon’t forget that the argument to must be the context object itself:\n\nA component calling will always re-render when the context value changes. If re-rendering the component is expensive, you can optimize it by using memoization.\n\nPutting it together with Context.Provider\n\nThis example is modified for hooks from a previous example in the Context Advanced Guide, where you can find more information about when and how to use Context.\n\nThe following Hooks are either variants of the basic ones from the previous section, or only needed for specific edge cases. Don’t stress about learning them up front.\n\nAn alternative to . Accepts a reducer of type , and returns the current state paired with a method. (If you’re familiar with Redux, you already know how this works.)\n\nis usually preferable to when you have complex state logic that involves multiple sub-values or when the next state depends on the previous one. also lets you optimize performance for components that trigger deep updates because you can pass down instead of callbacks.\n\nHere’s the counter example from the section, rewritten to use a reducer:\n\nThere are two different ways to initialize state. You may choose either one depending on the use case. The simplest way is to pass the initial state as a second argument:\n\nYou can also create the initial state lazily. To do this, you can pass an function as the third argument. The initial state will be set to .\n\nIt lets you extract the logic for calculating the initial state outside the reducer. This is also handy for resetting the state later in response to an action:\n\nIf you return the same value from a Reducer Hook as the current state, React will bail out without rendering the children or firing effects. (React uses the comparison algorithm.)\n\nNote that React may still need to render that specific component again before bailing out. That shouldn’t be a concern because React won’t unnecessarily go “deeper” into the tree. If you’re doing expensive calculations while rendering, you can optimize them with .\n\nPass an inline callback and an array of dependencies. will return a memoized version of the callback that only changes if one of the dependencies has changed. This is useful when passing callbacks to optimized child components that rely on reference equality to prevent unnecessary renders (e.g. ).\n\nPass a “create” function and an array of dependencies. will only recompute the memoized value when one of the dependencies has changed. This optimization helps to avoid expensive calculations on every render.\n\nRemember that the function passed to runs during rendering. Don’t do anything there that you wouldn’t normally do while rendering. For example, side effects belong in , not .\n\nIf no array is provided, a new value will be computed on every render.\n\nYou may rely on as a performance optimization, not as a semantic guarantee. In the future, React may choose to “forget” some previously memoized values and recalculate them on next render, e.g. to free memory for offscreen components. Write your code so that it still works without — and then add it to optimize performance.\n\nreturns a mutable ref object whose property is initialized to the passed argument ( ). The returned object will persist for the full lifetime of the component.\n\nA common use case is to access a child imperatively:\n\nEssentially, is like a “box” that can hold a mutable value in its property.\n\nYou might be familiar with refs primarily as a way to access the DOM. If you pass a ref object to React with , React will set its property to the corresponding DOM node whenever that node changes.\n\nHowever, is useful for more than the attribute. It’s handy for keeping any mutable value around similar to how you’d use instance fields in classes.\n\nThis works because creates a plain JavaScript object. The only difference between and creating a object yourself is that will give you the same ref object on every render.\n\nKeep in mind that doesn’t notify you when its content changes. Mutating the property doesn’t cause a re-render. If you want to run some code when React attaches or detaches a ref to a DOM node, you may want to use a callback ref instead.\n\ncustomizes the instance value that is exposed to parent components when using . As always, imperative code using refs should be avoided in most cases. should be used with :\n\nIn this example, a parent component that renders would be able to call .\n\nThe signature is identical to , but it fires synchronously after all DOM mutations. Use this to read layout from the DOM and synchronously re-render. Updates scheduled inside will be flushed synchronously, before the browser has a chance to paint.\n\nPrefer the standard when possible to avoid blocking visual updates.\n\ncan be used to display a label for custom hooks in React DevTools.\n\nFor example, consider the custom Hook described in “Building Your Own Hooks”:\n\nIn some cases formatting a value for display might be an expensive operation. It’s also unnecessary unless a Hook is actually inspected.\n\nFor this reason accepts a formatting function as an optional second parameter. This function is only called if the Hooks are inspected. It receives the debug value as a parameter and should return a formatted display value.\n\nFor example a custom Hook that returned a value could avoid calling the function unnecessarily by passing the following formatter:\n\naccepts a value and returns a new copy of the value that will defer to more urgent updates. If the current render is the result of an urgent update, like user input, React will return the previous value and then render the new value after the urgent render has completed.\n\nThis hook is similar to user-space hooks which use debouncing or throttling to defer updates. The benefits to using is that React will work on the update as soon as other work finishes (instead of waiting for an arbitrary amount of time), and like , deferred values can suspend without triggering an unexpected fallback for existing content.\n\nonly defers the value that you pass to it. If you want to prevent a child component from re-rendering during an urgent update, you must also memoize that component with or :\n\nMemoizing the children tells React that it only needs to re-render them when changes and not when changes. This caveat is not unique to , and it’s the same pattern you would use with similar hooks that use debouncing or throttling.\n\nReturns a stateful value for the pending state of the transition, and a function to start it.\n\nlets you mark updates in the provided callback as transitions:\n\nindicates when a transition is active to show a pending state:\n\nis a hook for generating unique IDs that are stable across the server and client, while avoiding hydration mismatches.\n\nFor a basic example, pass the directly to the elements that need it:\n\nFor multiple IDs in the same component, append a suffix using the same :\n\nThe following Hooks are provided for library authors to integrate libraries deeply into the React model, and are not typically used in application code.\n\nis a hook recommended for reading and subscribing from external data sources in a way that’s compatible with concurrent rendering features like selective hydration and time slicing.\n\nThis method returns the value of the store and accepts three arguments:\n• : function to register a callback that is called whenever the store changes.\n• : function that returns the current value of the store.\n• : function that returns the snapshot used during server rendering.\n\nThe most basic example simply subscribes to the entire store:\n\nHowever, you can also subscribe to a specific field:\n\nWhen server rendering, you must serialize the store value used on the server, and provide it to . React will use this snapshot during hydration to prevent server mismatches:\n\nThe signature is identical to , but it fires synchronously before all DOM mutations. Use this to inject styles into the DOM before reading layout in . Since this hook is limited in scope, this hook does not have access to refs and cannot schedule updates."
    },
    {
        "link": "https://legacy.reactjs.org/docs/hooks-effect.html",
        "document": "Hooks are a new addition in React 16.8. They let you use state and other React features without writing a class.\n\nThe Effect Hook lets you perform side effects in function components:\n\nThis snippet is based on the counter example from the previous page, but we added a new feature to it: we set the document title to a custom message including the number of clicks.\n\nData fetching, setting up a subscription, and manually changing the DOM in React components are all examples of side effects. Whether or not you’re used to calling these operations “side effects” (or just “effects”), you’ve likely performed them in your components before.\n\nThere are two common kinds of side effects in React components: those that don’t require cleanup, and those that do. Let’s look at this distinction in more detail.\n\nSometimes, we want to run some additional code after React has updated the DOM. Network requests, manual DOM mutations, and logging are common examples of effects that don’t require a cleanup. We say that because we can run them and immediately forget about them. Let’s compare how classes and Hooks let us express such side effects.\n\nIn React class components, the method itself shouldn’t cause side effects. It would be too early — we typically want to perform our effects after React has updated the DOM.\n\nThis is why in React classes, we put side effects into and . Coming back to our example, here is a React counter class component that updates the document title right after React makes changes to the DOM:\n\nNote how we have to duplicate the code between these two lifecycle methods in class.\n\nThis is because in many cases we want to perform the same side effect regardless of whether the component just mounted, or if it has been updated. Conceptually, we want it to happen after every render — but React class components don’t have a method like this. We could extract a separate method but we would still have to call it in two places.\n\nNow let’s see how we can do the same with the Hook.\n\nWe’ve already seen this example at the top of this page, but let’s take a closer look at it:\n\nWhat does do? By using this Hook, you tell React that your component needs to do something after render. React will remember the function you passed (we’ll refer to it as our “effect”), and call it later after performing the DOM updates. In this effect, we set the document title, but we could also perform data fetching or call some other imperative API.\n\nWhy is called inside a component? Placing inside the component lets us access the state variable (or any props) right from the effect. We don’t need a special API to read it — it’s already in the function scope. Hooks embrace JavaScript closures and avoid introducing React-specific APIs where JavaScript already provides a solution.\n\nDoes run after every render? Yes! By default, it runs both after the first render and after every update. (We will later talk about how to customize this.) Instead of thinking in terms of “mounting” and “updating”, you might find it easier to think that effects happen “after render”. React guarantees the DOM has been updated by the time it runs the effects.\n\nNow that we know more about effects, these lines should make sense:\n\nWe declare the state variable, and then we tell React we need to use an effect. We pass a function to the Hook. This function we pass is our effect. Inside our effect, we set the document title using the browser API. We can read the latest inside the effect because it’s in the scope of our function. When React renders our component, it will remember the effect we used, and then run our effect after updating the DOM. This happens for every render, including the first one.\n\nExperienced JavaScript developers might notice that the function passed to is going to be different on every render. This is intentional. In fact, this is what lets us read the value from inside the effect without worrying about it getting stale. Every time we re-render, we schedule a different effect, replacing the previous one. In a way, this makes the effects behave more like a part of the render result — each effect “belongs” to a particular render. We will see more clearly why this is useful later on this page.\n\nEarlier, we looked at how to express side effects that don’t require any cleanup. However, some effects do. For example, we might want to set up a subscription to some external data source. In that case, it is important to clean up so that we don’t introduce a memory leak! Let’s compare how we can do it with classes and with Hooks.\n\nIn a React class, you would typically set up a subscription in , and clean it up in . For example, let’s say we have a module that lets us subscribe to a friend’s online status. Here’s how we might subscribe and display that status using a class:\n\nNotice how and need to mirror each other. Lifecycle methods force us to split this logic even though conceptually code in both of them is related to the same effect.\n\nLet’s see how we could write this component with Hooks.\n\nYou might be thinking that we’d need a separate effect to perform the cleanup. But code for adding and removing a subscription is so tightly related that is designed to keep it together. If your effect returns a function, React will run it when it is time to clean up:\n\nWhy did we return a function from our effect? This is the optional cleanup mechanism for effects. Every effect may return a function that cleans up after it. This lets us keep the logic for adding and removing subscriptions close to each other. They’re part of the same effect!\n\nWhen exactly does React clean up an effect? React performs the cleanup when the component unmounts. However, as we learned earlier, effects run for every render and not just once. This is why React also cleans up effects from the previous render before running the effects next time. We’ll discuss why this helps avoid bugs and how to opt out of this behavior in case it creates performance issues later below.\n\nWe’ve learned that lets us express different kinds of side effects after a component renders. Some effects might require cleanup so they return a function:\n\nOther effects might not have a cleanup phase, and don’t return anything.\n\nThe Effect Hook unifies both use cases with a single API.\n\nIf you feel like you have a decent grasp on how the Effect Hook works, or if you feel overwhelmed, you can jump to the next page about Rules of Hooks now.\n\nWe’ll continue this page with an in-depth look at some aspects of that experienced React users will likely be curious about. Don’t feel obligated to dig into them now. You can always come back to this page to learn more details about the Effect Hook.\n\nOne of the problems we outlined in the Motivation for Hooks is that class lifecycle methods often contain unrelated logic, but related logic gets broken up into several methods. Here is a component that combines the counter and the friend status indicator logic from the previous examples:\n\nNote how the logic that sets is split between and . The subscription logic is also spread between and . And contains code for both tasks.\n\nSo, how can Hooks solve this problem? Just like you can use the State Hook more than once, you can also use several effects. This lets us separate unrelated logic into different effects:\n\nHooks let us split the code based on what it is doing rather than a lifecycle method name. React will apply every effect used by the component, in the order they were specified.\n\nIf you’re used to classes, you might be wondering why the effect cleanup phase happens after every re-render, and not just once during unmounting. Let’s look at a practical example to see why this design helps us create components with fewer bugs.\n\nEarlier on this page, we introduced an example component that displays whether a friend is online or not. Our class reads from , subscribes to the friend status after the component mounts, and unsubscribes during unmounting:\n\nBut what happens if the prop changes while the component is on the screen? Our component would continue displaying the online status of a different friend. This is a bug. We would also cause a memory leak or crash when unmounting since the unsubscribe call would use the wrong friend ID.\n\nIn a class component, we would need to add to handle this case:\n\nForgetting to handle properly is a common source of bugs in React applications.\n\nNow consider the version of this component that uses Hooks:\n\nIt doesn’t suffer from this bug. (But we also didn’t make any changes to it.)\n\nThere is no special code for handling updates because handles them by default. It cleans up the previous effects before applying the next effects. To illustrate this, here is a sequence of subscribe and unsubscribe calls that this component could produce over time:\n\nThis behavior ensures consistency by default and prevents bugs that are common in class components due to missing update logic.\n\nIn some cases, cleaning up or applying the effect after every render might create a performance problem. In class components, we can solve this by writing an extra comparison with or inside :\n\nThis requirement is common enough that it is built into the Hook API. You can tell React to skip applying an effect if certain values haven’t changed between re-renders. To do so, pass an array as an optional second argument to :\n\nIn the example above, we pass as the second argument. What does this mean? If the is , and then our component re-renders with still equal to , React will compare from the previous render and from the next render. Because all items in the array are the same ( ), React would skip the effect. That’s our optimization.\n\nWhen we render with updated to , React will compare the items in the array from the previous render to items in the array from the next render. This time, React will re-apply the effect because . If there are multiple items in the array, React will re-run the effect even if just one of them is different.\n\nThis also works for effects that have a cleanup phase:\n\nIn the future, the second argument might get added automatically by a build-time transformation.\n\nCongratulations! This was a long page, but hopefully by the end most of your questions about effects were answered. You’ve learned both the State Hook and the Effect Hook, and there is a lot you can do with both of them combined. They cover most of the use cases for classes — and where they don’t, you might find the additional Hooks helpful.\n\nWe’re also starting to see how Hooks solve problems outlined in Motivation. We’ve seen how effect cleanup avoids duplication in and , brings related code closer together, and helps us avoid bugs. We’ve also seen how we can separate effects by their purpose, which is something we couldn’t do in classes at all.\n\nAt this point you might be questioning how Hooks work. How can React know which call corresponds to which state variable between re-renders? How does React “match up” previous and next effects on every update? On the next page we will learn about the Rules of Hooks — they’re essential to making Hooks work."
    },
    {
        "link": "https://react.dev/learn/lifecycle-of-reactive-effects",
        "document": "Effects have a different lifecycle from components. Components may mount, update, or unmount. An Effect can only do two things: to start synchronizing something, and later to stop synchronizing it. This cycle can happen multiple times if your Effect depends on props and state that change over time. React provides a linter rule to check that you’ve specified your Effect’s dependencies correctly. This keeps your Effect synchronized to the latest props and state.\n• How an Effect’s lifecycle is different from a component’s lifecycle\n• How to think about each individual Effect in isolation\n• When your Effect needs to re-synchronize, and why\n• How your Effect’s dependencies are determined\n• What it means for a value to be reactive\n• How React verifies your dependencies are correct with a linter\n• What to do when you disagree with the linter The lifecycle of an Effect Every React component goes through the same lifecycle:\n• A component mounts when it’s added to the screen.\n• A component updates when it receives new props or state, usually in response to an interaction.\n• A component unmounts when it’s removed from the screen. It’s a good way to think about components, but not about Effects. Instead, try to think about each Effect independently from your component’s lifecycle. An Effect describes how to synchronize an external system to the current props and state. As your code changes, synchronization will need to happen more or less often. To illustrate this point, consider this Effect connecting your component to a chat server: Your Effect’s body specifies how to start synchronizing: The cleanup function returned by your Effect specifies how to stop synchronizing: Intuitively, you might think that React would start synchronizing when your component mounts and stop synchronizing when your component unmounts. However, this is not the end of the story! Sometimes, it may also be necessary to start and stop synchronizing multiple times while the component remains mounted. Let’s look at why this is necessary, when it happens, and how you can control this behavior. Some Effects don’t return a cleanup function at all. More often than not, you’ll want to return one—but if you don’t, React will behave as if you returned an empty cleanup function. Why synchronization may need to happen more than once Imagine this component receives a prop that the user picks in a dropdown. Let’s say that initially the user picks the room as the . Your app displays the chat room: Welcome to the room!\n\n After the UI is displayed, React will run your Effect to start synchronizing. It connects to the room: Later, the user picks a different room in the dropdown (for example, ). First, React will update the UI: Welcome to the room!\n\n Think about what should happen next. The user sees that is the selected chat room in the UI. However, the Effect that ran the last time is still connected to the room. The prop has changed, so what your Effect did back then (connecting to the room) no longer matches the UI. At this point, you want React to do two things:\n• Stop synchronizing with the old (disconnect from the room)\n• Start synchronizing with the new (connect to the room) Luckily, you’ve already taught React how to do both of these things! Your Effect’s body specifies how to start synchronizing, and your cleanup function specifies how to stop synchronizing. All that React needs to do now is to call them in the correct order and with the correct props and state. Let’s see how exactly that happens. Recall that your component has received a new value for its prop. It used to be , and now it is . React needs to re-synchronize your Effect to re-connect you to a different room. To stop synchronizing, React will call the cleanup function that your Effect returned after connecting to the room. Since was , the cleanup function disconnects from the room: Then React will run the Effect that you’ve provided during this render. This time, is so it will start synchronizing to the chat room (until its cleanup function is eventually called too): Thanks to this, you’re now connected to the same room that the user chose in the UI. Disaster averted! Every time after your component re-renders with a different , your Effect will re-synchronize. For example, let’s say the user changes from to . React will again stop synchronizing your Effect by calling its cleanup function (disconnecting you from the room). Then it will start synchronizing again by running its body with the new prop (connecting you to the room). Finally, when the user goes to a different screen, unmounts. Now there is no need to stay connected at all. React will stop synchronizing your Effect one last time and disconnect you from the chat room. Let’s recap everything that’s happened from the component’s perspective: During each of these points in the component’s lifecycle, your Effect did different things:\n• Your Effect connected to the room\n• Your Effect disconnected from the room and connected to the room\n• Your Effect disconnected from the room and connected to the room\n• Your Effect disconnected from the room Now let’s think about what happened from the perspective of the Effect itself: This code’s structure might inspire you to see what happened as a sequence of non-overlapping time periods:\n• Your Effect connected to the room (until it disconnected)\n• Your Effect connected to the room (until it disconnected)\n• Your Effect connected to the room (until it disconnected) Previously, you were thinking from the component’s perspective. When you looked from the component’s perspective, it was tempting to think of Effects as “callbacks” or “lifecycle events” that fire at a specific time like “after a render” or “before unmount”. This way of thinking gets complicated very fast, so it’s best to avoid. Instead, always focus on a single start/stop cycle at a time. It shouldn’t matter whether a component is mounting, updating, or unmounting. All you need to do is to describe how to start synchronization and how to stop it. If you do it well, your Effect will be resilient to being started and stopped as many times as it’s needed. This might remind you how you don’t think whether a component is mounting or updating when you write the rendering logic that creates JSX. You describe what should be on the screen, and React figures out the rest. How React verifies that your Effect can re-synchronize Here is a live example that you can play with. Press “Open chat” to mount the component:\n\nNotice that when the component mounts for the first time, you see three logs: The first two logs are development-only. In development, React always remounts each component once. React verifies that your Effect can re-synchronize by forcing it to do that immediately in development. This might remind you of opening a door and closing it an extra time to check if the door lock works. React starts and stops your Effect one extra time in development to check you’ve implemented its cleanup well. The main reason your Effect will re-synchronize in practice is if some data it uses has changed. In the sandbox above, change the selected chat room. Notice how, when the changes, your Effect re-synchronizes. However, there are also more unusual cases in which re-synchronization is necessary. For example, try editing the in the sandbox above while the chat is open. Notice how the Effect re-synchronizes in response to your edits to the code. In the future, React may add more features that rely on re-synchronization. How React knows that it needs to re-synchronize the Effect You might be wondering how React knew that your Effect needed to re-synchronize after changes. It’s because you told React that its code depends on by including it in the list of dependencies:\n• You knew is a prop, which means it can change over time.\n• You knew that your Effect reads (so its logic depends on a value that may change later).\n• This is why you specified it as your Effect’s dependency (so that it re-synchronizes when changes). Every time after your component re-renders, React will look at the array of dependencies that you have passed. If any of the values in the array is different from the value at the same spot that you passed during the previous render, React will re-synchronize your Effect. For example, if you passed during the initial render, and later you passed during the next render, React will compare and . These are different values (compared with ), so React will re-synchronize your Effect. On the other hand, if your component re-renders but has not changed, your Effect will remain connected to the same room. Resist adding unrelated logic to your Effect only because this logic needs to run at the same time as an Effect you already wrote. For example, let’s say you want to send an analytics event when the user visits the room. You already have an Effect that depends on , so you might feel tempted to add the analytics call there: But imagine you later add another dependency to this Effect that needs to re-establish the connection. If this Effect re-synchronizes, it will also call for the same room, which you did not intend. Logging the visit is a separate process from connecting. Write them as two separate Effects: Each Effect in your code should represent a separate and independent synchronization process. In the above example, deleting one Effect wouldn’t break the other Effect’s logic. This is a good indication that they synchronize different things, and so it made sense to split them up. On the other hand, if you split up a cohesive piece of logic into separate Effects, the code may look “cleaner” but will be more difficult to maintain. This is why you should think whether the processes are same or separate, not whether the code looks cleaner. Your Effect reads two variables ( and ), but you only specified as a dependency: Why doesn’t need to be a dependency? This is because the never changes due to a re-render. It’s always the same no matter how many times the component re-renders and why. Since never changes, it wouldn’t make sense to specify it as a dependency. After all, dependencies only do something when they change over time! On the other hand, may be different on a re-render. Props, state, and other values declared inside the component are reactive because they’re calculated during rendering and participate in the React data flow. If was a state variable, it would be reactive. Reactive values must be included in dependencies: By including as a dependency, you ensure that the Effect re-synchronizes after it changes. Try changing the selected chat room or edit the server URL in this sandbox:\n\nHowever, if you think from the Effect’s perspective, you don’t need to think about mounting and unmounting at all. What’s important is you’ve specified what your Effect does to start and stop synchronizing. Today, it has no reactive dependencies. But if you ever want the user to change or over time (and they would become reactive), your Effect’s code won’t change. You will only need to add them to the dependencies. All variables declared in the component body are reactive Props and state aren’t the only reactive values. Values that you calculate from them are also reactive. If the props or state change, your component will re-render, and the values calculated from them will also change. This is why all variables from the component body used by the Effect should be in the Effect dependency list. Let’s say that the user can pick a chat server in the dropdown, but they can also configure a default server in settings. Suppose you’ve already put the settings state in a context so you read the from that context. Now you calculate the based on the selected server from props and the default server: In this example, is not a prop or a state variable. It’s a regular variable that you calculate during rendering. But it’s calculated during rendering, so it can change due to a re-render. This is why it’s reactive. All values inside the component (including props, state, and variables in your component’s body) are reactive. Any reactive value can change on a re-render, so you need to include reactive values as Effect’s dependencies. In other words, Effects “react” to all values from the component body. Can global or mutable values be dependencies? A mutable value like can’t be a dependency. It’s mutable, so it can change at any time completely outside of the React rendering data flow. Changing it wouldn’t trigger a re-render of your component. Therefore, even if you specified it in the dependencies, React wouldn’t know to re-synchronize the Effect when it changes. This also breaks the rules of React because reading mutable data during rendering (which is when you calculate the dependencies) breaks purity of rendering. Instead, you should read and subscribe to an external mutable value with . A mutable value like or things you read from it also can’t be a dependency. The ref object returned by itself can be a dependency, but its property is intentionally mutable. It lets you keep track of something without triggering a re-render. But since changing it doesn’t trigger a re-render, it’s not a reactive value, and React won’t know to re-run your Effect when it changes. As you’ll learn below on this page, a linter will check for these issues automatically. React verifies that you specified every reactive value as a dependency If your linter is configured for React, it will check that every reactive value used by your Effect’s code is declared as its dependency. For example, this is a lint error because both and are reactive:\n\nThis may look like a React error, but really React is pointing out a bug in your code. Both and may change over time, but you’re forgetting to re-synchronize your Effect when they change. You will remain connected to the initial and even after the user picks different values in the UI. To fix the bug, follow the linter’s suggestion to specify and as dependencies of your Effect: Try this fix in the sandbox above. Verify that the linter error is gone, and the chat re-connects when needed. In some cases, React knows that a value never changes even though it’s declared inside the component. For example, the function returned from and the ref object returned by are stable—they are guaranteed to not change on a re-render. Stable values aren’t reactive, so you may omit them from the list. Including them is allowed: they won’t change, so it doesn’t matter. What to do when you don’t want to re-synchronize In the previous example, you’ve fixed the lint error by listing and as dependencies. However, you could instead “prove” to the linter that these values aren’t reactive values, i.e. that they can’t change as a result of a re-render. For example, if and don’t depend on rendering and always have the same values, you can move them outside the component. Now they don’t need to be dependencies: You can also move them inside the Effect. They aren’t calculated during rendering, so they’re not reactive: Effects are reactive blocks of code. They re-synchronize when the values you read inside of them change. Unlike event handlers, which only run once per interaction, Effects run whenever synchronization is necessary. You can’t “choose” your dependencies. Your dependencies must include every reactive value you read in the Effect. The linter enforces this. Sometimes this may lead to problems like infinite loops and to your Effect re-synchronizing too often. Don’t fix these problems by suppressing the linter! Here’s what to try instead:\n• Check that your Effect represents an independent synchronization process. If your Effect doesn’t synchronize anything, it might be unnecessary. If it synchronizes several independent things, split it up.\n• If you want to read the latest value of props or state without “reacting” to it and re-synchronizing the Effect, you can split your Effect into a reactive part (which you’ll keep in the Effect) and a non-reactive part (which you’ll extract into something called an Effect Event). Read about separating Events from Effects.\n• Avoid relying on objects and functions as dependencies. If you create objects and functions during rendering and then read them from an Effect, they will be different on every render. This will cause your Effect to re-synchronize every time. Read more about removing unnecessary dependencies from Effects. The linter is your friend, but its powers are limited. The linter only knows when the dependencies are wrong. It doesn’t know the best way to solve each case. If the linter suggests a dependency, but adding it causes a loop, it doesn’t mean the linter should be ignored. You need to change the code inside (or outside) the Effect so that that value isn’t reactive and doesn’t need to be a dependency. If you have an existing codebase, you might have some Effects that suppress the linter like this: On the next pages, you’ll learn how to fix this code without breaking the rules. It’s always worth fixing!\n• Each Effect has a separate lifecycle from the surrounding component.\n• Each Effect describes a separate synchronization process that can start and stop.\n• When you write and read Effects, think from each individual Effect’s perspective (how to start and stop synchronization) rather than from the component’s perspective (how it mounts, updates, or unmounts).\n• Reactive values should re-synchronize the Effect because they can change over time.\n• The linter verifies that all reactive values used inside the Effect are specified as dependencies.\n• All errors flagged by the linter are legitimate. There’s always a way to fix the code to not break the rules."
    },
    {
        "link": "https://blog.logrocket.com/useeffect-react-hook-complete-guide",
        "document": "Editor’s note: This article was last updated on 12 October 2023 to add a comparison of the and Hooks, the relationship between the Hook and React Server Components, and more.\n\nUnderstanding how the Hook works is one of the most important concepts for mastering React today. Especially if you have been working with React for several years, it is crucial to understand how working with differs from working with the lifecycle methods of class-based components.\n\nWith , you invoke side effects from within functional components, which is an important concept to understand in the React Hooks era. Working with the side effects invoked by the Hook may seem cumbersome at first, but eventually, everything will make sense.\n\nThe goal of this article is to gather information about the underlying concepts of and to provide learnings from my own experience with the Hook. The code snippets provided are part of my companion GitHub project.\n\nWhat are the effects, really? Examples include fetching data, reading from local storage, and registering and deregistering event listeners.\n\nReact’s effects are a completely different animal than the lifecycle methods of class-based components. The abstraction level differs, too. To their credit, lifecycle methods do give components a predictable structure. The code is more explicit in contrast to effects, so developers can directly spot the relevant parts (e.g., ) in terms of performing tasks at particular lifecycle phases (e.g., on component unmount).\n\nAs we will see later, the Hook fosters the separation of concerns and reduces code duplication. For example, the official React docs show that you can avoid the duplicated code that results from lifecycle methods with one statement.\n\nA couple of key points to note before we get started:\n• Functions defined in the body of your function component get recreated on every render cycle. This has an impact if you use it inside of your effect. There are strategies to cope with it (for example, hoist them outside of the component, define them inside of the effect, use )\n• It is important to understand basic JavaScript concepts such as stale closures, otherwise, you might have trouble tackling problems with outdated props or state values inside of your effect\n• You should not ignore suggestions from the React Hooks ESLint plugin\n• Do not mimic the lifecycle methods of class-based components. This way of thinking does more harm than good. Instead, think more about data flow and state associated with effects because you run effects based on state changes across render cycles\n\nFor your fellow developers, code blocks are clear indicators of asynchronous tasks. Though it is possible to write asynchronous code without , it is not the “React way,” as it increases both complexity and the likelihood of introducing errors.\n\nInstead of writing asynchronous code without , which might block the UI, using is a known pattern in the React community. With , developers can easily overview the code and quickly recognize code that is executed “outside the control flow,” which becomes relevant only after the first render cycle.\n\nOn top of that, blocks are candidates to extract into reusable and even more semantic custom Hooks.\n\nWhen are effects executed within the component lifecycle?\n\nThis interactive diagram shows the React phases in which certain lifecycle methods (e.g., ) are executed:\n\nIn contrast, the next diagram shows how things work in the context of functional components:\n\nThis may sound strange initially, but effects defined with are invoked after render. To be more specific, it runs both after the first render and after every update. In contrast to lifecycle methods, effects don’t block the UI because they run asynchronously.\n\nIf you are new to React, I would recommend ignoring class-based components and lifecycle methods and, instead, learning how to develop functional components and how to decipher the powerful possibilities of effects. Class-based components are rarely used in more recent React development projects.\n\nIf you are a seasoned React developer and are familiar with class-based components, you have to do some of the same things in your projects today as you did a few years ago when there were no Hooks.\n\nFor example, it is pretty common to “do something” when the component is first rendered. The difference with Hooks here is subtle: you do not do something after the component is mounted; you do something after the component is first presented to the user. Hooks force you to think more from the user’s perspective.\n\nHow does the Hook get executed?\n\nThis section briefly describes the control flow of effects. The following steps are carried out when executing an effect:\n• Initial render/mounting: When a functional component that contains a Hook is initially rendered, the code inside the block runs after the initial render of the component. This is similar to class components\n• Subsequent renders: You can pass a dependency array as the second argument to the Hook. This array contains variables or values that the effect depends on. Any change in these variables will re-render the component. If no dependency array is given, the effect will run on every render\n• Cleanup function: You can also run an optional cleanup function inside the effect. It is used to clean up any resources or subscriptions created by the effect when the component is unmounted or when the dependencies change\n• Unmounting: If a cleanup function is present, it is run and then the component is unmounted from the DOM\n\nIf one or more declarations exist for the component, React checks each to determine whether it fulfills the conditions to execute the implementation (the body of the callback function provided as the first argument). In this case, “conditions” mean one or more dependencies have changed since the last render cycle.\n\nHow to execute side effects with\n\nThe signature of the Hook looks like this:\n\nBecause the second argument is optional, the following execution is perfectly fine:\n\nLet’s take a look at an example. The user can change the document title with an input field:\n\nThe statement is only defined with a single, mandatory argument to implement the actual effect to execute. In our case, we use the state variable representing the title and assign its value to .\n\nBecause we skipped the second argument, this is called after every render. Because we implemented an uncontrolled input field with the help of the Hook, is only invoked after the user clicks on the button. This causes a re-render because performs a state change.\n\nAfter every render cycle, is executed again. To demonstrate this, I added two statements:\n\nThe first two log outputs are due to the initial rendering after the component was mounted. Let’s add another state variable to the example to toggle a dark mode with the help of a checkbox:\n\nHowever, this example leads to unnecessary effects when you toggle the state variable:\n\nOf course, it’s not a big deal in this example, but you can imagine more problematic use cases that cause bugs or, at least, performance issues. Let’s take a look at the following code and try to read the initial title from local storage, if available, in an additional block:\n\nAs you can see, we have an infinite loop of effects because every state changes with triggers another effect, which updates the state again:\n\nThe Hook’s second argument, known as the dependency array, serves the purpose of indicating the variables upon which the effect relies. This brings us to an important question: What items should be included in the dependency array?\n\nAccording to the React docs, you must include all values from the component scope that change their values between re-renders. What does this mean, exactly?\n\nAll external values referenced inside of the callback function, such as props, state variables, or context variables, are dependencies of the effect. Ref containers (i.e., what you directly get from and not the property) are also valid dependencies. Even local variables, which are derived from the aforementioned values, have to be listed in the dependency array.\n\nThe importance of the dependency array\n\nLet’s go back to our previous example with two states (title and dark mode). Why do we have the problem of unnecessary effects?\n\nAgain, if you do not provide a dependency array, every scheduled is executed. This means that after every render cycle, every effect defined in the corresponding component is executed one after the other based on the positioning in the source code.\n\nSo the order of your effect definitions matters. In our case, our single statement is executed whenever one of the state variables changes. You have the ability to opt out of this behavior. This is managed with dependencies you provide as array entries. In these cases, React only executes the statement if at least one of the provided dependencies has changed since the previous run.\n\nLet’s get back to our example where we want to skip unnecessary effects after an intended re-render. We just have to add an array with as a dependency. With that, the effect is only executed when the values between render cycles differ:\n\nAs you can see in the recording, effects are only invoked as expected when pressing the button:\n\nIt’s also possible to add an empty dependency array. In this case, effects are only executed once; it is similar to the lifecycle method. To demonstrate this, let’s take a look at the previous example with the infinite loop of effects:\n\nWe just added an empty array as our second argument. Because of this, the effect is only executed once after the first render and skipped for the following render cycles:\n\nIn principle, the dependency array says, “Execute the effect provided by the first argument after the next render cycle whenever one of the arguments changes.” However, we don’t have any argument, so dependencies will never change in the future.\n\nThat’s why using an empty dependency array makes React invoke an effect only once — after the first render. The second render along with the second is due to the state change invoked by after we read the value from local storage.\n\nThe next snippet shows an example demonstrating a problematic issue:\n\nThis code implements a React component representing a counter that increases a number every second. The parent component renders the counter and allows you to destroy the counter by clicking on a button.\n\nTake a look at the recording to see what happens when a user clicks on that button:\n\nThe child component has registered an interval that invokes a function every second. However, the component was destroyed without unregistering the interval. After the component is destroyed, the interval is still active and wants to update the component’s state variable ( ), which no longer exists.\n\nThe solution is to unregister the interval right before unmounting. This is possible with a cleanup function. Therefore, you must return a callback function inside the effect’s callback body:\n\nI want to emphasize that cleanup functions are not only invoked before destroying the React component. An effect’s cleanup function gets invoked every time right before the execution of the next scheduled effect.\n\nLet’s take a closer look at our example. We used a trick to have an empty dependency array in the first place, so the cleanup function acts like a lifecycle method. If we do not call with a callback function that gets the previous value as an argument, we need to come up with the following code, wherein we add to the dependencies array:\n\nIn comparison, the former example executes the cleanup function only once — on the mount — because we directly prevented using the state variable (count):\n\nIn this context, the latter approach is a small performance optimization because we reduce the number of cleanup function calls.\n\nBoth and improve functional components and allow them to do things that classes can and that functional components can’t do without Hooks. To understand the difference between the two better, we need to first understand the purpose of both these Hooks:\n\nThe Hook is used to manage state variables within a functional component, akin to how works in class components. With , you can declare and initialize a state variable, and the Hook provides a function to update its value.\n\nWe have already delved into in detail. In essence, it empowers functional components with lifecycle methods similar to those found in class components. You can employ to perform actions such as data fetching, DOM manipulation, or the establishment of subscriptions in response to component lifecycle events.\n\nWhile both of these hooks serve distinct purposes, they are frequently used in conjunction. For instance, states are often utilized in the dependency arrays of an effect, allowing components to re-render when state changes occur.\n\nImplications of prop and state changes\n\nThere is a natural correlation between prop changes and the execution of effects because they cause re-renders, and as we already know, effects are scheduled after every render cycle.\n\nConsider the following example. The plan is that the component’s interval can be configured by a prop with the same name:\n\nThe handy ESLint plugin points out that we are missing something important: because we haven’t added the prop to the dependency array (having instead defined an empty array), the change to the input field in the parent component is without effect.\n\nThe initial value of is used even after we adjust the input field’s value:\n\nInstead, we have to add the prop to the dependency array:\n\nNow things look much better:\n\nCustom Hooks are awesome because they lead to various benefits:\n• More semantic code due to the function calls of the custom Hooks inside of components\n• Effects can be tested when used inside of custom Hooks, as we’ll see in the next section\n\nThe following example represents a custom Hook for fetching data. We moved the code block into a function representing the custom Hook. Note that this is a rather simplified implementation that might not cover all your project’s requirements. You can find more production-ready custom fetch Hooks here:\n\nThe first statement within our React component, , uses the custom Hook . As you can see, using a custom Hook like this is more semantic than using an effect directly inside the component.\n\nBusiness logic is nicely abstracted out of the component. We have to use our custom Hook’s nice API that returns the state variables and .\n\nThe effect inside of the custom Hook is dependent on the scope variable that is passed to the Hook as a prop. This is because we have to include it in the dependency array. So even though we don’t foresee the URL changing in this example, it’s still good practice to define it as a dependency. As mentioned above, there is a chance that the value will change at runtime in the future.\n\nAdditional thoughts on functions used inside of effects\n\nIf you take a closer look at the last example, we defined the function inside the effect because we only use it there. This is a best practice for such a use case. If we define it outside the effect, we need to develop unnecessarily complex code:\n\nAs you can see, we need to add to the dependency array of our effect. In addition, we need to wrap the actual function body of with with its own dependency ( ) because the function gets recreated on every render.\n\nBy the way, if you move function definitions into effects, you produce more readable code because it is directly apparent which scope values the effect uses. The code is even more robust.\n\nFurthermore, if you do not pass dependencies into the component as props or context, the ESLint plugin “sees” all relevant dependencies and can suggest forgotten values to be declared.\n\nIf you recall our block inside the custom Hook, you might ask why we need this extra function definition. Can’t we refactor our code like so:\n\nI’m glad you asked, but no! The following error will occur:\n\nThe mighty ESLint plugin also warns you about it. The reason is that this code returns a promise, but an effect can only return void or a cleanup function.\n\nIn this section, I’ll show you some handy patterns that might be useful when using the Hook.\n\nExecute an effect only once when a certain condition is met\n\nAs we already know, you control the execution of effects mainly with the dependency array. Every time one of the dependencies is changed, the effect is executed. You should design your components to execute effects whenever a state changes, not just once.\n\nSometimes, however, you want to trigger an effect only under specific conditions, such as when a certain event occurs. You can do this with flags that you use within an statement inside of your effect.\n\nThe Hook is a good choice if you don’t want to add an extra render (which would be problematic most of the time) when updating the flag. In addition, you don’t have to add the ref to the dependency array.\n\nThe following example calls the function from our effect only if the following conditions are met:\n• The user clicked the button at least once\n• The user has ticked the checkbox to allow tracking\n\nAfter the checkbox is ticked, the tracking function should only be executed after the user clicks on the button once again:\n\nIn this implementation, we utilized two refs: and . The latter is the “gate” to guarantee that the tracking function is only invoked once after the other conditions are met.\n\nThe effect is rerun every time changes, i.e., whenever the user clicks on the button. Our statement checks the conditions and executes the actual business logic only if it evaluates to :\n\nThe log message is only printed once after the right conditions are met.\n\nIf you need to access some data from the previous render cycle, you can leverage a combination of and :\n\nWe synchronize our effect with the state variable so that it is executed after the user clicks on the button. Inside of our effect, we assign the current value of the state variable to the mutable property of . We output both values in the JSX section:\n\nWhen loading this demo, on initial render, the state variable has the initial value of the call. The ref value is . It demonstrates once more that effects are run after render. When the user clicks, it works as expected.\n\nWhen not to use\n\nThere are some situations in which you should avoid using due to potential performance concerns.\n\nIf you need to transform data before rendering, then you don’t need . Suppose you are showing a user list and only want to filter the user list based on some criteria. Maybe you only want to show the list of active users:\n\nHere you can just do the filtering and show the users directly, like so:\n\nThis will save you time and improve the performance of your application.\n\nYou don’t need user events. Let’s say you want to make a POST request once a user clicks on a form submit button. The following piece of code is inspired from React’s documentation:\n\nIn the above code, you can just make the post request once the button is clicked. But you are cascading the effect, so once the is triggered, it doesn’t have the complete context of what happened.\n\nThis might cause issues in the future; instead, you can just make the POST request on the function:\n\nThis is much cleaner and can help reduce future bugs.\n\nReact Server Components allow you to fetch and render components on the server, sending only the required data and parts of the UI to the client. The server pre-generates the initial HTML to prevent users from encountering a blank white page while the JavaScript bundles are being fetched and processed. Client-side React takes over from where server-side React left off, seamlessly integrating with the DOM and enhancing interactivity.\n\nHowever, Server Components can’t re-render. And we can’t use effects or states because they only run after the render on the client, but Server Components are already rendered on the server.\n\nServer Components are specifically crafted for server-side content pre-rendering, reducing their dependence on for data retrieval. Instead, they are capable of fetching data during the server rendering process and subsequently transmitting it as props to the client component.\n\nSo where can be used? Server components can pass data as props to the client components, which can then use to handle client-specific behavior. This approach can streamline the data flow and reduce the need for complex client-side data fetching logic.\n\nUnderstanding the underlying design concepts and best practices of the Hook is a key skill to master if you wish to become a next-level React developer.\n\nIf you started your React journey before early 2019, you have to unlearn your instinct to think in lifecycle methods instead of thinking in effects.\n\nAdopting the mental model of effects will familiarize you with the component lifecycle, data flow, other Hooks ( , , , , etc.), and even other optimizations like ."
    },
    {
        "link": "https://dev.to/mperon/axios-error-handling-like-a-boss-333d",
        "document": "I really love the problem/solution. approach. We see some problem, and then, a really nice solution. But for this talking, i think we need some introduction as well.\n\nWhen you develop an web application, you generally want's to separate the frontend and backend. Fo that, you need something that makes the communication between these guys.\n\nTo illustrate, you can build a frontend (commonly named as GUI or user interface) using vanilla HTML, CSS and Javascript, or, frequently, using several frameworks like Vue, React and so many more avaliable online. I marked Vue because it's my personal preference.\n\nWhy? I really don't study the others so deeply that i can't assure to you that Vue is the best, but i liked the way he works, the syntax, and so on. It's like your crush, it's a personal choice.\n\nBut, beside that, any framework you use, you will face the same problem:_ How to communicate with you backend_ (that can be written in so many languages, that i will not dare mention some. My current crush? Python an Flask).\n\nOne solution is to use AJAX (What is AJAX? Asynchronous JavaScript And XML). You can use XMLHttpRequest directly, to make requests to backend and get the data you need, but the downside is that the code is verbose. You can use Fetch API that will make an abstraction on top of , with a powerfull set of tools. Other great change is that will use Promises, avoiding the callbacks from (preventing the callback hell).\n\nAlternatively, we have a awesome library named Axios, that have a nice API (for curiosity purposes, under the hood, uses , giving a very wide browser support). The Axios API wraps the into , different from . Beside that, nowadays is well supported by the browsers engines available, and have polyfills for older browsers. I will not discuss which one is better because i really think is personal preference, like any other library or framework around. If you dont't have an opinion, i suggest that you seek some comparisons and dive deep articles. Has a nice article that i will mention to you written by Faraz Kelhini.\n\nMy personal choice is because have a nice API, has Response timeout, automatic JSON transformation, and Interceptors (we will use them in the proposal solution), and so much more. Nothing that cannot be accomplished by , but has another approach.\n\nTalking about , a simple GET HTTP request can be made with these lines of code:\n\n\n\nWe've used Typescript (interfaces, and generics), ES6 Modules, Promises, Axios and Arrow Functions. We will not touch them deeply, and will presume that you already know about them.\n\nSo, in the above code, if everything goes well, aka: the server is online, the network is working perfectly, so on, when you run this code you will see the list of users on console. The real life isn't always perfect.\n\nSo, when something is go bad, we need to use all the efforts in ours hands to resolve the problem ourselves, without the user even notice, and, when nothing more can be done, we have the obligation to show them a really nice message explaining what goes wrong, to easy theirs souls.\n\nlike uses to handle asynchronous calls and avoid the callbacks that we mention before. are a really nice API and not to difficult to understand. We can chain actions ( ) and error handlers ( ) one after another, and the API will call them in order. If an Error occurs in the Promise, the nearest is found and executed.\n\nSo, the code above with basic error handler will become:\n\n\n\nOk, and what is the problem then? Well, we have a hundred errors that, in every API call, the solution/message is the same. For curiosity, Axios show us a little list of them: . We have the HTTP Status Codes, where we found so many errors, like (Page Not Found), and so on. You get the picture. We have too much common errors to elegantly handle in every API request.\n\nOne very ugly solution that we can think of, is to write one big ass function that we increment every new error we found. Besides the ugliness of this approach, it will work, if you and your team remember to call the function in every API request.\n\n\n\nWith our magical badass function in place, we can use it like that:\n\n\n\nWe have to remember to add this in every API call, and, for every new error that we can graciously handle, we need to increase our nasty with some more code and ugly .\n\nOther problem we have with this approach, besides ugliness and lack of mantenability, is that, if in one, only single one API call, i desire to handle different from global approach, i cannot do.\n\nThe function will grow exponentially as the problems that came together. This solution will not scale right!\n\nWhen we work as a team, to make them remember the slickness of every piece of software is hard, very hard. Team members, come and go, and i do not know any documentation good enough to surpass this issue.\n\nIn other hand, if the code itself can handle these problems on a generic way, do-it! The developers cannot make mistakes if they need do nothing!\n\nBefore we jump into code (that is what we expect from this article), i have the need to speak some stuff to you understand what the codes do.\n\nAxios allow we to use something called that will be executed in every request you make. It's a awesome way of checking permission, add some header that need to be present, like a token, and preprocess responses, reducing the amount of boilerplate code.\n\nWe have two types of . Before (request) and After (response) an AJAX Call.\n\nIt's use is simple as that:\n\n\n\nBut, in this article, we will use the response interceptor, because is where we want to deal with errors. Nothing stops you to extend the solution to handle request errors as well.\n\nAn simple use of response interceptor, is to call ours big ugly function to handle all sort of errors.\n\nAs every form of automatic handler, we need a way to bypass this (disable), when we want. We are gonna extend the interface and add two optional options and . If is set to , we are gonna do nothing. is there to mute notifications that we show when dealing with global errors.\n\n\n\nNext step is to create a class that we will throw every time we want to inform the error handler to assume the problem.\n\n\n\nWell, we do not need to remember our magical badass function in every ajax call we made. And, we can disable when we want, just passing to request config.\n\n\n\nOk, this is a nice solution, but, this bad-ass ugly function will grow so much, that we cannot see the end. The function will become so big, that anyone will want to maintain.\n\nCan we improve more? Oh yeahhh.\n\nWe are gonna develop an class, using Registry Design Pattern. The class will allow you to register error handling by an key (we will deep dive in this in a moment) and a action, that can be an string (message), an object (that can do some nasty things) or an function, that will be executed when the error matches the key. The registry will have parent that can be placed to allow you override keys to custom handle scenarios.\n\nHere are some types that we will use througth the code:\n\n\n\nSo, with types done, let's see the class implementation. We are gonna use an Map to store object/keys and a parent, that we will seek if the key is not found in the current class. If parent is null, the search will end. On construction, we can pass an parent,and optionally, an instance of , to register some handlers.\n\n\n\nLet's deep dive the code. We choose to use as an identifier to select the best handler for error. When you look at the code, you see that has an order that will be searched in the registry. The rule is, search for the most specific to the most generic.\n\n\n\nThis is an example of an error sent by API:\n\n\n\nOther example, as well:\n\n\n\nSo, as an example, we can now register ours generic error handling:\n\n\n\nWe can register error handler in any place we like, group the most generic in one typescript file, and specific ones inline. You choose. But, to this work, we need to attach to ours axios instance. This is done like this:\n\n\n\nNow, we can make ajax requests, and the error handler will work as expected:\n\n\n\nThe code above will show a Notify ballon on the user screen, because will fire the error status code, that we registered before.\n\nThe solution doesn't end here. Let's assume that, in one, only one http request, you want to handle differently, but just . For that, we create the function below:\n\n\n\nThis function uses the parent to personalize one key, but for all others, use the global handlers (if you wanted that, is there to force not).\n\nSo, we can write code like this:\n\n\n\nAll this explanation is nice, but code, ah, the code, is so much better. So, i've created an github repository with all code from this article organized to you try out, improve and customize.\n• Click here to access the repo in github.\n• This post became so much bigger than a first realize, but i love to share my thoughts.\n• If you have some improvement to the code, please let me know in the comments.\n• If you see something wrong, please, fix-me!"
    },
    {
        "link": "https://stackoverflow.com/questions/49967779/axios-handling-errors",
        "document": "I'm trying to understand javascript promises better with Axios. What I pretend is to handle all errors in Request.js and only call the request function from anywhere without having to use . In this example, the response to the request will be 400 with an error message in JSON. This is the error I'm getting: The only solution I find is to add in Somewhere.js but I'm trying to avoid having to do that. Is it possible?"
    },
    {
        "link": "https://dpw-developer.medium.com/your-first-api-call-get-requests-in-typescript-using-axios-b374be0479b6",
        "document": "Your First API Call: GET Requests in Typescript using Axios\n• What is Axios and Why Use It?\n\nAxios is a promise-based HTTP Client for and the browser. It is isomorphic (= it can run in the browser and nodejs with the same codebase). On the server-side it uses the native node.js module, while on the client (browser) it uses XMLHttpRequests.\n• Axios abstracts the complicated features of the fetch() API, simplifying HTTP requests.\n• It supports automatic JSON conversion based on the Content-Type header and allows for custom response parsing via transformResponse.\n• It works across all modern browsers (Chrome, Firefox, Safari, Edge, Opera) and supports Internet Explorer 11 with polyfills.\n\nBenefits of Using TypeScript with Axios\n• Simplified Syntax: Utilizing .get() and .post() methods for cleaner code.\n• Type Safety: TypeScript helps in defining expected response types, making your code more robust against runtime errors.\n\nTo integrate Axios into your project, run the following in your terminal\n\nHere’s how you can set some defaults for Axios:\n\nYou might prefer to use a .env file for environment-specific configurations.\n\nNote: This example doesn’t include type annotations for the response data. We’ll cover that next.\n\nThis approach ensures your code is type-safe, but what if the API doesn’t return what you expect?\n• error.config: The Axios configuration for the request.\n\nWe can target statuses of requests:\n\nSomtimes you may want to retry the same request if it fails the first time. In that case we’d need to install axios-retry and this will attempt each axios call as many times as you specify. 3 times in the below example.\n\nif we need to handle an axios error in typescript we can use AxiosError as the type to safely access the properties in the catch.\n\nIf we wanted a particular row from a database we may pass the index through a param, here we’re passing key1 and key2 as params. Axios will add these to the URL.\n\nBelow you can see the html encoding of both params using the specified object property names and the values they hold.\n\nBelow we are passing an object into our fetch data function. This function is expecting the object to contain properties found in the description of our interface. This is protecting our call to our API by ensuring our data is in the expected datatypes.\n\nSee call below for how axios would handle these params.\n\nIn modern versions of axios we can use an abort controller to cancel a request through attaching a signal in the data. We then can call controller abort to cancel the request. It may be that our user wants to cancel a request to preform an another activity.\n• Sending Auth Tokens with GET Requests in Axios\n\nNow API’s have many different headers which we can add. One of which is a header. This is most commonly used for a token but there are many ways to do to hevily depends on what your API you’re interacting with uses. Below is an example with . You’ll notice we prefix a token with but this again depends on the API. Below we’ve added a headers object and placed this inside.\n\nIn Typescript you can make your call by extending authHeaders to include an authorization string. then you can add this to the request.\n\nYou can even use interceptors to automagically attach the token whenever you make a request if you need to by passing this token through local storgae when a user preforms an action.\n• CORS Issues: Check the network tab in browser developer tools for Access-Control-Allow-Origin issues.\n• Ensure Server Method Support: Verify if the server supports the HTTP methods, headers, and origin you’re using.\n• Use axios.isAxiosError() to check for Axios-specific errors.\n• Log requests and responses with interceptors for detailed debugging.\n• Use environment variables for API keys and sensitive data.\n• Implement proper error handling and logging for production use.\n• Utilize TypeScript generics with Axios for even stronger type checking."
    },
    {
        "link": "https://linkedin.com/pulse/mastering-http-requests-javascript-axios-typescript-novin-noori",
        "document": "Setting up Axios in your React TypeScript project\n\nUsing interceptors to modify requests and responses\n\nUsing Axios with authentication and authorisation"
    },
    {
        "link": "https://dev.to/mdmostafizurrahaman/handle-axios-error-in-typescript-4mf9",
        "document": "Let's imagine we are calling an API with within a block to get a list of posts. If the request is successful then we will get the response data, else we will get the error on our block\n\n\n\nBut the problem is typescript assumes this object as type. So, typescript won't allow us to access any properties inside this object. \n\n To handle this situation, we can assert the object type like this\n\n\n\nBut the assertion is not a good practice and we should avoid doing this. By asserting type you are forcing the typescript to stop doing his work. So this may be problematic sometimes.\n\nWe can use typeguard to handle this kind of situation and also provides a for handling errors. Here how it looks like\n\n\n\nWe can also pass generic to type the error and object with this .\n\n\n\nN:B: You can also use this in a method.\n\nTo learn about more tips and tricks with typescript, follow me on LinkedIn"
    }
]