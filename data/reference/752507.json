[
    {
        "link": "https://geeksforgeeks.org/overriding-in-java",
        "document": "Overriding in Java occurs when a subclass implements a method which is already defined in the superclass or Base Class. The method in the subclass must have the same signature as in the superclass. It allows the subclass to modify the inherited methods.\n\nExample: Below is an example of how overriding works in Java.\n\nExplnation: The Animal class defines base functionalities like move() and eat().t he Dog class inherits from Animal and overrides the move() method to provide a specific behavior Dog is running. Both classes can access their own methods. When creating a Dog object, calling move() executes the overridden method.\n\nMethod overriding is a key concept in Java that enables Run-time polymorphism. It allows a subclass to provide its specific implementation for a method inherited from its parent class. The actual method executed is determined by the object’s runtime type, not just the reference variable’s type. This dynamic behaviour is crucial for creating flexible and extensible object-oriented designs.\n\nExample: Below is the implementation of the Java Method Overriding\n\nExplanation: in this code the Child class inherits from the Parent class and overrides the show() method, providing its own implementation. When a Parent reference points to a Child object, the Child’s overridden show() method is executed at runtime, showcasing the principle of polymorphism in Java.\n\nAn overriding method’s access modifier in a subclass can be more permissive (e.g., protected to the public) than the overridden method in the superclass. However, reducing the access level (e.g., making a protected method private) is not allowed and will result in a compile-time error.\n\nExample: Java program to demonstrate Overriding an Access-Modifiers\n\nExpaination: Here the parent class is overridden by the subclass and from the output we can easily identify the difference.\n\n2. O methods can not be overridden\n\nIf we don’t want a method to be overridden, we declare it as final. Please see Using Final with Inheritance.\n\nExample: Java program which shows the final method can not override.\n\n3. Static methods can not be overridden(Method Overriding vs Method Hiding)\n\nWhen you define a static method with the same signature as a static method in the base class, it is known as method hiding.\n• None Subclass Instance method can override the superclass’s Instance method but when we try to override the superclass static method gives a compile time error.\n• None Subclass Static Method generate compile time when trying to override superclass Instance method subclass static method hides when trying to override superclass static method.\n\nExample: Java program to show method hiding in Java.\n\n4. Private methods can not be overridden\n\nPrivate methods cannot be overridden as they are bonded during compile time. Therefore we can’t even override private methods in a subclass.\n\nExample: This example shows private method can not be overridden in java\n\n5. Method must have the same return type (or subtype)\n\nFrom Java 5.0 onwards it is possible to have different return types for an overriding method in the child class, but the child’s return type should be a sub-type of the parent’s return type. This phenomenon is known as the covariant return type.\n\nExample: Java Program which shows Covariant Return Type in Method Overriding.\n\nWe can call the parent class method in the overriding method using the super keyword.\n\nExample: This example shows we can parent’s overridden method using super an.\n\nWe can not override the constructor as the parent and child class can never have a constructor with the same name(The constructor name must always be the same as the Class name).\n\nBelow are two rules to note when overriding methods related to exception handling.\n\nIf the super-class overridden method does not throw an exception, the subclass overriding method can only throw the unchecked exception, throwing a checked exception will lead to a compile-time error.\n\nExample: Below is an example of a java program when the parent class method does not declare the exception\n\nExplanation: this example shows that uper-class overridden method does not throw an exception, the subclass overriding method can only throw the exception because the super class does not declare the exception.\n\nIf the superclass overridden method does throw an exception, the subclass overriding method can only throw the same, subclass exception. Throwing parent exceptions in the Exception hierarchy will lead to compile time error. Also, there is no issue if the subclass overridden method does not throw any exception.\n\nExample: Java program to demonstrate overriding when superclass method does declare an exception\n\nAbstract methods in an interface or abstract class are meant to be overridden in derived concrete classes otherwise a compile-time error will be thrown.\n\nThe presence of a synchronized/strictfp modifier with the method has no effect on the rules of overriding, i.e. it’s possible that a synchronized/strictfp method can override a non-synchronized/strictfp one and vice-versa.\n\n1. Overloading is about the same method having different signatures. Overriding is about the same method, and same signature but different classes connected through inheritance.\n\n2. Overloading is an example of compiler-time polymorphism and overriding is an example of run-time polymorphism.\n\nQ2. When to apply Method Overriding? (with example)"
    },
    {
        "link": "https://stackoverflow.com/questions/46502934/good-practice-to-programming-in-java-override-and-hierarchy",
        "document": "I doing override a method declared in Class B. This method that override will be in Class C. The hierarchy is Class C extends B that extends A. The method is present in each class like this:\n\nThese classes is common for each project and the projects are many for these reason I can't modify this class unless exceptional cases.\n\nI have to override the method overrideMe() to add code inside but at the end of the method I still need call method of class A.\n\nNow the question are Two, is better:\n\n1) Create a method in Class B that call only method overrideMe() in class A and extends overrideMe():\n\n2) Create a custom method in class B, this method will be included in overrideMe() of class B and extends only for my project in class C:\n\nFYI: These class, A and B, are more method and code.\n\nOk so, issue that we will have to give in order to importance:\n\n1) Good programming practice of java 2) Less impact on code 3) Less impact for all project. These project are different project but share a common base code. 4) If i change common code each project are to check this code to are sure that there isn't impact for project.\n\nIs better the first solution or the second and why?"
    },
    {
        "link": "https://medium.com/@niitwork0921/rules-and-guidelines-for-method-overriding-in-java-809c889894a5",
        "document": "Method overriding is a core feature of the Java programming language that enables subclasses to offer their own implementation of a method that is specified in their superclasses. In object-oriented programming, this makes the idea of inheritance easier to understand and also makes polymorphism possible.\n\nHowever, in order to guarantee correct operation and to keep the code’s integrity intact, method overriding has to adhere to a few certain principles and norms. In this post, we will investigate the rules and guidelines for method overriding in Java. We will discuss fundamental principles and recommended practices that should be adhered to while implementing overridden methods.\n\nA Java developer course can be helpful to get a better understanding of this subject.\n\nThe Fundamentals of Inheritance and Method Overriding\n\nIt is essential to have a firm understanding of the idea of inheritance in Java if you want to comprehend the notion of method overriding data. Through the process of inheritance, a subclass may take on the characteristics and actions of its parent class. When a subclass offers its own implementation for a method that it has overridden, that implementation takes precedence over the one provided by the superclass.\n\nDuring the override, the method signature, which includes the name of the method, the return type, and the arguments, must stay unchanged. Method overriding makes it easier to apply the polymorphism principle, which states that objects of various classes may be handled consistently on the basis of the superclass they share.\n\nMaintaining a consistent method signature is one of the most important guidelines to follow when overriding a method. The method that is overriding another method in the superclass must have the same name, return type, and argument signature as the method that is being overridden.\n\nThe return type has to be covariant, which means that it may either be exactly the same as the return type in the superclass or a subclass of that type. The parameters of the method have to be the same in type, order, and quantity. An error in the compilation will occur if the consistent method signature is violated at any point throughout the development process.\n\nAccess modifiers are an essential component of the method-overriding process. It is not possible for a method that is overridden to have a more stringent access modifier than the method that it is overriding in the superclass. For instance, if the method of the superclass is stated to have public access, the overriding method must likewise have public access or access that is less restricted (such as protected or default access).\n\nThis rule makes certain that the subclass does not make the inherited method less accessible than it was before. On the other hand, the overriding method might have a more lax access modifier (for instance, replacing a protected method with a public method could be an example of this).\n\nThe “final” and “static” Keywords: the “final” and “static”:\n\nThe use of the term “final” and static methods both have an effect on the process of method overriding. If a method in the superclass is defined to be final, then it is not possible for any subclass to override that method. When you use the “final” modifier, it indicates that the method’s implementation is finished and cannot be changed in any way. In a similar vein, static methods are not “overridden” in the conventional meaning of the word. They are instead hidden in subclasses, which means that a subclass may create a method with the same signature, but that method will not be deemed to be an overridden method. The behaviour of the static method is not dependent on the actual object type; rather, it is governed by the reference type.\n\nWhen overriding a method, the handling of exceptions is a crucial factor to take into account. In the event that the method that is being overridden in the superclass generates a checked exception, the method that is being overridden in the subclass has the option of declaring either the same checked exception or a subclass of it. Nevertheless, the overriding method must not throw an exception that is either more general or unrelated. By adhering to this rule, the subclass will not be in violation of the exception handling contract that the superclass has outlined. It makes it possible for the client code to handle exceptions in a consistent manner, free from any surprises.\n\nWhen implementing method overriding in Java, the use of the @Override annotation is a recommended practice that should be followed. During the compilation process, it assists in locating methods that have been overridden and verify that the method in question is effectively taking the place of a method inherited from a superclass.\n\nAn error in the compilation will occur if the method signature in the superclass does not match the method signature in the subclass when using the @Override annotation. In addition to this, it improves the readability of the code and makes it simpler and easier to maintain. When overriding a method’s implementation, it is strongly suggested that the @Override annotation be used in every case.\n\nJava’s robust method-overriding functionality is what makes the language’s polymorphism and code reuse capabilities possible. Method overriding may be ensured to be implemented correctly and consistently by adhering to the rules and principles that are covered in this article. Some of these rules and guidelines include keeping a consistent method signature, adhering to access modifier limitations, handling exceptions in the appropriate manner, and making use of the @Override annotation.\n\nThe ability of developers to successfully exploit method overriding to increase the flexibility and extensibility of their Java programs is contingent on their awareness of, and adherence to, the principles and recommended practices outlined here.\n\nA Java development course can enhance your skills."
    },
    {
        "link": "https://unstop.com/blog/method-overriding-in-java",
        "document": "Lean How To Find Leap Year Program In Java (With Code Examples)\n\nLearn How To Return ArrayList In Java With Detailed Code Examples\n\nHow To Return An Array In Java? A Detailed Guide With Examples\n\nBreak Statement In Java | Working, Uses And More (+Code Examples)\n\nNew Keyword In Java | Syntax, Uses And More (+Code Examples)\n\nThis Keyword In Java | Syntax, Best Practices & More (+Examples)\n\nTop 15 Best Java IDE (2025) That Every Developer Must Know!\n\nHow To Install Java For Windows, MacOS, And Linux? With Examples\n\nWhen the subclass redefines a method it inherited from the parent/ superclass, it is known as method overriding in Java. The language provides a set of rules to override methods without errors.\n\nImagine you have an old family recipe passed down for generations. And while you follow most of it, you like to add a few of your own touches—a pinch of spice here, a twist in flavor there—to make it uniquely yours. This is what method overriding in Java is about, but for methods/functions.\n\nIn technical terms, you inherit a method from a superclass (like the recipe) but redefine it in your subclass (your own version) to suit specific needs. In this article, we will discuss method overriding in Java in detail, including its rules, implementations, use cases, pitfalls, and more, with proper code examples.\n\nWhat Is Method Overriding In Java?\n\nMethod overriding is a powerful concept in Java that allows a subclass (or child class) to redefine a method inherited from its superclass (or parent class). This is especially useful when the implementation of the inherited method doesn’t fully serve the subclass's needs.\n• None By overriding, the subclass provides its own implementation of a method that already exists in the superclass, customizing its behavior as required.\n• None In method overriding, both the superclass and the subclass contain a method with the same\n• None When the subclass redefines this method, it effectively \"overrides\" the version in the superclass, replacing the inherited behavior with its own.\n\nThis allows objects to exhibit different behaviors based on their runtime types—a concept known as runtime polymorphism or dynamic method dispatch. With runtime polymorphism, the method that gets executed is chosen at runtime, depending on the object’s actual type.\n• Superclass is the base class containing the method to be overridden.\n• Subclass is the child class that extends the superclass and provides a custom implementation.\n• returnType specifies the type of value returned, like int or String.\n• methodName is the identifier or name of the method, matching the one in the superclass.\n• @Override annotation signals that the method in the subclass is intended to override one in the superclass, ensuring the method signatures match exactly.\n\nIn the syntax above, the superclass method provides default behavior, while the subclass method customizes it to meet specific needs.\n\nExample Of Method Overriding In Java\n\nNow that we've got some idea about the syntax of method overriding in Java, let’s look at an example that showcases how method overriding works in real code scenarios.\n\nIn the simple Java code example,\n• None The method uses println() method to display the string/ message– \"Inside Parent's display method\" when called.\n• None First, we use the annotation/ keyword @Override to indicate that this function must override another one.\n• None Then, we define the display() method, which prints the message– \"Inside Child's display method.\" when called on a Child object instead of the parent's version.\n• define the Main class , which serves as the entry point for executing our program. Inside, we create objects for both classes , i.e., Parent (parent) and Child (child), using the new operator\n• call the display() parent object , which invokes the method defined in the Parent class and prints the respective message.\n• call the display() child object , which invokes the overridden method in the Child class, printing the child-specific message.\n• demonstration of method overriding in Java , where the child class provides a specific implementation for a method that is already defined in the parent class.\n• polymorphism , for which we create a reference of type Parent but assign it an object of type Child\n• None This is allowed because Child is a subclass of Parent, meaning a Child object can be referred to by a Parent reference.\n• None Then, when we call the display() using the polymorphicRef reference , it might seem like the display() method of the Parent class should be called.\n• dynamic method dispatch , Java determines at runtime which method to call based on the actual object type, not the reference type. Since polymorphicRef points to an instance of Child, the overridden display() method in Child is called , and it prints the child's message.\n\nIdeal Use Cases Of Method Overriding In Java\n\nMethod overriding can be ideal in scenarios where we want to provide a specific implementation of a method in a subclass that is different from the implementation in the respective superclass. Following are some of the specific use cases where method overriding in Java can prove to be beneficial:\n• Implementing Runtime Polymorphism: Method overriding is a core mechanism behind runtime polymorphism in Java. It allows a subclass to provide its own implementation of a method that exists in its superclass. This makes it possible for objects of different types to respond to the same method call in different ways, depending on their actual type at runtime.\n• Customizing Behavior: Method overriding enables customization of behavior inherited from a superclass. If a subclass needs to alter or extend the functionality of an inherited method, it can simply override the method with a more specialized implementation suited to its requirements.\n• Enhancing Reusability : Method overriding in Java allows us to reuse the same method name and signature (from superclass) across subclasses. This promotes code reusability by allowing subclasses to retain the same method interface but customize the functionality, reducing code duplication.\n• Implementing Abstract Methods: If a class extends an abstract class or implements an interface, it must provide concrete implementations for all abstract methods defined in the superclass. Method overriding in Java helps implement these abstract methods, making the subclass a concrete class.\n• Enabling Dynamic Dispatch: With method overriding, Java achieves dynamic dispatch, where the JVM determines which method implementation to invoke based on the actual type of the object at runtime. This flexibility is essential in scenarios where you manipulate objects of different subclasses via a common superclass or interface reference.\n• Framework and Library Extensions: Method overriding in Java is commonly used in frameworks and libraries to extend or customize the behavior of existing classes without modifying their source code. By overriding methods in these predefined classes, we can create custom components or behaviors that fit the specific needs of our application.\n\nIn short, method overriding enables customization, extensibility, and polymorphism in Java applications, making the codebase more flexible, scalable, and easier to maintain.\n\nMethod overriding is essential for creating flexible, large-scale programs, enabling subclasses to modify inherited methods to meet specific needs. While the concept is crucial, it's also vital to understand the rules that govern how a subclass can override a method from its superclass.\n\nThese rules provide a structure for modifying inherited methods without breaking functionality, ensuring that your code remains adaptive and cohesive. Here are key rules you must note when working with method overriding in Java:\n\nWhen overriding a method, we cannot reduce the visibility of the method in the subclass. The order of access modifiers from most restrictive to least restrictive is:\n\nThis means you can increase the visibility (e.g., from protected to public) but not decrease it (e.g., from public to protected). We will discuss this in detail in a later section.\n\n2. Method Signature For Superclass & Subclass Must Be Same For Method Overriding In Java\n\nThe method signature (name, return type, and parameter list) in the subclass must be identical to the one in the superclass.\n\nWhen a subclass method overrides a parent method, it can throw unchecked exceptions (like RuntimeException), even if the parent method doesn’t throw any exceptions. However, it should not throw new checked exceptions (like IOException) or exceptions that are more general than those thrown by the parent method. The overriding method can throw fewer or more specific exceptions than the parent, which allows the subclass to limit the types of exceptions it throws compared to the parent.\n\nIn Java, constructors are not inherited by subclasses, so they cannot be overridden. Each class must define its own constructor, and while a subclass can call a superclass constructor using super(), it doesn’t override it.\n\n5. Final Methods Cannot Be Overridden In Java\n\nThe final keyword can be used to mark a method as final, meaning it cannot be overridden in any subclass. This ensures that the method’s implementation remains consistent across all subclasses.\n\nSuppose you have a superclass Shape with a final method calculateArea(), to calculate the area of the shape. Let’s see what happens when we try to override this method in a subclass.\n\nThe method calculateArea() in the Shape class is marked as final, which prevents any subclass from overriding it. Trying to override it in the Circle subclass results in a compilation error.\n\nStatic methods are resolved at compile time and are tied to the class, not the instance of the class. As a result, static methods cannot be overridden. If a subclass defines a static method with the same signature as a static method in its superclass, it's considered method hiding, not overriding.\n\nSay a superclass Animal has a static method eat() that represents a general eating behavior for all animals. We then have a subclass Dog that attempts to override eat() with a non-static method eat() to represent a specific eating behavior for dogs. The Java program example below highlights how this works.\n\nIn the example above, the Dog class tries to override the static method eat(), which is not allowed in Java. Static methods belong to the class itself and do not support polymorphism. The error message indicates that we can't override static methods with instance methods.\n\n7. Private Methods Can Not Be Overridden\n\nPrivate methods, that is, methods defined with the private access specifier, are not visible to subclasses. So, they cannot be overridden. If a subclass defines a method with the same signature as a private method in the superclass, it’s treated as a new, separate method, not an override. The simple Java program example below illustrates this concept.\n\nEven though Subclass has a method privateMethod() that has the same signature as the one in Superclass, it doesn't override it because private methods are inaccessible to subclasses. When calling callPrivateMethod(), the method from Superclass is executed, as private methods in Superclass are not overridden.\n\n8. The Overriding Method Must Have the Same Return Type (or Subtype)\n\nThe return data type of the overriding method in Java subclasses must be the same as, or a subtype of, the return type of the overridden method in the superclass. This feature, known as the covariant return type, was introduced in Java 5.0.\n\nIn this example, the method getAnimal() in Dog returns a Dog object, which is a subtype of Animal. This is a valid example of covariant return types, where the overriding method can have a more specific return type than the overridden method in the superclass.\n\nIn Java, the super keyword is used to refer to the superclass of the current object, allowing a subclass to access superclass members directly. This can include calling superclass methods ( despite overriding the same method), accessing superclass variables, and invoking superclass constructors.\n\nUse Cases Of super Keyword In Method Overriding In Java\n\nThe primary use cases of super keyword include the following three situations:\n\nWhen a subclass overrides a method, the super keyword can be used to call the overridden method from the parent class. This is particularly useful if you want to extend or modify the behavior of the parent method while still retaining access to its original functionality.\n\nIn the Java example code,\n• base class Parent method display() that simply prints the message– \"Parent class method\" to the console.\n• child class, Child that extends the Parent overrides the display()\n• None Inside this overriding method, we use the super keyword to call the display() method from Parent (via super.display()), the immediate parent class of Child.\n• Main class an instance of Child using the new operator with constructor and then use it to call the display()\n• None As a result, the display() method inside Child first invokes the display() method from the parent, printing the message– ‘Parent class method’.\n• None It then prints the message– ‘Child class method’ as this is part of the method’s own definition.\n\nThis demonstrates the use of the super keyword to invoke the method of the immediate parent class. In this case, it allows the Child class to call and augment the behavior of the Parent class method.\n\nThe super() keyword can also be used to call the parent class's constructor. This is particularly useful if the parent class does not have a no-argument constructor or if you want to ensure proper initialization of inherited members. If the parent class lacks a no-argument constructor and you don't explicitly call another constructor with super(), the code will not compile.\n\nIn the Java code example,\n• Child that extends the Parent class, which means it inherits from Parent.\n• None The Child class has its own constructor, Child(),\n• None We use the super() keyword to explicitly call the constructor of the immediate parent class (Parent class in this case).\n• None This is necessary if you want to explicitly call a specific constructor in the parent class (especially a parameterized one), as Java does not automatically call it if it’s not the default (no-argument) constructor.\n• None Without an explicit super() call, Java will only attempt to call the no-argument constructor in the parent class.\n• None After calling super(), the child class constructor continues its execution and prints \"Child class constructor\".\n• Main class instance of Child new operator with the Child()\n• triggers the constructor chain starting from the Parent class constructor and then the Child class constructor.\n• None The output demonstrates the use of the super keyword to invoke the immediate parent class constructor explicitly, ensuring proper initialization of the parent class before the child class constructor executes.\n\nAlthough not directly related to method overriding, super can also refer to variables in the parent class. This is handy when the subclass has a variable with the same name, and you want to clarify which one to use.\n\nAs discussed in the rules section above, constructors are special methods used to initialize new objects. They share the class name and don’t return any value, not even void. Constructors differ from other methods because they aren’t inherited and therefore cannot be overridden in subclasses.\n• None However, constructors in a parent class still play a role when creating a subclass object.\n• None When a subclass object is instantiated, Java ensures that a parent constructor is called first.\n• None This can be done either implicitly (via Java’s default constructor call if no specific constructor is defined) or explicitly using super() in the subclass constructor.\n• None If no constructor is defined in the subclass, Java automatically calls a no-argument constructor of the superclass using super(). If the superclass lacks a no-argument constructor, we must manually call one of its parameterized constructors using super().\n\nTo provide different constructors in a subclass, we can define constructors with various parameters and explicitly call specific superclass constructors. This approach ensures that we can initialize inherited members correctly, using the parent class’s initialization logic when necessary.\n\nIn Java, exception handling allows subclasses to either maintain, restrict, or expand the exceptions thrown by an overridden method from the superclass. This control is governed by rules that help ensure subclasses don't introduce unexpected checked exceptions. Let's break down how exceptions, particularly checked and unchecked, interact with method overriding in Java language.\n\nWhen a method in a superclass throws a checked exception (like IOException), any overriding method in a subclass must adhere to certain rules:\n• Same Exception: The subclass can throw the exact same checked exception.\n• Subclass Exception: The subclass can throw a more specific (subclass) checked exception.\n• No Exception or Broader Exception: Alternatively, the subclass can choose not to throw any checked exception or throw an unchecked exception instead.\n\nExample: Checked Exception Handling with Method Overriding in Java\n\nLet’s consider a scenario where we have a superclass FileProcessor with a processFile() method that reads files and may throw an IOException. In a subclass TextFileProcessor, we override processFile() to add specific behavior, such as verifying if the file is a text file, while handling potential file-related exceptions.\n\nIn the example Java code,\n• superclass FileProcessor method processFile() that takes a File object and reads its contents.\n• can throw an IOException , if needed. It includes error handling for FileNotFoundException to handle cases where the file is not found.\n• None In the overriding method, we first call the overridden method from superclass using the super() keyword\n• None We use an if-statement to add specific behavior by checking if the filename ends in the extension ‘.txt’. If it does not, we throw an IOException\n• Main class File object for ‘example.txt’ and an instance of TextFileProcessor\n• None Since the processFile() method in the superclass FileProcessor throws an IOException, the overriding method in TextFileProcessor must also declare that it throws IOException or a superclass of IOException, which is done using the throws IOException clause in its method signature.\n• None The output of the program (when ‘example.txt’ does not exist) demonstrates the error message ‘File not found: example.txt (No such file or directory)’ indicating that the FileNotFoundException was caught in the superclass method.\n\nThis is how if the example.txt file doesn’t exist or doesn’t match the expected format, an exception is thrown and handled, ensuring the program doesn’t crash unexpectedly. It demonstrates how the subclass respects the checked exception IOException and builds on it without introducing new exceptions outside what the superclass declared. This preserves compatibility with the superclass’s exception handling while extending functionality.\n\nThe Java language is much more lenient when it comes to unchecked exceptions in method overriding. These exceptions, which are subclasses of RuntimeException (such as IllegalArgumentException), don’t need to be declared or handled by the superclass. This allows the subclass to introduce or omit any unchecked exceptions in its overridden methods, giving it more flexibility for cases where runtime issues may arise.\n\nExample: Unchecked Exception Handling with Method Overriding in Java\n\nIn the Java example below, we modify processFile to throw an unchecked IllegalArgumentException if the file path is invalid.\n\nIn the example Java program,\n• superclass FileProcessor processFile() that validates the file path and throws an IllegalArgumentException if the path is null or empty.\n• None In the overriding method, we first call the superclass method using super to ensure the original validation for null or empty file paths is performed.\n• None It then uses an if-else statement to check if the file path ends with ‘.txt’ . If it does, then it prints a message indicating that the text file is being processed.\n• None If not, then it throws another IllegalArgumentException.\n• IllegalArgumentException is an unchecked exception , there are no restrictions on its use. The subclass can freely add checks without the need for the superclass to account for this exception, as it doesn't require a declaration in the method signature (because it’s unchecked).\n• None As shown in the output, since the file path is valid, the program prints a message indicating that the text file is being processed.\n\nThis approach allows TextFileProcessor to handle runtime-specific cases more flexibly while retaining the original method’s validation.\n\nAs mentioned in the rules section, one crucial point to remember when method overriding in Java is that we cannot reduce the visibility of the method in the subclass. That is, the access modifier of the method in the subclass must be equal to or more permissive than the access modifier of the method in the superclass.\n\nIn other words, we can increase the visibility (e.g., from protected to public), but we cannot decrease it (e.g., from public to protected). The hierarchy of access modifiers, from the most restrictive to the least restrictive, is as follows:\n\nThis rule ensures that subclasses don't inadvertently restrict access to functionality that is accessible in the parent class. Let's explore this with two examples—one demonstrating reduced visibility and another showing increased visibility with method overriding in Java.\n\nExample 1: Reducing Visibility (Not Allowed) In Method Overriding In Java\n\nConsider a superclass Animal with a method makeSound() declared as public. The subclass Dog tries to override makeSound() with a more restrictive access modifier, protected. This is not allowed in Java, as it violates the rule of reducing visibility.\n\nIn the Java example,\n• makeSound() in the Animal class is public , meaning it is accessible everywhere.\n• None In the Dog class, the method is overridden with protected visibility , which is less permissive than public. Java does not allow this because it would reduce the method's visibility from what was declared in the superclass.\n• results in a compilation error indicating that we are trying to assign weaker access privileges.\n\nExample 2: Increasing Visibility (Allowed) In Method Overriding In Java\n\nNow, let's consider increasing the visibility of the overridden method. In this example, we have a superclass Animal with a protected method makeSound(). The subclass Dog overrides this method with a public access modifier, which is allowed.\n\nIn the example,\n• makeSound() in the Animal class is protected , meaning it is accessible within the same package and by subclasses.\n• None In the Dog class, the method is overridden with public visibility , which is more permissive. This is allowed because the method in the subclass is more accessible than the method in the superclass.\n• None This results in the program running without errors , and the output is \"Dog barks\", demonstrating that the subclass method is invoked.\n\n​​Method overriding is a key feature in Java, enabling subclasses to provide their own implementation of a method inherited from a superclass. While this powerful feature offers several benefits, it also comes with its set of challenges.\n• Polymorphic Behavior: Method overriding enables polymorphism, allowing objects of different classes to be treated as objects of a common superclass. This promotes code reusability and enhances the flexibility of design by enabling dynamic method invocation based on the object type at runtime.\n• Enhanced Flexibility: Subclasses can customize inherited methods to meet their specific needs, offering greater control over functionality. This flexibility of method overriding in Java allows for specialization while still maintaining the foundation provided by the superclass.\n• Improved Readability and Maintainability: By overriding methods, subclasses focus only on their custom behavior without altering the superclass. This separation of concerns results in cleaner, more modular code, which is easier to read and maintain.\n• Code Reusability: With method overriding in Java, subclasses can reuse the superclass method's structure, reducing the need to duplicate code. This increases efficiency and ensures consistency, making the codebase easier to maintain.\n• Run-Time Polymorphism: Method overriding is resolved at runtime based on the actual type of the object, enabling dynamic method dispatch. This allows Java to choose the appropriate method to call based on the object that invokes the method, making the application more flexible.\n\nWhile method overriding offers many benefits, it also has some limitations and challenges that we should be aware of.\n• Complexity and Overhead: While method overriding brings flexibility, it can also introduce complexity, especially in large class hierarchies. This is because managing interactions between superclass and subclass methods requires careful planning to avoid unexpected behavior or bugs.\n• Fragility: Changes to the superclass method (e.g., modifying the method signature or behavior) can inadvertently affect the behavior of overridden methods in subclasses. This can lead to fragile code where a small change in the superclass has far-reaching consequences on the subclasses.\n• Potential for Misuse: When used incorrectly, method overriding in Java programs can violate the principle of encapsulation, leading to hard-to-understand and poorly maintained code. Overriding methods unnecessarily or inappropriately can confuse developers and make the codebase harder to manage.\n• Performance Impact: The use of dynamic method dispatch in method overriding introduces a slight performance overhead compared to static method invocation. While this impact is usually minimal and typically not noticeable in most applications, it can be a concern in performance-sensitive scenarios.\n• Limitations in Constructors: Constructors cannot be overridden in Java, limiting the flexibility of subclass initialization logic. While constructors can be overloaded, they cannot be overridden like regular methods, which can be a constraint in some cases.\n\nDifference Between Method Overloading Vs. Method Overriding In Java\n\nMethod overloading and method overriding are two important concepts in Java that involve the declaration and use of methods. While both concepts involve redefining methods, they are used in different contexts and have distinct characteristics. The table below highlights the difference between method overloading and method\n\nMethod overriding in Java is a powerful feature that allows subclasses to provide their own implementation of methods inherited from the superclass. This ability to override methods makes code more adaptable, as it tailors inherited behaviors to meet specific needs.\n• None In this article, we covered the essential rules governing method overriding, such as the importance of method signatures, the role of access modifiers, and the use of the super keyword.\n• None We also explored the unique case of constructors, which cannot be overridden, and delved into the relationship between method overriding and exception handling.\n• None Specifically, we discussed the importance of preserving exception hierarchies when overriding methods that throw checked exceptions.\n\nUltimately, method overriding empowers developers to create new behaviors in subclasses while maintaining compatibility with their parent class. By enhancing code flexibility and simplifying maintenance, method overriding is an invaluable tool in a Java developer's toolkit.\n\nQ. How does method overriding in Java relate to the Liskov Substitution Principle (LSP)?\n\nMethod overriding is closely tied to the Liskov Substitution Principle (LSP), which is one of the five SOLID principles of object-oriented design. The LSP states that objects of a superclass should be replaceable with objects of its subclasses without affecting the correctness of the program. In other words, a subclass should be able to substitute for its superclass without changing the behavior expected by the client code.\n• None Method overriding ensures compliance with LSP by allowing subclasses to provide specific implementations of superclass methods while maintaining the same interface.\n• None A subclass must adhere to the expected behavior of the superclass’s method, ensuring that client code remains unaffected when a subclass instance replaces a superclass instance.\n\nQ. Can a subclass declare a method to throw a checked exception that the superclass method doesn't declare?\n\nNo, a subclass cannot declare a method to throw a checked exception that isn’t declared by the superclass method it overrides.\n\nThis rule ensures consistency with the superclass's contract, preventing subclasses from introducing new exceptions that the superclass does not handle. The compiler enforces this, ensuring that any exception handling remains predictable and adheres to the superclass’s specifications.\n\nQ. What is dynamic method dispatch? How is it related to method overriding in Java?\n\nDynamic method dispatch is a mechanism in Java that determines which method to invoke at runtime based on the actual type of the object, not the reference type. This mechanism is a core feature of polymorphism (object-oriented programming) and is directly related to method overriding in Java programming.\n• None When a subclass overrides a method, dynamic dispatch ensures that the correct version of the method is called at runtime based on the object's type.\n• None This allows subclasses to provide specialized behavior for inherited methods and have the correct implementation called based on the type of the object.\n\nThis is how dynamic method dispatch is achieved through method overriding in Java.\n\nQ. What is the role of the @Override annotation in method overriding in Java? When should it be used?\n\nThe @Override annotation indicates that a method is overriding a method from its superclass.\n• None While optional, it is a best practice to use it because it helps the compiler check for errors, such as mismatched method signatures.\n• None If the method signature does not match a method in the superclass, the compiler will generate an error.\n• None Using @Override also improves code readability, making it clear to other developers that the method is meant to override a superclass method, thereby improving maintainability and reducing potential bugs.\n\nQ. Can a subclass define an overloaded method that is also a valid override of a superclass method?\n\nYes, a subclass can define an overloaded method that also overrides a superclass method. Method overloading and method overriding are independent concepts in Java, so it is possible for a subclass to overload a method with the same name but different parameter lists, while still overriding the original method. Let’s understand it through the following example:\n\n\n\nHere, we have a class Animal with a method named makeSound(), which is both overloaded and overridden in the child class Dog. The overloaded method expects an argument of String type, and the overridden method re-implements the logic according to the dog class.\n\nQ. Explain the concept of method hiding in Java. How does it differ from method overriding?\n\nMethod hiding occurs when a subclass defines a static method with the same signature as a static method in the superclass. Unlike method overriding, which happens at runtime with instance methods, method hiding involves static methods and is determined at compile-time.\n\nThe table below highlights the difference between method hiding and method overriding in Java.\n\nQ. Can a subclass call the overridden method from within the overriding method?\n\nYes, a subclass can call the overridden method from the subclass using the super keyword. This allows the subclass to augment or extend the functionality of the method in the superclass rather than completely replacing it.\n\nFor example, a subclass can call the superclass method within its own overridden method, allowing additional behavior to be added without losing the original method's functionality.\n\nIn this example, the Child class overrides the display() method from the Parent class. Inside this method, we use the super keyword to call the display() method of the Parent class before executing the additional logic in the Child class's display() method. As shown in the output, when we call the display() method from the Child class, it successfully invokes the called method and the overridden method from the superclass.\n\nThis compiles our discussion on method overriding in Java. Here are a few more topics you must explore:\n• None Difference Between Java And JavaScript Explained In Detail\n• None Top 15+ Difference Between C++ And Java Explained! (+Similarities)\n• None 90+ Java Collections Interview Questions (+Answers) You Must Know"
    },
    {
        "link": "https://geeksforgeeks.org/exception-handling-with-method-overriding-in-java",
        "document": "An Exception is an unwanted or unexpected event that occurs during a program’s execution, i.e., at runtime and disrupts the normal flow of the program’s instructions. Exception handling in Java handles runtime errors and helps maintain the program’s normal flow.\n\nIn any object-oriented programming, method overriding allows a subclass to redefine a method from its superclass. With exception handling, the subclass can:\n• None The subclass can throw the same or smaller exceptions.\n• None It can choose not to throw any exceptions.\n• None It cannot throw new checked exceptions not in the parent method.\n\nExplanation: In this example, the SuperClass method does not declare any exceptions. The SubClass method overrides the method() and declares an unchecked exception i.e. the ArithmeticException. The main method demonstrates how the exception is thrown and caught in the SubClass.\n\nWhen Exception handling is involved with Method overriding, ambiguity occurs. The compiler gets confused as to which definition is to be followed.\n\nThere are two types of problems associated with it which are as follows:\n• Problem 1 If The SuperClass does not declare an exception\n• Problem 2 : If The SuperClass declares an exception\n\nLet us discuss different cases under these problems and perceived their outputs.\n\nIn this problem, two cases that will arise are as follows:\n\nCase 1: If SuperClass doesn’t declare any exception and subclass declare checked exception.\n\nCase 2: If SuperClass doesn’t declare any exception and SubClass declare Unchecked exception.\n\nIf the SuperClass declares an exception. In this problem 3 cases will arise as follows:\n\nCase 1: If SuperClass declares an exception and SubClass declares exceptions other than the child exception of the SuperClass declared Exception.\n\nCase 2: If SuperClass declares an exception and SubClass declares a child exception of the SuperClass declared Exception.\n\n\n\nCase 3: If SuperClass declares an exception and SubClass declares without exception.\n• Case 1 : The subclass cannot declare an exception unrelated to the superclass exception.\n• Case 2 : The subclass can declare a child exception of the superclass exception.\n• Case 3 : The subclass can choose to declare no exception."
    },
    {
        "link": "https://amorserv.com/insights/game-development-with-java-a-comprehensive-guide",
        "document": ""
    },
    {
        "link": "https://stackabuse.com/object-oriented-design-principles-in-java",
        "document": "Design principles are generalized pieces of advice or proven good coding practices that are used as rules of thumb when making design choices.\n\nThey're a similar concept to design patterns, the main difference being that design principles are more abstract and generalized. They are high-level pieces of advice, often applicable to many different programming languages or even different paradigms.\n\nDesign patterns are also abstractions or generalized good practices, but they provide much more concrete and practical low-level advice, and are related to entire classes of problems rather than just generalized coding practices.\n\nSome of the most important design principles in the object oriented paradigm are listed in this article, but this is by no means an exhaustive list.\n• Keep It Simple and Stupid (KISS) Principle\n\nThe SRP, LSP, Open/Closed, and DIP principles are often bundled together and called SOLID principles.\n\nThe Don't Repeat Yourself (DRY) principle is a common principle across programming paradigms, but it is especially important in OOP. According to the principle:\n\nWhen it comes to OOP, this means utilizing abstract classes, interfaces, and public constants. Whenever there's a functionality common across classes, it either might make sense to abstract them away into a common parent class or use interfaces to couple their functionality:\n\nBoth a and a need to eat food, but they speak differently. Since eating food is a common functionality for them, we can abstract it into a parent class such as and then have them extend the class.\n\nNow, instead of both classes implementing the same functionality of eating food, each can focus on their own unique logic.\n\nThe output would be:\n\nWhenever there's a constant that's used multiple times, it's good practice to define it as a public constant:\n\nFor example, we'll be using these constants several times, and eventually we'll be changing their values manually to optimize a genetic algorithm. It would be easy to make a mistake if we had to update each of these values at multiple places.\n\nAlso, we don't want to make a mistake and programmatically change these values during execution, so we're also introducing the modifier.\n\nNote: Due to the naming convention in Java, these should be capitalized with words separated by an underscore (\"_\").\n\nThe purpose of this principle is to ensure easy maintenance of code, because when a functionality or a constant changes you have to edit the code only in one place. This not only makes the job easier, but ensures that mistakes won't happen in the future. You may forget to edit the code in multiple places, or somebody else who's not as familiar with your project may not know that you've repeated code and may end up editing it in just one place.\n\nHowever, it's important to apply common sense when using this principle. If you use the same piece of code to do two different things initially, that doesn't mean those two things will always need to be dealt with in the same way.\n\nThis usually happens if structures are actually dissimilar, despite the same code being used to handle them. The code can also be 'over-dried', making it essentially unreadable because methods are called from unrelated, incomprehensible places.\n\nA good architecture can amortize this, but the problem can crop up in practice nonetheless.\n\nViolations of the DRY Principle are often referred to as WET solutions. WET can be an abbreviation for multiple things:\n\nWET solutions aren't always bad, as repetition is sometimes advisable in inherently dissimilar classes, or in order to make code more readable, less inter-dependent, etc.\n\nKeep It Simple and Stupid (KISS) Principle\n\nThe Keep it Simple and Stupid (KISS) principle is a reminder to keep your code simple and readable for humans. If your method handles multiple use-cases, split them into smaller functions. If it performs multiple functionalities, make multiple methods instead.\n\nThe core of this principle is that for most cases, unless efficiency is extremely crucial, another stack call isn't going to severely affect the performance of your program. In fact, some compilers or runtime environments will even simplify a method call into an inline execution.\n\nOn the other hand, unreadable and long methods will be very hard to maintain for human programmers, bugs will be harder to find, and you might find yourself violating DRY as well because if a function does two things, you can't call it to do just one of them, so you'll make another method.\n\nAll in all, if you find yourself tangled up in your own code and unsure what each part does, it's time for reevaluation.\n\nIt's almost certain that the design could be tweaked to make it more readable. And if you are having trouble as the one who designed it while it's all still fresh in your mind, think about how somebody who sees it for the first time in the future will perform.\n\nThe Single Responsibility Principle (SRP) states that there should never be two functionalities in one class. Sometimes, it's paraphrased as:\n\nWhere a \"reason to be changed\" is the responsibility of the class. If there is more than one responsibility, there are more reasons to change that class at some point.\n\nThis means that in the event of a functionality needing an update, there shouldn't be multiple separate functionalities in that same class that may be affected.\n\nThis principle makes it easier to deal with bugs, to implement changes without confusing co-dependencies, and to inherit from a class without having to implement or inherit methods your class doesn't need.\n\nWhile it may seem that this encourages you to rely on dependencies a lot, this sort of modularity is much more important. Some level of dependency between classes is inevitable, which is why we also have principles and patterns to deal with that.\n\nFor example, say our application should retrieve some product information from the database, then process it and finally display it to the end-user.\n\nWe could use a single class to handle the database call, process the information and push the information to the presentation layer. Though, bundling these functionalities makes our code unreadable and illogical.\n\nWhat we'd do instead is define a class, such as that would fetch the product from the database, a to process the info and then we'd display it in a presentation layer - either an HTML page or another class/GUI.\n\nThe Open/Closed principle states that classes or objects and methods should be open for extension, but closed for modifications.\n\nWhat this means in essence is that you should design your classes and modules with possible future updates in mind, so they should have a generic design that you won't need to change the class itself in order to extend their behavior.\n\nYou can add more fields or methods, but in such a way that you don't need to rewrite old methods, delete old fields and modify the old code in order to make it work again. Thinking ahead will help you write stable code, before and after an update of requirements.\n\nThis principle is important in order to ensure backwards compatibility and prevent regressions - a bug which happens when your programs features or efficiency breaks after an update.\n\nAccording to the Liskov Substitution Principle (LSP), derived classes should be able to substitute their base classes without the behavior of your code changing.\n\nThis principle is closely related to The Interface Segregation Principle and The Single Responsibility Principle, meaning that a violation of either of those is likely to be (or become) a violation of LSP as well. This is because if a class does more than one thing, subclasses extending it are less likely to meaningfully implement those two or more functionalities.\n\nA common way people think about object relationships (which can be a bit misleading at times) is that there needs to be an is relationship between classes.\n\nIt's important to note that these relationships don't go in both directions. The fact that is a might not mean that is a - it can be a , , ...\n\nThe reason this can be misleading is a common mistake people make when thinking about it in natural language. For example, if I asked you if has an \"is relationship\" with , you might automatically say yes.\n\nAfter all, we know from geometry that a square is a special case of a rectangle. But depending on how your structures are implemented, this might not be the case:\n\nNow let's try inheriting from it for our within the same package:\n\nYou'll notice that setters here actually set both and . Some of you may already guess the problem. Let's say we initialized our and applied polymorphism to contain it within a variable:\n\nAnd let's say that sometime later in the program, maybe in an entirely separate function, another programmer who had nothing to do with implementing these classes, decides that they want to resize their rectangle. They may try something like this:\n\nThey'll get completely unexpected behavior and it might be difficult to trace back what the problem is.\n\nIf they try to use the result won't be as they might expect from a rectangle with sides of lengths and .\n\nThe result would instead be because their rectangle is actually a square and has two equal sides - of length .\n\nYou may say that this is exactly the behavior you wanted because that's how a square works, but it's nonetheless not the expected behavior from a rectangle.\n\nSo when we're inheriting we have to keep in mind the behavior of our classes and are they really functionally interchangeable within the code, rather than just the concepts being similar outside of the context of their usage in the program.\n\nThe Interface Segregation Principle (ISP) states that the client should never be forced to depend on an interface they aren't using in its entirety. This means that an interface should have a minimum set of methods necessary for the functionality it ensures, and should be limited to only one functionality.\n\nFor example, a interface shouldn't be required to implement an method, because this doesn't have to be available for every type of pizza. For the sake of this tutorial, let's assume that all pizzas have a sauce and need to be baked and there's not a single exception.\n\nThis is when we can define an interface:\n\nAnd then, let's implement this through a couple of classes:\n\nThe has mushrooms whereas the has pepperoni. Both, of course, need sauce and need to be baked, which is also defined in the interface.\n\nIf the or methods were located in the interface, both classes would have to implement them even though they don't need both, but rather only one each.\n\nWe should strip interfaces of all but absolutely necessary functionalities.\n\nAccording to the Dependency Inversion Principle (DIP), high-level and low-level modules should be decoupled in such a way that changing (or even replacing) low-level modules doesn't require (much) rework of high-level modules. Given that, both low-level and high-level modules shouldn't depend on each other, but rather they should depend on abstractions, such as interfaces.\n\nThis principle is important because it decouples modules, making the system less complex, easier to maintain and update, easier to test, and more reusable. I can't stress enough how much of a game changer this is, especially for unit testing and reusability. If the code is written generically enough, it can easily find application in another project, while code that's too specific and interdependent with other modules of the original project will be hard to decouple from it.\n\nThis principle is closely related to the dependency injection, which is practically the implementation or rather, the goal of DIP. DI boils down to - if two classes are dependent, their features should be abstracted away and they should both depend on the abstraction, instead of on each other. This essentially should allow us to change details of the implementation while retaining its functionality.\n\nThe Dependency Inversion Principle and Inversion of Control (IoC) are used interchangeably by some people, although it is not technically true.\n\nDependency Inversion guides us towards decoupling by using dependency injection through an Inversion of Control Container. Another name of IoC Containers could very well be Dependency Injection Containers, though the old name sticks around.\n\nOne should often prefer composition over inheritance when designing their systems. In Java, this means that we should more often define interfaces and implement them, rather than defining classes and extending them.\n\nWe've already mentioned the is a as a common guiding principle people use to determine whether classes should inherit one another or not.\n\nDespite being tricky to think about and tending to violate The Liskov Substitution Principle, this way of thinking is extremely problematic when it comes to reusing and repurposing code later in development.\n\nThe problem here is illustrated by the following example:\n\nand extend an abstract class , while and extend . Each has their respective methods which make sense for the type of vehicle, and we'd naturally group them together with abstraction when thinking of them in these terms.\n\nThis inheritance structure is based on thinking about objects in terms of what they are instead of what they do.\n\nThe problem with this is that new requirements can throw the whole hierarchy off balance. In this example, what if your boss waltzed in and informed you that a client wants a flying car now? If you inherit from , you'll have to implement again even though that same functionality already exists, thereby violating the DRY Principle, and vice-versa:\n\nSince most languages, including Java, don't allow multiple inheritance, we can opt to extend either one of these classes. Though, in both cases, we can't inherit the functionality of the other and have to rewrite it.\n\nYou may figure out a way to change the whole architecture to fit around this new class, but depending on how deep in the development you are, that can be a costly process.\n\nGiven this problem, we could try and avoid this whole mess by basing our generalities on common functionality instead of inherent similarity. This is the way a lot of built-in Java mechanisms have been developed.\n\nWe use , , etc. instead of using some abstract classes implementing their methods because it's cleaner, it makes code more reusable, and it makes it easy to create a new class that conforms to what we need in order to use previously made functionalities.\n\nThis also resolves the problem of dependencies destroying important functionalities and causing a chain reaction throughout our code. Instead of having a big problem when we need to make our code work for a new type of thing, we can simply make that new thing conform to previously set standards and work just as well as the old thing.\n\nIn our vehicle example, we could just implement interfaces and instead of introducing abstraction and inheritance.\n\nOur and could implement , our and could implement , and our new could implement both.\n\nNo changes in the class structure needed, no major DRY violations, no confusion of colleagues. If you happen to need exact same functionality in multiple classes, you can implement it using a default method in your interface, to avoid violating DRY.\n\nDesign principles are an important part of a developer's toolkit, and making more conscious choices when designing your software is going to help you nail down the nuances of careful, future-proof, design.\n\nMost developers truly learn these through experience rather than theory, but theory can help by giving you a new point of view and orient you towards more thoughtful design habits, especially on that interview in that company that built their whole systems on these principles."
    },
    {
        "link": "https://reddit.com/r/gamedev/comments/16lphg/trying_to_structure_a_simple_game_using_proper",
        "document": "Edit: I appreciate all of the advice here. I haven't been able to comment on each reply, but I have been reading on my breaks at work. I may be replying to some of you for some clarification if and when I get some friggin time! Thanks again!\n\nFairly beginner here, haven't finished a simple game yet. I'm working in XNA, but it's very much a generic game programming (or even just straight programming) question, I think. For reference, I have learned enough to recreate the first few levels of Chip's Challenge and a simple level editor to craft those levels.\n\nBut the code was messy, unorganized, probably very inefficient, and I know that I broke many OOP rules in the process. I'm trying to learn to program simple games using proper OOP guidelines and standards.\n\nI'll try to make this specific problem as simple as possible. I'm trying to code a simple Roguelike engine using graphical tiles. This means a turn-based overhead game with no animation. Very simple.\n\nSo I have a World class that has a Player object, an Enemy object, and an integer array (currently, 0 = no obstacle, 1 = obstacle) in it. The issue is that I'm not sure how I should program the objects to interact with each other.\n\nAs I was programming movement in a member function in the Player class, I realized that if I was going to check for collision with obstacles in this class, I'd have to pass the array though it as a parameter. So I did that. Then I realized if I wanted my player to interact with the enemy when they collided, I'd need to pass the enemy through as well. And then every other potential interactive object. Surely, passing all possibly interactive objects through the player's movement member function can't be optimal code...\n\nSo I pull the collision code out of the player's movement method and put it up a level in the World's update method. I'm using the player's movement method just to change its coordinates, and the World.Update method is getting messy fast. Very very basically, it's like this:\n\nAnd I'll need to move the enemy, detect for collision, and react to the collision all in this Update class too.\n\nBut this doesn't seem right either, since moving the enemies will involve picking a direction in which to move, which sounds like AI, which definitely sounds like it should be coded within the enemy class. Now I'm back to square 1 - how am I supposed to code AI inside of the enemy class without passing literally every other thing in the game through as parameters? The enemy should decide where to move based on the player's position, the surrounding enemies, the environment, obstacles, etc., and I just can't believe that all of this should be passed as parameters through an \"enemy.Movement\" function.\n\nHopefully I haven't made this simple conundrum too convoluted. The TL;DR is that I don't understand how to make two objects interact with one another without passing one through the other's methods, or putting tons of object-interacting-with-object code outside of the object. Any help will be appreciated, be it in the form of a simple explanation, a link to some simple reading that might answer this question, or a (hopefully somewhat simple) tutorial/example code in XNA, generic C#, or even C++ (been a while since I've C++ed)."
    },
    {
        "link": "https://medium.com/@greekykhs/object-oriented-design-principles-in-java-3f9ad50c4722",
        "document": "The Object-Oriented Design Principles are the core of Object Oriented Programming, with their help we can create a clean and modular design, which would be easy to test, debug, and maintain.\n\nWe can say the design principles are generalized pieces of advice or proven good coding practices that can be used as rules of thumb while making design choices.\n\nWhat is the difference between a design patterns and design principle?\n\nDesign principles are more abstract and generalized. They are high-level pieces of advice, which are often applicable to many different programming languages or even different paradigms.\n\nDesign patterns are also abstract and generalized, but they provide much more concrete and practical low-level advice, and are related to entire classes of problems rather than just generalized coding practices.\n\nName some of the important design principles in the object oriented paradigm.\n• Keep It Simple and Stupid (KISS) Principle\n\nThe SRP, LSP, Open/Closed, and DIP principles are often bundled together and called SOLID principles.\n\nWhat is SOLID principle in Java? Or What is open closed design principle in Java?\n\n1). Single Responsibility Principle : One class should have one and only one responsibility. We should write, change and maintain a class for only one purpose.\n\n2). Open Closed Principle : Software components should be open for extension, but closed for modification. It means that your classes should be designed in such a way that whenever fellow developers wants to change the flow of control in specific conditions in application, all they need to extend your class and override some functions and that’s it. If other developers are not able to design desired behavior due to constraints put by your class, then you should reconsider changing your class.\n\n3). Liskov’s Substitution Principle : Derived types must be completely substitutable for their base types. It means that the classes fellow developer created by extending your class should be able to fit in application without failure. i.e. if a fellow developer poorly extended some part of your class and injected into framework/ application then it should not break the application or should not throw fatal exceptions.\n\n4). Interface Segregation Principle : It is applicable to interfaces as single responsibility principle holds to classes. Clients should not be forced to implement unnecessary methods which they will not use. e.g: If you created an interface Reportable and added two methods generateExcel() and generatedPdf(). Now another developer wants to use this interface but he intend to use reports only in PDF format and not in excel. He will have to implement two methods, out of which one is extra burden put on him by designer of software. Either he will implement another method or leave it blank. Which is wrong. Instead of one interface, we should create two interfaces by breaking the existing one. They should be like PdfReportable and ExcelReportable. This will give the flexibility to user to use only required functionality only.\n\n5). Dependency Inversion Principle : Depend on abstractions, not on concretions. We should design our software in such a way that various modules can be separated from each other using an abstract layer to bind them together.\n• As the name suggests it means don’t write duplicate code, instead use Abstraction to abstract common things in one place.\n• Every piece of knowledge or logic must have a single, unambiguous representation within a system. If you have a block of code in more than two places, consider making it a separate method.\n• Duplication is not for code, but for functionality also.\n• In case of OOP, we should use abstract classes, interfaces, and public constants. Whenever there’s a functionality common across classes, it either might make sense to abstract them away into a common parent class or use interfaces to couple their functionality.\n• Whenever there’s a constant that’s used multiple times, it’s good practice to define it as a public constant. Due to the naming convention in Java, ‘public constant should be capitalized with words separated by an underscore and must be ‘final’.\n\nViolations of the DRY Principle are often referred to as WET solutions. WET can be an abbreviation for multiple things: We Enjoy Typing, Waste Everyone’s Time, Write Every Time, Write Everything Twice etc.\n\nWell, WET solutions aren’t always bad, as repetition is sometimes advisable in inherently dissimilar classes, or in order to make code more readable, less inter-dependent, etc.\n\nKeep It Simple and Stupid (KISS) Principle\n• KISS design principle says that that most software, program works well if they are made simple rather than complex.\n• It’s a reminder to keep your code simple and readable for humans. Unreadable and long methods are very hard to maintain, bugs will be harder to find.\n• If your method handles multiple use-cases, split them into smaller functions rather writing a method of 3000 lines.\n• If a method performs multiple functionalities, make multiple methods instead for each functionality.\n• We should often prefer composition over inheritance when designing their systems.\n• Inheritance and composition relationships are also referred as IS-A and HAS-A relationships.\n• In Java, we should more often define interfaces and implement them, rather than defining classes and extending them.\n• In composition, a class, which desire to use functionality of an existing class, doesn’t inherit, instead it holds a reference of that class in a member variable.\n• In Inheritance, an instance of sub class can be passed to a method, which accepts instance of super class.\n• A super class reference variable can refer to an instance of sub class. By using composition, you don’t get this behavior, but still it offers a lot more to tilde the balance in its side.\n\nReasons to prefer Composition over Inheritance in Java?\n\n1). Java doesn’t support multiple inheritance. If you need multiple functionality like e.g. for reading and writing character data into file, we need Reader and Writer functionality and having them as private members will make our job easy. We can use interface and provide different Reader and Writer implementation at different situation. But we won’t get this flexibility by using Inheritance, because in case of extending a class, we only get facilities which are available at compile time.\n\n2). Better test-ability is offered by Composition, we can easily Mock Object representing composed class for sake of testing. Inheritance doesn’t provide this facility. In order to test derived class, we must need its super class.\n\n3). Composition provides flexibility, we can easily replace implementation of Composed class with better and improved version.\n\nDid you know you could give up to 50 claps?\n\nYes, 50 claps, isn’t it awesome. If you feel my posts are interesting or helpful to you, please do press the 👏 clap button and share/ follow, help others find this story too.\n\nI’d appreciate if you’d buy me a coffee☕"
    },
    {
        "link": "https://gamedev.net/tutorials/programming/general-and-gameplay-programming/the-faster-you-unlearn-oop-the-better-for-you-and-your-software-r5026",
        "document": "Maybe it's just my experience, but Object-Oriented Programming seems like a default, most common paradigm of software engineering. The one typically thought to students, featured in online material and for some reason, spontaneously applied even by people that didn't intend it.\n\nI know how succumbing it is, and how great of an idea it seems on the surface. It took me years to break its spell, and understand clearly how horrible it is and why. Because of this perspective, I have a strong belief that it's important that people understand what is wrong with OOP, and what they should do instead.\n\nMany people discussed problems with OOP before, and I will provide a list of my favorite articles and videos at the end of this post. Before that, I'd like to give it my own take.\n\nData is more important than code\n\nAt its core, all software is about manipulating data to achieve a certain goal. The goal determines how the data should be structured, and the structure of the data determines what code is necessary.\n\nThis part is very important, so I will repeat.\n\nOne must never change the order here! When designing a piece of software, always start with figuring out what do you want to achieve, then at least roughly think about data architecture: data structures and infrastructure you need to efficiently achieve it. Only then write your code to work in such architecture. If with time the goal changes, alter the architecture, then change your code.\n\nIn my experience, the biggest problem with OOP is that encourages ignoring the data model architecture and applying a mindless pattern of storing everything in objects, promising some vague benefits. If it looks like a candidate for a class, it goes into a class. Do I have a Customer? It goes into class Customer. Do I have a rendering context? It goes into class RenderingContext.\n\nInstead of building a good data architecture, the developer attention is moved toward inventing “good” classes, relations between them, taxonomies, inheritance hierarchies and so on. Not only is this a useless effort. It's actually deeply harmful.\n\nWhen explicitly designing a data architecture, the result is typically a minimum viable set of data structures that support the goal of our software. When thinking in terms of abstract classes and objects there is no upper bound to how grandiose and complex can our abstractions be. Just look at FizzBuzz Enterprise Edition – the reason why such a simple problem can be implemented in so many lines of code, is because in OOP there's always a room for more abstractions.\n\nOOP apologists will respond that it's a matter of developer skill, to keep abstractions in check. Maybe. But in practice, OOP programs tend to only grow and never shrink because OOP encourages it.\n\nBecause OOP requires scattering everything across many, many tiny encapsulated objects, the number of references to these objects explodes as well. OOP requires passing long lists of arguments everywhere or holding references to related objects directly to shortcut it.\n\nYour class Customer has a reference to class Order and vice versa. class OrderManager holds references to all Orders, and thus indirectly to Customer's. Everything tends to point to everything else because as time passes, there are more and more places in the code that require referring to a related object.\n\nInstead of a well-designed data store, OOP projects tend to look like a huge spaghetti graph of objects pointing at each other and methods taking long argument lists. When you start to design Context objects just to cut on the number of arguments passed around, you know you're writing real OOP Enterprise-level software.\n\nThe vast majority of essential code is not operating on just one object – it is actually implementing cross-cutting concerns. Example: when class Player hits() a class Monster, where exactly do we modify data? Monster's hp has to decrease by Player's attackPower, Player's xps increase by Monster's level if Monster got killed. Does it happen in Player.hits(Monster m) or Monster.isHitBy(Player p). What if there's a class Weapon involved? Do we pass it as an argument to isHitBy or does Player has a currentWeapon() getter?\n\nThis oversimplified example with just 3 interacting classes is already becoming a typical OOP nightmare. A simple data transformation becomes a bunch of awkward, intertwined methods that call each other for no reason other than OOP dogma of encapsulation. Adding a bit of inheritance to the mix gets us a nice example of what stereotypical “Enterprise” software is about.\n\nLet's look at the definition of Encapsulation:\n\nThe sentiment is good, but in practice, encapsulation on a granularity of an object or a class often leads to code trying to separate everything from everything else (from itself). It generates tons of boilerplate: getters, setters, multiple constructors, odd methods, all trying to protect from mistakes that are unlikely to happen, on a scale too small to mater. The metaphor that I give is putting a padlock on your left pocket, to make sure your right hand can't take anything from it.\n\nDon't get me wrong – enforcing constraints, especially on ADTs is usually a great idea. But in OOP with all the inter-referencing of objects, encapsulation often doesn't achieve anything useful, and it's hard to address the constraints spanning across many classes.\n\nIn my opinion classes and objects are just too granular, and the right place to focus on the isolation, APIs etc. are “modules”/“components”/“libraries” boundaries. And in my experience, OOP (Java/Scala) codebases are usually the ones in which no modules/libraries are employed. Developers focus on putting boundaries around each class, without much thought which groups of classes form together a standalone, reusable, consistent logical unit.\n\nThere are multiple ways to look at the same data\n\nOOP requires an inflexible data organization: splitting it into many logical objects, which defines a data architecture: graph of objects with associated behavior (methods). However, it's often useful to have multiple ways of logically expressing data manipulations.\n\nIf program data is stored e.g. in a tabular, data-oriented form, it's possible to have two or more modules each operating on the same data structure, but in a different way. If the data is split into objects with methods it's no longer possible.\n\nThat's also the main reason for Object-relational impedance mismatch. While relational data architecture might not always be the best one, it is typically flexible enough to be able to operate on the data in many different ways, using different paradigms. However, the rigidness of OOP data organization causes incompatibility with any other data architecture.\n\nCombination of data scattered between many small objects, heavy use of indirection and pointers and lack of right data architecture in the first place leads to poor runtime performance. Nuff said.\n\nWhat to do instead?\n\nI don't think there's a silver bullet, so I'm going to just describe how it tends to work in my code nowadays.\n\nFirst, the data-consideration goes first. I analyze what is going to be the input and the outputs, their format, volume. How should the data be stored at runtime, and how persisted: what operations will have to be supported, how fast (throughput, latencies) etc.\n\nTypically the design is something close to a database for the data that has any significant volume. That is: there will be some object like a DataStore with an API exposing all the necessary operations for querying and storing the data. The data itself will be in form of an ADT/PoD structures, and any references between the data records will be of a form of an ID (number, uuid, or a deterministic hash). Under the hood, it typically closely resembles or actually is backed by a relational database: Vectors or HashMaps storing bulk of the data by Index or ID, some other ones for “indices” that are required for fast lookup and so on. Other data structures like LRU caches etc. are also placed there.\n\nThe bulk of actual program logic takes a reference to such DataStores, and performs the necessary operations on them. For concurrency and multi-threading, I typically glue different logical components via message passing, actor-style. Example of an actor: stdin reader, input data processor, trust manager, game state, etc. Such “actors” can be implemented as thread-pools, elements of pipelines etc. When required, they can have their own DataStore or share one with other “actors”.\n\nSuch architecture gives me nice testing points: DataStores can have multiple implementations via polymorphism, and actors communicating via messages can be instantiated separately and driven through test sequence of messages.\n\nThe main point is: just because my software operates in a domain with concepts of eg. Customers and Orders, doesn't mean there is any Customer class, with methods associated with it. Quite the opposite: the Customer concept is just a bunch of data in a tabular form in one or more DataStores, and “business logic” code manipulates the data directly.\n\nAs many things in software engineering critique of OOP is not a simple matter. I might have failed at clearly articulating my views and/or convincing you. If you're still interested, here are some links for you:\n• Two videos by Brian Will where he makes plenty of great points against OOP: Object-Oriented Programming is Bad and Object-Oriented Programming is Garbage: 3800 SLOC example\n• CppCon 2018: Stoyan Nikolov “OOP Is Dead, Long Live Data-oriented Design” where the author beautifully goes through an example OOP codebase and points out problems with it.\n• Arguments Against Oop on wiki.c2.com for a list of common arguments against OOP.\n• Object Oriented Programming is an expensive disaster which must end by Lawrence Krubner – this one is long and goes in depth into many ideas\n\nI've been receiving comments and more links, so I'm putting them here:\n• Quora: Is C++ OOP slower than C? If yes, is the difference significant?\n\nNote: This article was originally published on the author's blog, and is republished here with kind permission."
    }
]