[
    {
        "link": "https://docs.aiogram.dev",
        "document": "# Bot token can be obtained via https://t.me/BotFather # All handlers should be attached to the Router (or Dispatcher) # Most event objects have aliases for API methods that can be called in events' context # For example if you want to answer to incoming message you can use `message.answer(...)` alias # and the target chat will be passed to :ref:`aiogram.methods.send_message.SendMessage` Handler will forward receive a message back to the sender By default, message handler will handle all message types (like a text, photo, sticker etc.) # But not all the types is supported to be copied so need to handle it # Initialize Bot instance with default bot properties which will be passed to all API calls"
    },
    {
        "link": "https://docs.aiogram.dev/en/stable/dispatcher/errors.html",
        "document": "# Bot token can be obtained via https://t.me/BotFather # All handlers should be attached to the Router (or Dispatcher) # Most event objects have aliases for API methods that can be called in events' context # For example if you want to answer to incoming message you can use `message.answer(...)` alias # and the target chat will be passed to :ref:`aiogram.methods.send_message.SendMessage` Handler will forward receive a message back to the sender By default, message handler will handle all message types (like a text, photo, sticker etc.) # But not all the types is supported to be copied so need to handle it # Initialize Bot instance with default bot properties which will be passed to all API calls"
    },
    {
        "link": "https://docs.aiogram.dev/en/dev-3.x/dispatcher/errors.html",
        "document": "Is recommended way that you should use errors inside handlers using try-except block, but in common cases you can use global errors handler at router or dispatcher level.\n\nIf you specify errors handler for router - it will be used for all handlers inside this router.\n\nIf you specify errors handler for dispatcher - it will be used for all handlers inside all routers."
    },
    {
        "link": "https://docs.aiogram.dev/en/v3.14.0/dispatcher/errors.html",
        "document": "Is recommended way that you should use errors inside handlers using try-except block, but in common cases you can use global errors handler at router or dispatcher level.\n\nIf you specify errors handler for router - it will be used for all handlers inside this router.\n\nIf you specify errors handler for dispatcher - it will be used for all handlers inside all routers."
    },
    {
        "link": "https://restack.io/p/aiogram-answer-best-telegram-bot-frameworks-ai-cat-ai",
        "document": "To use Aiogram, a powerful framework for building Telegram bots in Python, you first need to ensure that Python is installed on your system. Some operating systems come with Python pre-installed, while others may require manual installation. To check if Python is already installed, follow these steps:\n• MacOS: Open Terminal, which can be found in the Applications folder or accessed via Spotlight (Command + Space).\n• Windows: Open Command Prompt by searching for 'cmd' in the start menu.\n\nOnce the terminal is open, type and press Enter. If you enter the Python interpreter, Python is installed. If you see an error message like \"Error: command python not found\", you will need to install Python.\n\nTo download Python, visit the official Python website and download the latest version. Ensure you install at least Python 3.7.1 or newer. If you're new to Python, you can follow the official installation guide for beginners.\n\nCreating a virtual environment is a recommended practice when working with Python projects, including Aiogram. A virtual environment allows you to manage dependencies for your project without affecting other projects on your system. If you prefer not to use a virtual environment, you can skip to the next step.\n\nTo create a virtual environment, use the built-in module. Run the following command in your terminal:\n\nAfter creating the virtual environment, activate it:\n\nOnce activated, your terminal prompt will change to indicate that you are now working within the virtual environment. This is a clear sign that any packages you install will be contained within this environment, preventing conflicts with other projects.\n\nFor more details on managing virtual environments, refer to the official Python documentation."
    },
    {
        "link": "https://pynative.com/python-timedelta",
        "document": "In this tutorial, you’ll learn the timedelta in Python and its usage.\n• How to calculate the difference between two datetime using timedelta\n• Calculate future dates and compare two dates using timedelta\n\nWhat is Timedelta in Python?\n\nA timedelta represents a duration which is the difference between two dates, time, or datetime instances, to the microsecond resolution.\n\nThe class available in Python’s datetime module. Use the to add or subtract weeks, days, hours, minutes, seconds, microseconds, and milliseconds from a given date and time.\n\nimport the class from the datetime module and you are ready to use it.\n\nExample 1: Calculate the difference between two dates\n\nLet’s see how to use class to calculate future dates by adding four weeks to a given date.\n\nThe object has seven arguments: days, seconds, minutes, hours, weeks, milliseconds, and microseconds.\n\nCreate a timedelta object in Python using the following method. It returns a object\n• All seven arguments are optional, and the default value is 0.\n• We can give either integer or float values to these arguments.\n\nUse any of the above arguments to calculate past and future dates from a given date.\n\nInternally the values are stored as days, seconds, and microseconds. Values passed in any other unit will be converted to these units. For example, a millisecond will be converted to 1000 seconds, and a week will be converted to 7 days, and so on.\n\nNormalizing a time delta object is merging the timedelta argument values to only three attributes, namely days, seconds, and microseconds. This is done internally while storing the time delta object.\n\nWhile merging, the values are generally checked in the range mentioned in the below table. If they are outside this range, it will throw an .\n\nWe can access each attribute from the object. Below table shows all 6 attributes and their meaning.\n\nThese attributes are helpful when we calculate the difference between two dates using timedelta. We can access an individual difference, like the difference between two dates in seconds or minutes, or days.\n\nWe can use the attribute of the timedelta class to add or subtract weeks from a given date to compute future and past dates in Python.\n\nUse the seconds and milliseconds attribute of a object to compute the time before or after a few seconds/milliseconds.\n\nA time delta object instance has a method called to calculate the total number of seconds in duration.\n\nThis returns a floating-point value of total seconds, up to microseconds accuracy. But for larger intervals like 270 years, this method loses the microsecond accuracy.\n\nSo this method is most commonly used to convert a object to a floating-point number.\n\nWe can compute the future date and past dates by adding or subtracting the current date with a timedelta object by passing the desired number of days to object.\n\nWe can compute hours before or after the current time using the by mentioning the number of hours.\n\nWhile finding the difference between two dates, we get timedelta objects consisting of days and seconds displayed separately. But sometimes, for further calculations, we need to add or subtract two timedelta objects.\n\nBy subtracting we get the difference between two timedelta.\n\nFor example, you want to fetch reports that are two weeks, two days, 12 hours, and 30 minutes old. And save the new report date, which is two weeks, one days, 11 hours, and 30 minutes away from a current date.\n\nIn addition to adding and subtracting two timedelta objects, we can perform the following operations with them.\n• Multiplying with a Floating point value: We can multiply a object with an integer or float, and the result is rounded to the nearest multiple.\n• Modulo Operation: Performing the modulo( ) operation with two objects, the remainder is computed as a object.\n\nUse the relational operators to comparing two timedelta objects.\n• The or operator always returns a boolean even if we compare a object with an integer.\n• You will get a TypeError: '>' not supported between instances of 'datetime.timedelta' and 'int' if we try to compare a object to an object of another type.\n\nAfter computing the future or past durations using the , we can use the date formatting function to display the timedelta e in the desired format.\n\nThe above code produced the following formatted\n\nWe can even convert time in string format to by using the strptime() function and then extracting the information using the module.\n• We can use the constructor to print the time delta in the string form . You can also use the method on timedelta object to display it in string format\n• We can use the to print the timedelta as a constructor with attributes in a string format."
    },
    {
        "link": "https://docs.python.org/3/library/datetime.html",
        "document": ""
    },
    {
        "link": "https://geeksforgeeks.org/python-datetime-timedelta-class",
        "document": "Timedelta class is used for calculating differences between dates and represents a duration. The difference can both be positive as well as negative.\n\nLet’s see the attributes provided by this class –\n\nExample: Getting the minimum and maximum value of timedelta objects\n\nTimedelta class provides only one function which is total_seconds(). This method returns the duration provided by the timedelta object in the number of seconds.\n\nNote: For a duration of more than 270 years this method will be accurate for microseconds.\n\nExample: Getting various duration in seconds\n\nExample 2: Getting Absolute value and the string representation of timedelta objects\n\nNote: For more information on Python Datetime, refer to Python Datetime Tutorial"
    },
    {
        "link": "https://geeksforgeeks.org/python-datetime-timedelta-function",
        "document": "Python timedelta() function is present under datetime library which is generally used for calculating differences in dates and also can be used for date manipulations in Python. It is one of the easiest ways to perform date manipulations.\n\nCreate a timedelta object with the desired time difference.\n\nSubtract the timedelta object from a date or datetime object using the – operator.\n\nWhat does timedelta() return in Python?\n\nHow to find timedelta in Python?\n\nHow to compare 2 datetime in Python?\n\nYou can compare two datetime objects using comparison operators (<, <=, >, >=, ==, !=). \n\n \n\n \n\n \n\n \n\n\n\n \n\n\n\n print(\"date1 is later than date2\") \n\n\n\n\n\nHow to get time from timedelta?\n\nYou can access the time components (days, hours, minutes, seconds) from a timedelta object using its attributes: .days, .seconds, and .microseconds. Here’s an example:\n\nWhat is the alternative to Timedelta in Python?\n\nThere isn’t a direct alternative to timedelta for representing durations between dates or times in Python’s standard library. timedelta is specifically designed for this purpose and is part of the datetime module. However, you can use libraries like arrow, dateutil, or pendulum for more advanced date and time manipulations, which may offer additional features or easier syntax for handling durations and intervals."
    },
    {
        "link": "https://datacamp.com/tutorial/timedelta-python-time-intervals",
        "document": "Master the basics of data analysis with Python in just four hours. This online course will introduce the Python interface and explore popular packages."
    },
    {
        "link": "https://stackoverflow.com/questions/33142922/datetime-attribute-error-in-python",
        "document": "There is nothing wrong with your code. It could be reduced a bit though:\n\nwhich should also cause the error. If this really causes the error, I would say your installation is messed up or, unlikely, there's a bug in Python. Please also make sure you don't have a datetime.py in your working directory. Further, check the output of after importing it and with a different version of Python."
    },
    {
        "link": "https://stackoverflow.com/questions/74596100/attribute-error-datetime-date-object-has-no-attribute-date",
        "document": "I wrote a code to get the year month and day in int from input and used datetime.. Date() to convert it into date format.\n\nThe error which I received is\n\nHow do I solve this ?"
    },
    {
        "link": "https://labex.io/tutorials/python-how-to-resolve-datetime-parsing-error-438481",
        "document": "Datetime is a fundamental module in Python for handling dates, times, and time-related operations. Understanding its basic concepts is crucial for effective data manipulation and time-based programming.\n\nPython's module provides several key classes for working with dates and times:\n\ngraph TD A[Create Datetime Object] --> B{What Type?} B --> |Date| C[Use date class] B --> |Time| D[Use time class] B --> |Full Datetime| E[Use datetime class] C --> F[Year, Month, Day] D --> G[Hour, Minute, Second] E --> H[Combine Date and Time]\n• Always import the necessary classes from the module\n• Use appropriate methods for parsing and formatting dates\n\nWhen learning datetime manipulation, practice is key. LabEx provides interactive environments to experiment with datetime operations and improve your Python skills."
    },
    {
        "link": "https://blog.airbrake.io/blog/php-exception-handling/attributeerror",
        "document": "Moving along through our in-depth Python Exception Handling series, today we'll dig into the AttributeError. The in Python is raised when an invalid attribute reference is made, or when an attribute assignment fails. While most objects support attributes, those that do not will merely raise a when an attribute access attempt is made.\n\nThroughout this article we'll examine the by looking at where it sits in the larger Python Exception Class Hierarchy. We'll also discover a bit about how attributes and work in Python, then look at some functional sample code illustrating how to handle built-in and custom attribute access, and how doing so can raise in your own code. Let's get started!\n\nAll Python exceptions inherit from the class, or extend from an inherited class therein. The full exception hierarchy of this error is:\n\nBelow is the full code sample we'll be using in this article. It can be copied and pasted if you'd like to play with the code yourself and see how everything works.\n\nimport math\n\n import sys\n\n import traceback @classmethod\n\n def __output(cls, *args, sep: str = ' ', end: str = '\n\n', file=None):\n\n \"\"\"Prints the passed value(s) to the console. :param args: Values to output.\n\n :param sep: String inserted between values, default a space.\n\n :param end: String appended after the last value, default a newline.\n\n :param file: A file-like object (stream); defaults to the current sys.stdout.\n\n :return: None\n\n \"\"\"\n\n print(*args, sep=sep, end=end, file=file) @classmethod\n\n def line_separator(cls, value: str = None, length: int = separator_length_default,\n\n char: str = separator_character_default):\n\n \"\"\"Print a line separator with inserted text centered in the middle. :param value: Inserted text to be centered.\n\n :param length: Total separator length.\n\n :param char: Separator character.\n\n \"\"\"\n\n output = value # If no value passed, output separator of length.\n\n if value == None or len(value) == 0:\n\n output = f'{char * length}'\n\n elif len(value) < length:\n\n # Update length based on insert length, less a space for margin.\n\n length -= len(value) + 2\n\n # Halve the length and floor left side.\n\n left = math.floor(length / 2)\n\n right = left\n\n # If odd number, add dropped remainder to right side.\n\n if length % 2 != 0:\n\n right += 1 # Surround insert with separators.\n\n output = f'{char * left} {value} {char * right}' @classmethod\n\n def log(cls, *args, sep: str = ' ', end: str = '\n\n', file=None):\n\n \"\"\"Prints the passed value(s) to the console. :param args: Values to output.\n\n :param sep: String inserted between values, default a space.\n\n :param end: String appended after the last value, default a newline.\n\n :param file: A file-like object (stream); defaults to the current sys.stdout.\n\n \"\"\"\n\n cls.__output(*args, sep=sep, end=end, file=file) @classmethod\n\n def log_exception(cls, exception: BaseException, expected: bool = True):\n\n \"\"\"Prints the passed BaseException to the console, including traceback. :param exception: The BaseException to output.\n\n :param expected: Determines if BaseException was expected.\n\n \"\"\"\n\n output = \"[{}] {}: {}\".format('EXPECTED' if expected else 'UNEXPECTED', type(exception).__name__, exception)\n\n cls.__output(output)\n\n exc_type, exc_value, exc_traceback = sys.exc_info()\n\n traceback.print_tb(exc_traceback)\n\nWhen Should You Use It?\n\nAs previously mentioned, the is raised when attempting to access an invalid attribute of an object. The typically way to access an attribute is through an syntax form, which is to separate the (the object instance) and the attribute name with a period ( ). For example, would attempt to retrieve the attribute of the object.\n\nWhen evoking an attribute reference, under the hood Python expects to find the attribute that was directly accessed. If it fails to locate a matching attribute it will then call the method of the object, which performs a less efficient lookup of the instance attribute. If this also fails to find a matching attribute then an is raised to indicate that an invalid attribute was accessed.\n\nTo illustrate with a code example we start with a modified class:\n\nNotice that we've explicitly overriden the method of the base object class. This allows us to perform any custom logic that might be necessary when an attribute is not immediately located. To test this our method creates a new instance, outputs some explicit attributes to the log to prove everything works, and then attempts to directly access an invalid attribute of :\n\nExecuting this code produces the following output:\n\nAs you can see, everything worked fine until our attempt to acccess the attribute, at which point the overridden method was invoked, in which we raised an with the custom error message seen above.\n\nHowever, there's no reason to override the method if custom logic isn't required. To illustrate this we'll temporarily comment out our method so the built-in method is invoked instead. Rerunning our code now produces the following output with a slightly different message:\n\nAirbrake's robust error monitoring software provides real-time error monitoring and automatic exception reporting for all your development projects. Airbrake's state of the art web dashboard ensures you receive round-the-clock status updates on your application's health and error rates. No matter what you're working on, Airbrake easily integrates with all the most popular languages and frameworks. Plus, Airbrake makes it easy to customize exception parameters, while giving you complete control of the active error filter system, so you only gather the errors that matter most.\n\nCheck out Airbrake's error monitoring software today with a free 14-day trial, and see for yourself why so many of the world's best engineering teams use Airbrake to revolutionize their exception handling practices."
    },
    {
        "link": "https://docs.python.org/3/library/datetime.html",
        "document": ""
    }
]