[
    {
        "link": "https://pypi.org/project/svn",
        "document": "A required part of this site couldn’t load. This may be due to a browser extension, network issues, or browser settings. Please check your connection, disable any ad blockers, or try using a different browser."
    },
    {
        "link": "https://stackoverflow.com/questions/1448894/subversion-python-bindings-documentation",
        "document": "Just wanted to add a little clarification here.\n\nThanks to the above two answers (@BenjaminWohlwend and @Logan), I became aware there are more than one set of Python bindings/interfaces for Subversion; I did this on my Ubuntu 11.04 box:\n\nOne can look at the Debian package filelist, to determine which libraries these refer to; so we have:\n\n... and I also found another in the repository:\n\nThe link http://svn.apache.org/repos/asf/subversion (which I got from @BenjaminWohlwend) is apparently the Apache Software Foundation (asf?) Subversion repository for Subversion source code itself.\n\nThe OP's quest for documentation seems related to (or SWIG bindings (or ); whose build-from-source instructions are in @Logan's post. I couldn't find much better documentation source from the svn.developer: Using the APIs already referred in the OP, except for the bindings/swig/python/README; it explains how SWIG generates Python interfaces from C:\n\nThen, one could look in, say, svn/core.py, and find functions (and \"Symbols defined explicitly\") like ; noting that imports - where probably refers to the shared object ( ) files built from the C file libsvn_swig_py/swigutil_py.c.\n\nThen, we can look up , and find a commit message like SVNSearch: Subversion (commit 23570 05.03.2007), which refers to that function, and a ; looking up that file further, we find it in the ASF repository: svn_mergeinfo.h, which indeed contains:\n\nSeeing there, it's probably good here to refer to svn commit: r1175903 (Mon Sep 26 2011):\n\nThat is - that particular function has been deprecated in 2011 - so hopefully, one's Python SVN bindings and SVN installation should be matching..."
    },
    {
        "link": "https://svnbook.red-bean.com/en/1.8/svn.developer.usingapi.html",
        "document": "This text is a work in progress—highly subject to change—and may not accurately describe any released version of the Apache™ Subversion® software. Bookmarking or otherwise referring others to this page is probably not such a smart idea. Please visit http://www.svnbook.com/ for stable versions of this book.\n\nDeveloping applications against the Subversion library APIs is fairly straightforward. Subversion is primarily a set of C libraries, with header ( ) files that live in the directory of the source tree. These headers are copied into your system locations (e.g., ) when you build and install Subversion itself from source. These headers represent the entirety of the functions and types meant to be accessible by users of the Subversion libraries. The Subversion developer community is meticulous about ensuring that the public API is well documented—refer directly to the header files for that documentation.\n\nWhen examining the public header files, the first thing you might notice is that Subversion's datatypes and functions are namespace-protected. That is, every public Subversion symbol name begins with , followed by a short code for the library in which the symbol is defined (such as , , , etc.), followed by a single underscore ( ), and then the rest of the symbol name. Semipublic functions (used among source files of a given library but not by code outside that library, and found inside the library directories themselves) differ from this naming scheme in that instead of a single underscore after the library code, they use a double underscore ( ). Functions that are private to a given source file have no special prefixing and are declared . Of course, a compiler isn't interested in these naming conventions, but they help to clarify the scope of a given function or datatype.\n\nAnother good source of information about programming against the Subversion APIs is the project's own hacking guidelines, which you can find at https://subversion.apache.org/docs/community-guide/. This document contains useful information, which, while aimed at developers and would-be developers of Subversion itself, is equally applicable to folks developing against Subversion as a set of third-party libraries.\n\nAlong with Subversion's own datatypes, you will see many references to datatypes that begin with —symbols from the Apache Portable Runtime (APR) library. APR is Apache's portability library, originally carved out of its server code as an attempt to separate the OS-specific bits from the OS-independent portions of the code. The result was a library that provides a generic API for performing operations that differ mildly—or wildly—from OS to OS. While the Apache HTTP Server was obviously the first user of the APR library, the Subversion developers immediately recognized the value of using APR as well. This means that there is practically no OS-specific code in Subversion itself. Also, it means that the Subversion client compiles and runs anywhere that the Apache HTTP Server does. Currently, this list includes all flavors of Unix, Win32, BeOS, OS/2, and Mac OS X. In addition to providing consistent implementations of system calls that differ across operating systems, APR gives Subversion immediate access to many custom datatypes, such as dynamic arrays and hash tables. Subversion uses these types extensively. But perhaps the most pervasive APR datatype, found in nearly every Subversion API prototype, is the —the APR memory pool. Subversion uses pools internally for all its memory allocation needs (unless an external library requires a different memory management mechanism for data passed through its API), and while a person coding against the Subversion APIs is not required to do the same, she is required to provide pools to the API functions that need them. This means that users of the Subversion API must also link against APR, must call to initialize the APR subsystem, and then must create and manage pools for use with Subversion API calls, typically by using , , and . Almost every developer who has used the C programming language has at some point sighed at the daunting task of managing memory usage. Allocating enough memory to use, keeping track of those allocations, freeing the memory when you no longer need it—these tasks can be quite complex. And of course, failure to do those things properly can result in a program that crashes itself, or worse, crashes the computer. Higher-level languages, on the other hand, either take the job of memory management away from you completely or make it something you toy with only when doing extremely tight program optimization. Languages such as Java and Python use garbage collection, allocating memory for objects when needed, and automatically freeing that memory when the object is no longer in use. APR provides a middle-ground approach called pool-based memory management. It allows the developer to control memory usage at a lower resolution—per chunk (or “pool”) of memory, instead of per allocated object. Rather than using and friends to allocate enough memory for a given object, you ask APR to allocate the memory from a memory pool. When you're finished using the objects you've created in the pool, you destroy the entire pool, effectively de-allocating the memory consumed by all the objects you allocated from it. Thus, rather than keeping track of individual objects that need to be de-allocated, your program simply considers the general lifetimes of those objects and allocates the objects in a pool whose lifetime (the time between the pool's creation and its deletion) matches the object's needs.\n\nWith remote version control operation as the whole point of Subversion's existence, it makes sense that some attention has been paid to internationalization (i18n) support. After all, while “remote” might mean “across the office,” it could just as well mean “across the globe.” To facilitate this, all of Subversion's public interfaces that accept path arguments expect those paths to be canonicalized—which is most easily accomplished by passing them through or (depending on whether you are canonicalizing a local system path or a URL, respectively)—and encoded in UTF-8. This means, for example, that any new client binary that drives the interface needs to first convert paths from the locale-specific encoding to UTF-8 before passing those paths to the Subversion libraries, and then reconvert any resultant output paths from Subversion back into the locale's encoding before using those paths for non-Subversion purposes. Fortunately, Subversion provides a suite of functions (see ) that any program can use to do these conversions. Also, Subversion APIs require all URL parameters to be properly URI-encoded. So, instead of passing as the URL of a file named , you need to pass . Again, Subversion supplies helper functions that your application can use— and , for URI encoding and decoding, respectively.\n\nUsing Languages Other Than C and C++ If you are interested in using the Subversion libraries in conjunction with something other than a C program—say, a Python or Perl script—Subversion has some support for this via the Simplified Wrapper and Interface Generator (SWIG). The SWIG bindings for Subversion are located in . They are still maturing, but they are usable. These bindings allow you to call Subversion API functions indirectly, using wrappers that translate the datatypes native to your scripting language into the datatypes needed by Subversion's C libraries. Significant efforts have been made toward creating functional SWIG-generated bindings for Python, Perl, and Ruby. To some extent, the work done preparing the SWIG interface files for these languages is reusable in efforts to generate bindings for other languages supported by SWIG (which include versions of C#, Guile, Java, MzScheme, OCaml, PHP, and Tcl, among others). However, some extra programming is required to compensate for complex APIs that SWIG needs some help translating between languages. For more information on SWIG itself, see the project's web site at https://www.swig.org/. Subversion also has language bindings for Java. The javahl bindings (located in in the Subversion source tree) aren't SWIG-based, but are instead a mixture of Java and hand-coded JNI. Javahl covers most Subversion client-side APIs and is specifically targeted at implementors of Java-based Subversion clients and IDE integrations. Subversion's language bindings tend to lack the level of developer attention given to the core Subversion modules, but can generally be trusted as production-ready. A number of scripts and applications, alternative Subversion GUI clients, and other third-party tools are successfully using Subversion's language bindings today to accomplish their Subversion integrations. It's worth noting here that there are other options for interfacing with Subversion using other languages: alternative bindings for Subversion that aren't provided by the Subversion development community at all. There are a couple of popular ones we feel are especially noteworthy. First, Barry Scott's PySVN bindings (https://pysvn.sourceforge.io/) are a popular option for binding with Python. PySVN boasts of a more Pythonic interface than the more C-like APIs provided by Subversion's own Python bindings. And if you're looking for a pure Java implementation of Subversion, check out SVNKit (https://svnkit.com/), which is Subversion rewritten from the ground up in Java. In 2005, a small company called TMate announced the 1.0.0 release of JavaSVN—a pure Java implementation of Subversion. Since then, the project has been renamed to SVNKit (available at https://svnkit.com/) and has seen great success as a provider of Subversion functionality to various Subversion clients, IDE integrations, and other third-party tools. The SVNKit library is interesting in that, unlike the javahl library, it is not merely a wrapper around the official Subversion core libraries. In fact, it shares no code with Subversion at all. But while it is easy to confuse SVNKit with javahl, and easier still to not even realize which of these libraries you are using, folks should be aware that SVNKit differs from javahl in some significant ways. First, while SVNKit is developed as open source software just like Subversion, SVNKit's license is more restrictive than that of Subversion. Finally, by aiming to be a pure Java Subversion library, SVNKit is limited in which portions of Subversion can be reasonably cloned while still keeping up with Subversion's releases. This has already happened once—SVNKit cannot access BDB-backed Subversion repositories via the protocol because there's no pure Java implementation of Berkeley DB that is file-format-compatible with the native implementation of that library. That said, SVNKit has a well-established track record of reliability. And a pure Java solution is much more robust in the face of programming errors—a bug in SVNKit might raise a catchable Java Exception, but a bug in the Subversion core libraries as accessed via javahl can bring down your entire Java Runtime Environment. So, weigh the costs when choosing a Java-based Subversion implementation.\n\nExample 8.1, “Using the repository layer” contains a code segment (written in C) that illustrates some of the concepts we've been discussing. It uses both the repository and filesystem interfaces (as can be determined by the prefixes and of the function names, respectively) to create a new revision in which a directory is added. You can see the use of an APR pool, which is passed around for memory allocation purposes. Also, the code reveals a somewhat obscure fact about Subversion error handling—all Subversion errors must be explicitly handled to avoid memory leakage (and in some cases, application failure). Example 8.1. Using the repository layer /* Convert a Subversion error into a simple boolean error code. * * NOTE: Subversion errors must be cleared (using svn_error_clear()) * because they are allocated from the global pool, else memory * leaking occurs. */ #define INT_ERR(expr) \\ do { \\ svn_error_t *__temperr = (expr); \\ if (__temperr) \\ { \\ svn_error_clear(__temperr); \\ return 1; \\ } \\ return 0; \\ } while (0) /* Create a new directory at the path NEW_DIRECTORY in the Subversion * repository located at REPOS_PATH. Perform all memory allocation in * POOL. This function will create a new revision for the addition of * NEW_DIRECTORY. Return zero if the operation completes * successfully, nonzero otherwise. */ static int make_new_directory(const char *repos_path, const char *new_directory, apr_pool_t *pool) { svn_error_t *err; svn_repos_t *repos; svn_fs_t *fs; svn_revnum_t youngest_rev; svn_fs_txn_t *txn; svn_fs_root_t *txn_root; const char *conflict_str; /* Open the repository located at REPOS_PATH. */ INT_ERR(svn_repos_open(&repos, repos_path, pool)); /* Get a pointer to the filesystem object that is stored in REPOS. */ fs = svn_repos_fs(repos); /* Ask the filesystem to tell us the youngest revision that * currently exists. */ INT_ERR(svn_fs_youngest_rev(&youngest_rev, fs, pool)); /* Begin a new transaction that is based on YOUNGEST_REV. We are * less likely to have our later commit rejected as conflicting if we * always try to make our changes against a copy of the latest snapshot * of the filesystem tree. */ INT_ERR(svn_repos_fs_begin_txn_for_commit2(&txn, repos, youngest_rev, apr_hash_make(pool), pool)); /* Now that we have started a new Subversion transaction, get a root * object that represents that transaction. */ INT_ERR(svn_fs_txn_root(&txn_root, txn, pool)); /* Create our new directory under the transaction root, at the path * NEW_DIRECTORY. */ INT_ERR(svn_fs_make_dir(txn_root, new_directory, pool)); /* Commit the transaction, creating a new revision of the filesystem * which includes our added directory path. */ err = svn_repos_fs_commit_txn(&conflict_str, repos, &youngest_rev, txn, pool); if (! err) { /* No error? Excellent! Print a brief report of our success. */ printf(\"Directory '%s' was successfully added as new revision \" \"'%ld'.\n\n\", new_directory, youngest_rev); } else if (err->apr_err == SVN_ERR_FS_CONFLICT) { /* Uh-oh. Our commit failed as the result of a conflict * (someone else seems to have made changes to the same area * of the filesystem that we tried to modify). Print an error * message. */ printf(\"A conflict occurred at path '%s' while attempting \" \"to add directory '%s' to the repository at '%s'.\n\n\", conflict_str, new_directory, repos_path); } else { /* Some other error has occurred. Print an error message. */ printf(\"An error occurred while attempting to add directory '%s' \" \"to the repository at '%s'.\n\n\", new_directory, repos_path); } INT_ERR(err); } \n\n Note that in Example 8.1, “Using the repository layer”, the code could just as easily have committed the transaction using . But the filesystem API knows nothing about the repository library's hook mechanism. If you want your Subversion repository to automatically perform some set of non-Subversion tasks every time you commit a transaction (e.g., sending an email that describes all the changes made in that transaction to your developer mailing list), you need to use the -wrapped version of that function, which adds the hook triggering functionality—in this case, . (For more information regarding Subversion's repository hooks, see the section called “Implementing Repository Hooks”.) Now let's switch languages. Example 8.2, “Using the repository layer with Python” is a sample program that uses Subversion's SWIG Python bindings to recursively crawl the youngest repository revision, and to print the various paths reached during the crawl. Example 8.2. Using the repository layer with Python #!/usr/bin/python \"\"\"Crawl a repository, printing versioned object path names.\"\"\" import sys import os.path import svn.fs, svn.core, svn.repos def crawl_filesystem_dir(root, directory): \"\"\"Recursively crawl DIRECTORY under ROOT in the filesystem, and return a list of all the paths at or below DIRECTORY.\"\"\" # Print the name of this path. print directory + \"/\" # Get the directory entries for DIRECTORY. entries = svn.fs.svn_fs_dir_entries(root, directory) # Loop over the entries. names = entries.keys() for name in names: # Calculate the entry's full path. full_path = directory + '/' + name # If the entry is a directory, recurse. The recursion will return # a list with the entry and all its children, which we will add to # our running list of paths. if svn.fs.svn_fs_is_dir(root, full_path): crawl_filesystem_dir(root, full_path) else: # Else it's a file, so print its path here. print full_path def crawl_youngest(repos_path): \"\"\"Open the repository at REPOS_PATH, and recursively crawl its youngest revision.\"\"\" # Open the repository at REPOS_PATH, and get a reference to its # versioning filesystem. repos_obj = svn.repos.svn_repos_open(repos_path) fs_obj = svn.repos.svn_repos_fs(repos_obj) # Query the current youngest revision. youngest_rev = svn.fs.svn_fs_youngest_rev(fs_obj) # Open a root object representing the youngest (HEAD) revision. root_obj = svn.fs.svn_fs_revision_root(fs_obj, youngest_rev) # Do the recursive crawl. crawl_filesystem_dir(root_obj, \"\") if __name__ == \"__main__\": # Check for sane usage. if len(sys.argv) != 2: sys.stderr.write(\"Usage: %s REPOS_PATH\n\n\" % (os.path.basename(sys.argv[0]))) sys.exit(1) # Canonicalize the repository path. repos_path = svn.core.svn_dirent_canonicalize(sys.argv[1]) # Do the real work. crawl_youngest(repos_path) \n\n This same program in C would need to deal with APR's memory pool system. But Python handles memory usage automatically, and Subversion's Python bindings adhere to that convention. In C, you'd be working with custom datatypes (such as those provided by the APR library) for representing the hash of entries and the list of paths, but Python has hashes (called “dictionaries”) and lists as built-in datatypes, and it provides a rich collection of functions for operating on those types. So SWIG (with the help of some customizations in Subversion's language bindings layer) takes care of mapping those custom datatypes into the native datatypes of the target language. This provides a more intuitive interface for users of that language. The Subversion Python bindings can be used for working copy operations, too. In the previous section of this chapter, we mentioned the interface and how it exists for the sole purpose of simplifying the process of writing a Subversion client. Example 8.3, “A Python status crawler” is a brief example of how that library can be accessed via the SWIG Python bindings to re-create a scaled-down version of the svn status command. #!/usr/bin/env python \"\"\"Crawl a working copy directory, printing status information.\"\"\" import sys import os.path import getopt import svn.core, svn.client, svn.wc def generate_status_code(status): \"\"\"Translate a status value into a single-character status code, using the same logic as the Subversion command-line client.\"\"\" code_map = { svn.wc.svn_wc_status_none : ' ', svn.wc.svn_wc_status_normal : ' ', svn.wc.svn_wc_status_added : 'A', svn.wc.svn_wc_status_missing : '!', svn.wc.svn_wc_status_incomplete : '!', svn.wc.svn_wc_status_deleted : 'D', svn.wc.svn_wc_status_replaced : 'R', svn.wc.svn_wc_status_modified : 'M', svn.wc.svn_wc_status_conflicted : 'C', svn.wc.svn_wc_status_obstructed : '~', svn.wc.svn_wc_status_ignored : 'I', svn.wc.svn_wc_status_external : 'X', svn.wc.svn_wc_status_unversioned : '?', } return code_map.get(status, '?') def do_status(wc_path, verbose, prefix): # Build a client context baton. ctx = svn.client.svn_client_create_context() def _status_callback(path, status): \"\"\"A callback function for svn_client_status.\"\"\" # Print the path, minus the bit that overlaps with the root of # the status crawl text_status = generate_status_code(status.text_status) prop_status = generate_status_code(status.prop_status) prefix_text = '' if prefix is not None: prefix_text = prefix + \" \" print '%s%s%s %s' % (prefix_text, text_status, prop_status, path) # Do the status crawl, using _status_callback() as our callback function. revision = svn.core.svn_opt_revision_t() revision.type = svn.core.svn_opt_revision_head svn.client.svn_client_status2(wc_path, revision, _status_callback, svn.core.svn_depth_infinity, verbose, 0, 0, 1, ctx) def usage_and_exit(errorcode): \"\"\"Print usage message, and exit with ERRORCODE.\"\"\" stream = errorcode and sys.stderr or sys.stdout stream.write(\"\"\"Usage: %s OPTIONS WC-PATH Print working copy status, optionally with a bit of prefix text. Options: --help, -h : Show this usage message --prefix ARG : Print ARG, followed by a space, before each line of output --verbose, -v : Show all statuses, even uninteresting ones \"\"\" % (os.path.basename(sys.argv[0]))) sys.exit(errorcode) if __name__ == '__main__': # Parse command-line options. try: opts, args = getopt.getopt(sys.argv[1:], \"hv\", [\"help\", \"prefix=\", \"verbose\"]) except getopt.GetoptError: usage_and_exit(1) verbose = 0 prefix = None for opt, arg in opts: if opt in (\"-h\", \"--help\"): usage_and_exit(0) if opt in (\"--prefix\"): prefix = arg if opt in (\"-v\", \"--verbose\"): verbose = 1 if len(args) != 1: usage_and_exit(2) # Canonicalize the working copy path. wc_path = svn.core.svn_dirent_canonicalize(args[0]) # Do the real work. try: do_status(wc_path, verbose, prefix) except svn.core.SubversionException, e: sys.stderr.write(\"Error (%d): %s\n\n\" % (e.apr_err, e.message)) sys.exit(1) \n\n As was the case in Example 8.2, “Using the repository layer with Python”, this program is pool-free and uses, for the most part, normal Python datatypes. Run user-provided paths through the appropriate canonicalization function ( or ) before passing them to other API functions. Failure to do so can trigger assertions in the underlying Subversion C library which translate into rather immediate and unceremonious program abortion. Of particular interest to users of the Python flavor of Subversion's API is the implementation of callback functions. As previously mentioned, Subversion's C API makes liberal use of the callback function/baton paradigm. API functions which in C accept a function and baton pair only accept a callback function parameter in Python. How, then, does the caller pass arbitrary context information to the callback function? In Python, this is done by taking advantage of Python's scoping rules and default argument values. You can see this in action in Example 8.3, “A Python status crawler”. The function is given a callback function ( ) but no baton— gets access to the user-provided prefix string because that variable falls into the scope of the function automatically."
    },
    {
        "link": "https://pysvn.sourceforge.io",
        "document": "The PySVN project's goal is to enable Tools to be written in Python that use Subversion source control system.\n\nWindows, Mac OS X, Linux and other unix platforms are supported.\n• Easy to learn and use.\n• No need to understand the Subversion C API.\n• No longer build svn 1.10 kits as subversion LTS is 1.14 now\n\nPrebuilt kits are available for Windows and Mac OS X built for subversion 1.14.4 for python 3.9, 3.10, 3.11, 3.12 and 3.13\n\nThe downloads page for details of the available kits for Windows, Mac OS X and Linux.\n\nThe PySVN Programmer's Guide is a good place to get started using PySVN.\n\nIt covers the use of PySVN in a tutorial style with lots of examples.\n\nUse the PySVN Programmer's Reference to look up the detailed descriptions of all the classes, functions and variables of PySVN.\n\nThe python-library/site-packages/pysvn/Examples/Client/svn_cmd.py program is a replacement for the svn command line written using PySVN. It is a good place to look for working examples of use of all the pysvn module. View the latest version of svn_cmd.py.\n\nSCM Workbench is an App for Mac OS, Windows and Linux/Unix that provides Subversion, Git and Mercurial access. It is the replacement for the PySVN Workbench app.\n\nWe welcome contributions to PySVN with ideas, code, testing and documentation.\n\nDiscussions take place on the pysvn-discuss mailing lists. Feature requests, bugs and patches can be entered in the tickets database.\n\nThe main SourceForge PySVN Project page has links the Issue Tracker, Code browser and other services.\n\nThe extension is written in C++, using the PyCXX library. Everything else is written in Python."
    },
    {
        "link": "https://github.com/dsoprea/PySvn",
        "document": "svn is a simple Subversion library for Python. I wrote it so that there could be a lightweight and accessible library that was also available on PyPI. It is compatible with both Python 2.7 and 3.3+.\n\nThe library wraps the commandline client, which should consequently be installed on the local system.\n\nIn addition, there is also an \"admin\" class ( ) that provides a method with which to create repositories.\n\nYou are more than welcome to submit pull-requests to add more support for additional subcommands.\n\nUsage is divided between two clients that either allow for access to a local working-directory or a remote repository.\n\nBoth clients inherit a common set of methods that work with both local working- directories and remote repositories.\n\nis provided for convenience. If you provide a location that starts with a backslash, it will return a LocalClient instance. Otherwise, it will return a RemoteClient instance.\n\nYou may pass and as optional arguments to both the constructor and utility function.\n\nSvnException is raised whenever there is an issue with the svn repository. We are no longer supporting catching ValueError.\n\nThese methods are available on both clients.\n\nGet information about the directory.\n\nNOTE: The keys named with dashes, slashes, and hashes are considered obsolete, and only available for backwards compatibility. We have since moved to using only underscores to separate words.\n\nPerform a log-listing that can be bounded by time or revision number and/or take a maximum-count.\n\nCheckout the tree without embedding an meta-information.\n\nWe can also use option to force the svn export.\n\nReturn either a flat-list of filenames or a list of objects describing even more information about each.\n\nList all entries at and beneath the root or given relative-path.\n\nA lower-level diff summary that doesn't actually provide the content differences.\n\nThere was a previous contribution to the diff implementation that has been reported and confirmed to often throw an exception due to shoddy handling of the file-paths in the output. It also made secondary shell calls and mixed both text and XML output in the response. As a result of this, the decision has been made to just reimplement it and reshape the output in a backwards-incompatible way at the same time. If you need to stick to the older implementation, tie your dependencies to the 0.3.46 release."
    },
    {
        "link": "https://stackoverflow.com/questions/4471195/python-library-for-getting-information-about-svn-repository",
        "document": "I'm searching for a library that can extract (at least) the following information from a SVN repository (not a working copy!):\n• Changes in each revision (added, deleted, modified files)\n\nIs there a Python library that can do this?\n\nFor the authors and commit messages, I could parse \"db/revprops/0/...\" (simple format), but looking for changed files does not seem so easy, so I'd rather stick with a library that supports SVN repos."
    },
    {
        "link": "http://sfriederichs.github.io/how-to/python3/svn/2020/07/13/SVN-with-Python.html",
        "document": "I have a tedious task to perform which involves reading information from SVN and updating a review checklist with the information. The ‘hard’ part of this whole process is the actual review. The ‘easy’ part is looking up the revision information, paths, file names, etc and putting them into the spreadsheet. Despite the fact that this is the ‘easy’ part it’s also very easy to mess up. This tedious copy and paste process has many steps, requires significant working memory and can be easily confusing. The worst part is that even if you do the ‘hard’ part well, you need to do the ‘easy’ part perfectly because if you mess up a revision or a path there’s no way to link the work you did to the actual artifact being reviewed.\n\nSo, why not create a script?\n\nPython can read SVN and filesystem information. It can read Excel files. It can write excel files. So, let’s just automate this whole thing.\n\nThis post will focus on the SVN aspects of the process. I have another that focuses on the Excel aspects.\n\nThere is a package called PySVN that handles the interface between Python and SVN. It’s a bit of fun, so buckle up.\n\nOn a Windows 10 PC using Python 3 (3.8.1) I did the following:\n\nIt’s really odd. I can’t find a lot about why pip isn’t working. That being said, it seems you just install it with an installer, from their website.\n\nThe download website is here.\n\nI’m downloading the version for Python 3.8.1 and WIndows 1 x64, which is here. Note: it’s the 1.14.0 version.\n\nIt brings me to SourceForge (ew) and the download starts.\n\nUh, where is it?\n\nOh look, Windows Defender says that it’s scard of this download. I tell it ‘no’. You will run it.\n\nAnyway, on to the actual installation.\n• Ready to Install - Everything looks good, I click ‘Install’\n• And then, it finishes. So I click ‘Finish’\n\nThe first thing I like to do with anything new is to do a ‘Hello World’ type script. In this case, my workflow depends on several things:\n• Getting the full SVN URL of files checked out on to my PC\n• Getting the last few log entries of files check out on my PC\n• Finding the last user to commit a file check out on my PC\n\nThe first thing that shows up when I google for ‘pysvn examples’ is this page.\n\nIt has quite a few little snippets that look rather tasty. Let’s see if I can find what I’m looking for.\n\nEh, no. I can’t. Dang. What else do we have?\n\nOne thing I have noticed over the years of using PySVN is that it has curiously few examples running around out there. Few StackOverflow questions, few blog posts, etc.\n\nOne of the first things you’ll need to do is specify a callback function to get a login to your SVN server. Not much will work without it. This is the documentation for implementing a callback, and below you’ll see I’ve generated a simple function to suffice for the callback and register it to the SVN client.\n\nThat at least runs without error, so I’ll move on to the next part.\n\nFYI, none of those entries above are my real password to anything.\n\nI think the function I need to use is the info2 function. Read more about it here.\n\nI need to pick a file, point info2 towards it, then see what it returns. Here’s the code I’m trying:\n\nWhat the docs say will be returned is this:\n\nHistorically, PySVN has a very confusing way of storing useful information. Actually getting the information you want out of what it returns is complicated. Here’s what comes out of the print statement:\n\nSee? That’s just kinda weird. A tuple inside a list? And the first item of the tuple is just the file path I passed to it? So, to access the PysvnInfo member, you have to do this:\n\nBut the second print statement prints this out:\n\nBrilliant. So, we start trying to figure out what’s in there. Supposedly it’s a dictionary, right? So we’ll try accessing some of the named members from the website. Like this:\n\nOkay, so I didn’t put the actual URL there, but take my word for it: it prints out the URL.\n\nIt should be easy to get the rest of the information that we want.\n\nIf you thought an SVN revision was just an integer number, raise your hand.\n\nTurns out - I’m wrong. An SVN revision (as far as PySVN is concerned) is a pysvn.Revision type.\n\nNow what, pray tell, is that?\n\nIf you’re interested in what the opt_revision_kind enumeration information is, look here:\n\nOkay, so what will print out if we try to access the revision code? We try like this:\n\nInteresting, but supposedly tehre were three elements: kinda, date and number. Can we access them or am I misunderstanding things?\n\nWell, that at least bears out the part about having three elements. Now at least I can access the specific parts of the revision information that I’m looking for.\n\nHowever, we must take into account a wrinkle with SVN: last-changed revision vs. current revision.\n\nCurrent revision is basically the most recent revision of the working copy. Imagine if you did an update on the root of a working copy - when it finished you’d see something like “Updated to revision xxxx”. Now, the working copy is considered to be at revision xxxx. However, many files within the working copy might not have been changed in revision xxxx - they have a ‘last-changed’ revision which will be lower than the working copy revision. When SVN says ‘Updated to revision xxxx’ what it’s saying is ‘all the files in this working copy are up-to-date as of revision xxxx’. If you pick a file that was last updated in say, revision 443 and tell SVN to check out that file at any revision later than 443, you’ll get the most up-to-date file. If you choose to check out a revision earlier than 443, you will not have the most up-to-date file. 443 would be the ‘last-changed revision’, while xxxx would be the ‘revision’.\n\nGenerally, the ‘revision’ isn’t very useful when you’re looking at individual files. Instead, you’ll want to go with the ‘last-changed revision’.\n\nIn order to print out the information for ‘rev’ vs. ‘last-changed-rev’, I would use this code:\n\nAnd you get this output:\n\nNot bad, now we can get all the revision information we want.\n\nI’m guessing that the author information is this one:\n\nAnd luckily, it’s just a string, so it should be easy to access like this:\n\nKeep in mind, the ‘author’ will be a username, not necessarily a full-fledged first and last name.\n\nNow we’re getting a bit farther. Most of the information I was looking for could be found with the info2 function, but I don’t see anything about the log in the info2 documentation, so it must be elsewhere.\n\nLook no further than this.\n\nAlright, so what does this mean practically?\n\nIt’s worth noting that retrieving the log takes a second - much more time than the info2 command took.\n\nOkie…. this file has two entries in its log when I look at it, so that must be theese. Let’s assume those are dictionaries as specified above and see if we can print out the information we want for each entry. Here’s the code I created:\n\nI had to include the datetime library to get the correct formatting function since the timestamp comes back in a float format. But overall, not too bad!\n\nI have a situation where I need to get the SVN information (URL, last changed revision) for a few files in a directory. This presents an interesting twist: in a working copy, not all files may be version controlled. There could be uncommitted files hanging around there - this means it’s important not to do a directory listing of files, but instead to do an SVN listing of files.\n\nTurns out there’s a useful command called ‘ls’. Ha. Imagine that. Let’s see what the documentation says about it.\n\nOh. Okay. Where’s that?\n\nYou pass it a path and it returns some information:\n\nSo, I whip this code up:\n\nWell, we’ve got a problem: the paths are relative repository paths, not complete URLs. The server name and protocol is not present, which is not what I want.\n\nThe question is: how do I get that?\n\nI could use the list command to get a list of files and then use the info2 command to get their URLs.\n\nWhen you list a directory, the first entry returned is the directory itself!\n\nNot really a problem, but if you’re expecting just the files, you’ll get in some trouble.\n\nAnyway, here’s the code to do get the full URL with the info2 command:\n\nOne of the sanity checks I’ll have to do is to make sure that I haven’t failed to commit changes I’ve made to my checklists before I close an issue.\n\nI think I’d like to change it to something that returns a list of files with uncommitted changes. Let’s look up the status function. Documentation is here.\n\nAlright, the big question is going to be what the path returns - local? Repo? URL?\n\nThe other big issue is that the example code only looks for status NOT normal. That could include more things than just normal or uncommitted changes.\n\nThis is the documentation for the pysvn_wc_status_kind type, reproduced here:\n\nOkay, so we can check for a variety of non-ideal status. Honestly, at this point, if any status is not ‘normal’ it pump the brakes, so I guess that guy was right….\n\nAnyway, here’s what I wrote for code:\n\nAnd it produced this:\n\nAnd all of the file paths were local working directory paths. Doesn’t really matter to me.\n\nIt’s worth noting, again, that the first entry was the entry for the directory, not a file within the directory.\n\nWell, once you’ve ascertained there are uncommitted changes, you’ll want to commit them.\n\nBut PySVN doesn’t use the verb ‘commit’ for this, it uses ‘checkin’.\n\nOnly big question is how to get the log message. I know there can be a log message callback, but I think I’ll just use a text input to do this.\n\nThe try/catch is there because I know that it’s possible that there will be circumstances the commit will fail - one I know of for sure is a pre-commit hook failing. However, I don’t know exactly what the exception will be and the documentation isn’t explicit on that, so I’m just catching a generic exception.\n\nYes, I know - that’s bad. But until that exception occurs I won’t know what to look for specifically. Or I could do more research. But I won’t right now.\n\nAlso, I’ve had issues using os.linesep within log messages, as well as ‘\\r\n\n’. The server I’m working on only wants the ‘\n\n’.\n\nIf you have a newly-created file, you’ll need to add it to your working copy and then commit to get the file into SVN. Here’s how you do it.\n\nThese are miscellaneous notes I’m keeping about using PySVN.\n\nOne of the interesting things about PySVN is that there’s only one SVN client on your PC - anywhere. That means if you’re messing around with the command-line SVN client and you try to run a Python script that uses the SVN client your Python script will have to wait for the command-line process to finish before it can start.\n\nOne important upshot of this is that you really can’t do multi-threaded access to the SVN client in Python. If you try, you’re gonna have a confusing and frustrating time.\n\nOnly ever access the SVN client from _one_ Python thread"
    },
    {
        "link": "https://stackoverflow.com/questions/1449935/getting-svn-revision-number-into-a-program-automatically",
        "document": "I'm not sure about the Python specifics, but if put the string $Revision$ into your file somewhere and you have enable-auto-props=true in your SVN config, it'll get rewritten to something like $Revision: 144$. You could then parse this in your script.\n\nThere are a number of property keywords you can use in this way.\n\nThis won't have any overhead, e.g. querying the SVN repo, because the string is hard-coded into your file on commit or update.\n\nI'm not sure how you'd parse this in Python but in PHP I'd do:"
    },
    {
        "link": "https://pypi.org/project/svn",
        "document": "A required part of this site couldn’t load. This may be due to a browser extension, network issues, or browser settings. Please check your connection, disable any ad blockers, or try using a different browser."
    },
    {
        "link": "https://blog.christianposta.com/using-pysvn-to-get-a-tag-name-for-current-working-directory",
        "document": "Recently, I needed an way to report the version of the application I'm working on to the users of the application.\n\nI wanted to avoid manually updating a settings file or some similar configuration file that the application could read and runtime and report the version. This would be a manual step that would eventually be forgotten at some point, or overlooked.\n\nI tag each of my deployments in SVN, so I figured there must be some way to associate the tagname (which represented the version) to the version that's displayed to the users. When you run the 'svn info' command, it does display the working directory's URL path to the svn repo. I decided to ask around for suggestions, as I didn't necessarily want to roll new code to parse that URL path if some useful utility existed.\n\nLuckily, someone did recommend a library that provided an svn binding for python. I explored pysvn and found it provided exactly what I needed. The documentation for pysvn is outstanding. It gave all the examples and descriptions that I needed to easily write a function to retrieve the tag name from the working directory's svn URL.\n\nMy first step was to install the pysvn bindings. Unfortunately, I didn't see it available in PyPI, so I had to download and install it (thankfully on Ubuntu, it's a simple sudo apt-get python-svn call, as described here).\n\nI used the pysvn libraries to retrieve the working directory's svn URL, the builtin urlparse library to parse the path from the full url, and finally the posixpath library to get the 'basename' which is the tagname.\n\nHere's my final code for doing so:"
    }
]