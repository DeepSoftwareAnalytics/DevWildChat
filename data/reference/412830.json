[
    {
        "link": "https://doc.rust-lang.org/std/str/struct.Split.html",
        "document": ""
    },
    {
        "link": "https://doc.rust-lang.org/std/string/struct.String.html",
        "document": "is the most common string type. It has ownership over the contents of the string, stored in a heap-allocated buffer (see Representation). It is closely related to its borrowed counterpart, the primitive . You can create a from a literal string with : You can append a to a with the method, and append a with the method: If you have a vector of UTF-8 bytes, you can create a from it with the method: s are always valid UTF-8. If you need a non-UTF-8 string, consider . It is similar, but without the UTF-8 constraint. Because UTF-8 is a variable width encoding, s are typically smaller than an array of the same s: This raises interesting questions as to how should work. What should be here? Several options include byte indices and indices but, because of UTF-8 encoding, only byte indices would provide constant time indexing. Getting the th , for example, is available using : Next, what should return? Because indexing returns a reference to underlying data it could be , , or something else similar. Since we‚Äôre only providing one index, makes the most sense but that might not be what the user expects and can be explicitly achieved with : Due to these ambiguities/restrictions, indexing with a is simply forbidden: ‚ìò s = ; ( \"The first letter of s is {}\" , s[ ]); It is more clear, however, how should work (that is, indexing with a range). It should accept byte indices (to be constant-time) and return a which is UTF-8 encoded. This is also called ‚Äústring slicing‚Äù. Note this will panic if the byte indices provided are not character boundaries - see for more details. See the implementations for for more details on string slicing. For a non-panicking version of string slicing, see . The and methods return iterators over the bytes and codepoints of the string, respectively. To iterate over codepoints along with byte indices, use . implements , and so inherits all of ‚Äôs methods. In addition, this means that you can pass a to a function which takes a by using an ampersand ( ): This will create a from the and pass it in. This conversion is very inexpensive, and so generally, functions will accept s as arguments unless they need a for some specific reason. In certain cases Rust doesn‚Äôt have enough information to make this conversion, known as coercion. In the following example a string slice implements the trait , and the function takes anything that implements the trait. In this case Rust would need to make two implicit conversions, which Rust doesn‚Äôt have the means to do. For that reason, the following example will not compile. There are two options that would work instead. The first would be to change the line to , using the method to explicitly extract the string slice containing the string. The second way changes to . In this case we are dereferencing a to a , then referencing the back to . The second way is more idiomatic, however both work to do the conversion explicitly rather than relying on the implicit conversion. A is made up of three components: a pointer to some bytes, a length, and a capacity. The pointer points to the internal buffer which uses to store its data. The length is the number of bytes currently stored in the buffer, and the capacity is the size of the buffer in bytes. As such, the length will always be less than or equal to the capacity. This buffer is always stored on the heap. You can look at these with the , , and methods: If a has enough capacity, adding elements to it will not re-allocate. For example, consider this program: This will output the following: At first, we have no memory allocated at all, but as we append to the string, it increases its capacity appropriately. If we instead use the method to allocate the correct capacity initially: We end up with a different output: Here, there‚Äôs no need to allocate more memory inside the loop.\n\nThis length is in bytes, not s or graphemes. In other words, it might not be what a human considers the length of the string. Returns if has a length of zero bytes. Checks that -th byte is the first byte in a UTF-8 code point sequence or the end of the string. The start and end of the string (when ) are considered to be boundaries. Returns if is greater than . Finds the closest not exceeding where is . This method can help you truncate a string so that it‚Äôs still valid UTF-8, but doesn‚Äôt exceed a given number of bytes. Note that this is done purely at the character level and can still visually split graphemes, even though the underlying characters aren‚Äôt split. For example, the emoji üßë‚Äçüî¨ (scientist) could be split so that the string only includes üßë (person) instead. Finds the closest not below where is . If is greater than the length of the string, this returns the length of the string. This method is the natural complement to . See that method for more details. Converts a string slice to a byte slice. To convert the byte slice back into a string slice, use the function. The caller must ensure that the content of the slice is valid UTF-8 before the borrow ends and the underlying is used. Use of a whose contents are not valid UTF-8 is undefined behavior. As string slices are a slice of bytes, the raw pointer points to a . This pointer will be pointing to the first byte of the string slice. The caller must ensure that the returned pointer is never written to. If you need to mutate the contents of the string slice, use . As string slices are a slice of bytes, the raw pointer points to a . This pointer will be pointing to the first byte of the string slice. It is your responsibility to make sure that the string slice only gets modified in a way that it remains valid UTF-8. This is the non-panicking alternative to indexing the . Returns whenever equivalent indexing operation would panic. This is the non-panicking alternative to indexing the . Returns whenever equivalent indexing operation would panic. This is the unchecked alternative to indexing the . Callers of this function are responsible that these preconditions are satisfied:\n‚Ä¢ The starting index must not exceed the ending index;\n‚Ä¢ Indexes must be within bounds of the original slice; Failing that, the returned string slice may reference invalid memory or violate the invariants communicated by the type. This is the unchecked alternative to indexing the . Callers of this function are responsible that these preconditions are satisfied:\n‚Ä¢ The starting index must not exceed the ending index;\n‚Ä¢ Indexes must be within bounds of the original slice; Failing that, the returned string slice may reference invalid memory or violate the invariants communicated by the type. Deprecated since 1.29.0: use instead This is generally not recommended, use with caution! For a safe alternative see and . This new slice goes from to , including but excluding . To get a mutable string slice instead, see the method. Callers of this function are responsible that three preconditions are satisfied:\n‚Ä¢ and must be byte positions within the string slice.\n‚Ä¢ and must lie on UTF-8 sequence boundaries. Deprecated since 1.29.0: use instead This is generally not recommended, use with caution! For a safe alternative see and . This new slice goes from to , including but excluding . To get an immutable string slice instead, see the method. Callers of this function are responsible that three preconditions are satisfied:\n‚Ä¢ and must be byte positions within the string slice.\n‚Ä¢ and must lie on UTF-8 sequence boundaries. Divides one string slice into two at an index. The argument, , should be a byte offset from the start of the string. It must also be on the boundary of a UTF-8 code point. The two slices returned go from the start of the string slice to , and from to the end of the string slice. To get mutable string slices instead, see the method. Panics if is not on a UTF-8 code point boundary, or if it is past the end of the last code point of the string slice. For a non-panicking alternative see . s = ; (first, last) = s.split_at( ); ( , first); ( , last); Divides one mutable string slice into two at an index. The argument, , should be a byte offset from the start of the string. It must also be on the boundary of a UTF-8 code point. The two slices returned go from the start of the string slice to , and from to the end of the string slice. To get immutable string slices instead, see the method. Panics if is not on a UTF-8 code point boundary, or if it is past the end of the last code point of the string slice. For a non-panicking alternative see . s = .to_string(); { (first, last) = s.split_at_mut( ); first.make_ascii_uppercase(); ( , first); ( , last); } ( , s); Divides one string slice into two at an index. The argument, , should be a valid byte offset from the start of the string. It must also be on the boundary of a UTF-8 code point. The method returns if that‚Äôs not the case. The two slices returned go from the start of the string slice to , and from to the end of the string slice. To get mutable string slices instead, see the method. s = ; (first, last) = s.split_at_checked( ).unwrap(); ( , first); ( , last); ( , s.split_at_checked( )); ( , s.split_at_checked( )); Divides one mutable string slice into two at an index. The argument, , should be a valid byte offset from the start of the string. It must also be on the boundary of a UTF-8 code point. The method returns if that‚Äôs not the case. The two slices returned go from the start of the string slice to , and from to the end of the string slice. To get immutable string slices instead, see the method. s = .to_string(); ((first, last)) = s.split_at_mut_checked( ) { first.make_ascii_uppercase(); ( , first); ( , last); } ( , s); ( , s.split_at_mut_checked( )); ( , s.split_at_mut_checked( )); Returns an iterator over the s of a string slice. As a string slice consists of valid UTF-8, we can iterate through a string slice by . This method returns such an iterator. It‚Äôs important to remember that represents a Unicode Scalar Value, and might not match your idea of what a ‚Äòcharacter‚Äô is. Iteration over grapheme clusters may be what you actually want. This functionality is not provided by Rust‚Äôs standard library, check crates.io instead. Remember, s might not match your intuition about characters: Returns an iterator over the s of a string slice, and their positions. As a string slice consists of valid UTF-8, we can iterate through a string slice by . This method returns an iterator of both these s, as well as their byte positions. The iterator yields tuples. The position is first, the is second. Remember, s might not match your intuition about characters: Returns an iterator over the bytes of a string slice. As a string slice consists of a sequence of bytes, we can iterate through a string slice by byte. This method returns such an iterator. The iterator returned will return string slices that are sub-slices of the original string slice, separated by any amount of whitespace. ‚ÄòWhitespace‚Äô is defined according to the terms of the Unicode Derived Core Property . If you only want to split on ASCII whitespace instead, use . All kinds of whitespace are considered: If the string is empty or all whitespace, the iterator yields no string slices: The iterator returned will return string slices that are sub-slices of the original string slice, separated by any amount of ASCII whitespace. To split by Unicode instead, use . All kinds of ASCII whitespace are considered: If the string is empty or all ASCII whitespace, the iterator yields no string slices: Returns an iterator over the lines of a string, as string slices. Lines are split at line endings that are either newlines ( ) or sequences of a carriage return followed by a line feed ( ). Line terminators are not included in the lines returned by the iterator. Note that any carriage return ( ) not immediately followed by a line feed ( ) does not split a line. These carriage returns are thereby included in the produced lines. The final line ending is optional. A string that ends with a final line ending will return the same lines as an otherwise identical string without a final line ending. The final line does not require any ending: Deprecated since 1.4.0: use lines() instead now Returns an iterator over the lines of a string. Returns an iterator of over the string encoded as UTF-16. Returns if the given pattern matches a sub-slice of this string slice. Returns if it does not. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. Returns if the given pattern matches a prefix of this string slice. Returns if it does not. The pattern can be a , in which case this function will return true if the is a prefix of this string slice. The pattern can also be a , a slice of s, or a function or closure that determines if a character matches. These will only be checked against the first character of this string slice. Look at the second example below regarding behavior for slices of s. Returns if the given pattern matches a suffix of this string slice. Returns if it does not. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. Returns the byte index of the first character of this string slice that matches the pattern. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. More complex patterns using point-free style and closures: Returns the byte index for the first character of the last match of the pattern in this string slice. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. Returns an iterator over substrings of this string slice, separated by characters matched by a pattern. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. The returned iterator will be a if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., , but not for . If the pattern allows a reverse search but its results might differ from a forward search, the method can be used. If the pattern is a slice of chars, split on each occurrence of any of the characters: If a string contains multiple contiguous separators, you will end up with empty strings in the output: Contiguous separators are separated by the empty string. Separators at the start or end of a string are neighbored by empty strings. When the empty string is used as a separator, it separates every character in the string, along with the beginning and end of the string. Contiguous separators can lead to possibly surprising behavior when whitespace is used as the separator. This code is correct: Use for this behavior. Returns an iterator over substrings of this string slice, separated by characters matched by a pattern. Differs from the iterator produced by in that leaves the matched part as the terminator of the substring. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. If the last element of the string is matched, that element will be considered the terminator of the preceding substring. That substring will be the last item returned by the iterator. Returns an iterator over substrings of the given string slice, separated by characters matched by a pattern and yielded in reverse order. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. The returned iterator requires that the pattern supports a reverse search, and it will be a if a forward/reverse search yields the same elements. For iterating from the front, the method can be used. Returns an iterator over substrings of the given string slice, separated by characters matched by a pattern. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. Equivalent to , except that the trailing substring is skipped if empty. This method can be used for string data that is terminated, rather than separated by a pattern. The returned iterator will be a if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., , but not for . If the pattern allows a reverse search but its results might differ from a forward search, the method can be used. Returns an iterator over substrings of , separated by characters matched by a pattern and yielded in reverse order. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. Equivalent to , except that the trailing substring is skipped if empty. This method can be used for string data that is terminated, rather than separated by a pattern. The returned iterator requires that the pattern supports a reverse search, and it will be double ended if a forward/reverse search yields the same elements. For iterating from the front, the method can be used. Returns an iterator over substrings of the given string slice, separated by a pattern, restricted to returning at most items. If substrings are returned, the last substring (the th substring) will contain the remainder of the string. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. The returned iterator will not be double ended, because it is not efficient to support. If the pattern allows a reverse search, the method can be used. v: Vec< str> = .splitn( , |c| c == || c == ).collect(); (v, [ , ]); Returns an iterator over substrings of this string slice, separated by a pattern, starting from the end of the string, restricted to returning at most items. If substrings are returned, the last substring (the th substring) will contain the remainder of the string. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. The returned iterator will not be double ended, because it is not efficient to support. For splitting from the front, the method can be used. v: Vec< str> = .rsplitn( , |c| c == || c == ).collect(); (v, [ , ]); Splits the string on the first occurrence of the specified delimiter and returns prefix before delimiter and suffix after delimiter. Splits the string on the last occurrence of the specified delimiter and returns prefix before delimiter and suffix after delimiter. Returns an iterator over the disjoint matches of a pattern within the given string slice. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. The returned iterator will be a if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., , but not for . If the pattern allows a reverse search but its results might differ from a forward search, the method can be used. Returns an iterator over the disjoint matches of a pattern within this string slice, yielded in reverse order. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. The returned iterator requires that the pattern supports a reverse search, and it will be a if a forward/reverse search yields the same elements. For iterating from the front, the method can be used. Returns an iterator over the disjoint matches of a pattern within this string slice as well as the index that the match starts at. For matches of within that overlap, only the indices corresponding to the first match are returned. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. The returned iterator will be a if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., , but not for . If the pattern allows a reverse search but its results might differ from a forward search, the method can be used. Returns an iterator over the disjoint matches of a pattern within , yielded in reverse order along with the index of the match. For matches of within that overlap, only the indices corresponding to the last match are returned. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. The returned iterator requires that the pattern supports a reverse search, and it will be a if a forward/reverse search yields the same elements. For iterating from the front, the method can be used. ‚ÄòWhitespace‚Äô is defined according to the terms of the Unicode Derived Core Property , which includes newlines. ‚ÄòWhitespace‚Äô is defined according to the terms of the Unicode Derived Core Property , which includes newlines. A string is a sequence of bytes. in this context means the first position of that byte string; for a left-to-right language like English or Russian, this will be left side, and for right-to-left languages like Arabic or Hebrew, this will be the right side. ‚ÄòWhitespace‚Äô is defined according to the terms of the Unicode Derived Core Property , which includes newlines. A string is a sequence of bytes. in this context means the last position of that byte string; for a left-to-right language like English or Russian, this will be right side, and for right-to-left languages like Arabic or Hebrew, this will be the left side. ‚ÄòWhitespace‚Äô is defined according to the terms of the Unicode Derived Core Property . A string is a sequence of bytes. ‚ÄòLeft‚Äô in this context means the first position of that byte string; for a language like Arabic or Hebrew which are ‚Äòright to left‚Äô rather than ‚Äòleft to right‚Äô, this will be the right side, not the left. ‚ÄòWhitespace‚Äô is defined according to the terms of the Unicode Derived Core Property . A string is a sequence of bytes. ‚ÄòRight‚Äô in this context means the last position of that byte string; for a language like Arabic or Hebrew which are ‚Äòright to left‚Äô rather than ‚Äòleft to right‚Äô, this will be the left side, not the right. Returns a string slice with all prefixes and suffixes that match a pattern repeatedly removed. The pattern can be a , a slice of s, or a function or closure that determines if a character matches. Returns a string slice with all prefixes that match a pattern repeatedly removed. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. A string is a sequence of bytes. in this context means the first position of that byte string; for a left-to-right language like English or Russian, this will be left side, and for right-to-left languages like Arabic or Hebrew, this will be the right side. If the string starts with the pattern , returns the substring after the prefix, wrapped in . Unlike , this method removes the prefix exactly once. If the string does not start with , returns . The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. If the string ends with the pattern , returns the substring before the suffix, wrapped in . Unlike , this method removes the suffix exactly once. If the string does not end with , returns . The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. Returns a string slice with all suffixes that match a pattern repeatedly removed. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. A string is a sequence of bytes. in this context means the last position of that byte string; for a left-to-right language like English or Russian, this will be right side, and for right-to-left languages like Arabic or Hebrew, this will be the left side. Returns a string slice with all prefixes that match a pattern repeatedly removed. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. A string is a sequence of bytes. ‚ÄòLeft‚Äô in this context means the first position of that byte string; for a language like Arabic or Hebrew which are ‚Äòright to left‚Äô rather than ‚Äòleft to right‚Äô, this will be the right side, not the left. Returns a string slice with all suffixes that match a pattern repeatedly removed. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. A string is a sequence of bytes. ‚ÄòRight‚Äô in this context means the last position of that byte string; for a language like Arabic or Hebrew which are ‚Äòright to left‚Äô rather than ‚Äòleft to right‚Äô, this will be the left side, not the right. Parses this string slice into another type. Because is so general, it can cause problems with type inference. As such, is one of the few times you‚Äôll see the syntax affectionately known as the ‚Äòturbofish‚Äô: . This helps the inference algorithm understand specifically which type you‚Äôre trying to parse into. can parse into any type that implements the trait. Will return if it‚Äôs not possible to parse this string slice into the desired type. Using the ‚Äòturbofish‚Äô instead of annotating : Checks if all characters in this string are within the ASCII range. If this string slice , returns it as a slice of ASCII characters, otherwise returns . Checks that two strings are an ASCII case-insensitive match. Same as , but without allocating and copying temporaries. Converts this string to its ASCII upper case equivalent in-place. ASCII letters ‚Äòa‚Äô to ‚Äòz‚Äô are mapped to ‚ÄòA‚Äô to ‚ÄòZ‚Äô, but non-ASCII letters are unchanged. To return a new uppercased value without modifying the existing one, use . Converts this string to its ASCII lower case equivalent in-place. ASCII letters ‚ÄòA‚Äô to ‚ÄòZ‚Äô are mapped to ‚Äòa‚Äô to ‚Äòz‚Äô, but non-ASCII letters are unchanged. To return a new lowercased value without modifying the existing one, use . ‚ÄòWhitespace‚Äô refers to the definition used by . ‚ÄòWhitespace‚Äô refers to the definition used by . ‚ÄòWhitespace‚Äô refers to the definition used by . Returns an iterator that escapes each char in with . Note: only extended grapheme codepoints that begin the string will be escaped. Returns an iterator that escapes each char in with . Returns an iterator that escapes each char in with . Returns the range that a substring points to. Returns if does not point within . Unlike , this does not search through the string. Instead, it uses pointer arithmetic to find where in the string is derived from. This is useful for extending and similar methods. Note that this method may return false positives (typically either or ) if is a zero-length that points at the beginning or end of another, independent, . Returns the same string as a string slice . This method is redundant when used directly on , but it helps dereferencing other string-like types to string slices, for example references to or . Replaces all matches of a pattern with another string. creates a new , and copies the data from this string slice into it. While doing so, it attempts to find matches of a pattern. If it finds any, it replaces them with the replacement string slice. When the pattern doesn‚Äôt match, it returns this string slice as : Replaces first N matches of a pattern with another string. creates a new , and copies the data from this string slice into it. While doing so, it attempts to find matches of a pattern. If it finds any, it replaces them with the replacement string slice at most times. When the pattern doesn‚Äôt match, it returns this string slice as : Returns the lowercase equivalent of this string slice, as a new . ‚ÄòLowercase‚Äô is defined according to the terms of the Unicode Derived Core Property . Since some characters can expand into multiple characters when changing the case, this function returns a instead of modifying the parameter in-place. Languages without case are not changed: Returns the uppercase equivalent of this string slice, as a new . ‚ÄòUppercase‚Äô is defined according to the terms of the Unicode Derived Core Property . Since some characters can expand into multiple characters when changing the case, this function returns a instead of modifying the parameter in-place. Scripts without case are not changed: One character can become multiple: This function will panic if the capacity would overflow. Returns a copy of this string where each character is mapped to its ASCII upper case equivalent. ASCII letters ‚Äòa‚Äô to ‚Äòz‚Äô are mapped to ‚ÄòA‚Äô to ‚ÄòZ‚Äô, but non-ASCII letters are unchanged. To uppercase the value in-place, use . To uppercase ASCII characters in addition to non-ASCII characters, use . Returns a copy of this string where each character is mapped to its ASCII lower case equivalent. ASCII letters ‚ÄòA‚Äô to ‚ÄòZ‚Äô are mapped to ‚Äòa‚Äô to ‚Äòz‚Äô, but non-ASCII letters are unchanged. To lowercase the value in-place, use . To lowercase ASCII characters in addition to non-ASCII characters, use ."
    },
    {
        "link": "https://doc.rust-lang.org/nightly/std/string/struct.String.html",
        "document": "is the most common string type. It has ownership over the contents of the string, stored in a heap-allocated buffer (see Representation). It is closely related to its borrowed counterpart, the primitive . You can create a from a literal string with : You can append a to a with the method, and append a with the method: If you have a vector of UTF-8 bytes, you can create a from it with the method: s are always valid UTF-8. If you need a non-UTF-8 string, consider . It is similar, but without the UTF-8 constraint. Because UTF-8 is a variable width encoding, s are typically smaller than an array of the same s: This raises interesting questions as to how should work. What should be here? Several options include byte indices and indices but, because of UTF-8 encoding, only byte indices would provide constant time indexing. Getting the th , for example, is available using : Next, what should return? Because indexing returns a reference to underlying data it could be , , or something else similar. Since we‚Äôre only providing one index, makes the most sense but that might not be what the user expects and can be explicitly achieved with : Due to these ambiguities/restrictions, indexing with a is simply forbidden: ‚ìò s = ; ( \"The first letter of s is {}\" , s[ ]); It is more clear, however, how should work (that is, indexing with a range). It should accept byte indices (to be constant-time) and return a which is UTF-8 encoded. This is also called ‚Äústring slicing‚Äù. Note this will panic if the byte indices provided are not character boundaries - see for more details. See the implementations for for more details on string slicing. For a non-panicking version of string slicing, see . The and methods return iterators over the bytes and codepoints of the string, respectively. To iterate over codepoints along with byte indices, use . implements , and so inherits all of ‚Äôs methods. In addition, this means that you can pass a to a function which takes a by using an ampersand ( ): This will create a from the and pass it in. This conversion is very inexpensive, and so generally, functions will accept s as arguments unless they need a for some specific reason. In certain cases Rust doesn‚Äôt have enough information to make this conversion, known as coercion. In the following example a string slice implements the trait , and the function takes anything that implements the trait. In this case Rust would need to make two implicit conversions, which Rust doesn‚Äôt have the means to do. For that reason, the following example will not compile. There are two options that would work instead. The first would be to change the line to , using the method to explicitly extract the string slice containing the string. The second way changes to . In this case we are dereferencing a to a , then referencing the back to . The second way is more idiomatic, however both work to do the conversion explicitly rather than relying on the implicit conversion. A is made up of three components: a pointer to some bytes, a length, and a capacity. The pointer points to the internal buffer which uses to store its data. The length is the number of bytes currently stored in the buffer, and the capacity is the size of the buffer in bytes. As such, the length will always be less than or equal to the capacity. This buffer is always stored on the heap. You can look at these with the , , and methods: If a has enough capacity, adding elements to it will not re-allocate. For example, consider this program: This will output the following: At first, we have no memory allocated at all, but as we append to the string, it increases its capacity appropriately. If we instead use the method to allocate the correct capacity initially: We end up with a different output: Here, there‚Äôs no need to allocate more memory inside the loop.\n\nThis length is in bytes, not s or graphemes. In other words, it might not be what a human considers the length of the string. Returns if has a length of zero bytes. Checks that -th byte is the first byte in a UTF-8 code point sequence or the end of the string. The start and end of the string (when ) are considered to be boundaries. Returns if is greater than . Finds the closest not exceeding where is . This method can help you truncate a string so that it‚Äôs still valid UTF-8, but doesn‚Äôt exceed a given number of bytes. Note that this is done purely at the character level and can still visually split graphemes, even though the underlying characters aren‚Äôt split. For example, the emoji üßë‚Äçüî¨ (scientist) could be split so that the string only includes üßë (person) instead. Finds the closest not below where is . If is greater than the length of the string, this returns the length of the string. This method is the natural complement to . See that method for more details. Converts a string slice to a byte slice. To convert the byte slice back into a string slice, use the function. The caller must ensure that the content of the slice is valid UTF-8 before the borrow ends and the underlying is used. Use of a whose contents are not valid UTF-8 is undefined behavior. As string slices are a slice of bytes, the raw pointer points to a . This pointer will be pointing to the first byte of the string slice. The caller must ensure that the returned pointer is never written to. If you need to mutate the contents of the string slice, use . As string slices are a slice of bytes, the raw pointer points to a . This pointer will be pointing to the first byte of the string slice. It is your responsibility to make sure that the string slice only gets modified in a way that it remains valid UTF-8. This is the non-panicking alternative to indexing the . Returns whenever equivalent indexing operation would panic. This is the non-panicking alternative to indexing the . Returns whenever equivalent indexing operation would panic. This is the unchecked alternative to indexing the . Callers of this function are responsible that these preconditions are satisfied:\n‚Ä¢ The starting index must not exceed the ending index;\n‚Ä¢ Indexes must be within bounds of the original slice; Failing that, the returned string slice may reference invalid memory or violate the invariants communicated by the type. This is the unchecked alternative to indexing the . Callers of this function are responsible that these preconditions are satisfied:\n‚Ä¢ The starting index must not exceed the ending index;\n‚Ä¢ Indexes must be within bounds of the original slice; Failing that, the returned string slice may reference invalid memory or violate the invariants communicated by the type. Deprecated since 1.29.0: use instead This is generally not recommended, use with caution! For a safe alternative see and . This new slice goes from to , including but excluding . To get a mutable string slice instead, see the method. Callers of this function are responsible that three preconditions are satisfied:\n‚Ä¢ and must be byte positions within the string slice.\n‚Ä¢ and must lie on UTF-8 sequence boundaries. Deprecated since 1.29.0: use instead This is generally not recommended, use with caution! For a safe alternative see and . This new slice goes from to , including but excluding . To get an immutable string slice instead, see the method. Callers of this function are responsible that three preconditions are satisfied:\n‚Ä¢ and must be byte positions within the string slice.\n‚Ä¢ and must lie on UTF-8 sequence boundaries. Divides one string slice into two at an index. The argument, , should be a byte offset from the start of the string. It must also be on the boundary of a UTF-8 code point. The two slices returned go from the start of the string slice to , and from to the end of the string slice. To get mutable string slices instead, see the method. Panics if is not on a UTF-8 code point boundary, or if it is past the end of the last code point of the string slice. For a non-panicking alternative see . s = ; (first, last) = s.split_at( ); ( , first); ( , last); Divides one mutable string slice into two at an index. The argument, , should be a byte offset from the start of the string. It must also be on the boundary of a UTF-8 code point. The two slices returned go from the start of the string slice to , and from to the end of the string slice. To get immutable string slices instead, see the method. Panics if is not on a UTF-8 code point boundary, or if it is past the end of the last code point of the string slice. For a non-panicking alternative see . s = .to_string(); { (first, last) = s.split_at_mut( ); first.make_ascii_uppercase(); ( , first); ( , last); } ( , s); Divides one string slice into two at an index. The argument, , should be a valid byte offset from the start of the string. It must also be on the boundary of a UTF-8 code point. The method returns if that‚Äôs not the case. The two slices returned go from the start of the string slice to , and from to the end of the string slice. To get mutable string slices instead, see the method. s = ; (first, last) = s.split_at_checked( ).unwrap(); ( , first); ( , last); ( , s.split_at_checked( )); ( , s.split_at_checked( )); Divides one mutable string slice into two at an index. The argument, , should be a valid byte offset from the start of the string. It must also be on the boundary of a UTF-8 code point. The method returns if that‚Äôs not the case. The two slices returned go from the start of the string slice to , and from to the end of the string slice. To get immutable string slices instead, see the method. s = .to_string(); ((first, last)) = s.split_at_mut_checked( ) { first.make_ascii_uppercase(); ( , first); ( , last); } ( , s); ( , s.split_at_mut_checked( )); ( , s.split_at_mut_checked( )); Returns an iterator over the s of a string slice. As a string slice consists of valid UTF-8, we can iterate through a string slice by . This method returns such an iterator. It‚Äôs important to remember that represents a Unicode Scalar Value, and might not match your idea of what a ‚Äòcharacter‚Äô is. Iteration over grapheme clusters may be what you actually want. This functionality is not provided by Rust‚Äôs standard library, check crates.io instead. Remember, s might not match your intuition about characters: Returns an iterator over the s of a string slice, and their positions. As a string slice consists of valid UTF-8, we can iterate through a string slice by . This method returns an iterator of both these s, as well as their byte positions. The iterator yields tuples. The position is first, the is second. Remember, s might not match your intuition about characters: Returns an iterator over the bytes of a string slice. As a string slice consists of a sequence of bytes, we can iterate through a string slice by byte. This method returns such an iterator. The iterator returned will return string slices that are sub-slices of the original string slice, separated by any amount of whitespace. ‚ÄòWhitespace‚Äô is defined according to the terms of the Unicode Derived Core Property . If you only want to split on ASCII whitespace instead, use . All kinds of whitespace are considered: If the string is empty or all whitespace, the iterator yields no string slices: The iterator returned will return string slices that are sub-slices of the original string slice, separated by any amount of ASCII whitespace. To split by Unicode instead, use . All kinds of ASCII whitespace are considered: If the string is empty or all ASCII whitespace, the iterator yields no string slices: Returns an iterator over the lines of a string, as string slices. Lines are split at line endings that are either newlines ( ) or sequences of a carriage return followed by a line feed ( ). Line terminators are not included in the lines returned by the iterator. Note that any carriage return ( ) not immediately followed by a line feed ( ) does not split a line. These carriage returns are thereby included in the produced lines. The final line ending is optional. A string that ends with a final line ending will return the same lines as an otherwise identical string without a final line ending. The final line does not require any ending: Deprecated since 1.4.0: use lines() instead now Returns an iterator over the lines of a string. Returns an iterator of over the string encoded as native endian UTF-16 (without byte-order mark). Returns if the given pattern matches a sub-slice of this string slice. Returns if it does not. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. Returns if the given pattern matches a prefix of this string slice. Returns if it does not. The pattern can be a , in which case this function will return true if the is a prefix of this string slice. The pattern can also be a , a slice of s, or a function or closure that determines if a character matches. These will only be checked against the first character of this string slice. Look at the second example below regarding behavior for slices of s. Returns if the given pattern matches a suffix of this string slice. Returns if it does not. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. Returns the byte index of the first character of this string slice that matches the pattern. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. More complex patterns using point-free style and closures: Returns the byte index for the first character of the last match of the pattern in this string slice. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. Returns an iterator over substrings of this string slice, separated by characters matched by a pattern. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. The returned iterator will be a if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., , but not for . If the pattern allows a reverse search but its results might differ from a forward search, the method can be used. If the pattern is a slice of chars, split on each occurrence of any of the characters: If a string contains multiple contiguous separators, you will end up with empty strings in the output: Contiguous separators are separated by the empty string. Separators at the start or end of a string are neighbored by empty strings. When the empty string is used as a separator, it separates every character in the string, along with the beginning and end of the string. Contiguous separators can lead to possibly surprising behavior when whitespace is used as the separator. This code is correct: Use for this behavior. Returns an iterator over substrings of this string slice, separated by characters matched by a pattern. Differs from the iterator produced by in that leaves the matched part as the terminator of the substring. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. If the last element of the string is matched, that element will be considered the terminator of the preceding substring. That substring will be the last item returned by the iterator. Returns an iterator over substrings of the given string slice, separated by characters matched by a pattern and yielded in reverse order. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. The returned iterator requires that the pattern supports a reverse search, and it will be a if a forward/reverse search yields the same elements. For iterating from the front, the method can be used. Returns an iterator over substrings of the given string slice, separated by characters matched by a pattern. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. Equivalent to , except that the trailing substring is skipped if empty. This method can be used for string data that is terminated, rather than separated by a pattern. The returned iterator will be a if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., , but not for . If the pattern allows a reverse search but its results might differ from a forward search, the method can be used. Returns an iterator over substrings of , separated by characters matched by a pattern and yielded in reverse order. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. Equivalent to , except that the trailing substring is skipped if empty. This method can be used for string data that is terminated, rather than separated by a pattern. The returned iterator requires that the pattern supports a reverse search, and it will be double ended if a forward/reverse search yields the same elements. For iterating from the front, the method can be used. Returns an iterator over substrings of the given string slice, separated by a pattern, restricted to returning at most items. If substrings are returned, the last substring (the th substring) will contain the remainder of the string. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. The returned iterator will not be double ended, because it is not efficient to support. If the pattern allows a reverse search, the method can be used. v: Vec< str> = .splitn( , |c| c == || c == ).collect(); (v, [ , ]); Returns an iterator over substrings of this string slice, separated by a pattern, starting from the end of the string, restricted to returning at most items. If substrings are returned, the last substring (the th substring) will contain the remainder of the string. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. The returned iterator will not be double ended, because it is not efficient to support. For splitting from the front, the method can be used. v: Vec< str> = .rsplitn( , |c| c == || c == ).collect(); (v, [ , ]); Splits the string on the first occurrence of the specified delimiter and returns prefix before delimiter and suffix after delimiter. Splits the string on the last occurrence of the specified delimiter and returns prefix before delimiter and suffix after delimiter. Returns an iterator over the disjoint matches of a pattern within the given string slice. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. The returned iterator will be a if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., , but not for . If the pattern allows a reverse search but its results might differ from a forward search, the method can be used. Returns an iterator over the disjoint matches of a pattern within this string slice, yielded in reverse order. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. The returned iterator requires that the pattern supports a reverse search, and it will be a if a forward/reverse search yields the same elements. For iterating from the front, the method can be used. Returns an iterator over the disjoint matches of a pattern within this string slice as well as the index that the match starts at. For matches of within that overlap, only the indices corresponding to the first match are returned. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. The returned iterator will be a if the pattern allows a reverse search and forward/reverse search yields the same elements. This is true for, e.g., , but not for . If the pattern allows a reverse search but its results might differ from a forward search, the method can be used. Returns an iterator over the disjoint matches of a pattern within , yielded in reverse order along with the index of the match. For matches of within that overlap, only the indices corresponding to the last match are returned. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. The returned iterator requires that the pattern supports a reverse search, and it will be a if a forward/reverse search yields the same elements. For iterating from the front, the method can be used. ‚ÄòWhitespace‚Äô is defined according to the terms of the Unicode Derived Core Property , which includes newlines. ‚ÄòWhitespace‚Äô is defined according to the terms of the Unicode Derived Core Property , which includes newlines. A string is a sequence of bytes. in this context means the first position of that byte string; for a left-to-right language like English or Russian, this will be left side, and for right-to-left languages like Arabic or Hebrew, this will be the right side. ‚ÄòWhitespace‚Äô is defined according to the terms of the Unicode Derived Core Property , which includes newlines. A string is a sequence of bytes. in this context means the last position of that byte string; for a left-to-right language like English or Russian, this will be right side, and for right-to-left languages like Arabic or Hebrew, this will be the left side. ‚ÄòWhitespace‚Äô is defined according to the terms of the Unicode Derived Core Property . A string is a sequence of bytes. ‚ÄòLeft‚Äô in this context means the first position of that byte string; for a language like Arabic or Hebrew which are ‚Äòright to left‚Äô rather than ‚Äòleft to right‚Äô, this will be the right side, not the left. ‚ÄòWhitespace‚Äô is defined according to the terms of the Unicode Derived Core Property . A string is a sequence of bytes. ‚ÄòRight‚Äô in this context means the last position of that byte string; for a language like Arabic or Hebrew which are ‚Äòright to left‚Äô rather than ‚Äòleft to right‚Äô, this will be the left side, not the right. Returns a string slice with all prefixes and suffixes that match a pattern repeatedly removed. The pattern can be a , a slice of s, or a function or closure that determines if a character matches. Returns a string slice with all prefixes that match a pattern repeatedly removed. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. A string is a sequence of bytes. in this context means the first position of that byte string; for a left-to-right language like English or Russian, this will be left side, and for right-to-left languages like Arabic or Hebrew, this will be the right side. If the string starts with the pattern , returns the substring after the prefix, wrapped in . Unlike , this method removes the prefix exactly once. If the string does not start with , returns . The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. If the string ends with the pattern , returns the substring before the suffix, wrapped in . Unlike , this method removes the suffix exactly once. If the string does not end with , returns . The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. Returns a string slice with all suffixes that match a pattern repeatedly removed. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. A string is a sequence of bytes. in this context means the last position of that byte string; for a left-to-right language like English or Russian, this will be right side, and for right-to-left languages like Arabic or Hebrew, this will be the left side. Returns a string slice with all prefixes that match a pattern repeatedly removed. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. A string is a sequence of bytes. ‚ÄòLeft‚Äô in this context means the first position of that byte string; for a language like Arabic or Hebrew which are ‚Äòright to left‚Äô rather than ‚Äòleft to right‚Äô, this will be the right side, not the left. Returns a string slice with all suffixes that match a pattern repeatedly removed. The pattern can be a , , a slice of s, or a function or closure that determines if a character matches. A string is a sequence of bytes. ‚ÄòRight‚Äô in this context means the last position of that byte string; for a language like Arabic or Hebrew which are ‚Äòright to left‚Äô rather than ‚Äòleft to right‚Äô, this will be the left side, not the right. Parses this string slice into another type. Because is so general, it can cause problems with type inference. As such, is one of the few times you‚Äôll see the syntax affectionately known as the ‚Äòturbofish‚Äô: . This helps the inference algorithm understand specifically which type you‚Äôre trying to parse into. can parse into any type that implements the trait. Will return if it‚Äôs not possible to parse this string slice into the desired type. Using the ‚Äòturbofish‚Äô instead of annotating : Checks if all characters in this string are within the ASCII range. If this string slice , returns it as a slice of ASCII characters, otherwise returns . Checks that two strings are an ASCII case-insensitive match. Same as , but without allocating and copying temporaries. Converts this string to its ASCII upper case equivalent in-place. ASCII letters ‚Äòa‚Äô to ‚Äòz‚Äô are mapped to ‚ÄòA‚Äô to ‚ÄòZ‚Äô, but non-ASCII letters are unchanged. To return a new uppercased value without modifying the existing one, use . Converts this string to its ASCII lower case equivalent in-place. ASCII letters ‚ÄòA‚Äô to ‚ÄòZ‚Äô are mapped to ‚Äòa‚Äô to ‚Äòz‚Äô, but non-ASCII letters are unchanged. To return a new lowercased value without modifying the existing one, use . ‚ÄòWhitespace‚Äô refers to the definition used by . ‚ÄòWhitespace‚Äô refers to the definition used by . ‚ÄòWhitespace‚Äô refers to the definition used by . Returns an iterator that escapes each char in with . Note: only extended grapheme codepoints that begin the string will be escaped. Returns an iterator that escapes each char in with . Returns an iterator that escapes each char in with . Returns the range that a substring points to. Returns if does not point within . Unlike , this does not search through the string. Instead, it uses pointer arithmetic to find where in the string is derived from. This is useful for extending and similar methods. Note that this method may return false positives (typically either or ) if is a zero-length that points at the beginning or end of another, independent, . Returns the same string as a string slice . This method is redundant when used directly on , but it helps dereferencing other string-like types to string slices, for example references to or . Replaces all matches of a pattern with another string. creates a new , and copies the data from this string slice into it. While doing so, it attempts to find matches of a pattern. If it finds any, it replaces them with the replacement string slice. When the pattern doesn‚Äôt match, it returns this string slice as : Replaces first N matches of a pattern with another string. creates a new , and copies the data from this string slice into it. While doing so, it attempts to find matches of a pattern. If it finds any, it replaces them with the replacement string slice at most times. When the pattern doesn‚Äôt match, it returns this string slice as : Returns the lowercase equivalent of this string slice, as a new . ‚ÄòLowercase‚Äô is defined according to the terms of the Unicode Derived Core Property . Since some characters can expand into multiple characters when changing the case, this function returns a instead of modifying the parameter in-place. Languages without case are not changed: Returns the uppercase equivalent of this string slice, as a new . ‚ÄòUppercase‚Äô is defined according to the terms of the Unicode Derived Core Property . Since some characters can expand into multiple characters when changing the case, this function returns a instead of modifying the parameter in-place. Scripts without case are not changed: One character can become multiple: This function will panic if the capacity would overflow. Returns a copy of this string where each character is mapped to its ASCII upper case equivalent. ASCII letters ‚Äòa‚Äô to ‚Äòz‚Äô are mapped to ‚ÄòA‚Äô to ‚ÄòZ‚Äô, but non-ASCII letters are unchanged. To uppercase the value in-place, use . To uppercase ASCII characters in addition to non-ASCII characters, use . Returns a copy of this string where each character is mapped to its ASCII lower case equivalent. ASCII letters ‚ÄòA‚Äô to ‚ÄòZ‚Äô are mapped to ‚Äòa‚Äô to ‚Äòz‚Äô, but non-ASCII letters are unchanged. To lowercase the value in-place, use . To lowercase ASCII characters in addition to non-ASCII characters, use ."
    },
    {
        "link": "https://doc.rust-lang.org/std/primitive.str.html",
        "document": ""
    },
    {
        "link": "https://rustjobs.dev/blog/how-to-split-strings-in-rust",
        "document": "Splitting a string in Rust is a straightforward task, thanks to the language's robust standard library. The type in Rust provides several methods to split a string in various ways. Let's explore some common methods with code examples.\n\nThe simplest way to split a string is by a specific character using the method. It returns an iterator over the substrings.\n\nTo split by a string pattern rather than a single character, you can use the method just as easily.\n\nFor more complex splitting logic, you can pass a closure to that determines the split logic.\n\nThe method is a convenient way to split a string by whitespace.\n\nSometimes you might want to split a string into two parts at the first occurrence of a pattern. The method is perfect for this.\n\nSplitting and Keeping the Pattern in the Result\n\nRust also allows splitting without omitting the pattern in the resulting substrings. The method includes the pattern in the substrings after splitting.\n\nBe aware that methods will include empty substrings if there are consecutive split patterns.\n\nTo avoid empty strings, you can use to exclude them.\n\nRust provides a variety of ways to split strings, accommodating both simple and complex scenarios. By leveraging these methods, you can manipulate and process strings effectively in your Rust applications. Remember to convert the resulting iterator into a collection type like a if you need to work with the results directly."
    },
    {
        "link": "https://doc.rust-lang.org/book/ch13-01-closures.html",
        "document": "Rust‚Äôs closures are anonymous functions you can save in a variable or pass as arguments to other functions. You can create the closure in one place and then call the closure elsewhere to evaluate it in a different context. Unlike functions, closures can capture values from the scope in which they‚Äôre defined. We‚Äôll demonstrate how these closure features allow for code reuse and behavior customization.\n\nWe‚Äôll first examine how we can use closures to capture values from the environment they‚Äôre defined in for later use. Here‚Äôs the scenario: Every so often, our t-shirt company gives away an exclusive, limited-edition shirt to someone on our mailing list as a promotion. People on the mailing list can optionally add their favorite color to their profile. If the person chosen for a free shirt has their favorite color set, they get that color shirt. If the person hasn‚Äôt specified a favorite color, they get whatever color the company currently has the most of.\n\nThere are many ways to implement this. For this example, we‚Äôre going to use an enum called that has the variants and (limiting the number of colors available for simplicity). We represent the company‚Äôs inventory with an struct that has a field named that contains a representing the shirt colors currently in stock. The method defined on gets the optional shirt color preference of the free shirt winner, and returns the shirt color the person will get. This setup is shown in Listing 13-1:\n\nThe defined in has two blue shirts and one red shirt remaining to distribute for this limited-edition promotion. We call the method for a user with a preference for a red shirt and a user without any preference.\n\nAgain, this code could be implemented in many ways, and here, to focus on closures, we‚Äôve stuck to concepts you‚Äôve already learned except for the body of the method that uses a closure. In the method, we get the user preference as a parameter of type and call the method on . The method on is defined by the standard library. It takes one argument: a closure without any arguments that returns a value (the same type stored in the variant of the , in this case ). If the is the variant, returns the value from within the . If the is the variant, calls the closure and returns the value returned by the closure.\n\nWe specify the closure expression as the argument to . This is a closure that takes no parameters itself (if the closure had parameters, they would appear between the two vertical bars). The body of the closure calls . We‚Äôre defining the closure here, and the implementation of will evaluate the closure later if the result is needed.\n\nOne interesting aspect here is that we‚Äôve passed a closure that calls on the current instance. The standard library didn‚Äôt need to know anything about the or types we defined, or the logic we want to use in this scenario. The closure captures an immutable reference to the instance and passes it with the code we specify to the method. Functions, on the other hand, are not able to capture their environment in this way.\n\nThere are more differences between functions and closures. Closures don‚Äôt usually require you to annotate the types of the parameters or the return value like functions do. Type annotations are required on functions because the types are part of an explicit interface exposed to your users. Defining this interface rigidly is important for ensuring that everyone agrees on what types of values a function uses and returns. Closures, on the other hand, aren‚Äôt used in an exposed interface like this: they‚Äôre stored in variables and used without naming them and exposing them to users of our library.\n\nClosures are typically short and relevant only within a narrow context rather than in any arbitrary scenario. Within these limited contexts, the compiler can infer the types of the parameters and the return type, similar to how it‚Äôs able to infer the types of most variables (there are rare cases where the compiler needs closure type annotations too).\n\nAs with variables, we can add type annotations if we want to increase explicitness and clarity at the cost of being more verbose than is strictly necessary. Annotating the types for a closure would look like the definition shown in Listing 13-2. In this example, we‚Äôre defining a closure and storing it in a variable rather than defining the closure in the spot we pass it as an argument as we did in Listing 13-1.\n\nWith type annotations added, the syntax of closures looks more similar to the syntax of functions. Here we define a function that adds 1 to its parameter and a closure that has the same behavior, for comparison. We‚Äôve added some spaces to line up the relevant parts. This illustrates how closure syntax is similar to function syntax except for the use of pipes and the amount of syntax that is optional:\n\nThe first line shows a function definition, and the second line shows a fully annotated closure definition. In the third line, we remove the type annotations from the closure definition. In the fourth line, we remove the brackets, which are optional because the closure body has only one expression. These are all valid definitions that will produce the same behavior when they‚Äôre called. The and lines require the closures to be evaluated to be able to compile because the types will be inferred from their usage. This is similar to needing either type annotations or values of some type to be inserted into the for Rust to be able to infer the type.\n\nFor closure definitions, the compiler will infer one concrete type for each of their parameters and for their return value. For instance, Listing 13-3 shows the definition of a short closure that just returns the value it receives as a parameter. This closure isn‚Äôt very useful except for the purposes of this example. Note that we haven‚Äôt added any type annotations to the definition. Because there are no type annotations, we can call the closure with any type, which we‚Äôve done here with the first time. If we then try to call with an integer, we‚Äôll get an error.\n\nThe compiler gives us this error:\n\nThe first time we call with the value, the compiler infers the type of and the return type of the closure to be . Those types are then locked into the closure in , and we get a type error when we next try to use a different type with the same closure.\n\nClosures can capture values from their environment in three ways, which directly map to the three ways a function can take a parameter: borrowing immutably, borrowing mutably, and taking ownership. The closure will decide which of these to use based on what the body of the function does with the captured values.\n\nIn Listing 13-4, we define a closure that captures an immutable reference to the vector named because it only needs an immutable reference to print the value:\n\nThis example also illustrates that a variable can bind to a closure definition, and we can later call the closure by using the variable name and parentheses as if the variable name were a function name.\n\nBecause we can have multiple immutable references to at the same time, is still accessible from the code before the closure definition, after the closure definition but before the closure is called, and after the closure is called. This code compiles, runs, and prints:\n\nNext, in Listing 13-5, we change the closure body so that it adds an element to the vector. The closure now captures a mutable reference:\n\nNote that there‚Äôs no longer a between the definition and the call of the closure: when is defined, it captures a mutable reference to . We don‚Äôt use the closure again after the closure is called, so the mutable borrow ends. Between the closure definition and the closure call, an immutable borrow to print isn‚Äôt allowed because no other borrows are allowed when there‚Äôs a mutable borrow. Try adding a there to see what error message you get!\n\nIf you want to force the closure to take ownership of the values it uses in the environment even though the body of the closure doesn‚Äôt strictly need ownership, you can use the keyword before the parameter list.\n\nThis technique is mostly useful when passing a closure to a new thread to move the data so that it‚Äôs owned by the new thread. We‚Äôll discuss threads and why you would want to use them in detail in Chapter 16 when we talk about concurrency, but for now, let‚Äôs briefly explore spawning a new thread using a closure that needs the keyword. Listing 13-6 shows Listing 13-4 modified to print the vector in a new thread rather than in the main thread:\n\nWe spawn a new thread, giving the thread a closure to run as an argument. The closure body prints out the list. In Listing 13-4, the closure only captured using an immutable reference because that‚Äôs the least amount of access to needed to print it. In this example, even though the closure body still only needs an immutable reference, we need to specify that should be moved into the closure by putting the keyword at the beginning of the closure definition. The new thread might finish before the rest of the main thread finishes, or the main thread might finish first. If the main thread maintained ownership of but ended before the new thread did and dropped , the immutable reference in the thread would be invalid. Therefore, the compiler requires that be moved into the closure given to the new thread so the reference will be valid. Try removing the keyword or using in the main thread after the closure is defined to see what compiler errors you get!\n\nMoving Captured Values Out of Closures and the Traits\n\nOnce a closure has captured a reference or captured ownership of a value from the environment where the closure is defined (thus affecting what, if anything, is moved into the closure), the code in the body of the closure defines what happens to the references or values when the closure is evaluated later (thus affecting what, if anything, is moved out of the closure). A closure body can do any of the following: move a captured value out of the closure, mutate the captured value, neither move nor mutate the value, or capture nothing from the environment to begin with.\n\nThe way a closure captures and handles values from the environment affects which traits the closure implements, and traits are how functions and structs can specify what kinds of closures they can use. Closures will automatically implement one, two, or all three of these traits, in an additive fashion, depending on how the closure‚Äôs body handles the values:\n‚Ä¢ applies to closures that can be called once. All closures implement at least this trait, because all closures can be called. A closure that moves captured values out of its body will only implement and none of the other traits, because it can only be called once.\n‚Ä¢ applies to closures that don‚Äôt move captured values out of their body, but that might mutate the captured values. These closures can be called more than once.\n‚Ä¢ applies to closures that don‚Äôt move captured values out of their body and that don‚Äôt mutate captured values, as well as closures that capture nothing from their environment. These closures can be called more than once without mutating their environment, which is important in cases such as calling a closure multiple times concurrently.\n\nLet‚Äôs look at the definition of the method on that we used in Listing 13-1:\n\nRecall that is the generic type representing the type of the value in the variant of an . That type is also the return type of the function: code that calls on an , for example, will get a .\n\nNext, notice that the function has the additional generic type parameter . The type is the type of the parameter named , which is the closure we provide when calling .\n\nThe trait bound specified on the generic type is , which means must be able to be called once, take no arguments, and return a . Using in the trait bound expresses the constraint that is only going to call at most one time. In the body of , we can see that if the is , won‚Äôt be called. If the is , will be called once. Because all closures implement , accepts all three kinds of closures and is as flexible as it can be.\n\nNow let‚Äôs look at the standard library method defined on slices, to see how that differs from and why uses instead of for the trait bound. The closure gets one argument in the form of a reference to the current item in the slice being considered, and returns a value of type that can be ordered. This function is useful when you want to sort a slice by a particular attribute of each item. In Listing 13-7, we have a list of instances and we use to order them by their attribute from low to high:\n\nThe reason is defined to take an closure is that it calls the closure multiple times: once for each item in the slice. The closure doesn‚Äôt capture, mutate, or move out anything from its environment, so it meets the trait bound requirements.\n\nIn contrast, Listing 13-8 shows an example of a closure that implements just the trait, because it moves a value out of the environment. The compiler won‚Äôt let us use this closure with :\n\nThis is a contrived, convoluted way (that doesn‚Äôt work) to try and count the number of times calls the closure when sorting . This code attempts to do this counting by pushing ‚Äîa from the closure‚Äôs environment‚Äîinto the vector. The closure captures then moves out of the closure by transferring ownership of to the vector. This closure can be called once; trying to call it a second time wouldn‚Äôt work because would no longer be in the environment to be pushed into again! Therefore, this closure only implements . When we try to compile this code, we get this error that can‚Äôt be moved out of the closure because the closure must implement :\n\nThe error points to the line in the closure body that moves out of the environment. To fix this, we need to change the closure body so that it doesn‚Äôt move values out of the environment. To count the number of times the closure is called, keeping a counter in the environment and incrementing its value in the closure body is a more straightforward way to calculate that. The closure in Listing 13-9 works with because it is only capturing a mutable reference to the counter and can therefore be called more than once:\n\nThe traits are important when defining or using functions or types that make use of closures. In the next section, we‚Äôll discuss iterators. Many iterator methods take closure arguments, so keep these closure details in mind as we continue!"
    },
    {
        "link": "https://doc.rust-lang.org/rust-by-example/fn/closures.html",
        "document": "Closures are functions that can capture the enclosing environment. For example, a closure that captures the variable:\n\nThe syntax and capabilities of closures make them very convenient for on the fly usage. Calling a closure is exactly like calling a function. However, both input and return types can be inferred and input variable names must be specified.\n‚Ä¢ using instead of around input variables.\n‚Ä¢ the ability to capture the outer environment variables."
    },
    {
        "link": "https://tomas-svojanovsky.medium.com/comprehensive-guide-to-functions-and-closures-in-rust-5a180c386b77",
        "document": ""
    },
    {
        "link": "https://dev.to/francescoxx/closures-in-rust-2kcm",
        "document": "In this lesson, we will introduce Closures in Rust, a flexible feature that allows functions to capture variables from their environment, making them highly useful for tasks like functional programming, callbacks, and lazy evaluation.\n\nClosures are blocks of code that can be assigned to variables, passed to other functions, or returned from functions. They are similar to regular functions, but closures have one key advantage: they can capture variables from the scope in which they are defined. This allows them to be more flexible and powerful than traditional functions.\n\nAll the code is available on Github (link in the video description)\n‚Ä¢ Anonymous Functions: Closures are unnamed functions that can be stored in variables or passed to other functions.\n‚Ä¢ Capturing Environment: Closures can capture values from their surrounding scope by borrowing, mutably borrowing, or taking ownership of them.\n‚Ä¢ Type Inference: Rust infers the types of parameters and return types in most closures, so explicit type annotations are often unnecessary.\n‚Ä¢ Flexibility: Closures can be stored as function pointers or as traits like , , and , depending on how they capture variables.\n\nClosures in Rust are defined using the syntax. The represent the arguments the closure takes, and the is the code that the closure executes. Here's an example of a closure that takes no arguments and returns a string:\n\n\n\nHere's a more complex example with two arguments:\n\n\n\nRust can infer the types of a and b in most cases, so you can simplify this to:\n\n\n\nHere's an example of a closure that adds two numbers:\n\n\n\nIn this example, the closure add takes two arguments, a and b, and returns their sum. The |a, b| syntax defines the closure's arguments, and the body is simply a + b.\n\nClosures can capture variables from their environment in three different ways: by borrowing (immutably or mutably) or by taking ownership of the variable (moving it). This behavior is determined by how the closure is used.\n\nIn this case, the closure borrows a variable immutably, meaning it can read the variable but not modify it.\n\n\n\nIn this example, the closure closure borrows the variable x immutably, allowing it to read x but not modify it.\n\nThe closure borrows a variable mutably, allowing it to both read and modify the variable.\n\nIn this example, the closure mutably borrows the variable x, allowing it to modify the value of x.\n\nThe closure can take ownership of a variable, meaning the variable is moved into the closure and can no longer be used outside of it.\n\nIn this example, the closure consume_x takes ownership of the variable x by using the move keyword. After being moved into the closure, x cannot be used outside the closure.\n\nRust provides three traits that represent how closures capture variables from their environment:\n‚Ä¢ Fn: The closure captures variables immutably, allowing it to be called multiple times.\n‚Ä¢ FnMut: The closure captures variables mutably, meaning it can modify them. It can also be called multiple times.\n‚Ä¢ FnOnce: The closure takes ownership of captured variables and can only be called once because it consumes the environment.\n\nRust automatically chooses the most appropriate trait depending on how the closure is used.\n\nClosures can be passed as arguments to functions, enabling custom behavior within those functions.\n\nThis is often used in scenarios where you want to pass logic (in the form of a closure) to a function that can then execute it.\n\nIn this example, the apply function accepts a closure f as an argument.\n\nThe closure must implement the Fn(i32) -> i32 trait, which means it takes an i32 as input and returns an i32.\n\nThe double closure doubles its argument and is passed to apply, which calls it with the value 10.\n\nWhile closures and functions share similarities, they have important differences:\n‚Ä¢ None Capturing Variables: Closures can capture variables from the surrounding scope, whereas functions cannot.\n‚Ä¢ None Syntax: Closures are defined using the |args| body syntax, while functions use the fn keyword.\n‚Ä¢ None Flexibility: Closures can be stored in variables, passed around as arguments, and returned from other functions, giving them more flexibility than traditional functions.\n‚Ä¢ None Memory Usage: Closures that capture variables from their environment may use more memory than regular functions because they store those captured values.\n\nClosures in Rust are a powerful feature that allows you to capture variables from their environment and create flexible, reusable code blocks. By understanding the different ways closures capture variables (borrowing, mutably borrowing, or moving), you can make the most of Rust's closures in scenarios where traditional functions might fall short.\n\nClosures are often used in functional programming, callback functions, and iterator chains, making them a vital part of mastering Rust.\n\nAll the code is available on Github (link in the video description)\n\nIf you have any comments, just drop them below.\n\nYou can also find me here: https://francescociulla.com"
    },
    {
        "link": "https://reddit.com/r/learnrust/comments/ongxa7/explanation_closures_in_rust",
        "document": "I wrote this explanation of closures in Rust for someone on this sub and figured it might also be useful for someone else.\n\nClosures are anonymous functions that can capture their environment.\n\nThey have the following syntax:\n\nInside the you can specify the arguments that your closure accepts, and next to it you specify the expression (can be a block wrapped in ) that the closure returns, and you can call it as a ‚Äúnormal‚Äù function, e.g.:\n\nUnlike with functions, you don‚Äôt need to specify return type for a closure, and you may, but don‚Äôt have to, specify argument types if they can be inferred. That‚Äôs why closures are often used with APIs that need you to provide a function of any kind, factory, filter, middleware and so on.\n\nThe ‚Äúsuperpower‚Äù of closures is that they can capture values from their scope:\n\nThis can be useful when you want to ‚Äúprepackage‚Äù a function with some values and then pass it to an API that will provide additional arguments. For example:\n\nHere we pass a closure to the API and it calls the closure with a different item each time, however the value is bound to the closure.\n\nInternally, closures consist of the actual callable function part, and captured values. It might help to actually think of closures as structs rather than functions. Consider the following example:\n\nWithout closures, we could do something similar like this:\n\nClosures are roughly speaking just syntactic sugar. Closures automatically detect what values from their scope they need to capture, and whether they need a mutable or shared reference to these values, based on how you use the values. You can also use the keyword to force the function to take ownership of each value that it captures, instead of taking reference. Then the following code:\n\nWould desugar roughly to this:\n\nThe downside is of cause that such closure can only be called once, because when it‚Äôs called it consumes all the values that it captured.\n\nThe final gotcha with closures is that most APIs that accept them are generic. So instead of stuff like this:\n\n‚Ä¶ you will see stuff like this:\n\nThis is because different closures can capture different sets of values, and therefore be of different types and sizes. But the only thing that the API cares about is a call signature. For example, the method doesn‚Äôt care which particular closure with which particular captured values you want to pass to it. It just cares that it is something that can be called with a single argument of type , and returns a boolean."
    }
]