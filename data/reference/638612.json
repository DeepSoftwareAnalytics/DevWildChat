[
    {
        "link": "https://docs.unity3d.com/6000.0/Documentation/ScriptReference/ParticleSystem.html",
        "document": "General parameters \n\n \n\nThe Particle System's general parameters are kept inside a special Main module. These parameters are visible in the Inspector above all the other modules:\n\n\n\n \n\n\n\nIn script, these parameters are accessible through ParticleSystem.main.\n\n\n\nAccessing module properties\n\n\n\nParticle System properties are grouped by the module they belong to, such as ParticleSystem.noise and ParticleSystem.emission. These properties are structs, but do not behave like normal C# structs. They are simply interfaces directly into the native code, so it is important to know how to use them, compared to a normal C# struct.\n\n\n\nThe key difference is that it is not necessary to assign the struct back to the Particle System component. When you set any property on a module struct, Unity immediately assigns that value to the Particle System.\n\n\n\nAlso, because each module is a struct, you must cache it in a local variable before you can assign any new values to the module. For example, instead of:\n\n \n\n write:\n\n \n\n emission.enabled = true; // Applies the new value directly to the Particle System \n\n\n\n\n\nModule effect multipliers\n\n\n\nEvery module has special multiplier properties that allow you to change the overall effect of a curve without having to edit the curve itself. These multiplier properties are all named after the curve they affect - for instance ParticleSystem.emission.rateMultiplier controls the overall effect of ParticleSystem.emission.rate in a given system.\n\n\n\nConstant value shorthand\n\n\n\nParameters support a shorthand notation for simple constant values. To set a constant value for a parameter, all you need to do is assign a number to it. It is not necessary to create a MinMaxCurve or MinMaxGradient object in the ParticleSystemCurveMode.Constant mode.\n\n\n\nFor example, instead of:\n\n \n\n \n\n write:\n\n \n\n \n\n\n\nPerformance note: When setting properties on particle modules, the settings are passed immediately into native code. This gives the best performance. This means that setting properties on a module struct doesn't set something in script that requires setting back to the Particle System; it all happens automatically.\n\n\n\nAdditional resources: Particle."
    },
    {
        "link": "https://docs.unity3d.com/2023.1/Documentation/Manual/PartSysColorOverLifeModule.html",
        "document": "This module specifies how a particle’s color and transparency changes over its lifetime.\n\nUsing the Color over Lifetime module\n\nThis module is part of the Particle SystemA component that simulates fluid entities such as liquids, clouds and flames by generating and animating large numbers of small 2D images in the scene. More info\n\nSee in Glossary component. When you create a new Particle System GameObjectThe fundamental object in Unity scenes, which can represent characters, props, scenery, cameras, waypoints, and more. A GameObject’s functionality is defined by the Components attached to it. More info\n\nSee in Glossary, or add a Particle System component to an exiting GameObject, Unity adds the Color over Lifetime module to the Particle System. By default, Unity disables this module. To create a new Particle System and enable this module:\n• In the Inspector \n\n A Unity window that displays information about the currently selected GameObject, asset or project settings, allowing you to inspect and edit the values. More info , find the Particle System component.\n• In the Particle System component, find the Color over Lifetime module fold-out.\n• To the left of the fold-out header, enable the checkbox.\n\nSince this module is part of the Particle System component, you access it through the ParticleSystem class. For information on how to access it and change values at runtime, see the Color over Lifetime module API documentation.\n\nFor some properties in this section, you can use different modes to set their value. For information on the modes you can use, see Varying properties over time.\n\nMany types of natural and fantastical particles vary in color over time, and so this property has many uses. For example, white hot sparks will cool as they pass through the air and a magic spell might burst into a rainbow of colors. Equally important, though, is the variation of alpha (transparency). It is very common for particles to burn out, fade or dissipate as they reach the end of their lifetime (for example, hot sparks, fireworks and smoke particles) and a simple diminishing gradient produces this effect.\n\nWhen also using the Start Color property, this module multiples the 2 colors together, to get the final particle color."
    },
    {
        "link": "https://discussions.unity.com/t/trying-to-change-the-color-of-a-particle-system-through-code/887239",
        "document": ""
    },
    {
        "link": "https://discussions.unity.com/t/how-to-adjust-alpha-color-of-particle-system-main-module-during-runtime-shuriken/206640",
        "document": ""
    },
    {
        "link": "https://discussions.unity.com/t/modify-a-particle-system-with-c/688328",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/74438240/c-sharp-unity-3d-how-to-use-a-boxcollider-to-check-if-a-position-is-inside-of",
        "document": "I am using Poisson Sampling technique to spawn some trees, but to make it easier I want to use a box Collider to easily define the areas where I want to spawn the trees.\n\nIm was using a Rect because its easy and it was being used by the Sampler by default to check if a value is inside of it using\n\nHowever the Rect is apparently a 2D UI element, thats only using x, y coordinates, width and height, no depth.\n\nI however want to use a 3D BoxCollider to easily visualize and change the size of the Area that I want to use, in my case for spawning trees inside a rectangular area.\n\nSo the main thing Im trying to figure out is how to take the values from a BoxCollider and find out if my samples are within those bounds.\n\nI think the sampler is the problem here. Because it spits out one random sample outside the box and nothing more after that.\n\nHeres how I use that Sampler:\n\nIf there is another way instead of using a Box Collider for each area, or maybe another solution so I dont need to use the Rect, then Im all ears!\n\nI setup an island with the BoxCollider and tried using those bounds to see if its inside and spawn the tree, however it is ony spawning 1 tree, randomly way outside the BoxCollider and then nothing else, which leads me to believe thats the very first random sample, and after that it cant find any more because the first one is already outside the box.\n\nP.S. I know I can use raytracing but Id rather not as its quite expensive. Im really looking for a mathematical way, using the box.bounds.Contains() seems the cheapest way.."
    },
    {
        "link": "https://discussions.unity.com/t/detecting-presence-of-a-gameobject-inside-a-camera-field-of-view/692957",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/62285523/camera-collision-detection",
        "document": "I'm having trouble with my Camera script. The Camera rotates around the player by using a pivot that's assigned as a child of the camera. This works with 2 arrows (I'm developing this game for mobiles, so they're touch arrows) that allow the camera to rotate left and right.\n\nThe problem is when the Camera goes behind a wall or a huge object and can't see anything. I looked for a solution and I see that many developers used the RaycastHit or something similar.\n\nHere's my code, the goal is to get the Camera to go closer to the pivot when near a wall in order to avoid blocking the Camera view. Can anyone help me?"
    },
    {
        "link": "https://discussions.unity.com/t/is-there-a-way-to-detect-which-side-of-a-collider-is-hit/699661",
        "document": ""
    },
    {
        "link": "https://docs.unity3d.com/Manual/CollidersOverview.html",
        "document": "In Unity, a collision happens when two GameObjectsThe fundamental object in Unity scenes, which can represent characters, props, scenery, cameras, waypoints, and more. A GameObject’s functionality is defined by the Components attached to it. More info\n\nSee in Glossary that are configured for collision occupy the same physical space. Collision is a foundational part of most games, and many interactive applications and simulators.\n\nTo handle collision between GameObjects, Unity uses colliders. A collider is a Unity component that defines the shape of a GameObject for the purposes of physical collisions. Colliders are invisible, and do not need to be the same shape as the GameObject’s mesh.\n\nFor guidance on how to add components to a GameObject, see Use Components.\n\nEach 3D collider has a 2D equivalent. In Unity, 2D and 3D physics run on different physics simulation systems. For guidance on 2D physics colliders, see Collider 2D.\n\nA collider’s type is based on the configuration of its GameObject’s Collider and RigidbodyA component that allows a GameObject to be affected by simulated gravity and other forces. More info\n\nSee in Glossary components. This configuration determines how a collider behaves, and how it interacts with other colliders.\n• Static colliders: The GameObject has a collider but no Rigidbody.\n• Rigidbody colliders: The GameObject has a collider and a Rigidbody.\n• Dynamic colliders: The Rigidbody is dynamic (that is, it has Is Kinematic disabled).\n• Kinematic colliders: The Rigidbody is kinematic (that is, it has Is Kinematic enabled).\n\nThere is also a sub-type of collider called a Trigger collider. Trigger colliders do not physically collide with other colliders; instead, Unity calls a function when other colliders pass through them.\n\nTrigger colliders don’t cause collisions. Instead, they detect other Colliders that pass through them, and call functions that you can use to initiate events (see Use collisions to trigger other events).\n\nTo turn a collider into a trigger collider, enable the Is Trigger property on the Collider component. A trigger collider does not collide with other colliders; instead, other colliders pass through it.\n\nFor a trigger collider to work, at least one GameObject involved in the collision must have a Rigidbody. Trigger colliders can be any collider type (static or Rigidbody), but in most cases it’s good practice to make the trigger collider a static collider. and add a Rigidbody to the GameObject that passes through the trigger. If several GameObjects are passing through one trigger, there must be a Rigidbody on at least one GameObject in each collision pair.\n\nTriggers can be any collider shape (see Collider shapes), and they can be visible or invisible. To make a trigger invisible, add the collider to an empty GameObject. Only add a trigger to a visible GameObject if it is okay for other GameObjects to visibly pass through it.\n\nFor gameplay and simulation, triggers might need some adjustment to make them feel intuitive for the player. For example, you could experiment with making a trigger collider slightly larger than its associated visible GameObject, so that it has a wider radius.\n\nFor information on how different collider types interact with each other on collision, see Interaction between collider types.\n\nCollider components are available in different shape configurations. There are three main shape types for colliders:\n\nPrimitive colliders are built-in simple shapes that you can attach to your GameObject and scale to approximately the same size and shape. You can also combine several primitive collider shapes to create compound colliders. Mesh collidersA free-form collider component which accepts a mesh reference to define its collision surface shape. More info\n\nSee in Glossary exactly match the shape of the GameObject’s MeshThe main graphics primitive of Unity. Meshes make up a large part of your 3D worlds. Unity supports triangulated or Quadrangulated polygon meshes. Nurbs, Nurms, Subdiv surfaces must be converted to polygons. More info\n\nSee in Glossary. They are more accurate than primitive colliders for complex shapes, but require more computational resources. Wheel collidersA special collider for grounded vehicles. It has built-in collision detection, wheel physics, and a slip-based tire friction model. It can be used for objects other than wheels, but it is specifically designed for vehicles with wheels. More info\n\nSee in Glossary are raycast-based Colliders specifically for in-game items that have physics-simulated wheels (for example, vehicles). They have built-in wheel physics, and controls for friction.\n\nYou can control the friction and bounciness of a collider’s surface. When two colliders meet, the physics system uses the properties of each surface to calculate the friction and bounce between them.\n\nFor more information, see Collider surfaces."
    }
]