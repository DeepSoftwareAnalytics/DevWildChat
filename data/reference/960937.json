[
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html",
        "document": "Resizable-array implementation of theinterface. Implements all optional list operations, and permits all elements, including. In addition to implementing theinterface, this class provides methods to manipulate the size of the array that is used internally to store the list. (This class is roughly equivalent to, except that it is unsynchronized.)\n\nThe , , , , , and operations run in constant time. The operation runs in amortized constant time, that is, adding n elements requires O(n) time. All of the other operations run in linear time (roughly speaking). The constant factor is low compared to that for the implementation.\n\nEach instance has a capacity. The capacity is the size of the array used to store the elements in the list. It is always at least as large as the list size. As elements are added to an ArrayList, its capacity grows automatically. The details of the growth policy are not specified beyond the fact that adding an element has constant amortized time cost.\n\nAn application can increase the capacity of an instance before adding a large number of elements using the operation. This may reduce the amount of incremental reallocation.\n\nNote that this implementation is not synchronized. If multiple threads access an instance concurrently, and at least one of the threads modifies the list structurally, it must be synchronized externally. (A structural modification is any operation that adds or deletes one or more elements, or explicitly resizes the backing array; merely setting the value of an element is not a structural modification.) This is typically accomplished by synchronizing on some object that naturally encapsulates the list. If no such object exists, the list should be \"wrapped\" using the method. This is best done at creation time, to prevent accidental unsynchronized access to the list:\n\nThe iterators returned by this class's and methods are fail-fast: if the list is structurally modified at any time after the iterator is created, in any way except through the iterator's own or methods, the iterator will throw a . Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future.\n\nNote that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs.\n\nThis class is a member of the Java Collections Framework."
    },
    {
        "link": "https://docs.oracle.com/javase/8/docs/api?java/util/ArrayList.html",
        "document": "JavaScript is disabled on your browser.\n\nThis document is designed to be viewed using the frames feature. If you see this message, you are using a non-frame-capable web client. Link to Non-frame version."
    },
    {
        "link": "https://w3schools.com/java/java_arraylist.asp",
        "document": "The class is a resizable array, which can be found in the package.\n\nThe difference between a built-in array and an in Java, is that the size of an array cannot be modified (if you want to add or remove elements to/from an array, you have to create a new one). While elements can be added and removed from an whenever you want. The syntax is also slightly different:\n\nThe class has many useful methods. For example, to add elements to the list, use the method:\n\nYou can also add an item at a specified position by referring to the index number:\n\nTo access an element in the , use the method and refer to the index number:\n\nTo modify an element, use the method and refer to the index number:\n\nTo remove an element, use the method and refer to the index number:\n\nTo remove all the elements in the , use the method:\n\nTo find out how many elements an ArrayList have, use the method:\n\nLoop through the elements of an with a loop, and use the method to specify how many times the loop should run:\n\nYou can also loop through an with the for-each loop:\n\nElements in an ArrayList are actually objects. In the examples above, we created elements (objects) of type \"String\". Remember that a String in Java is an object (not a primitive type). To use other types, such as int, you must specify an equivalent wrapper class: . For other primitive types, use: for boolean, for char, for double, etc:\n\nAnother useful class in the package is the class, which include the method for sorting lists alphabetically or numerically:"
    },
    {
        "link": "https://geeksforgeeks.org/arraylist-in-java",
        "document": "Java ArrayList is a part of the collections framework and it is a class of java.util package. It provides us with dynamic-sized arrays in Java.\n• advantage of ArrayList is that, unlike normal arrays, we don’t need to mention the size when creating ArrayList. It automatically adjusts its capacity as elements are added or removed.\n• None It may be slower than standard arrays, but it is helpful when the size is not known in advance. Note that creating a large fixed-sized array would cause a waste of space.\n• None Since ArrayList is part of the collections framework, it has better interoperability with other collections. For example, conversion to a HashSet is straightforward.\n\nArrayList is a Java class implemented using the List interface. Java ArrayList, as the name suggests, provides the functionality of a dynamic array where the size is not fixed as an array. Also, as a part of Collections framework, it has many features not available with arrays.\n\nNote: You can also create a generic ArrayList\n• None ArrayList is initialized by size. However, the size is increased automatically if the collection grows or shrinks if the are removed from the collection.\n• None Java ArrayList allows us to randomly access the list.\n• None ArrayList can not be used for , like int, char, etc. We need a\n• None ArrayList in Java can be seen as a\n• None ArrayList is not Synchronized. Its equivalent synchronized class in Java is\n\nLet’s understand the Java ArrayList in depth. Look at the below image:\n\nIn the above illustration, AbstractList, CopyOnWriteArrayList, and AbstractSequentialList are the classes that implement the list interface. A separate functionality is implemented in each of the mentioned classes. They are:\n• AbstractList: This class is used to implement an unmodifiable list, for which one needs to only extend this AbstractList Class and implement only the get() size()\n• CopyOnWriteArrayList: This class implements the list interface. It is an enhanced version of in which all the modifications(add, set, remove, etc.) are implemented by making a fresh copy of the list.\n• AbstractSequentialList: This class extends AbstractList. This class is used to provide the skeletal implementation for lists that are accessed sequiencially (i.e iterators) to create a concrete class. It can implement the get(int index) and size() methods.\n\nIn order to Create an ArrayList, we need to create an object of the ArrayList class. The ArrayList class consists of various constructors which allow the possible creation of the array list. The following are the constructors available in this class:\n\nNow, Using the constructors we have got ArrayList for further operations like Insertion , Deletion and Updation of the elements in ArrayList.\n\nLet us understand how the three operations performed in above Program works.\n\nAdding elements seems bit complex when the size of ArrayList is not defined:\n• None Creates a bigger-sized memory on heap memory (for example memory of double size).\n• None Copies the current memory elements to the new memory.\n• None The new item is added now as there is bigger memory available now.\n\nAfter adding the elements, if we wish to change the element, it can be done using the set() method. Since an ArrayList is indexed, the element which we wish to change is referenced by the index of the element. Therefore, this method takes an index and the updated element which needs to be inserted at that index.\n\nIn order to remove an element from an ArrayList, we can use the remove() method. This method is overloaded to perform multiple operations based on different parameters. \n\n\n\nSome Key Points of ArrayList in Java\n\nBelow are the advantages and disadvantages of using ArrayList in Java:\n• Dynamic size: ArrayList can dynamically grow and shrink in size, making it easy to add or remove elements as needed.\n• Easy to use : ArrayList is simple to use, making it a popular choice for many Java developers.\n• Fast access : ArrayList provides fast access to elements, as it is implemented as an array under the hood.\n• Ordered collection : ArrayList preserves the order of elements, allowing you to access elements in the order they were added.\n• Supports null values : ArrayList can store null values, making it useful in cases where the absence of a value needs to be represented.\n• Slower than arrays : ArrayList is slower than arrays for certain operations, such as inserting elements in the middle of the list.\n• Increased memory usage : ArrayList requires more memory than arrays, as it needs to maintain its dynamic size and handle resizing.\n• Not thread-safe: ArrayList is not thread-safe, meaning that multiple threads may access and modify the list concurrently, leading to potential race conditions and data corruption.\n• Performance degradation : ArrayList’s performance may degrade as the number of elements in the list increases, especially for operations such as searching for elements or inserting elements in the middle of the list.\n\nHow is ArrayList different from an Array in Java?\n\nHow to Access elements in an ArrayList?\n\nHow to Remove an element from an ArrayList?\n\nCan we Store null elements in an ArrayList?\n\nHow is data stored in ArrayList?"
    },
    {
        "link": "https://download.java.net/java/GA/jdk14/docs/api/java.base/java/util/class-use/ArrayList.html",
        "document": "A RoleUnresolvedList represents a list of RoleUnresolved objects, representing roles not retrieved from a relation due to a problem encountered when trying to access (read or write) the roles.\n\nReturns an array list containing the elements returned by the specified enumeration in the order they are returned by the enumeration.\n\nDrag and Drop is a direct manipulation gesture found in many Graphical User Interface systems that provides a mechanism to transfer information between two entities logically associated with presentation elements in the GUI.\n\nReport a bug or suggest an enhancement\n\n For further API reference and developer documentation see the Java SE Documentation, which contains more detailed, developer-targeted descriptions with conceptual overviews, definitions of terms, workarounds, and working code examples.\n\n Java is a trademark or registered trademark of Oracle and/or its affiliates in the US and other countries.\n\n Copyright © 1993, 2020, Oracle and/or its affiliates, 500 Oracle Parkway, Redwood Shores, CA 94065 USA.\n\nAll rights reserved. Use is subject to license terms and the documentation redistribution policy."
    },
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/util/Random.html",
        "document": "\n• seed. The general contract of is that it alters the state of this random number generator object so as to be in exactly the same state as if it had just been created with the argument as a seed. The method is implemented by class by atomically updating the seed to and clearing the flag used by Sets the seed of this random number generator using a singleseed. The general contract ofis that it alters the state of this random number generator object so as to be in exactly the same state as if it had just been created with the argumentas a seed. The methodis implemented by classby atomically updating the seed toand clearing theflag used by The implementation of by class happens to use only 48 bits of the given seed. In general, however, an overriding method may use all 64 bits of the argument as a seed value.\n• Generates the next pseudorandom number. Subclasses should override this, as this is used by all other methods. The general contract of is that it returns an value and if the argument is between and (inclusive), then that many low-order bits of the returned value will be (approximately) independently chosen bit values, each of which is (approximately) equally likely to be or . The method is implemented by class by atomically updating the seed to and returning This is a linear congruential pseudorandom number generator, as defined by D. H. Lehmer and described by Donald E. Knuth in The Art of Computer Programming, Volume 3: Seminumerical Algorithms, section 3.2.1. and returningThis is a linear congruential pseudorandom number generator, as defined by D. H. Lehmer and described by Donald E. Knuth inVolume 3:, section 3.2.1. the next pseudorandom value from this random number generator's sequence\n• Generates random bytes and places them into a user-supplied byte array. The number of random bytes produced is equal to the length of the byte array. The method is implemented by class as if by: - the byte array to fill with random bytes - if the byte array is null\n• value from this random number generator's sequence. The general contract of is that one value is pseudorandomly generated and returned. All 232 possible values are produced with (approximately) equal probability. Returns the next pseudorandom, uniformly distributedvalue from this random number generator's sequence. The general contract ofis that onevalue is pseudorandomly generated and returned. All 2possiblevalues are produced with (approximately) equal probability. The method is implemented by class as if by: the next pseudorandom, uniformly distributed value from this random number generator's sequence\n• value between 0 (inclusive) and the specified value (exclusive), drawn from this random number generator's sequence. The general contract of is that one value in the specified range is pseudorandomly generated and returned. All possible values are produced with (approximately) equal probability. The method is implemented by class as if by: public int nextInt(int bound) { if (bound <= 0) throw new IllegalArgumentException(\"bound must be positive\"); if ((bound & -bound) == bound) // i.e., bound is a power of 2 return (int)((bound * (long)next(31)) >> 31); int bits, val; do { bits = next(31); val = bits % bound; } while (bits - val + (bound-1) < 0); return val; } Returns a pseudorandom, uniformly distributedvalue between 0 (inclusive) and the specified value (exclusive), drawn from this random number generator's sequence. The general contract ofis that onevalue in the specified range is pseudorandomly generated and returned. Allpossiblevalues are produced with (approximately) equal probability. The methodis implemented by classas if by: The hedge \"approximately\" is used in the foregoing description only because the next method is only approximately an unbiased source of independently chosen bits. If it were a perfect source of randomly chosen bits, then the algorithm shown would choose values from the stated range with perfect uniformity. The algorithm is slightly tricky. It rejects values that would result in an uneven distribution (due to the fact that 2^31 is not divisible by n). The probability of a value being rejected depends on n. The worst case is n=2^30+1, for which the probability of a reject is 1/2, and the expected number of iterations before the loop terminates is 2. The algorithm treats the case where n is a power of two specially: it returns the correct number of high-order bits from the underlying pseudo-random number generator. In the absence of special treatment, the correct number of low-order bits would be returned. Linear congruential pseudo-random number generators such as the one implemented by this class are known to have short periods in the sequence of values of their low-order bits. Thus, this special case greatly increases the length of the sequence of values returned by successive calls to this method if n is a small power of two. - the upper bound (exclusive). Must be positive. the next pseudorandom, uniformly distributed value between zero (inclusive) and (exclusive) from this random number generator's sequence - if bound is not positive\n• value from this random number generator's sequence. The general contract of is that one value is pseudorandomly generated and returned. Returns the next pseudorandom, uniformly distributedvalue from this random number generator's sequence. The general contract ofis that onevalue is pseudorandomly generated and returned. The method is implemented by class as if by: Because class uses a seed with only 48 bits, this algorithm will not return all possible values. Because classuses a seed with only 48 bits, this algorithm will not return all possiblevalues. the next pseudorandom, uniformly distributed value from this random number generator's sequence\n• value from this random number generator's sequence. The general contract of is that one value is pseudorandomly generated and returned. The values and are produced with (approximately) equal probability. Returns the next pseudorandom, uniformly distributedvalue from this random number generator's sequence. The general contract ofis that onevalue is pseudorandomly generated and returned. The valuesandare produced with (approximately) equal probability. The method is implemented by class as if by: the next pseudorandom, uniformly distributed value from this random number generator's sequence\n• value between and from this random number generator's sequence. Returns the next pseudorandom, uniformly distributedvalue betweenandfrom this random number generator's sequence. The general contract of is that one value, chosen (approximately) uniformly from the range (inclusive) to (exclusive), is pseudorandomly generated and returned. All 224 possible values of the form m x 2-24, where m is a positive integer less than 224, are produced with (approximately) equal probability. The method is implemented by class as if by: The hedge \"approximately\" is used in the foregoing description only because the next method is only approximately an unbiased source of independently chosen bits. If it were a perfect source of randomly chosen bits, then the algorithm shown would choose values from the stated range with perfect uniformity. [In early versions of Java, the result was incorrectly calculated as: This might seem to be equivalent, if not better, but in fact it introduced a slight nonuniformity because of the bias in the rounding of floating-point numbers: it was slightly more likely that the low-order bit of the significand would be 0 than that it would be 1.] This might seem to be equivalent, if not better, but in fact it introduced a slight nonuniformity because of the bias in the rounding of floating-point numbers: it was slightly more likely that the low-order bit of the significand would be 0 than that it would be 1.] the next pseudorandom, uniformly distributed value between and from this random number generator's sequence\n• value between and from this random number generator's sequence. Returns the next pseudorandom, uniformly distributedvalue betweenandfrom this random number generator's sequence. The general contract of is that one value, chosen (approximately) uniformly from the range (inclusive) to (exclusive), is pseudorandomly generated and returned. The method is implemented by class as if by: The hedge \"approximately\" is used in the foregoing description only because the method is only approximately an unbiased source of independently chosen bits. If it were a perfect source of randomly chosen bits, then the algorithm shown would choose values from the stated range with perfect uniformity. [In early versions of Java, the result was incorrectly calculated as: This might seem to be equivalent, if not better, but in fact it introduced a large nonuniformity because of the bias in the rounding of floating-point numbers: it was three times as likely that the low-order bit of the significand would be 0 than that it would be 1! This nonuniformity probably doesn't matter much in practice, but we strive for perfection.] This might seem to be equivalent, if not better, but in fact it introduced a large nonuniformity because of the bias in the rounding of floating-point numbers: it was three times as likely that the low-order bit of the significand would be 0 than that it would be 1! This nonuniformity probably doesn't matter much in practice, but we strive for perfection.] the next pseudorandom, uniformly distributed value between and from this random number generator's sequence\n• value with mean and standard deviation from this random number generator's sequence. Returns the next pseudorandom, Gaussian (\"normally\") distributedvalue with meanand standard deviationfrom this random number generator's sequence. The general contract of is that one value, chosen from (approximately) the usual normal distribution with mean and standard deviation , is pseudorandomly generated and returned. The method is implemented by class as if by a threadsafe version of the following: private double nextNextGaussian; private boolean haveNextNextGaussian = false; public double nextGaussian() { if (haveNextNextGaussian) { haveNextNextGaussian = false; return nextNextGaussian; } else { double v1, v2, s; do { v1 = 2 * nextDouble() - 1; // between -1.0 and 1.0 v2 = 2 * nextDouble() - 1; // between -1.0 and 1.0 s = v1 * v1 + v2 * v2; } while (s >= 1 || s == 0); double multiplier = StrictMath.sqrt(-2 * StrictMath.log(s)/s); nextNextGaussian = v2 * multiplier; haveNextNextGaussian = true; return v1 * multiplier; } } This uses the polar method of G. E. P. Box, M. E. Muller, and G. Marsaglia, as described by Donald E. Knuth in The Art of Computer Programming, Volume 3: Seminumerical Algorithms, section 3.4.1, subsection C, algorithm P. Note that it generates two independent values at the cost of only one call to and one call to . This uses theof G. E. P. Box, M. E. Muller, and G. Marsaglia, as described by Donald E. Knuth in, Volume 3:, section 3.4.1, subsection C, algorithm P. Note that it generates two independent values at the cost of only one call toand one call to the next pseudorandom, Gaussian (\"normally\") distributed value with mean and standard deviation from this random number generator's sequence\n• number of pseudorandom values. A pseudorandom value is generated as if it's the result of calling the method . - the number of values to generate - if is less than zero\n• values. A pseudorandom value is generated as if it's the result of calling the method . This method is implemented to be equivalent to .\n• number of pseudorandom values, each conforming to the given origin (inclusive) and bound (exclusive). Returns a stream producing the givennumber of pseudorandomvalues, each conforming to the given origin (inclusive) and bound (exclusive). A pseudorandom value is generated as if it's the result of calling the following method with the origin and bound: int nextInt(int origin, int bound) { int n = bound - origin; if (n > 0) { return nextInt(n) + origin; } else { // range not representable as int int r; do { r = nextInt(); } while (r < origin || r >= bound); return r; } } - the number of values to generate - the origin (inclusive) of each random value - the bound (exclusive) of each random value a stream of pseudorandom values, each with the given origin (inclusive) and bound (exclusive) - if is less than zero, or is greater than or equal to\n• values, each conforming to the given origin (inclusive) and bound (exclusive). Returns an effectively unlimited stream of pseudorandomvalues, each conforming to the given origin (inclusive) and bound (exclusive). A pseudorandom value is generated as if it's the result of calling the following method with the origin and bound: int nextInt(int origin, int bound) { int n = bound - origin; if (n > 0) { return nextInt(n) + origin; } else { // range not representable as int int r; do { r = nextInt(); } while (r < origin || r >= bound); return r; } } This method is implemented to be equivalent to . - the origin (inclusive) of each random value - the bound (exclusive) of each random value a stream of pseudorandom values, each with the given origin (inclusive) and bound (exclusive) - if is greater than or equal to\n• number of pseudorandom values. A pseudorandom value is generated as if it's the result of calling the method . - the number of values to generate - if is less than zero\n• values. A pseudorandom value is generated as if it's the result of calling the method . This method is implemented to be equivalent to .\n• number of pseudorandom , each conforming to the given origin (inclusive) and bound (exclusive). Returns a stream producing the givennumber of pseudorandom, each conforming to the given origin (inclusive) and bound (exclusive). A pseudorandom value is generated as if it's the result of calling the following method with the origin and bound: long nextLong(long origin, long bound) { long r = nextLong(); long n = bound - origin, m = n - 1; if ((n & m) == 0L) // power of two r = (r & m) + origin; else if (n > 0L) { // reject over-represented candidates for (long u = r >>> 1; // ensure nonnegative u + m - (r = u % n) < 0L; // rejection check u = nextLong() >>> 1) // retry ; r += origin; } else { // range not representable as long while (r < origin || r >= bound) r = nextLong(); } return r; } - the number of values to generate - the origin (inclusive) of each random value - the bound (exclusive) of each random value a stream of pseudorandom values, each with the given origin (inclusive) and bound (exclusive) - if is less than zero, or is greater than or equal to\n• values, each conforming to the given origin (inclusive) and bound (exclusive). Returns an effectively unlimited stream of pseudorandomvalues, each conforming to the given origin (inclusive) and bound (exclusive). A pseudorandom value is generated as if it's the result of calling the following method with the origin and bound: long nextLong(long origin, long bound) { long r = nextLong(); long n = bound - origin, m = n - 1; if ((n & m) == 0L) // power of two r = (r & m) + origin; else if (n > 0L) { // reject over-represented candidates for (long u = r >>> 1; // ensure nonnegative u + m - (r = u % n) < 0L; // rejection check u = nextLong() >>> 1) // retry ; r += origin; } else { // range not representable as long while (r < origin || r >= bound) r = nextLong(); } return r; } This method is implemented to be equivalent to . - the origin (inclusive) of each random value - the bound (exclusive) of each random value a stream of pseudorandom values, each with the given origin (inclusive) and bound (exclusive) - if is greater than or equal to\n• number of pseudorandom values, each between zero (inclusive) and one (exclusive). Returns a stream producing the givennumber of pseudorandomvalues, each between zero (inclusive) and one (exclusive). A pseudorandom value is generated as if it's the result of calling the method . - the number of values to generate - if is less than zero\n• values, each between zero (inclusive) and one (exclusive). Returns an effectively unlimited stream of pseudorandomvalues, each between zero (inclusive) and one (exclusive). A pseudorandom value is generated as if it's the result of calling the method . This method is implemented to be equivalent to .\n• number of pseudorandom values, each conforming to the given origin (inclusive) and bound (exclusive). Returns a stream producing the givennumber of pseudorandomvalues, each conforming to the given origin (inclusive) and bound (exclusive). A pseudorandom value is generated as if it's the result of calling the following method with the origin and bound: - the number of values to generate - the origin (inclusive) of each random value - the bound (exclusive) of each random value a stream of pseudorandom values, each with the given origin (inclusive) and bound (exclusive) - if is less than zero - if is greater than or equal to\n• values, each conforming to the given origin (inclusive) and bound (exclusive). Returns an effectively unlimited stream of pseudorandomvalues, each conforming to the given origin (inclusive) and bound (exclusive). A pseudorandom value is generated as if it's the result of calling the following method with the origin and bound: This method is implemented to be equivalent to . - the origin (inclusive) of each random value - the bound (exclusive) of each random value a stream of pseudorandom values, each with the given origin (inclusive) and bound (exclusive) - if is greater than or equal to"
    },
    {
        "link": "https://medium.com/@AlexanderObregon/working-with-javas-random-api-c78ff104ba06",
        "document": "In the world of Java programming, the generation of random numbers is a common requirement for a vast array of applications. From simple games to complex simulation systems, the need for randomness is ubiquitous. Java’s Random API, part of the package, provides a foundation for introducing this randomness in a controlled and predictable manner. Let's explore how this API works, understand its limitations, and discover how to utilize it in your Java applications.\n\nIn any programming language, the ability to generate random numbers is an essential feature. In Java, this capability is provided through the class, a part of the Java Collections Framework. The Random class encapsulates the concept of a pseudo-random number generator (PRNG), which, as the name suggests, generates numbers that seem random but are actually the result of a deterministic computation.\n\nThe numbers generated by PRNGs are not truly random because they are calculated using a deterministic algorithm. However, for most…"
    },
    {
        "link": "https://stackoverflow.com/questions/32725145/efficient-way-to-generate-lots-of-random-numbers",
        "document": "Random numbers using the Random class use an algorithm that bit mangles an int to give you a new int. It will use the same algorithm regardless of how quickly or how many times you call it. The progression is the progression.\n\nTo test this, seed it with a number, like 42. Then watch the progression. Seed it with the same number again. Same exact progression.\n\nThe downside to this approach is that the numbers are not TRULY random. They're pretty random, and good enough for most things, but not perfectly random.\n\nI ran the output of the Random method through the die hard battery of tests. It passed most of them with flying colors, one it was borderline, and one it just flat failed. That's the kind of random we're talking about.\n\nPlus, because it uses a date time stamp to seed itself, it is somewhat predictable in some circumstances. Picture someone that boots up and runs your task every Monday morning first thing for that week. There is some predictability because it will run with a timestamp of Monday morning between 8 and 8:30.\n\nSo, Random is good enough for most operations that don't have to do with security. Even a lot of them.\n\nSecureRandom, on the other hand, will generate truly random numbers. It does this by looking at system timings and other things that vary from second to second based on a myriad of factors.\n\nThe downside is that these factors only change so often in a second, so SecureRandom can only generate a finite number of random numbers in a period of time. It does try to generate some ahead of time and cache them for use, but you can blow the cache.\n\nIn this way, it's like my reverse osmosis water filter. It holds a gallon of water that it has already filtered. If you use the whole gallon of water in one shot, then you get it at the rate it filters it--something like 1 ounce per 5 seconds or some such. The first gallon is fast, then it's really slow."
    },
    {
        "link": "https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/random/package-summary.html",
        "document": "This package contains classes and interfaces that support a generic API for random number generation.\n\nThese classes and interfaces support the definition and use of \"random generators\", a term covering what have traditionally been called \"random number generators\" as well as generators of other sorts of randomly chosen values (eg. booleans). These classes and interfaces cover not only deterministic (pseudorandom) algorithms but also generators of values that use some \"truly random\" physical source (stochastic algorithms perhaps making use of thermal noise, for example, or quantum-mechanical effects).\n\nThe principal interface is , which provides methods for requesting individual values of type , , , , or chosen pseudorandomly from a uniform distribution; methods for requesting values of type chosen pseudorandomly from a normal distribution or from an exponential distribution; and methods for creating streams of values of type , , or chosen pseudorandomly from a uniform distribution (such streams are spliterator-based, allowing for parallel processing of their elements). There are also static factory methods for creating an instance of a specific random number generator algorithm given its name.\n\nThe principal supporting class is . This can be used to generate multiple random number generators for a specific algorithm. also provides methods for selecting random number generator algorithms. RandomGeneratorFactory registers implementations of interface using the service provider API.\n\nAn important subsidiary interface is , which provides methods for creating spliterator-based streams of objects, allowing for parallel processing of these objects using multiple threads. Unlike , most implementations of are not thread-safe. The intent is that instances should not be shared among threads; rather, each thread should have its own random generator(s) to use. The various pseudorandom algorithms provided by this package are designed so that multiple instances will (with very high probability) behave as if statistically independent.\n\nFor many purposes, these are the only two interfaces that a consumer of pseudorandom values will need. There are also some more specialized interfaces that describe more specialized categories of random number generators , , , and that have specific strategies for creating statistically independent instances.\n\nTo get started, an application should first create one instance of a generator class. Assume that the contents of the package has been imported:Then one can choose a specific implementation by giving the name of a generator algorithm to the static method , in which case the no-arguments constructor for that implementation is used:For a single-threaded application, this is all that is needed. One can then invoke methods ofsuch as and to generate individual randomly chosen values. One can also use the methods and to create streams of randomly chosen values. The methods and draw floating-point values from nonuniform distributions.\n\nFor a multi-threaded application, one can repeat the preceding steps to create additional RandomGenerators, but often it is preferable to use methods of the one single initially created generator to create others like it. (One reason is that some generator algorithms, if asked to create a new set of generators all at once, can make a special effort to ensure that the new generators are statistically independent.) If the initial generator implements the interface , then the method can be used to create a stream of generators. If this is a parallel stream, then it is easy to get parallel execution by using the method on the stream.\n\nFor a multi-threaded application that forks new threads dynamically, another approach is to use an initial generator that implements the interface , which is then considered to \"belong\" to the initial thread for its exclusive use; then whenever any thread needs to fork a new thread, it first uses the method of its own generator to create a new generator, which is then passed to the newly created thread for exclusive use by that new thread.\n\nThere are three groups of random number generator algorithm provided in Java: the Legacy group, the LXM group, and the Xoroshiro/Xoshiro group.\n\nThe legacy group includes random number generators that existed before JDK 17: Random, ThreadLocalRandom, SplittableRandom, and SecureRandom. Random (LCG) is the weakest of the available algorithms, and it is recommended that users migrate to newer algorithms. If an application requires a random number generator algorithm that is cryptographically secure, then it should continue to use an instance of the class .\n\nThe algorithms in the LXM group are similar to each other. The parameters of each algorithm can be found in the algorithm name. The number after \"L\" indicates the number of state bits for the LCG subgenerator, and the number after \"X\" indicates the number of state bits for the XBG subgenerator. \"Mix\" indicates that the algorithm uses an 8-operation bit-mixing function; \"StarStar\" indicates use of a 3-operation bit-scrambler.\n\nThe algorithms in the Xoroshiro/Xoshiro group are more traditional algorithms (see David Blackman and Sebastiano Vigna, \"Scrambled Linear Pseudorandom Number Generators,\" ACM Transactions on Mathematical Software, 2021); the number in the name indicates the number of state bits.\n\nFor applications (such as physical simulation, machine learning, and games) that do not require a cryptographically secure algorithm, this package provides multiple implementations of interface that provide trade-offs among speed, space, period, accidental correlation, and equidistribution properties.\n\nFor applications with no special requirements, has a good balance among speed, space, and period, and is suitable for both single-threaded and multi-threaded applications when used properly (a separate instance for each thread).\n\nIf the application uses only a single thread, then is even smaller and faster, and certainly has a sufficiently long period.\n\nFor an application running in a 32-bit hardware environment and using only one thread or a small number of threads, may be a good choice.\n\nFor an application that uses many threads that are allocated in one batch at the start of the computation, either a \"jumpable\" generator such as or may be used, or a \"splittable\" generator such as or may be used.\n\nFor an application that creates many threads dynamically, perhaps through the use of spliterators, a \"splittable\" generator such as or is recommended. If the number of generators created dynamically may be very large (millions or more), then using generators such as or , which use a 128-bit parameter rather than a 64-bit parameter for their LCG subgenerator, will make it much less likely that two instances use the same state cycle.\n\nFor an application that uses tuples of consecutively generated values, it may be desirable to use a generator that is k-equidistributed such that k is at least as large as the length of the tuples being generated. The generator is provably 4-equidistributed, and is provably 16-equidistributed.\n\nFor applications that generate large permutations, it may be best to use a generator whose period is much larger than the total number of possible permutations; otherwise it will be impossible to generate some of the intended permutations. For example, if the goal is to shuffle a deck of 52 cards, the number of possible permutations is 52! (52 factorial), which is larger than 2225 (but smaller than 2226), so it may be best to use a generator whose period at least 2256, such as or or or . (It is of course also necessary to provide sufficiently many seed bits when the generator is initialized, or else it will still be impossible to generate some of the intended permutations.)\n\nThese algorithms [in the table below] must be found with the current version of Java SE. A particular JDK implementation may recognize additional algorithms; check the JDK's documentation for details. The set of algorithms required by Java SE may be updated by changes to the Java SE specification. Over time, new algorithms may be added and old algorithms may be removed.\n\nIn addition, as another life-cycle phase, an algorithm may be deprecated. A deprecated algorithm is not recommended for use. If a required algorithm is deprecated, it may be removed in a future release. Due to advances in random number generator algorithm development and analysis, an algorithm may be deprecated during the lifetime of a particular Java SE release. Changing the deprecation status of an algorithm is not a specification change.\n\n* ThreadLocalRandom can only be accessed via .\n\nHistorically, most pseudorandom generator algorithms have been based on some sort of finite-state machine with a single, large cycle of states; when it is necessary to have multiple threads use the same algorithm simultaneously, the usual technique is to arrange for each thread to traverse a different region of the state cycle. These regions may be doled out to threads by starting with a single initial state and then using a \"jump function\" that travels a long distance around the cycle (perhaps 2steps or more); the jump function is applied repeatedly and sequentially, to identify widely spaced states that are then doled out, one to each thread, to serve as the initial state for the generator to be used by that thread. This strategy is supported by the interface . Sometimes it is desirable to support two levels of jumping (by long distances and bylong distances); this strategy is supported by the interface . There is also an interface for algorithms that allow jumping along the state cycle by any user-specified distance. In this package, implementations of these interfaces include \"Xoroshiro128PlusPlus\", and \"Xoshiro256PlusPlus\".\n\nA more recent category of \"splittable\" pseudorandom generator algorithms uses a large family of state cycles and makes some attempt to ensure that distinct instances use different state cycles; but even if two instances \"accidentally\" use the same state cycle, they are highly likely to traverse different regions parts of that shared state cycle. This strategy is supported by the interface . In this package, implementations of this interface include \"L32X64MixRandom\", \"L64X128StarStarRandom\", \"L64X128MixRandom\", \"L64X256MixRandom\", \"L64X1024MixRandom\", \"L128X128MixRandom\", \"L128X256MixRandom\", and \"L128X1024MixRandom\"; note that the class also implements this interface.\n\nThe structure of the central nextLong (or nextInt) method of an LXM algorithm follows a suggestion in December 2017 by Sebastiano Vigna that using one Linear Congruential Generator (LCG) as a first subgenerator and one Xor-Based Generator (XBG) as a second subgenerator (rather than using two LCG subgenerators) would provide a longer period, superior equidistribution, scalability, and better quality. Each of the specific implementations here combines one of the best currently known XBG algorithms (xoroshiro128 or xoshiro256, described by Blackman and Vigna in \"Scrambled Linear Pseudorandom Number Generators\", ACM Transactions on Mathematical Software, 2021) with an LCG that uses one of the best currently known multipliers (found by a search for better multipliers in 2019 by Steele and Vigna), and then applies either a mixing function identified by Doug Lea or a simple scrambler proposed by Blackman and Vigna. Testing has confirmed that the LXM algorithm is far superior in quality to the SplitMix algorithm (2014) used by. Each class with a name of the formuses some specific member of the LXM family of random number algorithms; \"LXM\" is short for \"LCG, XBG, Mixer\". Every LXM generator has two subgenerators; one is an LCG (Linear Congruential Generator) and the other is an XBG (Xor-Based Generator). Each output of an LXM generator is the result of combining state from the LCG with state from the XBG using a Mixing function (and then the state of the LCG and the state of the XBG are advanced).\n\nThe LCG subgenerator has an update step of the form , where , , and are all binary integers of the same size, each having p bits; is the mutable state, the multiplier is fixed (the same for all instances of a class) and the addend is a parameter (a final field of the instance). The parameter is required to be odd (this allows the LCG to have the maximal period, namely 2p); therefore there are 2p−1 distinct choices of parameter. (When the size of is 128 bits, then we use the name \" \" below to refer to the high half of , that is, the high-order 64 bits of .)\n\nThe XBG subgenerator can in principle be any one of a wide variety of XBG algorithms; in this package it is always either , , or , in each case without any final scrambler (such as \"+\" or \"**\") because LXM uses a separate Mixer later in the process. The XBG state consists of some fixed number of or fields, generally named , , and so on, which can take on any values provided that they are not all zero. The collective total size of these fields is q bits; therefore the period of this subgenerator is 2q−1.\n\nBecause the periods 2p and 2q−1 of the two subgenerators are relatively prime, the period of any single instance of an LXM algorithm (the length of the series of generated values before it repeats) is the product of the periods of the subgenerators, that is, 2p(2q−1), which is just slightly smaller than 2(p+q). Moreover, if two distinct instances of the same LXM algorithm have different parameters, then their cycles of produced values will be different.\n\nGenerally speaking, among the \" p q\" generators, the memory required for an instance is 2p+q bits. (If q is 1024 or larger, the XBG state is represented as an array, so additional bits are needed for the array object header, and another 32 bits are used for an array index.)\n\nLarger values of p imply a lower probability that two distinct instances will traverse the same state cycle, and larger values of q imply that the generator is equidistributed in a larger number of dimensions (this is provably true when p is 64, and conjectured to be approximately true when p is 128). A class with \" \" in its name uses a fairly strong mixing function with excellent avalanche characteristics; a class with \" \" in its name uses a weaker but faster mixing function.\n\nThe specific LXM algorithms used in this package are all chosen so that the 64-bit values produced by the method are exactly equidistributed (for example, for any specific instance of \"L64X128MixRandom\", over the course of its cycle each of the 264 possible values will be produced 2128−1 times). The values produced by the , , and methods are likewise exactly equidistributed. Some algorithms provide a further guarantee of k-equidistribution for some k greater than 1, meaning that successive non-overlapping k-tuples of 64-bit values produced by the method are exactly equidistributed (equally likely to occur).\n\nThe following table gives the period, state size (in bits), parameter size (in bits, including the low-order bit that is required always to be a 1-bit), and equidistribution property for each of the specific LXM algorithms used in this package.\n\nFor the algorithms listed above whose names begin with, the 32-bit values produced by the method are exactly equidistributed, but the 64-bit values produced by the method are not exactly equidistributed.\n\nFor the algorithms listed above whose names begin with or , the 64-bit values produced by the method are exactly equidistributed: every instance, over the course of its cycle, will produce each of the 264 possible values exactly the same number of times. For example, any specific instance of \"L64X256MixRandom\", over the course of its cycle each of the 264 possible values will be produced 2256−1 times. The values produced by the , , and methods are likewise exactly equidistributed.\n\nIn addition, for the algorithms listed above whose names begin with , the 64-bit values produced by the method are k-equidistributed (but not exactly k-equidistributed). To be precise, and taking \"L64X256MixRandom\" as an example: for any specific instance of \"L64X256MixRandom\", consider the (overlapping) length-4 subsequences of the cycle of 64-bit values produced by (assuming no other methods are called that would affect the state). There are 264(2256−1) such subsequences, and each subsequence, which consists of 4 64-bit values, can have one of 2256 values. Of those 2256 subsequence values, nearly all of them (2256−264) occur 264 times over the course of the entire cycle, and the other 264 subsequence values occur only 264−1 times. So the ratio of the probability of getting any specific one of the less common subsequence values and the probability of getting any specific one of the more common subsequence values is 1−2-64. (Note that the set of 264 less-common subsequence values will differ from one instance of \"L64X256MixRandom\" to another, as a function of the additive parameter of the LCG.) The values produced by the , , and methods are likewise 4-equidistributed (but not exactly 4-equidistributed).\n\nThe next table gives the LCG multiplier value, the name of the specific XBG algorithm used, the specific numeric parameters for that XBG algorithm, and the mixing function for each of the specific LXM algorithms used in this package. (Note that the multiplier used for the 128-bit LCG cases is 65 bits wide, so the constant shown in the table cannot actually be used in code; instead, only the 64 low-order bits are represented in the source code, and the missing 1-bit is handled through special coding of the multiply-add algorithm used in the LCG.)"
    },
    {
        "link": "https://freecodecamp.org/news/generate-random-numbers-java",
        "document": "Computer generated random numbers are divided into two categories: true random numbers and pseudo-random numbers.\n\nTrue random numbers are generated based on external factors. For example, generating randomness using surrounding noises.\n\nBut generating such true random number is a time consuming task. Therefore, we can utilize pseudo-random numbers which are generated using an algorithm and a seed value.\n\nThese pseudo-random numbers are sufficient for most purposes. For example, you can use them in cryptography, in building games such as dice or cards, and in generating OTP (one-time password) numbers.\n\nIn this article, we will learn how to generate pseudo-random numbers using in Java.\n\nreturns a double type pseudo-random number, greater than or equal to zero and less than one.\n\nLet's try it out with some code:\n\nwill give us a different random number for each execution.\n\nLet's say we want to generate random numbers within a specified range, for example, zero to four.\n\nWhen we cast a double to int, the int value keeps only whole number part.\n\nFor example, in the above code, is . 's whole number part is and fractional part (numbers after the decimal point) is . So, will only hold the whole number part .\n\nYou can read more about the method in the Java documentation.\n\nUsing is not the only way to generate random numbers in Java. Next, we'll consider how we can generate random numbers using the Random class.\n\n2. Use the Random Class to Generate Integers\n\nIn the Random class, we have many instance methods which provide random numbers. In this section, we will consider two instance methods, , and .\n\nHow to use the nextInt(int bound) method\n\nreturns an int type pseudo-random number, greater than or equal to zero and less than the bound value.\n\nThe parameter specifies the range. For example, if we specify the bound as 4, will return an int type value, greater than or equal to zero and less than four. 0,1,2,3 are the possible outcomes of .\n\nAs this is an instance method we should create a random object to access this method. Let's try it.\n\nHow to use the nextDouble() method\n\nSimilar to , the returns a double type pseudo-random number, greater than or equal to zero and less than one.\n\nFor more information, you can read the random class's Java documentation.\n\nSo which random number method should you use?\n\nuses the random class. If we only want double type pseudo-random numbers in our application, then we can use .\n\nOtherwise, we can use the random class as it provides various methods to generate pseudo-random numbers in different types such as , , and .\n\nThank you for reading.\n\nYou can connect with me on Medium."
    }
]