[
    {
        "link": "https://docs.python.org/3/library/logging.html",
        "document": "This module defines functions and classes which implement a flexible event logging system for applications and libraries.\n\nThe key benefit of having the logging API provided by a standard library module is that all Python modules can participate in logging, so your application log can include your own messages integrated with messages from third-party modules.\n\nIf you run myapp.py, you should see this in myapp.log:\n\nThe key feature of this idiomatic usage is that the majority of code is simply creating a module level logger with , and using that logger to do any needed logging. This is concise, while allowing downstream code fine-grained control if needed. Logged messages to the module-level logger get forwarded to handlers of loggers in higher-level modules, all the way up to the highest-level logger known as the root logger; this approach is known as hierarchical logging.\n\nFor logging to be useful, it needs to be configured: setting the levels and destinations for each logger, potentially changing how specific modules log, often based on command-line arguments or application configuration. In most cases, like the one above, only the root logger needs to be so configured, since all the lower level loggers at module level eventually forward their messages to its handlers. provides a quick way to configure the root logger that handles many use cases.\n\nThe module provides a lot of functionality and flexibility. If you are unfamiliar with logging, the best way to get to grips with it is to view the tutorials (see the links above and on the right).\n\nThe basic classes defined by the module, together with their attributes and methods, are listed in the sections below.\n• None Loggers expose the interface that application code directly uses.\n• None Handlers send the log records (created by loggers) to the appropriate destination.\n• None Filters provide a finer grained facility for determining which log records to output.\n• None Formatters specify the layout of log records in the final output.\n\nLoggers have the following attributes and methods. Note that Loggers should NEVER be instantiated directly, but always through the module-level function . Multiple calls to with the same name will always return a reference to the same Logger object. The is potentially a period-separated hierarchical value, like (though it could also be just plain , for example). Loggers that are further down in the hierarchical list are children of loggers higher up in the list. For example, given a logger with a name of , loggers with names of , , and are all descendants of . In addition, all loggers are descendants of the root logger. The logger name hierarchy is analogous to the Python package hierarchy, and identical to it if you organise your loggers on a per-module basis using the recommended construction . That’s because in a module, is the module’s name in the Python package namespace. This is the logger’s name, and is the value that was passed to to obtain the logger. This attribute should be treated as read-only. The threshold of this logger, as set by the method. Do not set this attribute directly - always use , which has checks for the level passed to it. The parent logger of this logger. It may change based on later instantiation of loggers which are higher up in the namespace hierarchy. This value should be treated as read-only. If this attribute evaluates to true, events logged to this logger will be passed to the handlers of higher level (ancestor) loggers, in addition to any handlers attached to this logger. Messages are passed directly to the ancestor loggers’ handlers - neither the level nor filters of the ancestor loggers in question are considered. If this evaluates to false, logging messages are not passed to the handlers of ancestor loggers. Spelling it out with an example: If the propagate attribute of the logger named evaluates to true, any event logged to via a method call such as will [subject to passing that logger’s level and filter settings] be passed in turn to any handlers attached to loggers named , and the root logger, after first being passed to any handlers attached to . If any logger in the chain , , has its attribute set to false, then that is the last logger whose handlers are offered the event to handle, and propagation stops at that point. The constructor sets this attribute to . If you attach a handler to a logger and one or more of its ancestors, it may emit the same record multiple times. In general, you should not need to attach a handler to more than one logger - if you just attach it to the appropriate logger which is highest in the logger hierarchy, then it will see all events logged by all descendant loggers, provided that their propagate setting is left set to . A common scenario is to attach handlers only to the root logger, and to let propagation take care of the rest. The list of handlers directly attached to this logger instance. This attribute should be treated as read-only; it is normally changed via the and methods, which use locks to ensure thread-safe operation. This attribute disables handling of any events. It is set to in the initializer, and only changed by logging configuration code. This attribute should be treated as read-only. Sets the threshold for this logger to level. Logging messages which are less severe than level will be ignored; logging messages which have severity level or higher will be emitted by whichever handler or handlers service this logger, unless a handler’s level has been set to a higher severity level than level. When a logger is created, the level is set to (which causes all messages to be processed when the logger is the root logger, or delegation to the parent when the logger is a non-root logger). Note that the root logger is created with level . The term ‘delegation to the parent’ means that if a logger has a level of NOTSET, its chain of ancestor loggers is traversed until either an ancestor with a level other than NOTSET is found, or the root is reached. If an ancestor is found with a level other than NOTSET, then that ancestor’s level is treated as the effective level of the logger where the ancestor search began, and is used to determine how a logging event is handled. If the root is reached, and it has a level of NOTSET, then all messages will be processed. Otherwise, the root’s level will be used as the effective level. See Logging Levels for a list of levels. Changed in version 3.2: The level parameter now accepts a string representation of the level such as ‘INFO’ as an alternative to the integer constants such as . Note, however, that levels are internally stored as integers, and methods such as e.g. and will return/expect to be passed integers. Indicates if a message of severity level would be processed by this logger. This method checks first the module-level level set by and then the logger’s effective level as determined by . Indicates the effective level for this logger. If a value other than has been set using , it is returned. Otherwise, the hierarchy is traversed towards the root until a value other than is found, and that value is returned. The value returned is an integer, typically one of , etc. Returns a logger which is a descendant to this logger, as determined by the suffix. Thus, would return the same logger as would be returned by . This is a convenience method, useful when the parent logger is named using e.g. rather than a literal string. Returns a set of loggers which are immediate children of this logger. So for example might return a set containing loggers named and , but a logger named wouldn’t be included in the set. Likewise, might return a set including a logger named , but it wouldn’t include one named . Logs a message with level on this logger. The msg is the message format string, and the args are the arguments which are merged into msg using the string formatting operator. (Note that this means that you can use keywords in the format string, together with a single dictionary argument.) No % formatting operation is performed on msg when no args are supplied. There are four keyword arguments in kwargs which are inspected: exc_info, stack_info, stacklevel and extra. If exc_info does not evaluate as false, it causes exception information to be added to the logging message. If an exception tuple (in the format returned by ) or an exception instance is provided, it is used; otherwise, is called to get the exception information. The second optional keyword argument is stack_info, which defaults to . If true, stack information is added to the logging message, including the actual logging call. Note that this is not the same stack information as that displayed through specifying exc_info: The former is stack frames from the bottom of the stack up to the logging call in the current thread, whereas the latter is information about stack frames which have been unwound, following an exception, while searching for exception handlers. You can specify stack_info independently of exc_info, e.g. to just show how you got to a certain point in your code, even when no exceptions were raised. The stack frames are printed following a header line which says: This mimics the which is used when displaying exception frames. The third optional keyword argument is stacklevel, which defaults to . If greater than 1, the corresponding number of stack frames are skipped when computing the line number and function name set in the created for the logging event. This can be used in logging helpers so that the function name, filename and line number recorded are not the information for the helper function/method, but rather its caller. The name of this parameter mirrors the equivalent one in the module. The fourth keyword argument is extra which can be used to pass a dictionary which is used to populate the of the created for the logging event with user-defined attributes. These custom attributes can then be used as you like. For example, they could be incorporated into logged messages. For example: would print something like The keys in the dictionary passed in extra should not clash with the keys used by the logging system. (See the section on LogRecord attributes for more information on which keys are used by the logging system.) If you choose to use these attributes in logged messages, you need to exercise some care. In the above example, for instance, the has been set up with a format string which expects ‘clientip’ and ‘user’ in the attribute dictionary of the . If these are missing, the message will not be logged because a string formatting exception will occur. So in this case, you always need to pass the extra dictionary with these keys. While this might be annoying, this feature is intended for use in specialized circumstances, such as multi-threaded servers where the same code executes in many contexts, and interesting conditions which arise are dependent on this context (such as remote client IP address and authenticated user name, in the above example). In such circumstances, it is likely that specialized s would be used with particular s. If no handler is attached to this logger (or any of its ancestors, taking into account the relevant attributes), the message will be sent to the handler set on . Changed in version 3.2: The stack_info parameter was added. Changed in version 3.5: The exc_info parameter can now accept exception instances. Changed in version 3.8: The stacklevel parameter was added. Logs a message with level on this logger. The arguments are interpreted as for . Logs a message with level on this logger. The arguments are interpreted as for . There is an obsolete method which is functionally identical to . As is deprecated, please do not use it - use instead. Logs a message with level on this logger. The arguments are interpreted as for . Logs a message with level on this logger. The arguments are interpreted as for . Logs a message with integer level level on this logger. The other arguments are interpreted as for . Logs a message with level on this logger. The arguments are interpreted as for . Exception info is added to the logging message. This method should only be called from an exception handler. Adds the specified filter filter to this logger. Removes the specified filter filter from this logger. Apply this logger’s filters to the record and return if the record is to be processed. The filters are consulted in turn, until one of them returns a false value. If none of them return a false value, the record will be processed (passed to handlers). If one returns a false value, no further processing of the record occurs. Adds the specified handler hdlr to this logger. Removes the specified handler hdlr from this logger. Finds the caller’s source filename and line number. Returns the filename, line number, function name and stack information as a 4-element tuple. The stack information is returned as unless stack_info is . The stacklevel parameter is passed from code calling the and other APIs. If greater than 1, the excess is used to skip stack frames before determining the values to be returned. This will generally be useful when calling logging APIs from helper/wrapper code, so that the information in the event log refers not to the helper/wrapper code, but to the code that calls it. Handles a record by passing it to all handlers associated with this logger and its ancestors (until a false value of propagate is found). This method is used for unpickled records received from a socket, as well as those created locally. Logger-level filtering is applied using . This is a factory method which can be overridden in subclasses to create specialized instances. Checks to see if this logger has any handlers configured. This is done by looking for handlers in this logger and its parents in the logger hierarchy. Returns if a handler was found, else . The method stops searching up the hierarchy whenever a logger with the ‘propagate’ attribute set to false is found - that will be the last logger which is checked for the existence of handlers. Changed in version 3.7: Loggers can now be pickled and unpickled.\n\ncan be used by and for more sophisticated filtering than is provided by levels. The base filter class only allows events which are below a certain point in the logger hierarchy. For example, a filter initialized with ‘A.B’ will allow events logged by loggers ‘A.B’, ‘A.B.C’, ‘A.B.C.D’, ‘A.B.D’ etc. but not ‘A.BB’, ‘B.A.B’ etc. If initialized with the empty string, all events are passed. Returns an instance of the class. If name is specified, it names a logger which, together with its children, will have its events allowed through the filter. If name is the empty string, allows every event. Is the specified record to be logged? Returns false for no, true for yes. Filters can either modify log records in-place or return a completely different record instance which will replace the original log record in any future processing of the event. Note that filters attached to handlers are consulted before an event is emitted by the handler, whereas filters attached to loggers are consulted whenever an event is logged (using , , etc.), before sending an event to handlers. This means that events which have been generated by descendant loggers will not be filtered by a logger’s filter setting, unless the filter has also been applied to those descendant loggers. You don’t actually need to subclass : you can pass any instance which has a method with the same semantics. Changed in version 3.2: You don’t need to create specialized classes, or use other classes with a method: you can use a function (or other callable) as a filter. The filtering logic will check to see if the filter object has a attribute: if it does, it’s assumed to be a and its method is called. Otherwise, it’s assumed to be a callable and called with the record as the single parameter. The returned value should conform to that returned by . Changed in version 3.12: You can now return a instance from filters to replace the log record rather than modifying it in place. This allows filters attached to a to modify the log record before it is emitted, without having side effects on other handlers. Although filters are used primarily to filter records based on more sophisticated criteria than levels, they get to see every record which is processed by the handler or logger they’re attached to: this can be useful if you want to do things like counting how many records were processed by a particular logger or handler, or adding, changing or removing attributes in the being processed. Obviously changing the LogRecord needs to be done with some care, but it does allow the injection of contextual information into logs (see Using Filters to impart contextual information).\n\nThe LogRecord has a number of attributes, most of which are derived from the parameters to the constructor. (Note that the names do not always correspond exactly between the LogRecord constructor parameters and the LogRecord attributes.) These attributes can be used to merge data from the record into the format string. The following table lists (in alphabetical order) the attribute names, their meanings and the corresponding placeholder in a %-style format string. If you are using {}-formatting ( ), you can use as the placeholder in the format string. If you are using $-formatting ( ), use the form . In both cases, of course, replace with the actual attribute name you want to use. In the case of {}-formatting, you can specify formatting flags by placing them after the attribute name, separated from it with a colon. For example: a placeholder of would format a millisecond value of as . Refer to the documentation for full details on the options available to you. You shouldn’t need to format this yourself. The tuple of arguments merged into to produce , or a dict whose values are used for the merge (when there is only one argument, and it is a dictionary). Human-readable time when the was created. By default this is of the form ‘2003-07-08 16:49:45,896’ (the numbers after the comma are millisecond portion of the time). Time when the was created (as returned by / 1e9). You shouldn’t need to format this yourself. Exception tuple (à la ) or, if no exception has occurred, . Name of function containing the logging call. Source line number where the logging call was issued (if available). The logged message, computed as . This is set when is invoked. Millisecond portion of the time when the was created. You shouldn’t need to format this yourself. The format string passed in the original logging call. Merged with to produce , or an arbitrary object (see Using arbitrary objects as messages). Name of the logger used to log the call. Full pathname of the source file where the logging call was issued (if available). Process name (if available). Time in milliseconds when the LogRecord was created, relative to the time the logging module was loaded. You shouldn’t need to format this yourself. Stack frame information (where available) from the bottom of the stack in the current thread, up to and including the stack frame of the logging call which resulted in the creation of this record. Thread name (if available). name (if available).\n\nIn addition to the classes described above, there are a number of module-level functions. Return a logger with the specified name or, if name is , return the root logger of the hierarchy. If specified, the name is typically a dot-separated hierarchical name like ‘a’, ‘a.b’ or ‘a.b.c.d’. Choice of these names is entirely up to the developer who is using logging, though it is recommended that be used unless you have a specific reason for not doing that, as mentioned in Logger Objects. All calls to this function with a given name return the same logger instance. This means that logger instances never need to be passed between different parts of an application. Return either the standard class, or the last class passed to . This function may be called from within a new class definition, to ensure that installing a customized class will not undo customizations already applied by other code. For example: Return a callable which is used to create a . Added in version 3.2: This function has been provided, along with , to allow developers more control over how the representing a logging event is constructed. See for more information about the how the factory is called. This is a convenience function that calls , on the root logger. The handling of the arguments is in every way identical to what is described in that method. The only difference is that if the root logger has no handlers, then is called, prior to calling on the root logger. For very short scripts or quick demonstrations of facilities, and the other module-level functions may be convenient. However, most programs will want to carefully and explicitly control the logging configuration, and should therefore prefer creating a module-level logger and calling (or other level-specific methods) on it, as described at the beginnning of this documentation. Logs a message with level on the root logger. The arguments and behavior are otherwise the same as for . Logs a message with level on the root logger. The arguments and behavior are otherwise the same as for . There is an obsolete function which is functionally identical to . As is deprecated, please do not use it - use instead. Logs a message with level on the root logger. The arguments and behavior are otherwise the same as for . Logs a message with level on the root logger. The arguments and behavior are otherwise the same as for . Logs a message with level on the root logger. The arguments and behavior are otherwise the same as for . Exception info is added to the logging message. This function should only be called from an exception handler. Logs a message with level level on the root logger. The arguments and behavior are otherwise the same as for . Provides an overriding level level for all loggers which takes precedence over the logger’s own level. When the need arises to temporarily throttle logging output down across the whole application, this function can be useful. Its effect is to disable all logging calls of severity level and below, so that if you call it with a value of INFO, then all INFO and DEBUG events would be discarded, whereas those of severity WARNING and above would be processed according to the logger’s effective level. If is called, it effectively removes this overriding level, so that logging output again depends on the effective levels of individual loggers. Note that if you have defined any custom logging level higher than (this is not recommended), you won’t be able to rely on the default value for the level parameter, but will have to explicitly supply a suitable value. Changed in version 3.7: The level parameter was defaulted to level . See bpo-28524 for more information about this change. Associates level level with text levelName in an internal dictionary, which is used to map numeric levels to a textual representation, for example when a formats a message. This function can also be used to define your own levels. The only constraints are that all levels used must be registered using this function, levels should be positive integers and they should increase in increasing order of severity. If you are thinking of defining your own levels, please see the section on Custom Levels. Returns a mapping from level names to their corresponding logging levels. For example, the string “CRITICAL” maps to . The returned mapping is copied from an internal mapping on each call to this function. Returns the textual or numeric representation of logging level level. If level is one of the predefined levels , , , or then you get the corresponding string. If you have associated levels with names using then the name you have associated with level is returned. If a numeric value corresponding to one of the defined levels is passed in, the corresponding string representation is returned. The level parameter also accepts a string representation of the level such as ‘INFO’. In such cases, this functions returns the corresponding numeric value of the level. If no matching numeric or string value is passed in, the string ‘Level %s’ % level is returned. Levels are internally integers (as they need to be compared in the logging logic). This function is used to convert between an integer level and the level name displayed in the formatted log output by means of the format specifier (see LogRecord attributes), and vice versa. Changed in version 3.4: In Python versions earlier than 3.4, this function could also be passed a text level, and would return the corresponding numeric value of the level. This undocumented behaviour was considered a mistake, and was removed in Python 3.4, but reinstated in 3.4.2 due to retain backward compatibility. Returns a handler with the specified name, or if there is no handler with that name. Returns an immutable set of all known handler names. Creates and returns a new instance whose attributes are defined by attrdict. This function is useful for taking a pickled attribute dictionary, sent over a socket, and reconstituting it as a instance at the receiving end. Does basic configuration for the logging system by creating a with a default and adding it to the root logger. The functions , , , and will call automatically if no handlers are defined for the root logger. This function does nothing if the root logger already has handlers configured, unless the keyword argument force is set to . This function should be called from the main thread before other threads are started. In versions of Python prior to 2.7.1 and 3.2, if this function is called from multiple threads, it is possible (in rare circumstances) that a handler will be added to the root logger more than once, leading to unexpected results such as messages being duplicated in the log. The following keyword arguments are supported. Specifies that a be created, using the specified filename, rather than a . If filename is specified, open the file in this mode. Defaults to . Use the specified format string for the handler. Defaults to attributes , and separated by colons. Use the specified date/time format, as accepted by . If format is specified, use this style for the format string. One of , or for printf-style, or respectively. Defaults to . Set the root logger level to the specified level. Use the specified stream to initialize the . Note that this argument is incompatible with filename - if both are present, a is raised. If specified, this should be an iterable of already created handlers to add to the root logger. Any handlers which don’t already have a formatter set will be assigned the default formatter created in this function. Note that this argument is incompatible with filename or stream - if both are present, a is raised. If this keyword argument is specified as true, any existing handlers attached to the root logger are removed and closed, before carrying out the configuration as specified by the other arguments. If this keyword argument is specified along with filename, its value is used when the is created, and thus used when opening the output file. If this keyword argument is specified along with filename, its value is used when the is created, and thus used when opening the output file. If not specified, the value ‘backslashreplace’ is used. Note that if is specified, it will be passed as such to , which means that it will be treated the same as passing ‘errors’. Changed in version 3.2: The style argument was added. Changed in version 3.3: The handlers argument was added. Additional checks were added to catch situations where incompatible arguments are specified (e.g. handlers together with stream or filename, or stream together with filename). Changed in version 3.8: The force argument was added. Changed in version 3.9: The encoding and errors arguments were added. Informs the logging system to perform an orderly shutdown by flushing and closing all handlers. This should be called at application exit and no further use of the logging system should be made after this call. When the logging module is imported, it registers this function as an exit handler (see ), so normally there’s no need to do that manually. Tells the logging system to use the class klass when instantiating a logger. The class should define such that only a name argument is required, and the should call . This function is typically called before any loggers are instantiated by applications which need to use custom logger behavior. After this call, as at any other time, do not instantiate loggers directly using the subclass: continue to use the API to get your loggers. Set a callable which is used to create a . factory – The factory callable to be used to instantiate a log record. Added in version 3.2: This function has been provided, along with , to allow developers more control over how the representing a logging event is constructed. The factory has the following signature: The full pathname of the file where the logging call was made. The line number in the file where the logging call was made. The arguments for the logging message. The name of the function or method which invoked the logging call. A stack traceback such as is provided by , showing the call hierarchy."
    },
    {
        "link": "https://docs.python.org/3/howto/logging.html",
        "document": "This page contains tutorial information. For links to reference information and a logging cookbook, please see Other resources.\n\nLogging is a means of tracking events that happen when some software runs. The software’s developer adds logging calls to their code to indicate that certain events have occurred. An event is described by a descriptive message which can optionally contain variable data (i.e. data that is potentially different for each occurrence of the event). Events also have an importance which the developer ascribes to the event; the importance can also be called the level or severity. When to use logging¶ You can access logging functionality by creating a logger via , and then calling the logger’s , , , and methods. To determine when to use logging, and to see which logger methods to use when, see the table below. It states, for each of a set of common tasks, the best tool to use for that task. The best tool for the task Display console output for ordinary usage of a command line script or program Report events that occur during normal operation of a program (e.g. for status monitoring or fault investigation) A logger’s (or method for very detailed output for diagnostic purposes) in library code if the issue is avoidable and the client application should be modified to eliminate the warning A logger’s method if there is nothing the client application can do about the situation, but the event should still be noted Report an error regarding a particular runtime event Report suppression of an error without raising an exception (e.g. error handler in a long-running server process) A logger’s , or method as appropriate for the specific error and application domain The logger methods are named after the level or severity of the events they are used to track. The standard levels and their applicability are described below (in increasing order of severity): Detailed information, typically of interest only when diagnosing problems. Confirmation that things are working as expected. An indication that something unexpected happened, or indicative of some problem in the near future (e.g. ‘disk space low’). The software is still working as expected. Due to a more serious problem, the software has not been able to perform some function. A serious error, indicating that the program itself may be unable to continue running. The default level is , which means that only events of this severity and higher will be tracked, unless the logging package is configured to do otherwise. Events that are tracked can be handled in different ways. The simplest way of handling tracked events is to print them to the console. Another common way is to write them to a disk file. A very simple example is: # will print a message to the console # will not print anything If you type these lines into a script and run it, you’ll see: printed out on the console. The message doesn’t appear because the default level is . The printed message includes the indication of the level and the description of the event provided in the logging call, i.e. ‘Watch out!’. The actual output can be formatted quite flexibly if you need that; formatting options will also be explained later. Notice that in this example, we use functions directly on the module, like , rather than creating a logger and calling functions on it. These functions operation on the root logger, but can be useful as they will call for you if it has not been called yet, like in this example. In larger programs you’ll usually want to control the logging configuration explicitly however - so for that reason as well as others, it’s better to create loggers and call their methods. A very common situation is that of recording logging events in a file, so let’s look at that next. Be sure to try the following in a newly started Python interpreter, and don’t just continue from the session described above: 'This message should go to the log file' 'And non-ASCII stuff, too, like Øresund and Malmö' Changed in version 3.9: The encoding argument was added. In earlier Python versions, or if not specified, the encoding used is the default value used by . While not shown in the above example, an errors argument can also now be passed, which determines how encoding errors are handled. For available values and the default, see the documentation for . And now if we open the file and look at what we have, we should find the log messages: DEBUG:__main__:This message should go to the log file INFO:__main__:So should this WARNING:__main__:And this, too ERROR:__main__:And non-ASCII stuff, too, like Øresund and Malmö This example also shows how you can set the logging level which acts as the threshold for tracking. In this case, because we set the threshold to , all of the messages were printed. If you want to set the logging level from a command-line option such as: and you have the value of the parameter passed for in some variable loglevel, you can use: to get the value which you’ll pass to via the level argument. You may want to error check any user input value, perhaps as in the following example: # assuming loglevel is bound to the string value obtained from the # command line argument. Convert to upper case to allow the user to The call to should come before any calls to a logger’s methods such as , , etc. Otherwise, that logging event may not be handled in the desired manner. If you run the above script several times, the messages from successive runs are appended to the file example.log. If you want each run to start afresh, not remembering the messages from earlier runs, you can specify the filemode argument, by changing the call in the above example to: The output will be the same as before, but the log file is no longer appended to, so the messages from earlier runs are lost. To log variable data, use a format string for the event description message and append the variable data as arguments. For example: As you can see, merging of variable data into the event description message uses the old, %-style of string formatting. This is for backwards compatibility: the logging package pre-dates newer formatting options such as and . These newer formatting options are supported, but exploring them is outside the scope of this tutorial: see Using particular formatting styles throughout your application for more information. To change the format which is used to display messages, you need to specify the format you want to use: 'This message should appear on the console' DEBUG:This message should appear on the console INFO:So should this WARNING:And this, too Notice that the ‘root’ which appeared in earlier examples has disappeared. For a full set of things that can appear in format strings, you can refer to the documentation for LogRecord attributes, but for simple usage, you just need the levelname (severity), message (event description, including variable data) and perhaps to display when the event occurred. This is described in the next section. That concludes the basic tutorial. It should be enough to get you up and running with logging. There’s a lot more that the logging package offers, but to get the best out of it, you’ll need to invest a little more of your time in reading the following sections. If you’re ready for that, grab some of your favourite beverage and carry on. If your logging needs are simple, then use the above examples to incorporate logging into your own scripts, and if you run into problems or don’t understand something, please post a question on the comp.lang.python Usenet group (available at https://groups.google.com/g/comp.lang.python) and you should receive help before too long. Still here? You can carry on reading the next few sections, which provide a slightly more advanced/in-depth tutorial than the basic one above. After that, you can take a look at the Logging Cookbook.\n\nThe logging library takes a modular approach and offers several categories of components: loggers, handlers, filters, and formatters.\n• None Loggers expose the interface that application code directly uses.\n• None Handlers send the log records (created by loggers) to the appropriate destination.\n• None Filters provide a finer grained facility for determining which log records to output.\n• None Formatters specify the layout of log records in the final output. Log event information is passed between loggers, handlers, filters and formatters in a instance. Logging is performed by calling methods on instances of the class (hereafter called loggers). Each instance has a name, and they are conceptually arranged in a namespace hierarchy using dots (periods) as separators. For example, a logger named ‘scan’ is the parent of loggers ‘scan.text’, ‘scan.html’ and ‘scan.pdf’. Logger names can be anything you want, and indicate the area of an application in which a logged message originates. A good convention to use when naming loggers is to use a module-level logger, in each module which uses logging, named as follows: This means that logger names track the package/module hierarchy, and it’s intuitively obvious where events are logged just from the logger name. The root of the hierarchy of loggers is called the root logger. That’s the logger used by the functions , , , and , which just call the same-named method of the root logger. The functions and the methods have the same signatures. The root logger’s name is printed as ‘root’ in the logged output. It is, of course, possible to log messages to different destinations. Support is included in the package for writing log messages to files, HTTP GET/POST locations, email via SMTP, generic sockets, queues, or OS-specific logging mechanisms such as syslog or the Windows NT event log. Destinations are served by handler classes. You can create your own log destination class if you have special requirements not met by any of the built-in handler classes. By default, no destination is set for any logging messages. You can specify a destination (such as console or file) by using as in the tutorial examples. If you call the functions , , , and , they will check to see if no destination is set; and if one is not set, they will set a destination of the console ( ) and a default format for the displayed message before delegating to the root logger to do the actual message output. The default format set by for messages is: You can change this by passing a format string to with the format keyword argument. For all options regarding how a format string is constructed, see Formatter Objects. The flow of log event information in loggers and handlers is illustrated in the following diagram. At least one handler objects have a threefold job. First, they expose several methods to application code so that applications can log messages at runtime. Second, logger objects determine which log messages to act upon based upon severity (the default filtering facility) or filter objects. Third, logger objects pass along relevant log messages to all interested log handlers. The most widely used methods on logger objects fall into two categories: configuration and message sending. These are the most common configuration methods:\n• None specifies the lowest-severity log message a logger will handle, where debug is the lowest built-in severity level and critical is the highest built-in severity. For example, if the severity level is INFO, the logger will handle only INFO, WARNING, ERROR, and CRITICAL messages and will ignore DEBUG messages.\n• None and add and remove handler objects from the logger object. Handlers are covered in more detail in Handlers.\n• None and add and remove filter objects from the logger object. Filters are covered in more detail in Filter Objects. You don’t need to always call these methods on every logger you create. See the last two paragraphs in this section. With the logger object configured, the following methods create log messages:\n• None , , , , and all create log records with a message and a level that corresponds to their respective method names. The message is actually a format string, which may contain the standard string substitution syntax of , , , and so on. The rest of their arguments is a list of objects that correspond with the substitution fields in the message. With regard to , the logging methods care only about a keyword of and use it to determine whether to log exception information.\n• None creates a log message similar to . The difference is that dumps a stack trace along with it. Call this method only from an exception handler.\n• None takes a log level as an explicit argument. This is a little more verbose for logging messages than using the log level convenience methods listed above, but this is how to log at custom log levels. returns a reference to a logger instance with the specified name if it is provided, or if not. The names are period-separated hierarchical structures. Multiple calls to with the same name will return a reference to the same logger object. Loggers that are further down in the hierarchical list are children of loggers higher up in the list. For example, given a logger with a name of , loggers with names of , , and are all descendants of . Loggers have a concept of effective level. If a level is not explicitly set on a logger, the level of its parent is used instead as its effective level. If the parent has no explicit level set, its parent is examined, and so on - all ancestors are searched until an explicitly set level is found. The root logger always has an explicit level set ( by default). When deciding whether to process an event, the effective level of the logger is used to determine whether the event is passed to the logger’s handlers. Child loggers propagate messages up to the handlers associated with their ancestor loggers. Because of this, it is unnecessary to define and configure handlers for all the loggers an application uses. It is sufficient to configure handlers for a top-level logger and create child loggers as needed. (You can, however, turn off propagation by setting the propagate attribute of a logger to .) objects are responsible for dispatching the appropriate log messages (based on the log messages’ severity) to the handler’s specified destination. objects can add zero or more handler objects to themselves with an method. As an example scenario, an application may want to send all log messages to a log file, all log messages of error or higher to stdout, and all messages of critical to an email address. This scenario requires three individual handlers where each handler is responsible for sending messages of a specific severity to a specific location. The standard library includes quite a few handler types (see Useful Handlers); the tutorials use mainly and in its examples. There are very few methods in a handler for application developers to concern themselves with. The only handler methods that seem relevant for application developers who are using the built-in handler objects (that is, not creating custom handlers) are the following configuration methods:\n• None The method, just as in logger objects, specifies the lowest severity that will be dispatched to the appropriate destination. Why are there two methods? The level set in the logger determines which severity of messages it will pass to its handlers. The level set in each handler determines which messages that handler will send on.\n• None selects a Formatter object for this handler to use.\n• None and respectively configure and deconfigure filter objects on handlers. Application code should not directly instantiate and use instances of . Instead, the class is a base class that defines the interface that all handlers should have and establishes some default behavior that child classes can use (or override). Formatter objects configure the final order, structure, and contents of the log message. Unlike the base class, application code may instantiate formatter classes, although you could likely subclass the formatter if your application needs special behavior. The constructor takes three optional arguments – a message format string, a date format string and a style indicator. If there is no message format string, the default is to use the raw message. If there is no date format string, the default date format is: with the milliseconds tacked on at the end. The is one of , , or . If one of these is not specified, then will be used. If the is , the message format string uses styled string substitution; the possible keys are documented in LogRecord attributes. If the style is , the message format string is assumed to be compatible with (using keyword arguments), while if the style is then the message format string should conform to what is expected by . The following message format string will log the time in a human-readable format, the severity of the message, and the contents of the message, in that order: Formatters use a user-configurable function to convert the creation time of a record to a tuple. By default, is used; to change this for a particular formatter instance, set the attribute of the instance to a function with the same signature as or . To change it for all formatters, for example if you want all logging times to be shown in GMT, set the attribute in the Formatter class (to for GMT display). Programmers can configure logging in three ways:\n• None Creating loggers, handlers, and formatters explicitly using Python code that calls the configuration methods listed above.\n• None Creating a logging config file and reading it using the function.\n• None Creating a dictionary of configuration information and passing it to the function. For the reference documentation on the last two options, see Configuration functions. The following example configures a very simple logger, a console handler, and a simple formatter using Python code: Running this module from the command line produces the following output: The following Python module creates a logger, handler, and formatter nearly identical to those in the example listed above, with the only difference being the names of the objects: Here is the logging.conf file: The output is nearly identical to that of the non-config-file-based example: You can see that the config file approach has a few advantages over the Python code approach, mainly separation of configuration and code and the ability of noncoders to easily modify the logging properties. The function takes a default parameter, , which defaults to for reasons of backward compatibility. This may or may not be what you want, since it will cause any non-root loggers existing before the call to be disabled unless they (or an ancestor) are explicitly named in the configuration. Please refer to the reference documentation for more information, and specify for this parameter if you wish. The dictionary passed to can also specify a Boolean value with key , which if not specified explicitly in the dictionary also defaults to being interpreted as . This leads to the logger-disabling behaviour described above, which may not be what you want - in which case, provide the key explicitly with a value of . Note that the class names referenced in config files need to be either relative to the logging module, or absolute values which can be resolved using normal import mechanisms. Thus, you could use either (relative to the logging module) or (for a class defined in package and module , where is available on the Python import path). In Python 3.2, a new means of configuring logging has been introduced, using dictionaries to hold configuration information. This provides a superset of the functionality of the config-file-based approach outlined above, and is the recommended configuration method for new applications and deployments. Because a Python dictionary is used to hold configuration information, and since you can populate that dictionary using different means, you have more options for configuration. For example, you can use a configuration file in JSON format, or, if you have access to YAML processing functionality, a file in YAML format, to populate the configuration dictionary. Or, of course, you can construct the dictionary in Python code, receive it in pickled form over a socket, or use whatever approach makes sense for your application. Here’s an example of the same configuration as above, in YAML format for the new dictionary-based approach: For more information about logging using a dictionary, see Configuration functions. What happens if no configuration is provided¶ If no logging configuration is provided, it is possible to have a situation where a logging event needs to be output, but no handlers can be found to output the event. The event is output using a ‘handler of last resort’, stored in . This internal handler is not associated with any logger, and acts like a which writes the event description message to the current value of (therefore respecting any redirections which may be in effect). No formatting is done on the message - just the bare event description message is printed. The handler’s level is set to , so all events at this and greater severities will be output. Changed in version 3.2: For versions of Python prior to 3.2, the behaviour is as follows:\n• None If is (production mode), the event is silently dropped.\n• None If is (development mode), a message ‘No handlers could be found for logger X.Y.Z’ is printed once. To obtain the pre-3.2 behaviour, can be set to . When developing a library which uses logging, you should take care to document how the library uses logging - for example, the names of loggers used. Some consideration also needs to be given to its logging configuration. If the using application does not use logging, and library code makes logging calls, then (as described in the previous section) events of severity and greater will be printed to . This is regarded as the best default behaviour. If for some reason you don’t want these messages printed in the absence of any logging configuration, you can attach a do-nothing handler to the top-level logger for your library. This avoids the message being printed, since a handler will always be found for the library’s events: it just doesn’t produce any output. If the library user configures logging for application use, presumably that configuration will add some handlers, and if levels are suitably configured then logging calls made in library code will send output to those handlers, as normal. A do-nothing handler is included in the logging package: (since Python 3.1). An instance of this handler could be added to the top-level logger of the logging namespace used by the library (if you want to prevent your library’s logged events being output to in the absence of logging configuration). If all logging by a library foo is done using loggers with names matching ‘foo.x’, ‘foo.x.y’, etc. then the code: should have the desired effect. If an organisation produces a number of libraries, then the logger name specified can be ‘orgname.foo’ rather than just ‘foo’. It is strongly advised that you do not log to the root logger in your library. Instead, use a logger with a unique and easily identifiable name, such as the for your library’s top-level package or module. Logging to the root logger will make it difficult or impossible for the application developer to configure the logging verbosity or handlers of your library as they wish. It is strongly advised that you do not add any handlers other than to your library’s loggers. This is because the configuration of handlers is the prerogative of the application developer who uses your library. The application developer knows their target audience and what handlers are most appropriate for their application: if you add handlers ‘under the hood’, you might well interfere with their ability to carry out unit tests and deliver logs which suit their requirements.\n\nThe numeric values of logging levels are given in the following table. These are primarily of interest if you want to define your own levels, and need them to have specific values relative to the predefined levels. If you define a level with the same numeric value, it overwrites the predefined value; the predefined name is lost. Levels can also be associated with loggers, being set either by the developer or through loading a saved logging configuration. When a logging method is called on a logger, the logger compares its own level with the level associated with the method call. If the logger’s level is higher than the method call’s, no logging message is actually generated. This is the basic mechanism controlling the verbosity of logging output. Logging messages are encoded as instances of the class. When a logger decides to actually log an event, a instance is created from the logging message. Logging messages are subjected to a dispatch mechanism through the use of handlers, which are instances of subclasses of the class. Handlers are responsible for ensuring that a logged message (in the form of a ) ends up in a particular location (or set of locations) which is useful for the target audience for that message (such as end users, support desk staff, system administrators, developers). Handlers are passed instances intended for particular destinations. Each logger can have zero, one or more handlers associated with it (via the method of ). In addition to any handlers directly associated with a logger, all handlers associated with all ancestors of the logger are called to dispatch the message (unless the propagate flag for a logger is set to a false value, at which point the passing to ancestor handlers stops). Just as for loggers, handlers can have levels associated with them. A handler’s level acts as a filter in the same way as a logger’s level does. If a handler decides to actually dispatch an event, the method is used to send the message to its destination. Most user-defined subclasses of will need to override this . Defining your own levels is possible, but should not be necessary, as the existing levels have been chosen on the basis of practical experience. However, if you are convinced that you need custom levels, great care should be exercised when doing this, and it is possibly a very bad idea to define custom levels if you are developing a library. That’s because if multiple library authors all define their own custom levels, there is a chance that the logging output from such multiple libraries used together will be difficult for the using developer to control and/or interpret, because a given numeric value might mean different things for different libraries.\n\nFormatting of message arguments is deferred until it cannot be avoided. However, computing the arguments passed to the logging method can also be expensive, and you may want to avoid doing it if the logger will just throw away your event. To decide what to do, you can call the method which takes a level argument and returns true if the event would be created by the Logger for that level of call. You can write code like this: so that if the logger’s threshold is set above , the calls to and are never made. In some cases, can itself be more expensive than you’d like (e.g. for deeply nested loggers where an explicit level is only set high up in the logger hierarchy). In such cases (or if you want to avoid calling a method in tight loops), you can cache the result of a call to in a local or instance variable, and use that instead of calling the method each time. Such a cached value would only need to be recomputed when the logging configuration changes dynamically while the application is running (which is not all that common). There are other optimizations which can be made for specific applications which need more precise control over what logging information is collected. Here’s a list of things you can do to avoid processing during logging which you don’t need: What you don’t want to collect How to avoid collecting it Information about where calls were made from. Set to . This avoids calling , which may help to speed up your code in environments like PyPy (which can’t speed up code that uses ). Current process name when using to manage multiple processes. Current name when using . Also note that the core logging module only includes the basic handlers. If you don’t import and , they won’t take up any memory."
    },
    {
        "link": "https://loggly.com/ultimate-guide/python-logging-basics",
        "document": ""
    },
    {
        "link": "https://docs.python.org/3/library/logging.handlers.html",
        "document": "The following useful handlers are provided in the package. Note that three of the handlers ( , and ) are actually defined in the module itself, but have been documented here along with the other handlers.\n\nThe class, located in the module, is a which watches the file it is logging to. If the file changes, it is closed and reopened using the file name. A file change can happen because of usage of programs such as newsyslog and logrotate which perform log file rotation. This handler, intended for use under Unix/Linux, watches the file to see if it has changed since the last emit. (A file is deemed to have changed if its device or inode have changed.) If the file has changed, the old file stream is closed, and the file opened to get a new stream. This handler is not appropriate for use under Windows, because under Windows open log files cannot be moved or renamed - logging opens the files with exclusive locks - and so there is no need for such a handler. Furthermore, ST_INO is not supported under Windows; always returns zero for this value. Returns a new instance of the class. The specified file is opened and used as the stream for logging. If mode is not specified, is used. If encoding is not , it is used to open the file with that encoding. If delay is true, then file opening is deferred until the first call to . By default, the file grows indefinitely. If errors is provided, it determines how encoding errors are handled. Changed in version 3.6: As well as string values, objects are also accepted for the filename argument. Changed in version 3.9: The errors parameter was added. Checks to see if the file has changed. If it has, the existing stream is flushed and closed and the file opened again, typically as a precursor to outputting the record to the file. Outputs the record to the file, but first calls to reopen the file if it has changed.\n\nThe class, located in the module, is the base class for the rotating file handlers, and . You should not need to instantiate this class, but it has attributes and methods you may need to override. The parameters are as for . The attributes are: If this attribute is set to a callable, the method delegates to this callable. The parameters passed to the callable are those passed to . The namer function is called quite a few times during rollover, so it should be as simple and as fast as possible. It should also return the same output every time for a given input, otherwise the rollover behaviour may not work as expected. It’s also worth noting that care should be taken when using a namer to preserve certain attributes in the filename which are used during rotation. For example, expects to have a set of log files whose names contain successive integers, so that rotation works as expected, and deletes old log files (based on the parameter passed to the handler’s initializer) by determining the oldest files to delete. For this to happen, the filenames should be sortable using the date/time portion of the filename, and a namer needs to respect this. (If a namer is wanted that doesn’t respect this scheme, it will need to be used in a subclass of which overrides the method to fit in with the custom naming scheme.) If this attribute is set to a callable, the method delegates to this callable. The parameters passed to the callable are those passed to . Modify the filename of a log file when rotating. This is provided so that a custom filename can be provided. The default implementation calls the ‘namer’ attribute of the handler, if it’s callable, passing the default name to it. If the attribute isn’t callable (the default is ), the name is returned unchanged. default_name – The default name for the log file. The default implementation calls the ‘rotator’ attribute of the handler, if it’s callable, passing the source and dest arguments to it. If the attribute isn’t callable (the default is ), the source is simply renamed to the destination.\n• None source – The source filename. This is normally the base filename, e.g. ‘test.log’.\n• None dest – The destination filename. This is normally what the source is rotated to, e.g. ‘test.log.1’. The reason the attributes exist is to save you having to subclass - you can use the same callables for instances of and . If either the namer or rotator callable raises an exception, this will be handled in the same way as any other exception during an call, i.e. via the method of the handler. If you need to make more significant changes to rotation processing, you can override the methods. For an example, see Using a rotator and namer to customize log rotation processing.\n\nThe class, located in the module, supports rotation of disk log files at certain timed intervals. Returns a new instance of the class. The specified file is opened and used as the stream for logging. On rotating it also sets the filename suffix. Rotating happens based on the product of when and interval. You can use the when to specify the type of interval. The list of possible values is below. Note that they are not case sensitive. Roll over at midnight, if atTime not specified, else at time atTime When using weekday-based rotation, specify ‘W0’ for Monday, ‘W1’ for Tuesday, and so on up to ‘W6’ for Sunday. In this case, the value passed for interval isn’t used. The system will save old log files by appending extensions to the filename. The extensions are date-and-time based, using the strftime format or a leading portion thereof, depending on the rollover interval. When computing the next rollover time for the first time (when the handler is created), the last modification time of an existing log file, or else the current time, is used to compute when the next rotation will occur. If the utc argument is true, times in UTC will be used; otherwise local time is used. If backupCount is nonzero, at most backupCount files will be kept, and if more would be created when rollover occurs, the oldest one is deleted. The deletion logic uses the interval to determine which files to delete, so changing the interval may leave old files lying around. If delay is true, then file opening is deferred until the first call to . If atTime is not , it must be a instance which specifies the time of day when rollover occurs, for the cases where rollover is set to happen “at midnight” or “on a particular weekday”. Note that in these cases, the atTime value is effectively used to compute the initial rollover, and subsequent rollovers would be calculated via the normal interval calculation. If errors is specified, it’s used to determine how encoding errors are handled. Calculation of the initial rollover time is done when the handler is initialised. Calculation of subsequent rollover times is done only when rollover occurs, and rollover occurs only when emitting output. If this is not kept in mind, it might lead to some confusion. For example, if an interval of “every minute” is set, that does not mean you will always see log files with times (in the filename) separated by a minute; if, during application execution, logging output is generated more frequently than once a minute, then you can expect to see log files with times separated by a minute. If, on the other hand, logging messages are only output once every five minutes (say), then there will be gaps in the file times corresponding to the minutes where no output (and hence no rollover) occurred. Changed in version 3.6: As well as string values, objects are also accepted for the filename argument. Changed in version 3.9: The errors parameter was added. Does a rollover, as described above. Outputs the record to the file, catering for rollover as described above. Returns a list of filenames which should be deleted as part of rollover. These are the absolute paths of the oldest backup log files written by the handler.\n\nThe class, located in the module, supports sending logging messages to a remote or local Unix syslog. Returns a new instance of the class intended to communicate with a remote Unix machine whose address is given by address in the form of a tuple. If address is not specified, is used. The address is used to open a socket. An alternative to providing a tuple is providing an address as a string, for example ‘/dev/log’. In this case, a Unix domain socket is used to send the message to the syslog. If facility is not specified, is used. The type of socket opened depends on the socktype argument, which defaults to and thus opens a UDP socket. To open a TCP socket (for use with the newer syslog daemons such as rsyslog), specify a value of . Note that if your server is not listening on UDP port 514, may appear not to work. In that case, check what address you should be using for a domain socket - it’s system dependent. For example, on Linux it’s usually ‘/dev/log’ but on OS/X it’s ‘/var/run/syslog’. You’ll need to check your platform and use the appropriate address (you may need to do this check at runtime if your application needs to run on several platforms). On Windows, you pretty much have to use the UDP option. On macOS 12.x (Monterey), Apple has changed the behaviour of their syslog daemon - it no longer listens on a domain socket. Therefore, you cannot expect to work on this system. See gh-91070 for more information. Closes the socket to the remote host. Tries to create a socket and, if it’s not a datagram socket, connect it to the other end. This method is called during handler initialization, but it’s not regarded as an error if the other end isn’t listening at this point - the method will be called again when emitting an event, if there is no socket at that point. The record is formatted, and then sent to the syslog server. If exception information is present, it is not sent to the server. Changed in version 3.2.1: (See: bpo-12168.) In earlier versions, the message sent to the syslog daemons was always terminated with a NUL byte, because early versions of these daemons expected a NUL terminated message - even though it’s not in the relevant specification (RFC 5424). More recent versions of these daemons don’t expect the NUL byte but strip it off if it’s there, and even more recent daemons (which adhere more closely to RFC 5424) pass the NUL byte on as part of the message. To enable easier handling of syslog messages in the face of all these differing daemon behaviours, the appending of the NUL byte has been made configurable, through the use of a class-level attribute, . This defaults to (preserving the existing behaviour) but can be set to on a instance in order for that instance to not append the NUL terminator. Changed in version 3.3: (See: bpo-12419.) In earlier versions, there was no facility for an “ident” or “tag” prefix to identify the source of the message. This can now be specified using a class-level attribute, defaulting to to preserve existing behaviour, but which can be overridden on a instance in order for that instance to prepend the ident to every message handled. Note that the provided ident must be text, not bytes, and is prepended to the message exactly as is. Encodes the facility and priority into an integer. You can pass in strings or integers - if strings are passed, internal mapping dictionaries are used to convert them to integers. The symbolic values are defined in and mirror the values defined in the header file. Maps a logging level name to a syslog priority name. You may need to override this if you are using custom levels, or if the default algorithm is not suitable for your needs. The default algorithm maps , , , and to the equivalent syslog names, and all other level names to ‘warning’.\n\nThe class, located in the module, supports sending logging messages to a local Windows NT, Windows 2000 or Windows XP event log. Before you can use it, you need Mark Hammond’s Win32 extensions for Python installed. Returns a new instance of the class. The appname is used to define the application name as it appears in the event log. An appropriate registry entry is created using this name. The dllname should give the fully qualified pathname of a .dll or .exe which contains message definitions to hold in the log (if not specified, is used - this is installed with the Win32 extensions and contains some basic placeholder message definitions. Note that use of these placeholders will make your event logs big, as the entire message source is held in the log. If you want slimmer logs, you have to pass in the name of your own .dll or .exe which contains the message definitions you want to use in the event log). The logtype is one of , or , and defaults to . At this point, you can remove the application name from the registry as a source of event log entries. However, if you do this, you will not be able to see the events as you intended in the Event Log Viewer - it needs to be able to access the registry to get the .dll name. The current version does not do this. Determines the message ID, event category and event type, and then logs the message in the NT event log. Returns the event category for the record. Override this if you want to specify your own categories. This version returns 0. Returns the event type for the record. Override this if you want to specify your own types. This version does a mapping using the handler’s typemap attribute, which is set up in to a dictionary which contains mappings for , , , and . If you are using your own levels, you will either need to override this method or place a suitable dictionary in the handler’s typemap attribute. Returns the message ID for the record. If you are using your own messages, you could do this by having the msg passed to the logger being an ID rather than a format string. Then, in here, you could use a dictionary lookup to get the message ID. This version returns 1, which is the base message ID in .\n\nThe class, located in the module, supports sending logging messages to a queue, such as those implemented in the or modules. Along with the class, can be used to let handlers do their work on a separate thread from the one which does the logging. This is important in web applications and also other service applications where threads servicing clients need to respond as quickly as possible, while any potentially slow operations (such as sending an email via ) are done on a separate thread. Returns a new instance of the class. The instance is initialized with the queue to send messages to. The queue can be any queue-like object; it’s used as-is by the method, which needs to know how to send messages to it. The queue is not required to have the task tracking API, which means that you can use instances for queue. If you are using , you should avoid using and instead use . Enqueues the result of preparing the LogRecord. Should an exception occur (e.g. because a bounded queue has filled up), the method is called to handle the error. This can result in the record silently being dropped (if is ) or a message printed to (if is ). Prepares a record for queuing. The object returned by this method is enqueued. The base implementation formats the record to merge the message, arguments, exception and stack information, if present. It also removes unpickleable items from the record in-place. Specifically, it overwrites the record’s and attributes with the merged message (obtained by calling the handler’s method), and sets the , and attributes to . You might want to override this method if you want to convert the record to a dict or JSON string, or send a modified copy of the record while leaving the original intact. The base implementation formats the message with arguments, sets the and attributes to the formatted message and sets the and attributes to to allow pickling and to prevent further attempts at formatting. This means that a handler on the side won’t have the information to do custom formatting, e.g. of exceptions. You may wish to subclass and override this method to e.g. avoid setting to . Note that the / / changes are related to ensuring the record is pickleable, and you might or might not be able to avoid doing that depending on whether your are pickleable. (Note that you may have to consider not only your own code but also code in any libraries that you use.) Enqueues the record on the queue using ; you may want to override this if you want to use blocking behaviour, or a timeout, or a customized queue implementation. When created via configuration using , this attribute will contain a instance for use with this handler. Otherwise, it will be .\n\nThe class, located in the module, supports receiving logging messages from a queue, such as those implemented in the or modules. The messages are received from a queue in an internal thread and passed, on the same thread, to one or more handlers for processing. While is not itself a handler, it is documented here because it works hand-in-hand with . Along with the class, can be used to let handlers do their work on a separate thread from the one which does the logging. This is important in web applications and also other service applications where threads servicing clients need to respond as quickly as possible, while any potentially slow operations (such as sending an email via ) are done on a separate thread. Returns a new instance of the class. The instance is initialized with the queue to send messages to and a list of handlers which will handle entries placed on the queue. The queue can be any queue-like object; it’s passed as-is to the method, which needs to know how to get messages from it. The queue is not required to have the task tracking API (though it’s used if available), which means that you can use instances for queue. If you are using , you should avoid using and instead use . If is , a handler’s level is respected (compared with the level for the message) when deciding whether to pass messages to that handler; otherwise, the behaviour is as in previous Python versions - to always pass each message to each handler. Changed in version 3.5: The argument was added. The base implementation uses . You may want to override this method if you want to use timeouts or work with custom queue implementations. This implementation just returns the passed-in record. You may want to override this method if you need to do any custom marshalling or manipulation of the record before passing it to the handlers. This just loops through the handlers offering them the record to handle. The actual object passed to the handlers is that which is returned from . This starts up a background thread to monitor the queue for LogRecords to process. This asks the thread to terminate, and then waits for it to do so. Note that if you don’t call this before your application exits, there may be some records still left on the queue, which won’t be processed. Writes a sentinel to the queue to tell the listener to quit. This implementation uses . You may want to override this method if you want to use timeouts or work with custom queue implementations."
    },
    {
        "link": "https://stackoverflow.com/questions/50714316/how-to-use-logging-getlogger-name-in-multiple-modules",
        "document": "From the howto for Python 2.7 (my emphasis):\n\nA good convention to use when naming loggers is to use a module-level logger, in each module which uses logging, named as follows: This means that logger names track the package/module hierarchy, and it’s intuitively obvious where events are logged just from the logger name.\n\nNow, the cookbook provides an example for multiple modules, which uses hard-coded logger names instead of the constant. In the \"main module\" from the example we find\n\nand in the \"auxiliary module\" we find\n\nI copied this example verbatim into a package folder with the following structure:\n\nThis runs without issue, producing the expected logging output from both the main module and the auxiliary module, but here's the thing:\n\nIf I now replace the hard-coded logger names by the constant, as recommended by the howto, the cookbook example breaks down: I only get logging messages from the main module, but nothing from the auxiliary module.\n\nI must be missing something obvious. Any ideas what I am doing wrong?\n\nThere are a lot of very similar questions and related answers, e.g.: 1, 2, 3, 4, 5, 6, and many more. However, none of those appear to address this specific question.\n\nHere's a minimal example based on the cookbook example, with the explicit name strings replaced by ."
    },
    {
        "link": "https://reddit.com/r/learnpython/comments/1flof8q/best_practices_for_tryexcept_blocks_in_python",
        "document": "I am writing a python script to interact with an instrument. The instrument comes with a python library that I am using in my script.\n\nI am not sure what might be the best practice for using try/except blocks in Python.\n\nWhen there is an error that raises to a level of an exception, I don't want my script to just catch the exception and move on to the next step.\n\nThe step where this error could have occurred might be critical that it is not necessary to proceed with the execution of the remainder of the script.\n\nI am thinking that Approach 2 might be the best approach for my problem. But is it a good practice to do it this way?\n\nThe type of error that raises to the level of exception include: Instrument has a problem that it doesn't want to execute the command, lost communications etc."
    },
    {
        "link": "https://stackoverflow.com/questions/64622099/python-3-try-except-best-practice",
        "document": "This is a question about code structure, rather than syntax. I'd like to know what is best practice and why.\n\nImagine you've got a python programme. You've got a main class like so:\n\nThen you've got several separate .py files for managing interactions with various tables in a database. One of these .py files, looks like this:\n\nIn the example above the function is called from in the main class. contains try/except clauses to manage errors in interacting with the database. While this works fine, The try/except clauses could instead be placed in when calling . They could equally be located in both places. What is 'best practice' when using try/except? using try/except in the or using it in the where you're managing the programmes logic flow, or using it in both places? Bear in mind I'm giving the above specific example but I'm trying to extrapolate a general rule for applying try/except when writing python."
    },
    {
        "link": "https://signoz.io/guides/python-logging-best-practices",
        "document": ""
    },
    {
        "link": "https://docs.python.org/3/tutorial/errors.html",
        "document": "Until now error messages haven’t been more than mentioned, but if you have tried out the examples you have probably seen some. There are (at least) two distinguishable kinds of errors: syntax errors and exceptions.\n\nSyntax errors, also known as parsing errors, are perhaps the most common kind of complaint you get while you are still learning Python: The parser repeats the offending line and displays little arrows pointing at the place where the error was detected. Note that this is not always the place that needs to be fixed. In the example, the error is detected at the function , since a colon ( ) is missing just before it. The file name ( in our example) and line number are printed so you know where to look in case the input came from a file.\n\nEven if a statement or expression is syntactically correct, it may cause an error when an attempt is made to execute it. Errors detected during execution are called exceptions and are not unconditionally fatal: you will soon learn how to handle them in Python programs. Most exceptions are not handled by programs, however, and result in error messages as shown here: File , line , in : File , line , in : name 'spam' is not defined File , line , in : can only concatenate str (not \"int\") to str The last line of the error message indicates what happened. Exceptions come in different types, and the type is printed as part of the message: the types in the example are , and . The string printed as the exception type is the name of the built-in exception that occurred. This is true for all built-in exceptions, but need not be true for user-defined exceptions (although it is a useful convention). Standard exception names are built-in identifiers (not reserved keywords). The rest of the line provides detail based on the type of exception and what caused it. The preceding part of the error message shows the context where the exception occurred, in the form of a stack traceback. In general it contains a stack traceback listing source lines; however, it will not display lines read from standard input. Built-in Exceptions lists the built-in exceptions and their meanings.\n\nIt is possible to write programs that handle selected exceptions. Look at the following example, which asks the user for input until a valid integer has been entered, but allows the user to interrupt the program (using - or whatever the operating system supports); note that a user-generated interruption is signalled by raising the exception. \"Oops! That was no valid number. Try again...\" The statement works as follows.\n• None First, the try clause (the statement(s) between the and keywords) is executed.\n• None If no exception occurs, the except clause is skipped and execution of the statement is finished.\n• None If an exception occurs during execution of the clause, the rest of the clause is skipped. Then, if its type matches the exception named after the keyword, the except clause is executed, and then execution continues after the try/except block.\n• None If an exception occurs which does not match the exception named in the except clause, it is passed on to outer statements; if no handler is found, it is an unhandled exception and execution stops with an error message. A statement may have more than one except clause, to specify handlers for different exceptions. At most one handler will be executed. Handlers only handle exceptions that occur in the corresponding try clause, not in other handlers of the same statement. An except clause may name multiple exceptions as a parenthesized tuple, for example: A class in an clause matches exceptions which are instances of the class itself or one of its derived classes (but not the other way around — an except clause listing a derived class does not match instances of its base classes). For example, the following code will print B, C, D in that order: Note that if the except clauses were reversed (with first), it would have printed B, B, B — the first matching except clause is triggered. When an exception occurs, it may have associated values, also known as the exception’s arguments. The presence and types of the arguments depend on the exception type. The except clause may specify a variable after the exception name. The variable is bound to the exception instance which typically has an attribute that stores the arguments. For convenience, builtin exception types define to print all the arguments without explicitly accessing . # __str__ allows args to be printed directly, # but may be overridden in exception subclasses The exception’s output is printed as the last part (‘detail’) of the message for unhandled exceptions. is the common base class of all exceptions. One of its subclasses, , is the base class of all the non-fatal exceptions. Exceptions which are not subclasses of are not typically handled, because they are used to indicate that the program should terminate. They include which is raised by and which is raised when a user wishes to interrupt the program. can be used as a wildcard that catches (almost) everything. However, it is good practice to be as specific as possible with the types of exceptions that we intend to handle, and to allow any unexpected exceptions to propagate on. The most common pattern for handling is to print or log the exception and then re-raise it (allowing a caller to handle the exception as well): \"Could not convert data to an integer.\" The … statement has an optional else clause, which, when present, must follow all except clauses. It is useful for code that must be executed if the try clause does not raise an exception. For example: The use of the clause is better than adding additional code to the clause because it avoids accidentally catching an exception that wasn’t raised by the code being protected by the … statement. Exception handlers do not handle only exceptions that occur immediately in the try clause, but also those that occur inside functions that are called (even indirectly) in the try clause. For example:\n\nThe statement allows the programmer to force a specified exception to occur. For example: The sole argument to indicates the exception to be raised. This must be either an exception instance or an exception class (a class that derives from , such as or one of its subclasses). If an exception class is passed, it will be implicitly instantiated by calling its constructor with no arguments: If you need to determine whether an exception was raised but don’t intend to handle it, a simpler form of the statement allows you to re-raise the exception:\n\nIf an unhandled exception occurs inside an section, it will have the exception being handled attached to it and included in the error message: File , line , in : [Errno 2] No such file or directory: 'database.sqlite' During handling of the above exception, another exception occurred: File , line , in : To indicate that an exception is a direct consequence of another, the statement allows an optional clause: # exc must be exception instance or None. This can be useful when you are transforming exceptions. For example: File , line , in File , line , in The above exception was the direct cause of the following exception: File , line , in : It also allows disabling automatic exception chaining using the idiom: For more information about chaining mechanics, see Built-in Exceptions.\n\nThe statement has another optional clause which is intended to define clean-up actions that must be executed under all circumstances. For example: If a clause is present, the clause will execute as the last task before the statement completes. The clause runs whether or not the statement produces an exception. The following points discuss more complex cases when an exception occurs:\n• None If an exception occurs during execution of the clause, the exception may be handled by an clause. If the exception is not handled by an clause, the exception is re-raised after the clause has been executed.\n• None An exception could occur during execution of an or clause. Again, the exception is re-raised after the clause has been executed.\n• None If the clause executes a , or statement, exceptions are not re-raised.\n• None If the statement reaches a , or statement, the clause will execute just prior to the , or statement’s execution.\n• None If a clause includes a statement, the returned value will be the one from the clause’s statement, not the value from the clause’s statement. As you can see, the clause is executed in any event. The raised by dividing two strings is not handled by the clause and therefore re-raised after the clause has been executed. In real world applications, the clause is useful for releasing external resources (such as files or network connections), regardless of whether the use of the resource was successful.\n\nSome objects define standard clean-up actions to be undertaken when the object is no longer needed, regardless of whether or not the operation using the object succeeded or failed. Look at the following example, which tries to open a file and print its contents to the screen. The problem with this code is that it leaves the file open for an indeterminate amount of time after this part of the code has finished executing. This is not an issue in simple scripts, but can be a problem for larger applications. The statement allows objects like files to be used in a way that ensures they are always cleaned up promptly and correctly. After the statement is executed, the file f is always closed, even if a problem was encountered while processing the lines. Objects which, like files, provide predefined clean-up actions will indicate this in their documentation.\n\nThere are situations where it is necessary to report several exceptions that have occurred. This is often the case in concurrency frameworks, when several tasks may have failed in parallel, but there are also other use cases where it is desirable to continue execution and collect multiple errors rather than raise the first exception. The builtin wraps a list of exception instances so that they can be raised together. It is an exception itself, so it can be caught like any other exception. By using instead of , we can selectively handle only the exceptions in the group that match a certain type. In the following example, which shows a nested exception group, each clause extracts from the group exceptions of a certain type while letting all other exceptions propagate to other clauses and eventually to be reraised. Note that the exceptions nested in an exception group must be instances, not types. This is because in practice the exceptions would typically be ones that have already been raised and caught by the program, along the following pattern:\n\nWhen an exception is created in order to be raised, it is usually initialized with information that describes the error that has occurred. There are cases where it is useful to add information after the exception was caught. For this purpose, exceptions have a method that accepts a string and adds it to the exception’s notes list. The standard traceback rendering includes all notes, in the order they were added, after the exception. For example, when collecting exceptions into an exception group, we may want to add context information for the individual errors. In the following each exception in the group has a note indicating when this error has occurred. | ExceptionGroup: We have some problems (3 sub-exceptions)"
    },
    {
        "link": "https://stackoverflow.com/questions/78008188/best-practice-to-write-python-exception-in-a-log-file",
        "document": "I defined a function to print custom messages and write it in a log file. My project architecture is quite simple, with the main script calling functions from another file:\n\nI would like to catch any Python exception and print them in the log file, to help future users. For now I embedded almost all operations of main in a try/except block like this:\n\nI am used to do this for small portions of a code, but not the whole script like that. Is it the common practice? Is there a better way to write any exception to a log file?"
    }
]