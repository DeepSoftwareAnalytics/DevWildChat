[
    {
        "link": "https://docs.python.org/3/library/functions.html",
        "document": "The Python interpreter has a number of functions and types built into it that are always available. They are listed here in alphabetical order.\n\nOpen file and return a corresponding file object. If the file cannot be opened, an is raised. See Reading and Writing Files for more examples of how to use this function. file is a path-like object giving the pathname (absolute or relative to the current working directory) of the file to be opened or an integer file descriptor of the file to be wrapped. (If a file descriptor is given, it is closed when the returned I/O object is closed unless closefd is set to .) mode is an optional string that specifies the mode in which the file is opened. It defaults to which means open for reading in text mode. Other common values are for writing (truncating the file if it already exists), for exclusive creation, and for appending (which on some Unix systems, means that all writes append to the end of the file regardless of the current seek position). In text mode, if encoding is not specified the encoding used is platform-dependent: is called to get the current locale encoding. (For reading and writing raw bytes use binary mode and leave encoding unspecified.) The available modes are: open for writing, truncating the file first open for exclusive creation, failing if the file already exists open for writing, appending to the end of file if it exists The default mode is (open for reading text, a synonym of ). Modes and open and truncate the file. Modes and open the file with no truncation. As mentioned in the Overview, Python distinguishes between binary and text I/O. Files opened in binary mode (including in the mode argument) return contents as objects without any decoding. In text mode (the default, or when is included in the mode argument), the contents of the file are returned as , the bytes having been first decoded using a platform-dependent encoding or using the specified encoding if given. Python doesn’t depend on the underlying operating system’s notion of text files; all the processing is done by Python itself, and is therefore platform-independent. buffering is an optional integer used to set the buffering policy. Pass 0 to switch buffering off (only allowed in binary mode), 1 to select line buffering (only usable when writing in text mode), and an integer > 1 to indicate the size in bytes of a fixed-size chunk buffer. Note that specifying a buffer size this way applies for binary buffered I/O, but (i.e., files opened with ) would have another buffering. To disable buffering in , consider using the flag for . When no buffering argument is given, the default buffering policy works as follows:\n• None Binary files are buffered in fixed-size chunks; the size of the buffer is chosen using a heuristic trying to determine the underlying device’s “block size” and falling back on . On many systems, the buffer will typically be 4096 or 8192 bytes long.\n• None “Interactive” text files (files for which returns ) use line buffering. Other text files use the policy described above for binary files. encoding is the name of the encoding used to decode or encode the file. This should only be used in text mode. The default encoding is platform dependent (whatever returns), but any text encoding supported by Python can be used. See the module for the list of supported encodings. errors is an optional string that specifies how encoding and decoding errors are to be handled—this cannot be used in binary mode. A variety of standard error handlers are available (listed under Error Handlers), though any error handling name that has been registered with is also valid. The standard names include:\n• None to raise a exception if there is an encoding error. The default value of has the same effect.\n• None ignores errors. Note that ignoring encoding errors can lead to data loss.\n• None causes a replacement marker (such as ) to be inserted where there is malformed data.\n• None will represent any incorrect bytes as low surrogate code units ranging from U+DC80 to U+DCFF. These surrogate code units will then be turned back into the same bytes when the error handler is used when writing data. This is useful for processing files in an unknown encoding.\n• None is only supported when writing to a file. Characters not supported by the encoding are replaced with the appropriate XML character reference .\n• None (also only supported when writing) replaces unsupported characters with escape sequences. newline determines how to parse newline characters from the stream. It can be , , , , and . It works as follows:\n• None When reading input from the stream, if newline is , universal newlines mode is enabled. Lines in the input can end in , , or , and these are translated into before being returned to the caller. If it is , universal newlines mode is enabled, but line endings are returned to the caller untranslated. If it has any of the other legal values, input lines are only terminated by the given string, and the line ending is returned to the caller untranslated.\n• None When writing output to the stream, if newline is , any characters written are translated to the system default line separator, . If newline is or , no translation takes place. If newline is any of the other legal values, any characters written are translated to the given string. If closefd is and a file descriptor rather than a filename was given, the underlying file descriptor will be kept open when the file is closed. If a filename is given closefd must be (the default); otherwise, an error will be raised. A custom opener can be used by passing a callable as opener. The underlying file descriptor for the file object is then obtained by calling opener with (file, flags). opener must return an open file descriptor (passing as opener results in functionality similar to passing ). The following example uses the dir_fd parameter of the function to open a file relative to a given directory: 'This will be written to somedir/spamspam.txt' The type of file object returned by the function depends on the mode. When is used to open a file in a text mode ( , , , , etc.), it returns a subclass of (specifically ). When used to open a file in a binary mode with buffering, the returned class is a subclass of . The exact class varies: in read binary mode, it returns an ; in write binary and append binary modes, it returns an , and in read/write mode, it returns an . When buffering is disabled, the raw stream, a subclass of , , is returned. See also the file handling modules, such as , (where is declared), , , , and . The and arguments may have been modified or inferred from the original call.\n• None used to be raised, it is now an alias of .\n• None is now raised if the file opened in exclusive creation mode ( ) already exists.\n• None The file is now non-inheritable.\n• None If the system call is interrupted and the signal handler does not raise an exception, the function now retries the system call instead of raising an exception (see PEP 475 for the rationale).\n• None On Windows, opening a console buffer may return a subclass of other than . Changed in version 3.11: The mode has been removed.\n\nReturn a proxy object that delegates method calls to a parent or sibling class of type. This is useful for accessing inherited methods that have been overridden in a class. The object_or_type determines the method resolution order to be searched. The search starts from the class right after the type. For example, if of object_or_type is and the value of type is , then searches . The attribute of the class corresponding to object_or_type lists the method resolution search order used by both and . The attribute is dynamic and can change whenever the inheritance hierarchy is updated. If the second argument is omitted, the super object returned is unbound. If the second argument is an object, must be true. If the second argument is a type, must be true (this is useful for classmethods). When called directly within an ordinary method of a class, both arguments may be omitted (“zero-argument ”). In this case, type will be the enclosing class, and obj will be the first argument of the immediately enclosing function (typically ). (This means that zero-argument will not work as expected within nested functions, including generator expressions, which implicitly create nested functions.) There are two typical use cases for super. In a class hierarchy with single inheritance, super can be used to refer to parent classes without naming them explicitly, thus making the code more maintainable. This use closely parallels the use of super in other programming languages. The second use case is to support cooperative multiple inheritance in a dynamic execution environment. This use case is unique to Python and is not found in statically compiled languages or languages that only support single inheritance. This makes it possible to implement “diamond diagrams” where multiple base classes implement the same method. Good design dictates that such implementations have the same calling signature in every case (because the order of calls is determined at runtime, because that order adapts to changes in the class hierarchy, and because that order can include sibling classes that are unknown prior to runtime). For both use cases, a typical superclass call looks like this: # This does the same thing as: In addition to method lookups, also works for attribute lookups. One possible use case for this is calling descriptors in a parent or sibling class. Note that is implemented as part of the binding process for explicit dotted attribute lookups such as . It does so by implementing its own method for searching classes in a predictable order that supports cooperative multiple inheritance. Accordingly, is undefined for implicit lookups using statements or operators such as . Also note that, aside from the zero argument form, is not limited to use inside methods. The two argument form specifies the arguments exactly and makes the appropriate references. The zero argument form only works inside a class definition, as the compiler fills in the necessary details to correctly retrieve the class being defined, as well as accessing the current instance for ordinary methods. For practical suggestions on how to design cooperative classes using , see guide to using super()."
    },
    {
        "link": "https://docs.python.org/3/tutorial/errors.html",
        "document": "Until now error messages haven’t been more than mentioned, but if you have tried out the examples you have probably seen some. There are (at least) two distinguishable kinds of errors: syntax errors and exceptions.\n\nSyntax errors, also known as parsing errors, are perhaps the most common kind of complaint you get while you are still learning Python: The parser repeats the offending line and displays little arrows pointing at the place where the error was detected. Note that this is not always the place that needs to be fixed. In the example, the error is detected at the function , since a colon ( ) is missing just before it. The file name ( in our example) and line number are printed so you know where to look in case the input came from a file.\n\nEven if a statement or expression is syntactically correct, it may cause an error when an attempt is made to execute it. Errors detected during execution are called exceptions and are not unconditionally fatal: you will soon learn how to handle them in Python programs. Most exceptions are not handled by programs, however, and result in error messages as shown here: File , line , in : File , line , in : name 'spam' is not defined File , line , in : can only concatenate str (not \"int\") to str The last line of the error message indicates what happened. Exceptions come in different types, and the type is printed as part of the message: the types in the example are , and . The string printed as the exception type is the name of the built-in exception that occurred. This is true for all built-in exceptions, but need not be true for user-defined exceptions (although it is a useful convention). Standard exception names are built-in identifiers (not reserved keywords). The rest of the line provides detail based on the type of exception and what caused it. The preceding part of the error message shows the context where the exception occurred, in the form of a stack traceback. In general it contains a stack traceback listing source lines; however, it will not display lines read from standard input. Built-in Exceptions lists the built-in exceptions and their meanings.\n\nIt is possible to write programs that handle selected exceptions. Look at the following example, which asks the user for input until a valid integer has been entered, but allows the user to interrupt the program (using - or whatever the operating system supports); note that a user-generated interruption is signalled by raising the exception. \"Oops! That was no valid number. Try again...\" The statement works as follows.\n• None First, the try clause (the statement(s) between the and keywords) is executed.\n• None If no exception occurs, the except clause is skipped and execution of the statement is finished.\n• None If an exception occurs during execution of the clause, the rest of the clause is skipped. Then, if its type matches the exception named after the keyword, the except clause is executed, and then execution continues after the try/except block.\n• None If an exception occurs which does not match the exception named in the except clause, it is passed on to outer statements; if no handler is found, it is an unhandled exception and execution stops with an error message. A statement may have more than one except clause, to specify handlers for different exceptions. At most one handler will be executed. Handlers only handle exceptions that occur in the corresponding try clause, not in other handlers of the same statement. An except clause may name multiple exceptions as a parenthesized tuple, for example: A class in an clause matches exceptions which are instances of the class itself or one of its derived classes (but not the other way around — an except clause listing a derived class does not match instances of its base classes). For example, the following code will print B, C, D in that order: Note that if the except clauses were reversed (with first), it would have printed B, B, B — the first matching except clause is triggered. When an exception occurs, it may have associated values, also known as the exception’s arguments. The presence and types of the arguments depend on the exception type. The except clause may specify a variable after the exception name. The variable is bound to the exception instance which typically has an attribute that stores the arguments. For convenience, builtin exception types define to print all the arguments without explicitly accessing . # __str__ allows args to be printed directly, # but may be overridden in exception subclasses The exception’s output is printed as the last part (‘detail’) of the message for unhandled exceptions. is the common base class of all exceptions. One of its subclasses, , is the base class of all the non-fatal exceptions. Exceptions which are not subclasses of are not typically handled, because they are used to indicate that the program should terminate. They include which is raised by and which is raised when a user wishes to interrupt the program. can be used as a wildcard that catches (almost) everything. However, it is good practice to be as specific as possible with the types of exceptions that we intend to handle, and to allow any unexpected exceptions to propagate on. The most common pattern for handling is to print or log the exception and then re-raise it (allowing a caller to handle the exception as well): \"Could not convert data to an integer.\" The … statement has an optional else clause, which, when present, must follow all except clauses. It is useful for code that must be executed if the try clause does not raise an exception. For example: The use of the clause is better than adding additional code to the clause because it avoids accidentally catching an exception that wasn’t raised by the code being protected by the … statement. Exception handlers do not handle only exceptions that occur immediately in the try clause, but also those that occur inside functions that are called (even indirectly) in the try clause. For example:\n\nThe statement allows the programmer to force a specified exception to occur. For example: The sole argument to indicates the exception to be raised. This must be either an exception instance or an exception class (a class that derives from , such as or one of its subclasses). If an exception class is passed, it will be implicitly instantiated by calling its constructor with no arguments: If you need to determine whether an exception was raised but don’t intend to handle it, a simpler form of the statement allows you to re-raise the exception:\n\nIf an unhandled exception occurs inside an section, it will have the exception being handled attached to it and included in the error message: File , line , in : [Errno 2] No such file or directory: 'database.sqlite' During handling of the above exception, another exception occurred: File , line , in : To indicate that an exception is a direct consequence of another, the statement allows an optional clause: # exc must be exception instance or None. This can be useful when you are transforming exceptions. For example: File , line , in File , line , in The above exception was the direct cause of the following exception: File , line , in : It also allows disabling automatic exception chaining using the idiom: For more information about chaining mechanics, see Built-in Exceptions.\n\nThe statement has another optional clause which is intended to define clean-up actions that must be executed under all circumstances. For example: If a clause is present, the clause will execute as the last task before the statement completes. The clause runs whether or not the statement produces an exception. The following points discuss more complex cases when an exception occurs:\n• None If an exception occurs during execution of the clause, the exception may be handled by an clause. If the exception is not handled by an clause, the exception is re-raised after the clause has been executed.\n• None An exception could occur during execution of an or clause. Again, the exception is re-raised after the clause has been executed.\n• None If the clause executes a , or statement, exceptions are not re-raised.\n• None If the statement reaches a , or statement, the clause will execute just prior to the , or statement’s execution.\n• None If a clause includes a statement, the returned value will be the one from the clause’s statement, not the value from the clause’s statement. As you can see, the clause is executed in any event. The raised by dividing two strings is not handled by the clause and therefore re-raised after the clause has been executed. In real world applications, the clause is useful for releasing external resources (such as files or network connections), regardless of whether the use of the resource was successful.\n\nSome objects define standard clean-up actions to be undertaken when the object is no longer needed, regardless of whether or not the operation using the object succeeded or failed. Look at the following example, which tries to open a file and print its contents to the screen. The problem with this code is that it leaves the file open for an indeterminate amount of time after this part of the code has finished executing. This is not an issue in simple scripts, but can be a problem for larger applications. The statement allows objects like files to be used in a way that ensures they are always cleaned up promptly and correctly. After the statement is executed, the file f is always closed, even if a problem was encountered while processing the lines. Objects which, like files, provide predefined clean-up actions will indicate this in their documentation.\n\nThere are situations where it is necessary to report several exceptions that have occurred. This is often the case in concurrency frameworks, when several tasks may have failed in parallel, but there are also other use cases where it is desirable to continue execution and collect multiple errors rather than raise the first exception. The builtin wraps a list of exception instances so that they can be raised together. It is an exception itself, so it can be caught like any other exception. By using instead of , we can selectively handle only the exceptions in the group that match a certain type. In the following example, which shows a nested exception group, each clause extracts from the group exceptions of a certain type while letting all other exceptions propagate to other clauses and eventually to be reraised. Note that the exceptions nested in an exception group must be instances, not types. This is because in practice the exceptions would typically be ones that have already been raised and caught by the program, along the following pattern:\n\nWhen an exception is created in order to be raised, it is usually initialized with information that describes the error that has occurred. There are cases where it is useful to add information after the exception was caught. For this purpose, exceptions have a method that accepts a string and adds it to the exception’s notes list. The standard traceback rendering includes all notes, in the order they were added, after the exception. For example, when collecting exceptions into an exception group, we may want to add context information for the individual errors. In the following each exception in the group has a note indicating when this error has occurred. | ExceptionGroup: We have some problems (3 sub-exceptions)"
    },
    {
        "link": "https://stackoverflow.com/questions/8075877/converting-string-to-int-using-try-except-in-python",
        "document": "Firstly, / are not functions, but statements.\n\nTo convert a string (or any other type that can be converted) to an integer in Python, simply call the built-in function. will a if it fails and you should catch this specifically:"
    },
    {
        "link": "https://realpython.com/python-input-integer",
        "document": "If you’ve ever coded an interactive text-based application in Python, then you’ve probably found that you need a reliable way of asking the user for integers as input. It’s not enough simply to display a prompt and then gather keystrokes. You must check that the user’s input really represents an integer. If it doesn’t, then your code must react appropriately—typically by repeating the prompt.\n\nIn this tutorial, you’ll learn how to create a reusable utility function that’ll guarantee valid integer inputs from an interactive user. Along the way, you’ll learn about Python’s tools for getting a string from the console and converting that string into an integer.\n\nWhenever you’re writing a program that interacts with the keyboard, you must code defensively to manage invalid inputs, so you’ll also learn the most Pythonic way to deal with this situation. You’ll handle any errors robustly inside a function that’s guaranteed to return nothing but integers.\n\nHow to Get Integer Input Values in Python Python’s standard library provides a built-in tool for getting string input from the user, the function. Before you start using this function, double-check that you’re on a version of Python 3. If you’d like to learn why that’s so important, then check out the collapsible section below: Why you should beware of Python 2's functionShow/Hide Python 2’s version of the function was unsafe because the interpreter would actually execute the string returned by the function before the calling program had any opportunity to verify it. This allowed a malicious user to inject arbitrary code into the program. Because of this issue, Python 2 also provided the function as a much safer alternative, but there was always the risk that an unsuspecting programmer might choose the more obviously-named . Python 3 renamed to and removed the old, risky version of . In this tutorial, you’ll use Python 3, so this pitfall won’t be a concern. In Python 3, the function returns a , so you need to convert it to an integer. You can read the string, convert it to an integer, and print the results in three lines of code: \"The value of the integer is The value of the integer is 123 When the above snippet of code is executed, the interpreter pauses at the function and prompts the user to input an integer. A blinking cursor shows up at the end of the prompt, and the system waits for the user to type an arbitrary string of characters. When the user presses the key, the function returns a string containing the characters as typed, without a newline. As a reminder that the received value is a string, you’ve named the receiving variable . Your next line attempts to parse as an integer and store the result in . You use the class constructor to perform the conversion. Finally, the function displays the result.\n\nYou’ve probably already noticed that the above code is hopelessly optimistic. You can’t always rely on users to provide the kind of input that you expect. You can help a lot by providing an explicit prompt message, but through confusion, carelessness, or malice, there’ll always be users who provide invalid input. Your program should be ready to deal with any kind of text. The function can return arbitrary text, or even an empty string if the user pressed immediately at the prompt. How can you ensure that your program doesn’t attempt to perform arithmetic with a mess of characters when it’s expecting an ? You’re going to leverage Python’s own error-handling mechanism. By default, the integer conversion will throw a exception if it fails. Try the above code again, but this time, notice how it behaves with bad input: You’ll observe that this error occurs not in the line where the value is entered but in the one where you try to convert it using the built-in function . It’s up to you to handle this exception if it occurs. It seems a little more care is needed to ensure that your program gets good integer values. You’ll take care of that next.\n\nYou’ve seen that the Python standard library’s function allows the user to type just about anything at the prompt. You need to be sure that you can interpret what you have as an integer. You can take one of two approaches here: LBYL or EAFP, which stand for Look Before You Leap and Easier to Ask Forgiveness Than Permission, respectively. Basically, in LBYL, you aim to prevent errors from happening. EAFP focuses on handling errors after they’ve occurred. Briefly, the LBYL strategy would be to check the input carefully before attempting the conversion. EAFP, on the other hand, plunges in headlong by immediately attempting the conversion, counting on Python’s exception handling to deal with any errors. Although LBYL may seem like a more sophisticated approach, it often introduces complex error-checking logic and conditional flows into what should be a straightforward operation. Furthermore, you must perform the error checking on every input, even when it’s valid. In your use case of checking for integers, the EAFP approach results in code that’s not only simpler, but also faster. If a valid integer is supplied, then you won’t waste any time checking for nonexistent error conditions. On the other hand, if the string is invalid, then Python will throw a built-in exception. In Python, you handle exceptions in a … block. By wrapping the … block inside a loop, you can guarantee that only integers will make it through. A mechanism like this is sometimes called a retry loop. Here’s an example of how you can write this nearly bulletproof code: \"The integer you entered was You’ve nested the call to inside the call to . This does no harm, since only the function can fail. Now, if the user’s string can be parsed as a valid integer, then that value is assigned to before the interpreter returns to the top of the loop and retests the condition. Since this condition is now , the loop terminates, and execution continues at line 8 with a valid integer value. If, however, the user’s string is invalid, then a is thrown and the interpreter skips straight to the branch, where it prints the error message before looping back to the statement in line 2. In this case, is still , so the loop executes again. The result of this logic is that your code simply refuses to proceed until it’s acquired a valid integer.\n\nThe code above works well enough, but it’s not very reusable. If you copy and paste it into some other logic, then you’ll probably need to adjust the name of the variable and modify the prompts to suit the new situation. This approach risks introducing careless errors. It would be much better to wrap the code into your own robust function. Once it’s been properly tested, you can treat this function as a sort of black box—a foolproof, low-effort source of user-input integers for all your projects. Here’s how you can go about it. Since you may reuse your function in a variety of situations, it’ll provide a configurable prompt as well as an optional error message: The advantage of having a function like in your arsenal is that it takes care of common errors internally, so the code that calls it can remain simple. After you’ve defined your new function in the REPL as above, here’s how you can test it: If you find the function useful, then you can save it in a module for import. Mastering absolute and relative imports in Python is a great skill that can boost your code’s reusability. For demonstration purposes, you can simply save the function, exactly as you defined it above, in a file named . Then, to make it available to another module within the same virtual environment and the same directory, you just need the following line at the top of , for example: The function is a very simple example of reusable code. Once you’ve saved it in a module, you can call on it whenever you need a foolproof means of getting integers from the user.\n\nNow you’re ready to take user input without fear! Even if your user doesn’t type a valid integer at first, you can be confident that no garbage data will ever make its way into your program. Your function will doggedly continue to ask for input until it gets a valid integer. With that concern out of the way, you’re free to concentrate on the more fun parts of your project. In this tutorial, you’ve learned how to:\n• Use the Python standard library’s function to get string input from the user\n• Convert the string value to an integer value\n• Create a robust, reusable function that you can incorporate into many projects Code reuse is an important topic in software engineering. The best way to build reliable code is from small, reliable components. Your function is one example of this. Free Download: Click here to download the sample code that you’ll use to get integer input from users in Python.\n\nIn this tutorial, you’ve explored one particular strategy for validating user input. Now that you understand what goes into basic input validation in Python, you may be interested in some open-source projects that not only address this problem but also include some more sophisticated functionality: Here’s an example of how you could use just like your custom function: If you’d like more detail on Python input and output operations in general, then you can read Basic Input, Output, and String Formatting in Python and the official documentation. Plus, you can find more information on Python’s numeric types in the Numbers in Python tutorial. May all your integers be valid ones!"
    },
    {
        "link": "https://labex.io/questions/how-to-handle-type-conversion-errors-in-python-290726",
        "document": "Type conversion errors in Python can occur when you try to convert a value from one data type to another, and the conversion is not possible or results in an unexpected output. These errors can be challenging to handle, but Python provides several ways to manage them effectively.\n\nType conversion errors in Python can occur in various situations, such as:\n• Incompatible data types: Trying to convert a string to a number when the string cannot be interpreted as a valid number.\n• Overflow or underflow: Trying to convert a value that is outside the range of the target data type.\n• Loss of precision: Trying to convert a floating-point number to an integer, which can result in the loss of decimal places.\n\nHere's an example of a type conversion error:\n\nIn this case, the function cannot convert the string to an integer, and it will raise a exception.\n\nTo handle type conversion errors in Python, you can use the following approaches:\n• \n• Use a block to catch the specific exception that might be raised during the type conversion.\n• This allows you to handle the error gracefully and provide a fallback or alternative solution. try: x = int(\"hello\") except ValueError: print(\"Error: Cannot convert 'hello' to an integer.\")\n• \n• Before attempting a type conversion, validate the input to ensure that it is of the expected data type.\n• This can be done using built-in functions like or by checking the input against a specific pattern or range of values. user_input = input(\"Enter a number: \") if user_input.isdigit(): x = int(user_input) else: print(\"Error: Invalid input. Please enter a number.\")\n• \n• If a type conversion fails, you can provide a default value as a fallback.\n• This can be useful when you want to ensure that your program continues to run without interruption. x = 0 try: x = int(\"hello\") except ValueError: print(\"Error: Cannot convert 'hello' to an integer. Using default value 0.\")\n• \n• Python provides several built-in type conversion functions, such as , , and .\n• These functions often have additional parameters that allow you to specify the behavior when the conversion is not possible.\n\nBy using these techniques, you can effectively handle type conversion errors in your Python code and ensure that your program continues to run smoothly, even in the face of unexpected input or data types.\n\nIn the flowchart, we can see the different steps involved in handling type conversion errors in Python. When a type conversion is attempted, the process first checks if the conversion is possible. If it is, the conversion is successful. If not, a type conversion error occurs, and the program needs to handle the error using techniques like try-except blocks, input validation, default values, or type conversion functions.\n\nBy understanding and applying these techniques, you can effectively manage type conversion errors in your Python code, ensuring that your program remains robust and resilient in the face of unexpected input or data types."
    },
    {
        "link": "https://docs.python.org/3/tutorial/errors.html",
        "document": "Until now error messages haven’t been more than mentioned, but if you have tried out the examples you have probably seen some. There are (at least) two distinguishable kinds of errors: syntax errors and exceptions.\n\nSyntax errors, also known as parsing errors, are perhaps the most common kind of complaint you get while you are still learning Python: The parser repeats the offending line and displays little arrows pointing at the place where the error was detected. Note that this is not always the place that needs to be fixed. In the example, the error is detected at the function , since a colon ( ) is missing just before it. The file name ( in our example) and line number are printed so you know where to look in case the input came from a file.\n\nEven if a statement or expression is syntactically correct, it may cause an error when an attempt is made to execute it. Errors detected during execution are called exceptions and are not unconditionally fatal: you will soon learn how to handle them in Python programs. Most exceptions are not handled by programs, however, and result in error messages as shown here: File , line , in : File , line , in : name 'spam' is not defined File , line , in : can only concatenate str (not \"int\") to str The last line of the error message indicates what happened. Exceptions come in different types, and the type is printed as part of the message: the types in the example are , and . The string printed as the exception type is the name of the built-in exception that occurred. This is true for all built-in exceptions, but need not be true for user-defined exceptions (although it is a useful convention). Standard exception names are built-in identifiers (not reserved keywords). The rest of the line provides detail based on the type of exception and what caused it. The preceding part of the error message shows the context where the exception occurred, in the form of a stack traceback. In general it contains a stack traceback listing source lines; however, it will not display lines read from standard input. Built-in Exceptions lists the built-in exceptions and their meanings.\n\nIt is possible to write programs that handle selected exceptions. Look at the following example, which asks the user for input until a valid integer has been entered, but allows the user to interrupt the program (using - or whatever the operating system supports); note that a user-generated interruption is signalled by raising the exception. \"Oops! That was no valid number. Try again...\" The statement works as follows.\n• None First, the try clause (the statement(s) between the and keywords) is executed.\n• None If no exception occurs, the except clause is skipped and execution of the statement is finished.\n• None If an exception occurs during execution of the clause, the rest of the clause is skipped. Then, if its type matches the exception named after the keyword, the except clause is executed, and then execution continues after the try/except block.\n• None If an exception occurs which does not match the exception named in the except clause, it is passed on to outer statements; if no handler is found, it is an unhandled exception and execution stops with an error message. A statement may have more than one except clause, to specify handlers for different exceptions. At most one handler will be executed. Handlers only handle exceptions that occur in the corresponding try clause, not in other handlers of the same statement. An except clause may name multiple exceptions as a parenthesized tuple, for example: A class in an clause matches exceptions which are instances of the class itself or one of its derived classes (but not the other way around — an except clause listing a derived class does not match instances of its base classes). For example, the following code will print B, C, D in that order: Note that if the except clauses were reversed (with first), it would have printed B, B, B — the first matching except clause is triggered. When an exception occurs, it may have associated values, also known as the exception’s arguments. The presence and types of the arguments depend on the exception type. The except clause may specify a variable after the exception name. The variable is bound to the exception instance which typically has an attribute that stores the arguments. For convenience, builtin exception types define to print all the arguments without explicitly accessing . # __str__ allows args to be printed directly, # but may be overridden in exception subclasses The exception’s output is printed as the last part (‘detail’) of the message for unhandled exceptions. is the common base class of all exceptions. One of its subclasses, , is the base class of all the non-fatal exceptions. Exceptions which are not subclasses of are not typically handled, because they are used to indicate that the program should terminate. They include which is raised by and which is raised when a user wishes to interrupt the program. can be used as a wildcard that catches (almost) everything. However, it is good practice to be as specific as possible with the types of exceptions that we intend to handle, and to allow any unexpected exceptions to propagate on. The most common pattern for handling is to print or log the exception and then re-raise it (allowing a caller to handle the exception as well): \"Could not convert data to an integer.\" The … statement has an optional else clause, which, when present, must follow all except clauses. It is useful for code that must be executed if the try clause does not raise an exception. For example: The use of the clause is better than adding additional code to the clause because it avoids accidentally catching an exception that wasn’t raised by the code being protected by the … statement. Exception handlers do not handle only exceptions that occur immediately in the try clause, but also those that occur inside functions that are called (even indirectly) in the try clause. For example:\n\nThe statement allows the programmer to force a specified exception to occur. For example: The sole argument to indicates the exception to be raised. This must be either an exception instance or an exception class (a class that derives from , such as or one of its subclasses). If an exception class is passed, it will be implicitly instantiated by calling its constructor with no arguments: If you need to determine whether an exception was raised but don’t intend to handle it, a simpler form of the statement allows you to re-raise the exception:\n\nIf an unhandled exception occurs inside an section, it will have the exception being handled attached to it and included in the error message: File , line , in : [Errno 2] No such file or directory: 'database.sqlite' During handling of the above exception, another exception occurred: File , line , in : To indicate that an exception is a direct consequence of another, the statement allows an optional clause: # exc must be exception instance or None. This can be useful when you are transforming exceptions. For example: File , line , in File , line , in The above exception was the direct cause of the following exception: File , line , in : It also allows disabling automatic exception chaining using the idiom: For more information about chaining mechanics, see Built-in Exceptions.\n\nThe statement has another optional clause which is intended to define clean-up actions that must be executed under all circumstances. For example: If a clause is present, the clause will execute as the last task before the statement completes. The clause runs whether or not the statement produces an exception. The following points discuss more complex cases when an exception occurs:\n• None If an exception occurs during execution of the clause, the exception may be handled by an clause. If the exception is not handled by an clause, the exception is re-raised after the clause has been executed.\n• None An exception could occur during execution of an or clause. Again, the exception is re-raised after the clause has been executed.\n• None If the clause executes a , or statement, exceptions are not re-raised.\n• None If the statement reaches a , or statement, the clause will execute just prior to the , or statement’s execution.\n• None If a clause includes a statement, the returned value will be the one from the clause’s statement, not the value from the clause’s statement. As you can see, the clause is executed in any event. The raised by dividing two strings is not handled by the clause and therefore re-raised after the clause has been executed. In real world applications, the clause is useful for releasing external resources (such as files or network connections), regardless of whether the use of the resource was successful.\n\nSome objects define standard clean-up actions to be undertaken when the object is no longer needed, regardless of whether or not the operation using the object succeeded or failed. Look at the following example, which tries to open a file and print its contents to the screen. The problem with this code is that it leaves the file open for an indeterminate amount of time after this part of the code has finished executing. This is not an issue in simple scripts, but can be a problem for larger applications. The statement allows objects like files to be used in a way that ensures they are always cleaned up promptly and correctly. After the statement is executed, the file f is always closed, even if a problem was encountered while processing the lines. Objects which, like files, provide predefined clean-up actions will indicate this in their documentation.\n\nThere are situations where it is necessary to report several exceptions that have occurred. This is often the case in concurrency frameworks, when several tasks may have failed in parallel, but there are also other use cases where it is desirable to continue execution and collect multiple errors rather than raise the first exception. The builtin wraps a list of exception instances so that they can be raised together. It is an exception itself, so it can be caught like any other exception. By using instead of , we can selectively handle only the exceptions in the group that match a certain type. In the following example, which shows a nested exception group, each clause extracts from the group exceptions of a certain type while letting all other exceptions propagate to other clauses and eventually to be reraised. Note that the exceptions nested in an exception group must be instances, not types. This is because in practice the exceptions would typically be ones that have already been raised and caught by the program, along the following pattern:\n\nWhen an exception is created in order to be raised, it is usually initialized with information that describes the error that has occurred. There are cases where it is useful to add information after the exception was caught. For this purpose, exceptions have a method that accepts a string and adds it to the exception’s notes list. The standard traceback rendering includes all notes, in the order they were added, after the exception. For example, when collecting exceptions into an exception group, we may want to add context information for the individual errors. In the following each exception in the group has a note indicating when this error has occurred. | ExceptionGroup: We have some problems (3 sub-exceptions)"
    },
    {
        "link": "https://digitalocean.com/community/tutorials/python-valueerror-exception-handling-examples",
        "document": "Python ValueError is raised when a function receives an argument of the correct type but an inappropriate value. Also, the situation should not be described by a more precise exception such as IndexError.\n\nYou will get ValueError with mathematical operations, such as square root of a negative number.\n\nHere is a simple example to handle ValueError exception using try-except block.\n\nHere is the output of the program with different types of input.\n\nOur program can raise ValueError in int() and math.sqrt() functions. So, we can create a nested try-except block to handle both of them. Here is the updated snippet to take care of all the ValueError scenarios.\n\nHere is a simple example where we are raising ValueError for input argument of correct type but inappropriate value."
    },
    {
        "link": "https://stackoverflow.com/questions/68553427/valueerror-in-python-exception-how-to-handle-while-user-input-is-nested-in-argu",
        "document": "If you want to catch the exception, you need to add a - block:\n\nIf you want to prompt for input continuously until the user enters something acceptable, you need to wrap this in a loop:"
    },
    {
        "link": "https://qodo.ai/blog/6-best-practices-for-python-exception-handling",
        "document": "Exception handling in Python is often treated as an afterthought, tacked on at the end of development when things start breaking in production. Yet proper error handling is what separates robust applications from fragile ones that crumble at the first sign of unexpected input.\n\nWhile it’s tempting to wrap everything in a generic try-except block and call it a day, thoughtful error handling can mean the difference between graceful degradation and catastrophic failure. Let’s dive into six practical techniques that will elevate your exception handling from basic error-catching to professional-grade defensive programming.\n\n1. Keep your try blocks laser-focused\n\nWhen handling exceptions in Python, the scope of your try blocks directly impacts how effectively you can diagnose and fix issues. Large, encompassing try blocks often mask the true source of errors and make debugging significantly more challenging.\n\nThis code has several issues:\n• It’s impossible to determine which operation actually failed\n• All errors receive the same generic handling\n• Recovery options are limited since different errors are treated identically\n\nHere’s how we can improve it:\n\nNow, as you can notice:\n• Each operation has its own error boundary\n• Different types of failures can be handled appropriately\n• Debugging becomes straightforward as the error source is immediately apparent\n\nThe extra code is a worthwhile trade-off for the clarity and control it provides. While it might seem verbose, this pattern becomes invaluable as applications grow in complexity and when we’re debugging production issues.\n\nPython’s exception hierarchy is extensive and well-designed, yet many developers fall into the trap of using overly broad exception handling. In the hierarchy, built-in exceptions are organized logically — from broad base classes to specific error types. Each exception type serves a distinct purpose that you can use to identify and handle specific failure scenarios appropriately.\n\nFor instance, when working with dictionaries, catch `KeyError` rather than `Exception`. When parsing strings to integers, catch `ValueError`instead of using a broad try-except block:\n\nThe hierarchy also lets you catch multiple related exceptions elegantly:\n\nThe key points here are:\n• You should never use bare except clauses.\n• Always avoid catching `Exception` unless you’re re-raising it.\n\nContext managers in Python shine when it comes to resource management, but many developers miss out on their potential. While they’re commonly associated with file operations, their scope extends far beyond basic file handling.\n\nThe real power of context managers lies in their ability to handle setup and cleanup operations automatically, whether your code executes successfully or raises an exception. This becomes particularly crucial when dealing with:\n\nThis pattern ensures proper resource cleanup even when errors occur. You can then use it elegantly in your code:\n\nContext managers particularly excel in production environments where resource leaks can cause significant issues. They enforce clean resource management patterns and make code more maintainable by centralizing setup and cleanup logic.\n\nThe idea is to identify operations that require paired setup and cleanup actions. Not every operation needs a context manager — reserve them for scenarios involving resource management or operations that need guaranteed cleanup.\n\nPython 3.11 introduced Exception Groups, a powerful feature that shines when handling multiple exceptions occurring simultaneously, especially in concurrent operations. Traditional exception handling falls short when dealing with parallel tasks that might fail independently.\n\nException Groups provide several advantages. Now you can:\n• Handle multiple errors without losing contextMaintain clean error hierarchies in concurrent codeEnable precise error handling based on exception types.\n\nThe add_note() method, introduced in Python 3.11, lets you attach contextual breadcrumbs to exceptions as they bubble up through your application stack. This creates a richer debugging narrative without muddying the original error.\n• Preserves error integrity: The original exception remains intact, maintaining the precise error type and traceback.\n• Performance-conscious: Adding notes incurs minimal overhead, as they’re only formatted when the exception is printed.\n\nWhen exceptions hit the fan in production, proper logging becomes your best friend. While many developers can be found slapping a print statement or a basic `logger.error()`, a thoughtful logging strategy can save countless debugging hours.\n\nHere’s what they all miss — logging isn’t just about catching errors. Strategic logging helps track user behavior patterns, performance bottlenecks, and system health. When an exception occurs, your logs should tell a story about what led to the failure.\n\nTry this setup, for instance:\n\nThe secret sauce to exceptional logging lies in these key ingredients:\n• Log levels that actually mean something (`INFO` isn’t just `DEBUG`’s cousin)\n• Stack traces for exceptions (but only when they matter)\n\nThe key is finding the right balance between comprehensive error handling and code readability. Qodo can significantly enhance this process — its AI analyzes your code patterns and identifies potential edge cases where exceptions might occur. By integrating directly with your IDE, Qodo can suggest appropriate exception-handling patterns and even generate test cases that validate your error-handling logic. This means you can catch potential issues before they reach production, ensuring your exception handling is both comprehensive and properly tested.\n\nAll in all, keep your error handling focused, your logging informative, and your exceptions meaningful. With modern tools and best practices working together, you can build more resilient applications that gracefully handle whatever comes their way."
    },
    {
        "link": "https://stackoverflow.com/questions/67045725/python-exception-user-input",
        "document": "Whenever you use a try/except statement you are trying to catch something happening in the code the shouldn't have happened. In your example, you are haveing the user enter a number for a duration:\n\nAt this point, duration might equal something like '2'. If you wanted to add 10 to it then you could not because it is a string(you cannot and int+str). In order to do something like this, you would have to convert the user input to an int. For example:\n\nThe problem is that if the user enters a letter A, then the program will break when it tries to convert it to an int. Using a try/except statement will catch this behavior and handle it properly. For example:"
    }
]