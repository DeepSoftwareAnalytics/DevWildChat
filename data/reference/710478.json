[
    {
        "link": "https://developer.android.com/training/monitoring-device-state/battery-monitoring",
        "document": "When you're altering the frequency of your background updates to reduce the effect of those updates on battery life, checking the current battery level and charging state is a good place to start.\n\nThe battery-life impact of performing application updates depends on the battery level and charging state of the device. The impact of performing updates while the device is charging over AC is negligible, so in most cases you can maximize your refresh rate whenever the device is connected to a wall charger. Conversely, if the device is discharging, reducing your update rate helps prolong the battery life.\n\nSimilarly, you can check the battery charge level, potentially reducing the frequency of—or even stopping—your updates when the battery charge is nearly exhausted.\n\nStart by determining the current charge status. The broadcasts all battery and charging details in a sticky that includes the charging status.\n\nBecause it's a sticky intent, you don't need to register a —by simply calling passing in as the receiver as shown in the next snippet, the current battery status intent is returned. You could pass in an actual object here, but we'll be handling updates in a later section so it's not necessary.\n\nYou can extract both the current charging status and, if the device is being charged, whether it's charging via USB or AC charger:\n\nTypically you should maximize the rate of your background updates in the case where the device is connected to an AC charger, reduce the rate if the charge is over USB, and lower it further if the battery is discharging.\n\nThe charging status can change as easily as a device can be plugged in, so it's important to monitor the charging state for changes and alter your refresh rate accordingly.\n\nThe broadcasts an action whenever the device is connected or disconnected from power. It's important to receive these events even while your app isn't running—particularly as these events should impact how often you start your app in order to initiate a background update—so you should register a in your manifest to listen for both events by defining the and within an intent filter.\n\nIn some cases it's also useful to determine the current battery level. You may choose to reduce the rate of your background updates if the battery charge is below a certain level.\n\nYou can find the current battery charge by extracting the current battery level and scale from the battery status intent as shown here:\n\nReact to significant changes in battery level\n\nYou can't easily continually monitor the battery state, but you don't need to.\n\nGenerally speaking, the impact of monitoring the battery level has a greater impact on the battery than your app's normal behavior. For example, registering a in the manifest to cancel pending work when the battery is low will mainly serve to drain the battery further (and is therefore impossible since Android 8.0). Instead, you can provide constraints on work that describe when it should be run, allowing the system to make the decision without spending power starting your app.\n\nIt is generally good practice to not run your background updates when the battery is critically low. It doesn't matter how fresh your data is if the phone turns itself off before you can make use of it. To do this, use the WorkManager library with a constraint to specify that the work should not be run if the battery is low (in addition to any relevant constraints).\n\nIn many cases, the act of charging a device is coincident with putting it into a dock. To learn more, see Determine and monitor the docking state and type."
    },
    {
        "link": "https://stackoverflow.com/questions/14405726/get-battery-level-with-broadcastreceiver-in-android-service",
        "document": "I have a code, that I need get the Battery Level of my Android device, but I have a big problem. I have an Android Service where I go get battery level and send by UDP.\n\nThis is my Service code:\n\nMy problem is: I cannot get the level! I put a BreakPoint into onReceive method in BatInfoReceiver, but this code only is executed after the execute onStartCommand, and e NEED use the value of battery level into onStartCommand.\n\nHow can I do it?"
    },
    {
        "link": "https://stackoverflow.com/questions/3661464/get-battery-level-before-broadcast-receiver-responds-for-intent-action-battery-c",
        "document": "I have a broadcast receiver in my program to get react to the battery level like so:\n\nHowever this code has to wait for the battery status to be updated so if you have a GUI element that needs to be set based on the battery level it must wait for a battery event to occur. Is there a way to nudge this to get it working or simply run some code to see what the battery level was on the last broadcast?"
    },
    {
        "link": "https://developer.android.com/develop/background-work/background-tasks/broadcasts",
        "document": "Android apps send and receive broadcast messages from the Android system and other Android apps, similar to the publish-subscribe design pattern. The system and apps typically send broadcasts when certain events occur. For example, the Android system sends broadcasts when various system events occur, such as system boot or device charging. Apps also send custom broadcasts, for example, to notify other apps of something that might interest them (for example, new data download).\n\nApps can register to receive specific broadcasts. When a broadcast is sent, the system automatically routes broadcasts to apps that have subscribed to receive that particular type of broadcast.\n\nGenerally speaking, broadcasts can be used as a messaging system across apps and outside of the normal user flow. However, you must be careful not to abuse the opportunity to respond to broadcasts and run jobs in the background that can contribute to a slow system performance.\n\nThe system automatically sends broadcasts when various system events occur, such as when the system switches in and out of Airplane Mode. All subscribed apps receive these broadcasts.\n\nThe object wraps the broadcast message. The string identifies the event that occurred, such as . The intent might also include additional information bundled into its extra field. For example, the Airplane Mode intent includes a boolean extra that indicates whether or not Airplane Mode is on.\n\nFor more information about how to read intents and get the action string from an intent, see Intents and Intent Filters.\n\nFor a complete list of system broadcast actions, see the file in the Android SDK. Each broadcast action has a constant field associated with it. For example, the value of the constant is . Documentation for each broadcast action is available in its associated constant field.\n\nAs the Android platform evolves, it periodically changes how system broadcasts behave. Keep the following changes in mind to support all versions of Android.\n\nWhile apps are in a cached state, the system optimizes broadcast delivery for system health. For example, the system defers less important system broadcasts such as while the app is in a cached state. Once the app goes from the cached state into an active process lifecycle, the system delivers any deferred broadcasts.\n\nImportant broadcasts that are declared in the manifest temporarily remove apps from the cached state for delivery.\n\nBeginning with Android 9 (API level 28), The broadcast doesn't receive information about the user's location or personally identifiable data.\n\nIf your app is installed on a device running Android 9.0 (API level 28) or higher, the system doesn't include SSIDs, BSSIDs, connection information, or scan results in Wi-Fi broadcasts. To get this information, call instead.\n\nBeginning with Android 8.0 (API level 26), the system imposes additional restrictions on manifest-declared receivers.\n\nIf your app targets Android 8.0 or higher, you cannot use the manifest to declare a receiver for most implicit broadcasts (broadcasts that don't target your app specifically). You can still use a context-registered receiver when the user is actively using your app.\n\nAndroid 7.0 (API level 24) and higher don't send the following system broadcasts:\n\nAlso, apps targeting Android 7.0 and higher must register the broadcast using . Declaring a receiver in the manifest doesn't work.\n\nApps can receive broadcasts in two ways: through context-registered receivers and manifest-declared receivers.\n\nContext-registered receivers receive broadcasts as long as their registering context is valid. This is typically between the calls to and . The registering context also becomes invalid when the system destroys the corresponding context. For example, if you register within an context, you receive broadcasts as long as the activity remains active. If you register with the Application context, you receive broadcasts as long as the app runs.\n\nTo register a receiver with a context, perform the following steps:\n• None In your app's module-level build file, include version 1.9.0 or higher of the AndroidX Core library: // To use the Animator APIs // Optional - To enable APIs that query the performance characteristics of GMS devices. // Optional - to use ShortcutManagerCompat to donate shortcuts to be used by Google // To use the Animator APIs // Optional - To enable APIs that query the performance characteristics of GMS devices. // Optional - to use ShortcutManagerCompat to donate shortcuts to be used by Google\n• None Choose whether the broadcast receiver should be exported and visible to other apps on the device. If this receiver is listening for broadcasts sent from the system or from other apps—even other apps that you own—use the flag. If instead this receiver is listening only for broadcasts sent by your app, use the flag. Some system broadcasts come from highly privileged apps, such as Bluetooth and telephony, that are part of the Android framework but don't run under the system's unique process ID (UID). To receive all system broadcasts, including broadcasts from highly privileged apps, flag your receiver with . If you flag your receiver with , the receiver is able to receive some system broadcasts and broadcasts from your app, but not broadcasts from the highly privileged apps. If your app is listening for multiple broadcasts, but only some should be flagged and some , partition the broadcasts among different broadcast receivers. Caution: If you export the broadcast receiver, other apps could send unprotected broadcasts to your app.\n• None To stop receiving broadcasts, call . Be sure to unregister the receiver when you no longer need it or the context is no longer valid.\n\nWhile the broadcast receiver is registered, it holds a reference to the Context that you registered it with. This can potentially cause leaks if the receiver's registered scope exceeds the Context lifecycle scope. For example, this can occur when you register a receiver on an Activity scope, but you forget to unregister it when the system destroys the Activity. Therefore, always unregister your broadcast receiver.\n\nYour broadcast receiver should only be registered when you're actually interested in the result. Choose the smallest possible receiver scope:\n• or activity / lifecycle methods: The broadcast receiver only receives updates while the app is in its resumed state.\n• or activity / lifecycle methods: The broadcast receiver only receives updates while the app is in its resumed state.\n• : The broadcast receiver only receives updates while the composable is in the composition tree. This scope is not attached to the activity lifecycle scope. Consider registering the receiver on the application context. This is because the composable could theoretically outlive the activity lifecycle scope and leak the activity.\n• Activity / : The broadcast receiver receives updates while the activity is in its created state. Make sure to unregister in and not because this might not be called.\n• A custom scope: For example, you can register a receiver in your scope, so it survives activity recreation. Make sure to use the application context to register the receiver on, as the receiver can outlive the activity lifecycle scope and leak the activity.\n\nCompose has stateful and stateless composables. Registering or unregistering a broadcast receiver inside a composable makes it stateful. The composable is not a deterministic function that renders the same content when passed the same parameters. Internal state can change based on calls to the registered broadcast receiver.\n\nAs a best practice in Compose, we recommend that you split your composables into stateful and stateless versions. Therefore, we recommend that you hoist the creation of the broadcast receiver out of a Composable to make it stateless:\n\nIf you declare a broadcast receiver in your manifest, the system launches your app when the broadcast is sent. If the app is not already running, the system launches the app.\n\nTo declare a broadcast receiver in the manifest, perform the following steps:\n• None Specify the element in your app's manifest. <!-- If this receiver listens for broadcasts sent from the system or from other apps, even other apps that you own, set android:exported to \"true\". --> <receiver android:name=\".MyBroadcastReceiver\" android:exported=\"false\"> <intent-filter> <action android:name=\"com.example.snippets.ACTION_UPDATE_DATA\" /> </intent-filter> </receiver> The intent filters specify the broadcast actions your receiver subscribes to.\n• None Subclass and implement . The broadcast receiver in the following example logs and displays the contents of the broadcast: // Do something with the data, for example send it to a data repository: // Do something with the data, for example send it to a data repository:\n\nThe system package manager registers the receiver when the app is installed. The receiver then becomes a separate entry point into your app which means that the system can start the app and deliver the broadcast if the app is not running.\n\nThe system creates a new component object to handle each broadcast that it receives. This object is valid only for the duration of the call to . Once your code returns from this method, the system considers the component no longer active.\n\nWhether your is operating or not affects its contained process, which can alter its system-killing likelihood. A foreground process executes a receiver's method. The system runs the process except under extreme memory pressure.\n\nThe system deactivates the after . The receiver's host process's significance depends on its app components. If that process hosts only a manifest-declared receiver, the system might kill it after to free resources for other more critical processes. This is common for apps the user has never or not recently interacted with.\n\nThus, broadcast receivers shouldn't initiate long-running background threads. The system can stop the process at any moment after to reclaim memory, terminating the created thread. To keep the process alive, schedule a from the receiver using the so the system knows the process is still working. Background Work Overview provides more details.\n\nAndroid provides two ways for apps to send broadcasts:\n• The method sends broadcasts to one receiver at a time. As each receiver executes in turn, it can propagate a result to the next receiver. It can also completely abort the broadcast so that it doesn't reach other receivers. You can control the order in which receivers run. To do so, use the android:priority attribute of the matching intent-filter. Receivers with the same priority are run in an arbitrary order.\n• The method sends broadcasts to all receivers in an undefined order. This is called a Normal Broadcast. This is more efficient, but means that receivers cannot read results from other receivers, propagate data received from the broadcast, or abort the broadcast.\n\nThe following code snippet demonstrates how to send a broadcast by creating an Intent and calling .\n\nThe broadcast message is wrapped in an object. The intent's string must provide the app's Java package name syntax and uniquely identify the broadcast event. You can attach additional information to the intent with . You can also limit a broadcast to a set of apps in the same organization by calling on the intent.\n\nPermissions allow you to restrict broadcasts to the set of apps that hold certain permissions. You can enforce restrictions on either the sender or receiver of a broadcast.\n\nWhen you call or , you can specify a permission parameter. Only receivers who have requested that permission with the tag in their manifest can receive the broadcast. If the permission is dangerous, you must grant the permission before the receiver can receive the broadcast. For example, the following code sends a broadcast with a permission:\n\nTo receive the broadcast, the receiving app must request the permission as follows:\n\nYou can specify either an existing system permission like or define a custom permission with the element. For information on permissions and security in general, see the System Permissions.\n\nIf you specify a permission parameter when registering a broadcast receiver (either with or in tag in your manifest), then only broadcasters who have requested the permission with the tag in their manifest can send an Intent to the receiver. If the permission is dangerous, the broadcaster must also be granted the permission.\n\nFor example, assume your receiving app has a manifest-declared receiver as follows:\n\nOr your receiving app has a context-registered receiver as follows:\n\nThen, to be able to send broadcasts to those receivers, the sending app must request the permission as follows:\n\nHere are some security considerations for sending and receiving broadcasts:\n• None If many apps have registered to receive the same broadcast in their manifest, it can cause the system to launch a lot of apps, causing a substantial impact on both device performance and user experience. To avoid this, prefer using context registration over manifest declaration. Sometimes, the Android system itself enforces the use of context-registered receivers. For example, the broadcast is delivered only to context-registered receivers.\n• None Don't broadcast sensitive information using an implicit intent. Any app can read the information if it registers to receive the broadcast. There are three ways to control who can receive your broadcasts:\n• You can specify a permission when sending a broadcast.\n• In Android 4.0 (API level 14) and higher, you can specify a package with when sending a broadcast. The system restricts the broadcast to the set of apps that match the package.\n• None When you register a receiver, any app can send potentially malicious broadcasts to your app's receiver. There are several ways to limit the broadcasts that your app receives:\n• You can specify a permission when registering a broadcast receiver.\n• For manifest-declared receivers, you can set the android:exported attribute to \"false\" in the manifest. The receiver does not receive broadcasts from sources outside of the app.\n• None The namespace for broadcast actions is global. Make sure that action names and other strings are written in a namespace you own. Otherwise, you may inadvertently conflict with other apps.\n• None Because a receiver's method runs on the main thread, it should execute and return quickly. If you need to perform long-running work, be careful about spawning threads or starting background services because the system can kill the entire process after returns. For more information, see Effect on process state To perform long running work, we recommend:\n• Calling in your receiver's method and passing the to a background thread. This keeps the broadcast active after returning from . However, even with this approach the system expects you to finish with the broadcast very quickly (under 10 seconds). It does allow you to move work to another thread to avoid glitching the main thread.\n• Scheduling a job with the . For more information, see Intelligent Job Scheduling.\n• None Don't start activities from broadcast receivers because the user experience is jarring; especially if there is more than one receiver. Instead, consider displaying a notification."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/android-broadcastreceiver-example-tutorial",
        "document": "Today we’ll discuss and implement Android BroadcastReceiver that is a very important component of Android Framework.\n\nAndroid BroadcastReceiver is a dormant component of android that listens to system-wide broadcast events or intents. When any of these events occur it brings the application into action by either creating a status bar notification or performing a task. Unlike activities, android doesn’t contain any user interface. Broadcast receiver is generally implemented to delegate the tasks to services depending on the type of intent data that’s received. Following are some of the important system wide generated intents.\n• android.intent.action.BATTERY_LOW : Indicates low battery condition on the device.\n• android.intent.action.BOOT_COMPLETED : This is broadcast once, after the system has finished booting\n• android.intent.action.CALL : To perform a call to someone specified by the data\n• android.net.conn.CONNECTIVITY_CHANGE : The mobile network or wifi connection is changed(or reset)\n\nTo set up a Broadcast Receiver in android application we need to do the following two things.\n\nBroadcastReceiver is an abstract class with the method being abstract. The method is first called on the registered Broadcast Receivers when any event occurs. The intent object is passed with all the additional data. A Context object is also available and is used to start an activity or service using or respectively.\n\nA BroadcastReceiver can be registered in two ways.\n• By defining it in the file as shown below.\n\nUsing intent filters we tell the system any intent that matches our subelements should get delivered to that specific broadcast receiver.3. By defining it programmatically Following snippet shows a sample example to register broadcast receiver programmatically.\n\nTo unregister a broadcast receiver in or of the activity the following snippet can be used.\n\nThe following snippet is used to send an intent to all the related BroadcastReceivers.\n\nDon’t forget to add the above action in the intent filter tag of the manifest or programmatically. Let’s develop an application that listens to network change events and also to a custom intent and handles the data accordingly.\n\nThe consists of a button at the centre that sends a broadcast intent.\n\nThe is given below.\n\nIn the above code we’ve registered another custom action programmatically. The ConnectionReceiver is defined in the file as below.\n\nThe ConnectionReceiver.java class is defined below.\n\nIn the above code we check the intent action that triggers the method and based on that display the toast. Note: To make the broadcast receiver unavailable to external applications, add the attribute in the manifest. When we send a broadcast, it is possible for the external applications too to receive them. This can be prevented by specifying this limitation. The output app in action is given below. This brings an end android BroadcastReceiver tutorial. You can download the final BroadcastReceivers project from the link below."
    },
    {
        "link": "https://developer.android.com/develop/ui/views/notifications/channels",
        "document": "Stay organized with collections Save and categorize content based on your preferences.\n\nStarting in Android 8.0 (API level 26), all notifications must be assigned to a channel. For each channel, you can set the visual and auditory behavior that is applied to all notifications in that channel. Users can change these settings and decide which notification channels from your app can be intrusive or visible.\n\nCheck out the following video for an overview of channels and other notification features in Android 8.0.\n\nThe user settings for notification channels are available for each app in the system settings, as shown in figure 1.\n\nFigure 1. Notification settings for the Clock app and one of its channels.\n\nAfter you create a notification channel, you can't change the notification behaviors. The user has complete control at that point. However, you can still change a channel's name and description.\n\nCreate a channel for each type of notification you need to send. You can also create notification channels to reflect choices made by users. For example, you can set up separate notification channels for each conversation group created by a user in a messaging app.\n\nWhen you target Android 8.0 (API level 26) or higher, you must implement one or more notification channels. If your is set to 25 or lower, when your app runs on Android 8.0 (API level 26) or higher, it behaves the same as on devices running Android 7.1 (API level 25) or lower.\n• None Construct a object with a unique channel ID, user-visible name, and importance level.\n• None Optionally, specify the description that the user sees in the system settings with .\n• None Register the notification channel by passing it to .\n\nThe following example shows how to create and register a notification channel:\n\nRecreating an existing notification channel with its original values performs no operation, so it's safe to call this code when starting an app.\n\nBy default, all notifications posted to a given channel use the visual and auditory behaviors defined by the importance level from the class, such as or . See the next section for more information about importance levels.\n\nIf you want to further customize your channel's default notification behaviors, you can call methods such as , , and on the . Remember that once you create the channel, you can't change these settings, and the user has final control over whether these behaviors are active.\n\nYou can also create multiple notification channels in a single operation by calling .\n\nChannel importance affects the interruption level of all notifications posted in the channel. Specify it in the constructor, using one of five importance levels, ranging from to .\n\nTo support devices running Android 7.1 (API level 25) or lower, you must also call for each notification, using a priority constant from the class.\n\nThe importance ( ) and priority ( ) constants map to the user-visible importance options, as shown in the following table.\n\nAll notifications, regardless of importance, appear in non-interruptive system UI locations, such as in the notification drawer and as a badge on the launcher icon, though you can modify the appearance of the notification badge.\n\nOnce you submit the channel to the , you can't change the importance level. However, the user can change their preferences for your app's channels at any time.\n\nFor information about choosing an appropriate priority level, see \"Priority levels\" in the Notifications design guide.\n\nUsers can modify the settings for notification channels, including behaviors such as vibration and alert sound. If you want to know the settings a user applies to your notification channels, follow these steps:\n• None Get the object by calling or .\n• None Query specific channel settings such as , , and .\n\nIf you detect a channel setting that you believe inhibits the intended behavior for your app, you can suggest that the user change it and provide an action to open the channel settings, as shown in the next section.\n\nAfter you create a notification channel, you can't change the notification channel's visual and auditory behaviors programmatically. Only the user can change the channel behaviors from the system settings. To provide your users easy access to these notification settings, add an item in your app's settings UI that opens these system settings.\n\nYou can open the system settings for notification channels with an that uses the action.\n\nFor example, the following sample code shows how you can redirect a user to the settings for a notification channel:\n\nNotice that the intent requires two extras that specify your app's package name (also known as the application ID) and the channel to edit.\n\nYou can delete notification channels by calling . The following sample code demonstrates how to complete this process:\n\nIf want to further organize the appearance of your channels in the settings UI, you can create channel groups. This is a good idea when your app supports multiple user accounts, such as for work profiles, because it lets you create a notification channel group for each account. This way, users can easily identify and control multiple notification channels that have identical names.\n\nFigure 2. Notification channel settings with groups for personal and work accounts.\n\nFor example, a social networking app might include support for personal and work accounts. In this scenario, each account might require multiple notification channels with identical functions and names, such as the following:\n\nOrganizing the notification channels into groups for each account lets users distinguish between them.\n\nEach notification channel group requires an ID, which must be unique within your package, as well as a user-visible name. The following snippet demonstrates how to create a notification channel group.\n\nAfter you create a new group, you can call to associate a new object with the group.\n\nOnce you submit the channel to the notification manager, you can't change the association between notification channel and group."
    },
    {
        "link": "https://stackoverflow.com/questions/62882095/how-can-i-create-a-notification-channel-for-android-api-level-26-before-andro",
        "document": "I am currently working with an Android service: https://developer.android.com/guide/components/services\n\nI am creating a service that has to be a foreground service. But looking at the documentation, a foreground service requires a notification channel.\n\nBut a notification channel is only on api 26 or higher. How can i create a notification channel for < 26?\n\nI am stuck with this code"
    },
    {
        "link": "https://developer.android.com/develop/ui/views/notifications",
        "document": "Stay organized with collections Save and categorize content based on your preferences.\n\nA notification is a message that Android displays outside your app's UI to provide the user with reminders, communication from other people, or other timely information from your app. Users can tap the notification to open your app or take an action directly from the notification.\n\nThis page provides an overview of where notifications appear and the available features. To start building notifications, read Create a notification.\n\nFor more information about notification design and interaction patterns, see the Notifications design guide.\n\nNotifications automatically appear to users in different locations and formats. A notification appears as an icon in the status bar, a more detailed entry in the notification drawer, and a badge on the app's icon. Notifications also appear on paired wearables.\n\nWhen you issue a notification, it first appears as an icon in the status bar.\n\nFigure 1. Notification icons appear on the left side of the status bar.\n\nUsers can swipe down on the status bar to open the notification drawer, where they can view more details and take actions with the notification.\n\nUsers can drag down on a notification in the drawer to reveal the expanded view, which shows additional content and action buttons, if provided. Starting in Android 13, this expanded view includes a button that lets users stop an app that has ongoing foreground services.\n\nA notification remains visible in the notification drawer until it's dismissed by the app or user.\n\nBeginning with Android 5.0, notifications can briefly appear in a floating window called a heads-up notification. This behavior is normally for important notifications that the user needs to know about immediately, and it only appears if the device is unlocked.\n\nFigure 3. A heads-up notification appears in front of the foreground app.\n\nThe heads-up notification appears when your app issues the notification. It disappears after a moment, but it remains visible in the notification drawer as usual.\n\nConditions that might trigger heads-up notifications include the following:\n• None The user's activity is in fullscreen mode, such as when the app uses .\n• None The notification has high priority and uses ringtones or vibrations on devices running Android 7.1 (API level 25) and lower.\n• None The notification channel has high importance on devices running Android 8.0 (API level 26) and higher.\n\nBeginning with Android 5.0, notifications can appear on the lock screen.\n\nYou can programmatically set whether notifications posted by your app show on a secure lock screen and, if so, the level of detail visible.\n\nUsers can use the system settings to choose the level of detail visible in lock screen notifications or to disable all lock screen notifications. Starting with Android 8.0, users can disable or enable lock screen notifications for each notification channel.\n\nFigure 4. Notifications on the lock screen with sensitive content hidden.\n\nTo learn more, see Set lock screen visibility.\n\nIn supported launchers on devices running Android 8.0 (API level 26) and higher, app icons indicate new notifications with a colored badge known as a notification dot on the corresponding app launcher icon.\n\nUsers can touch & hold an app icon to see the notifications for that app. Users can dismiss or act on notifications from that menu, similar to the notification drawer.\n\nTo learn more about how badges work, read Modify a notification badge.\n\nIf the user has a paired Wear OS device, all your notifications appear there automatically, including expandable detail and action buttons.\n\nYou can enhance the experience by customizing the appearance of your notifications on wearables and by providing different actions, including suggested replies and voice input replies. For more information, see how to add wearable-specific features to your notification.\n\nThe design of a notification is determined by system templates, and your app defines the contents for each portion of the template. Some details of the notification appear only in the expanded view.\n\nThe most common parts of a notification are indicated in figure 7, as follows:\n• App name: provided by the system.\n• Time stamp: provided by the system, but you can override it using or hide it using .\n• Large icon: optional; usually used only for contact photos. Don't use it for your app icon. Set using .\n\nWe strongly recommend using system templates for proper design compatibility on all devices. If necessary, you can create a custom notification layout.\n\nFor more information about how to create a notification with these features and more, read Create a notification.\n\nAlthough it's not required, it's a good practice for every notification to open an appropriate app activity when it's tapped. In addition to this default notification action, you can add action buttons that complete an app-related task from the notification—often without opening an activity—as shown in figure 8.\n\nStarting in Android 7.0 (API level 24), you can add an action to reply to messages or enter other text directly from the notification.\n\nStarting in Android 10 (API level 29), the platform can automatically generate action buttons with suggested intent-based actions.\n\nAdding action buttons is explained further in Create a notification.\n\nUsers might see notification actions on the device's lock screen. If a notification action causes an app to launch an activity or send a direct reply, users must unlock the device before the app can invoke that notification action.\n\nOn Android 12 (API level 31) and higher, you can configure a notification action such that the device must be unlocked for your app to invoke that action, no matter what workflow the action launches. This option adds an extra layer of security to notifications on locked devices.\n\nTo require a device to be unlocked before your app invokes a given notification action, pass into when creating your notification action, as shown in the following code snippet:\n\nBy default, the notification's text content is truncated to fit on one line. If you want your notification to be longer, you can enable a larger text area that's expandable by applying an additional template, as shown in figure 9.\n\nYou can also create an expandable notification with an image, in inbox style, with a chat conversation, or with media playback controls. For more information, read Create an expandable notification.\n\nTo avoid flooding your users with multiple or redundant notifications when you have additional updates, update an existing notification rather than issuing a new one or use the inbox-style notification to show conversation updates.\n\nHowever, if it's necessary to deliver multiple notifications, consider grouping the separate notifications into a group, available on Android 7.0 and higher.\n\nA notification group lets you collapse multiple notifications into one post in the notification drawer with a summary. The user can progressively expand the notification group and each notification within it for more details, as shown in figure 10.\n\nTo learn how to add notifications to a group, see Create a group of notifications.\n\nStarting in Android 8.0 (API level 26), all notifications must be assigned to a channel or they don't appear. This lets users disable specific notification channels for your app instead of disabling all your notifications. Users can control the visual and auditory options for each channel from the Android system settings, as shown in figure 11. Users can also touch & hold a notification to change behaviors for the associated channel.\n\nOn devices running Android 7.1 (API level 25) and lower, users can manage notifications on a per-app basis only. Each app effectively has only one channel on Android 7.1 and lower.\n\nFigure 11. Notification settings for the Clock app and one of its channels.\n\nAn app can have separate channels for each type of notification the app issues. An app can also create notification channels in response to choices made by users. For example, you can set up separate notification channels for each conversation group created by a user in a messaging app.\n\nThe channel is also where you specify the importance level for your notifications on Android 8.0 and higher, so all notifications posted to the same notification channel have the same behavior. This is described in the following section.\n\nFor more information, see Create and manage notification channels.\n\nAndroid uses the importance of a notification to determine how much the notification interrupts the user visually and audibly. The higher the importance of a notification, the more interruptive the notification is.\n\nOn Android 7.1 (API level 25) and lower, the importance of a notification is determined by the notification's .\n\nOn Android 8.0 (API level 26) and higher, the importance of a notification is determined by the of the channel the notification is posted to. Users can change the importance of a notification channel in the system settings, as shown in figure 12.\n\nFigure 12. Users can change the importance of each channel on Android 8.0 and higher.\n\nThe possible importance levels and the associated notification behaviors are the following:\n• None Low: makes no sound and doesn't appear in the status bar.\n\nAll notifications, regardless of importance, appear in non-interruptive system UI locations, such as in the notification drawer and as a badge on the launcher icon. However, you can modify the appearance of the notification badge.\n\nFor more information, read about how to set the importance.\n\nStarting in Android 5.0 (API level 21), users can enable Do Not Disturb mode, which silences sound and vibration for all notifications. Notifications still appear in the system UI as normal, unless the user specifies otherwise.\n\nThere are three levels available in Do Not Disturb mode:\n• Total silence: blocks all sounds and vibrations, including from alarms, music, videos, and games.\n• Alarms only: blocks all sounds and vibrations, except from alarms.\n• Priority only: users can configure which system-wide categories can interrupt them, such as only alarms, reminders, events, calls, or messages. For messages and calls, users can filter based on sender or caller, as shown in figure 13.\n\nFigure 13. Users can can allow notifications through based on system-wide categories (left) and sender or caller (right).\n\nOn Android 8.0 (API level 26) and higher, users can additionally allow notifications through for app-specific categories—also known as channels—by overriding Do Not Disturb on a channel-by-channel basis. For example, a payment app might have channels for notifications related to withdrawals and deposits. The user can allow withdrawal notifications, deposit notifications, or both when in priority mode.\n\nOn devices running Android 7.1 (API level 25) and lower, users can allow notifications through on an app-by-app basis, rather than on a channel-by-channel basis.\n\nTo configure your notifications for these user settings, you must set a system-wide category.\n\nA notification is required when your app is running a foreground service—a running in the background that's long-living and noticeable to the user, such as a media player. This notification can't be dismissed like other notifications. To remove the notification, the service must be stopped or removed from the foreground state.\n\nFor more information, read Foreground services. If you are building a media player, also read Playing media in the background.\n\nBeginning with Android 8.1 (API level 27), apps can't make a notification sound more than once per second. If your app posts multiple notifications in one second, they all appear as expected, but only the first notification per second makes a sound.\n\nHowever, Android also applies a rate limit when updating a notification. If you post updates to a single notification too frequently, such as many in less than one second, the system might drop updates.\n\nThe Android notification system UI and the notification-related APIs continually evolve. To use the latest notification API features while supporting older devices, use the Support Library notification API, , and its subclasses, as well as . This lets you avoid writing conditional code to check API levels, because these APIs handle it.\n\nis updated as the platform evolves to include the latest methods. However, the availability of a method in doesn't guarantee that the corresponding feature is provided on older devices. In some cases, calling a newly introduced API results in a no-op on older devices.\n\nThe following is a summary of the most notable behavior changes by API level for Android notifications.\n• None Lets the user set the phone to Do Not Disturb mode and configure which notifications are allowed to interrupt them when the device is in priority-only mode.\n• None Adds methods to set whether a notification is displayed on the lock screen, such as ), and for specifying a “public” version of the notification text.\n• None Adds method, which tells the system how interruptive the notification is. For example, setting the priority to high makes the notification appear as a heads-up notification.\n• None Adds notification stacks support to Android Wear (now called Wear OS) devices. Put notifications into a stack using . Notification stacks, later known as a group or bundle, aren't supported on tablets or phones until Android 7.0 (API level 24).\n• None Restyles notification templates to put emphasis on the hero image and avatar.\n• None Adds three notification templates: one for messaging apps and the other two for decorating custom content views with the expandable affordance and other system decorations.\n• None Adds support to handheld devices, such as phones and tablets, for notification groups. Uses the same API as the Android Wear (now called Wear OS) notification stacks introduced in Android 5.0 (API level 21).\n• None Lets users reply inside a notification using inline reply. They can enter text, which is then routed to the notification's parent app.\n• None Lets users turn off notifications per channel, instead of turning off all notifications from an app.\n• None Makes apps with active notifications display a notification badge on top of their app icon on the home or launcher screen.\n• None Lets users snooze a notification from the drawer. You can set an automatic timeout for a notification.\n• None Moves some APIs regarding notification behaviors from to . For example, use instead of for Android 8.0 and higher.\n• Adds runtime permission. For your app to send non-exempt notifications, the user must grant this permission to your app.\n• None Limits full-screen intent notifications to apps that provide calls and alarms. Use the API to check if your app has permission. If not, your app can use to launch the settings page where users can grant the permission.\n• None Changes the way users experience non-dismissable notifications by allowing users to dismiss notifications action even when the flag is set. This doesn't apply to notifications if the flag is set or Device policy controller (DPC) and supporting packages for enterprise. This also does not apply when the phone is locked, or if the user selects Clear all.\n\nAndroid 15 introduces a notification cooldown feature that aims to improve the experience of notifications that arrive in quick succession. This feature reduces the appearance, sound volume and vibration intensity for repetitive notifications for up to two minutes.\n\nCritical notifications that require audio and haptics to get attention are not subject to cooldown. The user can turn off notification cooldown in Settings.\n\nThe following is an example of how to locatethe notification cooldown settings:"
    },
    {
        "link": "https://stackoverflow.com/questions/46483444/how-to-create-notificationchannel-for-lower-apis-26",
        "document": "Not possible. The Android OS does not support it. You can add the channelId to the notification with , but the OS will ignore it pre-Oreo.\n\nMy collegue tested it on API 15, 22, 23, and 26: https://stackoverflow.com/a/45979726/1310343"
    },
    {
        "link": "https://developer.android.com/develop/ui/views/notifications/build-notification",
        "document": "Stay organized with collections Save and categorize content based on your preferences.\n\nNotifications provide short, timely information about events in your app while it isn't in use. This document shows you how to create a notification with various features. For an introduction to how notifications appear on Android, see the Notifications overview. For sample code that uses notifications, see the SociaLite sample on GitHub.\n\nThe code in this page uses the APIs from the AndroidX Library. These APIs let you add features available only on newer versions of Android while still providing compatibility back to Android 9 (API level 28). However, some features, such as the inline reply action, result in a no-op on earlier versions.\n\nAlthough most projects created with Android Studio include the necessary dependencies to use , verify that your module-level file includes the following dependency:\n\nA notification in its most basic and compact form—also known as collapsed form—displays an icon, a title, and a small amount of text content. This section shows how to create a notification that the user can tap to launch an activity in your app.\n\nFigure 1. A notification with an icon, a title, and some text.\n\nFor more details about each part of a notification, read about notification anatomy.\n\nAndroid 13 (API level 33) and higher supports a runtime permission for posting non-exempt (including Foreground Services (FGS)) notifications from an app.\n\nThe permission that you need to declare in your app's manifest file appears in the following code snippet:\n\nFor more details about runtime permissions, see Notification runtime permission.\n\nTo get started, set the notification's content and channel using a object. The following example shows how to create a notification with the following:\n• None A small icon, set by . This is the only user-visible content that's required.\n• None The notification priority, set by . The priority determines how intrusive the notification is on Android 7.1 and earlier. For Android 8.0 and later, instead set the channel importance as shown in the next section.\n\nThe constructor requires you to provide a channel ID. This is required for compatibility with Android 8.0 (API level 26) and later, but is ignored by earlier versions.\n\nBy default, the notification's text content is truncated to fit one line. You can show additional information by creating an expandable notification.\n\nFigure 2. An expandable notification in its collapsed and expanded forms.\n\nIf you want your notification to be longer, you can enable an expandable notification by adding a style template with . For example, the following code creates a larger text area:\n\nFor more information about other large notification styles, including how to add an image and media playback controls, see Create an expandable notification.\n\nBefore you can deliver the notification on Android 8.0 and later, register your app's notification channel with the system by passing an instance of to . The following code is blocked by a condition on the version:\n\nBecause you must create the notification channel before posting any notifications on Android 8.0 and later, execute this code as soon as your app starts. It's safe to call this repeatedly, because creating an existing notification channel performs no operation.\n\nThe constructor requires an , using one of the constants from the class. This parameter determines how to interrupt the user for any notification that belongs to this channel. Set the priority with to support Android 7.1 and earlier, as shown in the preceding example.\n\nAlthough you must set the notification importance or priority as shown in the following example, the system doesn't guarantee the alert behavior you get. In some cases, the system might change the importance level based on other factors, and the user can always redefine what the importance level is for a given channel.\n\nFor more information about what the different levels mean, read about notification importance levels.\n\nEvery notification must respond to a tap, usually to open an activity in your app that corresponds to the notification. To do so, specify a content intent defined with a object and pass it to .\n\nThe following snippet shows how to create a basic intent to open an activity when the user taps the notification:\n\nThis code calls , which automatically removes the notification when the user taps it.\n\nThe intent flags in the preceding example preserve the user's expected navigation experience after the user opens your app using the notification. You might want to use it depending on the type of activity you're starting, which can be one of the following:\n• None An activity that exists exclusively for responses to the notification. There's no reason the user navigates to this activity during normal app use, so the activity starts a new task instead of being added to your app's existing task and back stack. This is the type of intent created in the preceding sample.\n• None An activity that exists in your app's regular app flow. In this case, starting the activity creates a back stack so that the user's expectations for the Back and Up buttons are preserved.\n\nFor more about the different ways to configure your notification's intent, see Start an Activity from a Notification.\n\nTo make the notification appear, call , passing it a unique ID for the notification and the result of . This is shown in the following example:\n\nSave the notification ID that you pass to , because you need it when you want to update or remove the notification.\n\nAdditionally, in order to test basic notifications on devices running on Android 13 and higher, turn on notifications manually or create a dialog to request notifications.\n\nA notification can offer up to three action buttons that let the user respond quickly, such as to snooze a reminder or to reply to a text message. But these action buttons must not duplicate the action performed when the user taps the notification.\n\nTo add an action button, pass a to the method. This is like setting up the notification's default tap action, except instead of launching an activity, you can do other things such as start a that performs a job in the background so that the action doesn't interrupt the app that's already open.\n\nFor example, the following code shows how to send a broadcast to a specific receiver:\n\nFor more information about building a to run background work, see the Broadcasts overview.\n\nIf you're instead trying to build a notification with media playback buttons, such as to pause and skip tracks, see how to create a notification with media controls.\n\nThe direct reply action, introduced in Android 7.0 (API level 24), lets users enter text directly into the notification. The text is then delivered to your app without opening an activity. For example, you can use a direct reply action to let users reply to text messages or update task lists from within the notification.\n\nThe direct reply action appears as an additional button in the notification that opens a text input. When the user finishes typing, the system attaches the text response to the intent you specify for the notification action and sends the intent to your app.\n\nTo create a notification action that supports direct reply, follow these steps:\n• Create an instance of that you can add to your notification action. This class's constructor accepts a string that the system uses as the key for the text input. Your app later uses that key to retrieve the text of the input. // Key for the string that's delivered in the action's intent. // Key for the string that's delivered in the action's intent.\n• Create a for the reply action. // Build a PendingIntent for the reply action to trigger. // Build a PendingIntent for the reply action to trigger. Caution: If you reuse a , a user might reply to a different conversation than the one they intend. You must provide a request code that is different for each conversation or provide an intent that doesn't return when you call on the reply intent of any other conversation. The conversation ID is frequently passed as part of the intent's extras bundle, but is ignored when you call .\n• Attach the object to an action using . // Create the reply action and add the remote input. // Create the reply action and add the remote input.\n• Apply the action to a notification and issue the notification. // Build the notification and add the action. // Build the notification and add the action.\n\nThe system prompts the user to input a response when they trigger the notification action, as shown in figure 4.\n\nTo receive user input from the notification's reply UI, call , passing it the received by your :\n\nAfter you process the text, update the notification by calling with the same ID and tag, if used. This is necessary to hide the direct reply UI and confirm to the user that their reply is received and processed correctly.\n\nWhen working with this new notification, use the context that's passed to the receiver's method.\n\nAppend the reply to the bottom of the notification by calling . However, if you're building a messaging app, create a messaging-style notification and append the new message to the conversation.\n\nFor more advice for notifications from a messaging apps, see the section about best practices for messaging apps.\n\nNotifications can include an animated progress indicator that shows users the status of an ongoing operation.\n\nFigure 5. The progress bar during an operation.\n\nIf you can estimate how much of the operation is complete at any time, use the \"determinate\" form of the indicator—as shown in figure 5—by calling . The first parameter is what the \"complete\" value is, such as 100. The second is how much is complete. The last indicates that this is a determinate progress bar.\n\nAs your operation proceeds, continuously call with an updated value for and reissue the notification, as shown in the following example.\n\nAt the end of the operation, must equal . You can leave the progress bar to show that the operation is done or remove it. In either case, update the notification text to show that the operation is complete. To remove the progress bar, call .\n\nTo display an indeterminate progress bar (a bar that doesn't indicate completion percentage), call . The result is an indicator that has the same style as the preceding progress bar except that it is a continuous animation that doesn't indicate completion. The progress animation runs until you call and then update the notification to remove the activity indicator.\n\nRemember to change the notification text to indicate that the operation is complete.\n\nAndroid uses predefined system-wide categories to determine whether to disturb the user with a given notification when the user enables Do Not Disturb mode.\n\nIf your notification falls into one of the notification categories defined in —such as , , , or —declare it as such by passing the appropriate category to :\n\nThe system uses this information about your notification category to make decisions about displaying your notification when the device is in Do Not Disturb. However, you aren't required to set a system-wide category. Only do so if your notifications match one of the categories defined by in .\n\nYour app might need to display an urgent, time-sensitive message, such as an incoming phone call or a ringing alarm. In these situations, you can associate a full-screen intent with your notification.\n\nWhen the notification is invoked, users see one of the following, depending on the device's lock status:\n• If the user's device is locked, a full-screen activity appears, covering the lockscreen.\n• If the user's device is unlocked, the notification appears in an expanded form that includes options for handling or dismissing the notification.\n\nThe following code snippet demonstrates how to associate your notification with a full-screen intent:\n\nTo control the level of detail visible in the notification from the lock screen, call and specify one of the following values:\n• None : the notification's full content shows on the lock screen.\n• None : no part of the notification shows on the lock screen.\n• None : only basic information, such as the notification's icon and the content title, shows on the lock screen. The notification's full content doesn't show.\n\nWhen you set , you can also provide an alternate version of the notification content that hides certain details. For example, an SMS app might display a notification that shows \"You have 3 new text messages,\" but hides the message contents and senders. To provide this alternative notification, first create the alternative notification with as usual. Then, attach the alternative notification to the normal notification with .\n\nBear in mind that the user always has ultimate control over whether their notifications are visible on the lock screen and can control them based on your app's notification channels.\n\nTo update a notification after you issue it, call again, passing it the same ID you used before. If the previous notification is dismissed, a new notification is created instead.\n\nYou can optionally call so your notification interrupts the user—with sound, vibration, or visual clues—only the first time the notification appears and not for later updates.\n\nNotifications remain visible until one of the following happens:\n• The user taps the notification, if you call when you create the notification.\n• You call for a specific notification ID. This method also deletes ongoing notifications.\n• You call , which removes all notifications you previously issued.\n• The specified duration elapses, if you set a timeout when creating the notification, using . If required, you can cancel a notification before the specified timeout duration elapses.\n\nConsider the best practices listed here when creating notifications for your messaging and chat apps.\n\nStarting in Android 7.0 (API level 24), Android provides a notification style template specifically for messaging content. Using the class, you can change several of the labels displayed on the notification, including the conversation title, additional messages, and the content view for the notification.\n\nThe following code snippet demonstrates how to customize a notification's style using the class.\n\nStarting in Android 9.0 (API level 28), It is also required to use the class in order to get an optimal rendering of the notification and its avatars.\n\nWhen using , do the following:\n• Call to set a title for group chats with more than two people. A good conversation title might be the name of the group chat or, if it doesn't have a name, a list of the participants in the conversation. Without this, the message might be mistaken as belonging to a one-to-one conversation with the sender of the most recent message in the conversation.\n• Use the method to include media messages such as images. MIME types of the pattern image/* are supported.\n• After a user replies with the inline reply action, use to update the notification, and don't retract or cancel the notification. Not cancelling the notification lets the user send multiple replies from the notification.\n• To make the inline reply action compatible with Wear OS, call .\n• Use the method to provide context to a direct reply conversation by adding historic messages to the notification.\n• To enable Smart Reply, call on the reply action. This causes Smart Reply responses to be available to users when the notification is bridged to a Wear OS device. Smart Reply responses are generated by an entirely on-watch machine learning model using the context provided by the notification, and no data is uploaded to the internet to generate the responses.\n• Assign notification metadata to tell the system how to handle your app notifications when the device is in . For example, use the or method to override the Do Not Disturb."
    }
]