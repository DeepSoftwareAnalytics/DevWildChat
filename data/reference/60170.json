[
    {
        "link": "https://mrexcel.com/board/threads/using-vba-to-calculate-relative-strenght-index.201709",
        "document": "Hello guysI would like to know if anybody could help me with some VBA code.I have a sheet where I have to calculate the Relative strenght Index, right now I am doing it like this.....In column A I have the \"dates\",In column B I have the closing stock price on the day given in column A. In column C I calculate the daily return as todays closing price minus the previus day closing prices.In column D I have this =IF(OR(C4>0;C4=0);C4;0), wich puts the days with positive returns in this column.In column E I have this =IF(C4<0;ABS(C4);0), wich puts the days with negative returns in this colunm.In column F I have =AVERAGE(D4:D15)/AVERAGE(E4:E15)In column G I have =100-(100/(1+F15))Oh my god, there has to be an easyer way to do this!!!!!!!To read more on how its is calculatet, go here: http://www.investopedia.com/terms/r/rsi.asp the formula is very simpel but Excel makes it very difficult to use, I was wondering if someone could make it as a function????Jonas Hvid"
    },
    {
        "link": "https://excelforum.com/excel-programming-vba-macros/717139-rsi-relative-strength-index-in-vba.html",
        "document": "If I have helped, Don't forget to add to my reputation (click on the star below the post) \n\n Don't forget to mark threads as \"Solved\" (Thread Tools->Mark thread as Solved) \n\n Use code tags when posting your VBA code: [code] Your code here [/code]"
    },
    {
        "link": "https://community.spiceworks.com/t/relative-strength-index-rsi/886745",
        "document": "Given how easy it is to do this in Excel, can you please speak to what you\n\n mean by “save a lot of space in excel”?\n\nThe formula given at your reference URL resolves to:\n\n …\n\n RSI = 100 - (100/(1+(Average(up range)/Average(down range)))\n\n …\n\nIf you have a column of the “down closes” and a column of the “up closes”,\n\n you can construct a third column that will display the RSI for each day (not\n\n including the first x days) by simply inserting a formula into the (x+1)\n\n cell of the new column and copying it down the column. For example, if your\n\n down closes are in column A and your up closes are in column b, you could\n\n put the following formula in cell C6:\n\n …\n\n =100 - (100/(1+AVERAGE(B2:B6)/AVERAGE(A2:A6)))\n\n …\n\n and copy it down the rest of column C. This will calculate an RSI using an\n\n averaging period of 5 days.\n\n Michael S. Meyers-Jouan"
    },
    {
        "link": "https://forum.ozgrid.com/forum/index.php?thread/130851-i-want-to-create-a-14-period-rsi-relative-strenght-index-using-excel-and-vba",
        "document": "I have a spreadsheet where the value of cell H11 keeps changing at random times. I have to grab that value every 5 minutes, write it to a sheet called \"Macro Page\" in a file called OTSLink.xlsx, cell A3 to A18, then work out the 14 period RSI from those values. As I understand it, I need to grab 15 entries before I can work out my first RSI value. From then I must create a RSI value every 5 minutes.\n\nI have been researching other Excel RSI systems, but they all work off historic imported data. That is of no use to me. My \"historic\" data is only 15 entries long.\n\nHere is the formula and a forum topic that could help.\n\nTo break this down in parts:\n\n1. Grab the value of cell H11 of file \"OTSLink.xlsx\", in a sheet called \"Prices\" and write it to sheet \"Macro Page\" cell A3. \n\n2. Then wait 5 minutes\n\n3. Then grab the value in H11 again and write it to \"Macro Page\" cell A4\n\n4. Do this over and over 15 times till I have a value in cell A18."
    },
    {
        "link": "https://macroption.com/rsi-calculation",
        "document": "This page is a detailed guide how to calculate Relative Strength Index (RSI). You can see how the formulas work in Excel in the RSI Calculator . The calculation is explained in detail in chapter 4 of the calculator's guide.\n• AvgU = average of all up moves in the last N price bars\n• AvgD = average of all down moves in the last N price bars\n• There are 3 different commonly used methods for the exact calculation of AvgU and AvgD (see details below)\n• Calculate up moves and down moves (get U and D)\n• Average the up moves and down moves (get AvgU and AvgD)\n\nStep 1: Calculating Up Moves and Down Moves\n\nWe'll illustrate the calculation of RSI on the example of the most common period, 14. For RSI calculation you need closing prices of the last 15 days (for RSI with a period of 10, you need the last 11 closing prices etc.).\n\nLet's start with calculating the up moves and down moves in the last 14 days (or 14 price bars in general).\n\nFirst, calculate the bar-to-bar changes for each bar: Chng = Close – Close\n\nFor each bar, up move (U) equals:\n• Close – Close if the price change is positive\n• Zero if the price change is negative or zero\n• The absolute value of Close – Close if the price change is negative\n• Zero if the price change is positive or zero\n\nThese up and down moves are calculated in columns C and D in the RSI Calculator.\n\nNow you have the first important input for the RSI formula, the increases and declines in the last N days (with N being the RSI period). The next step is to average them.\n\nThree different approaches are commonly used. They differ in the way how average up and down moves are calculated:\n\nUnder this method, which is the most straightforward, AvgU and AvgD are calculated as simple moving averages:\n\nAvgU = sum of all up moves (U) in the last N bars divided by N\n\nAvgD = sum of all down moves (D) in the last N bars divided by N\n\nHere AvgU and AvgD are calculated from up moves and down moves using an exponential moving average in the same way as you would calculate an EMA of price. The EMA period is the RSI period. The formula is:\n\nJ. Welles Wilder, the inventor of RSI, calculated the indicator using a smoothing method with the same logic as an exponential moving average, only the smoothing factor is different:\n\nFor example, for RSI 14 the formula for average up move is:\n\nYou will find the logic of these calculations is very similar to the calculation of Average True Range (ATR), another indicator invented by J. Welles Wilder.\n\nNow as you have the average up move (AvgU) and average down move (AvgD) in the last 14 price bars, the next step is to calculate Relative Strength, which is defined as the ratio of average up moves and average down moves.\n\nFinally, we know the Relative Strength and we can apply the whole RSI formula:\n\nWhat situation in the market would give us the lowest possible RSI value? A totally bearish market, of course. Imagine that every single day the market closed lower than the day before. There would be no up days (all the U's in the last N bars would be zero). AvgU would be zero (for SMA method immediately after N bars, for EMA and Wilder's methods it would gradually approach zero with each bar if there had been non-zero U's before). The average decline (AvgD), on the other hand, would be some positive number (as you take absolute values when calculating the RSI). Relative Strength would be zero divided by something positive, which gives us zero. The RSI would be zero:\n\nWhat situation in the market would give us the maximum possible RSI value? This would be a totally bullish market with no down days. AvgD would be zero, AvgU some positive number. Relative Strength would be something positive divided by zero. Mathematically, you can't calculate this – in this case the RSI value is defined as 100. If the average decline would be some very low number, but not zero, Relative Strength would be close to infinite and the RSI would be close to 100:\n\nTo conclude, RSI can reach values from 0 (bearish market) to 100 (bullish market).\n\nThe three calculation methods often give quite different results. While different traders have different preferences, most would agree that being consitent and sticking with one method (rather than jumping from one to another) is more important than which of the methods you choose (this also applies to RSI period length).\n\nThe RSI Calculator allows you to put up to 3 different RSI indicators on the chart at the same time, so you can compare how different settings looks in the same situation (for actual trading it is better to use just one, maybe two indicators simultaneously). Further explanation of RSI calculation methods and practical use is available in the calculator's guide."
    },
    {
        "link": "https://stackoverflow.com/questions/1038006/what-are-some-good-patterns-for-vba-error-handling",
        "document": "Error-handling has always been a bother. I've experimented with various techniques. Here's my solution.\n\nThis approach brings together my preferred methods on this SO page, plus a few of my own techniques.\n\nThe question asker mentions only the simple case -- a single procedure. I also cover sub-procedures, custom errors, logging, error-related processing, and other error-related topics.\n\nThe simplest case: Don't assume you always need handling. Procedures which are never going to error out don't need error-handling.\n\nIt's acceptable to simply ignore some errors. This is perfectly acceptable example of an ignored error, because you know there's no other error that can reasonably occur on that statement.\n\nI've never heard of any other error ever happening on that statement. Use your judgement. Ignore extremists. VBA is supposed to be easy. isn't \"the Devil incarnate\"; it's one way to implement Try..Catch in VBA. For more examples, see Jordi's answer.\n\nThe remainder of this answer is about unhandled errors. An unhandled error is an unexpected error which breaks your program.\n• Flow-through: Inspired by @NickD and others here, it completely eliminates \"Exit Sub\" and \"Resume\" from your code. Code flows in one direction, instead of jumping around. There's a single exit point in the procedure. All are important, if you like less typing, less code, and less spaghetti.\n• *Cleanup: This approach ensures the same cleanup code runs whether there is or isn't an error. Error and non-error conditions share the same cleanup code. Straightforward pattern handles a wide variety of scenarios regarding cleanup and custom-handling.\n\nThe basic style can handle more complex cases. For example, you can insert handling or cleanup for specific errors.\n\nA called procedure which doesn't have any special cleanup code doesn't need any error-code. It's errors, and those of it's sub-procedures, will automatically bubble up to the entry-procedure. You can have cleanup-code at each sub.\n\nHowever, a sub-procedure which must always run cleanup-code (even in case of an error) needs a bit of extra help. The sub's error-handler resets the error-event, so the error must be retriggered .\n\nThis means your handler for subs must be different than the handler for the kickoff-procedure (aka \"entry-point\", meaning the first procedure that runs at the beginning of the roundtrip code-loop).\n\nSub-handlers shouldn't show any message boxes or do any logging -- that should remain with the Main handler. Sub handlers should only be used for special cleanup, special processing, and to append extra error-info to the error object.\n\nBeware: any procedure executed with the Run statement requires special handling. If you raise an error within the procedure, the error will not bubble up to the entry procedure, and whatever into the Raise puts into the Err will be lost when execution returns to the caller. Therefore, you need to create a workaround. My workaround is to put Err.Number into a global variable, and then on return from the Run, check that variable.\n\nIf your intention is produce professional code, then you must communicate all unexpected errors appropriately to the user, as shown above. You never want users to see a \"Debug\" button or find themselves dropped into VBA.\n\nThe next evolution is centralized handling. This gives you a really quick and easy way to replicate your perfect error-handling everywhere. As mentioned by @igorsp7, centralized handling makes it simpler and easier to implement consistent, reliable error-handling everywhere. It makes it easy to reuse complex handler logic. It is so easy and simple to just place ErrorHandler at the bottom of every procedure. Reminder: Err is a global object, so there's no need to pass it around as an argument.\n\nUse = vbObjectError + 514 for your first one, as 1 to 513 are reserved for native VB errors. I'm still researching custom error numbering. There's a lot of conflicting information. It may be simply\n\nBut I don't know yet if that's correct! Your error handlers will work even if you use native error numbers. However, if your error handling is based on whether it's a native vs custom error, or if your application is reporting the error to a developer, then to avoid confusion or more bugs, the best practice is to not reuse native numbers.\n\nYou may want custom errors in an addin, an application workbook, and a data workbook. You should reserve a range of allowed error numbers for each type. Then your handlers can determine the source of the error by its number. This enum uses the starting number for each range.\n\nAs developer, you'll want to debug unhandled errors, instead of getting friendly messages. So you want to temporarily disable your handler when you're in development. That's conveniently done by manually setting a \"Debug\" state someplace. There are a couple of ways to do it:\n\nis a function that you need to write, which pulls your Debug mode from wherever you stored it. Can be stored in an Excel defined-name, a module constant, a worksheet cell -- whatever you prefer.\n\nThis needs to be applied in the VB IDE."
    },
    {
        "link": "https://stackoverflow.com/questions/30489035/vba-excel-simple-error-handling",
        "document": "I have looked online as much as I could (except for the Microsoft support website, which is blocked at work for some reason). I am trying to simply skip an error. My code written here is simplified but should work the same way.\n\nWhat my code is supposed to do: One of my subs creates shapes in a loop and names them (btn_1, btn_2, etc). But before creating them, it calls a sub that tries to delete them so as not to create duplicates. This sub loops through (btn_1, btn_2, etc) and deletes the shapes using:\n\nOf course, it happens that the shape cannot be deleted because it simply does not exist. I have found that most of the time, the reccomended fix is to add (on error resume next) before setting the shape, as I get an error saying it does not exist. I have tried it inside the loop, before the loop, etc, like so:\n\nAs far as I understand it is supposed to loop right through if the shape doesn't exist, but I still get the same error whether or not I add the On error resume next! What am I doing wrong?\n\nEDIT: There is no error when the shapes do exist."
    },
    {
        "link": "https://trumpexcel.com/vba-error-handling",
        "document": "No matter how experienced you’re with VBA coding, errors are always going to be a part of it.\n\nThe difference between a novice and an expert VBA programmer is that the expert programmers know how to effectively handle and use errors.\n\nIn this tutorial, I will show you various ways you can use to handle errors effectively in Excel VBA.\n\nBefore we get into VBA error handling, let’s first understand the different types of errors you are likely to encounter when programming in Excel VBA.\n\nThere are four types of errors in Excel VBA:\n\nLet’s quickly understand what these errors are and when you’re likely to encounter these.\n\nA syntax error, as the name suggests, occurs when VBA finds something wrong with the syntax in the code.\n\nFor example, if you forget a part of the statement/syntax that is needed, then you will see the compile error.\n\nIn the below code, as soon as I hit enter after the second line, I see a compile error. This is because the IF statement needs to have the ‘Then‘ command, which is missing in the below code.\n\nNote: When you are typing a code in Excel VBA, it checks for each sentence as soon as you hit enter. If VBA finds something missing in the syntax, it instantly shows a message with some text that can help you understand the missing part.\n\nTo make sure you see the syntax error whenever there is something missing, you need to make sure Autosyntax check is enabled. To do this, click on ‘Tools’ and then click on ‘Options’. In the options dialog box, make sure that the ‘Auto Syntax Check’ option is enabled.\n\nIf the ‘Auto Syntax Check’ option is disabled, VBA will still highlight the line with the syntax error in red, but it will not show the error dialog box.\n\nCompile errors occur when something is missing that is needed for the code to run.\n\nFor example, in the below code, as soon as I try to run the code, it will show the following error. This happens as I have used the IF Then statement without closing it with the mandatory ‘End If’.\n\nA syntax error is also a type of compile error. A syntax error occurs as soon as you hit enter and VBA identifies that something is missing. A compilation error can also occur when VBA doesn’t find anything missing while typing the code, but it does when the code is compiled or executed.\n\nVBA checks each line as you’re typing the code and highlights the syntax error as soon as the line is incorrect and you hit enter. Compile errors, on the other hand, are only identified when the entire code is analyzed by VBA.\n\nBelow are some scenarios where you’ll encounter the compile error:\n• Using an IF Statement without the End IF\n• Using For statement with the Next\n• Using Select statement without using the End Select\n• Not declaring the variable (this works only when Option Explicit is enabled)\n• Calling a Sub/Function that does not exist (or with wrong parameters)\n\nRuntime errors are those that occur when the code is running.\n\nRun time errors will occur only when all the syntax and compile errors are being taken care of.\n\nFor example, if you run code that is supposed to open an Excel workbook, but that workbook is unavailable (either deleted or name changed), your code would give you a runtime error.\n\nWhen a runtime error occurs, it will stop the code and show you the error dialog box.\n\nThe message in the Run-time error dialog box is a little more helpful. It tries to explain the problem that can help you correct it.\n\nIf you click on the Debug button, it will highlight the part of the code that is leading to the error.\n\nIf you have corrected the error, you can click on the Run button in the toolbar (or press F5) to continue running the code from where it left.\n\nOr you can also click on the End button to come out of the code.\n\nImportant: In case you click the End button in the dialog box, it will stop the code at the line at which is encountered. However, all the lines of code before that would have been executed.\n\nLogical errors would not make your code stop but can lead to wrong results. These could also be the most difficult types of errors to troubleshoot.\n\nThese errors are not highlighted by the compiler and need to be manually tackled.\n\nOne example of logical error (that I often find myself stuck with) is running into an endless loop.\n\nAnother example could be when it gives a result which is wrong. For example, you may end up using a wrong variable in the code or add two variables where one is incorrect.\n\nThere are a few ways I use to tackle logical errors:\n• Insert Message Box at some place in the code and highlight values/data that can help understand if eberything is going as expected.\n• Instead of running the code at one go, go through each line one by one. To do this, click anywhere in the code and press F8. you would notice that each time you press F8, one line gets executed. This allows you to go through the code one line at a time and identify the logical errors.\n\nOnce you’re done with the code, it’s a good practice to first compile it before running.\n\nTo compile a code, click on the Debug option in the toolbar and click on Compile VBAProject.\n\nWhen you compile a VBA project, it goes through the code and identifies errors (if any).\n\nIn case it finds an error, it will show you a dialog box with the error. It finds errors one by one. So if it finds an error and you have corrected it, you need to run compile again to find other errors (if there are).\n\nWhen you’re code is free of errors, the Compile VBAProject option will be greyed out.\n\nNote that Compiling will only find ‘Syntax’ errors and ‘Compile’ errors. It will NOT find the run-time errors.\n\nWhen you’re writing VBA code, you don’t want the errors to crop up. To avoid this, there are many error-handling methods you can use.\n\nIn the next few sections of this article, I will be covering the methods you can use for VBA error handling in Excel.\n\nBefore you start working with your code, you need to check for one setting in Excel VBA.\n\nGo to the VBA toolbar and click on Tools and then click on Options.\n\nIn the Options dialog box, click on the General tab and make sure that within the ‘Error Trapping’ group, ‘Break on Unhandled Errors’ is checked.\n\nLet me explain the three options:\n• Break on All Errors: This will stop your code on all types of errors, even when you have used the techniques to handle these errors.\n• Break in Class Module: This will stop your code on all unhandled errors, and at the same time, if you’re using objects such as Userforms, it will also break within those objects and highlight the exact line causing the error.\n• Break on Unhandled Errors: This will stop your code only for those errors that are not handled. This is the default setting as it ensures any unhandled errors are brought to your notice. If you’re using objects such as Userforms, this will not highlight the line causing the error in the object, but will only highlight the line that’s referring to that object.\n\nNote: If you work with objects such as Userforms, you can change this setting to ‘Break on Class Modules’. The difference between #2 and #3 is that when you use Break in Class Module, it will take you to the specific line in the object that is causing the error. You can also choose to go with this instead of ‘Break on Unhandled Errors’.\n\nSo in a nutshell – if you’re just starting with Excel VBA, ensure ‘Break on Unhandled Errors’ is checked.\n\nWhen your code encounters an error, there are a few things you can do:\n• Ignore the error and let the code continue\n• Have an error handling code in place and run it when an error occurs\n\nBoth of these error handling methods ensures that the end user will not get to see an error.\n\nThere are a few ‘On Error’ statements that you can use to get these done.\n\nWhen you use ‘On Error Resume Next’ in your code, any encountered error will be ignored and the code will continue to run.\n\nThis error handling method is used quite often, but you need to be cautious when using it. Since it completely ignores any error that may occur, you may not be able to identify the errors that need to be corrected.\n\nFor example, if the below code is run, it will return an error.\n\nThis happens because you can not divide a number by zero.\n\nBut if I use the ‘On Error Resume Next’ statement in this code (as shown below), it will ignore the error and I will not know that there is an issue that needs to be corrected.\n\nOn Error Resume Next should be used only when you clearly know the kind of errors your VBA code is expected to throw and it’s alright to ignore it.\n\nFor example, below is the VBA event code that would instantly add the date and time value in cell A1 of a newly inserted sheet (this code is added in the worksheet and not in a module).\n\nWhile this works great in most cases, it would show an error if I add a chart sheet instead of a worksheet. Since a chart sheet does not have cells, the code would throw an error.\n\nSo, if I use the ‘On Error Resume Next’ statement in this code, it will work as expected with worksheets and do nothing with chart sheets.\n\nNote: On Error Resume Next Statement is best used when you know what kind of errors you’re likely to encounter. And then if you think it’s safe to ignore these errors, you can use it.\n\nYou can take this code to the next level by analyzing if there was an error, and displaying a relevant message for it.\n\nThe below code would show a message box that would inform the user that a worksheet has not been inserted.\n\n‘Err.Number’ is used to get the error number and ‘Err.Description’ is used to get the error description. These will be covered later in this tutorial.\n\n‘On Error GoTo 0’ will stop the code on the line that causes the error and shows a message box that describes the error.\n\nIn simple terms, it enables the default error checking behavior and shows the default error message.\n\nThen why even use it?\n\nNormally, you don’t need to use ‘On Error Goto 0’, but it can be useful when you use it in conjunction with ‘On Error Resume Next’\n\nThe below code would select all the blank cells in the selection.\n\nBut it would show an error when there are no blank cells in the selected cells.\n\nSo to avoid showing the error, you can use On Error Resume next’\n\nNow, it will also show any error when you run the below code:\n\nSo far, so good!\n\nThe problem arises when there is a part of the code where error can occur, and since you’re using ‘On Error Resume Next’, the code would simply ignore it and move to the next line.\n\nFor example, in the below code, there would no error prompt:\n\nIn the above code, there are two places where an error can occur. The first place is where we are selecting all blank cells (using Selection.SpecialCells) and the second is in the remaining code.\n\nWhile the first error is expected, any error after that is not.\n\nThis is where On Error Goto 0 comes to rescue.\n\nWhen you use it, you reset the error setting to default, where it will start showing errors when it encounters it.\n\nFor example, in the below code, there would be no error in case there are no blank cells, but there would be an error prompt because of ’10/0′\n\nThe above two methods – ‘On Error Resume Next’ and ‘On Error Goto 0’ – doesn’t allow us to truly handle the error. One makes the code ignore the error and the second one resume error checking.\n\nOn Error Go [Label] is a way with which you can specify what you want to do in case your code has an error.\n\nBelow is the code structure that uses this error handler:\n\nNote that before the Error handling ‘Label’, there is an Exit Sub. This ensures that in case there are no errors, the sub is exited and the ‘Label’ code is not executed. In case you don’t use Exit Sub, it will always execute the ‘Label’ code.\n\nIn the example code below, when an error occurs, the code jumps and executes the code in the handler section (and shows a message box).\n\nNote that when an error occurs, the code has already run and executed the lines before the line causing the error. In the above example, the code sets the value of X as 12, but since the error occurs in the next line, it doesn’t set the values for Y and Z.\n\nOnce the code jumps to the error handler code (ErrMsg in this example), it will continue to execute all the lines in and below the error handler code and the exit the sub.\n\nThis one is a bit complicated, and in most cases, you’re unlikely to use this.\n\nBut I will still cover this as I have faced a situation where this was needed (feel free to ignore and jump to the next section if you’re only looking for basics).\n\nBefore I get into the mechanics of it, let me try and explain where can it be useful.\n\nSuppose you have a code where an error is encountered. But all is good as you have one error handler in place. But what happens when there is another error in the error handler code (yeah.. somewhat like the inception movie).\n\nIn such a case, you can not use the second handler as the first error has not been cleared. So while you have handled the first error, in VBA’s memory it still exists. And the VBA memory only has a place for one error – not two or more than that.\n\nIn this scenario, you can use On Error Goto -1.\n\nIt clears the error and frees up VBA memory to handle the next error.\n\nLet’s me explain now by using examples.\n\nSuppose I have the below code. This will throw an error as there is division by zero.\n\nSo to handle it, I use an error handler code (with the name ErrMsg) as shown below:\n\nAll is good now again. As soon as the error occurs, the error handler is used and shows a message box as shown below.\n\nNow, I expand the code so that I have more code in or after the error handler.\n\nSince the first error has been handled but the second has not been, I again see an error as shown below.\n\nStill all good. The code is behaving in the way we expected it to.\n\nSo to handle the second error, I use another error handler (ErrMsg2).\n\nAnd this is where it doesn’t work as expected.\n\nIf you run the above code, it will still give you a run-time error, even after having the second error handler in place.\n\nThis happens as we didn’t clear the first error from VBA’s memory.\n\nYes, we handled it! But it still remains in the memory.\n\nAnd when VBA encounters another error, it’s still stuck with the first error, and hence the second error handler is not used. The code stops at the line that caused the error and shows the error prompt.\n\nTo clear VBA’s memory and clear the previous error, you need to use the ‘On Error Goto -1’.\n\nSo if you add this line in the below code and run it, it will work as expected.\n\nNote: The error automatically gets cleared when a subroutine ends. So, ‘On Error Goto -1’ can be useful when you’re getting two or more than two errors in the same subroutine.\n\nWhenever an error occurs with a code, it’s the Err object that is used to get the details about the error (such as the error number or the description).\n\nThe Err Object has the following properties:\n\nWhile in most cases you don’t need to use Err object, it can sometimes be useful while handling errors in Excel.\n\nFor example, suppose you have a dataset as shown below and for each number, in the selection, you want to calculate the square root in the adjacent cell.\n\nThe below code can do it, but since there is a text string in cell A5, it shows an error as soon as this occurs.\n\nThe problem with this type of error message is that it gives you nothing about what has gone wrong and where the issue occurred.\n\nYou can use the Err object to make these error messages more meaningful.\n\nFor example, if I now use the below VBA code, it will stop the code as soon as the error occurs and show a message box with the cell address of the cell where there is an issue.\n\nThe above code would give you a lot more information than the simple ‘Type Mismatch’, especially the cell address so that you know where the error occurred.\n\nYou can further refine this code to make sure your code runs until the end (instead of breaking at each error) and then gives you a list of cell address where the error occurs.\n\nThe below code would do this:\n\nThe above code runs until the end and gives the square root of all the cells that have numbers in it (in the adjacent column). It then shows a message that lists all the cells where there was an error (as shown below):\n\nWhile the Err properties are useful to show useful information about the errors, there are two Err methods as well that can help you with error handling.\n\nLet’s quickly learn what these are and how/why to use these with VBA in Excel.\n\nSuppose you have a dataset as shown below and you want to get the square root of all these numbers in the adjacent column.\n\nThe following code will get the square roots of all the numbers in the adjacent column and show a message that an error occurred for cell A5 and A9 (as these have text in it).\n\nNote that I have used the Err.Clear method within the If Then statement.\n\nOnce an error has occurred and trapped by the If condition, Err.Clear method resets the error number back to 0. This ensures that IF condition only trap the errors for cells where it is raised.\n\nHad I not used the Err.Clear method, once the error occurs, it would always be true in the IF condition, and the error number has not been reset.\n\nAnother way of making this work is by using the On Error Goto -1, which resets the error completely.\n\nNote: Err.Clear is different from On Error Goto -1. Err.Clear only clears the error description and the error number. it doesn’t completely reset it. This means that if there is another instance of error in the same code, you won’t be able to handle it before resetting it (which can be done with ‘On Error Goto -1’ and not by ‘Err.Clear’).\n\nThe Err.Raise method allows you to raise a run-time error.\n\nBelow is the syntax of using the Err.Raise method:\n\nAll these arguments are optional and you can use these to make your error message more meaningful.\n\nBut why would you ever want to raise an error yourself?\n\nYou can use this method when there is an instance of an error (which means that there is going to an error anyway) and then you use this method to tell the user more about the error (instead of the less helpful error message that VBA shows by default).\n\nFor example, suppose you have a dataset as shown below and you want all the cells to have numeric values only.\n\nThe above code would show an error message that has the specified description and the context file.\n\nPersonally, I have never used Err.Raise as I mostly work with Excel only. But for someone who uses VBA to work with Excel along with other applications such as Outlook, Word or PowerPoint, this can be useful.\n\nHere is a detailed article on Err.Raise method in case you want to learn more.\n\nNo matter how skilled you get a writing VBA code, errors are always going to be a part of it. The best coders are those who have the skills to handle these errors properly.\n\nHere are some best practices you can use when it comes to error handling in Excel VBA.\n• Use ‘On Error Go [Label]’ at the beginning of the code. This will make sure any error that can happen from there is handled.\n• Use ‘On Error Resume Next’ ONLY when you’re sure about the errors that can occur. Use it with expected error only. In case you use it with unexpected errors, it will simply ignore it and move forward. You can use ‘On Error Resume Next’ with ‘Err.Raise’ if you want to ignore a certain type of error and catch the rest.\n• When using error handlers, make sure you’re using Exit Sub before the handlers. This will ensure that the error handler code is executed only when there is an error (else it will always be executed).\n• Use multiple error handlers to trap different kinds of errors. Having multiple error handler ensures that an error is properly addressed. For example, you would want to handle a ‘type mismatch’ error differently than a ‘Division by 0’ run-time error.\n\nHope you found this Excel article useful!\n\nHere are some more Excel VBA Tutorials that you may like:\n• Excel VBA Loops – For Next, Do While, Do Until, For Each\n• Excel Visual Basic Editor – How to Open and Use it in Excel"
    },
    {
        "link": "https://geeksforgeeks.org/excel-vba-error-handling",
        "document": "In a VBA code, there may be some errors like syntax errors, compilation errors, or runtime errors so we need to handle these errors. Suppose there is a code of 200 lines and the code has an error it’s very difficult to find an error in the code of 200 lines so it’s better to handle the error where we are expecting some error in our code. There are many error handling methods in VBA which we will discuss in this article but before that, we will discuss types of error.\n\nVBA Error handling is the process of Anticipating, detecting, and writing code to resolve the error that occurs when your application is running. The VBA Error handling process occurs when writing a code before any error occurs. Before moving to VBA Error handling first you need to know about the types of VBA Errors.\n\nSyntax errors are also called language errors, There are some particular syntaxes for writing any code, In VBA also user needs to follow a particular syntax, and if the user doesn’t write the syntax in the proper way it should be, then the user can face syntax errors.\n\nVBA will display an error message if the syntax is not correctly written.\n\nCompilation occurs over more than one line. In simple words, it can be understood as when something is missing that is needed for the code to run.\n\nWhen there is a statement where there is an error in more than one line of its statement then VBA will display an error message. In the following example, a for loop is written without Next which is a compilation error.\n\nAs the name suggests Rum time errors are those which occur at the time of code running.\n\nA code that is written perfectly but an error occurs at the time of execution. For example, if a file address is attached to the code which doesn’t exist or when a number is divided by zero a case runtime error occurs.\n\nAfter correcting the error the user can click on the run button in the toolbar. (Shortcut key to run is F5). It will continue running the code from where it left off.\n\nLogical errors would not make your code stop but may lead to an output that is not desired. These errors are considered to be the most difficult type of error to troubleshoot.\n\nThe compiler can not highlight the logical errors but it will give a wrong output. The code will run without any error but the output will come wrong. In case of a large number of codes, it is difficult to identify the logical errors, to resolve this problem we need to press “F8” it will run the code one line at a time and we can identify the mistakes for which we are getting the wrong output. The following code is written to the difference between two numbers where we are getting the summation of two numbers.\n\nHere, we can identify the logical error that instead of “-” we have written “+”\n• Expected Errors: Where we are expecting to get an error, there we write our code to handle the error.\n• Unexpected Errors: Where we don’t need to write our code we have VBA error handling statements to handle the errors.\n\nVBA Error Handling refers to the process of anticipating, detecting, and resolving VBA Runtime Errors. The VBA Error Handling process occurs when writing code before any errors actually occur.\n\nThe VBA on error statements is used for error handling. This statement performs some action when an error occurs during run time. Without an Error statement, any run-time error that occurs is misfortunate. Execution stops abruptly with an error message.\n\nMost VBA error handling is done with the On Error Statement. The On Error statement instructs the VBA what to do if it encounters the error.\n\nBelow are On Error Statement:\n\nIt is used to handle errors that occur during run time.\n\nThis Statement can be used in four different ways:\n• On Error GoTo 0: The code stops at the line where the error occurred and displays the message.\n• On Error Resume Next : No error message is displayed, the code will move to the next line.\n• On Error GoTo [Label] : The code moves to a specific line or label. No error message is displayed. This can be used for error handling.\n\nThis is the default behavior of VBA that if an error occurred it stops the execution of the code and displays the error message. For continuation of the code it requires user intervention or the user needs to start the application again. In this process, no error handling is taking place.\n\nThis statement will show an error message that a number or a variable is divided by zero.\n\nIt tells VBA if it gets a run time error then don’t show the error message simply resume to the next statement. In simple language, it can be said that it tells VBA to ignore all the errors and continue.\n\nThe above methods don’t truly allow us to handle the error but On Error, Goto [label] is the way with which the user can handle the error and it also specifies what you want to do with the code if an error occurs.\n• None It is similar to try and catch functionality as in other programming languages such as c and c#. If it gets an error then it will go to the specific statement which we will mention in the “label” part.\n\nThis is used to clear the current error rather than setting a particular behavior.\n\nWhen an error occurs an Error object is created with the help of that we can get details about the Error that is the type of error and error number.\n\nIt is used to get the line number of the error.\n\nWe can create our errors with the help of this method. We can also Raise an error that will return a specific message depending on what kind of information is given to the code.\n\nFrom 1-512, several errors are reserved by VBA. So, we can use anything from 513 to 65535.\n\nLet us consider the below example :\n\nIt is used to clear the number and type of the error from the Err. Object. It clears the description and numbers.’\n\nWe can use a clear method to explicitly clear the error object after an error has been handled.\n\nIt is used to print the description of the error from its number.\n\nVBA IsError is another method to handle error statements by testing for them. If an error occurs it returns a True or False value after testing an Expression for errors.\n\nwhere expression is what you to test if it is an error or not.\n\nLet’s consider the below example:\n\nUsers can handle errors in VBA using the Excel IfError function.\n\nThis Function must be accessed through Worksheet Function.\n\nThe above example will give an output value of Range “A1” If the value is an error it will give “0” as output.\n\nThe best way to error handle within a Loop is by using On Error Resume Next along with Err.Number to detect if an error has occurred,\n\nBelow is the code that is used to divide two numbers( Column A by Column B) and output the result into Column C.\n\nThe result will be 0 if there’s an error.\n\nVBA Error Trapping is just another term for VBA Error Handling\n\nThis article will help you to understand the concept of VBA Error Handling. Also, you can go through the different types of errors such as Syntax errors, compilation errors, Run time errors, and Logical errors. And What is the role of VBA Error Handling with different types of On Error Statement for example On Error Goto 0, On Error Resume Next, On Error GoTo [Label], and On Error GoTo -1. There are some more functions to handle the errors such as VBA IsError and IfError VBA. You can also learn some other important terms such as Err Object(which includes Er1 Function, Err.Raise, Err.Clear, Error Function), VBA Error Handling in a loop, and VBA Error Trapping.\n\nWhat if Auto check syntax is disabled?\n\nHow syntax errors and compiler errors are related?\n\nWhat is the difference between Err.Clear and OnError GoTo -1?"
    },
    {
        "link": "https://reddit.com/r/vba/comments/w7efk6/if_you_only_do_one_thing_right_in_your_vba_code",
        "document": "... AT LEAST ACCORDING TO u/ITFuture\n\nGo as fancy or simple as you want. Play around a bit, talk to strangers, but please know this: For every 5 - 10 minutes you use to add a bit of error handling, you are saving yourself hours and possibly days of work. There will always be bugs, and things that slip through, but catching those bugs early is a lot quicker and cheaper to fix.\n\nMy personal absolute requirements for where I must have great error handling is:\n• Any code that can get called from an event (like WorkbookOpen, Worksheet Before DoubleClick, Worksheet OnChange, Etc).\n• Any code that is 'reaching outside the comfy little Excel space', whether that's an API call, hitting a SharePoint document repo, sending an email, etc. Gotta make that shit bulletproof you know!\n• Any method that is deemed mission critical or extremly complex.\n\nYou decide the rest. You can put error handlers in literally everything if you want to. I wouldn't, some might think it's counterproductive, but you \"do you\" and it's all good. Sparse error handling, although it may cover those 3 areas listed might still take you a while to find bugs. Determining how to fix a bug could be quick or it could take days. Finding where the bug is, should never take days, and I'd argue should never take more than 1 hour -- preferrably less than 10 minutes. My opinion of course, but you need to have an opinion too! That way you can assess how you're measuring up. You don't want to take more than 30 minutes to find a bug? Start tracking that. If you find yourself spending hours and hours consistently, then you need more/better error handling.\n\n(#2) GIVE YOURSELF THE 'FINAL WORD' WHEN SOMETHING GOES WRONG\n\nErrors suck, but you know what sucks more? Having to open up that Task Manager / Activity Monitor (MAC) and Killing your spreadsheet -- including all the spreadsheet's little brothers and sisters that (GASP) weren't saved! Losing the data is not good, but have you ever sat back and reviewed how you're feeling after that happens. For me, it feels like something died. It's mentally draining, and this situation is preventable!\n\nThe 'Last Word' means YOU decide what steps to take when there's a problem. Common things that should be part of the 'unhappy path' are:\n• Application.Interactive = True (that's always helpful, right?)\n• Want users to be directed to a screen? Do that.\n• Need to re-protect the current worksheet? Do that.\n• Need to close some open db connections? Do that.\n\nBeing able to control that state of your application after an error will ease the pain and shorten the time it takes to do whatever is next.\n\nHere's the Error Handling 'pattern' that I have found works for me. Feel free to use it, or adopt your own, but please, for the love of all that is good and holy, don't forget to USE ERROR HANDLING\n\nHere's the structure I used without all the extra comments\n\nEDIT: I wanted to share this link for anyone who want to dive a little deeper with error handling. It's one I've kept bookmarked and has been a solid reference when I had questions."
    }
]