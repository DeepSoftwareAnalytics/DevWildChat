[
    {
        "link": "https://geeksforgeeks.org/socket-programming-cc",
        "document": "Socket programming is a way of connecting two nodes on a network to communicate with each other. One socket(node) listens on a particular port at an IP, while the other socket reaches out to the other to form a connection. The server forms the listener socket while the client reaches out to the server.\n\nSocket programming in C is a powerful way to handle network communication.\n\nThe server is created using the following steps:\n‚Ä¢ domain: integer, specifies communication domain. We use AF_ LOCAL as defined in the POSIX standard for communication between processes on the same host. For communicating between processes on different hosts connected by IPV4, we use AF_INET and AF_I NET 6 for processes connected by IPV6.\n‚Ä¢ protocol: Protocol value for Internet Protocol(IP), which is 0. This is the same number that appears on the protocol field in the IP header of a packet.(man protocols for more details)\n\nThis helps in manipulating options for the socket referred by the file descriptor sockfd. This is completely optional, but it helps in reuse of address and port. Prevents error such as: ‚Äúaddress already in use‚Äù.\n\nAfter the creation of the socket, the bind function binds the socket to the address and port number specified in addr(custom data structure). In the example code, we bind the server to the localhost, hence we use INADDR_ANY to specify the IP address.\n\nIt puts the server socket in a passive mode, where it waits for the client to approach the server to make a connection. The backlog, defines the maximum length to which the queue of pending connections for sockfd may grow. If a connection request arrives when the queue is full, the client may receive an error with an indication of ECONNREFUSED.\n\nIt extracts the first connection request on the queue of pending connections for the listening socket, sockfd, creates a new connected socket, and returns a new file descriptor referring to that socket. At this point, the connection is established between client and server, and they are ready to transfer data.\n\n1. Socket connection: Exactly the same as that of server‚Äôs socket creation\n\n2. Connect: The connect() system call connects the socket referred to by the file descriptor sockfd to the address specified by addr. Server‚Äôs address and port is specified in addr.\n\nHere we are exchanging one hello message between server and client to demonstrate the client/server model.\n‚Ä¢ Connection Failures: Ensure that the client is trying to connect to the correct server address and port.\n‚Ä¢ Port Binding Errors: If a port is already in use by another application, binding to that port will fail. Try using a different port or close the previous application using the port.\n‚Ä¢ Blocking Sockets: By default, sockets are blocking. This means that calls like accept() or recv() will wait indefinitely if there is no client connection or data. You can set the socket to non-blocking mode if needed.\n\nNext: Socket Programming in C/C++: Handling multiple clients on server without multi threading"
    },
    {
        "link": "https://dev.to/jeffreythecoder/how-i-built-a-simple-http-server-from-scratch-using-c-739",
        "document": "You might wonder how web servers \"serve\" files, and how they deliver files that piece together a website that shows on your screen. Well, knowing how a web server is implemented is certainly a good way to \"learn by building\".\n\nAlthough implementing a web server in C sounds very basic and detailed at a ground level, but it might help you better understand how HTTP works, and how servers actually interacts with clients. Let's get started!\n\nBefore building the web server, you need to know how a \"socket\" works.\n\nIf a program (or process) running on a host is like a house, a socket is like a door that lets mails go in and out. When a person in the house receives or delivers a letter, he or she can be agnostic to how the mail is being delivered in the outside world.\n\nUsing the socket network interface, our web server can use a set of functions from C standard package and let our server \"talk to\" clients over the internet. Those clients are also using sockets to talk to us, so socket is basically like a consesus on how to talk with each other over the internet.\n\nTo kick things off, I started by creating and configuring a socket for the server. I configured a few things:\n‚Ä¢ INADDR_ANY: the server accepts connections from any network interface\n\nbinds the socket to a port (I'm using 8080 here) means the socket will listen to any clients trying to connect to the port 8080. takes the maximum number of pending connections (I set it to 10).\n\nNow, my server is all set up and ready to accept incoming client connections.\n\nWith the server up and running, the next step is to handle incoming client connections. I used an infinite loop to continuously listen for new clients.\n\nWhen a client connects, the server accepts the connection and creates a new thread to handle the client's HTTP request. This way, the server can handle multiple clients concurrently.\n\nI defined a function that handles an incoming request from a client. I only implemented GET here since it shows a good case on how server \"serve\" files to clients.\n\nreceives the request data, extracts the requested file name, and decodes the URL (e.g. convert %20 to space). Then, it identifies the file extension, builds an HTTP response containing the requested file, and sends it back to the client.\n\nInside , I defined another function that constructs an HTTP response, containing a header and the actual file.\n\nThe function starts by building an HTTP header with the appropriate MIME type based on the file extension (e.g. if requesting.jpg, MIME type is image/jpeg). If the file doesn't exist, the function creates a 404 Not Found response. Otherwise, it retrieves the file's size and appends the 200 OK header to the response buffer.\n\nNext, it reads the file content and appends it to the response buffer. The response buffer returned back to is sent back to the client .I set BUFFER_SIZE to 1MB, meaning the server can handle any HTTP response with size up to 1MB.\n\nTo wrap up, I hope this tutorial helps you better understand how servers actually interacts with clients.\n\nHere is the github repo for the full code.\n\nCodeCrafters has a coding challenge that guides you to build a HTTP server step-by-step in any language. Join using my referral link to get 40% off üöÄ"
    },
    {
        "link": "https://reddit.com/r/C_Programming/comments/kbfa6t/building_a_http_server_in_c",
        "document": "During winter break I want to build a simple HTTP server from scratch in C. I got started today by building a simple program that opens a port and reads a connection.\n\nHowever, I'm not sure where to go from here. Are there any good resources that provide a checklist of things to implement? Any good tutorials on how to build a server?\n\nThank you so much!"
    },
    {
        "link": "https://dev.to/sanjayrv/a-beginners-guide-to-socket-programming-in-c-5an5",
        "document": "Hi allüëãüèΩ This is my first blog. I never had thoughts about writing blogs. I then came across why beginners should start blogging as they learn new things here, so here we go.\n\nMy career began 6 months ago as a backend developer working on node.js and expressüë®‚Äçüíª. I was thoroughly enjoying this phase of learning and coding. Eventually the project got over and in the new project I was to work on socket programming.\n\nI was more or less as clueless and sweating as this guy xD.\n\n \n\n But this was only in the beginning. Let's us go through the concepts of socket programming to feel betterüìà\n\nWithout wasting any time, let us start.\n\nSockets allow communication between two different processes on the same or different machines.\n\nSocket programming is a way of connecting two nodes on a network to communicate with each other. One socket (node) listens on a particular port at an IP, while other socket reaches out to the other to form a connection. Server forms the listener socket while client reaches out to the server.\n\nClient/Server communication involves two components, namely a client and a server. There are usually multiple clients in communication with a single server. The clients send requests to the server and the server responds to the client requests.\n\nClient is sometimes on and initiates requests to the server whenever interested. It needs to know the address of the server.\n\nServer is always on and services requests from many clients. It doesn‚Äôt initiate contact with any clients.\n\nHow to use sockets?\n‚Ä¢ Set up a Socket (Prepare to communicate)\n‚Ä¢ Initiate the connection to the server\n‚Ä¢ Send and receive packets (Exchange data with the server)\n‚Ä¢ Do stuff with the data (e.g., display a Web page)\n‚Ä¢ Set up a Socket (Prepare to communicate)\n‚Ä¢ Associate server‚Äôs IP address and port no. with the socket\n‚Ä¢ Wait to hear from a client\n‚Ä¢ Indicate how many connections can be pending on the socket\n‚Ä¢ Accept an incoming connection from a client, create a new socket s_new for the client.\n‚Ä¢ Send and receive packets (Exchange data with the client over the new socket s_new)\n‚Ä¢ Repeat 2.2-3.4 with the next connection request\n\nLet us see how each step is done.\n\nBoth client and server need to setup the socket\n\n \n\n Returns a socket descriptor on success, -1 on failure.\n\nOnly the server needs to bind.\n‚Ä¢ sockfd is a file descriptor socket() that is returned.\n\nstruct sockaddr_in { \n\n short sin_family; // e.g. AF_INET \n\n unsigned short sin_port; // e.g. htons(3490)‚Äè \n\n struct in_addr sin_addr; // see struct in_addr below \n\n char sin_zero[8]; // zero this if you want to \n\n };\n‚Ä¢ addrlen is the size of the address structure\n\nOnly the server needs to listen\n‚Ä¢ backlog specifies the maximum number of pending connections the kernel should queue for the socket. Listen returns 0 if OK, -1 on error\n\nOnly the server can accept the incoming client connections.\n‚Ä¢ fromaddr is a pointer to store the client address\n‚Ä¢ addrlen is a pointer to store the returned size of addr. accept() takes the first connection off the queue for sockfd and create a new socket (the return value) for communicating with the client. accept() return a new socket descriptor if OK, -1 on error\n\nThe client need not bind, listen or accept. All client needs to do is to just connect to the server.\n‚Ä¢ toaddr contains the IP address and port number of the serve\n‚Ä¢ addrlen is length of the socket address structure connect() returns 0 if connection is successful and -1 on error\n‚Ä¢ \n‚Ä¢ Read up to n bytes from sockfd into buffer\n‚Ä¢ Returns the number of bytes read on success (0 indicates end of file), -1 on error.\n‚Ä¢ \n‚Ä¢ Write up to n bytes from buffer to sockfd\n‚Ä¢ Returns the number of bytes written on success, -1 on error.\n\nDon't forget to close the socket descriptor after all the effort we've put.\n\n\n\nIf I could learn socket programming, you can too!\n\n Happy Programming!!"
    },
    {
        "link": "https://medium.com/@nipunweerasiri/a-simple-web-server-written-in-c-cf7445002e6",
        "document": "The main aim of this project is to develop a simple web server using socket programming in C on Linux. The web server is going to be very rudimentary. It can only send web pages (like .html) and files (like .jpg) and can only accept GET requests without parameters. All the files are going to be hosted under a directory called htdocs. I will be using WSL to build and run the code.\n\nA socket is a component in a computer network that acts like an endpoint for sending and receiving data. Socket programming is a way of connecting two nodes of a network via sockets to communicate with each other.\n\nA server first creates a socket and binds an address and port. Then it listens for any connections made by a client. The server accepts connections made to the socket in a first-come first-serve basis. Here, a connection between the client and server can be established and data transfer can take place.\n\nThe server receives the HTTP request from the client which begins with something like this:\n\nA request may contain more fields. For this project, we can just focus on the first line ‚Äî the HTTP request line. This line consists of three parts:\n‚Ä¢ URI ‚Äî Universal Resource Identifier, the location where the resource (.html, .jpg, etc.) is located.\n‚Ä¢ HTTP version ‚Äî version of the HTTP protocol used.\n\nThe server processes the request and then sends back a response which may begin with the following lines:\n\nThe response may also contain more fields. The first line of the response also consists of three parts:\n‚Ä¢ Status code ‚Äî indicating if the request has been successful.\n\nTo get started, we will need to have a basic knowledge of standard I/O, string manipulation, file handling and pointers in C.\n\nWe start by including the following headers to an empty .C file:\n\nWe start the application by first creating the server internet socket address:\n\nThe sin_family attribute is the address family used for the socket address which is set to AF_INET used to indicate the IPv4 address family. sin_port is set to the port number in network- byte order. sin_addr.s_addr is set to INADDR_LOOPBACK which refers to the local host via the loopback device (127.0.0.1), also in network-byte order.\n\nThen we create the socket for the application:\n\nThe socket() function creates an endpoint and returns its file descriptor. The setsockopt() function forces the server application to reuse an address it will be bound to ‚Äî it sets the Boolean value of 1 (true) to SO_REUSEADDR.\n\nWe then bind the socket to the server address and then listen for connections:\n\nThe listen() function takes in two arguments, the latter of which specifies the maximum number of connection requests that can be queued before they are rejected.\n\nWe then get the server‚Äôs address information and print it out to the console if there are no errors:\n\nWe then add an infinite loop which will continuously accept connections made by a client. Once we accept a connection, we read the HTTP request to a buffer and parse it to obtain the request method and route (URI) from the first line using sscanf():\n\nOnce we know it is a GET request, we can read the file using the route variable.\n\nThe getFileURL() function is a user defined function that takes in the route and returns the file location:\n\nThe function removes URL parameters, appends index.html if the route ends with a slash, else appends .html if the URL does not contain a period.\n\nIf the resource does not exist, we can return a response with status code 404 and message ‚ÄúNot Found‚Äù (more on HTTP response status codes here).\n\nIf the resource has been found, the server can send back a 200 ‚ÄúOK‚Äù response. The date and content-type fields of the response are generated using user-defined functions and added to the response header:\n\nThe getMimeType() function generates the content-type from the file extension in the URI:\n\nThe list of MIME-types here is only a small subset of all possible types. You can check out a list from MDN of all the common ones here.\n\nWe then calculate the size of the resource:\n\nWith this, we allocate a new response buffer whose size is the sum of the size of the header and the size of the resource. We then copy the contents of both to this buffer:\n\nThen we send the response, free the buffer and close the file. Then we close the connection and serve the next incoming connection from a client."
    },
    {
        "link": "https://w3.org/Protocols/HTTP/1.0/spec.html",
        "document": "Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time. It is inappropriate to use Internet-Drafts as reference material or to cite them other than as \"work in progress\".\n\nTo learn the current status of any Internet-Draft, please check the \" \" listing contained in the Internet-Drafts Shadow Directories on (Africa), (Europe), (Pacific Rim), (US East Coast), or (US West Coast).\n\nDistribution of this document is unlimited. Please send comments to the HTTP working group at < >. Discussions of the working group are archived at < >. General discussions about HTTP and the applications which use HTTP should take place on the < > mailing list.\n\nHTTP has been in use by the World-Wide Web global information initiative since 1990. This specification reflects common usage of the protocol referred to as \"HTTP/1.0\".\n\nPractical information systems require more functionality than simple retrieval, including search, front-end update, and annotation. HTTP allows an open-ended set of methods to be used to indicate the purpose of a request. It builds on the discipline of reference provided by the Uniform Resource Identifier (URI) [2], as a location (URL) [4] or name (URN) [16], for indicating the resource on which a method is to be applied. Messages are passed in a format similar to that used by Internet Mail [7] and the Multipurpose Internet Mail Extensions (MIME) [5].\n\nHTTP is also used as a generic protocol for communication between user agents and proxies/gateways to other Internet protocols, such as SMTP [12], NNTP [11], FTP [14], Gopher [1], and WAIS [8], allowing basic hypermedia access to resources available from diverse applications and simplifying the implementation of user agents.\n\nMost HTTP communication is initiated by a user agent and consists of a request to be applied to a resource on some origin server. In the simplest case, this may be accomplished via a single connection (v) between the user agent (UA) and the origin server (O).\n\nAny party to the communication which is not acting as a tunnel may employ an internal cache for handling requests. The effect of a cache is that the request/response chain is shortened if one of the participants along the chain has a cached response applicable to that request. The following illustrates the resulting chain if B has a cached copy of an earlier response from O (via C) for a request which has not been cached by UA or A.\n\nOn the Internet, HTTP communication generally takes place over TCP/IP connections. The default port is TCP 80 [15], but other ports can be used. This does not preclude HTTP from being implemented on top of any other protocol on the Internet, or on other networks. HTTP only presumes a reliable transport; any protocol that provides such guarantees can be used, and the mapping of the HTTP/1.0 request and response structures onto the transport data units of the protocol in question is outside the scope of this specification.\n\nExcept for experimental applications, current practice requires that the connection be established by the client prior to each request and closed by the server after sending the response. Both clients and servers should be aware that either party may close the connection prematurely, due to user action, automated time-out, or program failure, and should handle such closing in a predictable fashion. In any case, the closing of the connection by either or both parties always terminates the current request, regardless of its status.\n\nThe rule is only used for descriptive field contents and values that are not intended to be interpreted by the message parser. Words of may contain octets from character sets other than US-ASCII.\n\nHexadecimal numeric characters are used in several protocol elements.\n\nThe version of an HTTP message is indicated by an field in the first line of the message. If the protocol version is not specified, the recipient must assume that the message is in the simple HTTP/0.9 format.\n\nThis document defines both the 0.9 and 1.0 versions of the HTTP protocol. Applications sending or messages, as defined by this specification, must include an of \" \".\n‚Ä¢ recognize the format of the for HTTP/0.9 and HTTP/1.0 requests;\n‚Ä¢ understand any valid request in the format of HTTP/0.9 or HTTP/1.0;\n‚Ä¢ respond appropriately with a message in the same protocol version used by the client.\n‚Ä¢ recognize the format of the for HTTP/1.0 responses;\n‚Ä¢ understand any valid response in the format of HTTP/0.9 or HTTP/1.0.\n\nThe character set of an entity body should be labelled as the lowest common denominator of the character codes used within that body, with the exception that no label is preferred over the labels US-ASCII or ISO-8859-1.\n\nSome older HTTP applications do not recognize media type parameters. HTTP/1.0 applications should only use media type parameters when they are necessary to define the content of a message.\n\nMedia-type values are registered with the Internet Assigned Number Authority (IANA [15]). The media type registration process is outlined in RFC 1590 [13]. Use of non-registered media types is discouraged.\n\nMedia subtypes of the \"text\" type use as the text line break when in canonical form. However, HTTP allows the transport of text media with plain or alone representing a line break when used consistently within the . HTTP applications must accept , bare , and bare as being representative of a line break in text media received via HTTP.\n\nIn addition, if the text media is represented in a character set that does not use octets 13 and 10 for and respectively, as is the case for some multi-byte character sets, HTTP allows the use of whatever octet sequences are defined by that character set to represent the equivalent of and for line breaks. This flexibility regarding line breaks applies only to text media in the ; a bare or should not be substituted for within any of the HTTP control structures (such as header fields and multipart boundaries).\n\nThe \"charset\" parameter is used with some media types to define the character set (Section 3.4) of the data. When no explicit charset parameter is provided by the sender, media subtypes of the \"text\" type are defined to have a default charset value of \"ISO-8859-1\" when received via HTTP. Data in character sets other than \"ISO-8859-1\" or its subsets must be labelled with an appropriate charset value in order to be consistently interpreted by the recipient.\n\nAll multipart types share a common syntax and must include a boundary parameter as part of the media type value. The message body is itself a protocol element and must therefore use only to represent line breaks between body-parts. Multipart body-parts may contain HTTP header fields which are significant to the meaning of that part.\n\nMultiple fields with the same may be present in a message if and only if the entire for that header field is defined as a comma-separated list [i.e., ]. It must be possible to combine the multiple header fields into one \"field-name: field-value\" pair, without changing the semantics of the message, by appending each subsequent field-value to the first, each separated by a comma.\n\nThe methods commonly used by HTTP/1.0 applications are fully defined in Section 8.\n\nThe form is only allowed when the request is being made to a proxy. The proxy is requested to forward the request and return the response. If the request is or and a prior response is cached, the proxy may use the cached message if it passes any restrictions in the header field. Note that the proxy may forward the request on to another proxy or directly to the server specified by the . In order to avoid request loops, a proxy must be able to recognize all of its server names, including any aliases, local variations, and the numeric IP address. An example would be:\n\nThe is transmitted as an encoded string, where some characters may be escaped using the \"% HEX HEX\" encoding defined by RFC 1738 [4]. The origin server must decode the in order to properly interpret the request.\n\nThe first digit of the defines the class of response. The last two digits do not have any categorization role. There are 5 values for the first digit:\n‚Ä¢ 1xx: Informational - Not used, but reserved for future use\n‚Ä¢ 2xx: Success - The action was successfully received, understood, and accepted.\n‚Ä¢ 3xx: Redirection - Further action must be taken in order to complete the request\n‚Ä¢ 4xx: Client Error - The request contains bad syntax or cannot be fulfilled\n‚Ä¢ 5xx: Server Error - The server failed to fulfill an apparently valid request\n\nFor response messages, whether or not an entity body is included with a message is dependent on both the request method and the response code. All responses to the request method must not include a body, even though the presence of entity header fields may lead one to believe they do. All 1xx (informational), 204 (no content), and 304 (not modified) responses must not include a body. All other responses must include an entity body or a header field defined with a value of zero (0).\n\nAny HTTP/1.0 message containing an entity body should include a header field defining the media type of that body. If and only if the media type is not given by a header, as is the case for messages, the recipient may attempt to guess the media type via inspection of its content and/or the name extension(s) of the URL used to identify the resource. If the media type remains unknown, the recipient should treat it as type \" \".\n\nClosing the connection cannot be used to indicate the end of a request body, since it leaves no possibility for the server to send back a response. Therefore, HTTP/1.0 requests containing an entity body must include a valid header field. If a request contains an entity body and is not specified, and the server does not recognize or cannot calculate the length from other fields, then the server should send a 400 (bad request) response.\n\nThe semantics of the method changes to a \"conditional \" if the request message includes an header field. A conditional method requests that the identified resource be transferred only if it has been modified since the date given by the header, as described in Section 10.9. The conditional method is intended to reduce network usage by allowing cached entities to be refreshed without requiring multiple requests or transferring unnecessary data.\n\nThere is no \"conditional \" request analogous to the conditional . If an header field is included with a request, it should be ignored.\n‚Ä¢ Posting a message to a bulletin board, newsgroup, mailing list, or similar group of articles;\n‚Ä¢ Providing a block of data, such as the result of submitting a form [3], to a data-handling process;\n\nA successful does not require that the entity be created as a resource on the origin server or made accessible for future reference. That is, the action performed by the method might not result in a resource that can be identified by a URI. In this case, either 200 (ok) or 204 (no content) is the appropriate response status, depending on whether or not the response includes an entity that describes the result.\n\nIf a resource has been created on the origin server, the response should be 201 (created) and contain an entity (preferably of type \"text/html\") which describes the status of the request and refers to the new resource.\n\nA valid is required on all HTTP/1.0 requests. An HTTP/1.0 server should respond with a 400 (bad request) message if it cannot determine the length of the request message's content.\n\nApplications must not cache responses to a POST request because the application has no way of knowing that the server would return an equivalent response on some future request.\n\nOf the methods defined by this specification, only can create a resource.\n\nThe 202 response is intentionally non-committal. Its purpose is to allow a server to accept a request for some other process (perhaps a batch-oriented process that is only run once per day) without requiring that the user agent's connection to the server persist until the process is completed. The entity returned with this response should include an indication of the request's current status and either a pointer to a status monitor or some estimate of when the user can expect the request to be fulfilled.\n\nThe requested resource is available at one or more locations. Unless it was a request, the response should include an entity containing a list of resource characteristics and locations from which the user or user agent can choose the one most appropriate. If the server has a preferred choice, it should include the URL in a field; user agents may use this field value for automatic redirection.\n\nThe new URL must be given by the field in the response. Unless it was a request, the of the response should contain a short note with a hyperlink to the new URL.\n\nIf the 301 status code is received in response to a request using the method, the user agent must not automatically redirect the request unless it can be confirmed by the user, since this might change the conditions under which the request was issued.\n\nThe URL must be given by the field in the response. Unless it was a request, the of the response should contain a short note with a hyperlink to the new URI(s).\n\nIf the 302 status code is received in response to a request using the method, the user agent must not automatically redirect the request unless it can be confirmed by the user, since this might change the conditions under which the request was issued.\n\nA proxy must not modify the header field even if it does not understand all the methods specified, since the user agent may have other means of communicating with the origin server.\n\nThe header field does not indicate what methods are implemented by the server.\n\nResponses to requests containing an field are not cachable.\n\nAny greater than or equal to zero is a valid value. Section 7.2.2 describes how to determine the length of a response entity body if a is not given.\n\nIn theory, the date should represent the moment just before the entity is generated. In practice, the date can be generated at any time during the message origination without affecting its semantic value.\n\nThe Expires field cannot be used to force a user agent to refresh its display or reload a resource; its semantics apply only to caching mechanisms, and such mechanisms need only check a resource's expiration status when a new request for that resource is initiated.\n\nUser agents often have history mechanisms, such as \"Back\" buttons and history lists, which can be used to redisplay an entity retrieved earlier in a session. By default, the field does not apply to history mechanisms. If the entity is still in storage, a history mechanism should display it even if the entity has expired, unless the user has specifically configured the agent to refresh expired history documents.\n\nThe Internet e-mail address in this field may be separate from the Internet host which issued the request. For example, when a request is passed through a proxy, the original issuer's address should be used.\n\nAn origin server must not send a Last-Modified date which is later than the server's time of message origination. In such cases, where the resource's last modification would indicate some time in the future, the server must replace that date with the message origination date.\n\nPragma directives must be passed through by a proxy or gateway application, regardless of their significance to that application, since the directives may be applicable to all recipients along the request/response chain. It is not possible to specify a pragma for a specific recipient; however, any pragma directive not relevant to a recipient should be ignored by that recipient.\n\nA user agent that wishes to authenticate itself with a server--usually, but not necessarily, after receiving a 401 response--may do so by including an header field with the request. The field value consists of containing the authentication information of the user agent for the realm of the resource being requested.\n\nIf the server does not wish to accept the credentials sent with a request, it should return a 403 (forbidden) response.\n\nThe HTTP protocol does not restrict applications to this simple challenge-response mechanism for access authentication. Additional mechanisms may be used, such as encryption at the transport level or via message encapsulation, and with additional header fields specifying authentication information. However, these additional mechanisms are not defined by this specification.\n\nProxies must be completely transparent regarding user agent authentication. That is, they must forward the and headers untouched, and must not cache the response to a request containing . HTTP/1.0 does not provide a means for a client to be authenticated with a proxy.\n\nUpon receipt of an unauthorized request for a URI within the protection space, the server should respond with a challenge like the following:\n\nTo receive authorization, the client sends the user-ID and password, separated by a single colon (\":\") character, within a base64 [5] encoded string in the .\n\nIn particular, the convention has been established that the and methods should never have the significance of taking an action other than retrieval. These methods should be considered \"safe.\" This allows user agents to represent other methods, such as , in a special way, so that the user is made aware of the fact that a possibly unsafe action is being requested.\n\nNaturally, it is not possible to ensure that the server does not generate side-effects as a result of performing a request; in fact, some dynamic resources consider that a feature. The important distinction here is that the user did not request the side-effects, so therefore cannot be held accountable for them.\n\nRevealing the specific software version of the server may allow the server machine to become more vulnerable to attacks against software that is known to contain security holes. Implementors should make the header field a configurable option.\n\nThe field allows reading patterns to be studied and reverse links drawn. Although it can be very useful, its power can be abused if user details are not separated from the information contained in the . Even when the personal information has been removed, the field may indicate a private document's URI whose publication would be inappropriate.\n\nThe information sent in the field might conflict with the user's privacy interests or their site's security policy, and hence it should not be transmitted without the user being able to disable, enable, and modify the contents of the field. The user must be able to set the contents of this field within a user preference or application defaults configuration.\n\nWe suggest, though do not require, that a convenient toggle interface be provided for the user to enable or disable the sending of and information.\n\nThe HTTP protocol has evolved considerably over the past four years. It has benefited from a large and active developer community--the many people who have participated on the www-talk mailing list--and it is that community which has been most responsible for the success of HTTP and of the World-Wide Web in general. Marc Andreessen, Robert Cailliau, Daniel W. Connolly, Bob Denny, Jean-Francois Groff, Phillip M. Hallam-Baker, H√•kon W. Lie, Ari Luotonen, Rob McCool, Lou Montulli, Dave Raggett, Tony Sanders, and Marc VanHeyningen deserve special recognition for their efforts in defining aspects of the protocol for early versions of this specification.\n\nPaul Hoffman contributed sections regarding the informational status of this document and Appendices C and D.\n\nThis document has benefited greatly from the comments of all those participating in the HTTP-WG. In addition to those already mentioned, the following individuals have contributed to this specification:\n\nRoy T. Fielding\n\n Department of Information and Computer Science\n\n University of California\n\n Irvine, CA 92717-3425, U.S.A.\n\n Fax: +1 (714) 824-4056\n\n Email: fielding@ics.uci.edu\n\nClients should be tolerant in parsing the and servers tolerant when parsing the . In particular, they should accept any amount of or characters between fields, even though only a single is required.\n\nThe line terminator for fields is the sequence . However, we recommend that applications, when parsing such headers, recognize a single as a line terminator and ignore the leading .\n\nAt the time of this writing, it is expected that RFC 1521 will be revised. The revisions may include some of the practices found in HTTP/1.0 but not in RFC 1521.\n\nThis appendix describes specific areas where HTTP differs from RFC 1521. Proxies and gateways to strict MIME environments should be aware of these differences and provide the appropriate conversions where necessary. Proxies and gateways from MIME environments to HTTP also need to be aware of the differences because some conversions may be required.\n\nRFC 1521 requires that content with a Content-Type of \"text\" represent line breaks as CRLF and forbids the use of CR or LF outside of line break sequences. HTTP allows CRLF, bare CR, and bare LF to indicate a line break within text content when a message is transmitted over HTTP.\n\nWhere it is possible, a proxy or gateway from HTTP to a strict RFC 1521 environment should translate all line breaks within the text media types described in Section 3.6.1 of this document to the RFC 1521 canonical form of . Note, however, that this may be complicated by the presence of a and by the fact that HTTP allows the use of some character sets which do not use octets 13 and 10 to represent and , as is the case for some multi-byte character sets.\n\nProxies and gateways from HTTP to MIME-compliant protocols are responsible for ensuring that the message is in the correct format and encoding for safe transport on that protocol, where \"safe transport\" is defined by the limitations of the protocol being used. Such a proxy or gateway should label the data with an appropriate Content-Transfer-Encoding if doing so will improve the likelihood of safe transport over the destination protocol.\n\nThe fundamental difference between the POST and PUT requests is reflected in the different meaning of the . The URI in a POST request identifies the resource that will handle the enclosed entity as data to be processed. That resource may be a data-accepting process, a gateway to some other protocol, or a separate entity that accepts annotations. In contrast, the URI in a PUT request identifies the entity enclosed with the request -- the user agent knows what URI is intended and the server should not apply the request to some other resource."
    },
    {
        "link": "https://w3.org/Protocols/HTTP/1.0/draft-ietf-http-spec.html",
        "document": "Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time. It is inappropriate to use Internet-Drafts as reference material or to cite them other than as \"work in progress\".\n\nTo learn the current status of any Internet-Draft, please check the \" \" listing contained in the Internet-Drafts Shadow Directories on (Africa), (Europe), (Pacific Rim), (US East Coast), or (US West Coast).\n\nDistribution of this document is unlimited. Please send comments to the HTTP working group at < >. Discussions of the working group are archived at < >. General discussions about HTTP and the applications which use HTTP should take place on the < > mailing list.\n\nHTTP has been in use by the World-Wide Web global information initiative since 1990. This specification reflects common usage of the protocol referred to as \"HTTP/1.0\".\n\nPractical information systems require more functionality than simple retrieval, including search, front-end update, and annotation. HTTP allows an open-ended set of methods to be used to indicate the purpose of a request. It builds on the discipline of reference provided by the Uniform Resource Identifier (URI) [2], as a location (URL) [4] or name (URN) [16], for indicating the resource on which a method is to be applied. Messages are passed in a format similar to that used by Internet Mail [7] and the Multipurpose Internet Mail Extensions (MIME) [5].\n\nHTTP is also used as a generic protocol for communication between user agents and proxies/gateways to other Internet protocols, such as SMTP [12], NNTP [11], FTP [14], Gopher [1], and WAIS [8], allowing basic hypermedia access to resources available from diverse applications and simplifying the implementation of user agents.\n\nMost HTTP communication is initiated by a user agent and consists of a request to be applied to a resource on some origin server. In the simplest case, this may be accomplished via a single connection (v) between the user agent (UA) and the origin server (O).\n\nAny party to the communication which is not acting as a tunnel may employ an internal cache for handling requests. The effect of a cache is that the request/response chain is shortened if one of the participants along the chain has a cached response applicable to that request. The following illustrates the resulting chain if B has a cached copy of an earlier response from O (via C) for a request which has not been cached by UA or A.\n\nOn the Internet, HTTP communication generally takes place over TCP/IP connections. The default port is TCP 80 [15], but other ports can be used. This does not preclude HTTP from being implemented on top of any other protocol on the Internet, or on other networks. HTTP only presumes a reliable transport; any protocol that provides such guarantees can be used, and the mapping of the HTTP/1.0 request and response structures onto the transport data units of the protocol in question is outside the scope of this specification.\n\nExcept for experimental applications, current practice requires that the connection be established by the client prior to each request and closed by the server after sending the response. Both clients and servers should be aware that either party may close the connection prematurely, due to user action, automated time-out, or program failure, and should handle such closing in a predictable fashion. In any case, the closing of the connection by either or both parties always terminates the current request, regardless of its status.\n\nThe rule is only used for descriptive field contents and values that are not intended to be interpreted by the message parser. Words of may contain octets from character sets other than US-ASCII.\n\nHexadecimal numeric characters are used in several protocol elements.\n\nThe version of an HTTP message is indicated by an field in the first line of the message. If the protocol version is not specified, the recipient must assume that the message is in the simple HTTP/0.9 format.\n\nThis document defines both the 0.9 and 1.0 versions of the HTTP protocol. Applications sending or messages, as defined by this specification, must include an of \" \".\n‚Ä¢ recognize the format of the for HTTP/0.9 and HTTP/1.0 requests;\n‚Ä¢ understand any valid request in the format of HTTP/0.9 or HTTP/1.0;\n‚Ä¢ respond appropriately with a message in the same protocol version used by the client.\n‚Ä¢ recognize the format of the for HTTP/1.0 responses;\n‚Ä¢ understand any valid response in the format of HTTP/0.9 or HTTP/1.0.\n\nThe character set of an entity body should be labelled as the lowest common denominator of the character codes used within that body, with the exception that no label is preferred over the labels US-ASCII or ISO-8859-1.\n\nSome older HTTP applications do not recognize media type parameters. HTTP/1.0 applications should only use media type parameters when they are necessary to define the content of a message.\n\nMedia-type values are registered with the Internet Assigned Number Authority (IANA [15]). The media type registration process is outlined in RFC 1590 [13]. Use of non-registered media types is discouraged.\n\nMedia subtypes of the \"text\" type use as the text line break when in canonical form. However, HTTP allows the transport of text media with plain or alone representing a line break when used consistently within the . HTTP applications must accept , bare , and bare as being representative of a line break in text media received via HTTP.\n\nIn addition, if the text media is represented in a character set that does not use octets 13 and 10 for and respectively, as is the case for some multi-byte character sets, HTTP allows the use of whatever octet sequences are defined by that character set to represent the equivalent of and for line breaks. This flexibility regarding line breaks applies only to text media in the ; a bare or should not be substituted for within any of the HTTP control structures (such as header fields and multipart boundaries).\n\nThe \"charset\" parameter is used with some media types to define the character set (Section 3.4) of the data. When no explicit charset parameter is provided by the sender, media subtypes of the \"text\" type are defined to have a default charset value of \"ISO-8859-1\" when received via HTTP. Data in character sets other than \"ISO-8859-1\" or its subsets must be labelled with an appropriate charset value in order to be consistently interpreted by the recipient.\n\nAll multipart types share a common syntax and must include a boundary parameter as part of the media type value. The message body is itself a protocol element and must therefore use only to represent line breaks between body-parts. Multipart body-parts may contain HTTP header fields which are significant to the meaning of that part.\n\nMultiple fields with the same may be present in a message if and only if the entire for that header field is defined as a comma-separated list [i.e., ]. It must be possible to combine the multiple header fields into one \"field-name: field-value\" pair, without changing the semantics of the message, by appending each subsequent field-value to the first, each separated by a comma.\n\nThe methods commonly used by HTTP/1.0 applications are fully defined in Section 8.\n\nThe form is only allowed when the request is being made to a proxy. The proxy is requested to forward the request and return the response. If the request is or and a prior response is cached, the proxy may use the cached message if it passes any restrictions in the header field. Note that the proxy may forward the request on to another proxy or directly to the server specified by the . In order to avoid request loops, a proxy must be able to recognize all of its server names, including any aliases, local variations, and the numeric IP address. An example would be:\n\nThe is transmitted as an encoded string, where some characters may be escaped using the \"% HEX HEX\" encoding defined by RFC 1738 [4]. The origin server must decode the in order to properly interpret the request.\n\nThe first digit of the defines the class of response. The last two digits do not have any categorization role. There are 5 values for the first digit:\n‚Ä¢ 1xx: Informational - Not used, but reserved for future use\n‚Ä¢ 2xx: Success - The action was successfully received, understood, and accepted.\n‚Ä¢ 3xx: Redirection - Further action must be taken in order to complete the request\n‚Ä¢ 4xx: Client Error - The request contains bad syntax or cannot be fulfilled\n‚Ä¢ 5xx: Server Error - The server failed to fulfill an apparently valid request\n\nFor response messages, whether or not an entity body is included with a message is dependent on both the request method and the response code. All responses to the request method must not include a body, even though the presence of entity header fields may lead one to believe they do. All 1xx (informational), 204 (no content), and 304 (not modified) responses must not include a body. All other responses must include an entity body or a header field defined with a value of zero (0).\n\nAny HTTP/1.0 message containing an entity body should include a header field defining the media type of that body. If and only if the media type is not given by a header, as is the case for messages, the recipient may attempt to guess the media type via inspection of its content and/or the name extension(s) of the URL used to identify the resource. If the media type remains unknown, the recipient should treat it as type \" \".\n\nClosing the connection cannot be used to indicate the end of a request body, since it leaves no possibility for the server to send back a response. Therefore, HTTP/1.0 requests containing an entity body must include a valid header field. If a request contains an entity body and is not specified, and the server does not recognize or cannot calculate the length from other fields, then the server should send a 400 (bad request) response.\n\nThe semantics of the method changes to a \"conditional \" if the request message includes an header field. A conditional method requests that the identified resource be transferred only if it has been modified since the date given by the header, as described in Section 10.9. The conditional method is intended to reduce network usage by allowing cached entities to be refreshed without requiring multiple requests or transferring unnecessary data.\n\nThere is no \"conditional \" request analogous to the conditional . If an header field is included with a request, it should be ignored.\n‚Ä¢ Posting a message to a bulletin board, newsgroup, mailing list, or similar group of articles;\n‚Ä¢ Providing a block of data, such as the result of submitting a form [3], to a data-handling process;\n\nA successful does not require that the entity be created as a resource on the origin server or made accessible for future reference. That is, the action performed by the method might not result in a resource that can be identified by a URI. In this case, either 200 (ok) or 204 (no content) is the appropriate response status, depending on whether or not the response includes an entity that describes the result.\n\nIf a resource has been created on the origin server, the response should be 201 (created) and contain an entity (preferably of type \"text/html\") which describes the status of the request and refers to the new resource.\n\nA valid is required on all HTTP/1.0 requests. An HTTP/1.0 server should respond with a 400 (bad request) message if it cannot determine the length of the request message's content.\n\nApplications must not cache responses to a POST request because the application has no way of knowing that the server would return an equivalent response on some future request.\n\nOf the methods defined by this specification, only can create a resource.\n\nThe 202 response is intentionally non-committal. Its purpose is to allow a server to accept a request for some other process (perhaps a batch-oriented process that is only run once per day) without requiring that the user agent's connection to the server persist until the process is completed. The entity returned with this response should include an indication of the request's current status and either a pointer to a status monitor or some estimate of when the user can expect the request to be fulfilled.\n\nThe requested resource is available at one or more locations. Unless it was a request, the response should include an entity containing a list of resource characteristics and locations from which the user or user agent can choose the one most appropriate. If the server has a preferred choice, it should include the URL in a field; user agents may use this field value for automatic redirection.\n\nThe new URL must be given by the field in the response. Unless it was a request, the of the response should contain a short note with a hyperlink to the new URL.\n\nIf the 301 status code is received in response to a request using the method, the user agent must not automatically redirect the request unless it can be confirmed by the user, since this might change the conditions under which the request was issued.\n\nThe URL must be given by the field in the response. Unless it was a request, the of the response should contain a short note with a hyperlink to the new URI(s).\n\nIf the 302 status code is received in response to a request using the method, the user agent must not automatically redirect the request unless it can be confirmed by the user, since this might change the conditions under which the request was issued.\n\nA proxy must not modify the header field even if it does not understand all the methods specified, since the user agent may have other means of communicating with the origin server.\n\nThe header field does not indicate what methods are implemented by the server.\n\nResponses to requests containing an field are not cachable.\n\nAny greater than or equal to zero is a valid value. Section 7.2.2 describes how to determine the length of a response entity body if a is not given.\n\nIn theory, the date should represent the moment just before the entity is generated. In practice, the date can be generated at any time during the message origination without affecting its semantic value.\n\nThe Expires field cannot be used to force a user agent to refresh its display or reload a resource; its semantics apply only to caching mechanisms, and such mechanisms need only check a resource's expiration status when a new request for that resource is initiated.\n\nUser agents often have history mechanisms, such as \"Back\" buttons and history lists, which can be used to redisplay an entity retrieved earlier in a session. By default, the field does not apply to history mechanisms. If the entity is still in storage, a history mechanism should display it even if the entity has expired, unless the user has specifically configured the agent to refresh expired history documents.\n\nThe Internet e-mail address in this field may be separate from the Internet host which issued the request. For example, when a request is passed through a proxy, the original issuer's address should be used.\n\nAn origin server must not send a Last-Modified date which is later than the server's time of message origination. In such cases, where the resource's last modification would indicate some time in the future, the server must replace that date with the message origination date.\n\nPragma directives must be passed through by a proxy or gateway application, regardless of their significance to that application, since the directives may be applicable to all recipients along the request/response chain. It is not possible to specify a pragma for a specific recipient; however, any pragma directive not relevant to a recipient should be ignored by that recipient.\n\nA user agent that wishes to authenticate itself with a server--usually, but not necessarily, after receiving a 401 response--may do so by including an header field with the request. The field value consists of containing the authentication information of the user agent for the realm of the resource being requested.\n\nIf the server does not wish to accept the credentials sent with a request, it should return a 403 (forbidden) response.\n\nThe HTTP protocol does not restrict applications to this simple challenge-response mechanism for access authentication. Additional mechanisms may be used, such as encryption at the transport level or via message encapsulation, and with additional header fields specifying authentication information. However, these additional mechanisms are not defined by this specification.\n\nProxies must be completely transparent regarding user agent authentication. That is, they must forward the and headers untouched, and must not cache the response to a request containing . HTTP/1.0 does not provide a means for a client to be authenticated with a proxy.\n\nUpon receipt of an unauthorized request for a URI within the protection space, the server should respond with a challenge like the following:\n\nTo receive authorization, the client sends the user-ID and password, separated by a single colon (\":\") character, within a base64 [5] encoded string in the .\n\nIn particular, the convention has been established that the and methods should never have the significance of taking an action other than retrieval. These methods should be considered \"safe.\" This allows user agents to represent other methods, such as , in a special way, so that the user is made aware of the fact that a possibly unsafe action is being requested.\n\nNaturally, it is not possible to ensure that the server does not generate side-effects as a result of performing a request; in fact, some dynamic resources consider that a feature. The important distinction here is that the user did not request the side-effects, so therefore cannot be held accountable for them.\n\nRevealing the specific software version of the server may allow the server machine to become more vulnerable to attacks against software that is known to contain security holes. Implementors should make the header field a configurable option.\n\nThe field allows reading patterns to be studied and reverse links drawn. Although it can be very useful, its power can be abused if user details are not separated from the information contained in the . Even when the personal information has been removed, the field may indicate a private document's URI whose publication would be inappropriate.\n\nThe information sent in the field might conflict with the user's privacy interests or their site's security policy, and hence it should not be transmitted without the user being able to disable, enable, and modify the contents of the field. The user must be able to set the contents of this field within a user preference or application defaults configuration.\n\nWe suggest, though do not require, that a convenient toggle interface be provided for the user to enable or disable the sending of and information.\n\nThe HTTP protocol has evolved considerably over the past four years. It has benefited from a large and active developer community--the many people who have participated on the www-talk mailing list--and it is that community which has been most responsible for the success of HTTP and of the World-Wide Web in general. Marc Andreessen, Robert Cailliau, Daniel W. Connolly, Bob Denny, Jean-Francois Groff, Phillip M. Hallam-Baker, H√•kon W. Lie, Ari Luotonen, Rob McCool, Lou Montulli, Dave Raggett, Tony Sanders, and Marc VanHeyningen deserve special recognition for their efforts in defining aspects of the protocol for early versions of this specification.\n\nPaul Hoffman contributed sections regarding the informational status of this document and Appendices C and D.\n\nThis document has benefited greatly from the comments of all those participating in the HTTP-WG. In addition to those already mentioned, the following individuals have contributed to this specification:\n\nRoy T. Fielding\n\n Department of Information and Computer Science\n\n University of California\n\n Irvine, CA 92717-3425, U.S.A.\n\n Fax: +1 (714) 824-4056\n\n Email: fielding@ics.uci.edu\n\nClients should be tolerant in parsing the and servers tolerant when parsing the . In particular, they should accept any amount of or characters between fields, even though only a single is required.\n\nThe line terminator for fields is the sequence . However, we recommend that applications, when parsing such headers, recognize a single as a line terminator and ignore the leading .\n\nAt the time of this writing, it is expected that RFC 1521 will be revised. The revisions may include some of the practices found in HTTP/1.0 but not in RFC 1521.\n\nThis appendix describes specific areas where HTTP differs from RFC 1521. Proxies and gateways to strict MIME environments should be aware of these differences and provide the appropriate conversions where necessary. Proxies and gateways from MIME environments to HTTP also need to be aware of the differences because some conversions may be required.\n\nRFC 1521 requires that content with a Content-Type of \"text\" represent line breaks as CRLF and forbids the use of CR or LF outside of line break sequences. HTTP allows CRLF, bare CR, and bare LF to indicate a line break within text content when a message is transmitted over HTTP.\n\nWhere it is possible, a proxy or gateway from HTTP to a strict RFC 1521 environment should translate all line breaks within the text media types described in Section 3.6.1 of this document to the RFC 1521 canonical form of . Note, however, that this may be complicated by the presence of a and by the fact that HTTP allows the use of some character sets which do not use octets 13 and 10 to represent and , as is the case for some multi-byte character sets.\n\nProxies and gateways from HTTP to MIME-compliant protocols are responsible for ensuring that the message is in the correct format and encoding for safe transport on that protocol, where \"safe transport\" is defined by the limitations of the protocol being used. Such a proxy or gateway should label the data with an appropriate Content-Transfer-Encoding if doing so will improve the likelihood of safe transport over the destination protocol.\n\nThe fundamental difference between the POST and PUT requests is reflected in the different meaning of the . The URI in a POST request identifies the resource that will handle the enclosed entity as data to be processed. That resource may be a data-accepting process, a gateway to some other protocol, or a separate entity that accepts annotations. In contrast, the URI in a PUT request identifies the entity enclosed with the request -- the user agent knows what URI is intended and the server should not apply the request to some other resource."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Overview",
        "document": "HTTP is a protocol for fetching resources such as HTML documents. It is the foundation of any data exchange on the Web and it is a client-server protocol, which means requests are initiated by the recipient, usually the Web browser. A complete document is typically constructed from resources such as text content, layout instructions, images, videos, scripts, and more. Clients and servers communicate by exchanging individual messages (as opposed to a stream of data). The messages sent by the client are called requests and the messages sent by the server as an answer are called responses. Designed in the early 1990s, HTTP is an extensible protocol which has evolved over time. It is an application layer protocol that is sent over TCP, or over a TLS-encrypted TCP connection, though any reliable transport protocol could theoretically be used. Due to its extensibility, it is used to not only fetch hypertext documents, but also images and videos or to post content to servers, like with HTML form results. HTTP can also be used to fetch parts of documents to update Web pages on demand.\n\nHTTP is a client-server protocol: requests are sent by one entity, the user-agent (or a proxy on behalf of it). Most of the time the user-agent is a Web browser, but it can be anything, for example, a robot that crawls the Web to populate and maintain a search engine index. Each individual request is sent to a server, which handles it and provides an answer called the response. Between the client and the server there are numerous entities, collectively called proxies, which perform different operations and act as gateways or caches, for example. In reality, there are more computers between a browser and the server handling the request: there are routers, modems, and more. Thanks to the layered design of the Web, these are hidden in the network and transport layers. HTTP is on top, at the application layer. Although important for diagnosing network problems, the underlying layers are mostly irrelevant to the description of HTTP.\n\nThe user-agent is any tool that acts on behalf of the user. This role is primarily performed by the Web browser, but it may also be performed by programs used by engineers and Web developers to debug their applications. The browser is always the entity initiating the request. It is never the server (though some mechanisms have been added over the years to simulate server-initiated messages). To display a Web page, the browser sends an original request to fetch the HTML document that represents the page. It then parses this file, making additional requests corresponding to execution scripts, layout information (CSS) to display, and sub-resources contained within the page (usually images and videos). The Web browser then combines these resources to present the complete document, the Web page. Scripts executed by the browser can fetch more resources in later phases and the browser updates the Web page accordingly. A Web page is a hypertext document. This means some parts of the displayed content are links, which can be activated (usually by a click of the mouse) to fetch a new Web page, allowing the user to direct their user-agent and navigate through the Web. The browser translates these directions into HTTP requests, and further interprets the HTTP responses to present the user with a clear response.\n\nBetween the Web browser and the server, numerous computers and machines relay the HTTP messages. Due to the layered structure of the Web stack, most of these operate at the transport, network or physical levels, becoming transparent at the HTTP layer and potentially having a significant impact on performance. Those operating at the application layers are generally called proxies. These can be transparent, forwarding on the requests they receive without altering them in any way, or non-transparent, in which case they will change the request in some way before passing it along to the server. Proxies may perform numerous functions:\n‚Ä¢ caching (the cache can be public or private, like the browser cache)\n‚Ä¢ filtering (like an antivirus scan or parental controls)\n‚Ä¢ load balancing (to allow multiple servers to serve different requests)\n‚Ä¢ authentication (to control access to different resources)\n\nA connection is controlled at the transport layer, and therefore fundamentally out of scope for HTTP. HTTP doesn't require the underlying transport protocol to be connection-based; it only requires it to be reliable, or not lose messages (at minimum, presenting an error in such cases). Among the two most common transport protocols on the Internet, TCP is reliable and UDP isn't. HTTP therefore relies on the TCP standard, which is connection-based. Before a client and server can exchange an HTTP request/response pair, they must establish a TCP connection, a process which requires several round-trips. The default behavior of HTTP/1.0 is to open a separate TCP connection for each HTTP request/response pair. This is less efficient than sharing a single TCP connection when multiple requests are sent in close succession. In order to mitigate this flaw, HTTP/1.1 introduced pipelining (which proved difficult to implement) and persistent connections: the underlying TCP connection can be partially controlled using the header. HTTP/2 went a step further by multiplexing messages over a single connection, helping keep the connection warm and more efficient. Experiments are in progress to design a better transport protocol more suited to HTTP. For example, Google is experimenting with QUIC which builds on UDP to provide a more reliable and efficient transport protocol.\n\nWhen a client wants to communicate with a server, either the final server or an intermediate proxy, it performs the following steps:\n‚Ä¢ Open a TCP connection: The TCP connection is used to send a request, or several, and receive an answer. The client may open a new connection, reuse an existing connection, or open several TCP connections to the servers.\n‚Ä¢ Send an HTTP message: HTTP messages (before HTTP/2) are human-readable. With HTTP/2, these messages are encapsulated in frames, making them impossible to read directly, but the principle remains the same. For example:\n‚Ä¢ Read the response sent by the server, such as: HTTP/1.1 200 OK Date: Sat, 09 Oct 2010 14:28:02 GMT Server: Apache Last-Modified: Tue, 01 Dec 2009 20:18:22 GMT ETag: \"51142bc1-7449-479b075b2891b\" Accept-Ranges: bytes Content-Length: 29769 Content-Type: text/html <!doctype html>‚Ä¶ (here come the 29769 bytes of the requested web page)\n‚Ä¢ Close or reuse the connection for further requests. If HTTP pipelining is activated, several requests can be sent without waiting for the first response to be fully received. HTTP pipelining has proven difficult to implement in existing networks, where old pieces of software coexist with modern versions. HTTP pipelining has been superseded in HTTP/2 with more robust multiplexing requests within a frame."
    },
    {
        "link": "https://datatracker.ietf.org/doc/html/rfc1945",
        "document": ""
    },
    {
        "link": "https://www2.cs.uh.edu/~gnawali/courses/cosc4377-s12/hw2/http.html",
        "document": "HTTP is the network protocol of the Web. It is both simple and powerful. Knowing HTTP enables you to write Web browsers, Web servers, automatic page downloaders, link-checkers, and other useful tools.\n\nThis tutorial explains the simple, English-based structure of HTTP communication, and teaches you the practical details of writing HTTP clients and servers. It assumes you know basic socket programming. HTTP is simple enough for a beginning sockets programmer, so this page might be a good followup to a sockets tutorial. This Sockets FAQ focuses on C, but the underlying concepts are language-independent.\n\nSince you're reading this, you probably already use CGI. If not, it makes sense to learn that first.\n\nThe whole tutorial is about 15 printed pages long, including examples. The first half explains basic HTTP 1.0, and the second half explains the new requirements and features of HTTP 1.1. This tutorial doesn't cover everything about HTTP; it explains the basic framework, how to comply with the requirements, and where to find out more when you need it. If you plan to use HTTP extensively, you should read the specification as well-- see the end of this document for more details.\n\nBefore getting started, understand the following two paragraphs:\n\nWriting HTTP or other network programs requires more care than programming for a single machine. Of course, you have to follow standards, or no one will understand you. But even more important is the burden you place on other machines. Write a bad program for your own machine, and you waste your own resources (CPU time, bandwidth, memory). Write a bad network program, and you waste other people's resources. Write a really bad network program, and you waste many thousands of people's resources at the same time. Sloppy and malicious network programming forces network standards to be modified, made safer but less efficient. So be careful, respectful, and cooperative, for everyone's sake. In particular, don't be tempted to write programs that automatically follow Web links (called robots or spiders) before you really know what you're doing. They can be useful, but a badly-written robot is one of the worst kinds of programs on the Web, blindly following a rapidly increasing number of links and quickly draining server resources. If you plan to write anything like a robot, please read more about them. There may already be a working program to do what you want. If you really need to write your own, read these guidelines. Definitely support the current Standard for Robot Exclusion, and stay tuned for further developments.\n\nOK, enough of that. Let's get started.\n‚Ä¢ Other HTTP Methods, Like HEAD and POST\n‚Ä¢ Being Tolerant of Others\n‚Ä¢ HTTP 1.1 Servers\n‚Ä¢ Supporting the GET and HEAD methods\n\nSeveral related topics are discussed on a \"footnotes\" page:\n‚Ä¢ Using GET to Submit Query or Form Data\n\nHTTP stands for Hypertext Transfer Protocol. It's the network protocol used to deliver virtually all files and other data (collectively called resources) on the World Wide Web, whether they're HTML files, image files, query results, or anything else. Usually, HTTP takes place through TCP/IP sockets (and this tutorial ignores other possibilities).\n\nA browser is an HTTP client because it sends requests to an HTTP server (Web server), which then sends responses back to the client. The standard (and default) port for HTTP servers to listen on is 80, though they can use any port.\n\nHTTP is used to transmit resources, not just files. A resource is some chunk of information that can be identified by a URL (it's the R in URL). The most common kind of resource is a file, but a resource may also be a dynamically-generated query result, the output of a CGI script, a document that is available in several languages, or something else.\n\nWhile learning HTTP, it may help to think of a resource as similar to a file, but more general. As a practical matter, almost all HTTP resources are currently either files or server-side script output.\n\nLike most network protocols, HTTP uses the client-server model: An HTTP client opens a connection and sends a request message to an HTTP server; the server then returns a response message, usually containing the resource that was requested. After delivering the response, the server closes the connection (making HTTP a stateless protocol, i.e. not maintaining any connection information between transactions).\n\nThe format of the request and response messages are similar, and English-oriented. Both kinds of messages consist of:\n‚Ä¢ zero or more header lines,\n‚Ä¢ a blank line (i.e. a CRLF by itself), and\n‚Ä¢ an optional message body (e.g. a file, or query data, or query output).\n\nPut another way, the format of an HTTP message is:\n\nInitial lines and headers should end in CRLF, though you should gracefully handle lines ending in just LF. (More exactly, CR and LF here mean ASCII values 13 and 10, even though some platforms may use different characters.)\n\nThe initial line is different for the request than for the response. A request line has three parts, separated by spaces: a method name, the local path of the requested resource, and the version of HTTP being used. A typical request line is:\n‚Ä¢ GET is the most common HTTP method; it says \"give me this resource\". Other methods include POST and HEAD-- more on those later. Method names are always uppercase.\n‚Ä¢ The path is the part of the URL after the host name, also called the request URI (a URI is like a URL, but more general).\n‚Ä¢ The HTTP version always takes the form \"HTTP/x.x\", uppercase.\n\nThe initial response line, called the status line, also has three parts separated by spaces: the HTTP version, a response status code that gives the result of the request, and an English reason phrase describing the status code. Typical status lines are:\n‚Ä¢ The HTTP version is in the same format as in the request line, \"HTTP/x.x\".\n‚Ä¢ The status code is meant to be computer-readable; the reason phrase is meant to be human-readable, and may vary.\n‚Ä¢ The status code is a three-digit integer, and the first digit identifies the general category of response:\n‚Ä¢ 1xx indicates an informational message only\n‚Ä¢ 2xx indicates success of some kind\n‚Ä¢ 3xx redirects the client to another URL\n‚Ä¢ 4xx indicates an error on the client's part\n‚Ä¢ 5xx indicates an error on the server's part\n\nA complete list of status codes is in the HTTP specification (section 9 for HTTP 1.0, and section 10 for HTTP 1.1).\n\nHeader lines provide information about the request or response, or about the object sent in the message body.\n\nThe header lines are in the usual text header format, which is: one line per header, of the form \" \", ending with CRLF. It's the same format used for email and news postings, defined in RFC 822, section 3. Details about RFC 822 header lines:\n‚Ä¢ As noted above, they should end in CRLF, but you should handle LF correctly.\n‚Ä¢ The header name is not case-sensitive (though the value may be).\n‚Ä¢ Any number of spaces or tabs may be between the \":\" and the value.\n‚Ä¢ Header lines beginning with space or tab are actually part of the previous header line, folded into multiple lines for easy reading.\n\nThus, the following two headers are equivalent:\n\nHTTP 1.0 defines 16 headers, though none are required. HTTP 1.1 defines 46 headers, and one ( ) is required in requests. For Net-politeness, consider including these headers in your requests:\n‚Ä¢ The header gives the email address of whoever's making the request, or running the program doing so. (This must be user-configurable, for privacy concerns.)\n‚Ä¢ The header identifies the program that's making the request, in the form \"Program-name/x.xx\", where x.xx is the (mostly) alphanumeric version of the program. For example, Netscape 3.0 sends the header \" \".\n\nThese headers help webmasters troubleshoot problems. They also reveal information about the user. When you decide which headers to include, you must balance the webmasters' logging needs against your users' needs for privacy.\n\nIf you're writing servers, consider including these headers in your responses:\n‚Ä¢ The header is analogous to the header: it identifies the server software in the form \"Program-name/x.xx\". For example, one beta version of Apache's server returns \" \".\n‚Ä¢ The header gives the modification date of the resource that's being returned. It's used in caching and other bandwidth-saving activities. Use Greenwich Mean Time, in the format\n\nAn HTTP message may have a body of data sent after the header lines. In a response, this is where the requested resource is returned to the client (the most common use of the message body), or perhaps explanatory text if there's an error. In a request, this is where user-entered data or uploaded files are sent to the server.\n\nIf an HTTP message includes a body, there are usually header lines in the message that describe the body. In particular,\n‚Ä¢ The header gives the MIME-type of the data in the body, such as or .\n‚Ä¢ The header gives the number of bytes in the body.\n\nTo retrieve the file at the URL\n\nfirst open a socket to the host www.somehost.com, port 80 (use the default port of 80 because none is specified in the URL). Then, send something like the following through the socket:\n\nThe server should respond with something like the following, sent back through the same socket:\n\nTo familiarize yourself with requests and responses, manually experiment with HTTP using telnet.\n\nOther HTTP Methods, Like HEAD and POST\n\nBesides GET, the two most commonly used methods are HEAD and POST.\n\nA HEAD request is just like a GET request, except it asks the server to return the response headers only, and not the actual resource (i.e. no message body). This is useful to check characteristics of a resource without actually downloading it, thus saving bandwidth. Use HEAD when you don't actually need a file's contents.\n\nThe response to a HEAD request must never contain a message body, just the status line and headers.\n\nA POST request is used to send data to the server to be processed in some way, like by a CGI script. A POST request is different from a GET request in the following ways:\n‚Ä¢ There's a block of data sent with the request, in the message body. There are usually extra headers to describe this message body, like and .\n‚Ä¢ The request URI is not a resource to retrieve; it's usually a program to handle the data you're sending.\n‚Ä¢ The HTTP response is normally program output, not a static file.\n\nThe most common use of POST, by far, is to submit HTML form data to CGI scripts. In this case, the header is usually , and the header gives the length of the URL-encoded form data (here's a note on URL-encoding). The CGI script receives the message body through STDIN, and decodes it. Here's a typical form submission, using POST:\n\nYou can use a POST request to send whatever data you want, not just form submissions. Just make sure the sender and the receiving program agree on the format.\n\nThe GET method can also be used to submit forms. The form data is URL-encoded and appended to the request URI. Here are more details.\n\nIf you're writing HTTP servers that support CGI scripts, you should read the NCSA's CGI definition if you haven't already, especially which environment variables you need to pass to the scripts.\n\nAn HTTP proxy is a program that acts as an intermediary between a client and a server. It receives requests from clients, and forwards those requests to the intended servers. The responses pass back through it in the same way. Thus, a proxy has functions of both a client and a server.\n\nProxies are commonly used in firewalls, for LAN-wide caches, or in other situations. If you're writing proxies, read the HTTP specification; it contains details about proxies not covered in this tutorial.\n\nWhen a client uses a proxy, it typically sends all requests to that proxy, instead of to the servers in the URLs. Requests to a proxy differ from normal requests in one way: in the first line, they use the complete URL of the resource being requested, instead of just the path. For example,\n\nThat way, the proxy knows which server to forward the request to (though the proxy itself may use another proxy).\n\nBeing Tolerant of Others\n\nAs the saying goes (in network programming, anyway), \"Be strict in what you send and tolerant in what you receive.\" Other clients and servers you interact with may have minor flaws in their messages, but you should try to work gracefully with them. In particular, the HTTP specification suggests the following:\n‚Ä¢ Even though header lines should end with CRLF, someone might use a single LF instead. Accept either CRLF or LF.\n‚Ä¢ The three fields in the initial message line should be separated by a single space, but might instead use several spaces, or tabs. Accept any number of spaces or tabs between these fields.\n\nThe specification has other suggestions too, like how to handle varying date formats. If your program interprets dates from other programs, read the \"Tolerant Applications\" section of the specification.\n\nThat's the basic structure of HTTP. If you understand everything so far, you have a good overview of HTTP communication, and should be able to write simple HTTP 1.0 programs. See this example to get started. Again, before you do anything heavy-duty, read the specification. The rest of this document tells how to upgrade your clients and servers to use HTTP 1.1. There is a list of new client requirements, and a list of new server requirements. You can stop here if HTTP 1.0 satisfies your current needs (though you'll probably need HTTP 1.1 in the future). Note: As of early 1997, the Web is moving from HTTP 1.0 to HTTP 1.1. Whenever practical, use HTTP 1.1. It's more efficient overall, and by using it, you'll help the Web perform better for everyone. Like many protocols, HTTP is constantly evolving. HTTP 1.1 has recently been defined, to address new needs and overcome shortcomings of HTTP 1.0. Generally speaking, it is a superset of HTTP 1.0. Improvements include:\n‚Ä¢ Faster response, by allowing multiple transactions to take place over a single persistent connection.\n‚Ä¢ Faster response for dynamically-generated pages, by supporting chunked encoding, which allows a response to be sent before its total length is known.\n‚Ä¢ Efficient use of IP addresses, by allowing multiple domains to be served from a single IP address. HTTP 1.1 requires a few extra things from both clients and servers. The next two sections detail how to make clients and servers comply with HTTP 1.1. If you're only writing clients, you can skip the section on servers. If you're writing servers, read both sections. Only requirements for HTTP 1.1 compliance are described here. HTTP 1.1 has many optional features you may find useful; read the specification to learn more. To comply with HTTP 1.1, clients must\n‚Ä¢ include the header with each request\n‚Ä¢ either support persistent connections, or include the \" \" header with each request Starting with HTTP 1.1, one server at one IP address can be multi-homed, i.e. the home of several Web domains. For example, \"www.host1.com\" and \"www.host2.com\" can live on the same server. Several domains living on the same server is like several people sharing one phone: a caller knows who they're calling for, but whoever answers the phone doesn't. Thus, every HTTP request must specify which host name (and possibly port) the request is intended for, with the header. A complete HTTP 1.1 request might be except the \" \" isn't required, since that's the default HTTP port. is the only required header in an HTTP 1.1 request. It's also the most urgently needed new feature in HTTP 1.1. Without it, each host name requires a unique IP address, and we're quickly running out of IP addresses with the explosion of new domains. If a server wants to start sending a response before knowing its total length (like with long script output), it might use the simple chunked transfer-encoding, which breaks the complete response into smaller chunks and sends them in series. You can identify such a response because it contains the \" \" header. All HTTP 1.1 clients must be able to receive chunked messages. A chunked message body contains a series of chunks, followed by a line with \"0\" (zero), followed by optional footers (just like headers), and a blank line. Each chunk consists of two parts:\n‚Ä¢ a line with the size of the chunk data, in hex, possibly followed by a semicolon and extra parameters you can ignore (none are currently standard), and ending with CRLF.\n‚Ä¢ the data itself, followed by CRLF. So a chunked response might look like the following: Note the blank line after the last footer. The length of the text data is 42 bytes (1a + 10, in hex), and the data itself is abcdefghijklmnopqrstuvwxyz1234567890abcdef. The footers should be treated like headers, as if they were at the top of the response. The chunks can contain any binary data, and may be much larger than the examples here. The size-line parameters are rarely used, but you should at least ignore them correctly. Footers are also rare, but might be appropriate for things like checksums or digital signatures. For comparison, here's the equivalent to the above response, without using chunked encoding: In HTTP 1.0 and before, TCP connections are closed after each request and response, so each resource to be retrieved requires its own connection. Opening and closing TCP connections takes a substantial amount of CPU time, bandwidth, and memory. In practice, most Web pages consist of several files on the same server, so much can be saved by allowing several requests and responses to be sent through a single persistent connection. Persistent connections are the default in HTTP 1.1, so nothing special is required to use them. Just open a connection and send several requests in series (called pipelining), and read the responses in the same order as the requests were sent. If you do this, be very careful to read the correct length of each response, to separate them correctly. If a client includes the \" \" header in the request, then the connection will be closed after the corresponding response. Use this if you don't support persistent connections, or if you know a request will be the last on its connection. Similarly, if a response contains this header, then the server will close the connection following that response, and the client shouldn't send any more requests through that connection. A server might close the connection before all responses are sent, so a client must keep track of requests and resend them as needed. When resending, don't pipeline the requests until you know the connection is persistent. Don't pipeline at all if you know the server won't support persistent connections (like if it uses HTTP 1.0, based on a previous response). During the course of an HTTP 1.1 client sending a request to a server, the server might respond with an interim \" \" response. This means the server has received the first part of the request, and can be used to aid communication over slow links. In any case, all HTTP 1.1 clients must handle the 100 response correctly (perhaps by just ignoring it). The \" \" response is structured like any HTTP response, i.e. consists of a status line, optional headers, and a blank line. Unlike other responses, it is always followed by another complete, final response. So, further extending the last example, the full data that comes back from the server might consist of two responses in series, like To handle this, a simple HTTP 1.1 client might read one response from the socket; if the status code is 100, discard the first response and read the next one instead. To comply with HTTP 1.1, servers must:\n‚Ä¢ either support persistent connections, or include the \" \" header with each response\n‚Ä¢ include the header in each response\n‚Ä¢ support at least the GET and HEAD methods Because of the urgency of implementing the new header, servers are not allowed to tolerate HTTP 1.1 requests without it. If a server receives such a request, it must return a \" \" response, like This requirement applies only to clients using HTTP 1.1, not any future version of HTTP. If the request uses an HTTP version later than 1.1, the server can accept an absolute URL instead of a header (see next section). If the request uses HTTP 1.0, the server may accept the request without any host identification. The header is actually an interim solution to the problem of host identification. In future versions of HTTP, requests will use an absolute URL instead of a pathname, like To enable this protocol transition, HTTP 1.1 servers must accept this form of request, even though HTTP 1.1 clients won't send them. The server must still report an error if an HTTP 1.1 client leaves out the header, as described in the previous section. Just as HTTP 1.1 clients must accept chunked responses, servers must accept chunked requests (an unlikely scenario, but possible). See the earlier section on HTTP 1.1 Clients for details of the chunked data format. Servers aren't required to generate chunked messages; they just have to be able to receive them. If an HTTP 1.1 client sends multiple requests through a single connection, the server should send responses back in the same order as the requests-- this is all it takes for a server to support persistent connections. If a request includes the \" \" header, that request is the final one for the connection and the server should close the connection after sending the response. Also, the server should close an idle connection after some timeout period (can be anything; 10 seconds is fine). If you don't want to support persistent connections, include the \" \" header in the response. Use this header whenever you want to close the connection, even if not all requests have been fulfilled. The header says that the connection will be closed after the current response, and a valid HTTP 1.1 client will handle it correctly. As described in the section on HTTP 1.1 Clients, this response exists to help deal with slow links. When an HTTP 1.1 server receives the first line of an HTTP 1.1 (or later) request, it must respond with either \" \" or an error. If it sends the \" \" response, it must also send another, final response, once the request has been processed. The \" \" response requires no headers, but must be followed by the usual blank line, like: HTTP/1.1 100 Continue [blank line here] [another HTTP response will go here] Don't send \" \" to HTTP 1.0 clients, since they don't know how to handle it. Caching is an important improvement in HTTP 1.1, and can't work without timestamped responses. So, servers must timestamp every response with a header containing the current time, in the form All responses except those with 100-level status (but including error responses) must include the header. All time values in HTTP use Greenwich Mean Time. To avoid sending resources that don't need to be sent, thus saving bandwidth, HTTP 1.1 defines the and request headers. The former says \"only send the resource if it has changed since this date\"; the latter says the opposite. Clients aren't required to use them, but HTTP 1.1 servers are required to honor requests that do use them. Unfortunately, due to earlier HTTP versions, the date value may be in any of three possible formats: Again, all time values in HTTP use Greenwich Mean Time (though try to be tolerant of non-GMT times). If a date with a two-digit year seems to be more than 50 years in the future, treat it as being in the past-- this helps with the millennium bug. In fact, do this with any date handling in HTTP 1.1. Although servers must accept all three date formats, HTTP 1.1 clients and servers must only generate the first kind. If the date in either of these headers is invalid, or is in the future, ignore the header. If, without the header, the request would result in an unsuccessful (non-200-level) status code, ignore the header and send the non-200-level response. In other words, only apply these headers when you know the resource would otherwise be sent. The header is used with a GET request. If the requested resource has been modified since the given date, ignore the header and return the resource as you normally would. Otherwise, return a \" \" response, including the header and no message body, like The header is similar, but can be used with any method. If the requested resource has not been modified since the given date, ignore the header and return the resource as you normally would. Otherwise, return a \" \" response, like Supporting the GET and HEAD methods To comply with HTTP 1.1, a server must support at least the GET and HEAD methods. If you're handling CGI scripts, you should probably support the POST method too. Four other methods (PUT, DELETE, OPTIONS, and TRACE) are defined in HTTP 1.1, but are rarely used. If a client requests a method you don't support, respond with \" \", like To be compatible with older browsers, HTTP 1.1 servers must support HTTP 1.0 requests. In particular, when a request uses HTTP 1.0 (as identified in the initial request line), If you plan to do anything elaborate in HTTP, read the official specification. HTTP 1.0 was never made an official Internet standard, but the de facto standard is described in RFC 1945. HTTP 1.1 was developed by a working group of the IETF, openly gathering input from many sources before reaching an approximate consensus. The resulting specification is RFC 2616, released in June 1999. These documents are available in various formats: Download and print the version you'll be using, for reference and bedtime reading. The World Wide Web Consortium has a page devoted to HTTP including news and updates, and a page listing HTTP specifications, drafts, and reports. Other RFC's you might find useful:\n‚Ä¢ RFC 1521-- definition of MIME and of MIME types ¬© 1997 James Marshall (comments welcome)"
    }
]