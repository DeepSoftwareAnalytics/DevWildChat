[
    {
        "link": "https://learn.microsoft.com/en-us/cpp/cpp/errors-and-exception-handling-modern-cpp?view=msvc-170",
        "document": "Modern C++ best practices for exceptions and error handling\n\nIn modern C++, in most scenarios, the preferred way to report and handle both logic errors and runtime errors is to use exceptions. It's especially true when the stack might contain several function calls between the function that detects the error, and the function that has the context to handle the error. Exceptions provide a formal, well-defined way for code that detects errors to pass the information up the call stack.\n\nProgram errors are often divided into two categories:\n• Logic errors caused by programming mistakes. For example, an \"index out of range\" error.\n• Runtime errors that are beyond the control of programmer. For example, a \"network service unavailable\" error.\n\nIn C-style programming and in COM, error reporting is managed either by returning a value that represents an error code or a status code for a particular function, or by setting a global variable that the caller may optionally retrieve after every function call to see whether errors were reported. For example, COM programming uses the return value to communicate errors to the caller. And the Win32 API has the function to retrieve the last error reported by the call stack. In both of these cases, it's up to the caller to recognize the code and respond to it appropriately. If the caller doesn't explicitly handle the error code, the program might crash without warning. Or, it might continue to execute using bad data and produce incorrect results.\n\nExceptions are preferred in modern C++ for the following reasons:\n• An exception forces calling code to recognize an error condition and handle it. Unhandled exceptions stop program execution.\n• An exception jumps to the point in the call stack that can handle the error. Intermediate functions can let the exception propagate. They don't have to coordinate with other layers.\n• The exception stack-unwinding mechanism destroys all objects in scope after an exception is thrown, according to well-defined rules.\n• An exception enables a clean separation between the code that detects the error and the code that handles the error.\n\nThe following simplified example shows the necessary syntax for throwing and catching exceptions in C++:\n\nExceptions in C++ resemble ones in languages such as C# and Java. In the block, if an exception is thrown it is caught by the first associated block whose type matches that of the exception. In other words, execution jumps from the statement to the statement. If no usable catch block is found, is invoked and the program exits. In C++, any type may be thrown; however, we recommend that you throw a type that derives directly or indirectly from . In the previous example, the exception type, , is defined in the standard library in the header file. C++ doesn't provide or require a block to make sure all resources are released if an exception is thrown. The resource acquisition is initialization (RAII) idiom, which uses smart pointers, provides the required functionality for resource cleanup. For more information, see How to: Design for exception safety. For information about the C++ stack-unwinding mechanism, see Exceptions and stack unwinding.\n\nRobust error handling is challenging in any programming language. Although exceptions provide several features that support good error handling, they can't do all the work for you. To realize the benefits of the exception mechanism, keep exceptions in mind as you design your code.\n• Use asserts to check for conditions that should always be true or always be false. Use exceptions to check for errors that might occur, for example, errors in input validation on parameters of public functions. For more information, see the Exceptions versus assertions section.\n• Use exceptions when the code that handles the error is separated from the code that detects the error by one or more intervening function calls. Consider whether to use error codes instead in performance-critical loops, when code that handles the error is tightly coupled to the code that detects it.\n• For every function that might throw or propagate an exception, provide one of the three exception guarantees: the strong guarantee, the basic guarantee, or the nothrow ( ) guarantee. For more information, see How to: Design for exception safety.\n• Throw exceptions by value, catch them by reference. Don't catch what you can't handle.\n• Don't use exception specifications, which are deprecated in C++11. For more information, see the Exception specifications and section.\n• Use standard library exception types when they apply. Derive custom exception types from the Class hierarchy.\n• Don't allow exceptions to escape from destructors or memory-deallocation functions.\n\nThe exception mechanism has a minimal performance cost if no exception is thrown. If an exception is thrown, the cost of the stack traversal and unwinding is roughly comparable to the cost of a function call. Other data structures are required to track the call stack after a block is entered, and more instructions are required to unwind the stack if an exception is thrown. However, in most scenarios, the cost in performance and memory footprint isn't significant. The adverse effect of exceptions on performance is likely to be significant only on memory-constrained systems. Or, in performance-critical loops, where an error is likely to occur regularly and there's tight coupling between the code to handle it and the code that reports it. In any case, it's impossible to know the actual cost of exceptions without profiling and measuring. Even in those rare cases when the cost is significant, you can weigh it against the increased correctness, easier maintainability, and other advantages that are provided by a well-designed exception policy.\n\nExceptions and asserts are two distinct mechanisms for detecting run-time errors in a program. Use statements to test for conditions during development that should always be true or always be false if all your code is correct. There's no point in handling such an error by using an exception, because the error indicates that something in the code has to be fixed. It doesn't represent a condition that the program has to recover from at run time. An stops execution at the statement so that you can inspect the program state in the debugger. An exception continues execution from the first appropriate catch handler. Use exceptions to check error conditions that might occur at run time even if your code is correct, for example, \"file not found\" or \"out of memory.\" Exceptions can handle these conditions, even if the recovery just outputs a message to a log and ends the program. Always check arguments to public functions by using exceptions. Even if your function is error-free, you might not have complete control over arguments that a user might pass to it.\n\nBoth C and C++ programs can use the structured exception handling (SEH) mechanism in the Windows operating system. The concepts in SEH resemble the ones in C++ exceptions, except that SEH uses the , , and constructs instead of and . In the Microsoft C++ compiler (MSVC), C++ exceptions are implemented for SEH. However, when you write C++ code, use the C++ exception syntax.\n\nFor more information about SEH, see Structured Exception Handling (C/C++).\n\nException specifications were introduced in C++ as a way to specify the exceptions that a function might throw. However, exception specifications proved problematic in practice, and are deprecated in the C++11 draft standard. We recommend that you don't use exception specifications except for , which indicates that the function allows no exceptions to escape. If you must use exception specifications of the deprecated form , MSVC support is limited. For more information, see Exception Specifications (throw). The specifier is introduced in C++11 as the preferred alternative to .\n\nHow to: Interface between exceptional and non-exceptional code\n\n C++ language reference\n\n C++ Standard Library"
    },
    {
        "link": "https://stackoverflow.com/questions/9387377/how-to-design-exception-types-in-c",
        "document": "The C++ standard library’s exception hierarchy is IMHO pretty arbitrary and meaningless. For example, it would probably just create problems if anyone started actually using e.g. instead of terminating when it’s clear that the program has a Very Nasty Bug™. For as the standard puts it,\n\nThus, at the point where it might otherwise seem reasonable to throw a the program state might be unpredictably fouled up, and continued execution might put the user’s data in harm’s way.\n\nStill, like the standard exception class hierarchy has a really really practically important and useful feature, namely that it’s formally standard.\n\nSo any custom exception class should be derived indirectly or (although I would not recommend it) directly from .\n\nGenerally, when the debates about custom exception classes raged ten years ago, I recommended deriving only from , and I still recommend that. It is the standard exception class that supports custom messages (the others generally have hardcoded messages that one preferably should not change, since they have value in being recognizable). And one might argue that is the standard exception class that represents recoverable failures (as opposed to unrecoverable logic errors, which can’t be fixed at run time), or as the standard puts it,\n\nSometimes the C++ exception mechanism is used for other things, treated as just a low-level dynamic destination jump mechanism. For example, clever code can use exceptions for propagating a successful result out of a chain of recursive calls. But exception-as-failure is the most common usage, and that’s what C++ exceptions are typically optimized for, so mostly it makes sense to use as root for any custom exception class hierarchy – even if that forces someone who wants to be clever, to throw a “failure”-indicating exception to indicate success…\n\nWorth noting: there are three standard subclasses of , namely , and , and that contrary to what their names indicate the latter two are not required to be be generated by floating point operations and are not in practice generated by floating point operations, but are AFAIK only generated by some – surprise! – operations. Simply put, the standard library’s exception class hierarchy seems to me to have been thrown in there just for apperance’s sake, without any real good reasons or existing practice, and even without a does-it-make-sense check. But maybe I missed out on that and if so, then I still have something new to learn about this. :-)\n\nSo, it is, then.\n\nAt the top of a hierarchy of custom exception classes, with C++03 it was useful to add in the important stuff missing from C++03 standard exceptions:\n• None Virtual method (especially important for passing exceptions through C code).\n• None Virtual method (same main reason as for cloning).\n• None Support for carrying a failure cause code (like e.g. Windows or Posix error code).\n• None Support for getting a standard message from a carried failure cause code.\n\nC++11 added support for much of this, but except for trying out the new support for failure cause codes and messages, and noting that unfortunately it’s pretty Unix-specific and not very suitable for Windows, I haven’t yet used it. Anyway, for completeness: instead of adding cloning and virtual rethrowing (which is the best that an ordinary application programmer can do in a custom exception class hierarchy, because as an application programmer you cannot hoist a current exception object out of the storage that the implementation’s exception propagation uses), the C++11 standard adds free functions and , and instead of support for chained exception messages it adds a mixin class and free functions and .\n\nGiven the partial C++11 support for the above bullet points, a new and modern custom exception class hierarchy should better integrate with the C++11 support instead of addressing the C++03 shortcomings. Well, except for the C++11 failure code thing, which seems to be very unsuitable for Windows programming. So, at the top of the custom hierarchy, right under , there will ideally be at least one general exception class, and derived from that, one exception class that supports propagation of failure codes.\n\nNow, finally, to the gist of the question: should one now best derive a unique exception class for every possible failure cause, or at least for major failure causes?\n\nIf or where it is can be useful for a caller to distinguish a certain failure cause, a distinct exception class for that is very useful. But in most cases the only information of interest to a caller is the single fact that an exception has occurred. It is very rare that different failure causes lead to different attempted fixes.\n\nBut what about failure cause codes?\n\nWell, when that's what an underlying API gives you, it is just added work to create corresponding exception classes. But on the other hand, when you are communicating failure up in a call chain, and the caller might need to know the exact cause, then using a code for that means the caller will have to use some nested checking and dispatch inside the . So these are different situations: (A) your code is the original source of a failure indication, versus (B) your code uses e.g. a Windows or Posix API function that fails and that that indicates failure cause via a failure cause code."
    },
    {
        "link": "https://softwareengineering.stackexchange.com/questions/430984/what-are-the-best-practices-when-implementing-c-error-handling",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://stackoverflow.com/questions/41753358/creating-custom-exceptions-in-c",
        "document": "I am learning C++ and I am experiencing when I try and create my own exception and throw them on Linux.\n\nI've created a small test project to test my implementation and below is my exception class header file.\n\nThe source file for the exception class is\n\nIn my main app, I am calling a function which throws my exception and catches it in a try/catch as follows:\n\nWhen I run I'm expecting to get the following output:\n\nGoing to run now. oh dear I need to throw an exception Exception Caught: This is my exception error. :(\n\nInstead what I am getting is\n\nNotice the last line it says std::exception instead of my actual exception message \"This is my exception error\".\n\nWhy is this, it works OK on Windows but on Linux it does this.\n\nFrom what I've seen on various posts what I've done is correct so what am I missing."
    },
    {
        "link": "https://isocpp.org/wiki/faq/exceptions",
        "document": "What good can using exceptions do for me? The basic answer is: Using exceptions for error handling makes your code simpler, cleaner, and less likely to miss errors. But what’s wrong with “good old and -statements”? The basic answer is: Using those, your error handling and your normal code are closely intertwined. That way, your code gets messy and it becomes hard to ensure that you have dealt with all errors (think “spaghetti code” or a “rat’s nest of tests”).\n\nFirst of all there are things that just can’t be done right without exceptions. Consider an error detected in a constructor; how do you report the error? You throw an exception. That’s the basis of RAII (Resource Acquisition Is Initialization), which is the basis of some of the most effective modern C++ design techniques: A constructor’s job is to establish the invariants for the class (create the environment in which the member functions are to run) and that often requires the acquisition of resources, such as memory, locks, files, sockets, etc.\n\nImagine that we did not have exceptions, how would you deal with an error detected in a constructor? Remember that constructors are often invoked to initialize/construct objects in variables:\n\nThe or (output file stream) constructor could either set the variable into a “bad” state (as does by default) so that every subsequent operation fails. That’s not ideal. For example, in the case of , your output simply disappears if you forget to check that the open operation succeeded. For most classes that results are worse. At least, we would have to write:\n\nThat’s an extra test per object (to write, to remember or forget). This gets really messy for classes composed of several objects, especially if those sub-objects depend on each other. For more information see The C++ Programming Language section 8.3, Chapter 14, and Appendix E or the (more academic) paper Exception safety: Concepts and techniques.\n\nSo writing constructors can be tricky without exceptions, but what about plain old functions? We can either return an error code or set a non-local variable (e.g., ). Setting a global variable doesn’t work too well unless you test it immediately (or some other function might have re-set it). Don’t even think of that technique if you might have multiple threads accessing the global variable. The trouble with return values are that choosing the error return value can require cleverness and can be impossible:\n\nThere is no possible value for to return: Every possible is the correct answer for some and there is no correct answer for the most negative number in the twos-complement representation. In such cases, we would need to return pairs of values (and as usual remember to test) See Stroustrup’s Beginning programming book for more examples and explanations.\n\nCommon objections to the use of exceptions:\n• “But exceptions are expensive!” Not really. Modern C++ implementations reduce the overhead of using exceptions to a few percent (say, 3%) and that’s compared to no error handling. Writing code with error-return codes and tests is not free either. As a rule of thumb, exception handling is extremely cheap when you don’t throw an exception. It costs nothing on some implementations. All the cost is incurred when you throw an exception: that is, “normal code” is faster than code using error-return codes and tests. You incur cost only when you have an error.\n• “But in JSF++ Stroustrup himself bans exceptions outright!” JSF++ is for hard-real time and safety-critical applications (flight control software). If a computation takes too long someone may die. For that reason, we have to guarantee response times, and we can’t – with the current level of tool support – do that for exceptions. In that context, even free store allocation is banned! Actually, the JSF++ recommendations for error handling simulate the use of exceptions in anticipation of the day where we have the tools to do things right, i.e. using exceptions.\n• “But throwing an exception from a constructor invoked by causes a memory leak!” Nonsense! That’s an old-wives’ tale caused by a bug in one compiler – and that bug was immediately fixed over a decade ago.\n\nHow do I use exceptions?\n\nSee The C++ Programming Language section 8.3, Chapter 14, and Appendix E. The appendix focuses on techniques for writing exception-safe code in demanding applications, and is not written for novices.\n\nIn C++, exceptions are used to signal errors that cannot be handled locally, such as the failure to acquire a resource in a constructor. For example:\n\nDo not use exceptions as simply another way to return a value from a function. Most users assume – as the language definition encourages them to – that ** exception-handling code is error-handling code **, and implementations are optimized to reflect that assumption.\n\nA key technique is resource acquisition is initialization (sometimes abbreviated to RAII), which uses classes with destructors to impose order on resource management. For example:\n\nIf the “use f” part of fct() throws an exception, the destructor is still invoked and the file is properly closed. This contrasts to the common unsafe usage:\n\nIf the “use ” part of throws an exception – or simply does a return – the file isn’t closed. In C programs, is an additional hazard.\n\nWhat shouldn’t I use exceptions for?\n\nC++ exceptions are designed to support error handling.\n• Use only to signal an error (which means specifically that the function couldn’t do what it advertised, and establish its postconditions).\n• Use only to specify error handling actions when you know you can handle an error (possibly by translating it to another type and rethrowing an exception of that type, such as catching a and rethrowing a ).\n• Do not use to indicate a coding error in usage of a function. Use assert or other mechanism to either send the process into a debugger or to crash the process and collect the crash dump for the developer to debug.\n• Do not use if you discover unexpected violation of an invariant of your component, use assert or other mechanism to terminate the program. Throwing an exception will not cure memory corruption and may lead to further corruption of important user data.\n\nThere are other uses of exceptions – popular in other languages – but not idiomatic in C++ and deliberately not supported well by C++ implementations (those implementations are optimized based on the assumption that exceptions are used for error handling).\n\nIn particular, do not use exceptions for control flow. is not simply an alternative way of returning a value from a function (similar to ). Doing so will be slow and will confuse most C++ programmers who are rightly used to seeing exceptions used only for error handling. Similarly, is not a good way of getting out of a loop.\n\nWhat are some ways / / can improve software quality?\n\nBy eliminating one of the reasons for statements.\n\nThe commonly used alternative to / / is to return a return code (sometimes called an error code) that the caller explicitly tests via some conditional statement such as . For example, , and work this way: the caller is supposed to test the return value to see if the function succeeded.\n\nAlthough the return code technique is sometimes the most appropriate error handling technique, there are some nasty side effects to adding unnecessary statements:\n• Degrade quality: It is well known that conditional statements are approximately ten times more likely to contain errors than any other kind of statement. So all other things being equal, if you can eliminate conditionals / conditional statements from your code, you will likely have more robust code.\n• Slow down time-to-market: Since conditional statements are branch points which are related to the number of test cases that are needed for white-box testing, unnecessary conditional statements increase the amount of time that needs to be devoted to testing. Basically if you don’t exercise every branch point, there will be instructions in your code that will never have been executed under test conditions until they are seen by your users/customers. That’s bad.\n• Increase development cost: Bug finding, bug fixing, and testing are all increased by unnecessary control flow complexity.\n\nSo compared to error reporting via return-codes and , using / / is likely to result in code that has fewer bugs, is less expensive to develop, and has faster time-to-market. Of course if your organization doesn’t have any experiential knowledge of / / , you might want to use it on a toy project first just to make sure you know what you’re doing — you should always get used to a weapon on the firing range before you bring it to the front lines of a shooting war.\n\nI’m still not convinced: a 4-line code snippet shows that return-codes aren’t any worse than exceptions; why should I therefore use exceptions on an application that is orders of magnitude larger?\n\nBecause exceptions scale better than return-codes.\n\nThe problem with a 4-line example is that it has only 4 lines. Give it 4,000 lines and you’ll see the difference.\n\nHere’s a classic 4-line example, first with exceptions:\n\nHere’s the same example, this time using return-codes ( stands for “return code”):\n\nPeople point to those “toy” examples and say, “Exceptions don’t improve coding or testing or maintenance cost in that; why should I therefore use them in a ‘real’ project?”\n\nReason: exceptions help you with real-world applications. You won’t likely see much if any benefit on a toy example.\n\nIn the real world, the code that detects a problem must typically propagate error information back to a different function that will handle the problem. This “error propagation” often needs to go through dozens of functions — calls calls , etc., and a problem is discovered way down in (or ). The information about the problem needs to get propagated all the way back to , because only has enough context to actually know what should be done about the problem. In an interactive app, is typically up near the main event loop, but no matter what, the code that detects the problem often isn’t the same as the code that handles the problem, and the error information needs to get propagated through all the stack frames in between.\n\nExceptions make it easy to do this “error propagation”:\n\nOnly the code that detects the error, , and the code that handles the error, , have any clutter.\n\nHowever using return-codes forces “error propagation clutter” into all the functions in between those two. Here is the equivalent code that uses return codes:\n\nThe return-code solution “spreads out” the error logic. Functions through have explicit, hand-written code related to propagating the error condition back up to . That is badness:\n• It clutters functions through with extra decision logic — the most common cause of bugs.\n• It increases the bulk of the code.\n• It clouds the simplicity of the programming logic in functions through .\n• It requires the return value to perform two distinct duties — functions through will need to handle both “my function succeeded and the result is ” and “my function failed and the error information is ”. When the types of and differ, you sometimes need extra by-reference parameters to propagate both the “successful” and “unsuccessful” cases to the caller.\n\nIf you look very narrowly at and in the above examples, exceptions won’t give you much of an improvement. But if you instead open your eyes to the big picture, you will see a substantial difference in all the functions in between.\n\nConclusion: one of the benefits of exception handling is a cleaner, simpler way to propagate error information back to the caller that can handle the error. Another benefit is your function doesn’t need extra machinery to propagate both the “successful” and “unsuccessful” cases back to the caller. Toy examples often don’t emphasize either error propagation or handling of the two-return-types problem, therefore they don’t represent Real World code.\n\nHow do exceptions simplify my function return type and parameter types?\n\nWhen you use return codes, you often need two or more distinct return values: one to indicate that the function succeeded and to give the computed result, and another to propagate the error information back to the caller. If there are, say, 5 ways the function could fail, you could need as many as 6 different return values: the “successful computation” return value, and a possibly different package of bits for each of the 5 error cases.\n\nLet’s simplify it down to two cases:\n• “I succeeded and the result is .”\n• “I failed and the error information is .”\n\nLet’s work a simple example: we would like to create a class that supports the four arithmetic operations: add, subtract, multiply and divide. This is an obvious place for overloaded operators, so let’s define them:\n\nIt’s very easy to use:\n\nBut then we have a problem: handling errors. Adding numbers could cause overflow, dividing could cause divide-by-zero or underflow, etc. Whoops. How can we report both the “I succeeded and the result is ” as well as “I failed and the error information is ”?\n\nIf we use exceptions, it’s easy. Think of exceptions as a separate return type that gets used only when needed. So we just define all the exceptions and throw them when needed:\n\nBut if we use return codes instead of exceptions, life gets hard and messy. When you can’t shove both the “good” number and the error information (including details about what went wrong) inside the object, you will probably end up using extra by-reference parameters to handle one of the two cases: either “I succeeded” or “I failed” or both. Without loss of generality, I will handle the computed result via a normal return value and the “I failed” case via a by-reference parameter, but you can just as easily do the opposite. Here’s the result:\n\nNow here’s how to use it — this code is equivalent to the above:\n\nThe point of this is that you normally have to muck up the interface of functions that use return codes, particularly if there is more error information to propagate back to the caller. For example, if there are 5 error conditions and the “error information” requires different data structures, you might end up with a fairly messy function interface.\n\nNone of this clutter happens with exceptions. Exceptions can be thought of as a separate return value, as if the function automatically “grows” new return types and return values based on what the function can throw.\n\nNote: Please don’t write me saying that you propose using return codes and storing the error information in a namespace-scope, global or static variable, such as . That isn’t thread-safe. Even if you don’t have multiple threads today, you rarely want to permanently prevent anyone in the future from using your class with multiple threads. Certainly if you do, you should write lots and lots of BIG UGLY COMMENTS warning future programmers that your code is not thread-safe, and that it probably can’t be made thread-safe without a substantial rewrite.\n\nWhat does it mean that exceptions separate the “good path” (or “happy path”) from the “bad path”?\n\nIt’s another benefit of exceptions over return-codes.\n\nThe “good path” (sometimes called the “happy path”) is the control-flow path that happens when everything goes well — when there are no problems.\n\nThe “bad path” (or “error path”) is the path that control-flow takes when something goes wrong — when there is a problem.\n\nExceptions, when done right, separate the happy path from the error path.\n\nHere is a simple example: function is suppoesd to call functions , , and , in sequence, as shown below. If any of those fail with a “foo” or “bar” error, is to handle the error immediately then return successfully. If any other error occurs, is to propagate the error information back to the caller.\n\nHere is the code if exceptions are used:\n\nThe “good” path and the “bad” path are cleanly separated. The “good” (or “happy”) path is the body of the block — you can read that linearly, and if there are no errors, control flows in a simplistic path through those lines. The “bad” path is the body of the block and the body of any matching blocks in any caller.\n\nUsing return codes instead of exception clutters this to the point where it is difficult to see the relatively simple algorithm. The “good” (“happy”) and “bad” paths are hopelessly intermixed:\n\nBy intermixing the good/happy path with the bad/error path, it’s harder to see what the code is supposed to do. Contrast that with the version that used exceptions, which is almost self-documenting — the basic functionality is very obvious.\n\nI’m interpreting the previous FAQs as saying exception handling is easy and simple; did I get it right?\n\nNo! Wrong! Stop! Go back! Do not collect $200.\n\nThe message isn’t that exception handling is easy and simple. The message is that exception handling is worth it. The benefits outweigh the costs.\n\nHere are some of the costs:\n• Exception handling is not a free lunch. It requires discipline and rigor. To understand those disciplines, you really should read the rest of the FAQ and/or one of the excellent books on the subject.\n• Exception handling is not a panacea. If you work with a team that is sloppy and undisciplined, your team will likely have problems no matter whether they use exceptions or return codes. Incompetent carpenters do bad work even if they use a good hammer.\n• Exception handling is not one-size-fits-all. Even when you have decided to use exceptions rather than return codes, that doesn’t mean you use them for everything. This is part of the discipline: you need to know when a condition should be reported via return-code and when it should be reported via an exception.\n• Exception handling is a convenient whipping boy. If you work with people who blame their tools, beware of suggesting exceptions (or anything else that is new, for that matter). People whose ego is so fragile that they need to blame someone or something else for their screw-ups will invariably blame whatever “new” technology was used. Of course, ideally you will work with people who are emotionally capable of learning and growing: with them, you can make all sorts of suggestions, because those sorts of people will find a way to make it work, and you’ll have fun in the process.\n\nFortunately there is plenty of wisdom and insight on the proper use of exceptions. Exception handling is not new. The industry as a whole has seen many millions of lines of code and many person-centuries of effort using exceptions. The jury has returned its verdict: exceptions can be used properly, and when they are used properly, they improve code.\n\nException handling seems to make my life more difficult; that must mean exception handling itself is bad; clearly I’m not the problem, right??\n\nYou absolutely might be the problem!\n\nThe C++ exception handling mechanism can be powerful and useful, but if you have the wrong mindset, the result can be a mess. It’s a tool; use it properly and it will help you; but don’t blame the tool if you use it improperly.\n\nIf you’re getting bad results, for instance, if your code seems unnecessarily convoluted or overly cluttered with blocks, you might be suffering from a wrong mindset. This FAQ gives you a list of some of those wrong mindsets.\n\nWarning: do not be simplistic about these “wrong mindsets.” They are guidelines and ways of thinking, not hard and fast rules. Sometimes you will do the exact opposite of what they recommend — do not write me about some situation that is an exception (no pun intended) to one or more of them — I guarantee that there are exceptions. That’s not the point.\n\nHere are some “wrong exception-handling mindsets” in no apparent order:\n• The return-codes mindset: This causes programmers to clutter their code with gobs of blocks. Basically they think of a as a glorified return code, and a / as a glorified “if the return code indicates an error” test, and they put one of these blocks around just about every function that can .\n• The Java mindset: In Java, non-memory resources are reclaimed via explicit / blocks. When this mindset is used in C++, it results in a large number of unnecessary blocks, which, compared with RAII, clutters the code and makes the logic harder to follow. Essentially the code swaps back and forth between the “good path” and the “bad path” (the latter meaning the path taken during an exception). With RAII, the code is mostly optimistic — it’s all the “good path,” and the cleanup code is buried in destructors of the resource-owning objects. This also helps reduce the cost of code reviews and unit-testing, since these “resource-owning objects” can be validated in isolation (with explicit / blocks, each copy must be unit-tested and inspected individually; they cannot be handled as a group).\n• Organizing the exception classes around the physical thrower rather than the logical reason for the throw: For example, in a banking app, suppose any of five subsystems might throw an exception when the customer has insufficient funds. The right approach is to throw an exception representing the reason for the throw, e.g., an “insufficient funds exception”; the wrong mindset is for each subsystem to throw a subsystem-specific exception. For example, the subsystem might throw objects of class , the subsystem might throw objects of class , etc. This often leads to extra / blocks, e.g., to catch a , repackage it into a , then throw the latter. In general, exception classes should represent the problem, not the chunk of code that noticed the problem.\n• Using the bits / data within an exception object to differentiate different categories of errors: Suppose the subsystem in our banking app throws exceptions for bad account numbers, for attempting to liquidate an illiquid asset, and for insufficient funds. When these three logically distinct kinds of errors are represented by the same exception class, the catchers need to say to figure out what the problem really was. If your code wants to handle only bad account numbers, you need to the master exception class, then use to determine whether it is one you really want to handle, and if not, to rethrow it. In general, the preferred approach is for the error condition’s logical category to get encoded into the type of the exception object, not into the data of the exception object.\n• Designing exception classes on a subsystem by subsystem basis: In the bad old days, the specific meaning of any given return-code was local to a given function or API. Just because one function uses the return-code of 3 to mean “success,” it was still perfectly acceptable for another function to use 3 to mean something entirely different, e.g., “failed due to out of memory.” Consistency has always been preferred, but often that didn’t happen because it didn’t need to happen. People coming with that mentality often treat C++ exception-handling the same way: they assume exception classes can be localized to a subsystem. That causes no end of grief, e.g., lots of extra blocks to then a repackaged variant of the same exception. In large systems, exception hierarchies must be designed with a system-wide mindset. Exception classes cross subsystem boundaries — they are part of the intellectual glue that holds the architecture together.\n• Use of raw (as opposed to smart) pointers: This is actually just a special case of non-RAII coding, but I’m calling it out because it is so common. The result of using raw pointers is, as above, lots of extra / blocks whose only purpose in life is to an object then re- the exception.\n• Confusing logical errors with runtime situations: For example, suppose you have a function that must never be called with nullptr. However you discover that somebody somewhere is sometimes passing nullptr anyway. There are two possibilities: either they are passing nullptr because they got bad data from an external user (for example, the user forgot to fill in a field and that ultimately resulted in a nullptr) or they just plain made a mistake in their own code. In the former case, you should throw an exception since it is a runtime situation (i.e., something you can’t detect by a careful code-review; it is not a bug). In the latter case, you should definitely fix the bug in the caller’s code. You can still add some code to write a message in the log-file if it ever happens again, and you can even throw an exception if it ever happens again, but you must not merely change the code within ; you must, must, MUST fix the code in the caller(s) of .\n\nThere are other “wrong exception-handling mindsets,” but hopefully those will help you out. And remember: don’t take those as hard and fast rules. They are guidelines, and there are exceptions to each.\n\nI have too many try blocks; what can I do about it?\n\nYou might have the mindset of return codes even though you are using the syntax of / / . For instance, you might put a try block around just about every call:\n\nAlthough this uses the / / syntax, the overall structure is very similar to the way things are done with return codes, and the consequent software development/test/maintenance costs are basically the same as they were for return codes. In other words, this approach doesn’t buy you much over using return codes. In general, it is bad form.\n\nOne way out is to ask yourself this question for each try block: “Why am I using a try block here?” There are several possible answers:\n• Your answer might be, “So I can actually handle the exception. My catch clause deals with the error and continues execution without throwing any additional exceptions. My caller never knows that the exception occurred. My catch clause does not throw any exceptions and it does not return any error-codes.” In that case, you leave the try block as-is — it is probably good.\n• Your answer might be, “So I can have a catch clause that does blah blah blah, after which I will rethrow the exception.” In this case, consider changing the try block into an object whose destructor does blah blah blah. For instance, if you have a try block whose catch clause closes a file then rethrows the exception, consider replacing the whole thing with a object whose destructor closes the file. This is commonly called RAII.\n• Your answer might be, “So I can repackage the exception: I catch a , extract the details, then throw a .” When that happens, consider a better hierarchy of exception objects that doesn’t require this catch/repackage/rethrow idea. This often involves broadening the meaning of , though obviously you shouldn’t go too far.\n• There are other answers as well, but the above are some common ones that I’ve seen.\n\nMain point is to ask “Why?”. If you discover the reason you’re doing it, you might find that there are better ways to achieve your goal.\n\nHaving said all this, there are, unfortunately, some people who have the return-code-mindset burned so deeply into their psyche that they just can’t seem to see any alternatives. If that is you, there is still hope: get a mentor. If you see it done right, you’ll probably get it. Style is sometimes caught, not just taught.\n\nCan I throw an exception from a constructor? From a destructor?\n• For constructors, yes: You should throw an exception from a constructor whenever you cannot properly initialize (construct) an object. There is no really satisfactory alternative to exiting a constructor by a . For more details, see here.\n• For destructors, not really: You can throw an exception in a destructor, but that exception must not leave the destructor; if a destructor exits by emitting an exception, all kinds of bad things are likely to happen because the basic rules of the standard library and the language itself will be violated. Don’t do it. For more details, see here.\n\nFor examples and detailed explanations, see Appendix E of TC++PL3e.\n\nThere is a caveat: Exceptions can’t be used for some hard-real time projects. For example, see the JSF air vehicle C++ coding standards.\n\nHow can I handle a constructor that fails?\n\nConstructors don’t have a return type, so it’s not possible to use return codes. The best way to signal constructor failure is therefore to throw an exception. If you don’t have the option of using exceptions, the “least bad” work-around is to put the object into a “zombie” state by setting an internal status bit so the object acts sort of like it’s dead even though it is technically still alive.\n\nThe idea of a “zombie” object has a lot of down-side. You need to add a query (“inspector”) member function to check this “zombie” bit so users of your class can find out if their object is truly alive, or if it’s a zombie (i.e., a “living dead” object), and just about every place you construct one of your objects (including within a larger object or an array of objects) you need to check that status flag via an statement. You’ll also want to add an to your other member functions: if the object is a zombie, do a no-op or perhaps something more obnoxious.\n\nIn practice the “zombie” thing gets pretty ugly. Certainly you should prefer exceptions over zombie objects, but if you do not have the option of using exceptions, zombie objects might be the “least bad” alternative.\n\nNote: if a constructor finishes by throwing an exception, the memory associated with the object itself is cleaned up — there is no memory leak. For example:\n\nThere is some fine print on this topic, so you need to keep reading. Specifically you need to know how to prevent memory leaks if the constructor itself allocates memory, and you also need to be aware of what happens if you use “placement” rather than the ordinary used in the sample code above.\n\nHow can I handle a destructor that fails?\n\nWrite a message to a log-file. Terminate the process. Or call Aunt Tilda. But do not throw an exception!\n\nThe C++ rule is that you must never throw an exception from a destructor that is being called during the “stack unwinding” process of another exception. For example, if someone says , the stack will be unwound so all the stack frames between the\n\nwill get popped. This is called stack unwinding.\n\nDuring stack unwinding, all the local objects in all those stack frames are destructed. If one of those destructors throws an exception (say it throws a object), the C++ runtime system is in a no-win situation: should it ignore the and end up in the\n\nwhere it was originally headed? Should it ignore the and look for a\n\nhandler? There is no good answer — either choice loses information.\n\nSo the C++ language guarantees that it will call at this point, and kills the process. Bang you’re dead.\n\nThe easy way to prevent this is never throw an exception from a destructor. But if you really want to be clever, you can say never throw an exception from a destructor while processing another exception. But in this second case, you’re in a difficult situation: the destructor itself needs code to handle both throwing an exception and doing “something else”, and the caller has no guarantees as to what might happen when the destructor detects an error (it might throw an exception, it might do “something else”). So the whole solution is harder to write. So the easy thing to do is always do “something else”. That is, never throw an exception from a destructor.\n\nOf course the word never should be “in quotes” since there is always some situation somewhere where the rule won’t hold. But certainly at least 99% of the time this is a good rule of thumb.\n\nHow should I handle resources if my constructors may throw exceptions?\n\nEvery data member inside your object should clean up its own mess.\n\nIf a constructor throws an exception, the object’s destructor is not run. If your object has already done something that needs to be undone (such as allocating some memory, opening a file, or locking a semaphore), this “stuff that needs to be undone” must be remembered by a data member inside the object.\n\nFor example, rather than allocating memory into a raw data member, put the allocated memory into a “smart pointer” member object, and the destructor of this smart pointer will the object when the smart pointer dies. The template is an example of such as “smart pointer.” You can also write your own reference counting smart pointer. You can also use smart pointers to “point” to disk records or objects on other machines.\n\nBy the way, if you think your class is going to be allocated into a smart pointer, be nice to your users and create a within your class:\n\nThat simplifies the syntax of all the code that uses your objects: your users can say instead of :\n\nHow do I change the string-length of an array of to prevent memory leaks even if/when someone throws an exception?\n\nIf what you really want to do is work with strings, don’t use an array of in the first place, since arrays are evil. Instead use an object of some -like class.\n\nFor example, suppose you want to get a copy of a string, fiddle with the copy, then append another string to the end of the fiddled copy. The array-of- approach would look something like this:\n\nUsing s like this is tedious and error prone. Why not just use an object of some class? Your compiler probably supplies a -like class, and it’s probably just as fast and certainly it’s a lot simpler and safer than the code that you would have to write yourself. For example, if you’re using the class from the standardization committee, your code might look something like this:\n\nThe version requires you to write around three times more code than you would have to write with the version. Most of the savings came from ’s automatic memory management: in the version, we didn’t need to write any code…\n• to reallocate memory when we grow the string.\n• to anything at the end of the function.\n• to and re- any exceptions.\n\nC++, unlike just about every other language with exceptions, is very accomodating when it comes to what you can throw. In fact, you can throw anything you like. That begs the question then, what should you throw?\n\nGenerally, it’s best to throw objects, not built-ins. If possible, you should throw instances of classes that derive (ultimately) from the class. By making your exception class inherit (ultimately) from the standard exception base-class, you are making life easier for your users (they have the option of catching most things via ), plus you are probably providing them with more information (such as the fact that your particular exception might be a refinement of or whatever).\n\nThe most common practice is to throw a temporary:\n\nHere, a temporary of type is created and thrown. Class inherits from class which (ultimately) inherits from class .\n\nIn keeping with the C++ tradition of “there’s more than one way to do that” (translation: “give programmers options and tradeoffs so they can decide what’s best for them in their situation”), C++ allows you a variety of options for catching.\n• You can catch by value.\n• You can catch by reference.\n• You can catch by pointer.\n\nIn fact, you have all the flexibility that you have in declaring function parameters, and the rules for whether a particular exception matches (i.e., will be caught by) a particular catch clause are almost exactly the same as the rules for parameter compatibility when calling a function.\n\nGiven all this flexibility, how do you decide what to catch? Simple: unless there’s a good reason not to, catch by reference. Avoid catching by value, since that causes a copy to be made and the copy can have different behavior from what was thrown. Only under very special circumstances should you catch by pointer.\n\nBut MFC seems to encourage the use of catch-by-pointer; should I do the same?\n\nDepends. If you’re using MFC and catching one of their exceptions, by all means, do it their way. Same goes for any framework: when in Rome, do as the Romans. Don’t try to force a framework into your way of thinking, even if “your” way of thinking is “better.” If you decide to use a framework, embrace its way of thinking — use the idioms that its authors expected you to use.\n\nBut if you’re creating your own framework and/or a piece of the system that does not directly depend on MFC, then don’t catch by pointer just because MFC does it that way. When you’re not in Rome, you don’t necessarily do as the Romans. In this case, you should not. Libraries like MFC predated the standardization of exception handling in the C++ language, and some of these libraries use a backwards-compatible form of exception handling that requires (or at least encourages) you to catch by pointer.\n\nThe problem with catching by pointer is that it’s not clear who (if anyone) is responsible for deleting the pointed-to object. For example, consider the following:\n\nThere are three basic problems here:\n• It might be tough to decide whether to within the clause. For example, if object is inaccessible to the scope of the clause, such as when it’s buried in the private part of some class or is within some other compilation unit, it might be tough to figure out what to do.\n• If you solve the first problem by consistently using in the (and therefore consistently using in the ), then exceptions always use the heap which can cause problems when the exception was thrown because the system was running low on memory.\n• If you solve the first problem by consistently not using in the (and therefore consistently not using in the ), then you probably won’t be able to allocate your exception objects as locals (since then they might get destructed too early), in which case you’ll have to worry about thread-safety, locks, semaphores, etc. ( objects are not intrinsically thread-safe).\n\nThis isn’t to say it’s not possible to work through these issues. The point is simply this: if you catch by reference rather than by pointer, life is easier. Why make life hard when you don’t have to?\n\nThe moral: avoid throwing pointer expressions, and avoid catching by pointer, unless you’re using an existing library that “wants” you to do so.\n\nWhat does (without an exception object after the keyword) mean? Where would I use it?\n\nYou might see code that looks something like this:\n\nIn this example, the statement means “re-throw the current exception.” Here, a function caught an exception (by non-const reference), modified the exception (by adding information to it), and then re-threw the exception. This idiom can be used to implement a simple form of stack-trace, by adding appropriate catch clauses in the important functions of your program.\n\nAnother re-throwing idiom is the “exception dispatcher”:\n\nThis idiom allows a single function ( ) to be re-used to handle exceptions in a number of other functions.\n\nIf you try this, you might be surprised at run-time when your clause is entered, and not your clause. This happens because you didn’t throw polymorphically. In function , the statement throws an object with the same type as the static type of the expression . In other words, it throws an instance of . The statement behaves as-if the thrown object is copied, as opposed to making a “virtual copy”.\n\nNote that the statement has been moved into a virtual function. The statement will exhibit polymorphic behavior, since is declared and was passed by reference. As before, the thrown object will be of the static type of the argument in the statement, but within , that static type is , not .\n\nWhen I throw this object, how many times will it be copied?\n\nObjects that are thrown must have a publicly accessible copy-constructor. The compiler is allowed to generate code that copies the thrown object any number of times, including zero. However even if the compiler never actually copies the thrown object, it must make sure the exception class’s copy constructor exists and is accessible.\n\nBecause C++ supports an alternative that is almost always better: The “resource acquisition is initialization” technique. The basic idea is to represent a resource by a local object, so that the local object’s destructor will release the resource. That way, the programmer cannot forget to release the resource. For example:\n\nIn a system, in the worst case we need a “resource handle” class for each resource. However, we don’t have to have a “finally” clause for each acquisition of a resource. In realistic systems, there are far more resource acquisitions than kinds of resources, so the “resource acquisition is initialization” technique leads to less code than use of a “finally” construct.\n\nAlso, have a look at the examples of resource management in Appendix E of TC++PL3e.\n\nWhy can’t I resume after catching an exception?\n\nIn other words, why doesn’t C++ provide a primitive for returning to the point from which an exception was thrown and continuing execution from there?\n\nBasically, someone resuming from an exception handler can never be sure that the code after the point of throw was written to deal with the execution just continuing as if nothing had happened. An exception handler cannot know how much context to “get right” before resuming. To get such code right, the writer of the throw and the writer of the catch need intimate knowledge of each others code and context. This creates a complicated mutual dependency that wherever it has been allowed has led to serious maintenance problems.\n\nStroustrup seriously considered the possibility of allowing resumption when he designed the C++ exception handling mechanism and this issue was discussed in quite some detail during standardization. See the exception handling chapter of The Design and Evolution of C++.\n\nIf you want to check to see if you can fix a problem before throwing an exception, call a function that checks and then throws only if the problem cannot be dealt with locally. A is an example of this."
    },
    {
        "link": "https://geeksforgeeks.org/proxy-pattern-c-design-patterns",
        "document": "Design Patterns are an essential part of software engineering, offering proven solutions to common problems encountered during software development. One such pattern is the Proxy Pattern. The Proxy Pattern is a structural design pattern that provides a surrogate or placeholder for another object, allowing you to control access to it. This pattern can be particularly useful in situations where you need to add an extra layer of control, lazy loading, or remote access to objects.\n\nThe Proxy Pattern, also known as the Surrogate Pattern that falls under the Gang of Four Design Patterns, is a structural design pattern, meaning it deals with how classes and objects are composed to form larger structures. The pattern involves creating a new class (the proxy) that acts as an intermediary or placeholder for an object (the subject) to control access to it. The proxy can be a local representative of the subject, which helps in various tasks such as lazy initialization, access control, logging, monitoring, or remote communication.\n\nImagine you have a friend who's an expert at solving puzzles, but you don't want to bother them all the time. You'd like someone to help you access their puzzle-solving skills when needed.\n• Subject: Your friend's ability to solve puzzles is like the Subject. This is the core thing you want to use, which is solving puzzles.\n• Real Object: Your friend is the Real Object in this case. They can solve puzzles really well, but it might take some time and effort to engage them every time you need help.\n• Proxy: Proxy. In this scenario, the proxy could be your other friend, who acts as an intermediary. When you have a puzzle to solve, you talk to this proxy friend. The proxy friend decides if the puzzle is simple enough to handle themselves. If it's a tough puzzle, they'll ask your puzzle-solving expert friend for help.\n\nImplementation of the Proxy Pattern in C++\n\nWe'll create a simplified example where an Image class is used to represent images, and we'll implement a proxy to control access and display these images.\n\nThe Subject is the common interface that both the RealObject and Proxy will implement. In our example, it will be the Image interface:\n\nThe Real Object is the actual class that performs the real work. In our example, we create an RealImage class:\n\nThe Proxy class implements the same interface as the Real Object, and it maintains a reference to the Real Object. The proxy controls access to the Real Object. We'll call this ImageProxy:\n\nNow, let's use the Proxy Pattern:\n\nThis code sets up an image proxy, and when you request to display the image, the proxy checks whether the real image needs to be loaded. If it's already loaded, the proxy just displays it. This demonstrates the lazy-loading aspect of the Proxy Pattern.\n\nThe Proxy Pattern allows you to control access to a resource (in this case, an image) and manage when and how the real object is created and accessed without changing the client's code.\n\nBelow is the complete working code of the above example:\n\nUse Cases of the Proxy Pattern\n\nThe Proxy Pattern is particularly useful in various scenarios:\n• Lazy Loading: When you have a resource-intensive object that should be loaded only when it is needed, a proxy can handle its creation. For instance, loading large images or database connections on-demand.\n• Access Control: Proxies can control access to the Real Subject by adding authentication and authorization checks. This is especially useful in securing sensitive resources.\n• Caching: Proxies can cache the results of expensive operations, reducing the need to invoke the Real Subject repeatedly.\n• Logging and Monitoring: Proxies can be used to log or monitor the actions performed on the Real Subject without modifying its code.\n• Control: The Proxy Pattern allows you to control access to the real subject, enabling you to add additional features or security checks without modifying the subject itself.\n• Lazy Loading: With virtual proxies, you can delay the creation of resource-intensive objects until they are actually needed, improving performance.\n• Remote Access: In distributed systems, the Proxy Pattern allows you to access objects in different address spaces transparently.\n• Security: Protection proxies can enforce access control and security checks, preventing unauthorized access to the real subject.\n• Complexity: Introducing proxy classes can add complexity to the codebase, making it harder to maintain and understand.\n• Overhead: In some cases, the use of proxies can introduce additional method calls and indirection, potentially impacting performance.\n• Maintenance: Keeping proxies in sync with changes in the real subject can be challenging.\n• Misuse: If not used judiciously, the Proxy Pattern can lead to excessive code and an overly complex system.\n\nThe Proxy Pattern in C++ is a valuable tool for enhancing the control and efficiency of your applications. It allows you to add an additional layer of functionality to your classes without altering their structure. By using proxies, you can achieve lazy initialization, access control, logging and caching, improving the performance and maintainability of your code. When applied appropriately, the Proxy Pattern can be a powerful asses in your design patterns toolbox."
    },
    {
        "link": "https://medium.com/@lokeshbihani99/proxy-pattern-in-c-2a1e8e900784",
        "document": "The Proxy pattern is a structural design pattern that provides a surrogate, placeholder or proxy for another object to control access to it. The proxy object acts as an intermediary between the client and the real object, providing an additional level of indirection.\n\nThis pattern is useful in situations where you want to add functionality, such as caching, access control, logging, lazy initialization, without modifying the original object, adhering to the Open/Closed Principle.\n• Proxy: This is the object that controls access to the real subject. It implements the same interface as the real subject.\n• Real Subject: This is the object that does the actual work. The proxy controls access to this object.\n• Client: This is the object that interacts with the proxy (or sometimes directly with the real subject).\n\nAt the micro level, a class implements encapsulation by making properties private and providing public methods (class interface) to access or manipulate those properties. This ensures controlled access to the internal state of the class. Similarly, at a higher level, the Proxy pattern encapsulates the real subject and provides controlled access to it. The proxy acts as an intermediary, allowing additional behaviors like access control, logging, or lazy initialization to be added without modifying the real subject.\n\nSuppose we have an application that displays high-resolution images. Loading these images at startup can be time-consuming and unnecessary if the user doesn’t view all of them. By using proxy pattern we can delay the image loading process.\n\nLet’s say we want to log when our sql query starts and ends. One way to do this is by simple adding print statements before and after executing the query, but where’s the fun in that?\n\nLet’s see how different design patterns are used together to solve this usecase. We’ll use the class that we discussed in Factory Method pattern article.\n\nThis example follows the key principles of the Proxy pattern:\n• Controlled Access: The proxy controls access to the real service’s method by intercepting the call and performing additional logging operations.\n• Separation of Concerns: The logging functionality is separated from the core functionality of the RealService class, promoting a cleaner and more maintainable design.\n• Encapsulation: The RealService class is encapsulated by the LoggingProxyService class, which ensures that clients interact with the service through the proxy.\n• CDNs: CDNs use caching proxies to store copies of web content closer to the end-users. When a user requests a resource, the CDN proxy can serve the cached copy instead of fetching it from the origin server.\n• API Gateways: In microservices architecture, API gateways often act as security proxies. They handle tasks such as verifying API keys, checking user permissions, and logging requests before forwarding them to the appropriate microservice.\n• Reverse Proxies: Nginx can act as a reverse proxy, forwarding client requests to backend servers.\n• Distributed Systems: Remote proxies represent objects that reside on remote servers. The proxy handles network communication, making remote objects appear as if they were local. This is common in RPC (Remote Procedure Calls).\n\nProxy Pattern is used to control access, optimize resource usage, enhance security, and provide additional functionality without modifying the actual objects."
    },
    {
        "link": "https://refactoring.guru/design-patterns/proxy/cpp/example",
        "document": "Proxy is a structural design pattern that provides an object that acts as a substitute for a real service object used by a client. A proxy receives client requests, does some work (access control, caching, etc.) and then passes the request to a service object. The proxy object has the same interface as a service, which makes it interchangeable with a real object when passed to a client.\n\nUsage examples: While the Proxy pattern isn’t a frequent guest in most C++ applications, it’s still very handy in some special cases. It’s irreplaceable when you want to add some additional behaviors to an object of some existing class without changing the client code.\n\nIdentification: Proxies delegate all of the real work to some other object. Each proxy method should, in the end, refer to a service object unless the proxy is a subclass of a service.\n\nThis example illustrates the structure of the Proxy design pattern. It focuses on answering these questions:\n• What classes does it consist of?\n• What roles do these classes play?\n• In what way the elements of the pattern are related?"
    },
    {
        "link": "https://modernescpp.com/index.php/the-proxy-pattern",
        "document": "The Proxy Pattern is probably the most influential design pattern for C++. The Proxy provides a placeholder for accessing another object.\n\nThe proxy pattern is one of the seven structural patterns from the book “Design Patterns: Elements of Reusable Object-Oriented Software”. A proxy controls access to another object, allowing you to perform additional operations before or after you access the original object. Sound familiar?\n\nWhich idiom is characteristic of C++? Right: RAII (Resource Acquisition Is Initialization). RAII is the C++ way to implement the Proxy Pattern. Here are the facts about the Proxy Pattern.\n• Provides a placeholder for accessing another object.\n\nAlso Known As\n• Control access to another object\n• Remote proxy (acts as an intermediary for a remote service)\n• Controls the access and lifetime of the\n• Supports the same interface as\n• Defines the interface of the and the\n\nThe following examples use two generic proxies: and .\n\nBoth smart pointers can transparently access the member function of . It makes no difference if you call the member function on the , (line 1) on the , (line 2), or on the object directly. All calls return the same value:\n\nThe smart pointers model the Proxy Pattern in C++. Additionally, the RAII Idiom is the C++ adaption of the Proxy Pattern. RAII is the crucial idiom in C++. I will write more about it in a few lines.\n• The Adaptor Pattern adjusts an existing interface, but the Facade creates a new simplified interface.\n• The Decorator Pattern is structurally similar to the Proxy, but the Decorator has a different purpose. A Decorator extends an object with additional responsibilities. A Proxy controls access to an object.\n• The Facade Pattern is similar to the Proxy because it encapsulates access to an object. The Facade does not support the same interface as the Proxy but supports a simplified one.\n• The underlying object is fully transparent to the client.\n• The proxy can answer requests directly without using the client\n• The proxy can be transparently extended or replaced with another proxy.\n• The separation of the proxy and the object makes the code more difficult\n• The forwarded proxy calls may be performance critical\n\nRAII stands for Resource Acquisition Is Initialization. The most crucial idiom in C++ is that a resource should be acquired in the constructor and released in the object’s destructor. The key idea is that the destructor will automatically be called if the object goes out of scope. Or, to put it differently: A resource’s lifetime is bound to a local variable’s lifetime, and C++ automatically manages the lifetime of locals.\n\nThere is one big difference between the Proxy Pattern and the RAII Idiom in C++. In the classical Proxy Pattern, the Proxy and the RealObject (object) implement the same interface. Therefore, you invoke a member function on the proxy, and this call is delegated to the object. On the contrary, it is typical for RAII to do the operation on the object implicitly.\n\nThe following example shows the deterministic behavior of RAII in C++.\n\nResourceGuard is a guard that manages its resource. In this case, the string stands for the resource. ResourceGuard creates in its constructor the resource and releases the resource in its destructor. It does its job very decent.\n\nThe destructor of resGuard1 (line 1) is called at the end of the main function (line 2). The lifetime of resGuard2 (line 3) already ends in line 4. Therefore, the destructor is automatically executed. Even the throwing of an exception does not affect the reliability of resGuard3 (line 5). The destructor is called at the end of the try block (line 6).\n\nThe screenshot shows the lifetimes of the objects.\n\nIt’s pretty easy to apply the RAII Idiom to make out the a :\n\nAll instances of share the same mutex . When an instance goes out of scope, it automatically unlocks its mutex .\n\nI wrote that the RAII Idiom is the most crucial idiom in C++. Let me name a few prominent examples.\n• Containers of the STL, including : they automatically allocate in the constructor and deallocate in their destructor\n• Smart Pointers: and take ownership of the underlying raw pointer; they delete the underlying raw pointer if it is not needed anymore.\n• Locks: , , , and lock in their constructor the underlying mutex and unlock it in their destructor automatically\n• : in C++20 is an improved from C++11; automatically joins in its destructor if necessary\n\nIn my next post, I will continue my journey through the patterns of the book “Design Patterns: Elements of Reusable Object-Oriented Software”. The Observer Pattern is a behavioral pattern that should be in the toolbox of each professional programmer."
    },
    {
        "link": "https://geeksforgeeks.org/proxy-design-pattern",
        "document": "The Proxy Design Pattern a structural design pattern is a way to use a placeholder object to control access to another object. Instead of interacting directly with the main object, the client talks to the proxy, which then manages the interaction. This is useful for things like controlling access, delaying object creation until it’s needed (lazy initialization), logging, or adding security checks.\n\nThe Proxy Design Pattern is a design pattern in which the client and the actual object are connected by a proxy object. The client communicates with the proxy, which manages access to the real object, rather than the real object directly. Before sending the request to the real object, the proxy can take care of additional tasks like caching, security, logging, and lazy loading.\n\nChaining proxies in the Proxy Design Pattern means connecting them in a sequence, where each proxy adds its behavior or checks before passing the request to the next proxy or the real object. It’s like forming a chain of guards, each responsible for a specific task.\n\nThe is an interface or an abstract class that defines the common interface shared by the and classes. It declares the methods that the uses to control access to the .\n• None Declares the common interface for both\n• None Usually includes the methods that the client code can invoke on the\n\nThe is the actual object that the represents. It contains the real implementation of the business logic or the resource that the client code wants to access.\n• None It Implements the operations declared by the\n• None Represents the real resource or object that the\n\nThe acts as a surrogate or placeholder for the . It controls access to the real object and may provide additional functionality such as lazy loading, access control, or logging.\n• None Implements the same interface as the\n\nBelow are the simple steps to implement the Proxy Design Pattern:\n• Create the Real Object Interface : Define an interface or abstract class that represents the operations the real object will provide. Both the real object and proxy will implement this interface.\n• Create the Real Object : This class implements the interface and contains the actual logic or operation that the client wants to use.\n• Create the Proxy Class : The proxy class also implements the same interface as the real object. It holds a reference to the real object and controls access to it. The proxy can add extra logic like logging, caching, or security checks before calling the real object’s methods.\n• Client Uses the Proxy : Instead of creating the real object directly, the client interacts with the proxy. The proxy decides when and how to forward the client’s request to the real object.\n\nTo address this issue, we need to implement the Proxy Design Pattern to control the access and loading of images.\n\nThe interface declares the common methods for displaying images, acting as a blueprint for both the real and proxy objects. In this design, it defines the method that both and must implement. This ensures a uniform interface for clients interacting with image objects.\n\nThe class represents the real object that the proxy will control access to.\n• None interface, providing concrete implementations for loading and displaying images from disk.\n• None The constructor initializes the image file name, and the method is responsible for loading the image if not already loaded and then displaying it.\n\nThe class acts as a surrogate for the . It also implements the interface, maintaining a reference to the real image object.\n• None method in the proxy checks whether the real image has been loaded; if not, it creates a new instance of\n• None This lazy loading mechanism ensures that the real image is loaded only when necessary.\n\nThe client code ( ) demonstrates the usage of the Proxy Design Pattern. It creates an object, which is actually an instance of .\n• None The proxy, in turn, controls access to the real image, ensuring that it is loaded from disk only when needed.\n• None use the cached image in the proxy, avoiding redundant loading and improving performance.\n\n5. Complete Code of the above example:\n\nThis code demonstrates how the Proxy Pattern efficiently manages the loading and displaying of images by introducing a proxy that controls access to the real image object, providing additional functionality such as lazy loading.\n\nWhy do we need Proxy Design Pattern?\n\nThe Proxy Design Pattern is employed to address various concerns and scenarios in software development, providing a way to control access to objects, add functionality, or optimize performance.\n• Lazy Loading:\n• None One of the primary use cases for proxies is lazy loading. In situations where creating or initializing an object is resource-intensive, the proxy delays the creation of the real object until it is actually needed.\n• None This can lead to improved performance by avoiding unnecessary resource allocation.\n• Access Control:\n• None By acting as a gatekeeper to the real object, proxies can restrict access based on certain conditions, providing security or permission checks.\n• Protection Proxy:\n• None Protection proxies control access to a real object by adding an additional layer of security checks.\n• None They can ensure that the client code has the necessary permissions before allowing access to the real object.\n• Caching:\n• None Proxies can implement caching mechanisms to store results or resources.\n• None This is particularly useful when repeated operations on a real object can be optimized by caching previous results, avoiding redundant computations or data fetching.\n• Logging and Monitoring:\n• None By intercepting method calls to the real object, proxies can log information, track usage, or measure performance without modifying the real object.\n\nWhen to use ?\n• None Use a proxy when you want to postpone the creation of a resource-intensive object until it’s actually needed.\n• None Use a proxy when you need to control and manage access to an object, ensuring that certain conditions or permissions are met before allowing clients to interact with the real object.\n• None Use a proxy to optimize the utilization of resources, such as caching results or storing previously fetched data. This can lead to performance improvements by avoiding redundant computations or data retrieval.\n• None Use a proxy when dealing with distributed systems and you want to interact with objects located in different addresses or systems.\n• None The proxy can handle the communication details, making remote object interaction more seamless.\n\nWhen not to use ?\n• Overhead for Simple Operations: Avoid using a proxy for simple objects or operations that don’t involve resource-intensive tasks. Introducing a proxy might add unnecessary complexity in such cases.\n• Unnecessary Abstraction: If your application doesn’t require lazy loading, access control, or additional functionalities provided by proxies, introducing proxies may lead to unnecessary abstraction and code complexity.\n• Performance Impact: If the introduction of a proxy negatively impacts performance rather than improving it, especially in cases where objects are lightweight and creation is not a significant overhead.\n• When Access Control Isn’t Needed: If there are no access control requirements and the client code can directly interact with the real object without any restrictions.\n• When Eager Loading is Acceptable: If eager loading of objects is acceptable and doesn’t affect the performance of the system, introducing a proxy for lazy loading might be unnecessary."
    }
]