[
    {
        "link": "https://medium.com/@raygunio/best-practices-for-writing-clean-maintainable-javascript-cca3d4174f5a",
        "document": "The world‚Äôs biggest language comes with a huge collection of conventions and guidelines from the community‚Äôs collective wisdom. Following JavaScript best practices can help achieve faster page loads and better performance, improve code readability, and make maintenance and debugging easier. Carefully crafted code can also prevent errors and security issues, especially if it‚Äôs complemented with real-time diagnostic tools such as JavaScript error monitoring.\n\nIn this article, we‚Äôll look into a selection of JavaScript best practices that you can use in front-end development.\n\n1. Choose a JavaScript coding style guide and stick to it\n\nEven though you can set up your own coding guidelines that fit with your goals, you don‚Äôt necessarily have to. There are multiple ready-to-use JavaScript coding style guides that are well tested and widely used across the industry. Some examples include the community-based Idiomatic JavaScript, the Google JavaScript Style Guide, and AirBnB‚Äôs JavaScript Style Guide.\n\nUsing a coding style guide is especially important in teamwork, where multiple developers are working on the same project. As Idiomatic JavaScript puts it, ‚Äúall code in any code base should look like a single person typed it, no matter how many people contributed.‚Äù Whether you create your own style guide or use a third-party one, consistent code will be easier to read, write, debug, and maintain.\n\nMake the names of your variables, functions, and other code structures easy to understand for anyone who works with your code. Don‚Äôt use names that are either too short or too long, and take care that they succinctly describe their own purpose.\n\nSome good examples are (from the DOM API):\n\nAlso keep in mind that JavaScript is a case-sensitive language. As camel case capitalization is the most common naming system in JavaScript programming, you should use lower camelcase for variables and functions and upper camelcase for classes and interfaces for better code readability.\n\n3. Use shorthands, but be careful with them\n\nJavaScript includes many shorthands that allow you to write code faster and make your scripts load faster.\n\nThere are older shorthands that have been part of the JavaScript syntax for ages, such as the shorthand:\n\nAnd of course, there are newer ones, too, such as arrow functions introduced in ECMAScript 6:\n\nSometimes, however, shorthands might return surprising results. So, always be sure of what you‚Äôre doing, check the documentation, find relevant JavaScript code examples, and test the outcome.\n\n4. Comment your code, but keep it short\n\nCommenting is a hot topic in programming. Some say it‚Äôs not necessary at all, but code without any comments gets hard to read after a while ‚Äî especially when working on team or legacy projects. On the other hand, overly long and verbose comments are unnecessary because they‚Äôll take extra time to read through and understand.\n\nAs a rule of thumb, comment your code, especially functions, classes, objects, and interfaces, but only include key information. To keep your comments concise and easy to read, use tags such as , , , , and others.\n\nHere‚Äôs an example of a short but descriptive comment from JSDoc‚Äôs guidelines:\n\nIf you comment your JavaScript code properly, you can also use a tool such as JSDoc to automatically generate documentation for your project.\n\nTaking separation of concerns (SoC) seriously is one of the most important JavaScript coding practices. Technically, JavaScript allows you to directly change the CSS code using the property. However, to make debugging easier and improve code maintainability, it‚Äôs best to avoid it.\n\nAs an alternative, you can add and remove classes using the API as follows (then add the style rules with CSS):\n\nAs global variables are available to all the scripts running on your page, they can easily be overridden by other variables using the same name. There are various ways to reduce the number of global variables, but ECMAScript 6 has introduced two new JavaScript statements you can use to declare variables in the local scope: and .\n\nBoth and create block-scoped local variables, but can be re-declared (in a different scope) while can‚Äôt. As opposed to , neither nor becomes a property of the object, so they can‚Äôt be accessed, and therefore overridden, by other scripts ‚Äî even when they are declared globally (in the highest scope).\n\nYou can define with or without a value (however, it can only be read and written after full initialization), but you can‚Äôt declare without a value:\n\n7. Use instead of loops\n\nLoops can get costly performance-wise because you repeat the same operation over and over again. However, if you optimize them, you can make them run faster.\n\nThere are many JavaScript best practices to write more performant loops, such as avoiding nesting, keeping DOM manipulation outside of loops, and declaring a separate variable for the length of the loop (e.g. ).\n\nUsing the statement instead of is such a JavaScript coding practice, too. This syntax has been introduced by ECMAScript 6, and it includes a built-in iterator so that you don‚Äôt have to define the variable and the length value:\n\nYou can use the loop to iterate over any iterable object, such as arrays, strings, nodelists, maps, and more.\n\nThe topic of modularization comes up frequently in discussions of JavaScript best practices. Modularization means the splitting of larger files into smaller parts ‚Äî a.k.a. reusable modules. ECMAScript modules and module bundlers such as Webpack help with setting up such architecture, but creating modular and reusable functions is just as important.\n\nAs the first SOLID design principle (single responsibility principle) states, every function, interface, class, and other code structure should perform only one task. Creating helper functions for common tasks is one way to follow this principle. Helper functions should be context-independent so that they can be called from any module.\n\nTo see some JavaScript functionality examples, check out The Vanilla JS Toolkit that includes smart helper functions such as , , , , and others. For example, here‚Äôs the function ‚Äî as you can see, it performs one single action:\n\nUsing classes is another hot topic in JavaScript programming. Even though JavaScript has a prototypical inheritance model, ECMAScript 6 has introduced the class syntax to improve code readability. It‚Äôs frequently referred to as ‚Äúsyntactic sugar‚Äù as it doesn‚Äôt add any new functionality, and, as stated by the MDN Docs, classes are ‚Äúbeing converted into Prototypal Inheritance models‚Äù under the hood.\n\nSo whether you use classes or not mainly depends on your preferences and project requirements ‚Äî but if you do decide to use the class syntax, there are, of course, some JavaScript best practices to follow.\n\nFirst and foremost, you need to avoid creating irrelevant classes to build a well-structured application. Classes can be irrelevant for a couple of reasons, including:\n‚Ä¢ Catch-all classes that do more than one thing (or everything)\n‚Ä¢ Classes that only have data (properties) but no actions (methods) ‚Äî try to move the data into another class\n‚Ä¢ Classes that only include behavior (methods) but no data (properties) ‚Äî in this case, it‚Äôs better to create a function\n\nOverall, classes should respect the single responsibility principle (similar to functions) and include both data and behavior, for example:\n\n10. Pay attention to (the lack of) hoisting when using classes\n\nIn JavaScript, classes are a special type of function, but they don‚Äôt always behave like ordinary functions, which can lead to some confusion.\n\nFor instance, unlike functions, classes are not hoisted. Hoisting means that the JavaScript interpreter moves function declarations to the top of their scope so that they can be called before being declared. When working with classes, you can‚Äôt take advantage of this feature, however.\n\nYou always need to declare a class before you call it, otherwise you‚Äôll get an uncaught reference error. Following the previous example with the class:\n\nThe JavaScript coding practices discussed above can help you write cleaner and better-structured code that‚Äôs easier to maintain and debug. However, creating development code is just the first step of the software life cycle.\n\nEven if you‚Äôre diligently following these JavaScript best practices, errors can (and will) still occur when your end-users interact with your application. To ensure your users experience your code as intended, you need to detect and address errors in production. With JavaScript error tracking, you can take care of errors on the production side, monitoring your application in real-time, catching errors as they happen, and taking immediate action."
    },
    {
        "link": "https://medium.com/@lokesh-prajapati/day-18-javascript-best-practices-writing-clean-maintainable-code-87c78fe58b9c",
        "document": "Poorly named variables can make your code hard to understand. Use clear and meaningful names that describe their purpose.\n\n‚úÖ Tip: Use camelCase for variables ( ), PascalCase for classes ( ), and UPPER_CASE for constants ( )."
    },
    {
        "link": "https://quora.com/What-are-the-JavaScript-best-practices-for-readable-and-maintainable-code",
        "document": "Something went wrong. Wait a moment and try again."
    },
    {
        "link": "https://dev.to/dinhhuyams/10-tips-to-improve-readability-in-javascript-53a3",
        "document": "üëâ If you try the , you will get the trace which means that it is easier to debug the code\n\nLet's try other console functions yourself :)\n\nüòï It is hard to read double negatives\n\nüòï You don't know what the flag params are used for util you have to read the function declaration\n\nüê® Easy to understand\n\n üê® Reusable\n\n üê® A long descriptive name is better than a long comment\n\n\n\nHonestly, I love switch as well and I don't actually know when to use switch statement vs object literals. My feeling just tells me which one to go.\n\nCheck out these 2 blogs and decide which one is better for you\n\nüê® Nothing is free. The code trades the ability to change requirements for reduced duplication, and it is not a good trade - Dan Abramov\n\nThe code below is used to fetch an order and I am using Redux for the state management. What a boilerplate!!! Let's make an abstraction which I will regret later\n\nI dare you understand the abstraction code without clicking the link. And even go to that link, you have to read all the code to understand that abstraction.\n\nIf you want to take a deep look into this, checkout AHA Programming and Goodbye, Clean Code"
    },
    {
        "link": "https://reddit.com/r/learnprogramming/comments/eyt9sm/readability_best_practices_in_javascript_codewars",
        "document": "Mainly code in Python/SQL in my day job, doing a CodeWars challenge a day to familiarise myself with JavaScript on the side.\n\nDid a challenge where you have to return a string of alphabet positions given a text string, and given this could be something that could easily start to get a bit messy in terms of readability (and as useful as that website is im not sure its something they really prioritise) I was wondering if anyone here had any ideas as to what the best practices are in terms of readability conventions in JavaScript?"
    },
    {
        "link": "https://google.github.io/styleguide/jsguide.html",
        "document": "Please note: This guide is no longer being updated. Google recommends migrating to TypeScript, and following the TypeScript guide.\n\nThis document serves as the complete definition of Google‚Äôs coding standards for source code in the JavaScript programming language. A JavaScript source file is described as being in Google Style if and only if it adheres to the rules herein.\n\nLike other programming style guides, the issues covered span not only aesthetic issues of formatting, but other types of conventions or coding standards as well. However, this document focuses primarily on the hard-and-fast rules that we follow universally, and avoids giving advice that isn't clearly enforceable (whether by human or tool).\n\nIn this document, unless otherwise clarified:\n‚Ä¢ None The term comment always refers to implementation comments. We do not use the phrase , instead using the common term ‚ÄúJSDoc‚Äù for both human-readable text and machine-readable annotations within .\n‚Ä¢ None This Style Guide uses RFC 2119 terminology when using the phrases must, must not, should, should not, and may. The terms prefer and avoid correspond to should and should not, respectively. Imperative and declarative statements are prescriptive and correspond to must.\n\nOther will appear occasionally throughout the document.\n\nExample code in this document is non-normative. That is, while the examples are in Google Style, they may not illustrate the only stylish way to represent the code. Optional formatting choices made in examples must not be enforced as rules.\n\nFile names must be all lowercase and may include underscores ( ) or dashes ( ), but no additional punctuation. Follow the convention that your project uses. Filenames‚Äô extension must be .\n\nAside from the line terminator sequence, the ASCII horizontal space character (0x20) is the only whitespace character that appears anywhere in a source file. This implies that\n‚Ä¢ None All other whitespace characters in string literals are escaped, and\n‚Ä¢ None Tab characters are not used for indentation.\n\nFor any character that has a special escape sequence ( , , , , , , , , ), that sequence is used rather than the corresponding numeric escape (e.g , , or ). Legacy octal escapes are never used.\n\nFor the remaining non-ASCII characters, either the actual Unicode character (e.g. ) or the equivalent hex or Unicode escape (e.g. ) is used, depending only on which makes the code easier to read and understand.\n\nTip: In the Unicode escape case, and occasionally even when actual Unicode characters are used, an explanatory comment can be very helpful.\n\nTip: Never make your code less readable simply out of fear that some programs might not handle non-ASCII characters properly. If that happens, those programs are broken and they must be fixed.\n\nAll new source files should either be a file (a file containing a call) or an ECMAScript (ES) module (uses and statements).\n\nFiles consist of the following, in order:\n\nExactly one blank line separates each section that is present, except the file's implementation, which may be preceded by 1 or 2 blank lines.\n\nIf license or copyright information belongs in a file, it belongs here.\n\nAll files must declare exactly one name on a single line: lines containing a declaration must not be wrapped, and are therefore an exception to the 80-column limit.\n\nThe entire argument to is what defines a namespace. It is the package name (an identifier that reflects the fragment of the directory structure where the code lives) plus, optionally, the main class/enum/interface that it defines concatenated to the end in .\n\nModule namespaces may never be named as a direct child of another module's namespace.\n\nThe directory hierarchy reflects the namespace hierarchy, so that deeper-nested children are subdirectories of higher-level parent directories. Note that this implies that owners of ‚Äúparent‚Äù namespace groups are necessarily aware of all child namespaces, since they exist in the same directory.\n\nThe single statement may optionally be followed by a call to . Avoid when possible.\n\nexists to ease the transition from traditional object hierarchy-based namespaces but comes with some naming restrictions. As the child module name must be created after the parent namespace, this name must not be a child or parent of any other (for example, and cannot both exist safely, nor can and ).\n\nClasses, enums, functions, constants, and other symbols are exported using the object. Exported symbols may be defined directly on the object, or else declared locally and exported separately. Symbols are only exported if they are meant to be used outside the module. Non-exported module-local symbols are not declared . There is no prescribed ordering for exported and module-local symbols.\n\nDo not annotate the object as as it is already treated as a constant by the compiler.\n\nDo not use default exports as they don't translate easily to ES module semantics.\n\nES modules are files that use the and keywords.\n\nImport statements must not be line wrapped and are therefore an exception to the 80-column limit.\n\nES module files must use the statement to import other ES module files. Do not another ES module.\n\nThe file extension is not optional in import paths and must always be included.\n\nDo not import the same file multiple times. This can make it hard to determine the aggregate imports of a file.\n\nModule import names ( ) are names that are derived from the imported file name.\n\nSome libraries might commonly use a namespace import prefix that violates this naming scheme, but overbearingly common open source use makes the violating style more readable. The only library that currently falls under this exception is threejs, using the prefix.\n\nDefault import names are derived from the imported file name and follow the rules in ??.\n\nNote: In general this should not happen as default exports are banned by this style guide, see ??. Default imports are only used to import modules that do not conform to this style guide.\n\nIn general symbols imported via the named import ( ) should keep the same name. Avoid aliasing imports ( ). Prefer fixing name collisions by using a module import ( ) or renaming the exports themselves.\n\nIf renaming a named import is needed then use components of the imported module's file name or path in the resulting alias.\n\nSymbols are only exported if they are meant to be used outside the module. Non-exported module-local symbols are not declared . There is no prescribed ordering for exported and module-local symbols.\n\nUse named exports in all code. You can apply the keyword to a declaration, or use the syntax.\n\nDo not use default exports. Importing modules must give a name to these values, which can lead to inconsistencies in naming across modules.\n\nExported variables must not be mutated outside of module initialization.\n\nThere are alternatives if mutation is needed, including exporting a constant reference to an object that has mutable fields or exporting accessor functions for mutable data.\n\nstatements must not be line wrapped and are therefore an exception to the 80-column limit. This applies to both flavors.\n\nDo not create cycles between ES modules, even though the ECMAScript specification allows this. Note that it is possible to create cycles with both the and statements.\n\nexports only a subset of properties from the global that can be used in ES modules.\n\nin ES modules works as it does in files. You can require any Closure namespace symbol (i.e., symbols created by or ) and will return the value.\n\ncan be used within ES modules to declare a -like module ID. This means that this module ID can be d, d etc. as if it were a that did not call . It does not create the module ID as a globally available JavaScript symbol.\n\nA (or ) for a module ID from will always return the module object (as if it was 'd). As a result, the argument to should always end with a .\n\nNote: It is an error to call in an ES module, it can only be called from files. There is no direct way to associate a namespace with an ES module.\n\nshould only be used to upgrade Closure files to ES modules in place, where named exports are used.\n\nIn a file the statement and, if present, statement may optionally be followed by a call to .\n\nIn an ES module the statements may optionally be followed by a call to .\n\nImports are done with and statements. The names imported by a statement may be used both in code and in type annotations, while those imported by a may be used in type annotations only.\n\nThe and statements form a contiguous block with no empty lines. This block follows the declaration separated by a single empty line. The entire argument to or is a namespace defined by a in a separate file. and statements may not appear anywhere else in the file.\n\nEach or is assigned to a single constant alias, or else destructured into several constant aliases. These aliases are the only acceptable way to refer to dependencies in type annotations or code. Fully qualified namespaces must not be used anywhere, except as an argument to or .\n\nException: Types, variables, and functions declared in externs files have to use their fully qualified name in type annotations and code.\n\nWhen is assigned to a single constant alias, it must match the final dot-separated component of the imported module's namespace.\n\nException: In certain cases, additional components of the namespace can be used to form a longer alias. The resulting alias must retain the original identifier's casing such that it still correctly identifies its type. Longer aliases may be used to disambiguate otherwise identical aliases, or if it significantly improves readability. In addition, a longer alias must be used to prevent masking native types such as , , , , and (for a more complete list, see Standard Built-in Objects and Web APIs at MDN).\n\nWhen renaming destructured aliases, a space must follow the colon as required in ??\n\nA file should not contain both a and a statement for the same namespace. If the imported name is used both in code and in type annotations, it should be imported by a single statement.\n\nIf a module is imported only for its side effects, the call must be a (not a ) and assignment may be omitted. A comment is required to explain why this is needed and suppress a compiler warning.\n\nThe lines are sorted according to the following rules: All requires with a name on the left hand side come first, sorted alphabetically by those names. Then destructuring requires, again sorted by the names on the left hand side. Finally, any require calls that are standalone (generally these are for modules imported just for their side effects).\n\nTip: There‚Äôs no need to memorize this order and enforce it manually. You can rely on your IDE to report requires that are not sorted correctly.\n\nIf a long alias or module name would cause a line to exceed the 80-column limit, it must not be wrapped: require lines are an exception to the 80-column limit.\n\nThe actual implementation follows after all dependency information is declared (separated by at least one blank line).\n\nThis may consist of any module-local declarations (constants, variables, classes, functions, etc), as well as any exported symbols.\n\nTerminology Note: block-like construct refers to the body of a class, function, method, or brace-delimited block of code. Note that, by ?? and ??, any array or object literal may optionally be treated as if it were a block-like construct.\n\nTip: Use . The JavaScript community has invested effort to make sure clang-format does the right thing on JavaScript files. has integration with several popular editors.\n\n4.1.1 Braces are used for all control structures\n\nBraces are required for all control structures (i.e. , , , , , as well as any others), even if the body contains only a single statement. The first statement of a non-empty block must begin on its own line.\n\nException: A simple if statement that can fit entirely on a single line with no wrapping (and that doesn‚Äôt have an else) may be kept on a single line with no braces when it improves readability. This is the only case in which a control structure may omit braces and newlines.\n\nBraces follow the Kernighan and Ritchie style ( ) for nonempty blocks and block-like constructs:\n‚Ä¢ No line break before the opening brace.\n‚Ä¢ Line break after the closing brace if that brace terminates a statement or the body of a function or class statement, or a class method. Specifically, there is no line break after the brace if it is followed by , , , or a comma, semicolon, or right-parenthesis.\n\nAn empty block or block-like construct may be closed immediately after it is opened, with no characters, space, or line break in between (i.e. ), unless it is a part of a multi-block statement (one that directly contains multiple blocks: / or / / ).\n\nEach time a new block or block-like construct is opened, the indent increases by two spaces. When the block ends, the indent returns to the previous indent level. The indent level applies to both code and comments throughout the block. (See the example in ??).\n\nAny array literal may optionally be formatted as if it were a ‚Äúblock-like construct.‚Äù For example, the following are all valid (not an exhaustive list):\n\nOther combinations are allowed, particularly when emphasizing semantic groupings between elements, but should not be used only to reduce the vertical size of larger arrays.\n\nAny object literal may optionally be formatted as if it were a ‚Äúblock-like construct.‚Äù The same examples apply as ??. For example, the following are all valid (not an exhaustive list):\n\nClass literals (whether declarations or expressions) are indented as blocks. Do not add semicolons after methods, or after the closing brace of a class declaration (statements‚Äîsuch as assignments‚Äîthat contain class expressions are still terminated with a semicolon). For inheritance, the keyword is sufficient unless the superclass is templatized. Subclasses of templatized types must explicitly specify the template type in an JSDoc annotation, even if it is just passing along the same template name.\n\nWhen declaring an anonymous function in the list of arguments for a function call, the body of the function is indented two spaces more than the preceding indentation depth.\n\nAs with any other block, the contents of a switch block are indented +2.\n\nAfter a switch label, a newline appears, and the indentation level is increased +2, exactly as if a block were being opened. An explicit block may be used if required by lexical scoping. The following switch label returns to the previous indentation level, as if a block had been closed.\n\nA blank line is optional between a and the following case.\n\nEach statement is followed by a line-break.\n\nEvery statement must be terminated with a semicolon. Relying on automatic semicolon insertion is forbidden.\n\nJavaScript code has a column limit of 80 characters. Except as noted below, any line that would exceed this limit must be line-wrapped, as explained in ??.\n‚Ä¢ , and statements (see ?? and ??).\n‚Ä¢ ES module and statements (see ?? and ??).\n‚Ä¢ Lines where obeying the column limit is not possible or would hinder discoverability. Examples include:\n‚Ä¢ A long URL which should be clickable in source.\n‚Ä¢ A long string literal which may need to be copied or searched for wholly (e.g., a long file path).\n\nTerminology Note: Line wrapping is breaking a chunk of code into multiple lines to obey column limit, where the chunk could otherwise legally fit in a single line.\n\nThere is no comprehensive, deterministic formula showing exactly how to line-wrap in every situation. Very often there are several valid ways to line-wrap the same piece of code.\n\nNote: While the typical reason for line-wrapping is to avoid overflowing the column limit, even code that would in fact fit within the column limit may be line-wrapped at the author's discretion.\n\nTip: Extracting a method or local variable may solve the problem without the need to line-wrap.\n\nThe prime directive of line-wrapping is: prefer to break at a higher syntactic level.\n\nIn the preceding example, the syntactic levels from highest to lowest are as follows: assignment, division, function call, parameters, number constant.\n\nOperators are wrapped as follows:\n‚Ä¢ When a line is broken at an operator the break comes after the symbol. (Note that this is not the same practice used in Google style for Java.)\n‚Ä¢ This does not apply to the ( ), which is not actually an operator.\n‚Ä¢ A method or constructor name stays attached to the open parenthesis ( ) that follows it.\n‚Ä¢ A comma ( ) stays attached to the token that precedes it.\n‚Ä¢ A line break is never added between a return and the return value as this would change the meaning of the code.\n‚Ä¢ JSDoc annotations with type names break after . This is necessary as annotations with optional types (@const, @private, @param, etc) do not scan the next line.\n\nWhen line-wrapping, each line after the first (each continuation line) is indented at least +4 from the original line, unless it falls under the rules of block indentation.\n\nWhen there are multiple continuation lines, indentation may be varied beyond +4 as appropriate. In general, continuation lines at a deeper syntactic level are indented by larger multiples of 4, and two lines use the same indentation level if and only if they begin with syntactically parallel elements.\n\n?? addresses the discouraged practice of using a variable number of spaces to align certain tokens with previous lines.\n‚Ä¢ Between consecutive methods in a class or object literal\n‚Ä¢ Exception: A blank line between two consecutive properties definitions in an object literal (with no other code between them) is optional. Such blank lines are used as needed to create logical groupings of fields.\n‚Ä¢ Within method bodies, sparingly to create logical groupings of statements. Blank lines at the start or end of a function body are not allowed.\n‚Ä¢ Optionally before the first or after the last method in a class or object literal (neither encouraged nor discouraged).\n‚Ä¢ As required by other sections of this document (e.g. ??).\n\nMultiple consecutive blank lines are permitted, but never required (nor encouraged).\n\nUse of horizontal whitespace depends on location, and falls into three broad categories: leading (at the start of a line), trailing (at the end of a line), and internal. Leading whitespace (i.e., indentation) is addressed elsewhere. Trailing whitespace is forbidden.\n\nBeyond where required by the language or other style rules, and apart from literals, comments, and JSDoc, a single internal ASCII space also appears in the following places only.\n‚Ä¢ Separating any reserved word (such as , , or ) except for and , from an open parenthesis ( ) that follows it on that line.\n‚Ä¢ Separating any reserved word (such as or ) from a closing curly brace ( ) that precedes it on that line.\n‚Ä¢ Before any open curly brace ( ), with two exceptions:\n‚Ä¢ Before an object literal that is the first argument of a function or the first element in an array literal (e.g. ).\n‚Ä¢ In a template expansion, as it is forbidden by the language (e.g. valid: , invalid: ).\n‚Ä¢ On both sides of any binary or ternary operator.\n‚Ä¢ After a comma ( ) or semicolon ( ). Note that spaces are never allowed before these characters.\n‚Ä¢ After the colon ( ) in an object literal.\n‚Ä¢ On both sides of the double slash ( ) that begins an end-of-line comment. Here, multiple spaces are allowed, but not required.\n‚Ä¢ After an open-block comment character and on both sides of close characters (e.g. for short-form type declarations, casts, and parameter name comments: ; or ; or ).\n\nTerminology Note: Horizontal alignment is the practice of adding a variable number of additional spaces in your code with the goal of making certain tokens appear directly below certain other tokens on previous lines.\n\nThis practice is permitted, but it is generally discouraged by Google Style. It is not even required to maintain horizontal alignment in places where it was already used.\n\nHere is an example without alignment, followed by one with alignment. Both are allowed, but the latter is discouraged:\n\nTip: Alignment can aid readability, but it creates problems for future maintenance. Consider a future change that needs to touch just one line. This change may leave the formerly-pleasing formatting mangled, and that is allowed. More often it prompts the coder (perhaps you) to adjust whitespace on nearby lines as well, possibly triggering a cascading series of reformattings. That one-line change now has a This can at worst result in pointless busywork, but at best it still corrupts version history information, slows down reviewers and exacerbates merge conflicts.\n\nPrefer to put all function arguments on the same line as the function name. If doing so would exceed the 80-column limit, the arguments must be line-wrapped in a readable way. To save space, you may wrap as close to 80 as possible, or put each argument on its own line to enhance readability. Indentation should be four spaces. Aligning to the parenthesis is allowed, but discouraged. Below are the most common patterns for argument wrapping:\n\nOptional grouping parentheses are omitted only when the author and reviewer agree that there is no reasonable chance that the code will be misinterpreted without them, nor would they have made the code easier to read. It is not reasonable to assume that every reader has the entire operator precedence table memorized.\n\nDo not use unnecessary parentheses around the entire expression following , , , , , , , , or .\n\nThis section addresses implementation comments. JSDoc is addressed separately in ??.\n\nBlock comments are indented at the same level as the surrounding code. They may be in or -style. For multi-line comments, subsequent lines must start with * aligned with the on the previous line, to make comments obvious with no extra context.\n\nComments are not enclosed in boxes drawn with asterisks or other characters.\n\nDo not use JSDoc ( ) for implementation comments.\n\n‚ÄúParameter name‚Äù comments should be used whenever the value and method name do not sufficiently convey the meaning, and refactoring the method to be clearer is infeasible . Their preferred format is before the value with :\n\nFor consistency with surrounding code you may put them after the value without :\n\nJavaScript includes many dubious (and even dangerous) features. This section delineates which features may or may not be used, and any additional constraints on their use.\n\nLanguage features which are not discussed in this style guide may be used with no recommendations of their usage.\n\nDeclare all local variables with either or . Use by default, unless a variable needs to be reassigned. The keyword must not be used.\n\nEvery local variable declaration declares only one variable: declarations such as are not used.\n\n5.1.3 Declared when needed, initialized as soon as possible\n\nLocal variables are not habitually declared at the start of their containing block or block-like construct. Instead, local variables are declared close to the point they are first used (within reason), to minimize their scope, and initialized as soon as possible.\n\nJSDoc type annotations may be added either on the line above the declaration, or else inline before the variable name if no other JSDoc is present.\n\nMixing inline and JSDoc styles is not allowed: the compiler will only process the first JsDoc and the inline annotations will be lost.\n\nTip: There are many cases where the compiler can infer a templatized type but not its parameters. This is particularly the case when the initializing literal or constructor call does not include any values of the template parameter type (e.g., empty arrays, objects, s, or s), or if the variable is modified in a closure. Local variable type annotations are particularly helpful in these cases since otherwise the compiler will infer the template parameter as unknown.\n\nInclude a trailing comma whenever there is a line break between the final element and the closing bracket.\n\n5.2.2 Do not use the variadic constructor\n\nThe constructor is error-prone if arguments are added or removed. Use a literal instead.\n\nThis works as expected except for the third case: if is a whole number then is an array of size where all elements are . If is any other number, then an exception will be thrown, and if it is anything else then it will be a single-element array.\n\nExplicitly allocating an array of a given length using is allowed when appropriate.\n\nDo not define or use non-numeric properties on an array (other than ). Use a (or ) instead.\n\nArray literals may be used on the left-hand side of an assignment to perform destructuring (such as when unpacking multiple values from a single array or iterable). A final element may be included (with no space between the and the variable name). Elements should be omitted if they are unused.\n\nDestructuring may also be used for function parameters (note that a parameter name is required but ignored). Always specify as the default value if a destructured array parameter is optional, and provide default values on the left hand side:\n\nTip: For (un)packing multiple values into a function‚Äôs parameter or return, prefer object destructuring to array destructuring when possible, as it allows naming the individual elements and specifying a different type for each.\n\nArray literals may include the spread operator ( ) to flatten elements out of one or more other iterables. The spread operator should be used instead of more awkward constructs with . There is no space after the .\n\nInclude a trailing comma whenever there is a line break between the final property and the closing brace.\n\n5.3.2 Do not use the constructor\n\nWhile does not have the same problems as , it is still disallowed for consistency. Use an object literal ( or ) instead.\n\n5.3.3 Do not mix quoted and unquoted keys\n\nObject literals may represent either structs (with unquoted keys and/or symbols) or dicts (with quoted and/or computed keys). Do not mix these key types in a single object literal.\n\nThis also extends to passing the property name to functions, like . In particular, doing so will break in compiled code because the compiler cannot rename/obfuscate the string literal.\n\nThis is best implemented as:\n\nComputed property names (e.g., ) are allowed, and are considered dict-style (quoted) keys (i.e., must not be mixed with non-quoted keys) unless the computed property is a symbol (e.g., ). Enum values may also be used for computed keys, but should not be mixed with non-enum keys in the same literal.\n\nMethods can be defined on object literals using the method shorthand ( ) in place of a colon immediately followed by a or arrow function literal.\n\nNote that in a method shorthand or refers to the object literal itself whereas in an arrow function refers to the scope outside the object literal.\n\nObject destructuring patterns may be used on the left-hand side of an assignment to perform destructuring and unpack multiple values from a single object.\n\nDestructured objects may also be used as function parameters, but should be kept as simple as possible: a single level of unquoted shorthand properties. Deeper levels of nesting and computed properties may not be used in parameter destructuring. Specify any default values in the left-hand-side of the destructured parameter ( , rather than ), and if a destructured object is itself optional, it must default to . The JSDoc for the destructured parameter may be given any name (the name is unused but is required by the compiler).\n\nDestructuring may also be used for statements, and in this case must not be wrapped: the entire statement occupies one line, regardless of how long it is (see ??).\n\nEnumerations are defined by adding the annotation to an object literal. Enums must be module-local or assigned directly on , not nested under a type or object.\n\nAdditional properties may not be added to an enum after it is defined. Enums must be constant. All enum values must be either a string literal or a number.\n\nFor string enums, all values must be statically initialized and not computed using arithmetic operators, template literal substitution, function calls or even a variable reference.\n\nNote: Although TypeScript supports a few more patterns for enum values (e.g , etc), the restriction of only allowing string literals and numbers for enum values is to aid migration to TypeScript. For complex values consider using a const object without .\n\nConstructors are optional. Subclass constructors must call before setting any fields or otherwise accessing . Interfaces should declare non-method properties in the constructor.\n\nDefine all of a concrete object‚Äôs fields (i.e. all properties other than methods) in the constructor. Annotate fields that are never reassigned with (these need not be deeply immutable). Annotate non-public fields with the proper visibility annotation ( , , ). fields' names may optionally end with an underscore. Fields must not be defined within a nested scope in the constructor nor on a concrete class's .\n\nTip: Properties should never be added to or removed from an instance after the constructor is finished, since it significantly hinders VMs‚Äô ability to optimize. If necessary, fields that are initialized later should be explicitly set to in the constructor to prevent later shape changes. Adding to an object will check that undeclared properties are not added/accessed. Classes have this added by default.\n\nComputed properties may only be used in classes when the property is a symbol. Dict-style properties (that is, quoted or computed non-symbol keys, as defined in ??) are not allowed. A method should be defined for any classes that are logically iterable. Beyond this, should be used sparingly.\n\nTip: be careful of using any other built-in symbols (e.g., ) as they are not polyfilled by the compiler and will therefore not work in older browsers.\n\nWhere it does not interfere with readability, prefer module-local functions over private static methods.\n\nCode should not rely on dynamic dispatch of static methods, because it interferes with Closure Compiler optimizations. Static methods should only be called on the base class itself. Static methods should not be called on variables containing a dynamic instance that may be either the constructor or a subclass constructor (and must be defined with if this is done), and must not be called directly on a subclass that doesn‚Äôt define the method itself. Do not access in static methods.\n\nWhile ES6 classes are preferred, there are cases where ES6 classes may not be feasible. For example:\n‚Ä¢ None If there exist or will exist subclasses, including frameworks that create subclasses, that cannot be immediately changed to use ES6 class syntax. If such a class were to use ES6 syntax, all downstream subclasses not using ES6 class syntax would need to be modified.\n‚Ä¢ None Frameworks that require a known value before calling the superclass constructor, since constructors with ES6 super classes do not have access to the instance value until the call to returns.\n\nIn all other ways the style guide still applies to this code: , , default parameters, rest, and arrow functions should all be used when appropriate.\n\nallows for a class-like definition similar to ES6 class syntax:\n\nAlternatively, while should be preferred for all new code, more traditional syntax is also allowed.\n\nPer-instance properties should be defined in the constructor after the call to the super class constructor, if there is a super class. Methods should be defined on the prototype of the constructor.\n\nDefining constructor prototype hierarchies correctly is harder than it first appears! For that reason, it is best to use from the Closure Library .\n\nThe keyword allows clearer and more readable class definitions than defining properties. Ordinary implementation code has no business manipulating these objects, though they are still useful for defining classes as defined in ??. Mixins and modifying the prototypes of builtin objects are explicitly forbidden.\n\nException: Framework code (such as Polymer, or Angular) may need to use s, and should not resort to even-worse workarounds to avoid doing so.\n\nDo not use JavaScript getter and setter properties. They are potentially surprising and difficult to reason about, and have limited support in the compiler. Provide ordinary methods instead.\n\nException: there are situations where defining a getter or setter is unavoidable (e.g. data binding frameworks such as Angular and Polymer, or for compatibility with external APIs that cannot be adjusted). In these cases only, getters and setters may be used with caution, provided they are defined with the and shorthand method keywords or (not , which interferes with property renaming). Getters must not change observable state.\n\nThe method may be overridden, but must always succeed and never have visible side effects.\n\nTip: Beware, in particular, of calling other methods from toString, since exceptional conditions could lead to infinite loops.\n\nInterfaces may be declared with or . Interfaces declared with can be explicitly (i.e. via ) or implicitly implemented by a class or object literal.\n\nAll methods on an interface must be non-static and method bodies must be empty blocks. Fields must be declared as uninitialized members in the class constructor.\n\nUse abstract classes when appropriate. Abstract classes and methods must be annotated with . Do not use . See abstract classes and methods.\n\nDo not use container classes with only static methods or properties for the sake of namespacing.\n\nDo not define a nested type (e.g. class, typedef, enum, interface) on another module-local name.\n\nThese values should be top-level exports. Choose clear names for these values (e.g. FooConverter for a Converter that could have been nested on Foo). However, when the module name is redundant with part of the class name, consider omitting the redundancy: and rather than and . Importers can add the prefix when necessary for clarity (e.g. ) but cannot easily remove the redundancy when importing the entire module as a namespace.\n\nTop-level functions may be defined directly on the object, or else declared locally and optionally exported. See ?? for more on exports.\n\nFunctions may contain nested function definitions. If it is useful to give the function a name, it should be assigned to a local .\n\nArrow functions provide a concise function syntax and simplify scoping for nested functions. Prefer arrow functions over the keyword for nested functions (but see ??).\n\nPrefer arrow functions over other scoping approaches such as , , and . Arrow functions are particularly useful for calling into callbacks as they permit explicitly specifying which parameters to pass to the callback whereas binding will blindly pass along all parameters.\n\nThe left-hand side of the arrow contains zero or more parameters. Parentheses around the parameters are optional if there is only a single non-destructured parameter. When parentheses are used, inline parameter types may be specified (see ??).\n\nTip: Always using parentheses even for single-parameter arrow functions can avoid situations where adding parameters, but forgetting to add parentheses, may result in parseable code which no longer works as intended.\n\nThe right-hand side of the arrow contains the body of the function. By default the body is a block statement (zero or more statements surrounded by curly braces). The body may also be an implicitly returned single expression if either: the program logic requires returning a value, or the operator precedes a single function or method call (using ensures is returned, prevents leaking values, and communicates intent). The single expression form is preferred if it improves readability (e.g., for short or simple expressions).\n\nGenerators enable a number of useful abstractions and may be used as needed.\n\nWhen defining generator functions, attach the to the keyword when present, and separate it with a space from the name of the function. When using delegating yields, attach the to the keyword.\n\nFunction parameters and return types should usually be documented with JSDoc annotations. See ?? for more information.\n\nOptional parameters are permitted using the equals operator in the parameter list. Optional parameters must include spaces on both sides of the equals operator, be named exactly like required parameters (i.e., not prefixed with ), use the suffix in their JSDoc type, come after required parameters, and not use initializers that produce observable side effects. All optional parameters for concrete functions must have default values, even if that value is . In contrast to concrete functions, abstract and interface methods must omit default parameter values.\n\nUse default parameters sparingly. Prefer destructuring (as in ??) to create readable APIs when there are more than a small handful of optional parameters that do not have a natural order.\n\nNote: Unlike Python's default parameters, it is okay to use initializers that return new mutable objects (such as or ) because the initializer is evaluated each time the default value is used, so a single object won't be shared across invocations.\n\nTip: While arbitrary expressions including function calls may be used as initializers, these should be kept as simple as possible. Avoid initializers that expose shared mutable state, as that can easily introduce unintended coupling between function calls.\n\nUse a rest parameter instead of accessing . Rest parameters are typed with a prefix in their JSDoc. The rest parameter must be the last parameter in the list. There is no space between the and the parameter name. Do not name the rest parameter . Never name a local variable or parameter , which confusingly shadows the built-in name.\n\nDeclare generic functions and methods when necessary with in the JSDoc above the function or method definition.\n\nFunction calls may use the spread operator ( ). Prefer the spread operator to when an array or iterable is unpacked into multiple parameters of a variadic function. There is no space after the .\n\nOrdinary string literals are delimited with single quotes ( ), rather than double quotes ( ).\n\nTip: if a string contains a single quote character, consider using a template string to avoid having to escape the quote.\n\nUse template literals (delimited with ) over complex string concatenation, particularly if multiple string literals are involved. Template literals may span multiple lines.\n\nIf a template literal spans multiple lines, it does not need to follow the indentation of the enclosing block, though it may if the added whitespace does not matter.\n\nDo not use line continuations (that is, ending a line inside a string literal with a backslash) in either ordinary or template string literals. Even though ES5 allows this, it can lead to tricky errors if any trailing whitespace comes after the slash, and is less obvious to readers.\n\nNumbers may be specified in decimal, hex, octal, or binary. Use exactly , , and prefixes, with lowercase letters, for hex, octal, and binary, respectively. Never include a leading zero unless it is immediately followed by , , or .\n\nWith ES6, the language now has three different kinds of loops. All may be used, though - loops should be preferred when possible.\n\n- loops may only be used on dict-style objects (see ??), and should not be used to iterate over an array. should be used in - loops to exclude unwanted prototype properties. Prefer - and over - when possible.\n\nExceptions are an important part of the language and should be used whenever exceptional cases occur. Always throw s or subclasses of : never throw string literals or other objects. Always use when constructing an .\n\nThis treatment extends to rejection values as is equivalent to in async functions.\n\nCustom exceptions provide a great way to convey additional error information from functions. They should be defined and used wherever the native type is insufficient.\n\nPrefer throwing exceptions over ad-hoc error-handling approaches (such as passing an error container reference type, or returning an object with an error property).\n\nIt is very rarely correct to do nothing in response to a caught exception. When it truly is appropriate to take no action whatsoever in a catch block, the reason this is justified is explained in a comment.\n\nTip: Unlike in some other languages, patterns like the above simply don‚Äôt work since this will catch the error thrown by . Use instead.\n\nTerminology Note: Inside the braces of a switch block are one or more statement groups. Each statement group consists of one or more switch labels (either or ), followed by one or more statements.\n\nWithin a switch block, each statement group either terminates abruptly (with a , or n exception), or is marked with a comment to indicate that execution will or might continue into the next statement group. Any comment that communicates the idea of fall-through is sufficient (typically ). This special comment is not required in the last statement group of the switch block.\n\nEach switch statement includes a statement group, even if it contains no code. The statement group must be last.\n\nOnly use in class constructors and methods, in arrow functions defined within class constructors and methods, or in functions that have an explicit declared in the immediately-enclosing function‚Äôs JSDoc.\n\nNever use to refer to the global object, the context of an , the target of an event, or unnecessarily ed or ed functions.\n\nUse identity operators ( / ) except in the cases documented below.\n\nDo not use the keyword. It makes your code harder to understand and has been banned in strict mode since ES5.\n\nDo not use or the constructor (except for code loaders). These features are potentially dangerous and simply do not work in CSP environments.\n\nAlways terminate statements with semicolons (except function and class declarations, as noted above).\n\nDo not use non-standard features. This includes old features that have been removed (e.g., ), new features that are not yet standardized (e.g., the current TC39 working draft, proposals at any stage, or proposed but not-yet-complete web standards), or proprietary features that are only implemented in some browsers. Use only features defined in the current ECMA-262 or WHATWG standards. (Note that projects writing against specific APIs, such as Chrome extensions or Node.js, can obviously use those APIs). Non-standard language ‚Äúextensions‚Äù (such as those provided by some external transpilers) are forbidden.\n\nNever use on the primitive object wrappers ( , , , ), nor include them in type annotations.\n\nThe wrappers may be called as functions for coercing (which is preferred over using or concatenating the empty string) or creating symbols.\n\nNever modify builtin types, either by adding methods to their constructors or to their prototypes. Avoid depending on libraries that do this. Note that the JSCompiler‚Äôs runtime library will provide standards-compliant polyfills where possible; nothing else may modify builtin objects.\n\nDo not add symbols to the global object unless absolutely necessary (e.g. required by a third-party API).\n\nNever invoke a constructor in a statement without using parentheses .\n\nOmitting parentheses can lead to subtle mistakes. These two lines are not equivalent:\n\nIdentifiers use only ASCII letters and digits, and, in a small number of cases noted below, underscores and very rarely (when required by frameworks like Angular) dollar signs.\n\nGive as descriptive a name as possible, within reason. Do not worry about saving horizontal space as it is far more important to make your code immediately understandable by a new reader. Do not use abbreviations that are ambiguous or unfamiliar to readers outside your project, and do not abbreviate by deleting letters within a word.\n\nException: Variables that are in scope for 10 lines or fewer, including arguments that are not part of an exported API, may use short (e.g. single letter) variable names.\n\nPackage names are all . For example, , but not or .\n\nException: The package name may conform to TypeScript's path-based pattern. This is typically all lower case with underscores where present in filenames.\n\nClass, interface, record, and typedef names are written in . Unexported classes are simply locals: they are not marked .\n\nType names are typically nouns or noun phrases. For example, , , or . Additionally, interface names may sometimes be adjectives or adjective phrases instead (for example, ).\n\nMethod names are written in . Names for methods may optionally end with a trailing underscore.\n\nMethod names are typically verbs or verb phrases. For example, or . Getter and setter methods for properties are never required, but if they are used they should be named (or optionally or for booleans), or for setters.\n\nUnderscores may also appear in JsUnit test method names to separate logical components of the name. One typical pattern is , for example . There is no One Correct Way to name test methods.\n\nEnum names are written in , similar to classes, and should generally be singular nouns. Individual items within the enum are named in .\n\nConstant names use : all uppercase letters, with words separated by underscores. There is no reason for a constant to be named with a trailing underscore, since private static properties can be replaced by (implicitly private) module locals.\n\nEvery constant is a static property or a module-local declaration, but not all static properties and module-local s are constants. Before choosing constant case, consider whether the field really feels like a deeply immutable constant. For example, if any of that instance's observable state can change, it is almost certainly not a constant. Merely intending to never mutate the object is generally not enough.\n\nLocal aliases should be used whenever they improve readability over fully-qualified names. Follow the same rules as s (??), maintaining the last part of the aliased name. Aliases may also be used within functions. Aliases must be .\n\nNon-constant field names (static or otherwise) are written in , with an optional trailing underscore for private fields.\n\nThese names are typically nouns or noun phrases. For example, or .\n\nParameter names are written in . Note that this applies even if the parameter expects a constructor.\n\nOne-character parameter names should not be used in public methods.\n\nException: When required by a third-party framework, parameter names may begin with a . This exception does not apply to any other identifiers (e.g. local variables or properties).\n\nLocal variable names are written in , except for module-local (top-level) constants, as described above. Constants in function scopes are still named in . Note that is used even if the variable holds a constructor.\n\nTemplate parameter names should be concise, single-word or single-letter identifiers, and must be all-caps, such as or .\n\nModule-local names that are not exported are implicitly private. They are not marked . This applies to classes, functions, variables, constants, enums, and other module-local identifiers.\n\nSometimes there is more than one reasonable way to convert an English phrase into camel case, such as when acronyms or unusual constructs like or are present. To improve predictability, Google Style specifies the following (nearly) deterministic scheme.\n\nBeginning with the prose form of the name:\n‚Ä¢ Convert the phrase to plain ASCII and remove any apostrophes. For example, might become .\n‚Ä¢ Divide this result into words, splitting on spaces and any remaining punctuation (typically hyphens).\n‚Ä¢ Recommended: if any word already has a conventional camel case appearance in common usage, split this into its constituent parts (e.g., becomes ). Note that a word such as is not really in camel case per se; it defies any convention, so this recommendation does not apply.\n‚Ä¢ Now lowercase everything (including acronyms), then uppercase only the first character of:\n‚Ä¢ ‚Ä¶ each word, to yield , or\n‚Ä¢ ‚Ä¶ each word except the first, to yield\n‚Ä¢ Finally, join all the words into a single identifier.\n\nNote that the casing of the original words is almost entirely disregarded.\n\nFor examples of , uppercase the first letter of each correct example.\n\nNote: Some words are ambiguously hyphenated in the English language: for example and are both correct, so the method names and are likewise both correct.\n\nJSDoc is used on all classes, fields, and methods.\n\nThe basic formatting of JSDoc blocks is as seen in this example:\n\nor in this single-line example:\n\nIf a single-line comment overflows into multiple lines, it must use the multi-line style with and on their own lines.\n\nMany tools extract metadata from JSDoc comments to perform code validation and optimization. As such, these comments must be well-formed.\n\nJSDoc is written in Markdown, though it may include HTML when necessary.\n\nNote that tools that automatically extract JSDoc (e.g. JsDossier) will often ignore plain text formatting, so if you did this:\n\nit would come out like this:\n\nGoogle style allows a subset of JSDoc tags. See ?? for the complete list. Most tags must occupy their own line, with the tag at the beginning of the line.\n\nSimple tags that do not require any additional data (such as , , , ) may be combined onto the same line, along with an optional type when appropriate.\n\nThere is no hard rule for when to combine tags, or in which order, but be consistent.\n\nFor general information about annotating types in JavaScript see Annotating JavaScript for the Closure Compiler and Types in the Closure Type System.\n\nLine-wrapped block tags are indented four spaces. Wrapped description text may be lined up with the description on previous lines, but this horizontal alignment is discouraged.\n\nDo not indent when wrapping a or description.\n\nA file may have a top-level file overview. A copyright notice, author information, and default visibility level are optional. File overviews are generally recommended whenever a file consists of more than a single class definition. The top level comment is designed to orient readers unfamiliar with the code to what is in this file. If present, it may provide a description of the file's contents and any dependencies or compatibility information. Wrapped lines are not indented.\n\nClasses, interfaces and records must be documented with a description and any template parameters, implemented interfaces, visibility, or other appropriate tags. The class description should provide the reader with enough information to know how and when to use the class, as well as any additional considerations necessary to correctly use the class. Textual descriptions may be omitted on the constructor. When defining a class and annotations are not used with the keyword unless it extends a generic class. When defining an or a , the annotation is used when defining a subclass and the keyword is never used.\n\nAll enums and typedefs must be documented with appropriate JSDoc tags ( or ) on the preceding line. Public enums and typedefs must also have a description. Individual enum items may be documented with a JSDoc comment on the preceding line.\n\nTypedefs are useful for defining short record types, or aliases for unions, complex functions, or generic types. Typedefs should be avoided for record types with many fields, since they do not allow documenting individual fields, nor using templates or recursive references. For large record types, prefer .\n\nIn methods and named functions, parameter and return types must be documented, even in the case of same-signature s. The type should be documented when necessary. Return type may be omitted if the function has no non-empty statements.\n\nMethod, parameter, and return descriptions (but not types) may be omitted if they are obvious from the rest of the method‚Äôs JSDoc or from its signature.\n\nMethod descriptions begin with a verb phrase that describes what the method does. This phrase is not an imperative sentence, but instead is written in the third person, as if there is an implied before it.\n\nIf a method overrides a superclass method, it must include an annotation. For overridden methods, all and annotations must be specified explicitly even if no type from the superclass method is refined. This is to align with TypeScript.\n\nIf you only need to document the param and return types of a function, you may optionally use inline JSDocs in the function's signature. These inline JSDocs specify the return and param types without tags.\n\nIf you need descriptions or tags, use a single JSDoc comment above the method. For example, methods which return values need a tag.\n\nIn anonymous functions annotations are generally optional. If the automatic type inference is insufficient or explicit annotation improves readability, then annotate param and return types like this:\n\nProperty types must be documented. The description may be omitted for private properties, if name and type provide enough documentation for understanding the code.\n\nPublicly exported constants are commented the same way as properties.\n\nType annotations are found on , , , and tags, and optionally on , , and any visibility tags. Type annotations attached to JSDoc tags must always be enclosed in braces.\n\nThe type system defines modifiers and for non-null and nullable, respectively. These modifiers must precede the type.\n\nNullability modifiers have different requirements for different types, which fall into two broad categories:\n‚Ä¢ Type annotations for primitives ( , , , , , ) and literals ( and ) are always non-nullable by default. Use the modifier to make it nullable, but omit the redundant .\n‚Ä¢ Reference types (generally, anything in , including ) refer to a class, enum, record, or typedef defined elsewhere. Since these types may or may not be nullable, it is impossible to tell from the name alone whether it is nullable or not. Always use explicit and modifiers for these types to prevent ambiguity at use sites.\n\nIn cases where the compiler doesn't accurately infer the type of an expression, and the assertion functions in goog.asserts cannot remedy it, it is possible to tighten the type by adding a type annotation comment and enclosing the expression in parentheses. Note that the parentheses are required.\n\nAlways specify template parameters. This way compiler can do a better job and it makes it easier for readers to understand what code does.\n\nCases when template parameters should not be used:\n‚Ä¢ is used for type hierarchy and not as map-like structure.\n\nTerminology Note: function type expression refers to a type annotation for function types with the keyword in the annotation (see examples below).\n\nWhere the function definition is given, do not use a function type expression. Specify parameter and return types with and , or with inline annotations (see ??). This includes anonymous functions and functions defined and assigned to a const (where the function jsdoc appears above the whole assignment expression).\n\nFunction type expressions are needed, for example, inside , or . Use it also for variables or properties of function type, if they are not immediately initialized with the function definition.\n\nWhen using a function type expression, always specify the return type explicitly. Otherwise the default return type is ( ), which leads to strange and unexpected behavior, and is rarely what is actually desired.\n\nBad - type error, but no warning given:\n\nWithin a type annotation, a single space or line break is required after each comma or colon. Additional line breaks may be inserted to improve readability or avoid exceeding the column limit. These breaks should be chosen and indented following the applicable guidelines (e.g. ?? and ??). No other whitespace is allowed in type annotations.\n\nVisibility annotations ( , , ) may be specified in a block, or on any exported symbol or property. Do not specify visibility for local variables, whether within a function or at the top level of a module. names may optionally end with an underscore.\n\nFor any style question that isn't settled definitively by this specification, prefer to do what the other code in the same file is already doing. If that doesn't resolve the question, consider emulating the other files in the same package.\n\nAs far as possible projects should use .\n\nBefore doing anything, make sure you understand exactly what the warning is telling you. If you're not positive why a warning is appearing, ask for help .\n\nOnce you understand the warning, attempt the following solutions in order:\n‚Ä¢ First, fix it or work around it. Make a strong attempt to actually address the warning, or find another way to accomplish the task that avoids the situation entirely.\n‚Ä¢ Otherwise, determine if it's a false alarm. If you are convinced that the warning is invalid and that the code is actually safe and correct, add a comment to convince the reader of this fact and apply the annotation.\n‚Ä¢ Otherwise, leave a TODO comment. This is a last resort. If you do this, do not suppress the warning. The warning should be visible until it can be taken care of properly.\n\nWarnings are suppressed at the narrowest reasonable scope, usually that of a single local variable or very small method. Often a variable or method is extracted for that reason alone.\n\nEven a large number of suppressions in a class is still better than blinding the entire class to this type of warning.\n\nMark deprecated methods, classes or interfaces with annotations. A deprecation comment must include simple, clear directions for people to fix their call sites.\n\nYou will occasionally encounter files in your codebase that are not in proper Google Style. These may have come from an acquisition, or may have been written before Google Style took a position on some issue, or may be in non-Google Style for any other reason.\n\nWhen updating the style of existing code, follow these guidelines.\n‚Ä¢ It is not required to change all existing code to meet current style guidelines. Reformatting existing code is a trade-off between code churn and consistency. Style rules evolve over time and these kinds of tweaks to maintain compliance would create unnecessary churn. However, if significant changes are being made to a file it is expected that the file will be in Google Style.\n‚Ä¢ Be careful not to allow opportunistic style fixes to muddle the focus of a CL. If you find yourself making a lot of style changes that aren‚Äôt critical to the central focus of a CL, promote those changes to a separate CL.\n\nBrand new files use Google Style, regardless of the style choices of other files in the same package.\n\nWhen adding new code to a file that is not in Google Style, reformatting the existing code first is recommended, subject to the advice in ??.\n\nIf this reformatting is not done, then new code should be as consistent as possible with existing code in the same file, but must not violate the style guide.\n\nTeams and projects may adopt additional style rules beyond those in this document, but must accept that cleanup changes may not abide by these additional rules, and must not block such cleanup changes due to violating any additional rules. Beware of excessive rules which serve no purpose. The style guide does not seek to define style in every possible scenario and neither should you.\n\nSource code generated by the build process is not required to be in Google Style. However, any generated identifiers that will be referenced from hand-written source code must follow the naming requirements. As a special exception, such identifiers are allowed to contain underscores, which may help to avoid conflicts with hand-written identifiers.\n\nJSDoc serves multiple purposes in JavaScript. In addition to being used to generate documentation it is also used to control tooling. The best known are the Closure Compiler type annotations.\n\nDocumentation for JSDoc used by the Closure Compiler is described in Annotating JavaScript for the Closure Compiler and Types in the Closure Type System.\n\nIn addition to the JSDoc described in Annotating JavaScript for the Closure Compiler the following tags are common and well supported by various documentation generation tools (such as JsDossier) for purely documentation purposes.\n\nYou may also see other types of JSDoc annotations in third-party code. These annotations appear in the JSDoc Toolkit Tag Reference but are not considered part of valid Google style.\n\nThe following annotations are specific to a particular framework.\n\nThe following tags used to be standard but are now deprecated.\n\nHere is a collection of lesser-known or commonly misunderstood facts about Google Style for JavaScript. (The following are true statements; this is not a list of )\n‚Ä¢ Neither a copyright statement nor credit is required in a source file. (Neither is explicitly recommended, either.)\n‚Ä¢ There is no rule governing how to order the members of a class (??).\n‚Ä¢ Empty blocks can usually be represented concisely as , as detailed in (??).\n‚Ä¢ The prime directive of line-wrapping is: prefer to break at a higher syntactic level (??).\n‚Ä¢ Non-ASCII characters are allowed in string literals, comments and JSDoc, and in fact are recommended when they make the code easier to read than the equivalent Unicode escape would (??).\n\nThe following tools exist to support various aspects of Google Style.\n\nThis program performs type checking and other checks, optimizations and other transformations (such as lowering code to ECMAScript 5).\n\nThis program reformats JavaScript source code into Google Style, and also follows a number of non-required but frequently readability-enhancing formatting practices. The output produced by is compliant with the style guide.\n\nis not required. Authors are allowed to change its output, and reviewers are allowed to ask for such changes; disputes are worked out in the usual way. However, subtrees may choose to opt in to such enforcement locally.\n\nThis program checks for a variety of missteps and anti-patterns.\n\nThe JS Conformance Framework is a tool that is part of the Closure Compiler that provides developers a simple means to specify a set of additional checks to be run against their code base above the standard checks. Conformance checks can, for example, forbid access to a certain property, or calls to a certain function, or missing type information (unknowns).\n\nThese rules are commonly used to enforce critical restrictions (such as defining globals, which could break the codebase) and security patterns (such as using or assigning to ), or more loosely to improve code quality.\n\nFor additional information see the official documentation for the JS Conformance Framework.\n\nThis section describes exceptions and additional rules to be followed when modern ECMAScript syntax is not available to the code authors. Exceptions to the recommended style are required when modern ECMAScript syntax is not possible and are outlined here:\n‚Ä¢ Use of declarations is allowed\n‚Ä¢ Use of is allowed\n\ndeclarations are scoped to the beginning of the nearest enclosing function, script or module, which can cause unexpected behavior, especially with function closures that reference declarations inside of loops. The following code gives an example:\n\n9.4.2.2 Declare variables as close as possible to first use\n\nEven though declarations are scoped to the beginning of the enclosing function, declarations should be as close as possible to their first use, for readability purposes. However, do not put a declaration inside a block if that variable is referenced outside the block. For example:\n\nFor global declarations where the keyword would be used, if it were available, annotate the declaration with instead (this is optional for local variables).\n\n9.4.3 Do not use block scoped functions declarations\n\nDo not do this:\n\nWhile most JavaScript VMs implemented before ECMAScript 6 support function declarations within blocks it was not standardized. Implementations were inconsistent with each other and with the now-standard ECMAScript behavior for block scoped function declaration. The ECMAScript 5 standard and prior only allow for function declarations in the root statement list of a script or function and explicitly ban them in block scopes in strict mode.\n\nTo get consistent behavior, instead use a initialized with a function expression to define a function within a block:\n\nWARNING: dependency management is deprecated. All new files, even in projects using for older files, should use . The following rules are for pre-existing files only.\n‚Ä¢ Place all s first, s second. Separate provides from requires with an empty line.\n‚Ä¢ Don't wrap and statements. Exceed 80 columns if necessary.\n\nstatements should be grouped together and placed first. All statements should follow. The two lists should be separated with an empty line.\n\nSimilar to import statements in other languages, and statements should be written in a single line, even if they exceed the 80 column line length limit.\n\nThe lines should be sorted alphabetically, with uppercase letters coming first:\n\nAll members defined on a class should be in the same file. Only top-level classes should be provided in a file that contains multiple members defined on the same class (e.g. enums, inner classes, etc).\n\nMembers on namespaces may also be provided:\n\nWARNING: is deprecated. New files should not use even in projects with existing usage.\n\nmay be used to shorten references to namespaced symbols in code using / dependency management.\n\nOnly one invocation may be added per file. Always place it in the global scope.\n\nThe opening invocation must be preceded by exactly one blank line and follow any statements, statements, or top-level comments. The invocation must be closed on the last line in the file. Append to the closing statement of the scope. Separate the comment from the semicolon by two spaces.\n\nSimilar to C++ namespaces, do not indent under declarations. Instead, continue from the 0 column.\n\nOnly make aliases for names that will not be re-assigned to another object (e.g., most constructors, enums, and namespaces). Do not do this (see below for how to alias a constructor):\n\nNames must be the same as the last property of the global that they are aliasing.\n\nPrefer to use instead of to break circular dependencies between files in the same library. Unlike , a statement is allowed to import a namespace before it is defined.\n\nstatements must follow the same style rules as and . The entire block of , and statements is sorted alphabetically.\n\nis used in legacy code to break circular references spanning across library boundaries. This pattern however is poorly supported by build tools and should not be used. Code should be organized to avoid circular dependencies across libraries (by splitting/merging libraries).\n\nIf a file depends on a file, the file can not normally refer to the module's exports via a global name. Instead, in addition to ing the module, the file must fetch the module's export object by calling .\n\nNote: Only calling does not create a build-time dependency of your code on the module. The is needed for the build dependency.\n\nWARNING: is only for transitional use.\n\nis only for use while migrating a JavaScript file and its consumers from to . Update consumers of your to use themselves. Remove calls to whenever possible.\n\nIf you can't update consumers of a legacy namespace from to soon, please wrap the contents of your file in a call to , use to import the legacy namespace--and then delete the call to in your .\n\nCalling inside a will declare the module's namespace as a global name just like a call does. This allows a non namespace to access the module's exports without calling ."
    },
    {
        "link": "http://w3schools.com/JS/js_conventions.asp",
        "document": "Always use the same coding conventions for all your JavaScript projects.\n\nCoding conventions are style guidelines for programming. They typically cover:\n‚Ä¢ Naming and declaration rules for variables and functions.\n‚Ä¢ Rules for the use of white space, indentation, and comments.\n\nCoding conventions can be documented rules for teams to follow, or just be your individual coding practice.\n\nAt W3schools we use camelCase for identifier names (variables and functions).\n\nAt the bottom of this page, you will find a wider discussion about naming rules.\n\nAlways put spaces around operators ( = + - * / ), and after commas:\n\nAlways use 2 spaces for indentation of code blocks:\n‚Ä¢ Put the opening bracket at the end of the first line.\n‚Ä¢ Use one space before the opening bracket.\n‚Ä¢ Put the closing bracket on a new line, without leading spaces.\n‚Ä¢ Do not end a complex statement with a semicolon.\n‚Ä¢ Place the opening bracket on the same line as the object name.\n‚Ä¢ Use colon plus one space between each property and its value.\n‚Ä¢ Use quotes around string values, not around numeric values.\n‚Ä¢ Do not add a comma after the last property-value pair.\n‚Ä¢ Place the closing bracket on a new line, without leading spaces.\n‚Ä¢ Always end an object definition with a semicolon.\n\nShort objects can be written compressed, on one line, using spaces only between properties, like this:\n\nIf a JavaScript statement does not fit on one line, the best place to break it, is after an operator or a comma.\n\nAlways use the same naming convention for all your code. For example:\n‚Ä¢ Global variables written in UPPERCASE (We don't, but it's quite common)\n\nShould you use hyp-hens, camelCase, or under_scores in variable names?\n\nThis is a question programmers often discuss. The answer depends on who you ask:\n\nMany programmers prefer to use underscores (date_of_birth), especially in SQL databases.\n\nUnderscores are often used in PHP documentation.\n\nPascalCase is often preferred by C programmers.\n\ncamelCase is used by JavaScript itself, by jQuery, and other JavaScript libraries.\n\nUse simple syntax for loading external scripts (the type attribute is not necessary):\n\nA consequence of using \"untidy\" HTML styles, might result in JavaScript errors.\n\nThese two JavaScript statements will produce different results:\n\nIf possible, use the same naming convention (as JavaScript) in HTML.\n\nHTML files should have a .html extension (.htm is allowed).\n\nMost web servers (Apache, Unix) are case sensitive about file names:\n\nlondon.jpg cannot be accessed as London.jpg.\n\nOther web servers (Microsoft, IIS) are not case sensitive:\n\nlondon.jpg can be accessed as London.jpg or london.jpg.\n\nIf you use a mix of upper and lower case, you have to be extremely consistent.\n\nIf you move from a case insensitive, to a case sensitive server, even small errors can break your web site.\n\nTo avoid these problems, always use lower case file names (if possible).\n\nCoding conventions are not used by computers. Most rules have little impact on the execution of programs.\n\nIndentation and extra spaces are not significant in small scripts.\n\nFor code in development, readability should be preferred. Larger production scripts should be minimized."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/MDN/Writing_guidelines/Writing_style_guide/Code_style_guide/JavaScript",
        "document": "Opinions on correct indentation, whitespace, and line lengths have always been controversial. Discussions on these topics are a distraction from creating and maintaining content. On MDN Web Docs, we use Prettier as a code formatter to keep the code style consistent (and to avoid off-topic discussions). You can consult our configuration file to learn about the current rules, and read the Prettier documentation. Prettier formats all the code and keeps the style consistent. Nevertheless, there are a few additional rules that you need to follow.\n\nWhen loops are required, choose the appropriate one from , , , etc.\n‚Ä¢ When iterating through all collection elements, avoid using the classical loop; prefer or . Note that if you are using a collection that is not an , you have to check that is actually supported (it requires the variable to be iterable), or that the method is actually present. Do not use ‚Äî not only do you have to add an extra index, , but you also have to track the length of the array. This can be error-prone for beginners.\n‚Ä¢ Make sure that you define the initializer properly by using the keyword for or for the other loops. Don't omit it. These are correct examples: const cats = [\"Athena\", \"Luna\"]; for (const cat of cats) { console.log(cat); } for (let i = 0; i < 4; i++) { result += arr[i]; } The example below does not follow the recommended guidelines for the initialization (it implicitly creates a global variable and will fail in strict mode):\n‚Ä¢ When you need to access both the value and the index, you can use instead of . Write: Warning: Never use with arrays and strings. Note: Consider not using a loop at all. If you are using an (or a for some operations), consider using more semantic iteration methods instead, like , , , , , and many more.\n‚Ä¢ Use short identifiers, and avoid non-common abbreviations. Good variable names are usually between 3 to 10-character long, but as a hint only. For example, is more descriptive than abbreviating to for the sake of character length.\n‚Ä¢ Try to use real-world relevant examples where each variable has clear semantics. Only fall back to placeholder names like and when the example is simple and contrived.\n‚Ä¢ Do not use the Hungarian notation naming convention. Do not prefix the variable name with its type. For example, write rather than or instead of .\n‚Ä¢ For collections, avoid adding the type such as list, array, queue in the name. Use the content name in the plural form. For example, for an array of cars, use and not or . There may be exceptions, like when you want to show the abstract form of a feature without the context of a particular application.\n‚Ä¢ For primitive values, use camelCase, starting with a lowercase character. Do not use . Use concise, human-readable, and semantic names where appropriate. For example, use rather than .\n‚Ä¢ Avoid using articles and possessives. For example, use instead of or . There may be exceptions, like when describing a feature in general without a practical context.\n‚Ä¢ Use variable names as shown here: Don't name variables like this: Note: The only place where it's allowed not to use human-readable, semantic names is where a very commonly recognized convention exists, such as using and for loop iterators."
    },
    {
        "link": "https://github.com/airbnb/javascript",
        "document": "This guide is available in other languages too. See Translation\n‚Ä¢ Chat With Us About JavaScript\n‚Ä¢ 1.1 Primitives: When you access a primitive type you work directly on its value.\n‚Ä¢ Symbols and BigInts cannot be faithfully polyfilled, so they should not be used when targeting browsers/environments that don‚Äôt support them natively.\n‚Ä¢ 1.2 Complex: When you access a complex type you work on a reference to its value.\n‚Ä¢ 2.1 Use for all of your references; avoid using . eslint: , Why? This ensures that you can‚Äôt reassign your references, which can lead to bugs and difficult to comprehend code.\n‚Ä¢ 2.2 If you must reassign references, use instead of . eslint: Why? is block-scoped rather than function-scoped like . // good, use the let.\n‚Ä¢ 2.3 Note that both and are block-scoped, whereas is function-scoped. // const and let only exist in the blocks they are defined in. In the above code, you can see that referencing and will produce a ReferenceError, while contains the number. This is because and are block scoped, while is scoped to the containing function.\n‚Ä¢ 3.1 Use the literal syntax for object creation. eslint:\n‚Ä¢ 3.2 Use computed property names when creating objects with dynamic property names. Why? They allow you to define all the properties of an object in one place.\n‚Ä¢ Why? It is shorter and descriptive.\n‚Ä¢ 3.5 Group your shorthand properties at the beginning of your object declaration. Why? It‚Äôs easier to tell which properties are using the shorthand.\n‚Ä¢ 3.6 Only quote properties that are invalid identifiers. eslint: Why? In general we consider it subjectively easier to read. It improves syntax highlighting, and is also more easily optimized by many JS engines.\n‚Ä¢ 3.7 Do not call methods directly, such as , , and . eslint: Why? These methods may be shadowed by properties on the object in question - consider - or, the object may be a null object ( ). In modern browsers that support ES2022, or with a polyfill such as https://npmjs.com/object.hasown, can also be used as an alternative to . // cache the lookup once, in module scope. // only supported in browsers that support ES2022\n‚Ä¢ 3.8 Prefer the object spread syntax over to shallow-copy objects. Use the object rest parameter syntax to get a new object with certain properties omitted. eslint: : : : // so does this : : : : : ... : a ...\n‚Ä¢ 4.1 Use the literal syntax for array creation. eslint:\n‚Ä¢ 4.2 Use Array#push instead of direct assignment to add items to an array.\n‚Ä¢ 4.4 To convert an iterable object to an array, use spreads instead of\n‚Ä¢ 4.5 Use for converting an array-like object to an array.\n‚Ä¢ 4.6 Use instead of spread for mapping over iterables, because it avoids creating an intermediate array.\n‚Ä¢ 4.7 Use return statements in array method callbacks. It‚Äôs ok to omit the return if the function body consists of a single statement returning an expression without side effects, following 8.2. eslint: // bad - no returned value means `acc` becomes undefined after the first iteration subject author subject author\n‚Ä¢ 4.8 Use line breaks after opening array brackets and before closing array brackets, if an array has multiple lines\n‚Ä¢ 5.1 Use object destructuring when accessing and using multiple properties of an object. eslint: Why? Destructuring saves you from creating temporary references for those properties, and from repetitive access of the object. Repeating object access creates more repetitive code, requires more reading, and creates more opportunities for mistakes. Destructuring objects also provides a single site of definition of the object structure that is used in the block, rather than requiring reading the entire block to determine what is used.\n‚Ä¢ 5.3 Use object destructuring for multiple return values, not array destructuring. Why? You can add new properties over time or change the order of things without breaking call sites. // the caller needs to think about the order of return data left right top bottom // the caller selects only the data they need left top\n‚Ä¢ // bad - template literals should contain interpolation or newlines\n‚Ä¢ 6.2 Strings that cause the line to go over 100 characters should not be written across multiple lines using string concatenation. Why? Broken strings are painful to work with and make code less searchable. 'This is a super long error that was thrown because \\ of Batman. When you stop to think about how Batman had anything to do \\ with this, you would get nowhere \\ 'This is a super long error that was thrown because ' 'of Batman. When you stop to think about how Batman had anything to do ' 'with this, you would get nowhere fast.' 'This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.'\n‚Ä¢ 6.3 When programmatically building up strings, use template strings instead of concatenation. eslint: Why? Template strings give you a readable, concise syntax with proper newlines and string interpolation features. 'How are you, ' 'How are you, ' `How are you, ?` `How are you, ?`\n‚Ä¢ 6.4 Never use on a string; it opens too many vulnerabilities. eslint:\n‚Ä¢ 6.5 Do not unnecessarily escape characters in strings. eslint: Why? Backslashes harm readability, thus they should only be present when necessary. `my name is ' '`\n‚Ä¢ 7.1 Use named function expressions instead of function declarations. eslint: , Why? Function declarations are hoisted, which means that it‚Äôs easy - too easy - to reference the function before it is defined in the file. This harms readability and maintainability. If you find that a function‚Äôs definition is large or complex enough that it is interfering with understanding the rest of the file, then perhaps it‚Äôs time to extract it to its own module! Don‚Äôt forget to explicitly name the expression, regardless of whether or not the name is inferred from the containing variable (which is often the case in modern browsers or when using compilers such as Babel). This eliminates any assumptions made about the Error‚Äôs call stack. (Discussion) // lexical name distinguished from the variable-referenced invocation(s)\n‚Ä¢ Why? An immediately invoked function expression is a single unit - wrapping both it, and its invocation parens, in parens, cleanly expresses this. Note that in a world with modules everywhere, you almost never need an IIFE. 'Welcome to the Internet. Please follow me.'\n‚Ä¢ 7.3 Never declare a function in a non-function block ( , , etc). Assign the function to a variable instead. Browsers will allow you to do it, but they all interpret it differently, which is bad news bears. eslint:\n‚Ä¢ 7.4 Note: ECMA-262 defines a as a list of statements. A function declaration is not a statement.\n‚Ä¢ 7.5 Never name a parameter . This will take precedence over the object that is given to every function scope.\n‚Ä¢ 7.6 Never use , opt to use rest syntax instead. eslint: Why? is explicit about which arguments you want pulled. Plus, rest arguments are a real Array, and not merely Array-like like .\n‚Ä¢ 7.7 Use default parameter syntax rather than mutating function arguments. // Double bad: if opts is falsy it'll be set to an object which may // be what you want but it can introduce subtle bugs.\n‚Ä¢ Why? They are confusing to reason about.\n‚Ä¢ 7.10 Never use the Function constructor to create a new function. eslint: Why? Creating a function in this way evaluates a string similarly to , which opens vulnerabilities.\n‚Ä¢ Why? Consistency is good, and you shouldn‚Äôt have to add or remove a space when adding or removing a name.\n‚Ä¢ Why? Manipulating objects passed in as parameters can cause unwanted variable side effects in the original caller.\n‚Ä¢ Why? Reassigning parameters can lead to unexpected behavior, especially when accessing the object. It can also cause optimization issues, especially in V8.\n‚Ä¢ 7.14 Prefer the use of the spread syntax to call variadic functions. eslint: Why? It‚Äôs cleaner, you don‚Äôt need to supply a context, and you can not easily compose with .\n‚Ä¢ 7.15 Functions with multiline signatures, or invocations, should be indented just like every other multiline list in this guide: with each item on a line by itself, with a trailing comma on the last item. eslint:\n‚Ä¢ 8.1 When you must use an anonymous function (as when passing an inline callback), use arrow function notation. eslint: , Why? It creates a version of the function that executes in the context of , which is usually what you want, and is a more concise syntax. Why not? If you have a fairly complicated function, you might move that logic out into its own named function expression.\n‚Ä¢ 8.2 If the function body consists of a single statement returning an expression without side effects, omit the braces and use the implicit return. Otherwise, keep the braces and use a statement. eslint: , Why? Syntactic sugar. It reads well when multiple functions are chained together. : // Do something if callback returns true\n‚Ä¢ 8.3 In case the expression spans over multiple lines, wrap it in parentheses for better readability. Why? It shows clearly where the function starts and ends.\n‚Ä¢ 8.4 Always include parentheses around arguments for clarity and consistency. eslint: Why? Minimizes diff churn when adding or removing arguments. `A long string with the . It‚Äôs so long that we don‚Äôt want it to take up space on the .map line!` `A long string with the . It‚Äôs so long that we don‚Äôt want it to take up space on the .map line!`\n‚Ä¢ 8.6 Enforce the location of arrow function bodies with implicit returns. eslint:\n‚Ä¢ Why? syntax is more concise and easier to reason about.\n‚Ä¢ Why? It is a built-in way to inherit prototype functionality without breaking .\n‚Ä¢ 9.3 Methods can return to help with method chaining.\n‚Ä¢ 9.4 It‚Äôs okay to write a custom method, just make sure it works successfully and causes no side effects.\n‚Ä¢ 9.5 Classes have a default constructor if one is not specified. An empty constructor function or one that just delegates to a parent class is unnecessary. eslint:\n‚Ä¢ Why? Duplicate class member declarations will silently prefer the last one - having duplicates is almost certainly a bug.\n‚Ä¢ 9.7 Class methods should use or be made into a static method unless an external library or framework requires using specific non-static methods. Being an instance method should indicate that it behaves differently based on properties of the receiver. eslint: // good - this is used // good - static methods aren't expected to use this\n‚Ä¢ 10.1 Always use modules ( / ) over a non-standard module system. You can always transpile to your preferred module system. Why? Modules are the future, let‚Äôs start using the future now.\n‚Ä¢ 10.2 Do not use wildcard imports. Why? This makes sure you have a single default export.\n‚Ä¢ 10.3 And do not export directly from an import. Why? Although the one-liner is concise, having one clear way to import and one clear way to export makes things consistent.\n‚Ä¢ 10.4 Only import from a path in one place. eslint: Why? Having multiple lines that import from the same path can make code harder to maintain.\n‚Ä¢ Why? Mutation should be avoided in general, but in particular when exporting mutable bindings. While this technique may be needed for some special cases, in general, only constant references should be exported.\n‚Ä¢ 10.6 In modules with a single export, prefer default export over named export. eslint: Why? To encourage more files that only ever export one thing, which is better for readability and maintainability.\n‚Ä¢ Why? Since s are hoisted, keeping them all at the top prevents surprising behavior.\n‚Ä¢ 10.8 Multiline imports should be indented just like multiline array and object literals. eslint: Why? The curly braces follow the same indentation rules as every other curly brace block in the style guide, as do the trailing commas.\n‚Ä¢ Why? Since using Webpack syntax in the imports couples the code to a module bundler. Prefer using the loader syntax in .\n‚Ä¢ Why? Including extensions inhibits refactoring, and inappropriately hardcodes implementation details of the module you're importing in every consumer.\n‚Ä¢ 11.1 Don‚Äôt use iterators. Prefer JavaScript‚Äôs higher-order functions instead of loops like or . eslint: Why? This enforces our immutable rule. Dealing with pure functions that return values is easier to reason about than side effects. Use / / / / / / / ... to iterate over arrays, and / / to produce arrays so you can iterate over objects. // best (use the functional force)\n‚Ä¢ 11.2 Don‚Äôt use generators for now. Why? They don‚Äôt transpile well to ES5.\n‚Ä¢ 11.3 If you must use generators, or if you disregard our advice, make sure their function signature is spaced properly. eslint: Why? and are part of the same conceptual keyword - is not a modifier for , is a unique construct, different from .\n‚Ä¢ 12.2 Use bracket notation when accessing properties with a variable.\n‚Ä¢ 13.1 Always use or to declare variables. Not doing so will result in global variables. We want to avoid polluting the global namespace. Captain Planet warned us of that. eslint:\n‚Ä¢ 13.2 Use one or declaration per variable or assignment. eslint: Why? It‚Äôs easier to add new variable declarations this way, and you never have to worry about swapping out a for a or introducing punctuation-only diffs. You can also step through each declaration with the debugger, instead of jumping through all of them at once. // (compare to above, and try to spot the mistake)\n‚Ä¢ 13.3 Group all your s and then group all your s. Why? This is helpful when later on you might need to assign a variable depending on one of the previously assigned variables.\n‚Ä¢ 13.4 Assign variables where you need them, but place them in a reasonable place. Why? and are block scoped and not function scoped.\n‚Ä¢ // The let keyword only applies to variable a; variables b and c become // the same applies for `const`\n‚Ä¢ Why? Per the eslint documentation, unary increment and decrement statements are subject to automatic semicolon insertion and can cause silent errors with incrementing or decrementing values within an application. It is also more expressive to mutate your values with statements like instead of or . Disallowing unary increment and decrement statements also prevents you from pre-incrementing/pre-decrementing values unintentionally which can also cause unexpected behavior in your programs.\n‚Ä¢ 13.7 Avoid linebreaks before or after in an assignment. If your assignment violates , surround the value in parens. eslint . Why? Linebreaks surrounding can obfuscate the value of an assignment.\n‚Ä¢ Why? Variables that are declared and not used anywhere in the code are most likely an error due to incomplete refactoring. Such variables take up space in the code and can lead to confusion by readers. // Write-only variables are not considered as used. // A read for a modification of itself is not considered as used. // 'type' is ignored even if unused because it has a rest property sibling. // This is a form of extracting an object that omits the specified keys. type ... // 'coords' is now the 'data' object without its 'type' property.\n‚Ä¢ 14.1 declarations get hoisted to the top of their closest enclosing function scope, their assignment does not. and declarations are blessed with a new concept called Temporal Dead Zones (TDZ). It‚Äôs important to know why typeof is no longer safe. // we know this wouldn‚Äôt work (assuming there // reference the variable will work due to // value of `true` is not hoisted. // the interpreter is hoisting the variable // declaration to the top of the scope, // which means our example could be rewritten as: // using const and let\n‚Ä¢ 14.2 Anonymous function expressions hoist their variable name, but not the function assignment.\n‚Ä¢ 14.3 Named function expressions hoist the variable name, not the function name or the function body. // the same is true when the function name // is the same as the variable name.\n‚Ä¢ 14.4 Function declarations hoist their name and the function body.\n‚Ä¢ 14.5 Variables, classes, and functions should be defined before they can be used. eslint: Why? When variables, classes, or functions are declared after being used, it can harm readability since a reader won't know what a thing that's referenced is. It's much clearer for a reader to first encounter the source of a thing (whether imported from another module, or defined in the file) before encountering a use of the thing. // Variable a is being used before it is being defined. // this will be undefined, since while the declaration is hoisted, the initialization is not // Function fun is being called before being defined. // Class A is being used before being defined. // `let` and `const` are hoisted, but they don't have a default initialization. // The variables 'a' and 'b' are in a Temporal Dead Zone where JavaScript // knows they exist (declaration is hoisted) but they are not accessible // (as they are not yet initialized).\n‚Ä¢ For more information refer to JavaScript Scoping & Hoisting by Ben Cherry.\n‚Ä¢ 15.1 Use and over and . eslint:\n‚Ä¢ 15.2 Conditional statements such as the statement evaluate their expression using coercion with the abstract method and always follow these simple rules:\n‚Ä¢ Booleans evaluate to the value of the boolean\n‚Ä¢ Numbers evaluate to false if +0, -0, or NaN, otherwise true\n‚Ä¢ Strings evaluate to false if an empty string , otherwise true // an array (even an empty one) is an object, objects will evaluate to true\n‚Ä¢ 15.3 Use shortcuts for booleans, but explicit comparisons for strings and numbers.\n‚Ä¢ 15.4 For more information see Truth, Equality, and JavaScript by Angus Croll.\n‚Ä¢ 15.5 Use braces to create blocks in and clauses that contain lexical declarations (e.g. , , , and ). eslint: Why? Lexical declarations are visible in the entire block but only get initialized when assigned, which only happens when its is reached. This causes problems when multiple clauses attempt to define the same thing.\n‚Ä¢ 15.6 Ternaries should not be nested and generally be single line expressions. eslint:\n‚Ä¢ 15.8 When mixing operators, enclose them in parentheses. The only exception is the standard arithmetic operators: , , and since their precedence is broadly understood. We recommend enclosing and in parentheses because their precedence can be ambiguous when they are mixed. eslint: Why? This improves readability and clarifies the developer‚Äôs intention. // one may be confused into thinking (a || b) && c\n‚Ä¢ 15.9 The nullish coalescing operator ( ) is a logical operator that returns its right-hand side operand when its left-hand side operand is or . Otherwise, it returns the left-hand side operand. Why? It provides precision by distinguishing null/undefined from other falsy values, enhancing code clarity and predictability.\n‚Ä¢ 16.1 Use braces with all multiline blocks. eslint:\n‚Ä¢ 16.2 If you‚Äôre using multiline blocks with and , put on the same line as your block‚Äôs closing brace. eslint:\n‚Ä¢ 16.3 If an block always executes a statement, the subsequent block is unnecessary. A in an block following an block that contains a can be separated into multiple blocks. eslint:\n‚Ä¢ 17.1 In case your control statement ( , etc.) gets too long or exceeds the maximum line length, each (grouped) condition could be put into a new line. The logical operator should begin the line. Why? Requiring operators at the beginning of the line keeps the operators aligned and follows a pattern similar to method chaining. This also improves readability by making it easier to visually follow complex logic.\n‚Ä¢ 17.2 Don't use selection operators in place of control statements.\n‚Ä¢ // based on the passed in tag name * based on the passed-in tag name\n‚Ä¢ 18.2 Use for single line comments. Place single line comments on a newline above the subject of the comment. Put an empty line before the comment unless it‚Äôs on the first line of a block. // set the default type to 'no type' // set the default type to 'no type' // set the default type to 'no type'\n‚Ä¢ 18.3 Start all comments with a space to make it easier to read. eslint: *based on the passed-in tag name * based on the passed-in tag name\n‚Ä¢ 18.4 Prefixing your comments with or helps other developers quickly understand if you‚Äôre pointing out a problem that needs to be revisited, or if you‚Äôre suggesting a solution to the problem that needs to be implemented. These are different than regular comments because they are actionable. The actions are FIXME: -- need to figure this out or .\n‚Ä¢ 18.6 Use to annotate solutions to problems. // TODO: total should be configurable by an options param\n‚Ä¢ 19.3 Place 1 space before the opening parenthesis in control statements ( , etc.). Place no space between the argument list and the function name in function calls and declarations. eslint:\n‚Ä¢ 19.6 Use indentation when making long method chains (more than 2 method chains). Use a leading dot, which emphasizes that the line is a method call, not a new statement. eslint:\n‚Ä¢ 19.7 Leave a blank line after blocks and before the next statement.\n‚Ä¢ 19.8 Do not pad your blocks with blank lines. eslint:\n‚Ä¢ 19.9 Do not use multiple blank lines to pad your code. eslint:\n‚Ä¢ 19.13 Avoid having lines of code that are longer than 100 characters (including whitespace). Note: per above, long strings are exempt from this rule, and should not be broken up. eslint: Why? This ensures readability and maintainability. : : : : 'You have failed this city.' : : : : 'You have failed this city.'\n‚Ä¢ 19.14 Require consistent spacing inside an open block token and the next token on the same line. This rule also enforces consistent spacing inside a close block token and previous token on the same line. eslint:\n‚Ä¢ 19.15 Avoid spaces before commas and require a space after commas. eslint:\n‚Ä¢ 19.17 Avoid spaces between functions and their invocations. eslint:\n‚Ä¢ 19.18 Enforce spacing between keys and values in object literal properties. eslint:\n‚Ä¢ 19.19 Avoid trailing spaces at the end of lines. eslint:\n‚Ä¢ 19.20 Avoid multiple empty lines, only allow one newline at the end of files, and avoid a newline at the beginning of files. eslint:\n‚Ä¢ Why? This leads to cleaner git diffs. Also, transpilers like Babel will remove the additional trailing comma in the transpiled code which means you don‚Äôt have to worry about the trailing comma problem in legacy browsers. : : : : // good (note that a comma must not appear after a \"rest\" element) ... // good (note that a comma must not appear after a \"rest\" element) ...\n‚Ä¢ Why? When JavaScript encounters a line break without a semicolon, it uses a set of rules called Automatic Semicolon Insertion to determine whether it should regard that line break as the end of a statement, and (as the name implies) place a semicolon into your code before the line break if it thinks so. ASI contains a few eccentric behaviors, though, and your code will break if JavaScript misinterprets your line break. These rules will become more complicated as new features become a part of JavaScript. Explicitly terminating your statements and configuring your linter to catch missing semicolons will help prevent you from encountering issues. // bad - returns `undefined` instead of the value on the next line - always happens when `return` is on a line by itself because of ASI! 'search your feelings, you know it to be foo' 'search your feelings, you know it to be foo'\n‚Ä¢ 22.1 Perform type coercion at the beginning of the statement.\n‚Ä¢ 22.3 Numbers: Use for type casting and always with a radix for parsing strings. eslint: Why? The function produces an integer value dictated by interpretation of the contents of the string argument according to the specified radix. Leading whitespace in string is ignored. If radix is or , it is assumed to be except when the number begins with the character pairs or , in which case a radix of 16 is assumed. This differs from ECMAScript 3, which merely discouraged (but allowed) octal interpretation. Many implementations have not adopted this behavior as of 2013. And, because older browsers must be supported, always specify a radix.\n‚Ä¢ 22.4 If for whatever reason you are doing something wild and is your bottleneck and need to use Bitshift for performance reasons, leave a comment explaining why and what you‚Äôre doing. * parseInt was the reason my code was slow. * Bitshifting the String to coerce it to a\n‚Ä¢ 22.5 Note: Be careful when using bitshift operations. Numbers are represented as 64-bit values, but bitshift operations always return a 32-bit integer (source). Bitshift can lead to unexpected behavior for integer values larger than 32 bits. Discussion. Largest signed 32-bit Int is 2,147,483,647:\n‚Ä¢ 23.1 Avoid single letter names. Be descriptive with your naming. eslint:\n‚Ä¢ 23.2 Use camelCase when naming objects, functions, and instances. eslint:\n‚Ä¢ 23.3 Use PascalCase only when naming constructors or classes. eslint:\n‚Ä¢ 23.4 Do not use trailing or leading underscores. eslint: Why? JavaScript does not have the concept of privacy in terms of properties or methods. Although a leading underscore is a common convention to mean ‚Äúprivate‚Äù, in fact, these properties are fully public, and as such, are part of your public API contract. This convention might lead developers to wrongly think that a change won‚Äôt count as breaking, or that tests aren‚Äôt needed. tl;dr: if you want something to be ‚Äúprivate‚Äù, it must not be observably present. // good, in environments where WeakMaps are available\n‚Ä¢ 23.5 Don‚Äôt save references to . Use arrow functions or Function#bind.\n‚Ä¢ 23.6 A base filename should exactly match the name of its default export. // in some other file\n‚Ä¢ 23.7 Use camelCase when you export-default a function. Your filename should be identical to your function‚Äôs name.\n‚Ä¢ 23.8 Use PascalCase when you export a constructor / class / singleton / function library / bare object.\n‚Ä¢ 23.9 Acronyms and initialisms should always be all uppercased, or all lowercased. Why? Names are for readability, not to appease a computer algorithm.\n‚Ä¢ 23.10 You may optionally uppercase a constant only if it (1) is exported, (2) is a (it can not be reassigned), and (3) the programmer can trust it (and its nested properties) to never change. Why? This is an additional tool to assist in situations where the programmer would be unsure if a variable might ever change. UPPERCASE_VARIABLES are letting the programmer know that they can trust the variable (and its properties) not to change.\n‚Ä¢ What about all variables? - This is unnecessary, so uppercasing should not be used for constants within a file. It should be used for exported constants however.\n‚Ä¢ What about exported objects? - Uppercase at the top level of export (e.g. ) and maintain that all nested properties do not change. 'should not be unnecessarily uppercased within a file' 'should obviously not be uppercased' 'do not use let with uppercase variables' // allowed but does not supply semantic value // better in most cases // bad - unnecessarily uppercases key while adding no semantic value : :\n‚Ä¢ 24.1 Accessor functions for properties are not required.\n‚Ä¢ 24.2 Do not use JavaScript getters/setters as they cause unexpected side effects and are harder to test, maintain, and reason about. Instead, if you do make accessor functions, use and .\n‚Ä¢ 24.3 If the property/method is a , use or .\n‚Ä¢ 24.4 It‚Äôs okay to create and functions, but be consistent.\n‚Ä¢ 25.1 When attaching data payloads to events (whether DOM events or something more proprietary like Backbone events), pass an object literal (also known as a \"hash\") instead of a raw value. This allows a subsequent contributor to add more data to the event payload without finding and updating every handler for the event. For example, instead of: // do something with listingID : // do something with data.listingID\n‚Ä¢ 26.3 For DOM queries use Cascading or parent > child . jsPerf\n‚Ä¢ 28.1 This is a collection of links to the various ES6+ features.\n‚Ä¢ 28.2 Do not use TC39 proposals that have not reached stage 3. Why? They are not finalized, and they are subject to change or to be withdrawn entirely. We want to use JavaScript, and proposals are not JavaScript yet.\n\nThe Standard Library contains utilities that are functionally broken but remain for legacy reasons.\n‚Ä¢ 29.1 Use instead of global . eslint: Why? The global coerces non-numbers to numbers, returning true for anything that coerces to NaN. If this behavior is desired, make it explicit.\n‚Ä¢ 29.2 Use instead of global . eslint: Why? The global coerces non-numbers to numbers, returning true for anything that coerces to a finite number. If this behavior is desired, make it explicit.\n‚Ä¢ 30.2 No, but seriously:\n‚Ä¢ Whichever testing framework you use, you should be writing tests!\n‚Ä¢ Strive to write many small pure functions, and minimize where mutations occur.\n‚Ä¢ Be cautious about stubs and mocks - they can make your tests more brittle.\n‚Ä¢ We primarily use and at Airbnb. is also used occasionally for small, separate modules.\n‚Ä¢ 100% test coverage is a good goal to strive for, even if it‚Äôs not always practical to reach it.\n‚Ä¢ Whenever you fix a bug, write a regression test. A bug fixed without a regression test is almost certainly going to break again in the future.\n‚Ä¢ Are JavaScript functions like , , and optimized for traversing arrays?\n‚Ä¢ You Might Not Need jQuery - Zack Bloom & Adam Schwartz\n‚Ä¢ Secrets of the JavaScript Ninja - John Resig and Bear Bibeault\n‚Ä¢ Effective JavaScript: 68 Specific Ways to Harness the Power of JavaScript - David Herman\n‚Ä¢ You Don‚Äôt Know JS: ES6 & Beyond - Kyle Simpson\n\nThis is a list of organizations that are using this style guide. Send us a pull request and we'll add you to the list.\n‚Ä¢ How About We: howaboutwe/javascript\n\nThis style guide is also available in other languages:\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the 'Software'), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nWe encourage you to fork this guide and change the rules to fit your team‚Äôs style guide. Below, you may list some amendments to the style guide. This allows you to periodically update your style guide without having to deal with merge conflicts."
    },
    {
        "link": "https://javascript.info/coding-style",
        "document": "Our code must be as clean and easy to read as possible.\n\nThat is actually the art of programming ‚Äì to take a complex task and code it in a way that is both correct and human-readable. A good code style greatly assists in that.\n\nHere is a cheat sheet with some suggested rules (see below for more details):\n\nNow let‚Äôs discuss the rules and reasons for them in detail.\n\nIn most JavaScript projects curly braces are written in ‚ÄúEgyptian‚Äù style with the opening brace on the same line as the corresponding keyword ‚Äì not on a new line. There should also be a space before the opening bracket, like this:\n\nA single-line construct, such as , is an important edge case. Should we use braces at all?\n\nHere are the annotated variants so you can judge their readability for yourself:\n‚Ä¢ üò† Beginners sometimes do that. Bad! Curly braces are not needed: if (n < 0) {alert(`Power ${n} is not supported`);}\n‚Ä¢ üò† Split to a separate line without braces. Never do that, easy to make an error when adding new lines: if (n < 0) alert(`Power ${n} is not supported`);\n‚Ä¢ üòè One line without braces ‚Äì acceptable, if it‚Äôs short: if (n < 0) alert(`Power ${n} is not supported`);\n‚Ä¢ üòÉ The best variant: if (n < 0) { alert(`Power ${n} is not supported`); }\n\nFor a very brief code, one line is allowed, e.g. . But a code block (the last variant) is usually more readable.\n\nNo one likes to read a long horizontal line of code. It‚Äôs best practice to split them.\n\nThe maximum line length should be agreed upon at the team-level. It‚Äôs usually 80 or 120 characters.\n\nThere are two types of indents:\n‚Ä¢ A horizontal indentation is made using either 2 or 4 spaces or the horizontal tab symbol (key ). Which one to choose is an old holy war. Spaces are more common nowadays. One advantage of spaces over tabs is that spaces allow more flexible configurations of indents than the tab symbol. For instance, we can align the parameters with the opening bracket, like this: show(parameters, aligned, // 5 spaces padding at the left one, after, another ) { // ... }\n‚Ä¢ Even a single function can often be divided into logical blocks. In the example below, the initialization of variables, the main loop and returning the result are split vertically: function pow(x, n) { let result = 1; // <-- for (let i = 0; i < n; i++) { result *= x; } // <-- return result; } Insert an extra newline where it helps to make the code more readable. There should not be more than nine lines of code without a vertical indentation.\n\nA semicolon should be present after each statement, even if it could possibly be skipped.\n\nThere are languages where a semicolon is truly optional and it is rarely used. In JavaScript, though, there are cases where a line break is not interpreted as a semicolon, leaving the code vulnerable to errors. See more about that in the chapter Code structure.\n\nIf you‚Äôre an experienced JavaScript programmer, you may choose a no-semicolon code style like StandardJS. Otherwise, it‚Äôs best to use semicolons to avoid possible pitfalls. The majority of developers put semicolons.\n\nTry to avoid nesting code too many levels deep.\n\nFor example, in the loop, it‚Äôs sometimes a good idea to use the directive to avoid extra nesting.\n\nFor example, instead of adding a nested conditional like this:\n\nA similar thing can be done with and .\n\nFor example, two constructs below are identical.\n\nThe second one is more readable because the ‚Äúspecial case‚Äù of is handled early on. Once the check is done we can move on to the ‚Äúmain‚Äù code flow without the need for additional nesting.\n\nIf you are writing several ‚Äúhelper‚Äù functions and the code that uses them, there are three ways to organize the functions.\n‚Ä¢ Declare the functions above the code that uses them: // function declarations function createElement() { ... } function setHandler(elem) { ... } function walkAround() { ... } // the code which uses them let elem = createElement(); setHandler(elem); walkAround();\n‚Ä¢ // the code which uses the functions let elem = createElement(); setHandler(elem); walkAround(); // --- helper functions --- function createElement() { ... } function setHandler(elem) { ... } function walkAround() { ... }\n‚Ä¢ Mixed: a function is declared where it‚Äôs first used.\n\nMost of time, the second variant is preferred.\n\nThat‚Äôs because when reading code, we first want to know what it does. If the code goes first, then it becomes clear from the start. Then, maybe we won‚Äôt need to read the functions at all, especially if their names are descriptive of what they actually do.\n\nA style guide contains general rules about ‚Äúhow to write‚Äù code, e.g. which quotes to use, how many spaces to indent, the maximal line length, etc. A lot of minor things.\n\nWhen all members of a team use the same style guide, the code looks uniform, regardless of which team member wrote it.\n\nOf course, a team can always write their own style guide, but usually there‚Äôs no need to. There are many existing guides to choose from.\n\nIf you‚Äôre a novice developer, start with the cheat sheet at the beginning of this chapter. Then you can browse other style guides to pick up more ideas and decide which one you like best.\n\nLinters are tools that can automatically check the style of your code and make improving suggestions.\n\nThe great thing about them is that style-checking can also find some bugs, like typos in variable or function names. Because of this feature, using a linter is recommended even if you don‚Äôt want to stick to one particular ‚Äúcode style‚Äù.\n\nHere are some well-known linting tools:\n‚Ä¢ JSLint ‚Äì one of the first linters.\n‚Ä¢ ESLint ‚Äì probably the newest one.\n\nAll of them can do the job. The author uses ESLint.\n\nMost linters are integrated with many popular editors: just enable the plugin in the editor and configure the style.\n\nFor instance, for ESLint you should do the following:\n‚Ä¢ Install ESLint with the command (npm is a JavaScript package installer).\n‚Ä¢ Create a config file named in the root of your JavaScript project (in the folder that contains all your files).\n‚Ä¢ Install/enable the plugin for your editor that integrates with ESLint. The majority of editors have one.\n\nHere‚Äôs an example of an file:\n\nHere the directive denotes that the configuration is based on the ‚Äúeslint:recommended‚Äù set of settings. After that, we specify our own.\n\nIt is also possible to download style rule sets from the web and extend them instead. See https://eslint.org/docs/user-guide/getting-started for more details about installation.\n\nAlso certain IDEs have built-in linting, which is convenient but not as customizable as ESLint.\n\nAll syntax rules described in this chapter (and in the style guides referenced) aim to increase the readability of your code. All of them are debatable.\n\nWhen we think about writing ‚Äúbetter‚Äù code, the questions we should ask ourselves are: ‚ÄúWhat makes the code more readable and easier to understand?‚Äù and ‚ÄúWhat can help us avoid errors?‚Äù These are the main things to keep in mind when choosing and debating code styles.\n\nReading popular style guides will allow you to keep up to date with the latest ideas about code style trends and best practices."
    }
]