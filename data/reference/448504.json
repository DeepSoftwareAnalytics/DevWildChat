[
    {
        "link": "https://cdn.sencha.com/ext/gpl/4.2.1/docs#!/api/Ext.grid.Panel",
        "document": "Ext JS 4.2 is a pure JavaScript application framework that works on all modern browsers from IE6 to the latest version of Chrome. It enables you to create the best cross-platform applications using nothing but a browser, and has a phenomenal API.\n\nThis is the biggest upgrade we've ever made to Ext JS and we think you're going to love it.\n\nView the Examples Discuss Ext JS 4.2 on the forum"
    },
    {
        "link": "https://docs.sencha.com/ext/6.5.0/classic/Ext.grid.Panel.html",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/43382507/scroll-event-on-extjs-grid-panel",
        "document": "I have a grid panel in ExtJS with scroll bars. I am trying to detect when the user has scrolled all the way down(so that they can not move bar anymore). So far I have this, which detects when scroll occurs but provides no information(?) about where the scroll bar is.\n\nAny pointers would be appreciated."
    },
    {
        "link": "https://stackoverflow.com/questions/23692355/how-to-scroll-to-bottom-of-grid-using-extjs",
        "document": "I'm using ExtJs. I want my scroll still in the bottom (last row) when i click 'add' button on my grid. I do some code like this:\n\ni created event click like that. It works when the first click. But when the next click, the scroll is moving up.\n\nWhat should i do to make scroll always still in the bottom of grid?"
    },
    {
        "link": "https://docs.sencha.com/extjs/4.2.3/extjs-build/docs/index.html#!/api/Ext.grid.property.Grid",
        "document": "Ext JS 4.2 is a pure JavaScript application framework that works on all modern browsers from IE6 to the latest version of Chrome. It enables you to create the best cross-platform applications using nothing but a browser, and has a phenomenal API.\n\nThis is the biggest upgrade we've ever made to Ext JS and we think you're going to love it.\n\nView the Examples Discuss Ext JS 4.2 on the forum"
    },
    {
        "link": "https://stackoverflow.com/questions/18539705/extjs-grid-width-calculated-wrong",
        "document": "I am trying to create a Extjs Grid with no vertical and horizontal scroll bars. it means that the grid should expand to infinity in both direction.\n\nhere is my code:\n\ni'm rendering my grid to a div element so practically i don't use any layout or etc.\n\nHere is my browser's screen shot that shows the vertical scroll bar [just like I expected].\n\nThere is NO horizontal scroll bar and part of columns just cut off from page and there is no way to see the data they are presenting.\n\ni can see that extjs tries to calculate the height and the width for the grids. in case of height it's correct but for width it's not, the calculated width is equals to my browser's width, not to the sum of columns which are in the grid.\n\nI appreciate any suggestion or words from your side, thank you. any one can help me with that?"
    },
    {
        "link": "https://docs.sencha.com/ext/7.0.0/guides/components/grids.html",
        "document": "Ext.grid.Panel is one of the centerpieces of ExtJS. It's an incredibly versatile component that provides an easy way to display, sort, group, and edit data.\n\nLet's get started by creating a basic Ext.grid.Panel. Here's all you need to know to get a simple grid up and running:\n\nExt.grid.Panel is simply a component that displays data contained in a Ext.data.Store. Ext.data.Store can be thought of as a collection of records, or Ext.data.Model instances.\n\nThe benefit of this setup is separating our concerns. Ext.grid.Panel is only concerned with displaying the data, while Ext.data.Store takes care of fetching and saving the data using Ext.data.proxy.Proxy.\n\nFirst, we need to define a Ext.data.Model. A model is just a collection of fields that represents a type of data. Let's define a model that represents a \"User\":\n\nNext let's create a Ext.data.Store that contains several \"User\" instances.\n\nFor sake of ease, we configured Ext.data.Store to load its data inline. In a real world application, you would most likely configure the Ext.data.Store to use an Ext.data.proxy.Proxy to load data from the server.\n\nNow, we have a model, which defines our data structure. We have also loaded several model instances into an Ext.data.Store. Now we're ready to display the data using Ext.grid.Panel.\n\nIn this example, we configured the Grid with renderTo to immediately render the Grid into the HTML document.\n\nIn many situations, the grid will be a descendant of Ext.container.Viewport, which means rendering is already handled.\n\nAnd that's all there is to it.\n\nWe just created an Ext.grid.Panel that renders itself to the body element. We also told the Grid panel to get its data from the that we previously created.\n\nFinally, we defined the Grid panel's columns and gave them a dataIndex property. This associates a field from our model to a column.\n\nThe \"Name\" column has a fixed of \"100px\" and has sorting and hiding disabled. The \"Email Address\" column is hidden by default (it can be shown again by using the menu on any other column header). Finally, the \"Phone Number\" column flexes to fit the remainder of the Grid panel's total width.\n\nFor a larger example, see the Basic Grid Example.\n\nYou can use the renderer property of the column config to change the way in which data is displayed. A is a function that modifies the underlying value and returns a new value for display. Some of the most common renderers are included in Ext.util.Format, but you can write your own as well:\n\nSee the Kitchen Sink's Basic Grid for a live demo that uses custom renderers.\n\nIn accordance with accessibility guidelines, grid cells accept focus, and the focus rendition my be specified in the theme.\n\nArrow keys navigate the focus position in two dimensions. TAB tabs out of the grid into the following focusable element.\n\nThis is known as Navigable Mode, and is the default mode for handling focus within a grid.\n\nIf there are focusable elements within a cell (Such as [[Ext.grid.column.ActionColumn action columns]] then the actionable items may be accessed by using the ENTER or F2 key to enter Actionable Mode wherin focus navigation takes place within cells using the TAB key.\n\nCell editing which is discussed below is a special case of Actionable Mode.\n\nESC or F2 exits actionable mode, and focus pops up to the encapsulating cell of the recently focused actionable item.\n\nGrid panels can be used to simply display data. However, it is often necessary to interact with the Grid's data. All Grid panels have an Ext.selection.Model, which determines how data is selected. The most versatile Selection Model is Ext.grid.selection.SpreadsheetModel, which may be configured to select cells, rows, or columns, and to optionally display a selection checkbox if selecting rows.\n\nSee the Kitchen Sink's Spreadsheet Model for an example.\n\nOther selection models include Ext.selection.RowModel, where entire rows are selected, and Ext.selection.CellModel, where individual cells are selected. These are less flexible than the SpreadsheetModel.\n\nGrid panels use Ext.selection.RowModel by default, but it's easy to switch to an Ext.grid.selection.SpreadsheetModel:\n\nGrid panel has built-in support for editing. Let's look at the two main editing modes - row editing and cell editing.\n\nCell editing allows you to edit the data in a Grid panel one cell at a time. The first step in implementing cell editing is to configure an editor for each Ext.grid.column.Column in your Grid Panel that should be editable. This is done using the Ext.grid.column.Column#editor config. The simplest way is to specify just the xtype of the field you want to use as an editor:\n\nIf you need more control over how the editor field behaves, the Ext.grid.column.Column#editor config can also take a config object for a Field. For example, if we are using a Ext.form.field.Text and we want to require a value:\n\nYou can use any class in the \"Ext.form.field.*\" package as an editor field. Lets suppose we want to edit a column that contains dates. We can use a Ext.form.field.Date editor:\n\nAny Ext.grid.column.Column in a Ext.grid.Panel that do not have a ] configured will not be editable.\n\nNow that we've configured which columns we want to be editable, to enable editing we need to configure the Ext.grid.Panel with a Ext.grid.plugin.CellEditing:\n\nAnd that's all it takes to create an editable Grid using cell editing. See Cell Editing for a working example.\n\nRow editing enables you to edit an entire row at a time, rather than editing cell by cell. Row editing works in exactly the same way as cell editing - all we need to do is change the plugin type to Ext.grid.plugin.RowEditing.\n\nSee Row Editing for a working example.\n\nOrganizing the rows into groups is easy. First we specify a groupField property on our store:\n\nNext, we configure a Grid with Ext.grid.feature.Grouping that will handle displaying the rows in groups:\n\nSee the Kitchen Sink's Grouping Grid Panel for a live example.\n\nSometimes your data set is too large to display all on one page. Ext.grid.Panel supports displaying individual pages from the dataset using a Ext.toolbar.Paging, which loads pages using previous/next buttons.\n\nBefore we can set up paging on a Ext.grid.Panel, we have to configure the Ext.data.Store to support paging. In the below example we add Ext.data.Store#pageSize to the Ext.data.Store, and we configure our Ext.data.reader.Reader with a Ext.data.reader.Reader#totalProperty:\n\nThe Ext.data.reader.Reader#totalProperty config tells Ext.data.reader.Json where to get the total number of results in the JSON response. This Ext.data.Store is configured to consume a JSON response that looks something like this:\n\nNow that we've set up our Ext.data.Store to support paging, all that's left is to configure a Ext.toolbar.Paging. You could put the Ext.toolbar.Paging anywhere in your application layout, but typically it is docked to the Ext.grid.Panel:\n\nSee the Paging Grid for a working example.\n\nGrids and Trees enable buffered rendering of extremely large datasets as an alternative to using a paging toolbar. Your users can scroll through thousands of records without the performance penalties of renderering all the records on screen at once.\n\nOnly enough rows are rendered to fill the visible area of the Grid with a little Ext.grid.Panel-cfg-leadingBufferZone overflow either side to allow scrolling. As scrolling proceeds, new rows are rendered in the direction of scroll, and rows are removed from the receding side of the table.\n\nGrids use buffered rendering by default, so you no longer need to add the plugin to your Grid component.\n\nSee Big Data of Filtered Tree for working examples.\n\nSince ExtJS 5.0, developers have had the ability to embed components within grid cells using the Widget Column class.\n\nIn versions prior to 6.2.0, components embedded in this way had no access to the grid's . The field referenced by the column's was bound to the component's .\n\nIn 6.2.0, components embedded in grids have access to the ViewModel and all the data within it. The ViewModel contains two row-specific properties:\n\nSince ExtJS 6.2.0, developers have had the ability to configure a component to be displayed in an expansion row below (or, configurably, above) the data row.\n\nThe embedded component has access to the grid's ViewModel.\n\nSee Using Components in Grids guide for more details."
    },
    {
        "link": "https://docs.sencha.com/extjs/7.8.0/guides/components/grids/configurations.html",
        "document": "Ext.grid.Panel is one of the centerpieces of ExtJS. It's an incredibly versatile component that provides an easy way to display, sort, group, and edit data.\n\nLet's get started by creating a basic Ext.grid.Panel. Here's all you need to know to get a simple grid up and running:\n\nExt.grid.Panel is simply a component that displays data contained in a Ext.data.Store. Ext.data.Store can be thought of as a collection of records, or Ext.data.Model instances.\n\nThe benefit of this setup is separating our concerns. Ext.grid.Panel is only concerned with displaying the data, while Ext.data.Store takes care of fetching and saving the data using Ext.data.proxy.Proxy.\n\nFirst, we need to define a Ext.data.Model. A model is just a collection of fields that represents a type of data. Let's define a model that represents a \"User\":\n\nNext let's create a Ext.data.Store that contains several \"User\" instances.\n\nFor sake of ease, we configured Ext.data.Store to load its data inline. In a real world application, you would most likely configure the Ext.data.Store to use an Ext.data.proxy.Proxy to load data from the server.\n\nNow, we have a model, which defines our data structure. We have also loaded several model instances into an Ext.data.Store. Now we're ready to display the data using Ext.grid.Panel.\n\nIn this example, we configured the Grid with renderTo to immediately render the Grid into the HTML document.\n\nIn many situations, the grid will be a descendant of Ext.container.Viewport, which means rendering is already handled.\n\nAnd that's all there is to it.\n\nWe just created an Ext.grid.Panel that renders itself to the body element. We also told the Grid panel to get its data from the that we previously created.\n\nFinally, we defined the Grid panel's columns and gave them a dataIndex property. This associates a field from our model to a column.\n\nThe \"Name\" column has a fixed of \"100px\" and has sorting and hiding disabled. The \"Email Address\" column is hidden by default (it can be shown again by using the menu on any other column header). Finally, the \"Phone Number\" column flexes to fit the remainder of the Grid panel's total width.\n\nFor a larger example, see the Basic Grid Example.\n\nYou can use the renderer property of the column config to change the way in which data is displayed. A is a function that modifies the underlying value and returns a new value for display. Some of the most common renderers are included in Ext.util.Format, but you can write your own as well:\n\nSee the Kitchen Sink's Basic Grid for a live demo that uses custom renderers.\n\nIn accordance with accessibility guidelines, grid cells accept focus, and the focus rendition my be specified in the theme.\n\nArrow keys navigate the focus position in two dimensions. TAB tabs out of the grid into the following focusable element.\n\nThis is known as Navigable Mode, and is the default mode for handling focus within a grid.\n\nIf there are focusable elements within a cell (Such as [[Ext.grid.column.Action action columns]] then the actionable items may be accessed by using the ENTER or F2 key to enter Actionable Mode wherein focus navigation takes place within cells using the TAB key.\n\nCell editing which is discussed below is a special case of Actionable Mode.\n\nESC or F2 exits actionable mode, and focus pops up to the encapsulating cell of the recently focused actionable item.\n\nGrid panels can be used to simply display data. However, it is often necessary to interact with the Grid's data. All Grid panels have an Ext.selection.Model, which determines how data is selected. The most versatile Selection Model is Ext.grid.selection.SpreadsheetModel, which may be configured to select cells, rows, or columns, and to optionally display a selection checkbox if selecting rows.\n\nSee the Kitchen Sink's Spreadsheet Model for an example.\n\nOther selection models include Ext.selection.RowModel, where entire rows are selected, and Ext.selection.CellModel, where individual cells are selected. These are less flexible than the SpreadsheetModel.\n\nGrid panels use Ext.selection.RowModel by default, but it's easy to switch to an Ext.grid.selection.SpreadsheetModel:\n\nGrid panel has built-in support for editing. Let's look at the two main editing modes - row editing and cell editing.\n\nCell editing allows you to edit the data in a Grid panel one cell at a time. The first step in implementing cell editing is to configure an editor for each Ext.grid.column.Column in your Grid Panel that should be editable. This is done using the Ext.grid.column.Column#cfg-editor config. The simplest way is to specify just the xtype of the field you want to use as an editor:\n\nIf you need more control over how the editor field behaves, the Ext.grid.column.Column#cfg-editor config can also take a config object for a Field. For example, if we are using a Ext.form.field.Text and we want to require a value:\n\nYou can use any class in the \"Ext.form.field.*\" package as an editor field. Lets suppose we want to edit a column that contains dates. We can use a Ext.form.field.Date editor:\n\nAny Ext.grid.column.Column in a Ext.grid.Panel that do not have a ] configured will not be editable.\n\nNow that we've configured which columns we want to be editable, to enable editing we need to configure the Ext.grid.Panel with a Ext.grid.plugin.CellEditing:\n\nAnd that's all it takes to create an editable Grid using cell editing. See Cell Editing for a working example.\n\nRow editing enables you to edit an entire row at a time, rather than editing cell by cell. Row editing works in exactly the same way as cell editing - all we need to do is change the plugin type to Ext.grid.plugin.RowEditing.\n\nSee Row Editing for a working example.\n\nOrganizing the rows into groups is easy. First we specify a groupField property on our store:\n\nNext, we configure a Grid with Ext.grid.feature.Grouping that will handle displaying the rows in groups:\n\nSee the Kitchen Sink's Grouping Grid Panel for a live example.\n\nSometimes your data set is too large to display all on one page. Ext.grid.Panel supports displaying individual pages from the dataset using a Ext.toolbar.Paging, which loads pages using previous/next buttons.\n\nBefore we can set up paging on a Ext.grid.Panel, we have to configure the Ext.data.Store to support paging. In the below example we add Ext.data.Store#cfg-pageSize to the Ext.data.Store, and we configure our Ext.data.reader.Reader with a Ext.data.reader.Reader#cfg-totalProperty:\n\nThe Ext.data.reader.Reader#totalProperty config tells Ext.data.reader.Json where to get the total number of results in the JSON response. This Ext.data.Store is configured to consume a JSON response that looks something like this:\n\nNow that we've set up our Ext.data.Store to support paging, all that's left is to configure a Ext.toolbar.Paging. You could put the Ext.toolbar.Paging anywhere in your application layout, but typically it is docked to the Ext.grid.Panel:\n\nSee the Paging Grid for a working example.\n\nGrids and Trees enable buffered rendering of extremely large datasets as an alternative to using a paging toolbar. Your users can scroll through thousands of records without the performance penalties of rendering all the records on screen at once.\n\nOnly enough rows are rendered to fill the visible area of the Grid with a little Ext.grid.Panel#cfg-leadingBufferZone overflow either side to allow scrolling. As scrolling proceeds, new rows are rendered in the direction of scroll, and rows are removed from the receding side of the table.\n\nGrids use buffered rendering by default, so you no longer need to add the plugin to your Grid component.\n\nSee Big Data of Filtered Tree for working examples.\n\nSince ExtJS 5.0, developers have had the ability to embed components within grid cells using the Widget Column class.\n\nIn versions prior to 6.2.0, components embedded in this way had no access to the grid's . The field referenced by the column's was bound to the component's .\n\nIn 6.2.0, components embedded in grids have access to the ViewModel and all the data within it. The ViewModel contains two row-specific properties:\n\nSince ExtJS 6.2.0, developers have had the ability to configure a component to be displayed in an expansion row below (or, configurably, above) the data row.\n\nThe embedded component has access to the grid's ViewModel.\n\nSee Using Components in Grids guide for more details."
    },
    {
        "link": "https://stackoverflow.com/questions/26127464/how-to-put-horizontal-scrollbar-at-top-of-extjs-3-4-grid",
        "document": "I've reviewed the excellent solutions to adding top horizontal scrollbars to a div and adding a top horizontal scrollbar to a jqgrid, but what about an extjs grid?\n\nI saw a suggestion for an extjs version 4.1+ grid but it wasn't fleshed out in an example and the function referenced became available after 3.4 (which is the version I'm using).\n\nHas anyone done this in extjs 3.x? If so, can you provide an example please or at least explain the methodology? Thank you."
    },
    {
        "link": "https://docs.sencha.com/extjs/7.0.0-CE/guides/components/grids.html",
        "document": "Ext.grid.Panel is one of the centerpieces of ExtJS. It's an incredibly versatile component that provides an easy way to display, sort, group, and edit data.\n\nLet's get started by creating a basic Ext.grid.Panel. Here's all you need to know to get a simple grid up and running:\n\nExt.grid.Panel is simply a component that displays data contained in a Ext.data.Store. Ext.data.Store can be thought of as a collection of records, or Ext.data.Model instances.\n\nThe benefit of this setup is separating our concerns. Ext.grid.Panel is only concerned with displaying the data, while Ext.data.Store takes care of fetching and saving the data using Ext.data.proxy.Proxy.\n\nFirst, we need to define a Ext.data.Model. A model is just a collection of fields that represents a type of data. Let's define a model that represents a \"User\":\n\nNext let's create a Ext.data.Store that contains several \"User\" instances.\n\nFor sake of ease, we configured Ext.data.Store to load its data inline. In a real world application, you would most likely configure the Ext.data.Store to use an Ext.data.proxy.Proxy to load data from the server.\n\nNow, we have a model, which defines our data structure. We have also loaded several model instances into an Ext.data.Store. Now we're ready to display the data using Ext.grid.Panel.\n\nIn this example, we configured the Grid with renderTo to immediately render the Grid into the HTML document.\n\nIn many situations, the grid will be a descendant of Ext.container.Viewport, which means rendering is already handled.\n\nAnd that's all there is to it.\n\nWe just created an Ext.grid.Panel that renders itself to the body element. We also told the Grid panel to get its data from the that we previously created.\n\nFinally, we defined the Grid panel's columns and gave them a dataIndex property. This associates a field from our model to a column.\n\nThe \"Name\" column has a fixed of \"100px\" and has sorting and hiding disabled. The \"Email Address\" column is hidden by default (it can be shown again by using the menu on any other column header). Finally, the \"Phone Number\" column flexes to fit the remainder of the Grid panel's total width.\n\nFor a larger example, see the Basic Grid Example.\n\nYou can use the renderer property of the column config to change the way in which data is displayed. A is a function that modifies the underlying value and returns a new value for display. Some of the most common renderers are included in Ext.util.Format, but you can write your own as well:\n\nSee the Kitchen Sink's Basic Grid for a live demo that uses custom renderers.\n\nIn accordance with accessibility guidelines, grid cells accept focus, and the focus rendition my be specified in the theme.\n\nArrow keys navigate the focus position in two dimensions. TAB tabs out of the grid into the following focusable element.\n\nThis is known as Navigable Mode, and is the default mode for handling focus within a grid.\n\nIf there are focusable elements within a cell (Such as [[Ext.grid.column.ActionColumn action columns]] then the actionable items may be accessed by using the ENTER or F2 key to enter Actionable Mode wherin focus navigation takes place within cells using the TAB key.\n\nCell editing which is discussed below is a special case of Actionable Mode.\n\nESC or F2 exits actionable mode, and focus pops up to the encapsulating cell of the recently focused actionable item.\n\nGrid panels can be used to simply display data. However, it is often necessary to interact with the Grid's data. All Grid panels have an Ext.selection.Model, which determines how data is selected. The most versatile Selection Model is Ext.grid.selection.SpreadsheetModel, which may be configured to select cells, rows, or columns, and to optionally display a selection checkbox if selecting rows.\n\nSee the Kitchen Sink's Spreadsheet Model for an example.\n\nOther selection models include Ext.selection.RowModel, where entire rows are selected, and Ext.selection.CellModel, where individual cells are selected. These are less flexible than the SpreadsheetModel.\n\nGrid panels use Ext.selection.RowModel by default, but it's easy to switch to an Ext.grid.selection.SpreadsheetModel:\n\nGrid panel has built-in support for editing. Let's look at the two main editing modes - row editing and cell editing.\n\nCell editing allows you to edit the data in a Grid panel one cell at a time. The first step in implementing cell editing is to configure an editor for each Ext.grid.column.Column in your Grid Panel that should be editable. This is done using the Ext.grid.column.Column#editor config. The simplest way is to specify just the xtype of the field you want to use as an editor:\n\nIf you need more control over how the editor field behaves, the Ext.grid.column.Column#editor config can also take a config object for a Field. For example, if we are using a Ext.form.field.Text and we want to require a value:\n\nYou can use any class in the \"Ext.form.field.*\" package as an editor field. Lets suppose we want to edit a column that contains dates. We can use a Ext.form.field.Date editor:\n\nAny Ext.grid.column.Column in a Ext.grid.Panel that do not have a ] configured will not be editable.\n\nNow that we've configured which columns we want to be editable, to enable editing we need to configure the Ext.grid.Panel with a Ext.grid.plugin.CellEditing:\n\nAnd that's all it takes to create an editable Grid using cell editing. See Cell Editing for a working example.\n\nRow editing enables you to edit an entire row at a time, rather than editing cell by cell. Row editing works in exactly the same way as cell editing - all we need to do is change the plugin type to Ext.grid.plugin.RowEditing.\n\nSee Row Editing for a working example.\n\nOrganizing the rows into groups is easy. First we specify a groupField property on our store:\n\nNext, we configure a Grid with Ext.grid.feature.Grouping that will handle displaying the rows in groups:\n\nSee the Kitchen Sink's Grouping Grid Panel for a live example.\n\nSometimes your data set is too large to display all on one page. Ext.grid.Panel supports displaying individual pages from the dataset using a Ext.toolbar.Paging, which loads pages using previous/next buttons.\n\nBefore we can set up paging on a Ext.grid.Panel, we have to configure the Ext.data.Store to support paging. In the below example we add Ext.data.Store#pageSize to the Ext.data.Store, and we configure our Ext.data.reader.Reader with a Ext.data.reader.Reader#totalProperty:\n\nThe Ext.data.reader.Reader#totalProperty config tells Ext.data.reader.Json where to get the total number of results in the JSON response. This Ext.data.Store is configured to consume a JSON response that looks something like this:\n\nNow that we've set up our Ext.data.Store to support paging, all that's left is to configure a Ext.toolbar.Paging. You could put the Ext.toolbar.Paging anywhere in your application layout, but typically it is docked to the Ext.grid.Panel:\n\nSee the Paging Grid for a working example.\n\nGrids and Trees enable buffered rendering of extremely large datasets as an alternative to using a paging toolbar. Your users can scroll through thousands of records without the performance penalties of renderering all the records on screen at once.\n\nOnly enough rows are rendered to fill the visible area of the Grid with a little Ext.grid.Panel#cfg-leadingBufferZone overflow either side to allow scrolling. As scrolling proceeds, new rows are rendered in the direction of scroll, and rows are removed from the receding side of the table.\n\nGrids use buffered rendering by default, so you no longer need to add the plugin to your Grid component.\n\nSee Big Data of Filtered Tree for working examples.\n\nSince ExtJS 5.0, developers have had the ability to embed components within grid cells using the Widget Column class.\n\nIn versions prior to 6.2.0, components embedded in this way had no access to the grid's . The field referenced by the column's was bound to the component's .\n\nIn 6.2.0, components embedded in grids have access to the ViewModel and all the data within it. The ViewModel contains two row-specific properties:\n\nSince ExtJS 6.2.0, developers have had the ability to configure a component to be displayed in an expansion row below (or, configurably, above) the data row.\n\nThe embedded component has access to the grid's ViewModel.\n\nSee Using Components in Grids guide for more details."
    }
]