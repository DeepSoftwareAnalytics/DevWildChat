[
    {
        "link": "https://github.com/dart-lang/language/issues/356",
        "document": "Hi, trying to produce some generic code, I discovered that interfaces can't have non-implemented static methods.\n\nBut it would be a nice feature to allow this.\n\nI can illustrate it by this piece of Rust code:\n\nI tried to produce a non-working equivalent in Dart:"
    },
    {
        "link": "https://github.com/dart-lang/language/issues/2089",
        "document": "Sometimes there are situations when it would be great to write something like this:\n\nRecently I worked on a tool for loading data from a database. When you work with a database, you know the type of loaded value, but you need the same unified method for data deserialization for different types. Currently, you can use the Factory pattern:\n\nWith static interfaces this could be much shorter:\n\nHive - they use Hive.registerAdapter but could use this feature\n\n more about registerAdapter"
    },
    {
        "link": "https://dart.dev/language/classes",
        "document": "Dart is an object-oriented language with classes and mixin-based inheritance. Every object is an instance of a class, and all classes except descend from . Mixin-based inheritance means that although every class (except for the top class, ) has exactly one superclass, a class body can be reused in multiple class hierarchies. Extension methods are a way to add functionality to a class without changing the class or creating a subclass. Class modifiers allow you to control how libraries can subtype a class.\n\nObjects have members consisting of functions and data (methods and instance variables, respectively). When you call a method, you invoke it on an object: the method has access to that object's functions and data.\n\nUse a dot ( ) to refer to an instance variable or method:\n\nUse instead of to avoid an exception when the leftmost operand is null:\n\nYou can create an object using a constructor. Constructor names can be either or . For example, the following code creates objects using the and constructors:\n\nThe following code has the same effect, but uses the optional keyword before the constructor name:\n\nSome classes provide constant constructors. To create a compile-time constant using a constant constructor, put the keyword before the constructor name:\n\nWithin a constant context, you can omit the before a constructor or literal. For example, look at this code, which creates a const map:\n\nYou can omit all but the first use of the keyword:\n\nIf a constant constructor is outside of a constant context and is invoked without , it creates a non-constant object:\n\nTo get an object's type at runtime, you can use the property , which returns a object.\n\nUp to here, you've seen how to use classes. The rest of this section shows how to implement classes.\n\nAn uninitialized instance variable declared with a nullable type has the value . Non-nullable instance variables must be initialized at declaration.\n\nAll instance variables generate an implicit getter method. Non-final instance variables and instance variables without initializers also generate an implicit setter method. For details, check out Getters and setters.\n\nInitializing a non- instance variable where it's declared sets the value when the instance is created, before the constructor and its initializer list execute. As a result, the initializing expression (after the ) of a non- instance variable can't access .\n\nInstance variables can be , in which case they must be set exactly once. Initialize , non- instance variables at declaration, using a constructor parameter, or using a constructor's initializer list:\n\nIf you need to assign the value of a instance variable after the constructor body starts, you can use one of the following:\n• Use , but be careful: a without an initializer adds a setter to the API.\n\nEvery class implicitly defines an interface containing all the instance members of the class and of any interfaces it implements. If you want to create a class A that supports class B's API without inheriting B's implementation, class A should implement the B interface.\n\nA class implements one or more interfaces by declaring them in an clause and then providing the APIs required by the interfaces. For example:\n\nHere's an example of specifying that a class implements multiple interfaces:\n\nUse the keyword to implement class-wide variables and methods.\n\nStatic variables (class variables) are useful for class-wide state and constants:\n\nStatic methods (class methods) don't operate on an instance, and thus don't have access to . They do, however, have access to static variables. As the following example shows, you invoke static methods directly on a class:\n\nYou can use static methods as compile-time constants. For example, you can pass a static method as a parameter to a constant constructor.\n\nUnless stated otherwise, the documentation on this site reflects Dart 3.7.1. Page last updated on 2025-02-12. View source or report an issue."
    },
    {
        "link": "https://stackoverflow.com/questions/20741737/can-one-declare-a-static-method-within-an-abstract-class-in-dart",
        "document": "Dart doesn't inherit static methods to derived classes. So it makes no sense to create abstract static methods (without implementation).\n\nIf you want a static method in class you have to fully define it there and always call it like\n\nI'm sure I read or heard some arguments from Gilad Bracha about it but can't find it now.\n\nThis behaviour is IMHO common mostly in statically typed languages (I don't know many dynamic languages). A static method is like a top level function where the class name just acts as a namespace. A static method has nothing to do with an instantiated object so inheritance is not applicable. In languages where static methods are 'inherited' this is just syntactic sugar. Dart likes to be more explicit here and to avoid confusion between instance methods and static methods (which actually are not methods but just functions because they don't act on an instance). This is not my primary domain, but hopefully may make some sense anyways ;-)"
    },
    {
        "link": "https://steemit.com/utopianio/@tensor/a-beginners-guide-to-dart---inheritance-abstract-classes-interfaces-mixins-and-casting---part-five",
        "document": "\n• You will learn about Abstract Classes\n• You will learn about Class Inheritance\n• You will learn about Class Interfaces\n• You will learn about Type Casting\n• You will learn about Mixins\n• IDEA intellij or Visual Studio Code with the Dart Plugins\n• A Dart supported text editor (Dart Pad can be used)\n• A little time to sit and watch a video and some patience to learn the language\n\nIn this video tutorial, we continue to look at Object Oriented and Class based Programming in the Dart programming language. To fully understand why Classes and Objects are useful in a programming context, we need to understand inheritance and the Dart single inheritance model. This includes looking at Abstract Classes, Class Interfaces, Mixins and Type Casting. Along the way, we also look at importing libraries and the logical switch statement.\n\nAn abstract class is a type of class that doesn't allow for object instantiation. This tool exists so that developers may further generalize their class blueprints into interfaces. As such, abstract classes are used to define methods and properties without including implementation details. These methods, properties and other details make up the interface of the Class. Dart makes use of these class interfaces to create a description of the complex relationships between classes. This enables Inheritance, Implementations and Mixins despite the language only allowing a single inheritance model.\n\n\n\nIn the example, we take a look at direct inheritance using an abstract class. The class allows us to define the interface for any other objects in our program. To be a type, an object must implement three getter methods; a name method, a area method and a perimeter method. This graph shows the flow of inheritance between the three main classes that we created in the example. and directly inherit from and therefore must have their own implementations of the getters. on the other hand inherits from which allows us to save writing a new implementation of the Interface. While Square's direct parent class is the Class, it still is a type because both implement the interface.\n\nAdding Properties and Methods Without Using Inheritance\n\nDart's single inheritance model may seem restrictive when compared to multiple inheritance models from other programming languages. Dart provides us with several ways to include attributes from multiple other classes outside of inheritance. Every Dart class automatically exposes its interface and a class can implement multiple interfaces which allows us to build composite classes.\n\nIn this image, we have an example of a complex class. This class implements the interfaces for class and class by way of the keyword. must contain the full interface for both and to satisfy this call. also adds a third class called through the use of a Mixin. For a class to be used as a Mixin, it must follow three specific rules. The class must not have a declared constructor, it also can not be a subclass to another class and it must not have any calls to the keyword. When the class fits these rules, its behavior can be mixed directly into another class using the keyword.\n\nThe Source Code for this video may be found here: https://github.com/tensor-programming/dart_for_beginners/tree/tensor-programming-patch-4\n• A Beginners Guide to Dart - Methods, Final, Static, and Class Inheritance - Part Four\n• A Beginners Guide to Dart - Intro to Classes and Objects - Part Three\n• A Beginners Guide to Dart - Control Flow and Low Level Compilation - Part Two\n• A Beginners Guide to Dart - Types, Functions, Variables and Objects - Part One"
    },
    {
        "link": "https://medium.com/@hemant.ramphul/complete-sqlite-crud-operations-in-flutter-6cbba8582c45",
        "document": "Are you a Flutter developer looking for a reliable way to handle local data storage? Look no further! SQLite is here to simplify your life.\n\nTable of content\n\n ∘ What is SQLite?\n\n ∘ Why Choose SQLite?\n\n ∘ What is Sqflite?\n\n ∘ CRUD Operations\n\n ∘ Source Code (GitHub)\n\n ∘ Conclusion\n• SQLite is a C-language library that serves as a self-contained, high-reliability SQL database engine.\n• Most Used: SQLite stands as one of the most widely used database engines worldwide, admired for its efficiency and versatility.\n• Prevalence: It’s not just for developers; SQLite is built into countless mobile phones, computers, and everyday applications that we use, making it an integral part of our digital lives.\n• Performance: Sqflite offers high-performance local data storage, making it suitable for apps of all sizes.\n• Simplicity: With a straightforward API, you can quickly create, read, update, and delete records.\n• Cross-Platform: Flutter is all about cross-platform development, and Sqflite follows suit, supporting both Android and iOS.\n\nSQLite boasts a widespread user base, including tech giants like Google and Apple. Its simplicity and efficiency make it a trusted choice for various applications. Explore the list of famous users on SQLite’s website.\n\nSqflite is a Flutter package that provides a simple and efficient way to work with SQLite databases in your Flutter applications. It’s lightweight, easy to use, and perfect for managing your local data. Everything in this package is asynchronous.\n\nStart harnessing the potential of Sqflite today, whether you’re crafting a minimalist to-do list or embarking on a feature-rich mobile app journey. Sqflite is your key to efficient and robust local data storage in Flutter!\n\nTo integrate SQLite functionality in your Flutter project, follow these steps:\n\n1. Add dependency by open the file in your project directory.\n• : This package provides SQLite database functionality for your Flutter app.\n• : This package allows you to specify the path to the database on your device.\n\n3. Or use command to add the packages as a dependency,\n\n2. After adding these dependencies, run and to fetch and install the packages.\n• In that file, create a model class with the required properties.\n• Implement a `toJson` method within the model class to map its properties into JSON format.\n• Implement a `fromJson` method to convert JSON data fetched from the database into an instance of the Model class.\n• Both the `toJson` and `fromJson` methods are user-defined and customized to handle the specific data conversion requirements.\n• Adding the imports: add the required imports to the database helper file.\n• Open the database: To open the database we use openDatabase the method takes the path and returns a Database object.\n• Initialize the database: declare a function which uses the above imports to open a database connection.\n• To perform operations on a database, the database must be opened.\n• After the database is open, the returned database object can be utilized for a range of operations.\n• When it comes to data insertion, the insert method is employed.\n• With sqflite, data querying offers various options using arguments like where, groupBy, having, orderBy, and columns within the query() helper.\n• Use update() helper to update any record in the database. To update specific records, use the where argument.\n• Use the where argument in delete() helper to delete specific rows from the table.\n• Remember to use whereArgs to pass arguments to where statement in order to prevent SQL injection attacks.\n\nThe source code for this project is available on GitHub. Explore and contribute to the repository to enhance your understanding and collaborate with the community on this Flutter application leveraging Sqflite for local data storage.\n\nIn conclusion, Sqflite is a powerful tool for local data storage in Flutter, providing efficient data management. Whether developing a basic task manager or a complex mobile app, Sqflite, coupled with an OOP approach, offers a reliable foundation for seamless local database operations. Dive into Sqflite today to elevate your Flutter development and ensure robust handling of local data.\n\nThank you for reading! Stay tuned for more exciting articles. Until then, Happy Coding! 💻"
    },
    {
        "link": "https://docs.flutter.dev/cookbook/persistence/sqlite",
        "document": "If you are writing an app that needs to persist and query large amounts of data on the local device, consider using a database instead of a local file or key-value store. In general, databases provide faster inserts, updates, and queries compared to other local persistence solutions.\n\nFlutter apps can make use of the SQLite databases via the plugin available on pub.dev. This recipe demonstrates the basics of using to insert, read, update, and remove data about various Dogs.\n\nIf you are new to SQLite and SQL statements, review the SQLite Tutorial to learn the basics before completing this recipe.\n\nThis recipe uses the following steps:\n\nTo work with SQLite databases, import the and packages.\n• The package provides classes and functions to interact with a SQLite database.\n• The package provides functions to define the location for storing the database on disk.\n\nTo add the packages as a dependency, run :\n\nMake sure to import the packages in the file you'll be working in.\n\nBefore creating the table to store information on Dogs, take a few moments to define the data that needs to be stored. For this example, define a Dog class that contains three pieces of data: A unique , the , and the of each dog.\n\nBefore reading and writing data to the database, open a connection to the database. This involves two steps:\n• Define the path to the database file using from the package, combined with the function from the package.\n• Open the database with the function from .\n\nNext, create a table to store information about various Dogs. For this example, create a table called that defines the data that can be stored. Each contains an , , and . Therefore, these are represented as three columns in the table.\n• The is a Dart , and is stored as an SQLite Datatype. It is also good practice to use an as the primary key for the table to improve query and update times.\n• The is a Dart , and is stored as a SQLite Datatype.\n• The is also a Dart , and is stored as an Datatype.\n\nFor more information about the available Datatypes that can be stored in a SQLite database, see the official SQLite Datatypes documentation.\n\nNow that you have a database with a table suitable for storing information about various dogs, it's time to read and write data.\n\nFirst, insert a into the table. This involves two steps:\n• Use the method to store the in the table.\n\nNow that a is stored in the database, query the database for a specific dog or a list of all dogs. This involves two steps:\n• Run a against the table. This returns a .\n\nAfter inserting information into the database, you might want to update that information at a later time. You can do this by using the method from the library.\n• Use a clause to ensure you update the correct Dog.\n\nIn addition to inserting and updating information about Dogs, you can also remove dogs from the database. To delete data, use the method from the library.\n\nIn this section, create a function that takes an id and deletes the dog with a matching id from the database. To make this work, you must provide a clause to limit the records being deleted.\n\nTo run the example:\n• Add the and packages to your .\n• Paste the following code into a new file called .\n\n// Open the database and store the reference. // Set the path to the database. Note: Using the `join` function from the // `path` package is best practice to ensure the path is correctly // When the database is first created, create a table to store dogs. // Run the CREATE TABLE statement on the database. // Set the version. This executes the onCreate function and provides a // Define a function that inserts dogs into the database // Get a reference to the database. // Insert the Dog into the correct table. You might also specify the // `conflictAlgorithm` to use in case the same dog is inserted twice. // In this case, replace any previous data. // A method that retrieves all the dogs from the dogs table. // Get a reference to the database. // Query the table for all the dogs. // Convert the list of each dog's fields into a list of `Dog` objects. // Get a reference to the database. // Ensure that the Dog has a matching id. // Pass the Dog's id as a whereArg to prevent SQL injection. // Get a reference to the database. // Remove the Dog from the database. // Use a `where` clause to delete a specific dog. // Pass the Dog's id as a whereArg to prevent SQL injection. // Create a Dog and add it to the dogs table // Now, use the method above to retrieve all the dogs. // Update Fido's age and save it to the database. // Convert a Dog into a Map. The keys must correspond to the names of the // Implement toString to make it easier to see information about // each dog when using the print statement."
    },
    {
        "link": "https://github.com/duyhuy27/Flutter-Sqflite-Example-CRUD",
        "document": "A Flutter application showcasing a Patient Management System with basic CRUD functions, login and registration features, and support for dark mode. The app utilizes the Sqflite library for local database management in the Flutter framework.\n• Dark Mode: Enhance user experience with a dark mode option for comfortable usage in low-light environments.\n• Run the app on your preferred Flutter development environment or build it for the desired platform.\n\nIf you'd like to contribute to the project, please follow the contribution guidelines.\n\nThis project is licensed under the MIT License.\n• Special thanks to Flutter for providing an excellent framework for building cross-platform mobile applications.\n• Inspired by the need for efficient patient management systems in healthcare.\n\nFor inquiries or suggestions, please feel free to open an issue or contact the project maintainer at huynd.mob@ambitionx.io.vn"
    },
    {
        "link": "https://stackoverflow.com/questions/78329221/sqflite-package-problem-while-making-a-simple-app-for-implementing-crud-operatio",
        "document": "I'm learning Flutter. I have created an Flutter app (Project) named my_diary_using_sqflite for practicing CRUD operation in SQLite Database.\n\nBut I'm stuck among sqflite package and sqflite_common_ffi package and sqflite_common_ffi_web package.\n\nI'm presenting two dart files code here, I think the problem is in those two files.\n\n1. note_repository.dart [ This is the file where I write the code of all CRUD operation function and Database related functions ]\n\nWhen I run the app in Windows (Chrome), and after going the screen of add new note and when I click on submit checkmark icon after filling the form by entering Title and Description, Error is\n• Error: Bad state: databaseFactory not initialized databaseFactory is only initialized when using sqflite. When using \n\n You must call before using global openDatabase API *\n\nIt is saying that i'm using sqflite_common_ffi, but in fact, I use sqflite\n\nhere, extra dependencies were added after the error come into my way one by one..\n\nand after this first Error of sqflite_common_ffi of databaseFactory, I made a change to my 2. main.dart file, that is\n\nand then I feel that now it will work for me. but again i run the app, and this time only white screen with Error :\n\nRejecting promise with error: Unsupported operation: Unsupported on the web, use sqflite_common_ffi_web\n\nThat's why, I decided to add sqflite_common_ffi_web dependency, But not went out from this errors. The problem may be path related, but direct me what is the actual problem? And How it can be solved. That's why I can perform CRUD operation successfully. :)"
    },
    {
        "link": "https://medium.com/@zaidqassim.me/flutter-sqlite-tutorial-mastering-full-crud-operations-bbdfee00d80c",
        "document": "Now, you’re ready to integrate SQLite into your Flutter apps and take control of offline data storage.\n\nWhat will you build next? Share your thoughts in the comments below! 🚀"
    },
    {
        "link": "https://codewithandrea.com/articles/flutter-repository-pattern",
        "document": "Design patterns are useful templates that help us solve common problems in software design.\n\nAnd when it comes to app architecture, structural design patterns can help us decide how the different parts of the app are organized.\n\nIn this context, we can use the repository pattern to access data objects from various sources, such as a backend API, and make them available as type-safe entities to the domain layer of the app (which is where our business logic lives).\n\nAnd in this article, we'll learn about the repository pattern in detail:\n• what it is and when to use it\n• implementation details using concrete or abstract classes and their tradeoffs\n• how to test code with repositories\n\nAnd I'll also share an example weather app with complete source code.\n\nWhat is the repository design pattern?\n\nTo understand this, let's consider the following architecture diagram:\n\nIn this context, repositories are found in the data layer. And their job is to:\n• isolate domain models (or entities) from the implementation details of the data sources in the data layer.\n• convert data transfer objects to validated entities that are understood by the domain layer\n\nAlso note how the widgets belong to the presentation layer, which has nothing to do with business logic or networking code.\n\nWhen to use the repository pattern?\n\nThe repository pattern is very handy if your app has a complex data layer with many different endpoints that return unstructured data (such as JSON) that you want to isolate from the rest of the app.\n\nMore broadly, here are a few use cases where I feel the repository pattern is most appropriate:\n• talking to local or remote databases (e.g. Sembast, Hive, Firestore, etc.)\n\nOne great benefit of this approach is that if there are breaking changes in any 3rd party APIs you use, you'll only have to update your repository code.\n\nAnd that alone makes repositories 100% worth it. 💯\n\nSo let's see how to use them! 🚀\n\nAs an example, I've built a simple Flutter app (here's the source code) that pulls weather data from the OpenWeatherMap API.\n\nBy reading the API docs, we can find out how to call the API, along with some examples of response data in JSON format.\n\nAnd the repository pattern is great for abstracting away all the networking and JSON serialization code.\n\nFor example, here's an abstract class that defines the interface for our repository:\n\nThe above has only one method, but there could be more (for example, if you wanted to support all the CRUD operations).\n\nWhat matters is that the repository allows us to define a contract for how to retrieve the weather for a given city.\n\nAnd we need to implement the with a concrete class that makes the necessary API calls using a networking client such as http or dio:\n\nAll these implementation details are concerns of the data layer, and the rest of the app shouldn't care or even know about them.\n\nOf course, we'll also have to define a model class (or entity), along with the JSON serialization code for parsing the API response data:\n\nNote that while the JSON response may contain many different fields, we only need to parse the ones that will be used in the UI.\n\nOnce we have defined a repository, we need a way to initialize it and make it accessible to the rest of the app.\n\nThe syntax for doing this changes depending on your DI/state management solution of choice.\n\nHere's an example using get_it:\n\nHere's another using a provider from the Riverpod package:\n\nAnd here's the equivalent if you're into the flutter_bloc package:\n\nThe bottom line is the same: once you've initialized your repository, you can access it anywhere else in your app (widgets, blocs, controllers, etc.).\n\nOne common question when creating repositories is this: do you really need an abstract class, or can you just create a concrete class and do away with all the ceremony?\n\nThis is a very valid concern since adding more and more methods across two classes can become quite tedious:\n\nAs is often the case in software design, the answer is: it depends.\n\nSo let's take look at some pros and cons of each approach.\n• Pro: it's nice to see the interface of our repository in one place, without all the clutter.\n• Pro: we can swap the repository with a completely different implementation (e.g. rather than ), and change just one line in the initialization code, because the rest of the app only knows about .\n• Con: VSCode will get a bit confused when we \"jump to reference\" and take us to the method definition in the abstract class, rather than the implementation in the concrete class.\n• Pro: \"jump to reference\" just works as the repository methods will be found in one class only.\n• Con: swapping to a different implementation requires more changes if we change the repository name (though it's easy to rename things across the entire project with VSCode).\n\nWhen deciding which approach to use, we should also figure out how to write tests for our code.\n\nOne common requirement during testing is to swap out the networking code with a mock or \"fake\" so that our tests run faster and more reliably.\n\nHowever, abstract classes don't give us any advantage here, because in Dart all classes have an implicit interface.\n\nThis means that we can do this:\n\nIn other words, there's no need to create abstract classes if we intend to mock our repositories in the tests.\n\nIn fact, packages like mocktail use this to their advantage and we can use them like so:\n\nAs you write your tests, you can mock your repositores and return canned responses like we did above.\n\nBut there's another option, and that is to mock the underlying data source.\n\nLet's recall how the was defined:\n\nIn this case, we can choose to mock the object that is passed to the constructor. Here's an example test showing of how you may do this:\n\nIn the end, you can choose if you want to mock the repository itself or the underlying data source, depending on what you're trying to test.\n\nHaving figured out how to test repositories, let's get back to our initial question about abstract classes.\n\nRepositories may not need an abstract class\n\nIn general, creating an abstract class makes sense if you need many implementations that conform to the same interface.\n\nFor example, both and are abstract classes in the Flutter SDK, because they are meant to be subclassed.\n\nBut when working with repositories, you'll likely need only one implementation for a given repository.\n\nPutting everything behind an interface can also lock you into choosing the lowest common denominator between APIs that have different capabilities.\n\nMaybe one API or backend supports realtime updates, which can be modeled with a Stream-based API.\n\nBut if you're using pure REST (without websockets), you can only send a request and get a single response, which is best modeled with a Future-based API.\n\nDealing with this is quite easy: just use a stream-based API, and just return a stream with one value if you're using REST.\n\nBut sometimes there are broader API differences.\n\nFor example, Firestore supports transactions and batched writes. These kinds of APIs use the builder pattern under the hood, in a way that is not easily abstracted away behind a generic interface.\n\nAnd if you migrate to a different backend, chances are that the new API will be considerably different. In other words, future-proofing your current APIs is often impractical and counter-productive.\n\nAs your application grows, you may find yourself adding more and more methods to a given repository.\n\nThis is likely to happen if your backend has a large API surface, or if your app connects to many different data sources.\n\nIn this scenario, consider creating multiple repositories, keeping related methods together. For example, if you're building an eCommerce app, you could have separate repositories for product listings, shopping cart, orders management, authentication, checkout, etc.\n\nAs usual, keeping things simple is always a good idea. So don't get too wound up overthinking your APIs.\n\nYou can model your repository's interface after the API that you need to use, and call it a day. You can always refactor later if needed. 👍\n\nIf there's one thing I'd like you to take away from this article, it would be this:\n\nIf anything, I hope this overview has encouraged you to think more clearly about app architecture and the importance of having separate presentation, application, domain, and data layers, with clear boundaries.\n\nAnd for more details about this architecture and each individual layer, check the remaining articles in this series:\n\nFlutter Foundations Course Now Available\n\nI launched a brand new course that covers Flutter app architecture in great depth, along with other important topics like state management, navigation & routing, testing, and much more:"
    },
    {
        "link": "https://medium.com/@imaakashagrawal/dart-clean-architecture-repository-pattern-085434aa2277",
        "document": "In Dart (and Flutter), the Repository Pattern is a design pattern that helps you separate your app’s data layer from the rest of the app, making it easier to manage and test. With this pattern, the repository acts as a bridge between the app’s data sources (e.g., APIs, databases, or local storage) and the business logic or UI, providing a clean, structured way to access data.\n\nWhy Use the Repository Pattern?\n\nThe main goals of the Repository Pattern are to:\n• Abstract data sources: Make the rest of your app agnostic to where data is coming from (like local databases or remote APIs).\n• Encapsulate data logic: Keep data fetching, caching, and manipulation logic in one place, so the UI code is not cluttered with these details.\n• Enable easy testing: By creating a single interface for data access, you can mock the repository in tests, making unit testing straightforward.\n\nWith the Repository Pattern, you:\n• Define a repository interface to specify which data functions the repository will offer.\n• Implement one or more concrete repositories that fetch data from APIs, databases, etc.\n• Use a repository instance in your business logic (e.g., in a BLoC or ViewModel) to fetch and manipulate data.\n\nBasic Example of a Repository Pattern in Dart\n\nSuppose we have an app that fetches user data from both a remote API and a local database. Let’s implement a that retrieves this data.\n\nCreate an abstract class to define the methods the repository will provide.\n\nNow, implement repositories to handle different data sources, such as an API and a local database.\n\nStep 4: Use the Repository in Business Logic\n\nNow you can use in your BLoC, ViewModel, or any other business logic to fetch and display data without worrying about where it’s coming from.\n• Decouples data sources: You can switch data sources without changing the business logic.\n• Cleaner code: Keeps data-fetching logic out of the UI.\n\nWhen to Use the Repository Pattern\n\nUse the Repository Pattern when:\n• You have multiple data sources (like local and remote) for the same data.\n• You want to separate data handling from UI components.\n• You want a more testable, maintainable data layer."
    },
    {
        "link": "https://blog.logrocket.com/implementing-repository-pattern-flutter",
        "document": "Flutter developers use various design patterns to write clean and maintainable codebases. They often write reusable widget implementations in individual Dart files, separate the main app screens into different files, and decompose large and isolated widgets into private methods/classes.\n\nBut we can also use generic software design patterns in our Flutter apps to improve the quality of the codebase. For example, design concepts like the MVC (Model–view–controller) architecture, repository pattern, service model pattern, and Data Transfer Object (DTO) can also help us to write manageable codebases. The repository pattern in particular motivates us to decouple data access logic (database layer interface) from the business logic via an additional abstraction layer.\n\nAlmost all Flutter apps use data sources for data persistence and retrieval. The repository pattern is helpful for all Flutter developers in learning how to organize their code in a better, more manageable way. In this tutorial, I will explain how you can implement a repository pattern in your Flutter applications.\n• What is the repository pattern?\n• Defining models and setting up the repository\n• Using the repository from the Flutter application frontend\n• How to write unit tests for the repository pattern\n\nWhat is the repository pattern?\n\nThe repository pattern is a software design pattern that decouples the data access logic from the business logic by introducing a centralized component called a repository. Look at the following diagram. As you can see in the above diagram, the generic repository pattern consists of three inter-connected components:\n• Client — refers to a component that initiates the data request, like a controller or service\n• Repository — provides data in a domain-friendly format via a specific API, and doesn’t let clients directly access data from the source\n• Data source — provides data records according to a data-layer-specific format; the data source can be a RESTful API, SQLite connection, or MongoDB connection\n\nAssume we are going to build a repository called . The can expose a method to list all book titles in a given database. Then, everywhere you need to retrieve , you can access the , rather than writing repetitive code to find books from the data source.\n\nThe repository pattern offers us the following key benefits:\n• It gives a way to access data from a centralized location to prevent data-access-related code repetition\n• The codebase becomes more unit-testable because the data layer gets decoupled from the business logic\n• We can easily switch data sources without doing time-consuming code changes\n\nNow that we know the theoretical background behind the repository pattern, let’s implement one in our Flutter app.\n\nThere is indeed not a strict rule about how to implement a repository pattern in real-world apps, like any other design pattern principle — this pattern teaches you a generic design concept to decouple data access logic. However, most developers recommend exposing CRUD (Create, Read, Update, and Delete) operations from repositories. Also, as a best practice, we’ll create one repository for each business entity.\n\nLet’s implement a simple bookstore application with the CRUD-based repository pattern. Note that we will use a virtual data layer (a mock database provider) as our data provider infrastructure to focus solely on the repository pattern implementation. You can replace any data layer API such as SQLite, Firebase, or another RESTful API with this virtual data layer module.\n\nYou can try this example application by creating a new Flutter application, or you can use these design principles in your existing Flutter project. If you plan to begin with a new project, enter the following command to create the bookstore app.\n\nRun the app with the following command to get it started. You can test this example on Chrome, mobile, or desktop window, since Flutter is a universal app development framework.\n\nDefining models and setting up the repository\n\nRepositories don’t expose the internal data source’s structures or data formats — they expose data via models, also known as DTOs.\n\nThe bookstore app will show some details about books, so we need to create a book model. Add the following code to\n\nThe above code defines a model for the business entity with several properties and methods. We are planning to build a virtual database access layer with Dart Maps, so here, we created and helper functions for type conversion purposes.\n\nNow we need to create a virtual data access layer. This module will simulate a data provider like a RESTful API or database connection with a simple Dart class. Add the following code to .\n\nThe above singleton class implements several functions to add, edit, remove, and retrieve key-value-based data records. As you may have already noticed, we made all operations asynchronous to simulate a real data layer connection. Also, the list operation simulates a data read delay with the function.\n\nThe repository pattern motivates us to consume a data layer connection via a repository class — so, we need to create a repository class for the business entity.\n\nBut, first, we need to create the base repository interface as a good practice. Then we can write multiple concrete repositories by implementing the same interface. For example, you can create book repository implementations for various data sources — a SQLite-based book repository, aRESTful book repository, etc. — with this base interface.\n\nAdd the following code to :\n\nNow, let’s create a concrete implementation for the book repository using the above interface definition. Add the following code to :\n\nThe above code snippet implements the book repository via the previous book repository interface definition by overriding all abstract methods.\n\nNote that, at this level, we only expose functions using business entities. For example, we can insert a new book into our virtual database by sending a instance. At this level, we added an abstraction layer on top of the data access layer, so we don’t need to consider our virtual database layer for the next steps.\n\nBesides, this repository layer is the highest layer where we directly access the database layer.\n\nUsing the repository from the Flutter application frontend\n\nOur book repository is now ready to be used. Let’s move on to creating a frontend for our bookstore app.\n\nWe typically don’t add data processing logic to views (Flutter widgets) to keep UI logic decoupled from the main business logic. Therefore, we can create a controller/service to manipulate data from the widget level.\n\nLet’s assume that we need to implement a frontend for adding, displaying, and removing books. We’ll then need to expose the required functionality via a controller.\n\nAdd the following code to to create a controller for the homepage.\n\nOur controller class is ready; it exposes functions for listing, adding, and removing books by wrapping the book repository API.\n\nNow we can build the frontend for the bookstore app. Replace your existing file’s code with the following Dart code.\n\nThe above UI code implements a multi-component single-page application with a form and data table. The form component lets the user add new books, and the data table component displays all book information. Besides, the user can remove a book from the store by tapping on the trash bin icon.\n\nHere, we added the entire UI into a single Dart file by using a callback-based state management approach . This mainly works because we have only one application screen. However, when you are developing large-scale Flutter apps with multiple screens, it’s always good to use multiple Dart files and select a flexible state management approach (the Flutter team recommends Provider).\n\nNote the following important points about the above UI source code:\n• It doesn’t directly access the book repository or database layer, but gains access to stored books via the instance\n• We used the class to render UI conditionally with asynchronous data retrieval. The class provides a productive way to display another widget until the asynchronous operation completes; in our case, we show a text label until we receive all books from the repository\n• The Add book button inserts a new book to the virtual database by creating a new instance of the Book DTO with the data obtained from the text editing controllers\n\nCheck your application, add new books, and try to remove existing books, as shown below.\n\nThe bookstore app supports adding, listing, and removing book entities via the book repository instance. Similarly, you can add another screen to update a selected book by using the and repository functions. The pattern is the same — you need to expose necessary repository functions via the controller to the stateful widget.\n\nThe full source code is available at my GitHub repository.\n\nHow to write unit tests for the repository pattern\n\nYou can implement unit testing for different elements of your Flutter applications, such as widgets, controllers, models, services, and repositories. It’s possible to unit-test repository-based Flutter codebases with the following strategies:\n\nYou don’t need to implement mock classes by yourself — the Mockito package helps you to generate them quickly and automatically. If you need to test the repository with a mock database class, you can pass the mock database instance to the repository, as shown below.\n\nOur bookstore application had only one business object and one repository. But, as we alluded to earlier, you may have to work with many business entities if you work with large-scale Flutter apps. How can we create multiple repositories for many business objects?\n\nAssume that we also need to manage e-books in the bookstore app we have made. Now we have two business entities: and .\n\nWe can organize our code with some additional classes with Dart generics syntax, as shown in the following steps.\n\nFirst, we need to define our models:\n\nNext, create a generic interface for the base repository definition.\n\nNow you can either write multiple concrete repositories or one generic concrete repository, according to your project’s architectural requirement. However, adding one generic repository implementation is a good way to avoid code repetition in all scenarios. Look at the following class.\n\nNote that, here, we are accepting only the type for generics with the definition. Finally, you can use the above with different sub-classes, as shown below.\n\nYou can inspect and run this example online from my DartPad.\n\nThe repository pattern looks somewhat similar to a Data Access Object (DAO) — not to be confused with Decentralized Autonomous Organizations (DAOs) — and service patterns, but there are several noticeable differences, as explained in the table below.\n\nWe learned how to implement the repository design pattern for Flutter applications with a sample app. Flutter app development teams use various design patterns for organizing code and managing the app state. For example, they often use various state management packages such as Redux, Riverpod, or Provider. They may also organize codebases with the MVC pattern, reusable components, inheritance, and reusable generic functions.\n\nThe repository concept also provides a way to organize code by creating another abstraction layer. If you need to process business entities, you can create a service class by wrapping a repository instance (or many) as we created a controller.\n\nWe can also hide the complexity of the data persistence layer by creating a DAO with repositories, but don’t over-engineer small or medium-scale apps with many classes, as these complex design patterns primarily exist for handling large-scale applications’ complexities."
    },
    {
        "link": "https://dhiwise.com/post/the-complete-guide-to-the-repository-pattern-in-flutter",
        "document": "Hello Flutter enthusiasts! In this blog post, we are going to unearth the power of the Repository Pattern in Flutter. Flutter, as most of you already know, is a free and open-source UI software development kit created by Google. It's used for developing natively compiled applications for mobile, web, and desktop from a single codebase.\n\nTo tap into its full potential, a well-structured app architecture is crucial. This is where the Repository Pattern comes into play. This is a popular design pattern that helps to centralize the data access logic in a solution, leading to more maintainable and flexible software. This blog post is your guide to understanding the nuances of the Repository Pattern, particularly in relation to Flutter.\n\nIn the repository pattern's context, Flutter distinguishes itself by providing a robust environment that not only supports but also reaps considerable benefit from this advanced pattern. Here is why:\n\nThe Repository Pattern promotes a clean architecture by separating the data access logic and business logic of an app. The repository class acts as a middleman between the data layer and the business layer. The presentation layer, thus, remains unaffected by where the data originates (remote database or local storage), leading to an uncluttered UI.\n\nThe repository design pattern seamlessly manages the flow of data from various data sources. This ability to gather and distribute data from multiple repositories provides the app with versatility and adaptability, essential attributes in today's ever-evolving software domain.\n\nBy isolating the data access logic from the business logic, testing becomes more efficient. You can easily test your business entities and domain models without dependence on data source availability or slow tests due to interaction with external APIs.\n\nThe repository pattern offers great advantages in a flutter project. To take these advantages further, it is important to implement the pattern effectively.\n\nThe theory and charm of the Repository Pattern are breezy; on the surface, it seems like a pretty straightforward concept - but, when it comes to actual implementation, there's more to the story. Let's dig deeper.\n\nAt the core of the repository pattern is the tenet of Segregation of Duties. This principle propels the need to separate the concerns of accessing databases and the business logic. By isolating these concerns, you can maintain the integrity of your Flutter applications and have a clear view of the data flow.\n\nThe repository pattern primarily consists of three integral components: Model, Repository, and Data Provider.\n\nModels reflect the domain objects or entities of your app. They consist of properties and methods that encapsulate business logic relevant to the entity.\n\nThe Repository or the repository class serves as an intermediary between the data layer and the business layer in your app. It is the gatekeeper that determines how data is fetched, saved, or manipulated before it reaches the UI or the business layer.\n\nThe Data Provider works intimately with repositories to help them manage data. It encapsulates implementation details of data access from various data sources, delivering a homogenized data format to the repositories.\n\nBenefits of using the Repository Pattern\n\nThe repository pattern brings about a distinct order and purpose-oriented structure to your Flutter project. While it drastically separates the concerns, it also knits them together in an organized manner to create a streamlined app architecture. The availability of multiple repositories allows more flexibility, and the use of a generic interface further optimizes data management.\n\nBefore we can implement the repository pattern in Flutter, we first need to ensure that our Flutter environment is prepared. It's important to have a solid foundation before you build, especially when managing complex topics like data architecture in Flutter apps.\n\nBefore we start, there are a few things you should have:\n• Latest Flutter SDK installed and configured in your system.\n• A basic understanding of Dart, which is the language used by Flutter.\n\nInstructions to set up the environment\n\nTo kick-start your Flutter project, simply follow these steps:\n\nStep 1: First, create a new Flutter project using the following command:\n\nStep 2: Verify your installation with the command:\n\nStep 3: Create a new Dart file, and name it repo.dart, where you'll be writing your repository code and functions.\n\nHaving set up the Flutter environment, let's explore the heart of the matter, Flutter repositories. The way data is handled in Flutter projects adheres to the primary principles of the repository pattern and thereby leads to an easily manageably state.\n\nA typical Flutter repository is composed of several key components:\n• Data Models: These are the classes that define the data structure of your app. They usually mirror the structure of the data in your database.\n• Data Sources: They are responsible for fetching the data from the database or any remote API.\n• Repository: The repository takes data from different data sources and delivers it to the UI.\n\nIn the Flutter framework, a repository class plays a central role in managing and organizing data. It provides a clean API to the rest of the app for data access. The repository is also responsible for all the CRUD operation.\n\nCrafting Your First Repository in Flutter: A Step-by-Step Guide\n\nWith the understanding of the role of a Repository in a Flutter app, now let's unfold the magic of creating your repository. We'll go step by step for a structured implementation.\n\nBefore diving into creating multiple repositories, it's advantageous to plan ahead. Define what kind of data your application requires. Is it a network REST API, or a local SQLite database, or maybe even both? Based on this, plan your repository structure.\n\nThis is where our interaction with the raw data happens. We define our data source here, fetch data, and parse responses. For our purpose, let's consider a remote data provider that fetches user information from a REST API. We create an abstract class to define methods we will implement:\n\nAfter having your data provider set up, it's time to create our User model. It’s always considered a good practice to use named constructors for parsing raw json data into Dart models.\n\nNow comes the most important part of our application - creating the Repository. The repository uses the abstract class we made in our data provider. Thus, we can have multiple instances providing different ways for CRUD operations, like from a REST API or SQLite database.\n\nGiven a theoretical explanation and detailed steps of creating a Repository, let's apply these principles to a practical Flutter repository example.\n\nSuppose we have a user management app, which can fetch user data and perform CRUD operations. However, with increased app complexity, managing data access started to be challenging, and hence, we decide to use the Repository Pattern.\n\nIn our previous steps, we create a remote data provider, a User model, and now we will create the UserRepository.\n\nThis is how we implement a Repository Pattern in Flutter. This organization of code helps to avoid code repetition, and improves the maintainability of our Flutter app.\n\nOnce you've implemented the Repository pattern in your application, it's vital to ensure everything is working as expected. Perform tests at various levels - unit tests, integration tests, and UI tests - to ensure the seamless functionality of your application.\n\nEnsuring the correctness of your code is vital, and it's impossible to overstate the importance of testing in this context. As our repository is the centerpiece where all app data gather, testing our repository is fundamental.\n\nIn the Flutter universe, testing consists of three levels:\n• Unit Tests: Verify the functionality of a method or class.\n• Integration Tests: Test a complete app or a large part of an app.\n\nFor our repository, we would focus on Unit Tests.\n\nWe perform the test by creating a mock data provider and checking if methods are called using the mockito package.\n\nTesting allows validating the correctness of our repository and ensures that our application code interacts properly with the repositories. Enhance your code quality by regularly testing your Flutter repositories.\n\nPitfalls to Avoid When Implementing Repository Pattern in Flutter\n\nWhile implementing the repository pattern in Flutter provides various benefits, there are potential pitfalls to be aware of. By pinpointing these, we can ensure a more robust and scalable Flutter project.\n\nPerhaps the most common error is not fully adhering to the principle of separation of concerns. This leads to entities having too many responsibilities, which in turn can cause challenges with maintainability and testing.\n\nAnother mistake to be cautious about is not creating a clear distinction between local and remote data sources. This can lead to unnecessary complications and hinder the goal of creating a seamless data flow.\n• Think Long-term: Plan out your app architecture ahead of implementation. Identify and segregate responsibilities.\n• Use Interfaces: Always program to an interface, not to an implementation. This ensures flexibility and makes your code more resistant to changes.\n• Code Reviews: Regularly review your code to detect and correct potential issues early on.\n\nAs we distil down, the Repository Pattern shines as an amazing tool that helps decouple the business logic and data access logic in a Flutter application. It enables a clean and efficient method of dealing with data sources, thus assisting you in maintaining a high code quality in your Flutter app.\n\nThe Repository Pattern in Flutter provides a structured way of handling data operations. It saves you from redundant code, enhances scalability, and helps in creating more maintainable software. It also amplifies the ease of testing for enhancing software quality.\n\nThe path to mastering the Repository Pattern, or any pattern, is through continuous learning and practice. Regularly broadly studying software design and architecture principles can help you build robust and scalable Flutter applications. Keep refining your skills and fuel yourself with the motivation to advance on this journey. And most importantly, enjoy the process!\n\nHappy coding, and here's to creating powerful, scalable Flutter apps that run with smoother data operations, all thanks to the Repository Design Pattern!\n\nShort on time? Speed things up with DhiWise!\n\nTired of manually designing screens, coding on weekends, and technical debt? Let DhiWise handle it for you!\n\nYou can build an e-commerce store, healthcare app, portfolio, blogging website, social media or admin panel right away. Use our library of 40+ pre-built free templates to create your first application using DhiWise."
    },
    {
        "link": "https://medium.com/@mahmoudsaal7/repository-pattern-in-flutter-enhancing-your-apps-architecture-56579831c498",
        "document": "Flutter, the UI toolkit from Google, has gained immense popularity for building beautiful and natively compiled applications. However, as Flutter applications grow in complexity, managing data efficiently becomes crucial. Enter the repository pattern — a strategic solution for effective data management. This article delves into what the repository pattern is, its significance in Flutter, and when it’s most advantageous to use.\n\nAt its core, the repository pattern is a design principle used to manage data flow between the application and data sources (like databases or network requests). It acts as a middle layer, a bridge if you will, between the business logic and data fetching mechanisms. This abstraction ensures that your business logic doesn’t need to know where or how data is stored or retrieved.\n\nAdvantages of the Repository Pattern in Flutter\n• Separation of Concerns: It keeps the UI and logic separate from data source operations, resulting in a cleaner and more organized codebase.\n• Simplification of Data Handling: With a centralized repository, data management becomes more straightforward and consistent.\n• Enhanced Testability: Testing becomes easier as you can mock the repositories instead of real data sources.\n\nStep 1: Define Data Sources: The first step is to define your data sources. These are the classes responsible for fetching data from different sources like APIs, local databases, or even mock sources for testing.\n\nStep 2: Define a Repository Interface: This interface outlines the data operations without being dependent on their concrete implementations.\n\nStep 3: Create Repository Implementations: The repository implementations will use the data source objects to fetch data. This way, the repository acts as a mediator between the business logic and data fetching mechanisms.\n\nStep 4: Use the Repository in Business Logic: Access data through the repository interface, making your business logic agnostic of data source details.\n\nWhen to Use the Repository Pattern\n\nThis pattern is particularly useful when:\n• There are multiple sources of data.\n• You need to abstract the data-fetching mechanism from the rest of your application.\n• Your application requires a clear separation of concerns for maintainability and scalability.\n• Creating too many layers that can overcomplicate simple data fetch operations.\n• Keep data sources simple and focused on fetching data.\n• Use dependency injection to manage data sources and repository instances, enhancing testability.\n\nIncorporating data sources in the repository pattern in Flutter adds an extra layer of abstraction, making your application more scalable and maintainable. It allows for a clean separation between how data is fetched and how it’s consumed in your business logic. This pattern is highly effective for complex applications with diverse data management needs."
    }
]