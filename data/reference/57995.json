[
    {
        "link": "https://forum.arduino.cc/t/how-to-control-the-pwm-output-of-the-nano/1126688",
        "document": "How To Change the PWM Frequency Of Arduino for Beginners - NerdyTechy\n\nTutorial How To Change the PWM Frequency Of Arduino. Changing the PWM Frequency on the ATmega328 (Arduino UNO/Nano/Pro Mini). Check it Now!"
    },
    {
        "link": "https://arduino.cc/en/Tutorial/SecretsOfArduinoPWM",
        "document": ""
    },
    {
        "link": "http://righto.com/2009/07/secrets-of-arduino-pwm.html",
        "document": "Pulse-width modulation (PWM) can be implemented on the Arduino in several ways. This article explains simple PWM techniques, as well as how to use the PWM registers directly for more control over the duty cycle and frequency. This article focuses on the Arduino Diecimila and Duemilanove models, which use the ATmega168 or ATmega328.\n\nIf you're unfamiliar with Pulse Width Modulation, see the tutorial. Briefly, a PWM signal is a digital square wave, where the frequency is constant, but that fraction of the time the signal is on (the duty cycle) can be varied between 0 and 100%. \n\n \n\n PWM has several uses:\n• Providing an analog output; if the digital output is filtered, it will provide an analog voltage between 0% and 100% .\n• Generating a modulated signal, for example to drive an infrared LED for a remote control.\n\nThe Arduino's programming language makes PWM easy to use; simply call, whereis a value from 0 to 255, andis one of the PWM pins (3, 5, 6, 9, 10, or 11). Thefunction provides a simple interface to the hardware PWM, but doesn't provide any control over frequency. (Note that despite the function name, the output is a digital signal.)\n\nProbably 99% of the readers can stop here, and just use , but there are other options that provide more flexibility.\n\nYou can \"manually\" implement PWM on any pin by repeatedly turning the pin on and off for the desired times. e.g.This technique has the advantage that it can use any digital output pin. In addition, you have full control the duty cycle and frequency. One major disadvantage is that any interrupts will affect the timing, which can cause considerable jitter unless you disable interrupts. A second disadvantage is you can't leave the output running while the processor does something else. Finally, it's difficult to determine the appropriate constants for a particular duty cycle and frequency unless you either carefully count cycles, or tweak the values while watching an oscilloscope.The ATmega168P/328P chip has three PWM timers, controlling 6 PWM outputs. By manipulating the chip's timer registers directly, you can obtain more control than thefunction provides.\n\nThe AVR ATmega328P datasheet provides a detailed description of the PWM timers, but the datasheet can be difficult to understand, due to the many different control and output modes of the timers. The following attempts to clarify the use of the timers.\n\nThe ATmega328P has three timers known as Timer 0, Timer 1, and Timer 2. Each timer has two output compare registers that control the PWM width for the timer's two outputs: when the timer reaches the compare register value, the corresponding output is toggled. The two outputs for each timer will normally have the same frequency, but can have different duty cycles (depending on the respective output compare register).\n\nEach of the timers has a prescaler that generates the timer clock by dividing the system clock by a prescale factor such as 1, 8, 64, 256, or 1024. The Arduino has a system clock of 16MHz and the timer clock frequency will be the system clock frequency divided by the prescale factor. Note that Timer 2 has a different set of prescale values from the other timers.\n\nThe timers are complicated by several different modes. The main PWM modes are \"Fast PWM\" and \"Phase-correct PWM\", which will be described below. The timer can either run from 0 to 255, or from 0 to a fixed value. (The 16-bit Timer 1 has additional modes to supports timer values up to 16 bits.) Each output can also be inverted.\n\nThe timers can also generate interrupts on overflow and/or match against either output compare register, but that's beyond the scope of this article.\n• Waveform Generation Mode bits (WGM): these control the overall mode of the timer. (These bits are split between TCCRnA and TCCRnB.)\n\nSeveral registers are used to control each timer. The Timer/Counter Control Registers TCCRnA and TCCRnB hold the main control bits for the timer. (Note that TCCRnA and TCCRnB do not correspond to the outputs A and B.) These registers hold several groups of bits:The Output Compare Registers OCRnA and OCRnB set the levels at which outputs A and B will be affected. When the timer value matches the register value, the corresponding output will be modified as specified by the mode.\n\nThe bits are slightly different for each timer, so consult the datasheet for details. Timer 1 is a 16-bit timer and has additional modes. Timer 2 has different prescaler values.\n\nIn the simplest PWM mode, the timer repeatedly counts from 0 to 255. The output turns on when the timer is at 0, and turns off when the timer matches the output compare register. The higher the value in the output compare register, the higher the duty cycle. This mode is known asThe following diagram shows the outputs for two particular values of OCRnA and OCRnB. Note that both outputs have the same frequency, matching the frequency of a complete timer cycle.The following code fragment sets up fast PWM on pins 3 and 11 (Timer 2). To summarize the register settings, setting the waveform generation mode bits WGM to 011 selects fast PWM. Setting the COM2A bits and COM2B bits to 10 provides non-inverted PWM for outputs A and B. Setting the CS bits to 100 sets the prescaler to divide the clock by 64. (Since the bits are different for the different timers, consult the datasheet for the right values.) The output compare registers are arbitrarily set to 180 and 50 to control the PWM duty cycle of outputs A and B. (Of course, you can modify the registers directly instead of using, but you do need to set the pins to output.)On the Arduino Duemilanove, these values yield:\n\nThe output frequency is the 16MHz system clock frequency, divided by the prescaler value (64), divided by the 256 cycles it takes for the timer to wrap around. Note that fast PWM holds the output high one cycle longer than the compare register value.\n\nThe second PWM mode is called. In this mode, the timer counts from 0 to 255 and then back down to 0. The output turns off as the timer hits the output compare register value on the way up, and turns back on as the timer hits the output compare register value on the way down. The result is a more symmetrical output. The output frequency will be approximately half of the value for fast PWM mode, because the timer runs both up and down.The following code fragment sets up phase-correct PWM on pins 3 and 11 (Timer 2). The waveform generation mode bits WGM are set to to 001 for phase-correct PWM. The other bits are the same as for fast PWM.On the Arduino Duemilanove, these values yield:\n\nPhase-correct PWM divides the frequency by two compared to fast PWM, because the timer goes both up and down. Somewhat surprisingly, the frequency is divided by 255 instead of 256, and the duty cycle calculations do not add one as for fast PWM. See the explanation below under \"Off-by-one\".\n\nBoth fast PWM and phase correct PWM have an additional mode that gives control over the output frequency. In this mode, the timer counts from 0 to OCRA (the value of output compare register A), rather than from 0 to 255. This gives much more control over the output frequency than the previous modes. (For even more frequency control, use the 16-bit Timer 1.)\n\nNote that in this mode, only output B can be used for PWM; OCRA cannot be used both as the top value and the PWM compare value. However, there is a special-case mode \"Toggle OCnA on Compare Match\" that will toggle output A at the end of each cycle, generating a fixed 50% duty cycle and half frequency in this case. The examples will use this mode.\n\nIn the following diagram, the timer resets when it matches OCRnA, yielding a faster output frequency for OCnB than in the previous diagrams. Note how OCnA toggles once for each timer reset. \n\n \n\n The following code fragment sets up fast PWM on pins 3 and 11 (Timer 2), using OCR2A as the top value for the timer. The waveform generation mode bits WGM are set to to 111 for fast PWM with OCRA controlling the top limit. The OCR2A top limit is arbitrarily set to 180, and the OCR2B compare register is arbitrarily set to 50. OCR2A's mode is set to \"Toggle on Compare Match\" by setting the COM2A bits to 01.\n\nOn the Arduino Duemilanove, these values yield:Note that in this example, the timer goes from 0 to 180, which takes 181 clock cycles, so the output frequency is divided by 181. Output A has half the frequency of Output B because the Toggle on Compare Match mode toggles Output A once each complete timer cycle.Similarly, the timer can be configured in phase-correct PWM mode to reset when it reaches OCRnA.The following code fragment sets up phase-correct PWM on pins 3 and 11 (Timer 2), using OCR2A as the top value for the timer. The waveform generation mode bits WGM are set to to 101 for phase-correct PWM with OCRA controlling the top limit. The OCR2A top limit is arbitrarily set to 180, and the OCR2B compare register is arbitrarily set to 50. OCR2A's mode is set to \"Toggle on Compare Match\" by setting the COM2A bits to 01.On the Arduino Duemilanove, these values yield:Note that in this example, the timer goes from 0 to 180 and back to 0, which takes 360 clock cycles. Thus, everything is divided by 180 or 360, unlike the fast PWM case, which divided everything by 181; see below for details.You may have noticed that fast PWM and phase-correct PWM seem to be off-by-one with respect to each other, dividing by 256 versus 255 and adding one in various places. The documentation is a bit opaque here, so I'll explain in a bit of detail.\n\nSuppose the timer is set to fast PWM mode and is set to count up to an OCRnA value of 3. The timer will take on the values 012301230123... Note that there are 4 clock cycles in each timer cycle. Thus, the frequency will be divided by 4, not 3. The duty cycle will be a multiple of 25%, since the output can be high for 0, 1, 2, 3, or 4 cycles out of the four. Likewise, if the timer counts up to 255, there will be 256 clock cycles in each timer cycle, and the duty cycle will be a multiple of 1/256. To summarize, fast PWM divides by N+1 where N is the maximum timer value (either OCRnA or 255).\n\nNow consider phase-correct PWM mode with the timer counting up to an OCRnA value of 3. The timer values will be 012321012321... There are 6 clock cycles in each timer cycle (012321). Thus the frequency will be divided by 6. The duty cycle will be a multiple of 33%, since the output can be high for 0, 2, 4, or 6 of the 6 cycles. Likewise, if the timer counts up to 255 and back down, there will be 510 clock cycles in each timer cycle, and the duty cycle will be a multiple of 1/255. To summarize, phase-correct PWM divides by 2N, where N is the maximum timer value.\n\nThe second important timing difference is that fast PWM holds the output high for one cycle longer than the output compare register value. The motivation for this is that for fast PWM counting to 255, the duty cycle can be from 0 to 256 cycles, but the output compare register can only hold a value from 0 to 255. What happens to the missing value? The fast PWM mode keeps the output high for N+1 cycles when the output compare register is set to N so an output compare register value of 255 is 100% duty cycle, but an output compare register value of 0 is not 0% duty cycle but 1/256 duty cycle. This is unlike phase-correct PWM, where a register value of 255 is 100% duty cycle and a value of 0 is a 0% duty cycle.\n\nThe Arduino supports PWM on a subset of its output pins. It may not be immediately obvious which timer controls which output, but the following table will clarify the situation. It gives for each timer output the output pin on the Arduino (i.e. the silkscreened label on the board), the pin on the ATmega chip, and the name and bit of the output port. For instance Timer 0 output OC0A is connected to the Arduino output pin 6; it uses chip pin 12 which is also known as PD6.\n\nThe Arduino performs some initialization of the timers. The Arduino initializes the prescaler on all three timers to divide the clock by 64. Timer 0 is initialized to Fast PWM, while Timer 1 and Timer 2 is initialized to Phase Correct PWM. See the Arduino source file wiring.c for details.\n\nThe Arduino uses Timer 0 internally for the and functions, so be warned that changing the frequency of this timer will cause those functions to be erroneous. Using the PWM outputs is safe if you don't change the frequency, though.\n\nThe function sets the appropriate pin to PWM and sets the appropriate output compare register to (with the special case for duty cycle of 0 on Timer 0). The function turns off PWM output if called on a timer pin. The relevant code is wiring_analog.c and wiring_digital.c.\n\nIf you use you get a duty cycle of 0%, even though pin 5's timer (Timer 0) is using fast PWM. How can this be, when a fast PWM value of 0 yields a duty cycle of 1/256 as explained above? The answer is that \"cheats\"; it has special-case code to explicitly turn off the pin when called on Timer 0 with a duty cycle of 0. As a consequency, the duty cycle of 1/256 is unavailable when you use on Timer0, and there is a jump in the actual duty cycle between values of 0 and 1.\n\nSome other Arduino models use dfferent AVR processors with similar timers. The Arduino Mega uses the ATmega1280 (datasheet), which has four 16-bit timers with 3 outputs each and two 8-bit timers with 2 outputs each. Only 14 of the PWM outputs are supported by the Arduino Wiring library, however. Some older Arduino models use the ATmega8 (datasheet), which has three timers but only 3 PWM outputs: Timer 0 has no PWM, Timer 1 is 16 bits and has two PWM outputs, and Timer 2 is 8 bits and has one PWM output.\n• You need to both enable the pin for output and enable the PWM mode on the pin in order to get any output. I.e. you need to do and set the COM bits.\n• The different timers use the control bits and prescaler differently; check the documentation for the appropriate timer.\n• Some combinations of bits that you might expect to work are reserved, which means if you try to use them, they won't work. For example, toggle mode doesn't work with fast PWM to 255, or with output B.\n• Make sure the bits are set the way you think. Bit operations can be tricky, so print out the register values and make sure they are what you expect.\n• Make sure you're using the right output pins. See the table above.\n• You'll probably want a decoupling capacitor to avoid spikes on the output.\n\nIt can be tricky to get the PWM outputs to work. Some tips:An oscilloscope is very handy for debugging PWM if you have access to one. If you don't have one, I recommend using your sound card and a program such as xoscope I hope this article helps explain the PWM modes of the Arduino. I found the documentation of the different modes somewhat opaque, and the off-by-one issues unexplained. Please let me know if you encounter any errors."
    },
    {
        "link": "https://forum.arduino.cc/t/how-can-pwm-work-with-transistors/557494",
        "document": "Hi I have been trying to understand how to use PWM with a common anode RGB led (20mA) through a transistor and it is really difficult (I'm quite a noob here, more experience in software dev). I have BJT transistors and N-Channel mosfet's to try. I would like to be able to supply current from a battery source for the LED to use with the use of a transistor. That sounds fairly simple, right? I think I am confused by Npn / Pnp, etc. Is it right to think it is possible to use PWM for like the brightness control of a Led through a transistor or is it that the transistor would only be able to turn the led on and off? If you can do PWM then how would the transistor pins be configured?\n\nWith PWM you get the brightness control by switching the LED on and off fast. You effectively see an average. Speed control of DC motors works the same way. It will work with a BJT or MOSFET although with a standard (max. 20mA) LED you don't really need one. You can just use PWM direct from an Arduino pin (through a resistor). Have a look at the Basics/Fade example in the IDE, or Analog/Fading. Both change LED brightness. For higher currents you need the transistor and the connection is always similar. See https://www.arduino.cc/en/Tutorial/TransistorMotorControl for one example.\n\nI've done this and it works, but I am not sure if it should be (Probably because I have tried to make this dozens of times now and am surprised) ... I drawn a schematic to show, could you say if it look's right to you? Like, are the resistance values working ok and isn't hurting the Tlc or Arduino? the Outx is a Tlc5940 output, the Iref is at 2k Ohm.. and i am using a pnp 2n3906 transistor. Using pnp because of the Tlc5940 and lighting of a regular 20mA common anode rgb LED.\n\nYou should use this what is on picture.\n\n Two resistors are needed to cut of to much current otherwise your transistor will burn out very fast.\n\n Using transistor is good idea.\n\n And last important thing, connect led diode to the resistor and vcc, if You connect it to the emitter, then the whole power will go thru the base and emitter, and almost moving thru collector.\n\n Transistor will start acting as normal diode. If You will use transistor pnp, then You need remember about reverse polarity. And collector with resistor and diode will be connected to the ground. And using arduino pin low, will turn on transistor. To better understand transistors use application on internet or mobile phone called everycircuit.\n\nByte3:\n\n The data sheet for the pnp for off mode says: Emitter−Base Breakdown Voltage Minimum 5.0vdc. If the Outx Is like doing up to 3.3v voltage, how can it get to 5v ? To turn the transistor off you need to get the output up to 9V. For a PNP transistor to be off its base should be connected to within 0.7V of its emitter. So you need Outx to output 9V. If it cannot then you need an NPN transistor to drive it. This is normal operation and nothing to do with the reverse emitter bias breakdown because we are talking about forward voltages here. For a PNP transistor the reverse voltage is positive not negative.\n\nI see.. much to think about here, thanks Mike. ct led diode to the resistor and vcc, if You connect it to the emitter, then the whole power will go thru the base and emitter, and almost moving thru collector.\n\n Transistor will start acting as normal diode. If You will use transistor pnp, then You need remember about reverse polarity. And collector with resistor and diode will be connected to the ground. And using arduino pin low, will turn on transistor. To better understand transistors use application on internet or mobile phone called everycircuit. That explains why the led was lighting because the transistor is acting like a diode ? I was looking at how to drive multiple led's and found the Tlc5940 but I think it is way too complicated for me now.I will try that every circuit app out some time, thanks\n\nByte3:\n\n Thanks for the Dc motor example. I had googled so much I think I've gotten lost. The dc motor Arduino example seems to be the place to start thinking about this. That page has a serious error that can damage your Arduino.\n\n The diagram/Fritzing shows a mosfet, but there is a TIP 120 in the parts list.\n\n Never connect the base of a bjt transistor directly to an Arduino pin (with the emitter connected to ground). High-side switching with a PNP transistor (post#4) won't work, because the Arduino pin can't provide the >8.5volt to turn the transistor OFF.\n\n The ~27mA flowing into the pin protection diodes when the output is set HIGH or the 80mA when the pin is set LOW will also damage your Arduino. As pointed out, you don't need transistors for a single <=20mA RGB LED.\n\n Just connect the anode to 5volt, and the three cathodes via >=220ohm resistors to three PWM pins.\n\n Leo..\n\nAh ! Okay, that is a much better idea. I will certainly look at using addressable led strips then Grumpy_Mike:\n\n These days addressable LEDs make the wiring simple and the software even simpler. You can cut up strips, get them individually mounted or in normal 5mm housings, so you can have them physically mounted in any configuration you want. Ah, excellent ! I have no idea why I was ignoring this fact."
    },
    {
        "link": "https://reddit.com/r/arduino/comments/obwyyc/offset_pwm_pulses",
        "document": "I'm using my Arduino Nano (ATmega328p) to create 3 PWM Signals from OC0A, OC0B and OC2B for a RGB LED driver. These signals seem to be synched in some way, so that their pulses all start at the exact same time. How can I space out or desynch there pulses so that their position is random or evenly distributed and they don't trigger at the exact same time?"
    },
    {
        "link": "https://docs.arduino.cc/libraries/stepper",
        "document": ""
    },
    {
        "link": "https://docs.arduino.cc/libraries/speedystepper",
        "document": ""
    },
    {
        "link": "https://docs.arduino.cc/learn/electronics/stepper-motors",
        "document": ""
    },
    {
        "link": "https://arduino.cc/en/Reference/StepperTwoPins",
        "document": ""
    },
    {
        "link": "https://forum.arduino.cc/t/basic-stepper-motor-control-using-speed-and-acceleration/1335691",
        "document": "Finding myself needing to use the AccelStepper library again, and again finding little documentation after several searches, I decided to write this manual as much for myself as for anybody else. This is not to say there is no documentation, it's..."
    },
    {
        "link": "https://reddit.com/r/arduino/comments/zad2th/help_needed_with_current_sensor_hw670",
        "document": "I recently purchased a current sensor on Amazon and can't seem to understand how to make use of it. I checked extensively online for a datasheet but couldn't find any useful info. it is marked HW-670.\n\nI hope to use them to measure the current of a 12v AC line. Please help me."
    },
    {
        "link": "https://forum.arduino.cc/t/reading-current-values-with-arduino/612862",
        "document": "I am trying to measure the output current of my sensor using arduino.\n\n Attached you can find the circuit that should work to my knowledge, however for some reason the reading values does not change at all. void setup() { // initialize serial communication at 9600 bits per second: Serial.begin(9600); } // the loop routine runs over and over again forever: void loop() { // read the input on analog pin 0: int sensorValue = analogRead(A0); // Convert the analog reading (which goes from 0 - 1023) to a voltage (0 - 5V): float voltage = sensorValue * (5 / 1023.0); // print out the value you read: Serial.println(sensorValue); }\n\nYou need to be careful here, what is the voltage supply of your sensor? please post a link to that sensor.\n\n Problem with Nano is it's AREF voltage(the voltage it compares analog voltages to) is different depending on how it is powered.\n\n If powered from USB socket, the AREF will be about 4.7V, if powered from 5V pin, AREF will be that voltage, if powered from VIN pin, AREF will be near 5V. You need to know that to get accurate readings. Also, be very careful NOT to apply more than VCC to an input pin, that's why I ask about sensor voltage.\n\nJCA34F:\n\n You need to be careful here, what is the voltage supply of your sensor? please post a link to that sensor.\n\n Problem with Nano is it's AREF voltage(the voltage it compares analog voltages to) is different depending on how it is powered.\n\n If powered from USB socket, the AREF will be about 4.7V, if powered from 5V pin, AREF will be that voltage, if powered from VIN pin, AREF will be near 5V. You need to know that to get accurate readings. Also, be very careful NOT to apply more than VCC to an input pin, that's why I ask about sensor voltage. Link to the sensor : https://cdn.sick.com/media/pdf/4/84/384/dataSheet_BCG05-K1KM01PP_6039745_en.pdf\n\n The supply voltage of the sensor is 19 -33 V. So I took 3.3V from nano and converted with a MT3608 DCDC converter to 24 V. The output of the sensor is current between 4-20mA. So I took another Nano to read it by converting it to correspond voltage value.\n\nWhy do you use a 3,3V Arduino when you want to use sensors in the 24V range. Pretty big up-convert. I see 2W for the sensor. Including DCDC losses that's almost 1A at 3,3V. And the sensor outputs current, did you put that through a shunt resistor? An Arduino can't measure current directly, you need to convert it to voltage. If you put it through a 55Ω resistor the 20mA will correspond to 1,1V (aka, internal reference voltage of a ATmega328p. If you didn't use a resistor and connected that sensor directly to the Arduino you might even have damaged the Arduino depending on the current the sensor was outputting.\n\nseptillion:\n\n Why do you use a 3,3V Arduino when you want to use sensors in the 24V range. Pretty big up-convert. I see 2W for the sensor. Including DCDC losses that's almost 1A at 3,3V. And the sensor outputs current, did you put that through a shunt resistor? An Arduino can't measure current directly, you need to convert it to voltage. If you put it through a 55Ω resistor the 20mA will correspond to 1,1V (aka, internal reference voltage of a ATmega328p. If you didn't use a resistor and connected that sensor directly to the Arduino you might even have damaged the Arduino depending on the current the sensor was outputting.\n• Yes, the sensor consumes 2W. Since the supply voltage is 24V, the corresponding supply current is about 83mA. As far as I know, the pins of Nano can provice upto 200 mA. So I thought this must be enough for the sensor, isnt it ?\n• The arduino cannot measure current directly, so that's why I used 220 Ohm resistor ( attached figure ). With this 220 Ohm, the current from the sensor in the range 4-20mA, should be converted to 0.88- 4.4V. Am I right so far?\n• You completly forget the change from 3v3 to 24V you do with the DCDC converter! Yes, 2W is 83mA on the 24V side, but 2W is 600mA on the 3.3V side with 100% efficient conversion. Think 70% efficient is still pretty good but that already makes it 866mA!\n• Ah, yeah, forgot about the image:\n\n \n\n Yes, 20mA through 220Ω gives you 4,4V. BUT, how is a 3,3V Arduino suppose to measure that? It can only go up to Vcc (and heck, above it can damage it). And this relies on the sensor and the Arduino share the ground. We know nothing about the DCDC converter / rest of the circuit so we just have to assume. And this still leaves the massive power consumption on the 3,3V side.\n• No, Arduino's are terrible at supping power. It would make much more sense to do it the other way around. Get yourself a proper 24V supply and use a DCDC converter to go to 3,3V (or 5V because a Arduino Mega isn't a 3,3V device).\n• You can only measure voltage across something. So when the Arduino needs to read a voltage on it's pin that's in reference with GND. Also, the sensor will try to let that 20mA flow to it's GND. So they must be the same. In your image, is the Nano on the left the same Nano as on the right? Also, what Arduino are you actually using? You speak about Nano, Mega and 3,3V which all suggest something else. PS WHY does this forum keep posting when I hit Preview sometimes!\n\nAnything that you could recommend? Something similar to Arudino which can be integrated into a system easily? You can only measure voltage across something. So when the Arduino needs to read a voltage on it's pin that's in reference with GND. Oh, I see. Does the circuit look better now? The arduino on the left is different than the arduino on the right. I am using two arduinos, one for the supply and one for the reading. Also, what Arduino are you actually using? Currently, I am using Nanos. I spoke of Mega because it can provide 5V which Nano cannot. Apparently, Mega still wouldnt be enough for 2W power supply.\n\nLike I said, all Arduino's are terrible at supplying current So swap one Arduino for whatever supply fits your needs and use a single Arduino (the one that suits the design) to do the task. About the supply, does the whole circuit only consists of that sensor and a single Arduino? Or is more connected? If that's all I would just get myself a decent USB charger and use that to power that MT3808 to get 24V for the sensor and to power the Nano on it's Vcc pin. But I would switch to the internal 1,1V reference (or another fixed reference) instead of using Vcc as a reference so it's more stable*. That's why I suggested a 55Ω resistor but to have some headroom and an easy to get resistor 47Ω would do. If it's a more complex system / more industrial I would get myself a nice 24V DIN-rail supply from Block or Meanwell or something. And use a DCDC converter to get 5V for the Arduino from that. Talking about DCDC converters, unless they specify it it's pretty safe to assume they have a shared GND. Aka, the GND on the input side is just the same (aka just linked) as on the output. Or in other words, it basically is just a 3-pin device, In, Out and GND. And in terms of powering I would pick the Nano. The Nano can be powered from 5V via it's Vcc pin while being connected to USB because it has a diode between USB power and Vcc. The Uno and Mega can not (although the design of some clones may differ) and can only be safely powered via Vin (or the Jack plug) while being connected to USB (which would require a volttage of >7, <12-ish).\n• Although it's more stable it might not be exact (same applies to the resistor), so you may need to do a calibration in software (or hardware)."
    },
    {
        "link": "https://instructables.com/DIY-Current-Sensor-for-Arduino",
        "document": "About: Electronic hobbyist : Love to explore the field of applied electronics and embedded systems with a motive to contribute and share creative ideas. Green Energy enthusiast Hello there, hope you are doing good and in this tutorial I will be showing you how i made a current sensor for Arduino using some very basic electronic components and a home-made shunt. This shunt can easily handle large magnitude of current, around 10-15 Amps. The accuracy is also pretty good and I was able to get very decent results while measuring low currents around 100mA.\n\nThe main parts you would need for this build is a Shunt along with the operational amplifier IC. For my application I am using the IC LM358 which is a dual OP-AMP 8 pin DIP IC of which I am using only one of the operational amplifier. You will also be needing resistors for the Non-inverting amplifier circuit. I have chosen 320K and 10K as my resistances. The choice of your resistance completely depends upon the amount of gain you want to have.Now the OP-AMP is being powered by the 5 volt of the Arduino. So we need to make sure that the output voltage from the OP-AMP when the full current is passing through the shunt should be less than 5 volts, preferably 4 volts to keep some margin of error. If we choose a gain which is very high enough then for a lower value of current, the OP-AMP will go into saturation region and only give 5 volts beyond any current value.So be sure to choose the value of amplifier gain appropriately. You would also require a prototyping PCB or breadboard to try this circuit. For the micro controller I am using the Arduino UNO to acquire the input from the amplifier output. You can choose any equivalent Arduino board you want.\n\nThe main heart of the project is the shunt resistor used to provide the small voltage drop. You can easily make this shunt without much of a hassle. If you have a thick solid steel wire then you can cut a reasonable length of that wire and can use as a shunt. Another alternative to this is to salvage shunt resistors from old or damaged multi meters just like shown over here.The current range you want to measure largely depends upon the value of the shunt resistor. Typically you can use shunts in the order of 8 to 10 milliohms.\n\nStep 4: Bringing It All Together... Now its finally time to make the current sensor module out these components. For this I cut out a small piece of veroboard and arranged my components in such a way that I could avoid the use of any jumper wires or connectors and the entire circuit could be connected using direct solder joints. For connection of the load through the shunt, I used screw terminals, which makes the connections much more neat and at the same time makes it much more easy to switch/replace different loads for which i want to measure current. Make sure you select the screw terminals of good quality which are capable of handling large currents. I've attached some pictures of the soldering process and as you can see the solder traces came out pretty well without use of any jumper or wire connector. This made my module even more durable. To give you a perspective of how small this module is I kept it along with an Indian 2 rupee coin and the size is almost comparable. This small size enables you to fit this module in your projects easily. If you can use SMD components, the size can even be reduced.\n\nAfter construction of the entire module here comes a slight tricky part, calibrating or rather coming up with the necessary code to measure the correct value of the current. Now essentially we are multiplying the voltage drop of the shunt to give us an amplified voltage, high enough for the Arduino analogRead() function to register. Now the resistance being constant, the output voltage is linear with respect to the magnitude of current passing through the shunt. The easy way to calibrate this module is to use an actual multimeter to calculate the value of current passing through a given circuit.Note this value of current, using the arduino and the serial monitor function, see what is the analog value that is coming( ranging from 0 to 1023.Use the variable as float data type to get better values ). Now we can multiply this analog value with a constant to get our desired current value and since the relation between the voltage and current is linear, this constant will be almost the same for the entire range of current, though you might have to do some minor adjustments later on. You can try with 4-5 known current values to get your constant value. I will be mentioning the code I used for this demonstration.\n\nThis current sensor works pretty well in most DC powered applications and has an error of less than 70 mA if calibrated properly. How ever there are some limitations of this design, at very low or very high currents, the deviation from the actual value becomes significant. So some modification of the code is necessary for the boundary cases. One alternative is to use an Instrumentation amplifier, which has precise circuitry to amplify very small voltages and can also be used in the high side of the circuit. Also the circuit can be improved by using a better, low noise OP-AMP. For my appliation it works well and gives repeatable output. I am planning to make a wattmeter, where I would be using this shunt current measurement system. Hope you guys enjoyed this build."
    },
    {
        "link": "https://engineersgarage.com/acs712-current-sensor-with-arduino",
        "document": "Connect the sensor in series to the system whose current you want to measure. Cut the circuit wire and connect one end of wire to IP+ and other to IP-. Recall the high school lectures, current can be measured only in series. So don’t connect the sensor in parallel You may damage it by connecting it in parallel. \n\n \n\n Viout is the voltage out pin. ACS712 outputs an analog signal in correspond to any variation across the IP+ and IP- pins or in other words it outputs analog voltage on VIOUT pin if their is any variation in the current.\n\nThe output of the device when the primary current is zero. For a uni-polar supply voltage,it nominally remains at VCC ⁄ 2. Thus, VCC = 5 V translates into VIOUT(Q) = 2.5 V Variation in VIOUT(Q) can be attributed to the resolution of the Acs712. If the Acs712 is working on 5v(Vcc=5v) and their is no current flowing from input the Viout will be 2.5v. 2.5v is the base voltage at input of 5v, now any change in the input current will bring change in the output voltage. Viout decreases when current start flowing through the acs712 pins.\n\nAcs712 is available in market in three ratings."
    },
    {
        "link": "https://forum.arduino.cc/t/yqj010504-single-phase-ac-current-sensor-module-active-output-5a-problem/384226",
        "document": "Electricity monitoring library - install in Arduino IDE's libraries folder then restart the IDE - GitHub - openenergymonitor/EmonLib: Electricity monitoring library - install in Arduino IDE'..."
    }
]