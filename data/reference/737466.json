[
    {
        "link": "https://developer.android.com/reference/android/content/ContentValues",
        "document": "This class is used to store a set of values that the can process.\n\nReturns true if this object has the named value. Describe the kinds of special objects contained in this Parcelable instance's marshaled representation. Indicates whether some other object is \"equal to\" this one. Gets a value and converts it to a Boolean. Gets a value and converts it to a Byte. Gets a value that is a byte array. Gets a value and converts it to a Double. Gets a value and converts it to a Float. Gets a value and converts it to an Integer. Gets a value and converts it to a Long. Gets a value and converts it to a Short. Gets a value and converts it to a String. Returns a hash code value for the object. Indicates whether this collection is empty. Returns a set of all of the keys Adds all values from the passed in ContentValues. Adds a null value to the set. Returns a string containing a concise, human-readable description of this object. Returns a set of all of the keys and values Flatten this object in to a Parcel.\n\nCreates and returns a copy of this object. Indicates whether some other object is \"equal to\" this one. Called by the garbage collector on an object when garbage collection determines that there are no more references to the object. Returns the runtime class of this . Returns a hash code value for the object. Wakes up a single thread that is waiting on this object's monitor. Wakes up all threads that are waiting on this object's monitor. Causes the current thread to wait until it is awakened, typically by being notified or interrupted, or until a certain amount of real time has elapsed. Causes the current thread to wait until it is awakened, typically by being notified or interrupted, or until a certain amount of real time has elapsed. Causes the current thread to wait until it is awakened, typically by being notified or interrupted. Describe the kinds of special objects contained in this Parcelable instance's marshaled representation. Flatten this object in to a Parcel.\n\nIndicates whether some other object is \"equal to\" this one. The method implements an equivalence relation on non-null object references:\n• It is reflexive: for any non-null reference value , should return .\n• It is symmetric: for any non-null reference values and , should return if and only if returns .\n• It is transitive: for any non-null reference values , , and , if returns and returns , then should return .\n• It is consistent: for any non-null reference values and , multiple invocations of consistently return or consistently return , provided no information used in comparisons on the objects is modified.\n• For any non-null reference value , should return . An equivalence relation partitions the elements it operates on into equivalence classes; all the members of an equivalence class are equal to each other. Members of an equivalence class are substitutable for each other, at least for some purposes. : This value may be . if this object is the same as the obj argument; otherwise."
    },
    {
        "link": "https://developer.android.com/reference/android/media/RingtoneManager",
        "document": "RingtoneManager provides access to ringtones, notification, and other types of sounds. It manages querying the different media providers and combines the results into a single cursor. It also provides a for each ringtone. We generically call these sounds ringtones, however the refers to the type of sounds that are suitable for the phone ringer.\n\nTo show a ringtone picker to the user, use the intent to launch the picker as a subactivity.\n\nGiven to the ringtone picker as a . Given to the ringtone picker as a . This constant was deprecated in API level 19. DRM ringtones are no longer supported Returned from the ringtone picker as a . Given to the ringtone picker as a boolean. Given to the ringtone picker as a boolean. Given to the ringtone picker as a . Given to the ringtone picker as an int. The column index (in the cursor returned by for the row ID. The column index (in the cursor returned by for the title. Type that refers to sounds that are used for the alarm. Type that refers to sounds that are used for notifications. Type that refers to sounds that are used for the phone ringer. The column index (in the cursor returned by for the media provider's URI.\n\nReturns a of all the ringtones available. Returns the for the default ringtone of a particular type. This method was deprecated in API level 19. DRM ringtones are no longer supported Gets a for the ringtone at the given position in the . Gets the position of a within this . Gets a for the ringtone at the given position in the . Returns if the at the given position in the contains haptic channels. Returns if the from a given sound URI contains haptic channels or not. Returns if the from a given sound URI contains haptics channels or not. Infers the volume stream type based on what type of ringtones this manager is returning. Returns whether the given is one of the default ringtones. Opens a raw file descriptor to read the data under the given default URI. Sets the of the default sound for a given sound type. This method was deprecated in API level 19. DRM ringtones are no longer supported Whether retrieving another will stop playing the previously retrieved . Sets which type(s) of ringtones will be listed by this. Stops playing the last retrieved from this.\n\nCreates and returns a copy of this object. Indicates whether some other object is \"equal to\" this one. Called by the garbage collector on an object when garbage collection determines that there are no more references to the object. Returns the runtime class of this . Returns a hash code value for the object. Wakes up a single thread that is waiting on this object's monitor. Wakes up all threads that are waiting on this object's monitor. Causes the current thread to wait until it is awakened, typically by being notified or interrupted, or until a certain amount of real time has elapsed. Causes the current thread to wait until it is awakened, typically by being notified or interrupted, or until a certain amount of real time has elapsed. Causes the current thread to wait until it is awakened, typically by being notified or interrupted.\n\nReturns a of all the ringtones available. The returned cursor will be the same cursor returned each time this method is called, so do not the cursor. The cursor can be safely. If was not used, the caller should manage the returned cursor through its activity's life cycle to prevent leaking the cursor. Note that the list of ringtones available will differ depending on whether the caller has the permission. A of all the ringtones available."
    },
    {
        "link": "https://stackoverflow.com/questions/76821370/how-to-set-ringtone-in-android-from-my-activity-on-upcoming-android-14-upside-d",
        "document": "I'm trying to find a way to set a new default ringtone by code from my Android activity.\n\nIt works well on Android 13 but on Android 14+ on Android Studio Emulator (for example Nexus 6P API 34) the app crashes. My code is below:\n\nThe problem is on this line here:\n\nCan someone help me to fix it, please?\n\nI tried to set the sound from the raw folder as a phone ringtone programmatically for the new Android 14+ OS which is incoming this month. I have tested on Android Studio Emulator (for example Nexus 6P API 34). The result is a crash. See the logcat."
    },
    {
        "link": "https://stackoverflow.com/questions/1271777/how-to-set-ringtone-in-android-from-my-activity",
        "document": "Finally, I managed to set the default ringtone to one that i downloaded. The download code is not included below, only what was needed to set it as default ringtone.\n\nAnyway, I do not totally understand what this code is doing.\n\nThe Ringtone manager needs a uri to the file that is to be set as new ringtone. But this uri can not be directly to the sdcard like \"/sdcard/media/ringtones/mysong.mp3\". That does not work!\n\nWhat you need is the external file uri of the file which could be something like \"/external/audio/media/46\"\n\nThe 46 is the id of the column in the MediaStore database, so thats why you need to add the sdcard file into the database first.\n\nAnyway, how does mediastore maintain its ids? This number can get really high, as you do this operation many times.\n\nDo i need to delete this row my self? Problem is that some times i dont even controll the deleting of the file since it can be deleted directly from the sdcard with a filebrowser."
    },
    {
        "link": "https://brainly.com/question/43508497",
        "document": ""
    },
    {
        "link": "https://developer.android.com/training/permissions/requesting",
        "document": "Stay organized with collections Save and categorize content based on your preferences.\n\nEvery Android app runs in a limited-access sandbox. If your app needs to use resources or information outside of its own sandbox, you can declare a runtime permission and set up a permission request that provides this access. These steps are part of the workflow for using permissions.\n\nIf you declare any dangerous permissions, and if your app is installed on a device that runs Android 6.0 (API level 23) or higher, you must request the dangerous permissions at runtime by following the steps in this guide.\n\nIf you don't declare any dangerous permissions, or if your app is installed on a device that runs Android 5.1 (API level 22) or lower, the permissions are automatically granted, and you don't need to complete any of the remaining steps on this page.\n\nThe basic principles for requesting permissions at runtime are as follows:\n• Ask for a permission in context, when the user starts to interact with the feature that requires it.\n• Don't block the user. Always provide the option to cancel an educational UI flow, such as a flow that explains the rationale for requesting permissions.\n• If the user denies or revokes a permission that a feature needs, gracefully degrade your app so that the user can continue using your app, possibly by disabling the feature that requires the permission.\n• Don't assume any system behavior. For example, don't assume that permissions appear in the same permission group. A permission group merely helps the system minimize the number of system dialogs that are presented to the user when an app requests closely related permissions.\n\nBefore you declare and request runtime permissions in your app, evaluate whether your app needs to do so. You can fulfill many use cases in your app, such as taking photos, pausing media playback, and displaying relevant ads, without needing to declare any permissions.\n\nIf you conclude that your app needs to declare and request runtime permissions, complete these steps:\n• In your app's manifest file, declare the permissions that your app might need to request.\n• Design your app's UX so that specific actions in your app are associated with specific runtime permissions. Let users know which actions might require them to grant permission for your app to access private user data.\n• Wait for the user to invoke the task or action in your app that requires access to specific private user data. At that time, your app can request the runtime permission that's required for accessing that data.\n• None Check whether the user has already granted the runtime permission that your app requires. If so, your app can access the private user data. If not, continue to the next step. You must check whether you have a permission every time you perform an operation that requires that permission.\n• None Check whether your app should show a rationale to the user, explaining why your app needs the user to grant a particular runtime permission. If the system determines that your app shouldn't show a rationale, continue to the next step directly, without showing a UI element. If the system determines that your app should show a rationale, however, present the rationale to the user in a UI element. In this rationale, clearly explain what data your app is trying to access and what benefits the app can provide to the user if they grant the runtime permission. After the user acknowledges the rationale, continue to the next step.\n• None Request the runtime permission that your app requires to access the private user data. The system displays a runtime permission prompt, such as the one shown on the permissions overview page.\n• None Check the user's response—whether they chose to grant or deny the runtime permission.\n• None If the user granted the permission to your app, you can access the private user data. If the user denied the permission instead, gracefully degrade your app experience so that it provides functionality to the user without the information that's protected by that permission.\n\nFigure 1 illustrates the workflow and set of decisions associated with this process:\n\nDetermine whether your app was already granted the permission\n\nTo check whether the user already granted your app a particular permission, pass that permission into the method. This method returns either or , depending on whether your app has the permission.\n\nExplain why your app needs the permission\n\nThe permissions dialog shown by the system when you call says what permission your app wants, but doesn't say why. In some cases, the user might find that puzzling. It's a good idea to explain to the user why your app wants the permissions before you call .\n\nResearch shows that users are much more comfortable with permissions requests if they know why the app needs them, such as whether the permission is needed to support a core feature of the app or for advertising. As a result, if you're only using a fraction of the API calls that fall under a permission group, it helps to explicitly list which of those permissions you're using and why. For example, if you're only using coarse location, let the user know this in your app description or in help articles about your app.\n\nUnder certain conditions, it's also helpful to let users know about sensitive data access in real time. For example, if you’re accessing the camera or microphone, it’s a good idea to let the user know by using a notification icon somewhere in your app, or in the notification tray (if the application is running in the background), so it doesn't seem like you're collecting data surreptitiously.\n\nUltimately, if you need to request a permission to make something in your app work, but the reason isn't clear to the user, find a way to let the user know why you need the most sensitive permissions.\n\nIf the method returns , call . If this method returns , show an educational UI to the user. In this UI, describe why the feature that the user wants to enable needs a particular permission.\n\nAdditionally, if your app requests a permission related to location, microphone, or camera, consider explaining why your app needs access to this information.\n\nAfter the user views an educational UI, or the return value of indicates that you don't need to show an educational UI, request the permission. Users see a system permission dialog, where they can choose whether to grant a particular permission to your app.\n\nTo do this, use the contract, included in an AndroidX library, where you allow the system to manage the permission request code for you. Because using the contract simplifies your logic, it is the recommended solution when possible. However, if needed you can also manage a request code yourself as part of the permission request and include this request code in your permission callback logic.\n\nAllow the system to manage the permission request code\n\nTo allow the system to manage the request code that's associated with a permissions request, add dependencies on the following libraries in your module's file:\n\nYou can then use one of the following classes:\n• To request multiple permissions at the same time, use .\n\nThe following steps show how to use the contract. The process is nearly the same for the contract.\n• None In your activity or fragment's initialization logic, pass in an implementation of into a call to . The defines how your app handles the user's response to the permission request. Keep a reference to the return value of , which is of type .\n• None To display the system permissions dialog when necessary, call the method on the instance of that you saved in the previous step. After is called, the system permissions dialog appears. When the user makes a choice, the system asynchronously invokes your implementation of , which you defined in the previous step. Note: Your app cannot customize the dialog that appears when you call . To provide more information or context to the user, change your app's UI so that it's easier for users to understand why a feature in your app needs a particular permission. For example, you might change the text in the button that enables the feature. Also, the text in the system permission dialog references the permission group associated with the permission that you requested. This permission grouping is designed for system ease-of-use, and your app shouldn't rely on permissions being within or outside of a specific permission group.\n\nThe following code snippet shows how to handle the permissions response:\n\nAnd this code snippet demonstrates the recommended process to check for a permission and to request a permission from the user when necessary:\n\nAs an alternative to allowing the system to manage the permission request code, you can manage the permission request code yourself. To do so, include the request code in a call to .\n\nThe following code snippet demonstrates how to request a permission using a request code:\n\nAfter the user responds to the system permissions dialog, the system then invokes your app's implementation of . The system passes in the user response to the permission dialog, as well as the request code that you defined, as shown in the following code snippet:\n\nWhen you request location permissions, follow the same best practices as for any other runtime permission. One important difference when it comes to location permissions is that the system includes multiple permissions related to location. Which permissions you request, and how you request them, depend on the location requirements for your app's use case.\n\nIf your app contains a feature that shares or receives location information only once, or for a defined amount of time, then that feature requires foreground location access. Some examples include the following:\n• Within a messaging app, a feature lets users share their current location with another user.\n\nThe system considers your app to be using foreground location if a feature of your app accesses the device's current location in one of the following situations:\n• An activity that belongs to your app is visible.\n• None Your app is running a foreground service. When a foreground service is running, the system raises user awareness by showing a persistent notification. Your app retains access when it's placed in the background, such as when the user presses the Home button on their device or turns their device's display off. On Android 10 (API level 29) and higher, you must declare a foreground service type of , as shown in the following code snippet. On earlier versions of Android, it's recommended that you declare this foreground service type. <!-- Recommended for Android 9 (API level 28) and lower. --> <!-- Required for Android 10 (API level 29) and higher. --> <service android:name=\"MyNavigationService\" android:foregroundServiceType=\"location\" ... > <!-- Any inner elements go here. --> </service>\n\nYou declare a need for foreground location when your app requests either the permission or the permission, as shown in the following snippet:\n\nAn app requires background location access if a feature within the app constantly shares location with other users or uses the Geofencing API. Several examples include the following:\n• Within an IoT app, a feature lets users configure their home devices such that they turn off when the user leaves their home and turn back on when the user returns home.\n\nThe system considers your app to be using background location if it accesses the device's current location in any situation other than the ones described in the foreground location section. The background location accuracy is the same as the foreground location accuracy, which depends on the location permissions that your app declares.\n\nOn Android 10 (API level 29) and higher, you must declare the permission in your app's manifest to request background location access at runtime. On earlier versions of Android, when your app receives foreground location access, it automatically receives background location access as well.\n\nIf the user denies a permission request, your app should help users understand the implications of denying the permission. In particular, your app should make users aware of the features that don't work because of the missing permission. When you do so, keep the following best practices in mind:\n• None Guide the user's attention. Highlight a specific part of your app's UI where there's limited functionality because your app doesn't have the necessary permission. Examples of what you could do include the following:\n• Show a message where the feature's results or data would have appeared.\n• Display a different button that contains an error icon and color.\n• None Be specific. Don't display a generic message. Instead, make clear which features are unavailable because your app doesn't have the necessary permission.\n• None Don't block the user interface. In other words, don't display a full-screen warning message that prevents users from continuing to use your app at all.\n\nAt the same time, your app should respect the user's decision to deny a permission. Starting in Android 11 (API level 30), if the user taps Deny for a specific permission more than once during your app's lifetime of installation on a device, the user doesn't see the system permissions dialog if your app requests that permission again. The user's action implies \"don't ask again.\" On previous versions, users saw the system permissions dialog each time your app requested a permission, unless they had previously selected a \"don't ask again\" checkbox or option.\n\nIf a user denies a permission request more than once, this is considered a permanant denial. It's very important to only prompt users for permissions when they need access to a specific feature, otherwise you might inadvertently lose the ability to re-request permissions.\n\nIn certain situations, the permission might be denied automatically, without the user taking any action. (A permission might be granted automatically as well.) It's important to not assume anything about automatic behavior. Each time your app needs to access functionality that requires a permission, check that your app is still granted that permission.\n\nTo provide the best user experience when asking for app permissions, also see App permissions best practices.\n\nTo identify whether an app has been permanently denied permissions (for debugging and testing purposes), use the following command:\n\nWhere is the name of the package to inspect.\n\nThe output of the command contains sections that look like this:\n\nPermissions that have been denied once by the user are flagged by . Permissions that have been denied permanently by selecting Deny twice are flagged by .\n\nTo ensure that testers see the request dialog during testing, reset these flags when you're done debugging your app. To do this, use the command:\n\nis the name of the permission you want to reset.\n\nTo view a complete list of Android app permissions, visit the permissions API reference page.\n\nStarting in Android 11 (API level 30), whenever your app requests a permission related to location, microphone, or camera, the user-facing permissions dialog contains an option called Only this time, as shown in figure 2. If the user selects this option in the dialog, your app is granted a temporary one-time permission.\n\nYour app can then access the related data for a period of time that depends on your app's behavior and the user's actions:\n• While your app's activity is visible, your app can access the data.\n• If the user sends your app to the background, your app can continue to access the data for a short period of time.\n• If you launch a foreground service while the activity is visible, and the user then moves your app to the background, your app can continue to access the data until the foreground service stops.\n\nIf the user revokes the one-time permission, such as in system settings, your app can't access the data, regardless of whether you launched a foreground service. As with any permission, if the user revokes your app's one-time permission, your app's process terminates.\n\nWhen the user next opens your app and a feature in your app requests access to location, microphone, or camera, the user is prompted for the permission again.\n\nAndroid provides several ways to reset unused runtime permissions to their default, denied state:\n• An API where you can proactively remove your app's access to an unused runtime permission.\n• A system mechanism that automatically resets the permissions of unused apps.\n\nOn Android 13 (API level 33) and higher, you can remove your app's access to runtime permissions that your app no longer requires. When you update your app, perform this step so that users are more likely to understand why your app continues to request specific permissions. This knowledge helps build user trust in your app.\n\nTo remove access to a runtime permission, pass the name of that permission into . To remove access to a group of runtime permissions at the same time, pass a collection of permission names into . The permission removal process happens asynchronously and kills all processes associated with your app's UID.\n\nFor the system to remove your app's access to the permissions, all processes tied to your app must be killed. When you call the API, the system determines when it's safe to kill these processes. Usually, the system waits until your app spends an extended period of time running in the background instead of the foreground.\n\nTo inform the user that your app no longer requires access to specific runtime permissions, show a dialog the next time the user launches your app. This dialog can include the list of permissions.\n\nIf your app targets Android 11 (API level 30) or higher and isn't used for a few months, the system protects user data by automatically resetting the sensitive runtime permissions that the user had granted your app. Learn more in the guide about app hibernation.\n\nRequest to become the default handler if necessary\n\nSome apps depend on access to sensitive user information related to call logs and SMS messages. If you want to request the permissions specific to call logs and SMS messages and publish your app to the Play Store, you must prompt the user to set your app as the default handler for a core system function before requesting these runtime permissions.\n\nFor more information on default handlers, including guidance on showing a default handler prompt to users, see the guide about permissions used only in default handlers.\n\nTo grant all runtime permissions automatically when you install an app on an emulator or test device, use the option for the command, as demonstrated in the following code snippet:\n\nFor additional information about permissions, read these articles:\n\nTo learn more about requesting permissions, review the permissions samples\n\nYou can also complete this codelab that demonstrates privacy best practices."
    },
    {
        "link": "https://source.android.com/docs/core/permissions/runtime_perms",
        "document": "In Android 6.0 and higher, the Android app permissions model is designed to make permissions more understandable, useful, and secure for users. The model moved Android apps that require dangerous permissions (see Affected permissions) from an install-time permission model to a runtime permission model:\n• Install-time permissions (Android 5.1 and lower) Users grant dangerous permissions to an app when they install or update the app. Device manufacturers and carriers can preinstall apps with pregranted permissions without notifying the user.\n• Runtime permissions (Android 10) Users see increased transparency and have control over which apps have activity recognition (AR) runtime permissions. Users are prompted by the runtime permissions dialog to either always allow, allow while in use, or deny permissions. On an OS upgrade to Android 10, permissions given to apps are retained, but users can go into Settings and change them.\n\nRuntime permissions prevent apps from gaining access to private data without a user's consent, and provide them with additional context and visibility into the types of permissions that apps are either seeking, or have been granted. The runtime model encourages developers to help users understand why apps require the requested permissions, and provides greater transparency so users can make better decisions about granting or denying them.\n\nAndroid 6.0 and higher requires dangerous permissions to use a runtime permissions model. Dangerous permissions are higher-risk permissions (such as ) that grant requesting apps access to private user data, or control over a device, which can negatively impact the user. To view a list of dangerous permissions, run the command:\n\nAndroid 6.0 and higher doesn't change the behavior of normal permissions. These are all non-dangerous permissions including normal, system, and signature permissions. Normal permissions are lower-risk permissions (such as ) that grant requesting apps access to isolated app-level features with minimal risk to other apps, the system, or the user. As in Android 5.1 and lower releases, the system automatically grants normal permissions to a requesting app at installation and doesn't prompt the user for approval. For details on permissions, see the <permission> element documentation.\n\nIn addition to being dangerous, a permission can be either hard-restricted or soft-restricted. In either case, the restricted permission must also be allowlisted. Non-allowlisted hard restrictions behave differently than non-allowlisted soft restrictions:\n• (Hard restrictions) Apps can't be granted permissions that aren't allowlisted.\n• (Soft restrictions) Apps without allowlisting behave according to the specific permission they request. The behavior is described in the public documentation for the requested permission.\n\nWhen installing an app, the installer (such as Google Play Store) may select to not allowlist the restricted permissions for the app. Permissions are restricted by the platform and are grantable only if an app meets special criteria per platform policy. Examples of hard-restricted permission types include SMS and Call Log permissions.\n\nAllowlisting happens during installation, and when\n• an app is already installed during an Android 9-to-10 upgrade.\n• a permission is pregranted or an app is preinstalled.\n• a permission is required for a role that's already defined to allowlist the permission.\n• the installer (such as Google Play Store) marks the permission as allowlisted.\n\nThe runtime permission model applies to all apps, including pre-installed apps and apps delivered to the device as part of the setup process. App software requirements include:\n• The runtime permission model must be consistent across all devices running Android 6.0 and higher. This is enforced by Android Compatibility Test Suite (CTS) tests.\n• Apps must prompt users to grant app permissions at runtime. For details, see Update apps. Limited exceptions may be granted to default apps and handlers that provide basic device functionality fundamental to the expected operation of the device. (For example, the device's default Dialer app for handling may have Phone permission access.) For details, see Creating exceptions.\n• Preloaded apps that have dangerous permissions must target API level 23 and maintain the runtime permission model. That is, the UI flow during app installation mustn't deviate from the AOSP implementation of PermissionController, users can revoke dangerous permissions of preinstalled apps, and so on.\n• Headless apps must use an activity to request permissions or to share a UID with another app that has the necessary permissions. For details, see Headless apps.\n\nPermissions granted to apps on Android 5.x remain granted after updating to Android 6.0 or higher, but users can revoke those permissions at any time.\n\nIn an Android 9-to-10 update, all hard-restricted permissions get allowlisted. For details on implementing the foreground/background split permissions, see Android 10 privacy change, beginning with Request background location.\n\nWhen integrating the app runtime permissions model for Android 6.0 and higher, you must update preinstalled apps to work with the new model. You can also define exceptions for apps that are the default handlers/providers for core functionality, define custom permissions, and customize the theme used in the app.\n\nApps on the system image and preinstalled apps aren't automatically pregranted permissions. We encourage you to work with preinstalled app developers (OEM, carrier, and third party) to make the required app modifications using developer guidelines. Specifically, you must ensure that preinstalled apps are modified to avoid crashes and other issues when users revoke permissions.\n\nIn Android 9 and lower, preloaded apps that use dangerous permissions must target API level 23 or higher, and maintain the Android 6.0 and higher AOSP permission model. For example, the UI flow during an app installation mustn't deviate from the AOSP implementation of . Users can even revoke the dangerous permissions of preinstalled apps.\n\nIn Android 6.0 through 9, some permissions are granted during the install flow. However, starting in 10, the install flow (performed by the app) is a separate function from permissions granting (in the app).\n\nOnly activities can request permissions. Services can't request permissions directly.\n• In Android 5.1 and earlier, headless apps can request permissions when installed, or if they were pre-installed without the use of an activity.\n• In Android 6.0 and higher, headless apps must use one of the following methods to request permissions:\n• Add an activity to request permissions. (This is the preferred method.)\n• Share a UID with another app that has the necessary permissions. Use this method only when you need the platform to handle multiple APKs as a single app.\n\nThe goal is to avoid confusing users with permission requests that appear out of context.\n\nIf desired, you can customize the Permissions UI theme by updating the default device themes ( and ) used by PackageInstaller. However, because consistency is critical for app developers, you can't customize the placement, position, and rules of when the Permissions UI appears.\n\nTo include strings for additional languages, contribute the strings to AOSP.\n\nYou can pre-grant permissions to apps that are default handlers or providers for core OS functionality using the class in PackageManager. Examples:\n\nYou can define custom permissions and groups as normal or dangerous and add OEM/Carrier-specific permissions to existing permissions groups, just as you could in Android 5.x and earlier releases.\n\nIn Android 6.0 and later, if you add a new dangerous permission, it must be handled in the same way as other dangerous permissions (requested during app runtime and revocable by users). Specifically:\n• You can add new permissions to a current group, but you can't modify the AOSP mapping of dangerous permissions and dangerous permissions groups. (In other words, you can't remove a permission from a group and assign to another group).\n• You can add new permission groups in apps installed on the device, but you can't add new permissions groups in the platform manifest.\n\nAndroid includes Compatibility Test Suite (CTS) tests that verify individual permissions are mapped to the correct groups. Passing these tests is a requirement for Android 6.0 and later CTS compatibility.\n\nIn Android 13 and later, you are able to revoke your own granted runtime permissions using . The revocation happens asynchronously and is triggered when it is safe to do so without disrupting the user. When the revocation is triggered, all processes running in the calling UID is killed.\n\nIt's important to understand that revoking a single permission may not be reflected in the settings UI, which treats permissions by group. Typically, a permission group is displayed as granted as long as at least one of the permissions in that group is granted. If ensuring that users are able to confirm the revocation in the settings is important to you, make sure to revoke every permission in the permission group. To learn which permissions belong to a certain group, you may use and .\n\nWhen the system revokes the permissions requested, it also revokes corresponding background permissions if none of their corresponding foreground permissions are still granted.\n\nThe revocation isn't triggered as long as the process remains in the foreground but can also be triggered right away by manually killing all processes running in the current uid, for instance using . However it is recommended to let the system decide when to trigger it.\n\nAfter a permission revocation is effective, you are able to request it again, and the user is prompted to grant or deny the request. It isn't possible to request a permission that had previously been denied by the user. While you are encouraged to revoke permissions that you currently hold but are no longer needed, you should be careful not to inform the user about the revocation until after it's in effect."
    },
    {
        "link": "https://stackoverflow.com/questions/32083410/cant-get-write-settings-permission",
        "document": "When I have a target API of 23 on Android M Preview 3, I cannot seem to acquire the Manifest.permission.WRITE_SETTTINGS permission.\n\nRequest permission doesn't bring up the dialog I would expect, but if I make the following call without this permission,\n\nThe call will except because I don't have the permission.\n\nI'm not sure where to go from here. Is there a new ringtone API for 23? Or did this permission change just make it impossible for any non-system apps to change the ringtone?"
    },
    {
        "link": "https://stackoverflow.com/questions/38973118/which-permission-do-we-need-at-runtime-in-android-6-0",
        "document": "I have an android code which can work well on Android 5.0 version. My is\n\nHowever, my customer who uses Android 6.0 (LG G5) reported the application does not work well. I do not have LG G5 to check what is the issue. In my opinion, I think the reason is that the permission changed from 5.0 to 6.0. Could you look at my permission and give me some improve/correct it for Android 6.0? Or do we have any way to automatically add permission for Android 6.0. Thank all"
    },
    {
        "link": "https://developer.android.com/training/permissions/usage-notes",
        "document": "Permission requests protect sensitive information available from a device and should only be used when access to information is necessary for the functioning of your app. This document provides tips on ways you might be able to achieve the same (or better) functionality without requiring access to such information; it is not an exhaustive discussion of how permissions work in the Android operating system.\n\nFor a more general look at Android permissions, please see Permissions overview. For details on how to work with permissions in your code, see Requesting app permissions.\n\nIn Android 6.0 (API level 23) and higher, apps can request permissions from the user at runtime, rather than prior to installation. This allows apps to request permissions when the app actually requires the services or data protected by the services. While this doesn't (necessarily) change overall app behavior, it does create a few changes relevant to the way sensitive user data is handled:\n\nUsers are prompted at runtime, in the context of your app, for permission to access the functionality covered by those permission groups. Users are more sensitive to the context in which the permission is requested, and if there’s a mismatch between what you are requesting and the purpose of your app, it's even more important to provide detailed explanation to the user as to why you’re requesting the permission. Whenever possible, you should provide an explanation of your request both at the time of the request and in a follow-up dialog if the user denies the request.\n\nTo increase the likelihood of a permission request being accepted, only prompt when a specific feature is required. For instance, only prompt for microphone access when a user clicks on the microphone button. Users are more likely to allow a permission that they are expecting.\n\nUsers can deny access to individual permissions at the time they’re requested and in settings, but they may still be surprised when functionality is broken as a result. It’s a good idea to monitor how many users are denying permissions (e.g. using Google Analytics) so that you can either refactor your app to avoid depending on that permission or provide a better explanation of why you need the permission for your app to work properly. You should also make sure that your app handles exceptions when users deny permission requests or toggle off permissions in settings.\n\nUsers are asked to grant access for permission groups individually and not as a set. This makes it extremely important to minimize the number of permissions you’re requesting. This increases the user-burden for granting permissions and therefore increases the probability that at least one of the requests will be denied.\n\nSome apps depend on access to sensitive user information related to call logs and SMS messages. If you want to request the permissions specific to call logs and SMS messages and publish your app to the Play Store, you must prompt the user to set your app as the default handler for a core system function before requesting these runtime permissions.\n\nFor more information on default handlers, including guidance on showing a default handler prompt to users, see the guide on permissions used only in default handlers.\n\nKnow the libraries you're working with\n\nSometimes permissions are required by the libraries you use in your app. For example, ads and analytics libraries may require access to the permissions group to implement the required functionality. But from the user's point of view, the permission request comes from your app, not the library.\n\nJust as users select apps that use fewer permissions for the same functionality, developers should review their libraries and select third-party SDKs that aren't using unnecessary permissions. For example, if you're using a library that provides location functionality, make sure you aren't requesting the permission unless you're using location-based targeting functionality.\n\nWhen your app is running in the background, access to location should be critical to the app's core functionality and show a clear benefit to users.\n\nIn Android 6.0 (API level 23) and higher, users grant and revoke app permissions at run time, instead of doing so when they install the app. As a result, you'll have to test your app under a wider range of conditions. Prior to Android 6.0, you could reasonably assume that if your app is running at all, it has all the permissions it declares in the app manifest. Now, the user can turn permissions on or off for any app, regardless of API level. You should test to ensure your app functions correctly across various permission scenarios.\n\nThe following tips will help you find permissions-related code problems on devices running API level 23 or higher:\n• Identify your app’s current permissions and the related code paths.\n• Test with various combinations of granted or revoked permissions. For example, a camera app might list , , and in its manifest. You should test the app with each of these permissions turned on and off, to make sure the app can handle all permission configurations gracefully.\n• Use the adb tool to manage permissions from the command line:\n• Grant or revoke one or more permissions:\n• Analyze your app for services that use permissions.\n• Android Marshmallow 6.0: Asking For Permission: This video explains the Android runtime permission model and the right way to ask users for permissions.\n• Explain why the app needs permissions"
    }
]