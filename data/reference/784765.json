[
    {
        "link": "https://docs.unity3d.com/6000.0/Documentation/ScriptReference/MonoBehaviour.html",
        "document": "MonoBehaviour offers life cycle functions that make it easier to develop with Unity.\n\n\n\nMonoBehaviours always exist as a Component of a GameObject, and can be instantiated with GameObject.AddComponent. Objects that need to exist independently of a GameObject should derive from ScriptableObject instead.\n\n\n\nA MonoBehaviour can be deleted with Object.Destroy or Object.DestroyImmediate. When the parent GameObject is destroyed all components are automatically deleted, including MonoBehaviours.\n\n\n\nAfter the underlying component is destroyed, the C# object for the MonoBehaviour remains in memory until garbage is collected. A MonoBehaviour in this state acts as if it is null. For example, it returns true for a \"obj == null\" check. However, this class doesn't support the null-conditional operator (?.) and the null-coalescing operator (??).\n\n\n\nWhen a MonoBehaviour is serialized, the value of C# fields are included according to Unity's Serialization rules. See Script Serialization for details. The serialized data also includes internal properties, such as the reference to the MonoScript that tracks the implementation class for the object.\n\n\n\nFor code samples, see the individual MonoBehaviour methods.\n\n\n\nNote: There is a checkbox for enabling or disabling MonoBehaviour in the Unity Editor. It disables functions when unticked. If none of these functions are present in the script, the Unity Editor does not display the checkbox. The functions are:\n\n\n\nStart()\n\n Update()\n\n FixedUpdate()\n\n LateUpdate()\n\n OnGUI()\n\n OnDisable()\n\n OnEnable()\n\n\n\nAdditional resources: The Deactivating GameObjects page in the manual."
    },
    {
        "link": "https://docs.unity3d.com/2023.1/Documentation/ScriptReference/MonoBehaviour.html?_ga=2.39093731.1320913147.1615166875-410775879.1593420064",
        "document": "MonoBehaviour offers life cycle functions that make it easier to develop with Unity.\n\n\n\nMonoBehaviours always exist as a Component of a GameObject, and can be instantiated with GameObject.AddComponent. Objects that need to exist independently of a GameObject should derive from ScriptableObject instead.\n\n\n\nA MonoBehaviour can be deleted with Object.Destroy or Object.DestroyImmediate. When the parent GameObject is destroyed all components are automatically deleted, including MonoBehaviours.\n\n\n\nAfter the underlying component is destroyed, the C# object for the MonoBehaviour remains in memory until garbage is collected. A MonoBehaviour in this state acts as if it is null. For example, it returns true for a \"obj == null\" check. However, this class doesn't support the null-conditional operator (?.) and the null-coalescing operator (??).\n\n\n\nWhen a MonoBehaviour is serialized, the value of C# fields are included according to Unity's Serialization rules. See Script Serialization for details. The serialized data also includes internal properties, such as the reference to the MonoScript that tracks the implementation class for the object.\n\n\n\nFor code samples, see the individual MonoBehaviour methods.\n\n\n\nNote: There is a checkbox for enabling or disabling MonoBehaviour in the Unity Editor. It disables functions when unticked. If none of these functions are present in the script, the Unity Editor does not display the checkbox. The functions are:\n\n\n\nStart()\n\n Update()\n\n FixedUpdate()\n\n LateUpdate()\n\n OnGUI()\n\n OnDisable()\n\n OnEnable()\n\n\n\nSee Also: The Deactivating GameObjects page in the manual."
    },
    {
        "link": "https://docs.unity.cn/Manual/class-MonoBehaviour.html",
        "document": "The MonoBehaviour class is the base class from which every Unity script derives, by default. When you create a C# script from Unity’s project windowA window that shows the contents of your folder (Project tab) More info\n\nSee in Glossary, it automatically inherits from MonoBehaviour, and provides you with a template script. See Creating and Using scripts for more information on this.\n\nThe MonoBehaviour class provides the framework which allows you to attach your script to a GameObject in the editor, as well as providing hooks into useful Events such as Start and Update.\n\nFor a complete reference of every member of the MonoBehaviour class, and its technical details, see the MonoBehaviour script reference.\n\nWhen you select a script in the Project window, the InspectorA Unity window that displays information about the currently selected GameObject, asset or project settings, allowing you to inspect and edit the values. More info\n\nSee in Glossary displays some basic information about that script asset, including the name of the assembly it belongs to, and a preview of the contents of the script.\n\nNote: Although the Inspector displays the contents of the script, you can’t edit the script in the Inspector window.\n\nThe script inspector also displays two buttons, Open and Execution Order.\n\nThe Open button opens the script in the currently configured External Script Editor (also known as an Integrated Development Environment, or IDE). The Open button performs the same function as double-clicking the script in the Project window. You can configure which external editor Unity uses to open your scriptsA piece of code that allows you to create your own Components, trigger game events, modify Component properties over time and respond to user input in any way you like. More info\n\nSee in Glossary in the External Tools section of the Preferences window.\n\nThe Execution Order button opens the Script Execution Order section of the Project Settings window, which allows you to alter the the order in which Unity executes your scripts.\n\nIf you define public ObjectThe fundamental object in Unity scenes, which can represent characters, props, scenery, cameras, waypoints, and more. A GameObject’s functionality is defined by the Components attached to it. More info\n\nSee in Glossary fields that can be assigned in the Editor in your MonoBehaviour script, you can set up default references for these fields. The default reference fields are visible in the inspector when you select the script asset in the Project window.\n\nIn the example above, there are three public Audio ClipA container for audio data in Unity. Unity supports mono, stereo and multichannel audio assets (up to eight channels). Unity can import .aif, .wav, .mp3, and .ogg audio file format, and .xm, .mod, .it, and .s3m tracker module formats. More info\n\nSee in Glossary fields, without default references assigned. You could assign audio clips to each of the AudioClip default reference fields.\n\nIf you assign default references, they are applied when you add your MonoBehaviour as a component to a GameObject, or when you reset an existing instance of your MonoBehaviour on a GameObject to its default values.\n\nNote: There is no ongoing link between the references on MonoBehaviour instances on GameObjects and the default references. This means if you change the default references, they are not automatically updated on existing GameObjects.\n\nOther types of inspector-editable fields that do not inherit from (for example, public string or int fields) do not have default fields in the inspector. Instead, they take their default values from the script itself.\n\nThe MonoBehaviour class allows you to start, stop, and manage Coroutines, which are a way to write asynchronous code which can include waiting for a certain amount of time, or for certain actions to complete, while allowing other code to continue executing.\n\nFor more information about coroutines, see the Coroutines manual page and the StartCoroutine method script reference.\n\nThe MonoBehaviour class provides access to a large collection of event messages, which allows you to execute your code based on what is currently happening in your project. Here are a few of the more common examples. For a list of them all, see the Messages section on the MonoBehaviour script reference page\n\n- called when the GameObject begins to exist (either when the Scene is loaded, or the GameObject is instantiated).\n\nand - called when a GameObject’s renderer enters or leaves a cameraA component which creates an image of a particular viewpoint in your scene. The output is either drawn to the screen or captured as a texture. More info\n\nSee in Glossary’s view.\n\nand - called when physics collisionsA collision occurs when the physics engine detects that the colliders of two GameObjects make contact or overlap, when at least one has a Rigidbody component and is in motion. More info\n\nSee in Glossary or triggers occur.\n\n- called when the GameObject is destroyed."
    },
    {
        "link": "https://discussions.unity.com/t/built-in-way-to-check-if-start-has-been-called-on-a-monobehaviour/652804",
        "document": ""
    },
    {
        "link": "https://discussions.unity.com/t/cancel-async-task-best-practice/771710",
        "document": ""
    },
    {
        "link": "https://docs.unity3d.com/6000.0/Documentation/ScriptReference/SpriteRenderer-sprite.html",
        "document": "Suggest a change Thank you for helping us improve the quality of Unity Documentation. Although we cannot accept all submissions, we do read each suggested change from our users and will make updates where applicable. Close For some reason your suggested change could not be submitted. Please <a>try again</a> in a few minutes. And thank you for taking the time to help us improve the quality of Unity Documentation. Close\n\nThe SpriteRenderer component will render the assigned Sprite.sprite sprite. The rendered sprite can be changed by specifying a different sprite in the sprite variable."
    },
    {
        "link": "https://docs.unity3d.com/2023.2/Documentation/Manual/class-SpriteRenderer.html",
        "document": "The SpriteA 2D graphic objects. If you are used to working in 3D, Sprites are essentially just standard textures but there are special techniques for combining and managing sprite textures for efficiency and convenience during development. More info\n\nSee in Glossary Renderer component renders the Sprite and controls how it visually appears in a SceneA Scene contains the environments and menus of your game. Think of each unique Scene file as a unique level. In each Scene, you place your environments, obstacles, and decorations, essentially designing and building your game in pieces. More info\n\nSee in Glossary for both 2D and 3D projects.\n\nWhen you create a sprite (GameObject > 2D Object > Sprite), Unity automatically creates a GameObject with the Sprite Renderer component attached. You can also add the component to an existing GameObject via the Components menu (Component > Rendering > Sprite Renderer).\n\nDefine which sprite texture the component should render. Click the circle icon to the right to open the object picker window, and select from the list of available sprite assets. Click this button to open the Sprite Editor window to edit the currently selected sprite. Note: If the 2D Sprite package isn’t installed, a button to install the 2D Sprite package will be available instead. Define the vertex color of the sprite, which tints or recolors the Sprite’s image. Use the color picker to set the vertex color of the rendered sprite texture. See the Color section below this table for examples. Flips the sprite texture along the checked axis. This doesn’t flip the Transform position of the GameObject \n\n The fundamental object in Unity scenes, which can represent characters, props, scenery, cameras, waypoints, and more. A GameObject’s functionality is defined by the Components attached to it. More info . Define the Material used to render the sprite texture. Define how the sprite scales when its dimensions change. Select one of the following options from the drop-down box. The entire image scales when its dimensions change. This is the default option. Select this mode if the sprite is 9-sliced. Enter the sprite’s new Width and Height to scale the 9-sliced sprite. You can also use the Rect Transform Tool to scale the sprite while applying 9-slicing properties. By default, this mode causes the middle of the 9-Sliced sprite to tile instead of scale when its dimensions change. Use Tile Mode to control the tiling behavior of the sprite. This is the default Tile Mode. In Continuous mode, the midsection tiles evenly when the sprite dimensions change. In Adaptive mode, the sprite texture stretches when its dimensions change, similar to Simple mode. When the scale of the changed dimensions meets the Stretch Value, the midsection begins to tile. Stretch Value (available when Adaptive is selected) Use the slider to set the value between 0 and 1. The max value is 1, which represents double the original Sprite’s scale. Set how the Sprite Renderer behaves when interacting with a Sprite Mask \n\n A texture which defines which areas of an underlying image to reveal or hide. More info . See examples of the different options in the Mask Interaction section below. The Sprite Renderer doesn’t interact with any Sprite Masks in the Scene. This is the default option. The sprite is visible where the Sprite Mask overlays it, but not outside of it. The sprite is visible outside of the Sprite Mask, but not inside it. The Sprite Mask hides the sections of the sprite it overlays. Choose between the Sprite’s Center or its Pivot Point when calculating the distance between the sprite and the camera \n\n A component which creates an image of a particular viewpoint in your scene. The output is either drawn to the screen or captured as a texture. More info . See the section on Sprite Sort Point for further details. Select this to have Unity measure the distance between the camera’s Transform position and the Center of the sprite to determine its render order. Select the Pivot option. Edit the sprite’s Pivot position in the Sprite Editor. Select the material for newly created sprites. The default material is Sprites - Default. Click the circle icon to open the object picker window and select other materials. Tip: Lighting doesn’t affect this default sprite material. To have the sprite react to lighting, use the object picker window and select the Default - Diffuse material instead. Set the Sorting Layer of the sprite, which controls its priority during rendering. Select an existing Sorting Layer from the drop-down box, or create a new Sorting Layer. The default layer the sprite is on. Select this to create a new sorting layer for the selected sprite. Set the render priority of the sprite within its Sorting Layer. Lower numbered Sprites are rendered first, with higher numbered Sprites overlapping those below.\n\nIf the 2D Sprite package isn’t installed, the following option will be available in the Sprite Renderer InspectorA Unity window that displays information about the currently selected GameObject, asset or project settings, allowing you to inspect and edit the values. More info\n\nSee in Glossary window.\n\nClick on Install 2D Sprite Package to install the 2D Sprite package. Upon installing the package, the “Open Sprite Editor” button becomes available.\n\nClick on Open Sprite Editor to open the Sprite Editor window. The sprite assigned to the selected Sprite Renderer is automatically selected and opened in the Sprite Editor window for you to edit.\n\nThe image below demonstrates the effect of changing the RGB values on the Sprite Renderer’s Color setting. To change a Sprite’s opacity, change the value of its Color property’s Alpha (A) channel.\n\nMask Interaction controls how the Sprite Renderer interacts with Sprite Masks. Select either Visible Inside Mask or Visible Outside Mask from the drop-down menu. The examples below demonstrate the effect of each option with a square Sprite and a circle Mask:\n\nTo interact with a Sprite Mask, select Visible Inside Mask or Visible Outside Mask from the drop-down menu.\n\nThis property is only available when the Sprite Renderer’s Draw Mode is set to Simple.\n\nIn a 2D project, the Main Camera is set to Orthographic Projection mode by default. In this mode, Unity renders Sprites in the order of their distance to the camera, along the direction of the Camera’s view.\n\nBy default, a Sprite’s Sort Point is set to its Center, and Unity measures the distance between the camera’s Transform position and the Center of the Sprite to determine their render order.\n\nTo set to a different Sort Point from the Center, select the Pivot option. Edit the Sprite’s Pivot position in the Sprite Editor.\n• None Ability to sort Sprite-based renderers using the pivot position added in 2017.3"
    },
    {
        "link": "https://discussions.unity.com/t/get-sprite-s-of-a-texture2d-at-runtime/890295",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/22430503/unity-4-3-2d-how-to-assign-programmatically-sprites-to-an-object",
        "document": "I'm trying to create an object that will be responsible of creating and showing different sprites, so I would like to access directly the assets/sprites programmatically instead of drag and drop a sprite in the hierarchy under that object.\n\nThere's a way to programmatically create a new sprite and assign what I have in the assets folder?\n\nI also would like to have a sort of data structure with a few images loaded at the start of the game, an array or a dictionary or something like that so I can change based on some situation which images I need to show. But what confuses me since I'm new to Unity is how to create a sprite taking the reference to the sprite programmatically using the assets folder.\n\nI've created an array of sprites like this:\n\nin Unity I've added sprites inside the array manually (I just dragged png's inside the variable array) so actually in this Object I have a Component with this array full of sprites\n\ninside the component I also have done this:\n\nI got no error until I run the game, then the sprite is NOT assigned and I got this:\n\n\"PPtr cast failed when dereferencing! Castin from Texture2D to Sprite!\"\n\nI got this error even without casting (Sprite) and btw I don't know why he is telling my about Texture2D since verything is setted as sprite"
    },
    {
        "link": "https://docs.unity.cn/2023.3/Documentation/Manual/class-SpriteRenderer.html",
        "document": "The SpriteA 2D graphic objects. If you are used to working in 3D, Sprites are essentially just standard textures but there are special techniques for combining and managing sprite textures for efficiency and convenience during development. More info\n\nSee in Glossary Renderer component renders the Sprite and controls how it visually appears in a SceneA Scene contains the environments and menus of your game. Think of each unique Scene file as a unique level. In each Scene, you place your environments, obstacles, and decorations, essentially designing and building your game in pieces. More info\n\nSee in Glossary for both 2D and 3D projects.\n\nWhen you create a sprite (GameObject > 2D Object > Sprite), Unity automatically creates a GameObject with the Sprite Renderer component attached. You can also add the component to an existing GameObject via the Components menu (Component > Rendering > Sprite Renderer).\n\nDefine which sprite texture the component should render. Click the circle icon to the right to open the object picker window, and select from the list of available sprite assets. Click this button to open the Sprite Editor window to edit the currently selected sprite. Note: If the 2D Sprite package isn’t installed, a button to install the 2D Sprite package will be available instead. Define the vertex color of the sprite, which tints or recolors the Sprite’s image. Use the color picker to set the vertex color of the rendered sprite texture. See the Color section below this table for examples. Flips the sprite texture along the checked axis. This doesn’t flip the Transform position of the GameObject \n\n The fundamental object in Unity scenes, which can represent characters, props, scenery, cameras, waypoints, and more. A GameObject’s functionality is defined by the Components attached to it. More info . Define the Material used to render the sprite texture. Define how the sprite scales when its dimensions change. Select one of the following options from the drop-down box. The entire image scales when its dimensions change. This is the default option. Select this mode if the sprite is 9-sliced. Enter the sprite’s new Width and Height to scale the 9-sliced sprite. You can also use the Rect Transform Tool to scale the sprite while applying 9-slicing properties. By default, this mode causes the middle of the 9-Sliced sprite to tile instead of scale when its dimensions change. Use Tile Mode to control the tiling behavior of the sprite. This is the default Tile Mode. In Continuous mode, the midsection tiles evenly when the sprite dimensions change. In Adaptive mode, the sprite texture stretches when its dimensions change, similar to Simple mode. When the scale of the changed dimensions meets the Stretch Value, the midsection begins to tile. Stretch Value (available when Adaptive is selected) Use the slider to set the value between 0 and 1. The max value is 1, which represents double the original Sprite’s scale. Set how the Sprite Renderer behaves when interacting with a Sprite Mask \n\n A texture which defines which areas of an underlying image to reveal or hide. More info . See examples of the different options in the Mask Interaction section below. The Sprite Renderer doesn’t interact with any Sprite Masks in the Scene. This is the default option. The sprite is visible where the Sprite Mask overlays it, but not outside of it. The sprite is visible outside of the Sprite Mask, but not inside it. The Sprite Mask hides the sections of the sprite it overlays. Choose between the Sprite’s Center or its Pivot Point when calculating the distance between the sprite and the camera \n\n A component which creates an image of a particular viewpoint in your scene. The output is either drawn to the screen or captured as a texture. More info . See the section on Sprite Sort Point for further details. Select this to have Unity measure the distance between the camera’s Transform position and the Center of the sprite to determine its render order. Select the Pivot option. Edit the sprite’s Pivot position in the Sprite Editor. Select the material for newly created sprites. The default material is Sprites - Default. Click the circle icon to open the object picker window and select other materials. Tip: Lighting doesn’t affect this default sprite material. To have the sprite react to lighting, use the object picker window and select the Default - Diffuse material instead. Set the Sorting Layer of the sprite, which controls its priority during rendering. Select an existing Sorting Layer from the drop-down box, or create a new Sorting Layer. The default layer the sprite is on. Select this to create a new sorting layer for the selected sprite. Set the render priority of the sprite within its Sorting Layer. Lower numbered Sprites are rendered first, with higher numbered Sprites overlapping those below.\n\nIf the 2D Sprite package isn’t installed, the following option will be available in the Sprite Renderer InspectorA Unity window that displays information about the currently selected GameObject, asset or project settings, allowing you to inspect and edit the values. More info\n\nSee in Glossary window.\n\nClick on Install 2D Sprite Package to install the 2D Sprite package. Upon installing the package, the “Open Sprite Editor” button becomes available.\n\nClick on Open Sprite Editor to open the Sprite Editor window. The sprite assigned to the selected Sprite Renderer is automatically selected and opened in the Sprite Editor window for you to edit.\n\nThe image below demonstrates the effect of changing the RGB values on the Sprite Renderer’s Color setting. To change a Sprite’s opacity, change the value of its Color property’s Alpha (A) channel.\n\nMask Interaction controls how the Sprite Renderer interacts with Sprite Masks. Select either Visible Inside Mask or Visible Outside Mask from the drop-down menu. The examples below demonstrate the effect of each option with a square Sprite and a circle Mask:\n\nTo interact with a Sprite Mask, select Visible Inside Mask or Visible Outside Mask from the drop-down menu.\n\nThis property is only available when the Sprite Renderer’s Draw Mode is set to Simple.\n\nIn a 2D project, the Main Camera is set to Orthographic Projection mode by default. In this mode, Unity renders Sprites in the order of their distance to the camera, along the direction of the Camera’s view.\n\nBy default, a Sprite’s Sort Point is set to its Center, and Unity measures the distance between the camera’s Transform position and the Center of the Sprite to determine their render order.\n\nTo set to a different Sort Point from the Center, select the Pivot option. Edit the Sprite’s Pivot position in the Sprite Editor.\n• None Ability to sort Sprite-based renderers using the pivot position added in 2017.3"
    }
]