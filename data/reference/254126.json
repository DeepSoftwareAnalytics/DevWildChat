[
    {
        "link": "https://geeksforgeeks.org/new-and-delete-operators-in-cpp-for-dynamic-memory",
        "document": "Dynamic memory allocation in C/C++ refers to performing memory allocation manually by a programmer. Dynamically allocated memory is allocated on Heap, and non-static and local variables get memory allocated on Stack (Refer to Memory Layout C Programs for details).\n• None One use of dynamically allocated memory is to allocate memory of variable size, which is not possible with compiler allocated memory except for\n• None The most important use is the flexibility provided to programmers. We are free to allocate and deallocate memory whenever we need it and whenever we don’t need it anymore. There are many cases where this flexibility helps. Examples of such cases are\n\nHow is it different from memory allocated to normal variables?\n\nFor normal variables like “int a”, “char str[10]”, etc, memory is automatically allocated and deallocated. For dynamically allocated memory like “int *p = new int[10]”, it is the programmer’s responsibility to deallocate memory when no longer needed. If the programmer doesn’t deallocate memory, it causes a memory leak (memory is not deallocated until the program terminates).\n\nHow is memory allocated/deallocated in C++? \n\nC uses the malloc() and calloc() function to allocate memory dynamically at run time and uses a free() function to free dynamically allocated memory. C++ supports these functions and also has two operators new and delete, that perform the task of allocating and freeing the memory in a better and easier way.\n\nThe new operator denotes a request for memory allocation on the Free Store. If sufficient memory is available, a new operator initializes the memory and returns the address of the newly allocated and initialized memory to the pointer variable.\n\nSyntax to use new operator\n\nHere, the pointer variable is the pointer of type data-type. Data type could be any built-in data type including array or any user-defined data type including structure and class. \n\nExample:\n\nInitialize memory: We can also initialize the memory for built-in data types using a new operator. For custom data types, a constructor is required (with the data type as input) for initializing the value. Here’s an example of the initialization of both data types :\n\nAllocate a block of memory: a new operator is also used to allocate a block(an array) of memory of type data type.\n\nwhere size(a variable) specifies the number of elements in an array.\n\nDynamically allocates memory for 10 integers continuously of type int and returns a pointer to the first element of the sequence, which is assigned top(a pointer). p[0] refers to the first element, p[1] refers to the second element, and so on.\n\nNormal Array Declaration vs Using new \n\nThere is a difference between declaring a normal array and allocating a block of memory using new. The most important difference is, that normal arrays are deallocated by the compiler (If the array is local, then deallocated when the function returns or completes). However, dynamically allocated arrays always remain there until either they are deallocated by the programmer or the program terminates.\n\nWhat if enough memory is not available during runtime? \n\nIf enough memory is not available in the heap to allocate, the new request indicates failure by throwing an exception of type std::bad_alloc, unless “nothrow” is used with the new operator, in which case it returns a NULL pointer (scroll to section “Exception handling of new operator” in this article). Therefore, it may be a good idea to check for the pointer variable produced by the new before using its program.\n\nSince it is the programmer’s responsibility to deallocate dynamically allocated memory, programmers are provided delete operator in C++ language.\n\nHere, the pointer variable is the pointer that points to the data object created by new.\n\nTo free the dynamically allocated array pointed by pointer variable, use the following form of delete:\n\nTime Complexity: O(n), where n is the given memory size.\n• None Quiz on new and delete"
    },
    {
        "link": "https://cplusplus.com/doc/tutorial/dynamic",
        "document": "std; main () { i,n; * p; cout << \"How many numbers would you like to type? \" ; cin >> i; p= (nothrow) [i]; (p == ) cout << \"Error: memory could not be allocated\" ; { (n=0; n<i; n++) { cout << ; cin >> p[n]; } cout << ; (n=0; n<i; n++) cout << p[n] << ; [] p; } 0; }\n\nHow many numbers would you like to type? 5 Enter number : 75 Enter number : 436 Enter number : 1067 Enter number : 8 Enter number : 32 You have entered: 75, 436, 1067, 8, 32,"
    },
    {
        "link": "https://stackoverflow.com/questions/25088801/c-dynamic-memory-allocation-using-new",
        "document": "I'm new to C++, trying to learn by myself (I've got Java background).\n\nThere's this concept of dynamic memory allocation that I can assign to an array (for example) using .\n\nIn C (and also in C++) I've got and that are doing that. In C++ they've added the for some reason I can't understand.\n\nI've read a lot about the difference between a normal array that goes to the stack while the dynamic allocated array goes to the heap.\n\nSo what I understand is that by using I'm allocating space in the heap which will not be deleted automatically when finished a function let's say, but will remain where it is until I finally, manually free it.\n\nI couldn't find practical examples of using the dynamic memory allocation over the normal memory.\n• It's said that I can't allocate memory through runtime when using normal array. Well, probably I didn't understand it right because when I tried to create a normal array (without ) with a capacity given as an input by the user (like ), it worked fine.\n\nhere is what I mean:\n• I didn't really understand why it's called dynamic when the only way of extending the capacity of an array is to copy it to a , larger array.\n\nI understood that the Vector class (which I haven't yet learned) is much better to use. But still, I can't just leave that gap of knowledge begin and I must understand why exactly it's called dynamic and why should I use it instead of a normal array. Why should I bother freeing memory manually when I can't really extend it but only copy it to a new array?"
    },
    {
        "link": "https://stackoverflow.com/questions/28953728/clarification-on-when-to-use-the-new-keyword-in-c",
        "document": "I'm reading the answer to When should I use the new keyword in C++?, and Why should C++ programmers minimize use of 'new'?. but I'm a little bit confused.\n\nIs it correct to say that I should use the keyword whenever I want to create an object whose size could change a lot?\n\nOr do I use whenever I don't know the size of an object at compile-time?\n\nTake the following examples:\n• None A which I don't know the size of at compile time, containing user-defined objects. Once initialized, the size never changes.\n• None A which I know the initial size of, but whose size could change throughout the program.\n• None A user defined object containing objects, whose sizes all don't change. Other fields also don't change in size, but the sizes are not known at compile-time.\n• None A user defined object whose fields could all change in size\n\nIt seems to me that I should use in case 1 and 2, but not 3 and 4. Although, in 3 and 4, I should use to allocate memory for the fields inside the user defined object. Is this correct?\n\nDoes the usage of depend on how much the size of an object changes?\n\nIf I don't use , what risks am I taking (such as stackoverflow?)?\n\nIn examples 3 and 4, If I don't use , and I pass this object around, will I be making copies of the object each time I pass it?\n\nIf so, and the size of the object is \"too big\" (for instance, it has many, very large fields), could passing the object possibly cause a stackoverflow, corrupting the data of other objects on the stack?\n\nFinally, when using , I understand I also have to use . However, if a lot of different objects (let's call them A, B, and C) have access to the same pointer (P*), how does calling in A affect P* in B and C? I assume it frees up the memory for all of them, such that if I now call P->get_something() in B or C, I would receive a segfault. Then, to prevent a memory leak, as long as something still has access to P*, I should not call , but as soon as I'm sure nothing has access to P*, I need to delete it, right?"
    },
    {
        "link": "https://learncpp.com/cpp-tutorial/dynamic-memory-allocation-with-new-and-delete",
        "document": "The need for dynamic memory allocation\n\nC++ supports three basic types of memory allocation, of which you’ve already seen two.\n• Static memory allocation happens for static and global variables. Memory for these types of variables is allocated once when your program is run and persists throughout the life of your program.\n• Automatic memory allocation happens for function parameters and local variables. Memory for these types of variables is allocated when the relevant block is entered, and freed when the block is exited, as many times as necessary.\n• Dynamic memory allocation is the topic of this article.\n\nBoth static and automatic allocation have two things in common:\n• The size of the variable / array must be known at compile time.\n• Memory allocation and deallocation happens automatically (when the variable is instantiated / destroyed).\n\nMost of the time, this is just fine. However, you will come across situations where one or both of these constraints cause problems, usually when dealing with external (user or file) input.\n\nFor example, we may want to use a string to hold someone’s name, but we do not know how long their name is until they enter it. Or we may want to read in a number of records from disk, but we don’t know in advance how many records there are. Or we may be creating a game, with a variable number of monsters (that changes over time as some monsters die and new ones are spawned) trying to kill the player.\n\nIf we have to declare the size of everything at compile time, the best we can do is try to make a guess the maximum size of variables we’ll need and hope that’s enough:\n\nThis is a poor solution for at least four reasons:\n\nFirst, it leads to wasted memory if the variables aren’t actually used. For example, if we allocate 25 chars for every name, but names on average are only 12 chars long, we’re using over twice what we really need. Or consider the rendering array above: if a rendering only uses 10,000 polygons, we have 20,000 Polygons worth of memory not being used!\n\nSecond, how do we tell which bits of memory are actually used? For strings, it’s easy: a string that starts with a \\0 is clearly not being used. But what about monster[24]? Is it alive or dead right now? Has it even been initialized in the first place? That necessitates having some way to tell the status of each monster, which adds complexity and can use up additional memory.\n\nThird, most normal variables (including fixed arrays) are allocated in a portion of memory called the stack. The amount of stack memory for a program is generally quite small -- Visual Studio defaults the stack size to 1MB. If you exceed this number, stack overflow will result, and the operating system will probably close down the program.\n\nOn Visual Studio, you can see this happen when running this program:\n\nBeing limited to just 1MB of memory would be problematic for many programs, especially those that deal with graphics.\n\nFourth, and most importantly, it can lead to artificial limitations and/or array overflows. What happens when the user tries to read in 600 records from disk, but we’ve only allocated memory for a maximum of 500 records? Either we have to give the user an error, only read the 500 records, or (in the worst case where we don’t handle this case at all) overflow the record array and watch something bad happen.\n\nFortunately, these problems are easily addressed via dynamic memory allocation. Dynamic memory allocation is a way for running programs to request memory from the operating system when needed. This memory does not come from the program’s limited stack memory -- instead, it is allocated from a much larger pool of memory managed by the operating system called the heap. On modern machines, the heap can be gigabytes in size.\n\nTo allocate a single variable dynamically, we use the scalar (non-array) form of the new operator:\n\nIn the above case, we’re requesting an integer’s worth of memory from the operating system. The new operator creates the object using that memory, and then returns a pointer containing the address of the memory that has been allocated.\n\nMost often, we’ll assign the return value to our own pointer variable so we can access the allocated memory later.\n\nWe can then dereference the pointer to access the memory:\n\nIf it wasn’t before, it should now be clear at least one case in which pointers are useful. Without a pointer to hold the address of the memory that was just allocated, we’d have no way to access the memory that was just allocated for us!\n\nNote that accessing heap-allocated objects is generally slower than accessing stack-allocated objects. Because the compiler knows the address of stack-allocated objects, it can go directly to that address to get a value. Heap allocated objects are typically accessed via pointer. This requires two steps: one to get the address of the object (from the pointer), and another to get the value.\n\nYour computer has memory (probably lots of it) that is available for applications to use. When you run an application, your operating system loads the application into some of that memory. This memory used by your application is divided into different areas, each of which serves a different purpose. One area contains your code. Another area is used for normal operations (keeping track of which functions were called, creating and destroying global and local variables, etc…). We’ll talk more about those later. However, much of the memory available just sits there, waiting to be handed out to programs that request it.\n\nWhen you dynamically allocate memory, you’re asking the operating system to reserve some of that memory for your program’s use. If it can fulfill this request, it will return the address of that memory to your application. From that point forward, your application can use this memory as it wishes. When your application is done with the memory, it can return the memory back to the operating system to be given to another program.\n\nUnlike static or automatic memory, the program itself is responsible for requesting and disposing of dynamically allocated memory.\n\nWhen you dynamically allocate a variable, you can also initialize it via direct initialization or uniform initialization:\n\nWhen we are done with a dynamically allocated variable, we need to explicitly tell C++ to free the memory for reuse. For single variables, this is done via the scalar (non-array) form of the delete operator:\n\nWhat does it mean to delete memory?\n\nThe delete operator does not actually delete anything. It simply returns the memory being pointed to back to the operating system. The operating system is then free to reassign that memory to another application (or to this application again later).\n\nAlthough the syntax makes it look like we’re deleting a variable, this is not the case! The pointer variable still has the same scope as before, and can be assigned a new value (e.g. ) just like any other variable.\n\nNote that deleting a pointer that is not pointing to dynamically allocated memory may cause bad things to happen.\n\nC++ does not make any guarantees about what will happen to the contents of deallocated memory, or to the value of the pointer being deleted. In most cases, the memory returned to the operating system will contain the same values it had before it was returned, and the pointer will be left pointing to the now deallocated memory.\n\nA pointer that is pointing to deallocated memory is called a dangling pointer. Dereferencing or deleting a dangling pointer will lead to undefined behavior. Consider the following program:\n\nIn the above program, the value of 7 that was previously assigned to the allocated memory will probably still be there, but it’s possible that the value at that memory address could have changed. It’s also possible the memory could be allocated to another application (or for the operating system’s own usage), and trying to access that memory will cause the operating system to shut the program down.\n\nDeallocating memory may create multiple dangling pointers. Consider the following example:\n\nThere are a few best practices that can help here.\n\nFirst, try to avoid having multiple pointers point at the same piece of dynamic memory. If this is not possible, be clear about which pointer “owns” the memory (and is responsible for deleting it) and which pointers are just accessing it.\n\nSecond, when you delete a pointer, if that pointer is not going out of scope immediately afterward, set the pointer to nullptr. We’ll talk more about null pointers, and why they are useful in a bit.\n\nWhen requesting memory from the operating system, in rare circumstances, the operating system may not have any memory to grant the request with.\n\nBy default, if new fails, a bad_alloc exception is thrown. If this exception isn’t properly handled (and it won’t be, since we haven’t covered exceptions or exception handling yet), the program will simply terminate (crash) with an unhandled exception error.\n\nIn many cases, having new throw an exception (or having your program crash) is undesirable, so there’s an alternate form of new that can be used instead to tell new to return a null pointer if memory can’t be allocated. This is done by adding the constant std::nothrow between the new keyword and the allocation type:\n\nIn the above example, if new fails to allocate memory, it will return a null pointer instead of the address of the allocated memory.\n\nNote that if you then attempt to dereference this pointer, undefined behavior will result (most likely, your program will crash). Consequently, the best practice is to check all memory requests to ensure they actually succeeded before using the allocated memory.\n\nBecause asking new for memory only fails rarely (and almost never in a dev environment), it’s common to forget to do this check!\n\nNull pointers (pointers set to nullptr) are particularly useful when dealing with dynamic memory allocation. In the context of dynamic memory allocation, a null pointer basically says “no memory has been allocated to this pointer”. This allows us to do things like conditionally allocate memory:\n\nDeleting a null pointer has no effect. Thus, there is no need for the following:\n\nInstead, you can just write:\n\nIf ptr is non-null, the dynamically allocated memory will be deleted. If ptr is null, nothing will happen.\n\nDynamically allocated memory stays allocated until it is explicitly deallocated or until the program ends (and the operating system cleans it up, assuming your operating system does that). However, the pointers used to hold dynamically allocated memory addresses follow the normal scoping rules for local variables. This mismatch can create interesting problems.\n\nConsider the following function:\n\nThis function allocates an integer dynamically, but never frees it using delete. Because pointers variables are just normal variables, when the function ends, ptr will go out of scope. And because ptr is the only variable holding the address of the dynamically allocated integer, when ptr is destroyed there are no more references to the dynamically allocated memory. This means the program has now “lost” the address of the dynamically allocated memory. As a result, this dynamically allocated integer can not be deleted.\n\nThis is called a memory leak. Memory leaks happen when your program loses the address of some bit of dynamically allocated memory before giving it back to the operating system. When this happens, your program can’t delete the dynamically allocated memory, because it no longer knows where it is. The operating system also can’t use this memory, because that memory is considered to be still in use by your program.\n\nMemory leaks eat up free memory while the program is running, making less memory available not only to this program, but to other programs as well. Programs with severe memory leak problems can eat all the available memory, causing the entire machine to run slowly or even crash. Only after your program terminates is the operating system able to clean up and “reclaim” all leaked memory.\n\nAlthough memory leaks can result from a pointer going out of scope, there are other ways that memory leaks can result. For example, a memory leak can occur if a pointer holding the address of the dynamically allocated memory is assigned another value:\n\nThis can be fixed by deleting the pointer before reassigning it:\n\nRelatedly, it is also possible to get a memory leak via double-allocation:\n\nThe address returned from the second allocation overwrites the address of the first allocation. Consequently, the first allocation becomes a memory leak!\n\nSimilarly, this can be avoided by ensuring you delete the pointer before reassigning.\n\nOperators new and delete allow us to dynamically allocate single variables for our programs.\n\nDynamically allocated memory has dynamic duration and will stay allocated until you deallocate it or the program terminates.\n\nBe careful not to perform dereference a dangling or null pointers.\n\nIn the next lesson, we’ll take a look at using new and delete to allocate and delete arrays."
    },
    {
        "link": "https://stackoverflow.com/questions/1354958/memory-leaks-in-c-via-newdelete",
        "document": "If you mean do you need the same number of instances of in your source code as you have instances of , then no. You can have objects ed in multiple places, but all these objects d by the same line of code. In fact this is a common idiom.\n\nSmart pointers, of varying types, generally take many different objects ed in many places in user code and them from a single place in library code.\n\nTechnically, every successfully memory allocation call needs to be matched with a dellocation call that takes the returned pointer from the original allocation call.\n\nMost expressions result in a call to an that allocates the memory and the constructs an object in the newly allocated memory. Using a expression destroys the object and causes a call to an that should free the allocated memory.\n\nThere are new expressions that construct objects in pre-allocated memory (placement ). These should not be matched by a delete expression, but the pre-allocated memory may need to be deallocated in a way that corresponds to the original allocation."
    },
    {
        "link": "https://stackoverflow.com/questions/76796/general-guidelines-to-avoid-memory-leaks-in-c",
        "document": "What are some general tips to make sure I don't leak memory in C++ programs? How do I figure out who should free memory that has been dynamically allocated?\n\nAs it currently stands, this question is not a good fit for our Q&A format. We expect answers to be supported by facts, references, or expertise, but this question will likely solicit debate, arguments, polling, or extended discussion. If you feel that this question can be improved and possibly reopened, visit the help center for guidance.\n• Forget Garbage Collection (Use RAII instead). Note that even the Garbage Collector can leak, too (if you forget to \"null\" some references in Java/C#), and that Garbage Collector won't help you to dispose of resources (if you have an object which acquired a handle to a file, the file won't be freed automatically when the object will go out of scope if you don't do it manually in Java, or use the \"dispose\" pattern in C#).\n• Forget the \"one return per function\" rule. This is a good C advice to avoid leaks, but it is outdated in C++ because of its use of exceptions (use RAII instead).\n• And while the \"Sandwich Pattern\" is a good C advice, it is outdated in C++ because of its use of exceptions (use RAII instead). This post seem to be repetitive, but in C++, the most basic pattern to know is RAII. Learn to use smart pointers, both from boost, TR1 or even the lowly (but often efficient enough) auto_ptr (but you must know its limitations). RAII is the basis of both exception safety and resource disposal in C++, and no other pattern (sandwich, etc.) will give you both (and most of the time, it will give you none). See below a comparison of RAII and non RAII code: void doSandwich() { T * p = new T() ; // do something with p delete p ; // leak if the p processing throws or return } void doRAIIDynamic() { std::auto_ptr<T> p(new T()) ; // you can use other smart pointers, too // do something with p // WON'T EVER LEAK, even in case of exceptions, returns, breaks, etc. } void doRAIIStatic() { T p ; // do something with p // WON'T EVER LEAK, even in case of exceptions, returns, breaks, etc. } To summarize (after the comment from Ogre Psalm33), RAII relies on three concepts:\n• Once the object is constructed, it just works! Do acquire resources in the constructor.\n• Object destruction is enough! Do free resources in the destructor.\n• It's all about scopes! Scoped objects (see doRAIIStatic example above) will be constructed at their declaration, and will be destroyed the moment the execution exits the scope, no matter how the exit (return, break, exception, etc.). This means that in correct C++ code, most objects won't be constructed with , and will be declared on the stack instead. And for those constructed using , all will be somehow scoped (e.g. attached to a smart pointer). As a developer, this is very powerful indeed as you won't need to care about manual resource handling (as done in C, or for some objects in Java which makes intensive use of / for that case)... \"scoped objects ... will be destructed ... no matter the exit\" that's not entirely true. there are ways to cheat RAII. any flavour of terminate() will bypass cleanup. exit(EXIT_SUCCESS) is an oxymoron in this regard. wilhelmtell is quite right about that: There are exceptional ways to cheat RAII, all leading to the process abrupt stop. Those are exceptional ways because C++ code is not littered with terminate, exit, etc., or in the case with exceptions, we do want an unhandled exception to crash the process and core dump its memory image as is, and not after cleaning. But we must still know about those cases because, while they rarely happen, they can still happen. (who calls or in casual C++ code?... I remember having to deal with that problem when playing with GLUT: This library is very C-oriented, going as far as actively designing it to make things difficult for C++ developers like not caring about stack allocated data, or having \"interesting\" decisions about never returning from their main loop... I won't comment about that).\n\nYou'll want to look at smart pointers, such as boost's smart pointers. boost::shared_ptr will automatically delete once the reference count is zero: int main() { boost::shared_ptr<Object> obj(new Object()); //... // destructor destroys when reference count is zero } Note my last note, \"when reference count is zero, which is the coolest part. So If you have multiple users of your object, you won't have to keep track of whether the object is still in use. Once nobody refers to your shared pointer, it gets destroyed. This is not a panacea, however. Though you can access the base pointer, you wouldn't want to pass it to a 3rd party API unless you were confident with what it was doing. Lots of times, your \"posting\" stuff to some other thread for work to be done AFTER the creating scope is finished. This is common with PostThreadMessage in Win32: void foo() { boost::shared_ptr<Object> obj(new Object()); // Simplified here PostThreadMessage(...., (LPARAM)ob.get()); // Destructor destroys! pointer sent to PostThreadMessage is invalid! Zohnoes! } As always, use your thinking cap with any tool...\n\nBah, you young kids and your new-fangled garbage collectors... Very strong rules on \"ownership\" - what object or part of the software has the right to delete the object. Clear comments and wise variable names to make it obvious if a pointer \"owns\" or is \"just look, don't touch\". To help decide who owns what, follow as much as possible the \"sandwich\" pattern within every subroutine or method. create a thing use that thing destroy that thing Sometimes it's necessary to create and destroy in widely different places; i think hard to avoid that. In any program requiring complex data structures, i create a strict clear-cut tree of objects containing other objects - using \"owner\" pointers. This tree models the basic hierarchy of application domain concepts. Example a 3D scene owns objects, lights, textures. At the end of the rendering when the program quits, there's a clear way to destroy everything. Many other pointers are defined as needed whenever one entity needs access another, to scan over arays or whatever; these are the \"just looking\". For the 3D scene example - an object uses a texture but does not own; other objects may use that same texture. The destruction of an object does not invoke destruction of any textures. Yes it's time consuming but that's what i do. I rarely have memory leaks or other problems. But then i work in the limited arena of high-performance scientific, data acquisition and graphics software. I don't often deal transactions like in banking and ecommerce, event-driven GUIs or high networked asynchronous chaos. Maybe the new-fangled ways have an advantage there!\n\nA frequent source of these bugs is when you have a method that accepts a reference or pointer to an object but leaves ownership unclear. Style and commenting conventions can make this less likely. Let the case where the function takes ownership of the object be the special case. In all situations where this happens, be sure to write a comment next to the function in the header file indicating this. You should strive to make sure that in most cases the module or class which allocates an object is also responsible for deallocating it. Using const can help a lot in some cases. If a function will not modify an object, and does not store a reference to it that persists after it returns, accept a const reference. From reading the caller's code it will be obvious that your function has not accepted ownership of the object. You could have had the same function accept a non-const pointer, and the caller may or may not have assumed that the callee accepted ownership, but with a const reference there's no question. Do not use non-const references in argument lists. It is very unclear when reading the caller code that the callee may have kept a reference to the parameter. I disagree with the comments recommending reference counted pointers. This usually works fine, but when you have a bug and it doesn't work, especially if your destructor does something non-trivial, such as in a multithreaded program. Definitely try to adjust your design to not need reference counting if it's not too hard.\n\nWe wrap all our allocation functions with a layer that appends a brief string at the front and a sentinel flag at the end. So for example you'd have a call to \"myalloc( pszSomeString, iSize, iAlignment ); or new( \"description\", iSize ) MyObject(); which internally allocates the specified size plus enough space for your header and sentinel. Of course, don't forget to comment this out for non-debug builds! It takes a little more memory to do this but the benefits far outweigh the costs. This has three benefits - first it allows you to easily and quickly track what code is leaking, by doing quick searches for code allocated in certain 'zones' but not cleaned up when those zones should have freed. It can also be useful to detect when a boundary has been overwritten by checking to ensure all sentinels are intact. This has saved us numerous times when trying to find those well-hidden crashes or array missteps. The third benefit is in tracking the use of memory to see who the big players are - a collation of certain descriptions in a MemDump tells you when 'sound' is taking up way more space than you anticipated, for example."
    },
    {
        "link": "https://ptolemy.berkeley.edu/ptolemyclassic/almagest/docs/prog/html/ptlang.doc7.html",
        "document": ""
    },
    {
        "link": "https://geeksforgeeks.org/new-and-delete-operators-in-cpp-for-dynamic-memory",
        "document": "Dynamic memory allocation in C/C++ refers to performing memory allocation manually by a programmer. Dynamically allocated memory is allocated on Heap, and non-static and local variables get memory allocated on Stack (Refer to Memory Layout C Programs for details).\n• None One use of dynamically allocated memory is to allocate memory of variable size, which is not possible with compiler allocated memory except for\n• None The most important use is the flexibility provided to programmers. We are free to allocate and deallocate memory whenever we need it and whenever we don’t need it anymore. There are many cases where this flexibility helps. Examples of such cases are\n\nHow is it different from memory allocated to normal variables?\n\nFor normal variables like “int a”, “char str[10]”, etc, memory is automatically allocated and deallocated. For dynamically allocated memory like “int *p = new int[10]”, it is the programmer’s responsibility to deallocate memory when no longer needed. If the programmer doesn’t deallocate memory, it causes a memory leak (memory is not deallocated until the program terminates).\n\nHow is memory allocated/deallocated in C++? \n\nC uses the malloc() and calloc() function to allocate memory dynamically at run time and uses a free() function to free dynamically allocated memory. C++ supports these functions and also has two operators new and delete, that perform the task of allocating and freeing the memory in a better and easier way.\n\nThe new operator denotes a request for memory allocation on the Free Store. If sufficient memory is available, a new operator initializes the memory and returns the address of the newly allocated and initialized memory to the pointer variable.\n\nSyntax to use new operator\n\nHere, the pointer variable is the pointer of type data-type. Data type could be any built-in data type including array or any user-defined data type including structure and class. \n\nExample:\n\nInitialize memory: We can also initialize the memory for built-in data types using a new operator. For custom data types, a constructor is required (with the data type as input) for initializing the value. Here’s an example of the initialization of both data types :\n\nAllocate a block of memory: a new operator is also used to allocate a block(an array) of memory of type data type.\n\nwhere size(a variable) specifies the number of elements in an array.\n\nDynamically allocates memory for 10 integers continuously of type int and returns a pointer to the first element of the sequence, which is assigned top(a pointer). p[0] refers to the first element, p[1] refers to the second element, and so on.\n\nNormal Array Declaration vs Using new \n\nThere is a difference between declaring a normal array and allocating a block of memory using new. The most important difference is, that normal arrays are deallocated by the compiler (If the array is local, then deallocated when the function returns or completes). However, dynamically allocated arrays always remain there until either they are deallocated by the programmer or the program terminates.\n\nWhat if enough memory is not available during runtime? \n\nIf enough memory is not available in the heap to allocate, the new request indicates failure by throwing an exception of type std::bad_alloc, unless “nothrow” is used with the new operator, in which case it returns a NULL pointer (scroll to section “Exception handling of new operator” in this article). Therefore, it may be a good idea to check for the pointer variable produced by the new before using its program.\n\nSince it is the programmer’s responsibility to deallocate dynamically allocated memory, programmers are provided delete operator in C++ language.\n\nHere, the pointer variable is the pointer that points to the data object created by new.\n\nTo free the dynamically allocated array pointed by pointer variable, use the following form of delete:\n\nTime Complexity: O(n), where n is the given memory size.\n• None Quiz on new and delete"
    },
    {
        "link": "https://quora.com/How-can-I-efficiently-handle-memory-management-in-C-to-avoid-memory-leaks",
        "document": "Something went wrong. Wait a moment and try again."
    }
]