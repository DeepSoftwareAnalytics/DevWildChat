[
    {
        "link": "https://geeksforgeeks.org/reverse-a-linked-list",
        "document": "Given a linked list, the task is to reverse the linked list by changing the links between nodes.\n\n[Expected Approach] Using Iterative Method – O(n) Time and O(1) Space\n\nThe idea is to reverse the links of all nodes using three pointers:\n• prev: pointer to keep track of the previous node\n• curr: pointer to keep track of the current node\n• next: pointer to keep track of the next node Starting from the first node, initialize curr with the head of linked list and next with the next node of curr. Update the next pointer of curr with prev. Finally, move the three pointer by updating prev with curr and curr with next.\n\nFollow the steps below to solve the problem:\n• None Iterate through the linked list. In a loop, do the following:\n• None Update the next pointer of curr to prev , curr -> next = prev\n• None Update prev as curr and curr as next, prev = curr curr = next\n\n// Given the head of a list, reverse the list and // Initialize three pointers: curr, prev and next // Traverse all the nodes of Linked List // Given the head of a list, reverse the list and return the // Initialize three pointers: curr, prev and next // Traverse all the nodes of Linked List // Given the head of a list, reverse the list and return the // Initialize three pointers: curr, prev and next // Traverse all the nodes of Linked List // of the linked list starting from the head # Given the head of a list, reverse the list and return the # Initialize three pointers: curr, prev and next # Traverse all the nodes of Linked List // Given the head of a list, reverse the list and return the // Initialize three pointers: curr, prev and next // Traverse all the nodes of Linked List // Given the head of a list, reverse the list and return the // Initialize three pointers: curr, prev and next // Traverse all the nodes of Linked List\n\n[Alternate Approach – 1] Using Recursion – O(n) Time and O(n) Space\n\nFollow the steps below to solve the problem:\n• None Divide the list in two parts – first node and rest of the linked list.\n• reverse for the rest of the linked list.\n• None Link the rest linked list to first.\n\n// Given the head of a list, reverse the list // and return the head of reversed list // reverse the rest of linked list and put // the first element at the end // Make the current head as last node of // Update next of current head to NULL // Given the head of a list, reverse the list and // reverse the rest of linked list and put // the first element at the end // Make the current head as last node of // Update next of current head to NULL // of the linked list starting from the head // Given the head of a list, reverse the list // and return the head of reversed list // If we have reached last node or linked // reverse the rest of linked list and put // the first element at the end // Make the current head as last node of // Update next of current head to NULL // of the linked list starting from the head # Given the head of a list, reverse the list and # reverse the rest of linked list and put the # first element at the end # Make the current head as last node of # Update next of current head to NULL // Given the head of a list, reverse the list // and return the head of reversed list // reverse the rest of linked list and // put the first element at the end // Make the current head as last node // Update next of current head to NULL // of the linked list starting from the head // Given the head of a list, reverse the list // and return the head of reversed list // reverse the rest of linked list and // put the first element at the end // Make the current head as last node of // Update next of current head to NULL\n\n[Alternate Approach – 2] Using Stack – O(n) Time and O(n) Space\n\n\n\nFollow the steps below to solve the problem:\n• None Push all the nodes(values and address) except the last node in the stack.\n• None Once the nodes are pushed, update the Head pointer to the last node.\n• None Start popping the nodes and push them at the end of the linked list in the same order until the stack is empty.\n• None Update the next pointer of last node in the stack by NULL.\n\n// C++ program to reverse linked list using Stack // Push all nodes except the last node into stack // Make the last node as new head of the linked list // Pop all the nodes and append to the linked list // append the top value of stack in list // Pop the value from stack // move to the next node in the list // Update the next pointer of last node of stack to NULL // C program to reverse linked list using Stack // Push all nodes except the last node into stack // Make the last node as new head of the linked list // Pop all the nodes and append to the linked list // append the top value of stack in list and // pop the top value by decrementing top by 1 // move to the next node in the list // Update the next pointer of last node of stack to NULL // Push all nodes except the last node into stack // Make the last node as new head of the linked list // Pop all the nodes and append to the linked list // append the top value of stack in list // move to the next node in the list // Update the next pointer of last node // of the linked list starting from the head # Push all nodes except the last node into stack # Make the last node as new head of the linked list # Pop all the nodes and append to the linked list # append the top value of stack in list # move to the next node in the list # Update the next pointer of last node // C# program to reverse linked list using stack // Push all nodes except the last node into stack // Make the last node as new head of the linked list // Pop all the nodes and append to the linked list // append the top value of stack in list // move to the next node in the list // Update the next pointer of last node of stack to null // Push all nodes except the last node into stack // Make the last node as new head of the Linked List // Pop all the nodes and append to the linked list // append the top value of stack in list // move to the next node in the list // Update the next pointer of last node of stack to null"
    },
    {
        "link": "https://geeksforgeeks.org/reverse-a-linkedlist-in-java",
        "document": "Assuming you have gone through LinkedList in java and know about linked list. This post contains different examples for reversing a linked list which are given below: 1. By writing our own function(Using additional space): reverseLinkedList() method contains logic for reversing string objects in a linked list. This method takes a linked list as a parameter, traverses all the elements in reverse order and adds it to the newly created linked list. Algorithm: Step 1. Create a linked list with n elements Step 2. Create an empty linked list which will be used to store reversed elements Step 3. Start traversing the list from ‘n’ to ‘0’ and store the elements in the newly created list. Step 4. The elements will be stored in the following order: n, n-1, n-2, ……0 Step 5. Return the list to the caller and print it\n\nTime Complexity: O(n) Space Complexity: O(n) NOTE: As we are using additional memory space for storing all the reversed ‘n’ elements, the space complexity is O(n).\n\n2. By writing our own function(Without using additional space): In the previous example, a linked list is used additionally for storing all the reversed elements which takes more space. To avoid that, same linked list can be used for reversing. Algorithm: 1. Create a linked list with n elements 1. Run the loop for n/2 times where ‘n’ is the number of elements in the linkedlist. 2. In the first pass, Swap the first and nth element 3. In the second pass, Swap the second and (n-1)th element and so on till you reach the mid of the linked list. 4. Return the linked list after loop termination.\n\n3. By using Collections class: Collections is a class in java.util package which contains various static methods for searching, sorting, reversing, finding max, min….etc. We can make use of the In-built Collections.reverse() method for reversing an linked list. It takes a list as an input parameter and returns the reversed list. NOTE: Collections.reverse() method uses the same algorithm as “By writing our own function(Without using additional space)”\n\n4.Reversing a linked list of user defined objects: An Employee class is created for creating user defined objects with employeeID, employeeName, departmentName as class variables which are initialized in the constructor. An linked list is created that takes only Employee(user defined) Objects. These objects are added to the linked list using add() method. The linked list is reversed using In-built reverse() method of Collections class. printElements() method is used to iterate through all the user defined objects in the linked list and print the employee ID, name and department name for every object."
    },
    {
        "link": "https://stackoverflow.com/questions/10277888/best-way-to-reverse-a-java-util-linkedlist-in-place-if-possible",
        "document": "I want to reverse a using the available methods.\n\n Looking in the methods provided and the I couldn't see an option other than the following:\n\nBut surely there must be a better way. I mean it is not a good idea to modify a list outside of an iterator, but I couldn't see how I could use one here without having to create a new list.\n\n Is there a better way?"
    },
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html",
        "document": "Appends all of the elements in the specified collection to the end of this list, in the order that they are returned by the specified collection's iterator.\n\nReturns the index of the first occurrence of the specified element in this list, or -1 if this list does not contain the element.\n\nReturns the index of the last occurrence of the specified element in this list, or -1 if this list does not contain the element.\n\nReturns an array containing all of the elements in this list in proper sequence (from first to last element); the runtime type of the returned array is that of the specified array."
    },
    {
        "link": "https://stackoverflow.com/questions/42220026/reversing-a-linked-list-in-java-without-changing-the-original",
        "document": "To understand it, picture your list looks like this\n\nIf you get the head, then you are getting object 'a'. Then you are modifying object 'a'. So you can see you are editing the list by doing this.\n\nWhat you need to do is: Get the head Create a copy Reverse the copy Get the next item Copy it Reverse it Join it to the last And so on\n\nSince you are using your own classes not java collections classes, the easiest way is for you to make sure that reverseNode() only edits a copy of the one you pass it, and returns the copy. First make sure your Node class has a constructor that copies another Node, then do something like this:\n\nOr you might add a static method in your Node class that constructs a new node that is reversed:\n\nOr a non static method of the node class which returns a reversed copy of itself;\n\nBut you should consider this can get very ugly because your copies will still have pointers pointing into the existing list!\n\nA better technique might be to create a new empty list, and then start from the end of your original, make a copy, and add it to the start of your new list.\n\nYou can use recursion to do this but might easily run out of memory.\n\nBut rather than do this manually, you might look at the java.util packages and switch to using one of their LinkedList and list item types. These classes have already solved all the problems with doing this stuff.\n\nThen you could (if you need to keep the original list unmodified): - Make a copy of your entire list. - reverse the copy as below\n\nIf you don't care about keeping the original, then just use this method(below) on your list, no need then to make a copy.\n\nThe Collections class will choose an efficient way to reverse the list, depending on whether it is bidirectional, single directional, etc."
    },
    {
        "link": "https://geeksforgeeks.org/implementing-a-linked-list-in-java-using-class",
        "document": "Like arrays, Linked List is a linear data structure. Unlike arrays, linked list elements are not stored at the contiguous location, the elements are linked using pointers as shown below.\n\nIn this article, insertion in the list is done at the end, that is the new node is added after the last node of the given Linked List. For example, if the given Linked List is 5->10->15->20->25 and 30 is to be inserted, then the Linked List becomes 5->10->15->20->25->30. \n\nSince a Linked List is typically represented by the head pointer of it, it is required to traverse the list till the last node and then change the next to last node to the new node.\n\nTraversal: For traversal, below is a general-purpose function printList() that prints any given list by traversing the list from head node to the last.\n\nThe deletion process can be understood as follows:\n\nTo be done:\n\nGiven a ‘key’, delete the first occurrence of this key in the linked list.\n\nHow to do it:\n\n// so main() can access it // Create a new node with given data // If the Linked List is empty, // then make the new node as head // Else traverse till the last node // and insert the new_node there // Insert the new_node at last node // Method to delete a node in the LinkedList by KEY // If head node itself holds the key to be deleted // If the key is somewhere other than at head // Search for the key to be deleted, // keep track of the previous node // as it is needed to change currNode.next // If currNode does not hold key // If the key was present, it should be at currNode // Therefore the currNode shall not be null // Since the key is at currNode // CASE 3: The key is not present // If key was not present in linked list // In this case the key is ***at head*** // In this case the key is present ***in the // In this case the key is ***not present***\n\nThis deletion process can be understood as follows:\n\nTo be done: \n\nGiven a ‘position’, delete the node at this position from the linked list.\n\nHow to do it:\n\n// so main() can access it // Create a new node with given data // If the Linked List is empty, // then make the new node as head // Else traverse till the last node // and insert the new_node there // Insert the new_node at last node // Method to delete a node in the LinkedList by POSITION // If index is 0, then head node itself is to be // If the index is greater than 0 but less than the // Count for the index to be deleted, // keep track of the previous node // as it is needed to change currNode.next // Since the currNode is the required // If current position is not the index // If the position element was found, it should be // at currNode Therefore the currNode shall not be // CASE 3: The index is greater than the size of the // In this case, the currNode should be null // In this case the key is ***at head*** // In this case the key is present ***in the // In this case the key is ***not present***\n\nBelow is the complete program that applies each operation together:\n\n// so main() can access it // Create a new node with given data // If the Linked List is empty, // then make the new node as head // Else traverse till the last node // and insert the new_node there // Insert the new_node at last node // Method to delete a node in the LinkedList by KEY // If head node itself holds the key to be deleted // If the key is somewhere other than at head // Search for the key to be deleted, // keep track of the previous node // as it is needed to change currNode.next // If currNode does not hold key // If the key was present, it should be at currNode // Therefore the currNode shall not be null // Since the key is at currNode // CASE 3: The key is not present // If key was not present in linked list // Method to delete a node in the LinkedList by POSITION // If index is 0, then head node itself is to be // If the index is greater than 0 but less than the // Count for the index to be deleted, // keep track of the previous node // as it is needed to change currNode.next // Since the currNode is the required // If current position is not the index // If the position element was found, it should be // at currNode Therefore the currNode shall not be // CASE 3: The index is greater than the size of the // In this case, the currNode should be null // In this case the key is ***at head*** // In this case the key is present ***in the // In this case the key is ***not present*** // In this case the key is ***at head*** // In this case the key is present ***in the // In this case the key is ***not present***"
    },
    {
        "link": "https://geeksforgeeks.org/linked-list-in-java",
        "document": "Linked List is a part of the Collection framework present in java.util package. This class is an implementation of the LinkedList data structure which is a linear data structure where the elements are not stored in contiguous locations and every element is a separate object with a data part and address part. The elements are linked using pointers and addresses and each element is known as a node.\n\nNote: It also has a few disadvantages like the nodes cannot be accessed directly instead we need to start from the head and follow through the link to reach a node we wish to access.\n\nSince a LinkedList acts as a dynamic array and we do not have to specify the size while creating it, the size of the list automatically increases when we dynamically add and remove items. And also, the elements are not stored in a continuous fashion. Therefore, there is no need to increase the size. Internally, the LinkedList is implemented using the doubly linked list data structure.\n\nThe main difference between a normal linked list and a doubly LinkedList is that a doubly linked list contains an extra pointer, typically called the previous pointer, together with the next pointer and data which are there in the singly linked list.\n\nIn order to create a LinkedList, we need to create an object of the LinkedList class. The LinkedList class consists of various constructors that allow the possible creation of the list. The following are the constructors available in this class:\n\n\n\n1. LinkedList(): This constructor is used to create an empty linked list. If we wish to create an empty LinkedList with the name ll, then, it can be created as:\n\n2. LinkedList(Collection C): This constructor is used to create an ordered list that contains all the elements of a specified collection, as returned by the collection’s iterator. If we wish to create a LinkedList with the name ll, then, it can be created as:\n\nBelow is the implementation of the above operations:\n\nIn the above illustration, AbstractList, CopyOnWriteArrayList, and AbstractSequentialList are the classes that implement the list interface. A separate functionality is implemented in each of the mentioned classes. They are:\n• AbstractList: This class is used to implement an unmodifiable list, for which one needs to only extend this AbstractList Class and implement only the get() and the size() methods.\n• CopyOnWriteArrayList: This class implements the list interface. It is an enhanced version of ArrayList in which all the modifications(add, set, remove, etc.) are implemented by making a fresh copy of the list.\n\nIn order to add an element to an ArrayList, we can use the add() method. This method is overloaded to perform multiple operations based on different parameters. They are:\n• add(Object): This method is used to add an element at the end of the LinkedList.\n• add(int index, Object): This method is used to add an element at a specific index in the LinkedList.\n\nBelow is the implementation of the above operation:\n\nAfter adding the elements, if we wish to change the element, it can be done using the set() method. Since a LinkedList is indexed, the element which we wish to change is referenced by the index of the element. Therefore, this method takes an index and the updated element which needs to be inserted at that index.\n\nBelow is the implementation of the above operation:\n\nIn order to remove an element from a LinkedList, we can use the remove() method. This method is overloaded to perform multiple operations based on different parameters. They are:\n• remove(Object): This method is used to simply remove an object from the LinkedList. If there are multiple such objects, then the first occurrence of the object is removed.\n• remove(int index): Since a LinkedList is indexed, this method takes an integer value which simply removes the element present at that specific index in the LinkedList. After removing the element and the indices of elements are updated so do the object of LinkedList is updated giving a new List after the deletion of element/s.\n\nBelow is the implementation of the above operation:\n\nThere are multiple ways to iterate through LinkedList. The most famous ways are by using the basic for loop in combination with a get() method to get the element at a specific index and the advanced for-loop.\n\nBelow is the implementation of the above operation:\n\nOperation 4: Linked list to To Array by using toArray();\n\nThe LinkedList class in Java is a part of the Java Collections Framework and provides a linked list implementation of the List interface. It allows for the storage and retrieval of elements in a doubly-linked list data structure, where each element is linked to its predecessor and successor elements.\n\nHere is a simple example that demonstrates how to use a LinkedList in Java:\n\nAdvantages of using LinkedList in Java\n• None Dynamic size: As with Vector, the size of a LinkedList can grow or shrink dynamically, so you don’t have to worry about setting an initial size.\n• None Efficient Insertions and Deletions: LinkedList is an efficient data structure for inserting or deleting elements in the middle of the list because you only need to change the links between elements, rather than shifting all elements after the insertion or deletion point.\n• None Flexible Iteration: With a linked list, you can efficiently iterate through the list in either direction, since each element has a reference to both its predecessor and successor elements.\n\nDisadvantages of using LinkedList in Java\n• None Performance: LinkedList has a slower performance than ArrayList when it comes to accessing individual elements. This is because you need to traverse the list to reach the desired element, whereas with ArrayList, you can simply access the desired element using an index.\n• None Memory overhead: LinkedList requires more memory than ArrayList because each element requires additional memory for the links to its predecessor and successor elements.\n\nA good reference book for learning about the Java Collections Framework and LinkedList is “Java Collections” by Naftalin and Wadler. This book provides a comprehensive look at the Java collections framework, including LinkedList, and includes many examples and exercises to help you understand how to use these classes effectively."
    },
    {
        "link": "https://stackoverflow.com/questions/4066729/creating-a-linkedlist-class-from-scratch",
        "document": "If you're actually building a real system, then yes, you'd typically just use the stuff in the standard library if what you need is available there. That said, don't think of this as a pointless exercise. It's good to understand how things work, and understanding linked lists is an important step towards understanding more complex data structures, many of which don't exist in the standard libraries.\n\nThere are some differences between the way you're creating a linked list and the way the Java collections API does it. The Collections API is trying to adhere to a more complicated interface. The Collections API linked list is also a doubly linked list, while you're building a singly linked list. What you're doing is more appropriate for a class assignment.\n\nWith your class, an instance will always be a list of at least one element. With this kind of setup you'd use for when you need an empty list.\n\nThink of as being \"the rest of the list\". In fact, many similar implementations use the name \"tail\" instead of \"next\".\n\nNote that it's a object pointing to a word (\"Hello\") and a list of 2 elements. The list of 2 elements has a word (\"Stack\") and a list of 1 element. That list of 1 element has a word (\"Overflow\") and an empty list ( ). So you can treat as just another list that happens to be one element shorter.\n\nYou may want to add another constructor that just takes a String, and sets next to . This would be for creating a 1-element list.\n\nTo append, you check if is . If it is, create a new one element list and set to that.\n\nIf next isn't , then append to instead.\n\nThis is the recursive approach, which is the least amount of code. You can turn that into an iterative solution which would be more efficient in Java*, and wouldn't risk a stack overflow with very long lists, but I'm guessing that level of complexity isn't needed for your assignment.\n\n* Some languages have tail call elimination, which is an optimization that lets the language implementation convert \"tail calls\" (a call to another function as the very last step before returning) into (effectively) a \"goto\". This makes such code completely avoid using the stack, which makes it safer (you can't overflow the stack if you don't use the stack) and typically more efficient. Scheme is probably the most well known example of a language with this feature."
    },
    {
        "link": "https://stackoverflow.com/questions/14107113/implementing-methods-in-custom-linked-list-using-java",
        "document": "1.) You have to write some sort of method that returns a Node that will allow you to get a reference to the node you're looking to remove.\n\nAssuming you have a doubly-linked one, you can just change the references of the nodes around and the garbage collector will clean that node out of memory.\n\nIf it's signly-linked, you need to use a for loop that will find the node you want to remove, then, using a reference to the previous node that follows the current one, change the reference of next in prev to be curr.next.\n\n2.) If you write a find method, you can either switch the data in the nodes, or you can use similar for loops from your remove to change the references of the nodes around.\n\n3.) Write a selection sort using nodes that will sort the data. Nodes don't need to necessarily be moved around, you could probably just switch the data.\n\nSomething like that."
    },
    {
        "link": "https://codingnomads.com/data-structure-java-linked-list-implementation",
        "document": "You can take a look at a basic linked list implementation and explore some of the basic operations.\n\nFirst, look at a possible class implementation in Java:\n\nNotice how the class contains an instance variable called , which is itself of type ? This is how one object links to another object -- holds the reference to the next item in the list.\n\nBecause of this, you can now do something like this, assuming you have a class defined:\n\nThis ability to chain objects together using the variable is what defines the linked list. This is where the dynamic nature of the linked list comes from -- you can link more and more objects onto each other, effectively changing the size of the linked list as the program runs.\n\nOf course, in the real world, you don't have to manipulate and manage objects directly. You create a class, which will manage the objects. Here's what a linked list might look like implemented in Java:\n\nThe class uses the class internally, so to recreate the code from above, you can use the following:\n\nGreat, but where does the method come from? You can explore how to add, remove, and find information in a linked list.\n\nAdding data to a linked list can be done in one of three ways:\n• Add new data at the head of the list.\n• Add new data at the tail of the list.\n• Add new data somewhere in the middle of the list.\n\nYou can look at the code for each of these.\n\n1. Add Data at the Head of a List\n\nAdding data to the head of the list occurs quickly because you already know where the head of the list is. Here's how this looks in code:\n\nSo what's going on here? Conceptually, you:\n• Create a new node with the new data to be added.\n• Set the reference of the new node to be the of the list.\n• Set the of the list to be the new node.\n\nThis works even if the list is empty since in that case.\n\nGraphically, here's what those steps look like:\n\n2. Add Data at the Tail of a List\n\nOf course, if you can add to the head of a list, you can also add it to the tail. However, this is a little more involved, as you need to find the tail before you can add data to it. If the list is long, this can be time-consuming. You can take a look at the code:\n\nYou can see this is a little more involved than simply adding something at the of the list. In this case, you need to:\n• Create a new node with the new data to be added.\n• Check to see if the list is empty. a. If it is, set the new node as the sole item in the list\n• Otherwise: a. Check that is not . b. If it is, set and keep checking. c. Otherwise, set to be the new node.\n\nThe loop (described in steps 3a and 3b) demonstrates a technique called traversing or walking the list. A variable (in this case, ) is used to check each link in the list, using the references to visit each link. Traversing is a common technique used in many linked list operations and algorithms, and you'll see more of that later in this unit.\n\nGraphically, this is what a list traversal to add data to the tail looks like:\n\n3. Add Data in the Middle of a List\n\nOf course, you can add data at any point in a linked list. You just need to know where in the list to put the new node. This is normally done when trying to keep a list of items in a specific order.\n\nYou can assume you want to insert your data before another piece of data. Here's what that code might look like:\n\nAs with the method, you first check if the list is empty before doing any work. However, you can also check if the contains the data for which you are searching. If so, then you can add the new node to the head of the list.\n\nOtherwise, you have to search for the data in the list using a traversal technique called a trailing reference. With the trailing reference technique, you have to use variables to walk the list. The variable refers to the node you want to check for the data to compare. The variable refers to the previous node in the list. Graphically, this looks like this:\n\nUsing a trailing reference provides you references to two adjacent objects. You can then insert your new node between them. Once the loop is done, is either pointing to the node you want to follow your new data or has walked off the end of the list and is . In either case, you can insert between them by making point to , and point to .\n\nOf course, you can also add data after another node in the list -- that is left as part of a lab.\n\nAs with adding data, you can remove data from a list in three ways:\n• Remove data from the head of the list.\n• Remove data from the tail of the list.\n• Remove data from the middle of the list.\n\nYou can take a look at all three techniques.\n\nRemoving the head of the list, like adding a new head, is quick. Conceptually, after checking for an empty list, you assign to be . This removes the first node from the list. If you wish, you can save the data in that node first, perhaps to be used as a return value as seen in the code below:\n\nRemoving data from the tail of the list requires that you not only find the tail but also the node just before the tail. The trailing reference technique can be used here as it was earlier, as it will allow you to find both references. All you need to do is make sure there are at least two items in the list to make use of the technique:\n\n3. Remove Data from the Middle of a List\n\nRemoving data from the middle of a linked list uses the same trailing reference technique as you've seen before. If the data to be removed is found in the list, you can set the reference of the previous node to the reference of the node being deleted. If you don't find the data to remove, then you do nothing:\n\nThis method doesn't return anything, because you passed the data contained in the removed node as a parameter.\n\nFinding a piece of data in a linked list requires you to traverse the list and inspect each item, looking for the data you want to find. Conceptually, this is like flipping through the pages of a book from start to finish:\n\nYou can also traverse a list to output the items in a list, which is left as a lab exercise.\n\nImplementing a linked list in Java requires two classes -- one for the node in which data is stored and another for the list structure itself. Adding, removing, and finding data in the list is possible using a technique called traversing the list.\n\nIn general, you do not need to implement your own Linked List, but understanding its structure and how it operates will give you insight into how the linked lists work, and how you can use them when necessary."
    }
]