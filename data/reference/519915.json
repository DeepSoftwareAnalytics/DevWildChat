[
    {
        "link": "https://learn.microsoft.com/en-us/dax/dax-function-reference",
        "document": "The DAX function reference provides detailed information including syntax, parameters, return values, and examples for each of the over 250 functions used in Data Analysis Expression (DAX) formulas.\n\nNew DAX functions - These functions are new or are existing functions that have been significantly updated.\n\nAggregation functions - These functions calculate a (scalar) value such as count, sum, average, minimum, or maximum for all rows in a column or table as defined by the expression.\n\nDate and time functions - These functions in DAX are similar to date and time functions in Microsoft Excel. However, DAX functions are based on the datetime data types used by Microsoft SQL Server.\n\nFilter functions - These functions help you return specific data types, look up values in related tables, and filter by related values. Lookup functions work by using tables and relationships between them. Filtering functions let you manipulate data context to create dynamic calculations.\n\nFinancial functions - These functions are used in formulas that perform financial calculations, such as net present value and rate of return.\n\nINFO functions - These functions return metadata about your semantic model, such as the tables, columns, relationships, and calculation DAX formulas. They can help you understand and document the model. They are based on the library of Dynamic Management Views (DMVs) in Analysis Services, which have been modified to work as DAX functions.\n\nInformation functions - These functions look at a table or column provided as an argument to another function and returns whether the value matches the expected type. For example, the ISERROR function returns if the value you reference contains an error.\n\nLogical functions - These functions return information about values in an expression. For example, the function lets you know whether an expression that you are evaluating returns a value.\n\nMath and Trig functions - Mathematical functions in DAX are similar to Excel's mathematical and trigonometric functions. However, there are some differences in the numeric data types used by DAX functions.\n\nOther functions - These functions perform unique actions that cannot be defined by any of the categories most other functions belong to.\n\nParent and Child functions - These functions help users manage data that is presented as a parent/child hierarchy in their data models.\n\nRelationship functions - These functions are for managing and utilizing relationships between tables. For example, you can specify a particular relationship to be used in a calculation.\n\nStatistical functions - These functions calculate values related to statistical distributions and probability, such as standard deviation and number of permutations.\n\nText functions - With these functions, you can return part of a string, search for text within a string, or concatenate string values. Additional functions are for controlling the formats for dates, times, and numbers.\n\nTime intelligence functions - These functions help you create calculations that use built-in knowledge about calendars and dates. By using time and date ranges in combination with aggregations or calculations, you can build meaningful comparisons across comparable time periods for sales, inventory, and so on."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dax/calculate-function-dax",
        "document": "The expression used as the first parameter is essentially the same as a measure.\n\nWhen there are multiple filters, they can be evaluated by using the AND ( ) logical operator, meaning all conditions must be , or by the OR ( ) logical operator, meaning either condition can be true.\n\nA Boolean expression filter is an expression that evaluates to or . There are several rules that they must abide by:\n• They can reference columns from a single table.\n• They cannot use a nested CALCULATE function.\n\nBeginning with the September 2021 release of Power BI Desktop, the following also apply:\n• They cannot use functions that scan or return a table unless they are passed as arguments to aggregation functions.\n• They can contain an aggregation function that returns a scalar value. For example, Total sales on the last selected date = CALCULATE ( SUM ( Sales[Sales Amount] ), 'Sales'[OrderDateKey] = MAX ( 'Sales'[OrderDateKey] ) )\n\nA table expression filter applies a table object as a filter. It could be a reference to a model table, but more likely it's a function that returns a table object. You can use the FILTER function to apply complex filter conditions, including those that cannot be defined by a Boolean filter expression.\n\nFilter modifier functions allow you to do more than simply add filters. They provide you with additional control when modifying filter context.\n\n1 The ALL function and its variants behave as both filter modifiers and as functions that return table objects. If the REMOVEFILTERS function is supported by your tool, it's better to use it to remove filters.\n\nThe value that is the result of the expression.\n• None When filter expressions are provided, the CALCULATE function modifies the filter context to evaluate the expression. For each filter expression, there are two possible standard outcomes when the filter expression is not wrapped in the KEEPFILTERS function:\n• If the columns (or tables) aren't in the filter context, then new filters will be added to the filter context to evaluate the expression.\n• If the columns (or tables) are already in the filter context, the existing filters will be overwritten by the new filters to evaluate the CALCULATE expression.\n• None The CALCULATE function used without filters achieves a specific requirement. It transitions row context to filter context. It's required when an expression (not a model measure) that summarizes model data needs to be evaluated in row context. This scenario can happen in a calculated column formula or when an expression in an iterator function is evaluated. Note that when a model measure is used in row context, context transition is automatic.\n• None This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules.\n\nThe following Sales table measure definition produces a revenue result, but only for products that have the color blue.\n\nExamples in this article can be used with the sample Adventure Works DW 2020 Power BI Desktop model. To get the model, see DAX sample model.\n\nThe CALCULATE function evaluates the sum of the Sales table Sales Amount column in a modified filter context. A new filter is added to the Product table Color column—or, the filter overwrites any filter that's already applied to the column.\n\nThe following Sales table measure definition produces a ratio of sales over sales for all sales channels.\n\nThe DIVIDE function divides an expression that sums of the Sales table Sales Amount column value (in the filter context) by the same expression in a modified filter context. It's the CALCULATE function that modifies the filter context by using the REMOVEFILTERS function, which is a filter modifier function. It removes filters from the Sales Order table Channel column.\n\nThe following Customer table calculated column definition classifies customers into a loyalty class. It's a very simple scenario: When the revenue produced by the customer is less than $2500, they're classified as Low; otherwise they're High.\n\nIn this example, row context is converted to the filter context. It's known as context transition. The ALLEXCEPT function removes filters from all Customer table columns except the CustomerKey column."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dax/dax-overview",
        "document": "Data Analysis Expressions (DAX) is a formula expression language used in Analysis Services, Power BI, and Power Pivot in Excel. DAX formulas include functions, operators, and values to perform advanced calculations and queries on data in related tables and columns in tabular data models.\n\nThis article provides only a basic introduction to the most important concepts in DAX. It describes DAX as it applies to all the products that use it. Some functionality may not apply to certain products or use cases. Refer to your product's documentation describing its particular implementation of DAX.\n\nDAX formulas are used in measures, calculated columns, calculated tables, and row-level security.\n\nMeasures are dynamic calculation formulas where the results change depending on context. Measures are used in reporting that support combining and filtering model data by using multiple attributes such as a Power BI report or Excel PivotTable or PivotChart. Measures are created by using the DAX formula bar in the model designer.\n\nA formula in a measure can use standard aggregation functions automatically created by using the Autosum feature, such as COUNT or SUM, or you can define your own formula by using the DAX formula bar. Named measures can be passed as an argument to other measures.\n\nWhen you define a formula for a measure in the formula bar, a Tooltip feature shows a preview of what the results would be for the total in the current context, but otherwise the results are not immediately output anywhere. The reason you cannot see the (filtered) results of the calculation immediately is because the result of a measure cannot be determined without context. To evaluate a measure requires a reporting client application that can provide the context needed to retrieve the data relevant to each cell and then evaluate the expression for each cell. That client might be an Excel PivotTable or PivotChart, a Power BI report, or a table expression in a DAX query in SQL Server Management Studio (SSMS).\n\nRegardless of the client, a separate query is run for each cell in the results. That is to say, each combination of row and column headers in a PivotTable, or each selection of slicers and filters in a Power BI report, generates a different subset of data over which the measure is calculated. For example, using this very simple measure formula:\n\nWhen a user places the TotalSales measure in a report, and then places the Product Category column from a Product table into Filters, the sum of Sales Amount is calculated and displayed for each product category.\n\nUnlike calculated columns, the syntax for a measure includes the measure's name preceding the formula. In the example just provided, the name Total Sales appears preceding the formula. After you've created a measure, the name and its definition appear in the reporting client application Fields list, and depending on perspectives and roles is available to all users of the model.\n\nTo learn more, see: Measures in Power BI Desktop Measures in Analysis Services Measures in Power Pivot\n\nA calculated column is a column that you add to an existing table (in the model designer) and then create a DAX formula that defines the column's values. When a calculated column contains a valid DAX formula, values are calculated for each row as soon as the formula is entered. Values are then stored in the in-memory data model. For example, in a Date table, when the formula is entered into the formula bar:\n\nA value for each row in the table is calculated by taking values from the Calendar Year column (in the same Date table), adding a space and the capital letter Q, and then adding the values from the Calendar Quarter column (in the same Date table). The result for each row in the calculated column is calculated immediately and appears, for example, as 2017 Q1. Column values are only recalculated if the table or any related table is processed (refresh) or the model is unloaded from memory and then reloaded, like when closing and reopening a Power BI Desktop file.\n\nTo learn more, see: Calculated columns in Power BI Desktop Calculated columns in Analysis Services Calculated Columns in Power Pivot.\n\nA calculated table is a computed object, based on a formula expression, derived from all or part of other tables in the same model. Instead of querying and loading values into your new table's columns from a data source, a DAX formula defines the table's values.\n\nCalculated tables can be helpful in a role-playing dimension. An example is the Date table, as OrderDate, ShipDate, or DueDate, depending on the foreign key relationship. By creating a calculated table for ShipDate explicitly, you get a standalone table that is available for queries, as fully operable as any other table. Calculated tables are also useful when configuring a filtered rowset, or a subset or superset of columns from other existing tables. This allows you to keep the original table intact while creating variations of that table to support specific scenarios.\n\nCalculated tables support relationships with other tables. The columns in your calculated table have data types, formatting, and can belong to a data category. Calculated tables can be named, and surfaced or hidden just like any other table. Calculated tables are re-calculated if any of the tables it pulls data from are refreshed or updated.\n\nTo learn more, see: Calculated tables in Power BI Desktop Calculated tables in Analysis Services.\n\nWith row-level security, a DAX formula must evaluate to a Boolean / condition, defining which rows can be returned by the results of a query by members of a particular role. For example, for members of the Sales role, the Customers table with the following DAX formula:\n\nMembers of the Sales role will only be able to view data for customers in the USA, and aggregates, such as SUM are returned only for customers in the USA. Row-level security is not available in Power Pivot in Excel.\n\nWhen defining row-level secuirty by using DAX formula, you are creating an allowed row set. This does not deny access to other rows; rather, they are simply not returned as part of the allowed row set. Other roles can allow access to the rows excluded by the DAX formula. If a user is a member of another role, and that role's row-level security allows access to that particular row set, the user can view data for that row.\n\nRow-level security formulas apply to the specified rows as well as related rows. When a table has multiple relationships, filters apply security for the relationship that is active. Row-level security formulas will be intersected with other formulas defined for related tables.\n\nTo learn more, see: Row-level security (RLS) with Power BI Roles in Analysis Services\n\nDAX queries can be created and run in SQL Server Management Studio (SSMS) and open-source tools like DAX Studio (daxstudio.org). Unlike DAX calculation formulas, which can only be created in tabular data models, DAX queries can also be run against Analysis Services Multidimensional models. DAX queries are often easier to write and more efficient than Multidimensional Data Expressions (MDX) queries.\n\nA DAX query is a statement, similar to a SELECT statement in T-SQL. The most basic type of DAX query is an evaluate statement. For example,\n\nReturns in Results a table listing only those products with a SafetyStockLevel less than 200, in ascending order by EnglishProductName.\n\nYou can create measures as part of the query. Measures exist only for the duration of the query. To learn more, see DAX queries.\n\nDAX formulas are essential for creating calculations in calculated columns and measures, and securing your data by using row-level security. To create formulas for calculated columns and measures, use the formula bar along the top of the model designer window or the DAX Editor. To create formulas for row-level security, use the Role Manager or Manage roles dialog box. Information in this section is meant to get you started with understanding the basics of DAX formulas.\n\nDAX formulas can be very simple or quite complex. The following table shows some examples of simple formulas that could be used in a calculated column.\n\nWhether the formula you create is simple or complex, you can use the following steps when building a formula:\n• None Each formula must begin with an equal sign (=).\n• None You can either type or select a function name, or type an expression.\n• None Begin to type the first few letters of the function or name you want, and AutoComplete displays a list of available functions, tables, and columns. Press TAB to add an item from the AutoComplete list to the formula. You can also click the Fx button to display a list of available functions. To select a function from the dropdown list, use the arrow keys to highlight the item, and click OK to add the function to the formula.\n• None Supply the arguments to the function by selecting them from a dropdown list of possible tables and columns, or by typing in values.\n• None Check for syntax errors: ensure that all parentheses are closed and columns, tables and values are referenced correctly.\n\nIn this example, let's look at a formula in a measure named Days in Current Quarter:\n\nThis measure is used to create a comparison ratio between an incomplete period and the previous period. The formula must take into account the proportion of the period that has elapsed, and compare it to the same proportion in the previous period. In this case, [Days Current Quarter to Date]/[Days in Current Quarter] gives the proportion elapsed in the current period.\n\nThis formula contains the following elements:\n\nAutoComplete helps you enter a valid formula syntax by providing you with options for each element in the formula.\n• None You can use formula AutoComplete in the middle of an existing formula with nested functions. The text immediately before the insertion point is used to display values in the drop-down list, and all of the text after the insertion point remains unchanged.\n• None AutoComplete does not add the closing parenthesis of functions or automatically match parentheses. You must make sure that each function is syntactically correct or you cannot save or use the formula.\n\nYou can nest functions, meaning that you use the results from one function as an argument of another function. You can nest up to 64 levels of functions in calculated columns. However, nesting can make it difficult to create or troubleshoot formulas. Many functions are designed to be used solely as nested functions. These functions return a table, which cannot be directly saved as a result; it must be provided as input to a table function. For example, the functions SUMX, AVERAGEX, and MINX all require a table as the first argument.\n\nA function is a named formula within an expression. Most functions have required and optional arguments, also known as parameters, as input. When the function is executed, a value is returned. DAX includes functions you can use to perform calculations using dates and times, create conditional values, work with strings, perform lookups based on relationships, and the ability to iterate over a table to perform recursive calculations. If you are familiar with Excel formulas, many of these functions will appear very similar; however, DAX formulas are different in the following important ways:\n• None A DAX function always references a complete column or a table. If you want to use only particular values from a table or column, you can add filters to the formula.\n• None If you need to customize calculations on a row-by-row basis, DAX provides functions that let you use the current row value or a related value as a kind of parameter, to perform calculations that vary by context. To understand how these functions work, see Context in this article.\n• None DAX includes many functions that return a table, rather than a value. The table is not displayed in a reporting client, but is used to provide input to other functions. For example, you can retrieve a table and then count the distinct values in it, or calculate dynamic sums across filtered tables or columns.\n• None DAX functions include a variety of time intelligence functions. These functions let you define or select date ranges, and perform dynamic calculations based on these dates or range. For example, you can compare sums across parallel periods.\n\nAggregation functions calculate a (scalar) value such as count, sum, average, minimum, or maximum for all rows in a column or table as defined by the expression. To learn more, see Aggregation functions.\n\nThe date and time functions in DAX are similar to date and time functions in Microsoft Excel. However, DAX functions are based on a datetime data type starting March 1, 1900. To learn more, see Date and time functions.\n\nThe filter functions in DAX return specific data types, look up values in related tales, and filter by related values. The lookup functions work by using tables and relationships, like a database. The filtering functions let you manipulate data context to create dynamic calculations. To learn more, see Filter functions.\n\nThe financial functions in DAX are used in formulas that perform financial calculations, such as net present value and rate of return. These functions are similar to financial functions used in Microsoft Excel. To learn more, see Financial functions.\n\nAn information function looks at the cell or row that is provided as an argument and tells you whether the value matches the expected type. For example, the ISERROR function returns if the value that you reference contains an error. To learn more, see Information functions.\n\nLogical functions act upon an expression to return information about the values in the expression. For example, the function lets you know whether an expression that you are evaluating returns a value. To learn more, see Logical functions.\n\nThe mathematical functions in DAX are very similar to the Excel mathematical and trigonometric functions. Some minor differences exist in the numeric data types used by DAX functions. To learn more, see Math and trig functions.\n\nThese functions perform unique actions that cannot be defined by any of the categories most other functions belong to. To learn more, see Other functions.\n\nRelationship functions in DAX allow you to return values from another related table, specify a particular relationship to use in an expression, and specify cross filtering direction. To learn more, see Relationship functions.\n\nStatistical functions calculate values related to statistical distributions and probability, such as standard deviation and number of permutations. To learn more, see Statistical functions.\n\nText functions in DAX are very similar to their counterparts in Excel. You can return part of a string, search for text within a string, or concatenate string values. DAX also provides functions for controlling the formats for dates, times, and numbers. To learn more, see Text functions.\n\nThe time intelligence functions provided in DAX let you create calculations that use built-in knowledge about calendars and dates. By using time and date ranges in combination with aggregations or calculations, you can build meaningful comparisons across comparable time periods for sales, inventory, and so on. To learn more, see Time intelligence functions (DAX).\n\nThese functions return a table or manipulate existing tables. For example, by using ADDCOLUMNS you can add calculated columns to a specified table, or you can return a summary table over a set of groups with the SUMMARIZECOLUMNS function. To learn more, see Table manipulation functions.\n\nYou can create variables within an expression by using VAR. VAR is technically not a function, it's a keyword to store the result of an expression as a named variable. That variable can then be passed as an argument to other measure expressions. For example:\n\nIn this example, TotalQty can be passed as a named variable to other expressions. Variables can be of any scalar data type, including tables. Using variables in your DAX formulas can be incredibly powerful.\n\nYou can import data into a model from many different data sources that might support different data types. When you import data into a model, the data is converted to one of the tabular model data types. When the model data is used in a calculation, the data is then converted to a DAX data type for the duration and output of the calculation. When you create a DAX formula, the terms used in the formula will automatically determine the value data type returned.\n\nTabular data models also include the Table data type as the input or output to many DAX functions. For example, the FILTER function takes a table as input and outputs another table that contains only the rows that meet the filter conditions. By combining table functions with aggregation functions, you can perform complex calculations over dynamically defined data sets.\n\nWhile data types are typically automatically set, it is important to understand data types and how they apply, in-particular, to DAX formulas. Errors in formulas or unexpected results, for example, are often caused by using a particular operator that cannot be used with a data type specified in an argument. For example, the formula, , returns a string result of 12. The formula, , however, returns an integer result of 3.\n\nContext is an important concept to understand when creating DAX formulas. Context is what enables you to perform dynamic analysis, as the results of a formula change to reflect the current row or cell selection and also any related data. Understanding context and using context effectively are critical for building high-performing, dynamic analyses, and for troubleshooting problems in formulas.\n\nFormulas in tabular models can be evaluated in a different context, depending on other design elements:\n• Relationships specified by using special functions within a formula\n\nThere are different types of context: row context, query context, and filter context.\n\nRow context can be thought of as \"the current row\". If you create a formula in a calculated column, the row context for that formula includes the values from all columns in the current row. If the table is related to another table, the content also includes all the values from the other table that are related to the current row.\n\nFor example, suppose you create a calculated column, , that adds together values from two columns, Freight and Tax, from the same table. This formula automatically gets only the values from the current row in the specified columns.\n\nRow context also follows any relationships that have been defined between tables, including relationships defined within a calculated column by using DAX formulas, to determine which rows in related tables are associated with the current row.\n\nFor example, the following formula uses the RELATED function to fetch a tax value from a related table, based on the region that the order was shipped to. The tax value is determined by using the value for region in the current table, looking up the region in the related table, and then getting the tax rate for that region from the related table.\n\nThis formula gets the tax rate for the current region from the Region table and adds it to the value of the Freight column. In DAX formulas, you do not need to know or specify the specific relationship that connects the tables.\n\nDAX includes functions that iterate calculations over a table. These functions can have multiple current rows, each with its own row context. In essence, these functions let you create formulas that perform operations recursively over an inner and outer loop.\n\nFor example, suppose your model contains a Products table and a Sales table. Users might want to go through the entire sales table, which is full of transactions involving multiple products, and find the largest quantity ordered for each product in any one transaction.\n\nWith DAX you can build a single formula that returns the correct value, and the results are automatically updated any time a user adds data to the tables.\n\nFor a detailed example of this formula, see EARLIER.\n\nTo summarize, the EARLIER function stores the row context from the operation that preceded the current operation. At all times, the function stores in memory two sets of context: one set of context represents the current row for the inner loop of the formula, and another set of context represents the current row for the outer loop of the formula. DAX automatically feeds values between the two loops so that you can create complex aggregates.\n\nQuery context refers to the subset of data that is implicitly retrieved for a formula. For example, when a user places a measure or field into a report, the engine examines row and column headers, slicers, and report filters to determine the context. The necessary queries are then run against model data to get the correct subset of data, make the calculations defined by the formula, and then populate values in the report.\n\nBecause context changes depending on where you place the formula, the results of the formula can also change. For example, suppose you create a formula that sums the values in the Profit column of the Sales table: . If you use this formula in a calculated column within the Sales table, the results for the formula will be the same for the entire table, because the query context for the formula is always the entire data set of the Sales table. Results will have profit for all regions, all products, all years, and so on.\n\nHowever, users typically don't want to see the same result hundreds of times, but instead want to get the profit for a particular year, a particular country, a particular product, or some combination of these, and then get a grand total.\n\nIn a report, context is changed by filtering, adding or removing fields, and using slicers. For each change, the query context in which the measure is evaluated. Therefore, the same formula, used in a measure, is evaluated in a different query context for each cell.\n\nFilter context is the set of values allowed in each column, or in the values retrieved from a related table. Filters can be applied to the column in the designer, or in the presentation layer (reports and PivotTables). Filters can also be defined explicitly by filter expressions within the formula.\n\nFilter context is added when you specify filter constraints on the set of values allowed in a column or table, by using arguments to a formula. Filter context applies on top of other contexts, such as row context or query context.\n\nIn tabular models, there are many ways to create filter context. Within the context of clients that can consume the model, such as Power BI reports, users can create filters on the fly by adding slicers or report filters on the row and column headings. You can also specify filter expressions directly within the formula, to specify related values, to filter tables that are used as inputs, or to dynamically get context for the values that are used in calculations. You can also completely clear or selectively clear the filters on particular columns. This is very useful when creating formulas that calculate grand totals.\n\nTo learn more about how to create filters within formulas, see the FILTER Function (DAX). For an example of how filters can be cleared to create grand totals, see the ALL Function (DAX).\n\nFor examples of how to selectively clear and apply filters within formulas, see ALLEXCEPT.\n\nWhen you create a DAX formula, the formula is first tested for valid syntax, and then tested to make sure the names of the columns and tables included in the formula can be found in the current context. If any column or table specified by the formula cannot be found, an error is returned.\n\nContext during validation (and recalculation operations) is determined as described in the preceding sections, by using the available tables in the model, any relationships between the tables, and any filters that have been applied.\n\nFor example, if you have just imported some data into a new table and it is not related to any other tables (and you have not applied any filters), the current context is the entire set of columns in the table. If the table is linked by relationships to other tables, the current context includes the related tables. If you add a column from the table to a report that has Slicers and maybe some report filters, the context for the formula is the subset of data in each cell of the report.\n\nContext is a powerful concept that can also make it difficult to troubleshoot formulas. We recommend that you begin with simple formulas and relationships to see how context works. The following section provides some examples of how formulas use different types of context to dynamically return results.\n\nThe DAX language uses four different types of calculation operators in formulas:\n• Comparison operators to compare values and return a logical `FALSE` value.\n• Text concatenation operators to join two or more text strings.\n• Logical operators that combine two or more expressions to return a single result.\n\nFor detailed information about operators used in DAX formulas, see DAX operators.\n\nTables in tabular data models look like Excel tables, but are different in the way they work with data and with formulas:\n• Formulas work only with tables and columns, not with individual cells, range references, or arrays.\n• Formulas can use relationships to get values from related tables. The values that are retrieved are always related to the current row value.\n• You cannot have irregular or \"ragged\" data like you can in an Excel worksheet. Each row in a table must contain the same number of columns. However, you can have empty values in some columns. Excel data tables and tabular model data tables are not interchangeable.\n• Because a data type is set for each column, each value in that column must be of the same type.\n\nReferring to tables and columns in formulas\n\nYou can refer to any table and column by using its name. For example, the following formula illustrates how to refer to columns from two tables by using the fully qualified name:\n\nWhen a formula is evaluated, the model designer first checks for general syntax, and then checks the names of columns and tables that you provide against possible columns and tables in the current context. If the name is ambiguous or if the column or table cannot be found, you will get an error on your formula (an #ERROR string instead of a data value in cells where the error occurs). To learn more about naming requirements for tables, columns, and other objects, see Naming Requirements in DAX syntax.\n\nBy creating relationships between tables, you gain the ability for related values in other tables to be used in calculations. For example, you can use a calculated column to determine all the shipping records related to the current reseller, and then sum the shipping costs for each. In many cases, however, a relationship might not be necessary. You can use the LOOKUPVALUE function in a formula to return the value in result_columnName for the row that meets criteria specified in the search_column and search_value arguments.\n\nMany DAX functions require that a relationship exist between the tables, or among multiple tables, in order to locate the columns that you have referenced and return results that make sense. Other functions will attempt to identify the relationship; however, for best results you should always create a relationship where possible. Tabular data models support multiple relationships among tables. To avoid confusion or incorrect results, only one relationship at a time is designated as the active relationship, but you can change the active relationship as necessary to traverse different connections in the data in calculations. USERELATIONSHIP function can be used to specify one or more relationships to be used in a specific calculation.\n\nIt's important to observe these formula design rules when using relationships:\n• None When tables are connected by a relationship, you must ensure the two columns used as keys have values that match. Referential integrity is not enforced, therefore it is possible to have non-matching values in a key column and still create a relationship. If this happens, you should be aware that blank values or non-matching values might affect the results of formulas.\n• None When you link tables in your model by using relationships, you enlarge the scope, or context, in which your formulas are evaluated. Changes in context resulting from the addition of new tables, new relationships, or from changes in the active relationship can cause your results to change in ways that you might not anticipate. To learn more, see Context in this article.\n\nProcess and recalculation are two separate but related operations. You should thoroughly understand these concepts when designing a model that contains complex formulas, large amounts of data, or data that is obtained from external data sources.\n\nProcess (refresh) is updating the data in a model with new data from an external data source.\n\nRecalculation is the process of updating the results of formulas to reflect any changes to the formulas themselves and to reflect changes in the underlying data. Recalculation can affect performance in the following ways:\n• None The values in a calculated column are computed and stored in the model. To update the values in the calculated column, you must process the model using one of three processing commands – Process Full, Process Data, or Process Recalc. The result of the formula must always be recalculated for the entire column, whenever you change the formula.\n• None The values calculated by measures are dynamically evaluated whenever a user adds the measure to a PivotTable or open a report; as the user modifies the context, values returned by the measure change. The results of the measure always reflect the latest in the in-memory cache.\n\nProcessing and recalculation have no effect on row-level security formulas unless the result of a recalculation returns a different value, thus making the row queryable or not queryable by role members.\n\nDAX is constantly being improved. New and updated functions are released with the next available update, which is usually monthly. Services are updated first, followed by installed applications like Power BI Desktop, Excel, SQL Server Management Studio (SSMS), and Analysis Services project extension for Visual Studio (SSDT). SQL Server Analysis Services is updated with the next cumulative update. New functions are first announced and described in the DAX function reference coinciding with Power BI Desktop updates.\n\nNot all functions are supported in earlier versions of SQL Server Analysis Services and Excel.\n\nIf you get an error when defining a formula, the formula might contain either a syntactic error, semantic error, or calculation error.\n\nSyntactic errors are the easiest to resolve. They typically involve a missing parenthesis or comma.\n\nThe other type of error occurs when the syntax is correct, but the value or a column referenced does not make sense in the context of the formula. Such semantic and calculation errors might be caused by any of the following problems:\n• The formula refers to a non-existing column, table, or function.\n• The formula appears to be correct, but when the data engine fetches the data, it finds a type mismatch and raises an error.\n• The formula passes an incorrect number or type of arguments to a function.\n• The formula refers to a different column that has an error, and therefore its values are invalid.\n• The formula refers to a column that has not been processed, meaning it has metadata but no actual data to use for calculations.\n\nIn the first four cases, DAX flags the entire column that contains the invalid formula. In the last case, DAX grays out the column to indicate that the column is in an unprocessed state.\n\nPower BI Desktop is a free data modeling and reporting application. The model designer includes a DAX editor for creating DAX calculation formulas.\n\nThe Power Pivot in Excel models designer includes a DAX editor for creating DAX calculation formulas.\n\nVisual Studio with Analysis Services projects extension (VSIX) is used to create Analysis Services model projects. Tabular model designer, installed with the projects extension includes a DAX editor.\n\nSQL Server Management Studio (SSMS) is an essential tool for working with Analysis Services. SSMS includes a DAX query editor for querying both tabular and multidimensional models.\n\nDAX Studio is an open-source client tool for creating and running DAX queries against Analysis Services, Power BI Desktop, and Power Pivot in Excel models.\n\nTabular Editor is an open-source tool that provides an intuitive, hierarchical view of every object in tabular model metadata. Tabular Editor includes a DAX Editor with syntax highlighting, which provides an easy way to edit measures, calculated column, and calculated table expressions.\n\nWhen learning DAX, it's best to use the application you'll be using to create your data models. Analysis Services, Power BI Desktop, and Power Pivot in Excel all have articles and tutorials that include lessons on creating measures, calculated columns, and row-filters by using DAX. Here are some additional resources:\n\nThe Definitive Guide to DAX by Alberto Ferrari and Marco Russo (Microsoft Press). Now in its second edition, this extensive guide provides basics to innovative high-performance techniques for beginning data modelers and BI professionals.\n\nDAX has a vibrant community always willing to share their expertise. Microsoft Power BI Community has a special discussion forum just for DAX, DAX Commands and Tips."
    },
    {
        "link": "https://learn.microsoft.com/en-us/power-bi/transform-model/desktop-quickstart-learn-dax-basics",
        "document": "Users who are new to Power BI Desktop can use this article as a quick and easy introduction on how you can use Data Analysis Expressions (DAX) to solve many basic calculations and data analysis problems. We’ll go over some conceptual information, a series of tasks you can complete, and a knowledge check to test what you’ve learned. After completing this article, you should have a good understanding of the most important fundamental concepts in DAX.\n\nDAX is a collection of functions, operators, and constants that can be used in a formula, or expression, to calculate and return one or more values. DAX helps you create new information from data already in your model.\n\nWhy is DAX so important?\n\nIt’s easy to create a new Power BI Desktop file and import some data into it. You can even create reports that show valuable insights without using any DAX formulas at all. But, what if you need to analyze growth percentage across product categories and for different date ranges? Or, you need to calculate year-over-year growth compared to market trends? DAX formulas provide this capability and many other important capabilities as well. Learning how to create effective DAX formulas will help you get the most out of your data. When you get the information you need, you can begin to solve real business problems that affect your bottom line.\n\nYou might already be familiar with creating formulas in Microsoft Excel, and that knowledge will be helpful in understanding DAX. But even if you have no experience with Excel formulas, the concepts described here will help you get started creating DAX formulas and solving real-world BI problems right away.\n\nWe’ll focus on understanding DAX formulas used in calculations, more specifically, in measures and calculated columns. You should already be familiar with using Power BI Desktop to import data and add fields to a report, and you should also be familiar with fundamental concepts of Measures and Calculated columns.\n\nThe best way to learn DAX is to create some basic formulas, use them with actual data, and see the results for yourself. The examples and tasks here use the Contoso Sales Sample for Power BI Desktop file. This sample file is the same one used in the Tutorial: Create your own measures in Power BI Desktop article.\n\nWe'll frame our understanding of DAX around three fundamental concepts: Syntax, Functions, and Context. There are other important concepts in DAX, but understanding these three concepts will provide the best foundation on which to build your DAX skills.\n\nBefore you create your own formulas, let’s take a look at DAX formula syntax. Syntax includes the various elements that make up a formula, or more simply, how the formula is written. For example, here's a simple DAX formula for a measure:\n\nThis formula includes the following syntax elements:\n\nB. The equals sign operator (=), which indicates the beginning of the formula. When calculated, it will return a result.\n\nC. The DAX function SUM, which adds up all of the numbers in the Sales[SalesAmount] column. You’ll learn more about functions later.\n\nD. Parenthesis (), which surround an expression that contains one or more arguments. Most functions require at least one argument. An argument passes a value to a function.\n\nF. The referenced column, [SalesAmount], in the Sales table. With this argument, the SUM function knows on which column to aggregate a SUM.\n\nWhen trying to understand a DAX formula, it's often helpful to break down each of the elements into a language you think and speak every day. For example, you can read this formula as:\n\nWhen added to a report, this measure calculates and returns values by summing up sales amounts for each of the other fields we include, for example, Cell Phones in the USA.\n\nYou might be thinking, \"Isn’t this measure doing the same thing as if I were to just add the SalesAmount field to my report?\" Well, yes. But, there’s a good reason to create our own measure that sums up values from the SalesAmount field: We can use it as an argument in other formulas. This solution might seem a little confusing now, but as your DAX formula skills grow, knowing this measure will make your formulas and your model more efficient. In fact, you’ll see the Total Sales measure showing up as an argument in other formulas later on.\n\nLet’s go over a few more things about this formula. In particular, we introduced a function, SUM. Functions are pre-written formulas that make it easier to do complex calculations and manipulations with numbers, dates, time, text, and more. You'll learn more about functions later.\n\nYou also see that the column name [SalesAmount] was preceded by the Sales table in which the column belongs. This name is known as a fully qualified column name in that it includes the column name preceded by the table name. Columns referenced in the same table don't require the table name be included in the formula, which can make long formulas that reference many columns shorter and easier to read. However, it's a good practice to include the table name in your measure formulas, even when in the same table.\n\nIt’s important your formulas have the correct syntax. In most cases, if the syntax isn't correct, a syntax error is returned. In other cases, the syntax might be correct, but the values returned might not be what you're expecting. The DAX editor in Power BI Desktop includes a suggestions feature, used to create syntactically correct formulas by helping you select the correct elements.\n\nLet’s create an example formula. This task will help you further understand formula syntax and how the suggestions feature in the formula bar can help you.\n• None In Report view, in the field list, right-click the Sales table, and then select New Measure.\n• None In the formula bar, replace Measure by entering a new measure name, Previous Quarter Sales.\n• None After the equals sign, type the first few letters CAL, and then double-click the function you want to use. In this formula, you want to use the CALCULATE function. You’ll use the CALCULATE function to filter the amounts we want to sum by an argument we pass to the CALCULATE function. This type of function is referred to as nesting functions. The CALCULATE function has at least two arguments. The first is the expression to be evaluated, and the second is a filter.\n• None After the opening parenthesis ( for the CALCULATE function, type SUM followed by another opening parenthesis (. Next, we'll pass an argument to the SUM function.\n• None Begin typing Sal, and then select Sales[SalesAmount], followed by a closing parenthesis ). This step creates the first expression argument for our CALCULATE function.\n• None Type a comma (,) followed by a space to specify the first filter, and then type PREVIOUSQUARTER. You’ll use the PREVIOUSQUARTER time intelligence function to filter SUM results by the previous quarter.\n• None After the opening parenthesis ( for the PREVIOUSQUARTER function, type Calendar[DateKey]. The PREVIOUSQUARTER function has one argument, a column containing a contiguous range of dates. In our case, that's the DateKey column in the Calendar table.\n• None Close both the arguments being passed to the PREVIOUSQUARTER function and the CALCULATE function by typing two closing parenthesis )). Your formula should now look like this:\n• None Select the checkmark in the formula bar or press Enter to validate the formula and add it to the Sales table.\n\nYou did it! You just created a complex measure by using DAX. What this formula will do is calculate the total sales for the previous quarter, depending on the filters applied in a report. For example, we can put SalesAmount and our new Previous Quarter Sales measure from the Sales table into a Clustered column chart. Then from the Calendar table add Year as a slicer and select 2011. Then after, add QuarterOfYear as another Slicer and select 4, and we get a chart like this:\n\nKeep in mind, the sample model contains only a small amount of sales data from 1/1/2011 to 1/19/2013. If you select a year or quarter where SalesAmount can't be summed, or your new measure can't calculate sales data for the current or previous quarter, no data for that period is shown. For example, if you select 2011 for Year and 1 for QuarterOfYear, no data is shown for Previous Quarter Sales because there's no data for the fourth quarter of 2010.\n\nYou were introduced to several important aspects of DAX formulas:\n• None This formula included two functions. PREVIOUSQUARTER, a time intelligence function, is nested as an argument passed to CALCULATE, a filter function. DAX formulas can contain up to 64 nested functions. It’s unlikely a formula would ever contain so many nested functions. In fact, such a formula would be difficult to create and debug, and it probably wouldn’t be fast either.\n• None In this formula, you also used filters. Filters narrow down what will be calculated. In this case, you selected one filter as an argument, which is actually the result of another function. You'll learn more about filters later.\n• None You used the CALCULATE function. This function is one of the most powerful functions in DAX. As you author models and create more complex formulas, you'll likely use this function many times. Although further discussion about the CALCULATE function is outside the scope of this article, as your knowledge of DAX grows, pay special attention to it.\n• None What does this button on the formula bar do?\n• None What always surrounds a column name in a DAX formula?\n\nAnswers are provided at the end of this article.\n\nFunctions are predefined formulas that perform calculations by using specific values, called arguments, in a particular order or structure. Arguments can be other functions, another formula, expression, column references, numbers, text, logical values such as TRUE or FALSE, or constants.\n\nDAX includes the following categories of functions: Date and Time, Time Intelligence, Information, Logical, Mathematical, Statistical, Text, Parent/Child, and Other functions. If you’re familiar with functions in Excel formulas, many of the functions in DAX will appear similar to you; however, DAX functions are unique in the following ways:\n• None A DAX function always references a complete column or a table. If you want to use only particular values from a table or column, you can add filters to the formula.\n• None If you need to customize calculations on a row-by-row basis, DAX provides functions that let you use the current row value or a related value as a kind of argument to perform calculations based on the context. You'll learn more about context later.\n• None DAX includes many functions that return a table rather than a value. The table isn't displayed, but is used to provide input to other functions. For example, you can retrieve a table and then count the distinct values in it, or calculate dynamic sums across filtered tables or columns.\n• None DAX includes various time intelligence functions. These functions let you define or select date ranges, and perform dynamic calculations based on them. For example, you can compare sums across parallel periods.\n• None Excel has a popular function, VLOOKUP. DAX functions don’t take a cell or cell range as a reference like VLOOKUP does in Excel. DAX functions take a column or a table as a reference. Keep in mind, in Power BI Desktop you’re working with a relational data model. Looking up values in another table is easy, and in most cases you don’t need to create any formulas at all. As you can see, functions in DAX can help you create powerful formulas. We only touched on the basics of functions. As your DAX skills grow, you'll create formulas by using many different functions. One of the best places to learn details about each of the DAX functions is in the DAX Function Reference.\n• What does a function always reference?\n• Can a formula contain more than one function?\n• What category of functions would you use to concatenate two text strings into one string?\n\nAnswers are provided at the end of this article.\n\nContext is one of the most important DAX concepts to understand. There are two types of context in DAX: row context and filter context. We’ll first look at row context.\n\nRow context is most easily thought of as the current row. It applies whenever a formula has a function that applies filters to identify a single row in a table. The function will inherently apply a row context for each row of the table over which it's filtering. This type of row context most often applies to measures.\n\nFilter context is a little more difficult to understand than row context. You can most easily think of filter context as: One or more filters applied in a calculation that determines a result or value.\n\nFilter context doesn’t exist in place of row context; rather, it applies in addition to row context. For example, to further narrow down the values to include in a calculation, you can apply a filter context, which not only specifies the row context, but also specifies a particular value (filter) in that row context.\n\nFilter context is easily seen in your reports. For example, when you add TotalCost to a visualization, and then add Year and Region, you're defining a filter context that selects a subset of data based on a given year and region.\n\nWhy is filter context so important to DAX? You've seen that filter context can be applied by adding fields to a visualization. Filter context can also be applied in a DAX formula by defining a filter with functions such as ALL, RELATED, FILTER, CALCULATE, by relationships, and by other measures and columns. For example, let’s look at the following formula in a measure named Store Sales:\n\nTo better understand this formula, we can break it down, much like with other formulas.\n\nThis formula includes the following syntax elements:\n\nB. The equals sign operator (=), which indicates the beginning of the formula.\n\nC. The CALCULATE function, which evaluates an expression, as an argument, in a context that is modified by the specified filters.\n\nD. Parenthesis (), which surround an expression containing one or more arguments.\n\nE. A measure [Total Sales] in the same table as an expression. The Total Sales measure has the formula: =SUM(Sales[SalesAmount]).\n\nF. A comma (,), which separates the first expression argument from the filter argument.\n\nG. The fully qualified referenced column, Channel[ChannelName]. This is our row context. Each row in this column specifies a channel, such as Store or Online.\n\nH. The particular value, Store, as a filter. This is our filter context.\n\nThis formula ensures only sales values defined by the Total Sales measure are calculated only for rows in the Channel[ChannelName] column, with the value Store used as a filter.\n\nAs you can imagine, being able to define filter context within a formula has immense and powerful capabilities. The ability to reference only a particular value in a related table is just one such example. Don’t worry if you don't completely understand context right away. As you create your own formulas, you'll better understand context and why it’s so important in DAX.\n• What are the two types of context?\n\nAnswers are provided at the end of this article.\n\nNow that you have a basic understanding of the most important concepts in DAX, you can begin creating DAX formulas for measures on your own. DAX can indeed be a little tricky to learn, but there are many resources available to you. After reading through this article and experimenting with a few of your own formulas, you can learn more about other DAX concepts and formulas that can help you solve your own business problems. There are many DAX resources available to you; most important is the Data Analysis Expressions (DAX) Reference.\n\nBecause DAX has been around for several years in other Microsoft BI tools such as Power Pivot and Analysis Services Tabular models, there are many great sources information out there. You can find more information in books, whitepapers, and blogs from both Microsoft and leading BI professionals. The DAX Resource Center is also a great place to start.\n• Validates and enters the measure into the model.\n• Yes. A formula can contain up to 64 nested functions.\n• One or more filters in a calculation that determines a single value."
    },
    {
        "link": "https://dax.guide",
        "document": "Browse DAX functions alphabetically from the sidebar or choose a category below:\n• Aggregation functions Aggregation functions return a scalar value by applying an aggregation function to a column or to an expression evaluated by iterating a table expression.\n• Date and Time functions Date and time functions help create calculations based on dates and time. Many of the functions in DAX are similar to the Excel date and time functions.\n• Financial functions Financial functions corresponding to Excel functions with the same name.\n• Information functions Information functions provide information about the data type or filter context of the argument provided.\n• Logical functions Logical functions act upon an expression, to return information about the values or sets in the expression.\n• Math and Trig functions The mathematical functions in DAX are very similar to the Excel mathematical and trigonometric functions.\n• Other functions These are special functions that cannot be classified in other categories.\n• Time Intelligence functions Time intelligence functions support calculations to compare and aggregate data over time periods, supporting days, months, quarters, and years.\n• Visual calculations functions Visual calculations functions can only be used in Power BI visual calculations and cannot be used in regular measures, calculated columns, nor calculated tables."
    },
    {
        "link": "https://datacamp.com/tutorial/guide-to-dax-lookupvalue",
        "document": "You will investigate a dataset from a fictitious company called Databel in Power BI, and need to figure out why customers are churning."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dax/lookupvalue-function-dax",
        "document": "Returns the value for the row that meets all criteria specified by one or more search conditions.\n\nThe value of at the row where all pairs of and have an exact match.\n\nIf there isn't a match that satisfies all the search values, BLANK or (if specified) is returned. In other words, the function doesn't return a lookup value if only some of the criteria match.\n\nIf multiple rows match the search values and the values in the for these rows are identical, then that value is returned. However, if returns different values, an error or (if specified) is returned.\n• None If there is a relationship between the table that contains the result column and tables that contain the search columns, in most cases, using the RELATED function instead of LOOKUPVALUE is more efficient and provides better performance.\n• None Multiple pairs of and can be specified.\n• None The and parameters are evaluated before the function iterates through the rows of the search table.\n• None Avoid using ISERROR or IFERROR functions to capture an error returned by LOOKUPVALUE. If some inputs to the function result in an error when a single output value cannot be determined, providing an parameter is the most reliable and highest performing way to handle the error.\n• None The parameter returns an error if specified in a Power Pivot calculated column.\n• None This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security (RLS) rules.\n\nIn this example, LOOKUPVALUE is used to search Average Rate for the currency used to pay for the order on the day the order was placed:\n\nBoth the Order Date and Currency are required to find the Average Rate for the correct date and currency. OrderDateKey and CurrencyKey are the keys used to look up the Average Rate in the Currency Rate table.\n\nYou can use the Exchange Rate to calculate the Sales Amount in local currency with:\n\nIn this example, the following calculated column defined in the Sales table uses the LOOKUPVALUE function to return channel values from the Sales Order table.\n\nHowever, in this case, because there is a relationship between the Sales Order and Sales tables, it's more efficient to use the RELATED function."
    },
    {
        "link": "https://dax.guide/lookupvalue",
        "document": "The value that is returned when there is no value or more than one value in the specified column; if omitted, BLANK is returned for no value and an error is returned for more than one value.\n\nThe value that you want to find in search_column.\n\nThe value of Result_Column at the row where all pairs of Search_Column and Search_Value have a match.\n\nIf there is no match that satisfies all the search values, a BLANK is returned. In other words, the function will not return a lookup value if only some of the criteria match. This also happens when the expected result is a Boolean data type.\n\nIf multiple rows match the search values and in all cases Result_Column values are identical then that value is returned. However, if Result_Column returns different values, the function returns Alternate_Result if defined, otherwise it returns an error.\n\nThe Search_ColumnName can be any column of the expanded table referenced by Result_ColumnName.\n\nEven though the LOOKUPVALUE internally uses CALCULATE, LOOKUPVALUE arguments are not affected by a possible context transition. For this reason, LOOKUPVALUE is not marked with the context transition attribute.\n\nConsider using LOOKUPVALUE when it is not possible to rely on RELATED to leverage an existing relationship in the data model, because RELATED is faster.\n\n The query plan generated by LOOKUPVALUE is usually relatively optimized. However, in certain conditions it could include CallbackDataID requests in storage engine queries, resulting in slower execution, lower performance and missed cache hits. When this happens, alternative approaches should be considered.\n\nYou can write LOOKUPVALUE using CALCULATE this way:\n\nWhen <expression_1> and <expression_2> are constant values, there shouldn’t be any issue. However, it is often the case that these expressions are more dynamic, and this could generate a more expensive query plan that includes CallbackDataID requests to the storage engine. This might also be the case for the LOOKUPVALUE function.\n\n In order to reduce this effort, you can move the expression outside of the filter predicates in CALCULATE; a similar approach in LOOKUPVALUE might not produce a similar level of optimization:\n\nThe code above corresponds to the following approach using TREATAS:\n\nIt is better to store the TREATAS result in a variable for readability reasons, but the following code is also identical to the previous code from a query plan perspective:\n\nFor the LOOKUPVALUE use case, it is possible to create a single multi-column filter instead of multiple filters – possibly resulting in a better query plan. A benchmark of different solutions is always a good idea:\n\nThis latter alternative to LOOKUPVALUE could optimize complex scenarios where the presence of LOOKUPVALUE in an iterator produces poor performance – mainly when the storage engine queries include CallbackDataID calls and are not stored in cache."
    },
    {
        "link": "https://blog.coupler.io/power-bi-lookupvalue",
        "document": "Power BI is packed with a powerful set of features for data analytics and reporting. It supports DAX (data analysis expressions) formulas, i.e., functions, operators, and values, for creating new fields or measures based on logic.\n\nLOOKUPVALUE in Power BI is one such useful DAX filter function. Similar to the VLOOKUP function in Microsoft Excel, it is used to retrieve a specific column value from a table based on another column.\n\nIn this complete guide, you’ll learn about Power BI LOOKUPVALUE function, understand its syntax, and see useful examples of how to master it.\n\nLOOKUPVALUE in Power BI is an in-built DAX filter function that you can use to retrieve the required column value based on another column in a table.\n\nTo understand this better, let’s say we have a table containing columns for employee ID and name. And we want to fetch the employee’s name based on the employee ID. We can use the LOOKUPVALUE in Power BI to do that (more on that later.)\n\nBefore we dive deeper, let’s dissect and have a closer look at the LOOKUPVALUE Power BI syntax.\n\nThe Power BI LOOKUPVALUE function requires multiple parameters to search and retrieve the required results.\n\nHere’s the general syntax of LOOKUPVALUE in Power BI:\n\nThe LOOKUPVALUE function takes the following four parameters as inputs:\n• result_columnname: the name of the column containing the required value.\n• search_columnname: the name of the column based on which we want to retrieve the required value.\n• search_value: the value we want to look for in the search_column.\n• alternate_result: the value that is returned in case no or multiple results are returned matching the declared criteria. This parameter is optional.\n\nIn simple terms, the above syntax returns the value of result_column where the value of search_column matches the search_value. It iterates through the entire record to find the column value matching the provided criteria.\n\nYou can also declare multiple pairs of search_value and search_column in the LOOKUPVALUE function.\n• The result column and search column should be in the same table.\n• Power BI evaluates the search value and alternate value before performing the look-up.\n• The LOOKUPVALUE function is not supported in the DirectQuery mode when used in calculated columns or row-level security rules.\n• The data type of the search column should match that of the value.\n\nHow to use LOOKUPVALUE in Power BI?\n\nTo use the LOOKUPVALUE function in Power BI, you’ll first need to create a new report and load data into it. And then you can proceed to adding visuals, using DAX functions, and analyzing your data in it.\n\nLet’s go through the tutorial and learn to import data to Power BI and use the LOOKUPVALUE function.\n\nYou can use native Power BI connectors or third-party tools to load data. In this example, we’ll use Coupler.io, a data automation and integration platform, to connect our data source. Coupler.io can pull data and schedule imports from 50+ data sources to Power BI and other destinations.\n\nIt saves a lot of time as it can send your data to Power BI automatically on a schedule and keep it fresh.\n\nTo transfer data into Power BI, select your data source from the dropdown in the widget below and click Proceed.\n\nFollow the instructions to connect the data source. Then, a preview of the data will appear in the transformation module. Here, you can use Coupler.io’s data transformation features to filter and sort data before loading it into Power BI. You can also use basic formulas to create new calculated columns and hide any unnecessary columns from the dataset.\n\nClick the button to generate and copy the integration link for Power BI and proceed further.\n\nNow, toggle the data automation option on to schedule updates. You can set the data refresh interval up to every 15 minutes and select the appropriate weekdays and time for automated data refreshes.\n\nOnce configured, click the Run Importer button. Now, go to Power BI Desktop, and paste the copied link in Get Data > Web.\n\nAdd the data source to Power BI. You can edit the data in the Power Query editor before finally adding it.\n\nNow, you can use the added data to create visuals and use the LOOKUPVALUE function in Power BI.\n\n2. Use the LOOKUPVALUE function in Power BI\n\nLet’s say we have a table (named Employees) containing employee records with columns like employee ID, name, department, etc. (In this entire guide, we’ll use this table as an example dataset.)\n\nAnd we want to fetch the name of the employee whose ID is 33. We can use the LOOKUPVALUE function in Power BI to do that.\n\nFirst, we’ll need to create a new column. Click on the three dots beside the datasource name and click “New column” in the dropdown.\n\nNow, enter the following DAX formula for the new column:\n\nNote: You’ll need to modify the DAX code as per the table and column names.\n\nNow, you can use this newly created column in the dataset for creating visuals.\n\nIn this example, we have created a card visual to display the name of the employee matching the criteria (i.e. employee ID = 33.)\n\nThat’s how you can use the Power BI LOOKUPVALUE function to retrieve specific values from tables.\n\nThe Power BI LOOKUPVALUE function can be utilized beyond the single-column value lookup. You can utilize it in advanced scenarios as per your analytics needs. For example, you can use it with multiple search conditions, filters, etc.\n\nLet’s now go through some advanced examples and use cases.\n\nThe LOOKUPVALUE Power BI function supports multiple criteria declarations. This means you can add more than just one condition to look for a specific value in the table.\n\nMultiple conditions in the LOOKUPVALUE function in Power BI can be helpful when you want to perform a more targeted lookup and complex data filtering. You can add multiple pairs of search columns and search values in series.\n\nFor example, let’s say we want to retrieve the name of the employee who works in the finance department and lives in Chicago.\n\nHere’s the formula to add these two conditions in the LOOKUPVALUE function:\n\nIt will return the value of the Name column where the Department is “Finance” and Location is “Chicago” from the table.\n\nIn the same way, you can add more conditions to the LOOKUPVALUE function and make it more specific. Power BI has not defined any limit on the number of conditions you can add. However, adding more conditions can slow down the process and impact reporting performance.\n\nThe Power BI LOOKUPVALUE function is meant to return only one value matching the defined conditions. And it is not well-suited to retrieve multiple values. But there are workarounds to lookup multiple values in Power BI using custom DAX formulas.\n\nThe in-built LOOKUPVALUE function will result in an error in case of multiple values matching the criteria.\n\nLet’s understand this through the same example of the Employee’s table.\n\nSuppose, we want to fetch the names of employees working in the finance department. We can use the following formula:\n\nHere, since we have entries of multiple people in the finance department, the LOOKUPVALUE function will return an error like the one displayed below.\n\nTo handle such LOOKUPVALUE errors, you can use alternate value parameter.\n\nIt is returned as a value in case no or multiple values match the defined condition or conditions. For example, we can modify the above function to:\n\nThe alternative value parameter is an effective way to handle errors and debug reporting issues.\n\nThe Power BI LOOKUPVALUE function can also look up values in other tables. It can be helpful for cross-table calculations and referencing.\n\nFor example, you can use:\n\nto get the value column from Table 2 to Table 1.\n\nConsider our previous example of the employee’s table, for example. And let’s say we’ve another table that contains Employee ID and Salary details.\n\nWe can use the LOOKUPVALUE function to create a new column and add salary details by EmployeeID from another table. Here’s the example formula:\n\nPower BI LOOKUPVALUE and RELATED are two different DAX functions to reference a calculated column from another related table.\n\nBut they serve different purposes and are used in different contexts.\n\nThe RELATED function in Power BI references a column from another table related to the current one. It follows the table relationships defined in the data model to retrieve the referenced column.\n\nGenerally, Power BI automatically establishes relationships between tables that share columns. But you may need to create a relationship manually between tables to use the RELATED function.\n\nHere’s the general syntax for the RELATED function:\n• Table_name: It is the name of the table you’re referencing.\n• Column_name: It is the name of the column to retrieve.\n\nIn the example shown below, we used the RELATED function in Power BI to retrieve an entire column from another table. Here’s the example formula:\n\nThe RELATED function is a better choice when it comes to performance. It is recommended to use the RELATED over LOOKUPVALUE function in Power BI when there is a relationship between tables. On the other hand, the LOOKUPVALUE function is a good choice when you want to retrieve data based on a unique identifier (primary keys in data.)\n\nCan you use Power BI LOOKUPVALUE with a filter?\n\nNo, the LOOKUPVALUE Power BI function ignores the filters applied to the tables. However, you can use the columns calculated using the LOOKUPVALUE function to filter the Power BI report or visualization.\n\nLet’s see how to use Power BI LOOKUPVALUE with a filter.\n\nYou can apply filters to the column with the LOOKUPVALUE function. To do this, select the visual containing the column, expand the Filters section and apply relevant filters to the column as shown below.\n\nIn the above example, we’ve filtered the table visual based on the Salary column that we created using the LOOKUPVALUE function.\n\nDoes LOOKUPVALUE return the first match in Power BI?\n\nNo. The Power BI LOOKUPVALUE function only works if there is one value matching the criteria. It will return an error if there are no or multiple matching results.\n\nWhy is Power BI LOOKUPVALUE not working?\n\nThere could be several reasons why the Power BI LOOKUPVALUE function may not work as expected. The most probable reasons include:\n• Invalid table or column name: The LOOKUPVALUE in Power BI may not work appropriately if the table or column names are invalid. Look for typos in the formula. Use the smart suggestions you get for table and column names to auto-complete the formulas as you type.\n• Data type mismatch: The search value and the column to be searched should be of the same data type. Power BI may be unable to look up the value in case of a data type mismatch.\n• No or multiple matching values: The Power BI LOOKUPVALUE function is used to identify unique values based on criteria. Double-check if the criteria are correctly defined. It may not work as expected if there are no or multiple results.\n• Case sensitivity: The Power BI LOOKUPVALUE is a case-sensitive function. It may not work as expected if there is a case mismatch in the name of the table and column parameters. E.g., a table named “CouplerData” can not be declared as “couplerdata”\n\nMany users also reported a common issue – LOOKUPVALUE stopped working after a data refresh. This can be due to multiple scenarios because of changes in data.\n\nFor example, the refresh introduced more rows in the data that match the criteria defined in the LOOKUPVALUE function. In such a case, the function may stop working because of multiple values in the result.\n\nAnother possible cause can be a change in the name of the columns. The LOOKUPVALUE function may break if there is a change in the column name during a refresh.\n\nIn all these cases, you can debug the issue by double-checking the LOOKUPVALUE function in Power BI against the above-mentioned points.\n\nTips to use LOOKUPVALUE in Power BI for optimal performance\n\nPower BI LOOKUPVALUE is a powerful function to retrieve single values from columns matching specific criteria. However, it can slow down the reporting, if not used correctly. The calculated columns are computed on every data refresh. Therefore, using the LOOKUPVALUE function to create custom columns can significantly impact the reporting performance when working with a vast dataset.\n\nHere are some useful tips for optimized usage:\n• Do not use too many pairs of search columns and values, unless required.\n• Prefer RELATED over LOOKUPVALUE when there is a relationship between tables.\n• Use the alternative value parameter to show an error instead of using ISBLANK, ISERROR, or IFERROR functions.\n\nThe key is to keep it simple. Not too complex. Minimal.\n\nYou can also use Coupler.io to automate dataflows to Power BI and speed up the reporting. The powerful transformation module lets you pull data from 50+ data sources and make it report-ready before loading it.\n\nYou can filter out unwanted columns, sort data, or add new calculated columns required for reporting. And that too without affecting the Power BI reporting performance. So go ahead and try Coupler.io now for free. For more on using formulas in PowerBI, check our article on performing VLOOKUP in Power BI."
    },
    {
        "link": "https://databear.com/mastering-the-lookupvalue-dax-function-in-power-bi",
        "document": "In today’s blog post, we will discuss the LOOKUPVALUE function: what it is, how to use it, and what you should consider before using this DAX function.\n\nWhat is the LOOKUPVALUE Function?\n\nThe LOOKUPVALUE DAX function returns the value for the row that meets all criteria specified by one or more search conditions. In other words, it allows you to search for a particular value based on specific criteria and return the corresponding result.\n• Result_ColumnName: The column containing the values you are looking for.\n• Search_ColumnName: The criteria by which you have to search.\n• Search_Value: The value you want to search for; this can be a column or a particular value.\n• Alternate_Result (optional): The value to return if no result is found.\n\nSuppose we have an Employee table and a Master table. The Employee table contains employee names, company names, position names, and states, while the Master table has state and country information. We want to create a new column in the Employee table that shows the corresponding country for each state.\n\nTo achieve this, we can use the LOOKUPVALUE function as follows:\n\nIn another example, we have a Fact Internet Sales table containing customer keys, sales order numbers, order quantities, and other columns. Our goal is to find the sales order number corresponding to a particular customer key.\n\nTo do this, we can create a new measure using the LOOKUPVALUE function:\n\nPoints to Consider for LOOKUPVALUE\n• If there is a relationship between the result and search table, using the RELATED function instead of LOOKUPVALUE is more efficient and provides better performance.\n• The search value and alternate result parameters are evaluated before the function iterates through the rows of the search table.\n• This function is not supported for use in DirectQuery mode when used in calculated columns or row-level security rules.\n\nWe hope this blog post has given you a better understanding of the LOOKUPVALUE DAX function and its use cases. If you have any questions or concerns, please let us know in the comment section below.\n\nYou can visit the rest of our blog posts for more insightful information on everything related to Power BI.\n\nLearn more about Power BI by taking our training course."
    }
]