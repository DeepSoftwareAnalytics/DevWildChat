[
    {
        "link": "https://docs.python.org/3/library/abc.html",
        "document": "This module provides the infrastructure for defining abstract base classes (ABCs) in Python, as outlined in PEP 3119; see the PEP for why this was added to Python. (See also PEP 3141 and the module regarding a type hierarchy for numbers based on ABCs.)\n\nThe module has some concrete classes that derive from ABCs; these can, of course, be further derived. In addition, the submodule has some ABCs that can be used to test whether a class or instance provides a particular interface, for example, if it is hashable or if it is a mapping.\n\nThis module provides the metaclass for defining ABCs and a helper class to alternatively define ABCs through inheritance:\n\nA helper class that has as its metaclass. With this class, an abstract base class can be created by simply deriving from avoiding sometimes confusing metaclass usage, for example: Note that the type of is still , therefore inheriting from requires the usual precautions regarding metaclass usage, as multiple inheritance may lead to metaclass conflicts. One may also define an abstract base class by passing the metaclass keyword and using directly, for example:\n\nUse this metaclass to create an ABC. An ABC can be subclassed directly, and then acts as a mix-in class. You can also register unrelated concrete classes (even built-in classes) and unrelated ABCs as “virtual subclasses” – these and their descendants will be considered subclasses of the registering ABC by the built-in function, but the registering ABC won’t show up in their MRO (Method Resolution Order) nor will method implementations defined by the registering ABC be callable (not even via ). Classes created with a metaclass of have the following method: Register subclass as a “virtual subclass” of this ABC. For example: Changed in version 3.3: Returns the registered subclass, to allow usage as a class decorator. Changed in version 3.4: To detect calls to , you can use the function. You can also override this method in an abstract base class: Check whether subclass is considered a subclass of this ABC. This means that you can customize the behavior of further without the need to call on every class you want to consider a subclass of the ABC. (This class method is called from the method of the ABC.) This method should return , or . If it returns , the subclass is considered a subclass of this ABC. If it returns , the subclass is not considered a subclass of this ABC, even if it would normally be one. If it returns , the subclass check is continued with the usual mechanism. For a demonstration of these concepts, look at this example ABC definition: The ABC defines the standard iterable method, , as an abstract method. The implementation given here can still be called from subclasses. The method is also part of the abstract base class, but it does not have to be overridden in non-abstract derived classes. The class method defined here says that any class that has an method in its (or in that of one of its base classes, accessed via the list) is considered a too. Finally, the last line makes a virtual subclass of , even though it does not define an method (it uses the old-style iterable protocol, defined in terms of and ). Note that this will not make available as a method of , so it is provided separately.\n\nThe module also provides the following decorator:\n\nUsing this decorator requires that the class’s metaclass is or is derived from it. A class that has a metaclass derived from cannot be instantiated unless all of its abstract methods and properties are overridden. The abstract methods can be called using any of the normal ‘super’ call mechanisms. may be used to declare abstract methods for properties and descriptors. Dynamically adding abstract methods to a class, or attempting to modify the abstraction status of a method or class once it is created, are only supported using the function. The only affects subclasses derived using regular inheritance; “virtual subclasses” registered with the ABC’s method are not affected. When is applied in combination with other method descriptors, it should be applied as the innermost decorator, as shown in the following usage examples: In order to correctly interoperate with the abstract base class machinery, the descriptor must identify itself as abstract using . In general, this attribute should be if any of the methods used to compose the descriptor are abstract. For example, Python’s built-in does the equivalent of: Unlike Java abstract methods, these abstract methods may have an implementation. This implementation can be called via the mechanism from the class that overrides it. This could be useful as an end-point for a super-call in a framework that uses cooperative multiple-inheritance.\n\nThe module also supports the following legacy decorators:\n\nDeprecated since version 3.3: It is now possible to use , , and with , making this decorator redundant. A subclass of the built-in , indicating an abstract property. This special case is deprecated, as the decorator is now correctly identified as abstract when applied to an abstract method: The above example defines a read-only property; you can also define a read-write abstract property by appropriately marking one or more of the underlying methods as abstract: If only some components are abstract, only those components need to be updated to create a concrete property in a subclass:\n\nThe module also provides the following functions:"
    },
    {
        "link": "https://docs.python.org/3/library/collections.abc.html",
        "document": "This module provides abstract base classes that can be used to test whether a class provides a particular interface; for example, whether it is hashable or whether it is a mapping.\n\nAn or test for an interface works in one of three ways.\n• None A newly written class can inherit directly from one of the abstract base classes. The class must supply the required abstract methods. The remaining mixin methods come from inheritance and can be overridden if desired. Other methods may be added as needed: # Extra method not required by the ABC\n• None Existing classes and built-in classes can be registered as “virtual subclasses” of the ABCs. Those classes should define the full API including all of the abstract methods and all of the mixin methods. This lets users rely on or tests to determine whether the full interface is supported. The exception to this rule is for methods that are automatically inferred from the rest of the API: # Extra method not required by the ABC In this example, class does not need to define , , and because the in-operator, the iteration logic, and the function automatically fall back to using and .\n• None Some simple interfaces are directly recognizable by the presence of the required methods (unless those methods have been set to ): Complex interfaces do not support this last technique because an interface is more than just the presence of method names. Interfaces specify semantics and relationships between methods that cannot be inferred solely from the presence of specific method names. For example, knowing that a class supplies , , and is insufficient for distinguishing a from a .\n\nABCs allow us to ask classes or instances if they provide particular functionality, for example: Several of the ABCs are also useful as mixins that make it easier to develop classes supporting container APIs. For example, to write a class supporting the full API, it is only necessary to supply the three underlying abstract methods: , , and . The ABC supplies the remaining methods such as and : and not requiring the set elements to be hashable. ''' # The __and__() method is supported automatically Notes on using and as a mixin:\n• None Since some set operations create new sets, the default mixin methods need a way to create new instances from an iterable. The class constructor is assumed to have a signature in the form . That assumption is factored-out to an internal called which calls to produce a new set. If the mixin is being used in a class with a different constructor signature, you will need to override with a classmethod or regular method that can construct new instances from an iterable argument.\n• None To override the comparisons (presumably for speed, as the semantics are fixed), redefine and , then the other operations will automatically follow suit.\n• None The mixin provides a method to compute a hash value for the set; however, is not defined because not all sets are hashable or immutable. To add set hashability using mixins, inherit from both and , then define .\n• None OrderedSet recipe for an example built on .\n• None For more about ABCs, see the module and PEP 3119."
    },
    {
        "link": "https://ioflood.com/blog/python-abstract-class",
        "document": "Are you finding it challenging to understand abstract classes in Python? You’re not alone. Many developers grapple with this concept, but once mastered, it can significantly streamline your coding process.\n\nThink of abstract classes as blueprints for other classes, guiding the structure of derived classes. They are a powerful tool in the Python programmer’s arsenal, enabling you to write more efficient, readable, and maintainable code.\n\nIn this guide, we’ll walk you through the ins and outs of abstract classes in Python, from basic usage to advanced techniques. We’ll cover everything from creating an abstract class using the module, to more complex uses of abstract classes, and even alternative approaches.\n\nTL;DR: How Do I Create an Abstract Class in Python?\n\nIn this example, we import the and from the module. We then define an abstract class using the as the base class. The decorator is used to declare the method as an abstract method. This means that any class that inherits from must provide an implementation of the method.\n\nCreating an Abstract Class in Python: The Basics\n\nIn Python, abstract classes are created using the module, which stands for Abstract Base Class. This module provides the necessary infrastructure for defining abstract base classes (ABCs) in Python. The key components of this module that we’ll use are the class and the decorator.\n\nThe module provides the class that we can use as a base class for creating abstract classes. Here’s a simple example:\n\nIn this example, we’ve created a class that inherits from . However, at this point, is not yet an abstract class because it doesn’t contain any abstract methods.\n\nTo create an abstract method, we use the decorator. An abstract method is a method declared in an abstract class but doesn’t contain any implementation. Subclasses of the abstract class are generally expected to provide an implementation for these methods. Here’s an example:\n\nIn this example, is an abstract method. If we create a subclass of and try to create an instance without providing an implementation for , Python will raise a .\n\nUsing abstract classes provides a clear structure for your code and makes it easier to work in a team setting. It ensures that certain methods must be implemented in any subclass, which can help prevent errors.\n\nHowever, it’s important to remember that Python’s module is not enforced at the language level but rather at the runtime level. This means that errors related to not implementing abstract methods in a subclass will only be caught at runtime, not during syntax checking or linting. Therefore, thorough testing is crucial when working with abstract classes in Python.\n\nAfter mastering the basics of abstract classes in Python, you may find yourself needing more advanced techniques. Abstract classes can be used in more complex scenarios like multiple inheritance and interface implementation. Let’s dive into these concepts.\n\nPython supports multiple inheritance, a feature where a class can inherit from more than one base class. This includes abstract classes. Here’s an example:\n\nIn this example, is a subclass of both and and provides an implementation for the abstract methods from both base classes.\n\nIn Python, abstract classes can also be used to implement interfaces. An interface is a blueprint for a class, much like an abstract class, but it usually only contains method signatures and no implementation.\n\nHere’s an example of using an abstract class to define an interface:\n\nIn this example, is an abstract class that serves as an interface. is a concrete class that provides an implementation for the methods defined in .\n\nUsing abstract classes for more complex scenarios like these can greatly enhance the structure and readability of your code. However, as with any powerful tool, it’s important to use these techniques judiciously and in the right context.\n\nWhile the module is a powerful tool for creating abstract classes in Python, there are other approaches you can use, such as metaclasses and third-party libraries like . Let’s dive into these alternative methods.\n\nA metaclass in Python is a class of a class, or rather, a class that defines the behavior of other classes. You can use metaclasses to create abstract classes in Python. Here’s an example:\n\nIn this example, is a metaclass that raises a if the class it’s being applied to doesn’t have any abstract methods. uses as its metaclass and defines an abstract method .\n\nThe library is a third-party library that provides a way to define interfaces and abstract classes in Python. Here’s an example:\n\nIn this example, is an interface that defines an abstract method . provides an implementation for and is declared to implement using the decorator.\n\nThese alternative approaches to creating abstract classes in Python can provide additional flexibility and capabilities beyond what the module offers. However, they also come with their own trade-offs. Metaclasses can be complex and difficult to understand, while third-party libraries add external dependencies to your project. As always, it’s important to consider the specific needs and constraints of your project when deciding which approach to use.\n\nWorking with abstract classes in Python can sometimes lead to errors or obstacles. Let’s explore some common issues and their solutions.\n\nOne common mistake when working with abstract classes is attempting to create an instance of an abstract class. Since abstract classes are meant to be a blueprint for other classes, they cannot be instantiated directly. Trying to do so will lead to a .\n\nThe solution is to create a concrete subclass that implements all the abstract methods of the abstract class, and then instantiate that subclass.\n\nAnother common error is not implementing all the abstract methods in a subclass of an abstract class. If a subclass doesn’t provide implementations for all abstract methods of the superclass, Python will raise a when you try to create an instance of the subclass.\n\nThe solution is to ensure that all subclasses implement all abstract methods of the superclass.\n\nWhen working with abstract classes in Python, it’s important to follow best practices to ensure your code is efficient and maintainable. Here are a few tips:\n• Use abstract classes when you want to provide a common interface for different classes.\n• Don’t overuse abstract classes. If a class doesn’t need to provide an interface and doesn’t have any abstract methods, it probably doesn’t need to be an abstract class.\n• Keep abstract classes small and focused. They should define a specific interface, not try to do too many things at once.\n• Remember that Python’s module is a runtime feature. Errors related to abstract classes won’t be caught until your code is actually running, so make sure to thoroughly test any code that uses abstract classes.\n\nTo fully understand the concept of abstract classes in Python, it’s crucial to have a grasp of some fundamental principles of Object-Oriented Programming (OOP). These principles include inheritance, encapsulation, and polymorphism. Let’s examine these concepts and the role of abstract classes in each.\n\nInheritance is an OOP principle that allows one class to inherit the properties and methods of another class. In the context of abstract classes, the abstract class serves as the parent class, and the subclasses that implement the abstract methods are the child classes.\n\nIn this example, is an abstract class with an abstract method . is a subclass of that provides an implementation for .\n\nEncapsulation is the principle of hiding the internal workings of an object and exposing only what is necessary. Abstract classes play a role in encapsulation by defining a clear interface that other classes can implement, hiding the complexity of the underlying implementation.\n\nPolymorphism is the ability of an object to take on many forms. With abstract classes, polymorphism is achieved through the implementation of the abstract methods in the subclasses. Each subclass can provide a different implementation, allowing for a variety of behaviors.\n\nIn this example, and are subclasses of the abstract class and provide different implementations for the method, demonstrating polymorphism.\n\nIn conclusion, abstract classes in Python play a crucial role in implementing the principles of OOP. They provide a blueprint for creating subclasses, encapsulate complexity, and enable polymorphism, making your code more structured, maintainable, and flexible.\n\nAbstract classes are not just theoretical constructs, but they have practical applications in larger projects and real-world scenarios. They are often used in software design patterns, such as the Template Method pattern, where an abstract class defines a ‘skeleton’ of an algorithm in an operation and defers some steps to subclasses.\n\nIn this example, defines the which outlines the algorithm’s structure and calls and , which are abstract methods. The provides the specific implementations for these operations.\n\nAs you continue to explore abstract classes, you’ll likely encounter related topics such as mixins, interfaces, and software design patterns. These concepts often accompany abstract classes in typical use cases and provide additional tools for structuring and organizing your code.\n\nTo deepen your understanding of abstract classes and related topics, here are some resources that offer more in-depth information:\n• Python OOP Best Practices – Dive into inheritance in Python to build relationships between classes and reuse code.\n• None Exploring the Object Class in Python – Learn about Python objects as instances of classes, representing real-world entities.\n• None Understanding Classes in Python – Learn how to define and instantiate classes in Python for object-oriented programming.\n• None Python’s Official Documentation on the ABC Module – Learn about Python’s abstract base class module from official sources.\n• None Real Python’s Guide on Abstract Base Classes – Detailed explanation of abstract base classes in Python.\n• None Python-Course’s Tutorial on Abstract Classes – Step-by-step guide to understanding abstract classes in Python.\n\nThese resources provide a wealth of information and examples that can help you master the use of abstract classes in Python and apply them effectively in your own projects.\n\nIn this comprehensive guide, we’ve navigated through the concept of abstract classes in Python. From understanding the basic use to exploring advanced techniques, we’ve covered the essential aspects of this powerful programming construct.\n\nWe started with the basics, learning how to create an abstract class using the module. We then ventured into more advanced territory, discussing complex uses such as multiple inheritance and interface implementation.\n\nAlong the way, we tackled common challenges you might face when using abstract classes and provided solutions to help you overcome these hurdles.\n\nWe also looked at alternative approaches to creating abstract classes, such as using metaclasses and third-party libraries like . This gave us a broader understanding of the various ways to implement abstract classes in Python.\n\nWhether you’re a beginner just starting out with abstract classes or an experienced Python developer looking to level up your skills, we hope this guide has given you a deeper understanding of abstract classes in Python and how to use them effectively in your code. Happy coding!"
    },
    {
        "link": "https://medium.com/@pouyahallaj/introduction-1616b3a4a637",
        "document": "Python is a versatile programming language known for its flexibility and expressiveness. It offers several features and concepts that enable developers to write clean and maintainable code. Two important concepts in Python that contribute to its power are Protocols and Abstract Base Classes (ABCs).\n\nUnderstanding Protocols and ABCs is crucial for Python developers who want to write code that is not only efficient but also adheres to good software design principles. While both Protocols and ABCs serve as tools for defining interfaces, they have distinct differences in their syntax, usage, and intended purposes.\n\nIn this article, we will dive into the world of Python Protocols and ABCs, exploring their individual characteristics and discussing the scenarios where one might be more suitable than the other. By the end of this article, you will have a clear understanding of the differences between Protocols and ABCs, allowing you to make informed decisions when designing and implementing interfaces in your Python projects.\n\nSo, let’s embark on this journey to unravel the intricacies of Python Protocols and ABCs, and discover how they contribute to writing robust and maintainable code.\n\nAbstract Base Classes (ABCs) in Python provide a mechanism for defining interfaces. An interface defines a set of methods that a class must implement to be considered compatible with that interface. ABCs help enforce this interface compatibility by allowing you to define abstract methods that must be implemented by subclasses.\n\nTo define an ABC in Python, you can make use of the module:\n\nIn the example above, we define an ABC called that inherits from the base class provided by the module. The decorator is used to mark the as an abstract method, indicating that any class inheriting from must implement this method.\n\nLet’s see how an actual class can implement this ABC:\n\nBy subclassing and implementing the method, the class becomes compatible with the interface.\n\nBenefits and Use Cases of ABCs\n• Interface enforcement: ABCs allow you to define a clear set of methods that must be implemented by subclasses, ensuring consistency and adherence to the interface.\n• Polymorphism: By designing code around ABCs, you can write functions that accept objects based on their interfaces rather than specific classes. This promotes polymorphism and code reuse.\n• Code organization: ABCs help in structuring your code by separating interface definitions from implementation details, leading to more modular and maintainable code.\n\nHowever, ABCs in Python have some shortcomings. One of the main limitations is that they rely on subclassing, meaning a class can only inherit from one ABC. This restriction can be problematic in cases where multiple inheritance is needed.\n\nThis is where Protocols come into play. In the next section, we will explore Protocols and how they address the shortcomings of ABCs.\n\nOne of the key limitations of ABCs is that they cannot be retroactively applied to existing classes. In other words, if you have a class that already exists and you want to make it compatible with an ABC, you would need to modify the class hierarchy and explicitly inherit from the ABC. This can be impractical or even impossible in certain situations.\n\nTo overcome this limitation, Python introduced Protocols, which provide a more flexible approach to interface definition. Protocols allow you to specify the expected methods and attributes that a class should have without requiring explicit inheritance or modifications to the class hierarchy.\n\nLet’s see an example of implementing a Protocol in Python:\n\nIn the code snippet above, we define a Protocol called using the base class provided by the module. The method is defined within the Protocol. Any class that has a compatible method can be considered compatible with , regardless of its inheritance hierarchy.\n\nHere’s an example of a class that implements the Protocol:\n\nThe class implements the method, which matches the signature specified in . Therefore, is compatible with .\n\nProtocols allow for more flexibility in defining interfaces, as they can be applied to existing classes without modifying their inheritance structure. This makes Protocols a valuable tool in scenarios where retroactively modifying class hierarchies is not feasible or desirable.\n\nLet’s explore the advantages and use cases of Protocols in Python.\n\nOne of the key advantages of Protocols is their ability to define interfaces without the need for explicit inheritance or modifications to the class hierarchy. This flexibility allows existing classes to be retroactively made compatible with a Protocol by simply implementing the required methods and attributes.\n\nProtocols are particularly useful in scenarios where modifying the inheritance structure of classes is impractical or where multiple inheritance is needed. With Protocols, you can focus on defining the desired behavior and characteristics of objects, regardless of their class hierarchy.\n\nPython is a dynamically typed language that follows the “duck typing” principle. It means that the compatibility of objects is determined by their behavior rather than their explicit type or class hierarchy. Protocols align well with this philosophy by allowing you to specify the expected methods and attributes that an object should have, enabling effective duck typing.\n\nProtocols enable you to define the essential behavior of objects, making it easier to write code that can accept a wide range of objects as long as they satisfy the required Protocol. This promotes code reusability and enhances the flexibility of your codebase.\n\nProtocols address some of the limitations of ABCs. Since Protocols do not rely on explicit inheritance, they offer the flexibility of defining interfaces for classes that may not be related through inheritance. This opens up opportunities for code reuse and composition in situations where multiple inheritance is required or where modifying class hierarchies is not practical.\n\nAdditionally, Protocols can be used to define interfaces for built-in types, third-party libraries, or classes that are not under your control. This capability is particularly valuable in situations where modifying existing classes or their inheritance hierarchy is not an option.\n\nLet’s explore an example of how Protocols can be used in practice:\n\nIn the code snippet above, we define a Protocol that specifies a single method . We then define a function that takes an argument of type and calls the function on it.\n\nThe and classes implement the method. As a result, they can be passed as arguments to the function, showcasing the flexibility and usability of Protocols.\n\nProtocols enable you to define contracts for behavior without imposing rigid class hierarchies, promoting code reusability, and enhancing the adaptability of your codebase.\n\nPython Protocols and Abstract Base Classes (ABCs) share similarities in defining interfaces, but they also have distinct differences in syntax, usage, and intended purposes. Let’s explore the key distinctions between Protocols and ABCs and understand when to choose one over the other.\n• Protocols are defined using the base class from the module.\n• Protocol methods are defined without implementation details, acting as placeholders for expected behavior.\n• Protocols allow for retroactively making existing classes compatible by implementing the required methods and attributes.\n• Multiple Protocols can be combined using the syntax.\n• ABCs are defined using the base class from the module.\n• ABC methods are defined using the decorator and must be implemented by subclasses.\n• Subclasses inherit the structure and behavior of the ABC, enforcing adherence to the defined interface.\n• ABCs rely on explicit inheritance, and existing classes need to be modified to inherit from the ABC to be compatible.\n• Protocols are particularly useful in scenarios where multiple inheritance is needed or modifying class hierarchies is impractical.\n• They align well with duck typing and allow for interface definition across different types and libraries.\n• ABCs are designed to enforce the implementation of a specific interface by subclasses.\n• They provide a mechanism for structuring and organizing code based on shared behavior.\n• ABCs are suitable when you have control over the class hierarchy and want to define a consistent interface across subclasses.\n\nLet’s explore some practical examples that illustrate the differences between Protocols and ABCs:\n\nIn the example above, the Protocol is used to define the behavior expected for printable objects. The function takes an argument of type and calls the function on it.\n\nOn the other hand, the ABC defines the interface for calculating the area of a shape. The and classes inherit from and implement the method.\n\nThe example illustrates that Protocols allow for more flexibility and compatibility across different types, as can accept any object that satisfies the Protocol. ABCs, on the other hand, enforce the implementation of the method by subclasses and provide a structured way to define a common interface.\n\nChoosing between Python Protocols and Abstract Base Classes (ABCs) depends on the specific requirements and constraints of your project. Here are some factors to consider when making a decision:\n\nFlexibility vs. Contract Enforcement: If you require a high degree of flexibility and adaptability in defining interfaces, Protocols are a suitable choice. They allow retroactive implementation and compatibility across different types. On the other hand, if you need to enforce a specific interface within a class hierarchy, ABCs provide a structured approach to contract enforcement.\n\nMultiple Inheritance: If your project requires multiple inheritance, Protocols are a more suitable option. They do not impose limitations on inheritance, allowing you to compose interfaces from multiple Protocols. ABCs, however, support single inheritance, which may not be sufficient in scenarios where multiple inheritance is necessary.\n\nBackward Compatibility: If you need to make existing classes compatible with an interface, Protocols offer a more practical solution. You can retroactively implement the required methods and attributes without modifying the class hierarchy. ABCs, on the other hand, require explicit inheritance, making them more suitable for designing interfaces from the start or when you have control over the class hierarchy.\n\nConsiderations for Libraries and Third-Party Code: Protocols can be useful for defining interfaces for built-in types or third-party libraries without modifying their code. This makes Protocols a valuable tool in scenarios where modifying existing classes or their inheritance hierarchy is not feasible or desirable.\n\nIn this article, we explored the distinctions between Python Protocols and Abstract Base Classes (ABCs). Protocols offer flexibility and adaptability in defining interfaces, allowing for retroactive implementation and compatibility across different types. On the other hand, ABCs provide a structured approach to contract enforcement within a class hierarchy.\n\nUnderstanding the differences between Protocols and ABCs is crucial in writing clean, robust, and maintainable Python code. By choosing the appropriate approach based on your project’s requirements, you can design effective interfaces and promote code reusability.\n\nWe encourage you to further explore and experiment with Protocols and ABCs in your Python projects. Familiarize yourself with their syntax, usage, and strengths to leverage their power in designing well-structured and adaptable codebases.\n\nStay tuned for more informative articles and don’t forget to follow for future updates. Happy coding!"
    },
    {
        "link": "https://python-course.eu/oop/the-abc-of-abstract-base-classes.php",
        "document": "Abstract classes are classes that contain one or more abstract methods. An abstract method is a method that is declared, but contains no implementation. Abstract classes cannot be instantiated, and require subclasses to provide implementations for the abstract methods.\n\nYou can see this in the following examples:\n\nIf we start this program, we see that this is not an abstract class, because:\n• we can instantiate an instance from\n• we are not required to implement do_something in the class defintition of B\n\nOur example implemented a case of simple inheritance which has nothing to do with an abstract class. In fact, Python on its own doesn't provide abstract classes. Yet, Python comes with a module which provides the infrastructure for defining Abstract Base Classes (ABCs). This module is called - for obvious reasons - abc.\n\nThe following Python code uses the abc module and defines an abstract base class:\n\nWe will define now a subclass using the previously defined abstract class. You will notice that we haven't implemented the do_something method, even though we are required to implement it, because this method is decorated as an abstract method with the decorator \"abstractmethod\". We get an exception that DoAdd42 can't be instantiated:\n\nWe will do it the correct way in the following example, in which we define two classes inheriting from our abstract class:\n\nA class that is derived from an abstract class cannot be instantiated unless all of its abstract methods are overridden.\n\nYou may think that abstract methods can't be implemented in the abstract base class. This impression is wrong: An abstract method can have an implementation in the abstract class! Even if they are implemented, designers of subclasses will be forced to override the implementation. Like in other cases of \"normal\" inheritance, the abstract method can be invoked with super() call mechanism. This enables providing some basic functionality in the abstract method, which can be enriched by the subclass implementation."
    },
    {
        "link": "https://stackoverflow.com/questions/60726156/best-way-to-implement-abstract-classes-in-python",
        "document": "If you really want the error to be raised if one of the subclasses try to call the superclass abstract method, then, yes, you should raise it manually. (and then, create an instance of the Exception class to the raise command even if it works with the class directly)\n\nHowever, the existing behavior is actually convenient: if your abstractmethod contains just a , then you can have any number of sub-classes inheriting your base class, and as long as at least one implements the abstractmethod, it will work. Even if all of them call the super() equivalent method, without checking anything else.\n\nIf an error - or any other, would be called, in a complex hierarchy, making use of mixins, and such, you'd need to check at each time you'd call if the error was raised, just to skipt it. For the record, checking if would hit the class where method is abstract with a conditional is possible, this way:\n\nSince what do you want if you reach the base of the hierarchy for a method is for it to do nothing, it is far simples if just nothing happens!\n\nNeither nor need to worry about any other class in the hierarchy, just do their thing and pass on. If A.validate would raise, both methods would have to do inside a statement, or inside a weird block, for the gain of...nothing.\n\nupdate - I just found this note on the oficial documentation:\n\nNote Unlike Java abstract methods, these abstract methods may have an implementation. This implementation can be called via the super() mechanism from the class that overrides it. This could be useful as an end-point for a super-call in a framework that uses cooperative multiple-inheritance. https://docs.python.org/3/library/abc.html#abc.abstractmethod\n\nI will even return you a personal question, if you can reply in the comments: I understand it is much less relevant in Java where one can't have multiple inheritance, so, even in a big hierarchy, the first subclass to implement the abstract method would usually be well known. But otherwise, in a Java project were one could pick one of various Base concrete classes, and proceed with others in an arbitrary order, since the abstractmethod raises, how is that resolved?"
    },
    {
        "link": "https://datacamp.com/tutorial/python-abstract-classes",
        "document": "From testing code and implementing version control to web scraping and developing packages, take the next step in your Python developer journey!"
    },
    {
        "link": "https://stackoverflow.com/questions/53213543/is-it-a-good-practice-to-put-common-methods-to-an-abstract-class-in-python",
        "document": "TL; DR; Yes, it is OK for an abstract class to have non-abstract methods.\n\nTypically what we call an abstract class is just a class that cannot be instantiated.\n\nOn the other hand what we call an interface is a class which has only method declarations but no implementations. In particular its an abstract class because it doesn't have a constructor.\n\nOf course in Python there are no real interfaces: every method has to have a body. But we can somewhat emulate interfaces via .\n\nAnyway interfaces form a subset of abstract classes. This obviously suggests that there are abstract classes that are not interfaces. This is exactly the case you are describing. Yes, abstract class may contain implemented, non-abstract methods. And it is not a bad practice. This is especially useful when a given method does not depend on concrete implementation.\n\nFor example consider an interface for a generic parser (I'm thinking about and ):\n\nIt's completely OK to give method which accepts a string instead of stream with a default implementation:\n\nalthough I would use prefix instead of . ;)"
    },
    {
        "link": "https://wscubetech.com/resources/python/data-abstraction",
        "document": ""
    },
    {
        "link": "https://geeksforgeeks.org/abstract-classes-in-python",
        "document": "In Python, an abstract class is a class that cannot be instantiated on its own and is designed to be a blueprint for other classes. Abstract classes allow us to define methods that must be implemented by subclasses, ensuring a consistent interface while still allowing the subclasses to provide specific implementations.\n\nIt defines methods that must be implemented by its subclasses, ensuring that the subclasses follow a consistent structure. ABCs allow you to define common interfaces that various subclasses can implement while enforcing a level of abstraction.\n\nPython provides the abc module to define ABCs and enforce the implementation of abstract methods in subclasses.\n• Abstract Base Class: Animal is an abstract class that inherits from ABC (Abstract Base Class). This class cannot be instantiated directly because it contains an abstract method sound(). The @abstractmethod decorator is used to mark sound() as an abstract method. This means any subclass must implement this method to be instantiated.\n• Concrete Subclass: Dog is a subclass of Animal that provides an implementation for the sound() method. This allows the Dog class to be instantiated and used.\n• Instantiation: We create an instance of Dog and call the sound() method, which returns “Bark”.\n\nThe main components of an abstract class are:\n\nAbstract methods are methods that are defined in an abstract class but do not have an implementation. They serve as a blueprint for the subclasses, ensuring that they provide their own implementation.\n• None make_sound() is an abstract method in the Animal class, so it doesn’t have any code inside it.\n\nConcrete methods are methods that have full implementations in an abstract class. These methods can be inherited by subclasses and used directly without needing to be redefined.\n• None The move() method is a concrete method in the Animal class. It is implemented and does not need to be overridden by the Dog class.\n\nAbstract properties work like abstract methods but are used for properties. These properties are declared with the decorator and marked as abstract using . Subclasses must implement these properties.\n• None species is an abstract property in the Animal class and it is marked as @abstractmethod.\n• None The Dog class implements the species property, making it a concrete subclass that can be instantiated.\n• None Abstract properties enforce that a subclass provides the property’s implementation.\n\nAbstract classes cannot be instantiated directly. This is because they contain one or more abstract methods or properties that lack implementations. Attempting to instantiate an abstract class results in a TypeError.\n• None The Animal class is abstract because it has the make_sound() method as an abstract method.\n• None If you try to instantiate Animal directly (e.g., animal = Animal()), Python raises a TypeError because you can’t instantiate a class with unimplemented abstract methods.\n• None Only subclasses that implement all abstract methods can be instantiated.\n\nWhat is the Purpose of Abstract Classes in Python?\n\nHow to Define and Use an Abstract Class in Python?\n\nWhat is the ‘ Module and How is It Used in Python?\n\nHow to Define Abstract Methods in Python?\n\nWhy Should Abstract Classes Be Used in Python?"
    },
    {
        "link": "https://docs.python.org/3/tutorial/errors.html",
        "document": "Until now error messages haven’t been more than mentioned, but if you have tried out the examples you have probably seen some. There are (at least) two distinguishable kinds of errors: syntax errors and exceptions.\n\nSyntax errors, also known as parsing errors, are perhaps the most common kind of complaint you get while you are still learning Python: The parser repeats the offending line and displays little arrows pointing at the place where the error was detected. Note that this is not always the place that needs to be fixed. In the example, the error is detected at the function , since a colon ( ) is missing just before it. The file name ( in our example) and line number are printed so you know where to look in case the input came from a file.\n\nEven if a statement or expression is syntactically correct, it may cause an error when an attempt is made to execute it. Errors detected during execution are called exceptions and are not unconditionally fatal: you will soon learn how to handle them in Python programs. Most exceptions are not handled by programs, however, and result in error messages as shown here: File , line , in : File , line , in : name 'spam' is not defined File , line , in : can only concatenate str (not \"int\") to str The last line of the error message indicates what happened. Exceptions come in different types, and the type is printed as part of the message: the types in the example are , and . The string printed as the exception type is the name of the built-in exception that occurred. This is true for all built-in exceptions, but need not be true for user-defined exceptions (although it is a useful convention). Standard exception names are built-in identifiers (not reserved keywords). The rest of the line provides detail based on the type of exception and what caused it. The preceding part of the error message shows the context where the exception occurred, in the form of a stack traceback. In general it contains a stack traceback listing source lines; however, it will not display lines read from standard input. Built-in Exceptions lists the built-in exceptions and their meanings.\n\nIt is possible to write programs that handle selected exceptions. Look at the following example, which asks the user for input until a valid integer has been entered, but allows the user to interrupt the program (using - or whatever the operating system supports); note that a user-generated interruption is signalled by raising the exception. \"Oops! That was no valid number. Try again...\" The statement works as follows.\n• None First, the try clause (the statement(s) between the and keywords) is executed.\n• None If no exception occurs, the except clause is skipped and execution of the statement is finished.\n• None If an exception occurs during execution of the clause, the rest of the clause is skipped. Then, if its type matches the exception named after the keyword, the except clause is executed, and then execution continues after the try/except block.\n• None If an exception occurs which does not match the exception named in the except clause, it is passed on to outer statements; if no handler is found, it is an unhandled exception and execution stops with an error message. A statement may have more than one except clause, to specify handlers for different exceptions. At most one handler will be executed. Handlers only handle exceptions that occur in the corresponding try clause, not in other handlers of the same statement. An except clause may name multiple exceptions as a parenthesized tuple, for example: A class in an clause matches exceptions which are instances of the class itself or one of its derived classes (but not the other way around — an except clause listing a derived class does not match instances of its base classes). For example, the following code will print B, C, D in that order: Note that if the except clauses were reversed (with first), it would have printed B, B, B — the first matching except clause is triggered. When an exception occurs, it may have associated values, also known as the exception’s arguments. The presence and types of the arguments depend on the exception type. The except clause may specify a variable after the exception name. The variable is bound to the exception instance which typically has an attribute that stores the arguments. For convenience, builtin exception types define to print all the arguments without explicitly accessing . # __str__ allows args to be printed directly, # but may be overridden in exception subclasses The exception’s output is printed as the last part (‘detail’) of the message for unhandled exceptions. is the common base class of all exceptions. One of its subclasses, , is the base class of all the non-fatal exceptions. Exceptions which are not subclasses of are not typically handled, because they are used to indicate that the program should terminate. They include which is raised by and which is raised when a user wishes to interrupt the program. can be used as a wildcard that catches (almost) everything. However, it is good practice to be as specific as possible with the types of exceptions that we intend to handle, and to allow any unexpected exceptions to propagate on. The most common pattern for handling is to print or log the exception and then re-raise it (allowing a caller to handle the exception as well): \"Could not convert data to an integer.\" The … statement has an optional else clause, which, when present, must follow all except clauses. It is useful for code that must be executed if the try clause does not raise an exception. For example: The use of the clause is better than adding additional code to the clause because it avoids accidentally catching an exception that wasn’t raised by the code being protected by the … statement. Exception handlers do not handle only exceptions that occur immediately in the try clause, but also those that occur inside functions that are called (even indirectly) in the try clause. For example:\n\nThe statement allows the programmer to force a specified exception to occur. For example: The sole argument to indicates the exception to be raised. This must be either an exception instance or an exception class (a class that derives from , such as or one of its subclasses). If an exception class is passed, it will be implicitly instantiated by calling its constructor with no arguments: If you need to determine whether an exception was raised but don’t intend to handle it, a simpler form of the statement allows you to re-raise the exception:\n\nIf an unhandled exception occurs inside an section, it will have the exception being handled attached to it and included in the error message: File , line , in : [Errno 2] No such file or directory: 'database.sqlite' During handling of the above exception, another exception occurred: File , line , in : To indicate that an exception is a direct consequence of another, the statement allows an optional clause: # exc must be exception instance or None. This can be useful when you are transforming exceptions. For example: File , line , in File , line , in The above exception was the direct cause of the following exception: File , line , in : It also allows disabling automatic exception chaining using the idiom: For more information about chaining mechanics, see Built-in Exceptions.\n\nThe statement has another optional clause which is intended to define clean-up actions that must be executed under all circumstances. For example: If a clause is present, the clause will execute as the last task before the statement completes. The clause runs whether or not the statement produces an exception. The following points discuss more complex cases when an exception occurs:\n• None If an exception occurs during execution of the clause, the exception may be handled by an clause. If the exception is not handled by an clause, the exception is re-raised after the clause has been executed.\n• None An exception could occur during execution of an or clause. Again, the exception is re-raised after the clause has been executed.\n• None If the clause executes a , or statement, exceptions are not re-raised.\n• None If the statement reaches a , or statement, the clause will execute just prior to the , or statement’s execution.\n• None If a clause includes a statement, the returned value will be the one from the clause’s statement, not the value from the clause’s statement. As you can see, the clause is executed in any event. The raised by dividing two strings is not handled by the clause and therefore re-raised after the clause has been executed. In real world applications, the clause is useful for releasing external resources (such as files or network connections), regardless of whether the use of the resource was successful.\n\nSome objects define standard clean-up actions to be undertaken when the object is no longer needed, regardless of whether or not the operation using the object succeeded or failed. Look at the following example, which tries to open a file and print its contents to the screen. The problem with this code is that it leaves the file open for an indeterminate amount of time after this part of the code has finished executing. This is not an issue in simple scripts, but can be a problem for larger applications. The statement allows objects like files to be used in a way that ensures they are always cleaned up promptly and correctly. After the statement is executed, the file f is always closed, even if a problem was encountered while processing the lines. Objects which, like files, provide predefined clean-up actions will indicate this in their documentation.\n\nThere are situations where it is necessary to report several exceptions that have occurred. This is often the case in concurrency frameworks, when several tasks may have failed in parallel, but there are also other use cases where it is desirable to continue execution and collect multiple errors rather than raise the first exception. The builtin wraps a list of exception instances so that they can be raised together. It is an exception itself, so it can be caught like any other exception. By using instead of , we can selectively handle only the exceptions in the group that match a certain type. In the following example, which shows a nested exception group, each clause extracts from the group exceptions of a certain type while letting all other exceptions propagate to other clauses and eventually to be reraised. Note that the exceptions nested in an exception group must be instances, not types. This is because in practice the exceptions would typically be ones that have already been raised and caught by the program, along the following pattern:\n\nWhen an exception is created in order to be raised, it is usually initialized with information that describes the error that has occurred. There are cases where it is useful to add information after the exception was caught. For this purpose, exceptions have a method that accepts a string and adds it to the exception’s notes list. The standard traceback rendering includes all notes, in the order they were added, after the exception. For example, when collecting exceptions into an exception group, we may want to add context information for the individual errors. In the following each exception in the group has a note indicating when this error has occurred. | ExceptionGroup: We have some problems (3 sub-exceptions)"
    },
    {
        "link": "https://geeksforgeeks.org/python-exception-handling",
        "document": "Python Exception Handling handles errors that occur during the execution of a program. Exception handling allows to respond to the error, instead of crashing the running program. It enables you to catch and manage errors, making your code more robust and user-friendly.\n\nExample: Trying to divide a number by zero will cause an exception.\n\nExplanation: In this example, dividing number by 0 raises a ZeroDivisionError. The try block contains the code that might cause an exception and the except block handles the exception, printing an error message instead of stopping the program.\n• Error : Errors are serious issues that a program should not try to handle. They are usually problems in the code’s logic or configuration and need to be fixed by the programmer. Examples include syntax errors and memory errors.\n• Exception : Exceptions are less severe than errors and can be handled by the program. They occur due to situations like invalid input, missing files or network issues.\n\nExplanation: A syntax error is a coding mistake that prevents the code from running. In contrast, an exception like ZeroDivisionError can be managed during the program’s execution using exception handling.\n\nException handling in Python is done using the try, except, else and finally blocks.\n\ntry, except, else and finally Blocks\n• try Block lets us test a block of code for errors. Python will “try” to execute the code in this block. If an exception occurs, execution will immediately jump to the except block.\n• except Block: enables us to handle the error or exception. If the code inside the try block throws an error, Python jumps to the except block and executes it. We can handle specific exceptions or use a general except to catch all exceptions.\n• else Block: is optional and if included, must follow all except blocks. The else block runs only if no exceptions are raised in the try block. This is useful for code that should execute if the try block succeeds.\n• finally Block: always runs, regardless of whether an exception occurred or not. It is typically used for cleanup operations (closing files, releasing resources).\n• try block asks for user input and tries to divide 100 by the input number.\n• else block runs if no exception occurs, displaying the result.\n• finally block runs regardless of the outcome, indicating the completion of execution.\n\nPython has many built-in exceptions, each representing a specific error condition. Some common ones include:\n\nThe base class for all built-in exceptions. The base class for all non-exit exceptions. Base class for all errors related to arithmetic operations. Raised when a division or modulo operation is performed with zero as the divisor. Raised when a numerical operation exceeds the maximum limit of a data type. Raised when an attribute reference or assignment fails. Raised when a sequence subscript is out of range. Raised when a dictionary key is not found. Raised when an operation runs out of memory. Raised when a local or global name is not found. Raised when an operation or function is applied to an object of inappropriate type. Raised when a function receives an argument of the right type but inappropriate value. Raised when an import statement has issues. Raised when a module cannot be found.\n\nWhen working with exceptions in Python, we can handle errors more efficiently by specifying the types of exceptions we expect. This can make code both safer and easier to debug.\n\nCatching specific exceptions makes code to respond to different exception types differently.\n• None The ValueError is caught because the string “str” cannot be converted to an integer.\n• None If x were 0 and conversion successful, the ZeroDivisionError would be caught when attempting to calculate its inverse.\n\nWe can catch multiple exceptions in a single block if we need to handle them in the same way or we can separate them if different types of exceptions require different handling.\n• None The ValueError is caught when trying to convert “twenty” to an integer.\n• None TypeError might occur if the operation was incorrectly applied to non-integer types, but it’s not triggered in this specific setup.\n• None IndexError would be caught if an index outside the range of the list was accessed, but in this scenario, it’s under control.\n\nHere’s a simple calculation that may fail due to various reasons.\n• None An ArithmeticError (more specific like ZeroDivisionError) might be caught if this were a number-to-number division error. However, TypeError is actually triggered here due to attempting to divide a string by a number.\n• catch-all except: is used to catch the TypeError, demonstrating the risk that the programmer might not realize the actual cause of the error (type mismatch) without more detailed error logging.\n\nWe raise an exception in Python using the raise keyword followed by an instance of the exception class that we want to trigger. We can choose from built-in exceptions or define our own custom exceptions by inheriting from Python’s built-in Exception class.\n• None The function set checks if the age is negative. If so, it raises a ValueError with a message explaining the issue.\n• None This ensures that the age attribute cannot be set to an invalid state, thus maintaining the integrity of the data.\n• Improved program reliability : By handling exceptions properly, you can prevent your program from crashing or producing incorrect results due to unexpected errors or input.\n• Simplified error handling : Exception handling allows you to separate error handling code from the main program logic, making it easier to read and maintain your code.\n• Cleaner code: With exception handling, you can avoid using complex conditional statements to check for errors, leading to cleaner and more readable code.\n• Easier debugging : When an exception is raised, the Python interpreter prints a traceback that shows the exact location where the exception occurred, making it easier to debug your code.\n• Performance overhead: Exception handling can be slower than using conditional statements to check for errors, as the interpreter has to perform additional work to catch and handle the exception.\n• Increased code complexity : Exception handling can make your code more complex, especially if you have to handle multiple types of exceptions or implement complex error handling logic.\n• Possible security risks: Improperly handled exceptions can potentially reveal sensitive information or create security vulnerabilities in your code, so it’s important to handle exceptions carefully and avoid exposing too much information about your program."
    },
    {
        "link": "https://python.land/deep-dives/python-try-except",
        "document": "Python exception handling is the process of identifying and responding to errors in a program. In other words, it is a way to deal with errors that might occur in your program. In this article, you will learn how to handle errors in Python by using the Python and keywords. It will also teach you how to create custom exceptions, which can be used to define your own specific error messages.\n\nWhat is an exception?\n\nAn exception is a condition that arises during a program’s execution. It is a signal that something unexpected happened. Python represents exceptions by an object of a specific type.\n\nIn Python, all built-in, non-system-exiting exceptions are derived from the class. Exceptions have their own descriptive names. For example, if you try to divide a number by zero, you will get a exception, which is also a subclass of the class.\n\nFor a complete hierarchy of all exceptions, you can view the Python manual if you’re interested. Here’s a small excerpt from this hierarchy to illustrate:\n\nIf your knowledge about objects, classes, and inheritance is a bit rusty, you may want to read my article on objects and classes and my article on inheritance first.\n\nWhen something unexpected occurs, we can raise an exception at the point of the error. When an exception is raised, Python stops the current flow of execution and starts looking for an exception handler that can handle it. So what is an exception handler? Here’s where the try and except statements come into play.\n\nAs the illustration demonstrates, we can create a code block by starting with a try statement. This means: try to run this code, but an exception might occur.\n\nAfter our try block, one or more except blocks must follow. This is where the magic happens. These except blocks can catch an exception, as we usually call this. In fact, many other programming languages use a statement called instead of . Each block can handle a specific type of exception.\n\nRemember: classes are hierarchical. For that reason, exceptions are hierarchical as well. Hence, except blocks must go from the most specific, like a , to less specific, like an .\n\nTo demonstrate this, imagine what happens when we start with an except block that catches Exception. This first block would catch everything because most exceptions inherit from this one, rendering the other except blocks useless.\n\nNow let’s first go back to raising an exception. When an exception is raised, the exception handler that’s able to handle the exception can be nearby, but it can also be in a different module. What’s important to realize is that Python won’t just scan your code randomly for an exception handler. Instead, the handler should be somewhere in the call stack.\n\nPlease forget about and for now. I’ll explain them in detail further down in this article. We first need to discuss call stacks to understand how an exception finds its way to an exception handler.\n\nA call stack is an ordered list of functions that are currently being executed. For example, you might call function A, which calls function B, which calls function C. We now have a call stack consisting of A, B, and C. When C raises an exception, Python will look for an exception handler in this call stack, going backward from end to start. It can be in function C (closest to the exception), in function B (somewhat farther), in function A, or even at the top level of the program where we called function A.\n\nIf Python finds a suitable except block, it executes the code in that block. If it doesn’t find one, Python handles the exception by itself. This means it will print the exception and exit the program since it has no clue what to do with it.\n\nI hope you’re still with me! If not, no worries. The examples on this page will hopefully clarify everything. You might want to revisit this section after finishing the entire article.\n\nCatching exceptions with try except\n\nLet’s finally write some actual code! To handle an exception, we need to catch it. As we just learned, we can catch an exception by using the and keywords. When an exception occurs while we are inside the block, the code in the block is executed.\n\nLet’s try a simple example first. As you hopefully know, we can’t divide by the number zero. If we do so anyway, Python will throw and exception called , which is a subclass of :\n\n\n\nIf you call a Python function inside the try block, and an exception occurs in that function, the flow of code execution stops at the point of the exception and the code in the except block is executed. Try doing this again without try and except. You’ll see that Python prints the exception for us. You can do so in the following code crumb:\n\nAlso, note that Python prints the error to stderr if you don’t handle the exception yourself. In the crumb above, this is visible because the output appears in an ‘Error’ tab instead of an ‘Output’ tab.\n\nLet’s try another, more common example. After all, who divides a number by zero, right?\n\nExceptions are likely to occur when interacting with the outside world, e.g., when working with files or networks. For example, if you try to open a file with Python, but that file doesn’t exist, you will get an exception. If you don’t have access to a file due to permissions, you will again get an exception. Let’s see how to handle these exceptions.\n\nPlease do the following:\n• Run the code below, and notice the file name (it doesn’t exist). See what happens.\n• Alter the file name to myfile.txt file and rerun the code. What happens now?\n\nThe file is not found in the first case. You should get this output:\n\nYou’ll still get an error after creating the file in the second case. This time, we’re trying to write to a file that is opened in read-only mode. For more information on these modes, read the article on opening, reading, and writing files with Python. The error should look like this:\n\nAlthough this is an error, it’s not written to the stderr output of the operating system. That’s because we handled the exception ourselves. If you removed the try.. except from the code completely and then try to write to the file in read-only mode, Python will catch the error, force the program to terminate, and show this message:\n\nThe finally and else blocks\n\nRemember the other two blocks that I asked you to forget for a while? Let’s look at those now, starting with the block.\n\nThe block is executed regardless of whether an exception occurs or not. blocks are useful, for example, when you want to close a file or a network connection regardless of what happens. After all, you want to clean up resources to prevent memory leaks.\n\nHere’s an example of this at work, in which we open a file without using the with , forcing us to close it ourselves:\n\nYou can also try this interactive example:\n\nYou should see the ‘Closing the file now’ message printed on your screen. Now change the writing mode to ‘r’ instead of ‘w’. You’ll get an error since the file does not exist. Despite this exception, we try to close the file anyway thanks to the finally block. This in turn goes wrong too: a exception is thrown because the file was never opened, and hence does not exist. You can fix this with a nested . Try it for yourself.\n\nThe else block in try-except\n\nIn addition to the and blocks, you can add an else block. The else block executes only when no exception occurs. So it differs from the finally block, since finally executes even if an exception occurs.\n\nWhen should you use the block? And why shouldn’t you just add extra code to the block? Good questions!\n\nAccording to the Python manual, using the else clause is better than adding additional code to the try clause. But why? The reasoning is that it avoids accidentally catching an exception that wasn’t raised by the code being protected by the try and except statements in the first place. I admit I don’t use else blocks very often myself. Also, I find them somewhat confusing, especially for people coming from other languages.\n\nSome exceptions are so common that you’ll inevitably encounter them. Here are a few of the most common ones:\n\nIf you like, you can try to evoke these exceptions intentionally. I promise you that you will encounter these countless times in your Python programming career. Understanding what they mean and when they occur will greatly help you debug your code.\n\nNow that we know the mechanics of handling exceptions, I’d like to share a couple of best practices with you.\n\nI’ve written about this in the blog post ‘How not to handle exceptions in Python‘. Don’t use a blank block when you want to catch a broad range of exceptions. By this, I mean something like:\n\nYou might encounter this in code samples on the web. If you do, make a habit of improving the exception handling. Why should you, and how can you improve code like the example above?\n\nAll exceptions, including system exceptions, inherit from a class called . If an clause mentions a particular class, that clause also handles any exception classes derived from that class. An empty is equivalent to , hence it will catch all possible exceptions.\n\nSo, although the syntax is allowed, I don’t recommend it. E.g., you’ll also catch KeyboardInterrupt and SystemExit exceptions, which prevent your program from exiting. Instead, use a try block with a list of explicit exceptions you can handle. Or, if you really need to, catch the base class to handle almost all the regular exceptions, but not the system ones.\n\nIf you’re feeling adventurous, you can try to catch all exceptions and see what happens:\n\nYou’ll probably need to close your terminal to stop this program. Now change the except block to catch . You will still catch almost all exceptions, but the program will exit on system exceptions like and :\n\nIt’s better to ask for forgiveness\n\nIn Python, you’ll often see a pattern where people simply try if something works, and if it doesn’t, catch the exception. In other words, it’s better to ask for forgiveness than permission. This is in contrast to other languages, where you preferably ask for permission. For example, in Java, exceptions can slow down your program, and you “ask for permission” by doing checks on an object instead of simply trying.\n\nTo make this more concrete: in Python, we often just try to access the key in a dictionary. If the key doesn’t exist, we’ll get an exception and handle it. Suppose we just converted some externally provided JSON to a dictionary and now start to use it:\n\nThis will print the error:\n\nWe could have added three checks ( if 'name' in user , , etc.) to make sure that all the fields are there. But this is not a good practice. It potentially introduces a lot of code just to check if keys exist. Instead, we ask for forgiveness in our except block once, which is much cleaner and more readable. And if you worry about performance: exceptions don’t take up that many CPU cycles in Python. Lots of comparisons are in fact slower than catching a single exception (if it occurs at all!).\n\nAll built-in, non-system-exiting exceptions are derived from the class as we learned before. All user-defined exceptions should also be derived from this class. So if we want to create our own exceptions, we need to create a subclass of the class.\n\nFor example, if you want to create an exception that indicates that a user was not found, you can create a exception. This would, in its most basic form, look like this:\n\nThis inherits all the properties and methods of , but we give it a new name to distinguish it from the class. This way, we’ll be able to specifically catch it with an except block.\n\nThe name of this exception clearly tells us the type of problem that was encountered, so as an added bonus, it functions as a form of code documentation as well. Just like well-named variables and functions, a well-named exception can be a big difference when reading back your code.\n\nWe’ll use this class in the example that follows.\n\nWe know some built-in exceptions and how to create custom exceptions. We also know how to catch exceptions with try and except. What’s left, is what’s called raising or throwing an exception. You can raise an exception yourself with the raise keyword.\n\nIn the example below, we use your previously defined . We call a function, , that fetches some user data from an imaginary database. If the user is not found, this database returns None. We decided that we don’t want to return None, which would force the caller to check for None every time. Instead, we use our custom .\n\nHere’s a little assignment. We could have used a regular Exception object instead. That way, we don’t need to define a custom one. Why is this a bad idea?\n\nYou can in fact raise a regular exception, e.g. with . But if you do, you need to catch all exceptions of type Exception. And as we know, there are a lot of those. Chances are you inadvertently catch some other exception that you’re not able to handle. For example, the database client might throw a which is also a subclass of .\n\nYou can print exceptions directly as long as you catch them properly. You may have seen examples of this above already. To be clear, here’s an example of how to catch and print an exception:\n\nIf you’d like to print the call stack, just like Python does when you don’t catch the exception yourself, you can import the traceback module:\n\nHere are some more resources to deepen your knowledge:\n• My blog article ‘How not to handle exceptions in Python‘\n• The official documentation on exceptions.\n• The official documentation on errors."
    },
    {
        "link": "https://w3schools.com/python/python_try_except.asp",
        "document": "The block lets you test a block of code for errors.\n\nThe block lets you handle the error.\n\nThe block lets you execute code when there is no error.\n\nThe block lets you execute code, regardless of the result of the try- and except blocks.\n\nWhen an error occurs, or exception as we call it, Python will normally stop and generate an error message.\n\nThese exceptions can be handled using the statement:\n\nSince the try block raises an error, the except block will be executed.\n\nWithout the try block, the program will crash and raise an error:\n\nYou can define as many exception blocks as you want, e.g. if you want to execute a special block of code for a special kind of error:\n\nPrint one message if the try block raises a and another for other errors: try:\n\n print(x)\n\nexcept NameError:\n\n print(\"Variable x is not defined\")\n\nexcept:\n\n print(\"Something else went wrong\") Try it Yourself »\n\nYou can use the keyword to define a block of code to be executed if no errors were raised:\n\nThe block, if specified, will be executed regardless if the try block raises an error or not.\n\nThis can be useful to close objects and clean up resources:\n\nThe program can continue, without leaving the file object open.\n\nAs a Python developer you can choose to throw an exception if a condition occurs.\n\nTo throw (or raise) an exception, use the keyword.\n\nThe keyword is used to raise an exception.\n\nYou can define what kind of error to raise, and the text to print to the user."
    },
    {
        "link": "https://datacamp.com/tutorial/exception-handling-python",
        "document": "Master the basics of data analysis with Python in just four hours. This online course will introduce the Python interface and explore popular packages."
    }
]