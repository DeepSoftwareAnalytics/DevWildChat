[
    {
        "link": "https://stackoverflow.com/questions/16136383/reading-a-text-file-using-openfiledialog-in-windows-forms",
        "document": "I am new to the OpenFileDialog function, but have the basics figured out. What I need to do is open a text file, read the data from the file (text only) and correctly place the data into separate text boxes in my application. Here's what I have in my \"open file\" event handler:\n\nThe text file I need to read is this (for homework, I need to read this exact file), It has an employee number, name, address, wage, and hours worked:\n\nIn the text file I was given, there are 4 more employees with info immediately after this in the same format. You can see that the employee wage and hours are on the same line, not a typo.\n\nI have an employee class here:\n\nSo I need to pull the text from that file into my Employee class, then output the data to the correct textbox in the windows forms application. I am having trouble understanding how to do this right. Do I need to use a streamreader? Or is there another, better way in this instance? Thank you."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/desktop/winforms/controls/how-to-open-files-using-the-openfiledialog-component?view=netframeworkdesktop-4.8",
        "document": "How to: Open files with the OpenFileDialog\n\nThe System.Windows.Forms.OpenFileDialog component opens the Windows dialog box for browsing and selecting files. To open and read the selected files, you can use the OpenFileDialog.OpenFile method, or create an instance of the System.IO.StreamReader class. The following examples show both approaches.\n\nIn .NET Framework, to get or set the FileName property requires a privilege level granted by the System.Security.Permissions.FileIOPermission class. The examples run a FileIOPermission permission check, and can throw an exception due to insufficient privileges if run in a partial-trust context. For more information, see Code access security basics.\n\nYou can build and run these examples as .NET Framework apps from the C# or Visual Basic command line. For more information, see Command-line building with csc.exe or Build from the command line.\n\nStarting with .NET Core 3.0, you can also build and run the examples as Windows .NET Core apps from a folder that has a .NET Core Windows Forms <folder name>.csproj project file.\n\nExample: Read a file as a stream with StreamReader\n\nThe following example uses the Windows Forms Button control's Click event handler to open the OpenFileDialog with the ShowDialog method. After the user chooses a file and selects OK, an instance of the StreamReader class reads the file and displays its contents in the form's text box. For more information about reading from file streams, see FileStream.BeginRead and FileStream.Read.\n\nExample: Open a file from a filtered selection with OpenFile\n\nThe following example uses the Button control's Click event handler to open the OpenFileDialog with a filter that shows only text files. After the user chooses a text file and selects OK, the OpenFile method is used to open the file in Notepad."
    },
    {
        "link": "https://stackoverflow.com/questions/50555219/how-to-use-openfiledialog-to-open-any-file-as-text-in-c",
        "document": "What you are doing at the moment is starting a with the argument , calling on the process and setting this as text in the TextBox. If the path was valid, the result would probably be something like \"System.Diagnostics.Process\". But since you use as a path, your application probably crashes with a file not found error.\n\nTo get the selected file of an , use . (See the docs here)\n\nWhat I think you actually want to do, is read from the file and write its contents as text to the TextBox. To do this, you need a , like so:\n\nThis way, you open the file with the StreamReader, read its contents and then assign them to the text box.\n\nThe statement is there because a needs to be disposed of after you're done with it so that the file is no longer in use and all resources are released. The using statement does this for you automatically."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.openfiledialog?view=windowsdesktop-9.0",
        "document": "The following code example creates an OpenFileDialog, sets several properties to define the file extension filter and dialog behavior, and displays the dialog box using the CommonDialog.ShowDialog method. The example requires a form with a Button placed on it and a reference to the System.IO namespace added to it.\n\nThis class allows you to check whether a file exists and to open it. The ShowReadOnly property determines whether a read-only check box appears in the dialog box. The ReadOnlyChecked property indicates whether the read-only check box is checked.\n\nMost of the core functionality for this class is found in the FileDialog class.\n\nOn a right-to-left operating system, setting the containing form's RightToLeft property to RightToLeft.Yes localizes the dialog's File Name, Open, and Cancel buttons. If the property is not set to RightToLeft.Yes, English text is used instead.\n\nIf you want to give the user the ability to select a folder instead of a file, use FolderBrowserDialog instead.\n\nInitializes an instance of the OpenFileDialog class. Gets or sets a value indicating whether the dialog box automatically adds an extension to a file name if the user omits the extension. (Inherited from FileDialog) Gets or sets a value indicating whether the dialog box adds the file being opened or saved to the recent list. (Inherited from FileDialog) Gets or sets a value indicating whether this FileDialog instance should automatically upgrade appearance and behavior when running on Windows Vista. (Inherited from FileDialog) Gets a value indicating whether the component can raise an event. (Inherited from Component) Gets or sets a value indicating whether the dialog box displays a warning if the user specifies a file name that does not exist. Gets or sets a value indicating whether the dialog box displays a warning if the user specifies a path that does not exist. (Inherited from FileDialog) Gets or sets the GUID to associate with this dialog state. Typically, state such as the last visited folder and the position and size of the dialog is persisted based on the name of the executable file. By specifying a GUID, an application can have different persisted states for different versions of the dialog within the same application (for example, an import dialog and an open dialog). This functionality is not available if an application is not using visual styles or if AutoUpgradeEnabled is set to . (Inherited from FileDialog) Gets the IContainer that contains the Component. (Inherited from Component) Gets the custom places collection for this FileDialog instance. (Inherited from FileDialog) Gets or sets the default file name extension. (Inherited from FileDialog) Gets or sets a value indicating whether the dialog box returns the location of the file referenced by the shortcut or whether it returns the location of the shortcut (.lnk). (Inherited from FileDialog) Gets a value that indicates whether the Component is currently in design mode. (Inherited from Component) Gets the list of event handlers that are attached to this Component. (Inherited from Component) Gets or sets a string containing the file name selected in the file dialog box. (Inherited from FileDialog) Gets the file names of all selected files in the dialog box. (Inherited from FileDialog) Gets or sets the current file name filter string, which determines the choices that appear in the \"Save as file type\" or \"Files of type\" box in the dialog box. (Inherited from FileDialog) Gets or sets the index of the filter currently selected in the file dialog box. (Inherited from FileDialog) Gets or sets the initial directory displayed by the file dialog box. (Inherited from FileDialog) Gets the Win32 instance handle for the application. (Inherited from FileDialog) Gets or sets a value indicating whether the dialog box allows multiple files to be selected. Gets or sets a value indicating whether the OK button of the dialog box is disabled until the user navigates the view or edits the filename (if applicable). (Inherited from FileDialog) Gets values to initialize the FileDialog. (Inherited from FileDialog) Gets or sets a value indicating whether the read-only check box is selected. Gets or sets a value indicating whether the dialog box restores the directory to the previously selected directory before closing. (Inherited from FileDialog) Gets the file name and extension for the file selected in the dialog box. The file name does not include the path. Gets an array of file names and extensions for all the selected files in the dialog box. The file names do not include the path. Gets or sets a value indicating whether the dialog box allows selection of read-only files. Gets or sets a value indicating whether the Help button is displayed in the file dialog box. (Inherited from FileDialog) Gets or sets a value indicating whether the dialog box displays hidden and system files. (Inherited from FileDialog) Gets or sets a value indicating whether the items shown by default in the view's navigation pane are shown. (Inherited from FileDialog) Gets or sets a value indicating whether the dialog box shows a preview for selected files. Gets or sets a value indicating whether the dialog box contains a read-only check box. Gets or sets the ISite of the Component. (Inherited from Component) Gets or sets whether the dialog box supports displaying and saving files that have multiple file name extensions. (Inherited from FileDialog) Gets or sets an object that contains data about the control. (Inherited from CommonDialog) Gets or sets the file dialog box title. (Inherited from FileDialog) Gets or sets a value indicating whether the dialog box accepts only valid Win32 file names. (Inherited from FileDialog) Creates an object that contains all the relevant information required to generate a proxy used to communicate with a remote object. (Inherited from MarshalByRefObject) Releases all resources used by the Component. (Inherited from Component) Releases the unmanaged resources used by the Component and optionally releases the managed resources. (Inherited from Component) Determines whether the specified object is equal to the current object. (Inherited from Object) Retrieves the current lifetime service object that controls the lifetime policy for this instance. (Inherited from MarshalByRefObject) Returns an object that represents a service provided by the Component or by its Container. (Inherited from Component) Gets the Type of the current instance. (Inherited from Object) Defines the common dialog box hook procedure that is overridden to add specific functionality to the file dialog box. (Inherited from FileDialog) Obtains a lifetime service object to control the lifetime policy for this instance. (Inherited from MarshalByRefObject) Opens the file selected by the user, with read-only permission. The file is specified by the FileName property. Defines the owner window procedure that is overridden to add specific functionality to a common dialog box. (Inherited from CommonDialog) Resets all properties to their default values. Runs a common dialog box with the specified owner. (Inherited from CommonDialog) Provides a string version of this object. (Inherited from FileDialog) Occurs when the component is disposed by a call to the Dispose() method. (Inherited from Component) Occurs when the user clicks on the Open or Save button on a file dialog box. (Inherited from FileDialog) Occurs when the user clicks the Help button on a common dialog box. (Inherited from CommonDialog)\n• How to: Read Text from a File"
    },
    {
        "link": "https://vbforums.com/showthread.php?497289-RESOLVED-Load-text-file-through-OpenFileDialog",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/183589/best-practice-for-exception-handling-in-a-windows-forms-application",
        "document": "The main things I'm currently trying to work out are:\n\nWould anyone like to share any pearls of wisdom on the subject? Post any common mistakes you've seen newbies like myself make, and any general advice on handling exceptions in a way that will my application more stable and robust.\n\nI'm currently in the process of writing my first Windows Forms application. I've read a few C# books now so I've got a relatively good understanding of what language features C# has to deal with exceptions. They're all quite theoretical however so what I haven't got yet is a feel for how to translate the basic concepts into a good exception-handling model in my application.\n\nYou absolutely should have a centralized exception handling policy in place. This can be as simple as wrapping in a try/catch, failing fast with a graceful error message to the user. This is the \"last resort\" exception handler. Preemptive checks are always correct if feasible, but not always perfect. For example, between the code where you check for a file's existence and the next line where you open it, the file could have been deleted or some other issue may impede your access. You still need try/catch/finally in that world. Use both the preemptive check and the try/catch/finally as appropriate. Never \"swallow\" an exception, except in the most well-documented cases when you are absolutely, positively sure that the exception being thrown is livable. This will almost never be the case. (And if it is, make sure you're swallowing only the specific exception class -- don't ever swallow .) When building libraries (used by your app), do not swallow exceptions, and do not be afraid to let the exceptions bubble up. Do not re-throw unless you have something useful to add. Do not ever (in C#) do this: As you will erase the call stack. If you must re-throw (which is occasionally necessary, such as when using the Exception Handling Block of Enterprise Library), use the following: At the end of the day, the very vast majority of exceptions thrown by a running application should be exposed somewhere. They should not be exposed to end users (as they often contain proprietary or otherwise valuable data), but rather usually logged, with administrators notified of the exception. The user can be presented with a generic dialog box, maybe with a reference number, to keep things simple. Exception handling in .NET is more art than science. Everyone will have their favorites to share here. These are just a few of the tips I've picked up using .NET since day 1, techniques which have saved my bacon on more than one occasion. Your mileage may vary.\n\nAll of the advice posted here so far is good and worth heeding. One thing I'd like to expand on is your question \"Do handling exceptions which might be thrown have a performance hit compared with pre-emptively testing things like whether a file on disk exists?\" The naive rule of thumb is \"try/catch blocks are expensive.\" That's not actually true. Trying isn't expensive. It's the catching, where the system has to create an Exception object and load it up with the stack trace, that's expensive. There are many cases in which the exception is, well, exceptional enough that it's perfectly fine to wrap the code in a try/catch block. For instance, if you're populating a Dictionary, this: is often faster than doing this: for every single item you're adding, because the exception only gets thrown when you are adding a duplicate key. (LINQ aggregate queries do this.) In the example you gave, I'd use try/catch almost without thinking. First, just because the file exists when you check for it doesn't mean that it's going to exist when you open it, so you should really handle the exception anyway. Second, and I think more importantly, unless your a) your process is opening thousands of files and b) the odds of a file it's trying to open not existing are not trivially low, the performance hit of creating the exception is not something you're ever going to notice. Generally speaking, when your program is trying to open a file, it's only trying to open one file. That's a case where writing safer code is almost certainly going to be better than writing the fastest possible code.\n\nHere are a few guidelines that I follow\n• None Fail-Fast: This is more of a exception generating guideline, For every assumption that you make and every parameter that you are getting into a function do a check to make sure that you're starting off with the right data and that the assumptions you're making are correct. Typical checks include, argument not null, argument in expected range etc.\n• None When rethrowing preserve stack trace - This simply translates to using throw when rethrowing instead of throw new Exception(). Alternatively if you feel that you can add more information then wrap the original exception as an inner exception. But if you're catching an exception only to log it then definitely use throw;\n• None Do not catch exceptions that you cannot handle, so don't worry about things like OutOfMemoryException because if they occur you won't be able to do much anyways.\n• None Do hook global exception handlers and make sure to log as much information as possible. For winforms hook both the appdomain and thread unhandled exception events.\n• None Performance should only be taken into consideration when you've analyzed the code and seen that it's causing a performance bottleneck, by default optimize for readability and design. So about your original question on the file existence check, I would say it depends, If you can do something about the file not being there, then yes do that check otherwise if all you're going to do is throw an exception if the file's not there then I don't see the point.\n• None There are definitely times when empty catch blocks are required, I think people who say otherwise have not worked on codebases that have evolved over several releases. But they should be commented and reviewed to make sure that they're really needed. The most typical example is developers using try/catch to convert string to integer instead of using ParseInt().\n• None If you expect the caller of your code to be able to handle error conditions then create custom exceptions that detail what the un excepected situation is and provide relevant information. Otherwise just stick to built-in exception types as much as possible.\n\nThe golden rule that have tried to stick to is handle the exception as close to the source as possible. If you must re-throw an exception try to add to it, re-throwing a FileNotFoundException does not help much but throwing a ConfigurationFileNotFoundException will allow it to be captured and acted upon somewhere up the chain. Another rule I try to follow is not to use try/catch as a form of program flow, so I do verify files/connections, ensure objects have been initiated, ect.. prior to using them. Try/catch should be for Exceptions, things you can not control. As for an empty catch block, if you are doing anything of importance in the code that generated the exception you should re-throw the exception at a minimum. If there is no consequences of the code that threw the exception not running why did you write it in the first place.\n\nYou have to think about the user. The application crash is the last thing the user wants. Therefore any operation that can fail should have a try catch block at the ui level. It's not necessary to use try catch in every method, but every time the user does something it must be able to handle generic exceptions. That by no means frees you from checking everything to prevent exceptions in the first case, but there is no complex application without bugs and the OS can easily add unexpected problems, therefore you must anticipate the unexpected and make sure if a user wants to use one operation there won't be data loss because the app crashes. There is no need to ever let your app crash, if you catch exceptions it will never be in an indeterminate state and the user is ALWAYS inconvenienced by a crash. Even if the exception is at the top most level, not crashing means the user can quickly reproduce the exception or at least record the error message and therefore greatly help you to fix the problem. Certainly a lot more than getting a simple error message and then seeing only windows error dialog or something like that. That's why you must NEVER just be conceited and think your app has no bugs, that is not guaranteed. And it is a very small effort to wrap some try catch blocks about the appropriate code and show an error message / log the error. As a user, I certainly get seriously pissed whenever a brows or office app or whatever crashes. If the exception is so high that the app can't continue it's better to display that message and tell the user what to do (restart, fix some os settings, report the bug, etc.) than to simply crash and that's it."
    },
    {
        "link": "https://stackoverflow.com/questions/19838595/how-to-properly-handle-exceptions-when-working-with-files-in-c-sharp",
        "document": "I've read many blogs/articles/book chapters about proper exception handling and still this topic is not clear to me. I will try to illustrate my question with following example.\n\nConsider the class method that has following requirements:\n• read the file content for each file or skip if there is any problem trying to do that\n\nSo the specs are straightforward and here is how I can start coding:\n\nNow note that the 2. from the specs says that method should \"skip any file which content can't be read for some reason\". So there could be many different reasons for this to happen (eg. file not existing, file access denied due to lack of security permissions, file being locked and in use by some other application etc...) but the point is that I should not care what the reason is, I just want to read file's content if possible or skip the file if not. I don't care what the error is...\n\nSo how to properly implement this method then?\n\nOK the first rule of proper exception handling is never catch general Exception. So this code is not good then:\n\nThe next rule of proper exception handlig says: catch only specific exceptions you can handle. Well I do not I care about handling any specific exceptions that can be thrown, I just want to check if file can be read or not. How can I do that in a proper, the best-practice way?"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/standard/exceptions/best-practices-for-exceptions",
        "document": "Proper exception handling is essential for application reliability. You can intentionally handle expected exceptions to prevent your app from crashing. However, a crashed app is more reliable and diagnosable than an app with undefined behavior.\n\nThis article describes best practices for handling and creating exceptions.\n\nThe following best practices concern how you handle exceptions:\n• Use try/catch/finally blocks to recover from errors or release resources\n• Design classes so that exceptions can be avoided\n\nUse try/catch/finally blocks to recover from errors or release resources\n\nFor code that can potentially generate an exception, and when your app can recover from that exception, use / blocks around the code. In blocks, always order exceptions from the most derived to the least derived. (All exceptions derive from the Exception class. More derived exceptions aren't handled by a clause that's preceded by a clause for a base exception class.) When your code can't recover from an exception, don't catch that exception. Enable methods further up the call stack to recover if possible.\n\nClean up resources that are allocated with either statements or blocks. Prefer statements to automatically clean up resources when exceptions are thrown. Use blocks to clean up resources that don't implement IDisposable. Code in a clause is almost always executed even when exceptions are thrown.\n\nFor conditions that are likely to occur but might trigger an exception, consider handling them in a way that avoids the exception. For example, if you try to close a connection that's already closed, you'll get an . You can avoid that by using an statement to check the connection state before trying to close it.\n\nIf you don't check the connection state before closing, you can catch the exception.\n\nThe approach to choose depends on how often you expect the event to occur.\n• None Use exception handling if the event doesn't occur often, that is, if the event is truly exceptional and indicates an error, such as an unexpected end-of-file. When you use exception handling, less code is executed in normal conditions.\n• None Check for error conditions in code if the event happens routinely and could be considered part of normal execution. When you check for common error conditions, less code is executed because you avoid exceptions. Up-front checks eliminate exceptions most of the time. However, there can be race conditions where the guarded condition changes between the check and the operation, and in that case, you could still incur an exception.\n\nIf the performance cost of exceptions is prohibitive, some .NET library methods provide alternative forms of error handling. For example, Int32.Parse throws an OverflowException if the value to be parsed is too large to be represented by Int32. However, Int32.TryParse doesn't throw this exception. Instead, it returns a Boolean and has an parameter that contains the parsed valid integer upon success. Dictionary<TKey,TValue>.TryGetValue has similar behavior for attempting to get a value from a dictionary.\n\nIt's better to catch OperationCanceledException instead of TaskCanceledException, which derives from , when you call an asynchronous method. Many asynchronous methods throw an OperationCanceledException exception if cancellation is requested. These exceptions enable execution to be efficiently halted and the callstack to be unwound once a cancellation request is observed.\n\nAsynchronous methods store exceptions that are thrown during execution in the task they return. If an exception is stored into the returned task, that exception will be thrown when the task is awaited. Usage exceptions, such as ArgumentException, are still thrown synchronously. For more information, see Asynchronous exceptions.\n\nDesign classes so that exceptions can be avoided\n\nA class can provide methods or properties that enable you to avoid making a call that would trigger an exception. For example, the FileStream class provides methods that help determine whether the end of the file has been reached. You can call these methods to avoid the exception that's thrown if you read past the end of the file. The following example shows how to read to the end of a file without triggering an exception:\n\nAnother way to avoid exceptions is to return (or default) for most common error cases instead of throwing an exception. A common error case can be considered a normal flow of control. By returning (or default) in these cases, you minimize the performance impact to an app.\n\nFor value types, consider whether to use or as the error indicator for your app. By using , becomes instead of . Sometimes, adding can make it clearer when a value is present or absent. Other times, adding can create extra cases to check that aren't necessary and only serve to create potential sources of errors.\n\nCallers should be able to assume that there are no side effects when an exception is thrown from a method. For example, if you have code that transfers money by withdrawing from one account and depositing in another account, and an exception is thrown while executing the deposit, you don't want the withdrawal to remain in effect.\n\nThe preceding method doesn't directly throw any exceptions. However, you must write the method so that the withdrawal is reversed if the deposit operation fails.\n\nOne way to handle this situation is to catch any exceptions thrown by the deposit transaction and roll back the withdrawal.\n\nThis example illustrates the use of to rethrow the original exception, making it easier for callers to see the real cause of the problem without having to examine the InnerException property. An alternative is to throw a new exception and include the original exception as the inner exception.\n\nOnce an exception is thrown, part of the information it carries is the stack trace. The stack trace is a list of the method call hierarchy that starts with the method that throws the exception and ends with the method that catches the exception. If you rethrow an exception by specifying the exception in the statement, for example, , the stack trace is restarted at the current method and the list of method calls between the original method that threw the exception and the current method is lost. To keep the original stack trace information with the exception, there are two options that depend on where you're rethrowing the exception from:\n• If you rethrow the exception from within the handler ( block) that's caught the exception instance, use the statement without specifying the exception. Code analysis rule CA2200 helps you find places in your code where you might inadvertently lose stack trace information.\n• If you're rethrowing the exception from somewhere other than the handler ( block), use ExceptionDispatchInfo.Capture(Exception) to capture the exception in the handler and ExceptionDispatchInfo.Throw() when you want to rethrow it. You can use the ExceptionDispatchInfo.SourceException property to inspect the captured exception.\n\nThe following example shows how the ExceptionDispatchInfo class can be used, and what the output might look like.\n\nIf the file in the example code doesn't exist, the following output is produced:\n\nThe following best practices concern how you throw exceptions:\n\nIntroduce a new exception class only when a predefined one doesn't apply. For example:\n• If a property set or method call isn't appropriate given the object's current state, throw an InvalidOperationException exception.\n• If invalid parameters are passed, throw an ArgumentException exception or one of the predefined classes that derive from ArgumentException.\n\nIt's common for a class to throw the same exception from different places in its implementation. To avoid excessive code, create a helper method that creates the exception and returns it. For example:\n\nSome key .NET exception types have such static helper methods that allocate and throw the exception. You should call these methods instead of constructing and throwing the corresponding exception type:\n\nIf you're implementing an asynchronous method, call CancellationToken.ThrowIfCancellationRequested() instead of checking if cancellation was requested and then constructing and throwing OperationCanceledException. For more information, see CA2250.\n\nThe error message the user sees is derived from the Exception.Message property of the exception that was thrown, and not from the name of the exception class. Typically, you assign a value to the Exception.Message property by passing the message string to the argument of an Exception constructor.\n\nFor localized applications, you should provide a localized message string for every exception that your application can throw. You use resource files to provide localized error messages. For information on localizing applications and retrieving localized strings, see the following articles:\n• How to: Create user-defined exceptions with localized exception messages\n\nWrite clear sentences and include ending punctuation. Each sentence in the string assigned to the Exception.Message property should end in a period. For example, \"The log table has overflowed.\" uses correct grammar and punctuation.\n\nPlace throw statements where the stack trace will be helpful. The stack trace begins at the statement where the exception is thrown and ends at the statement that catches the exception.\n\nDon't raise exceptions in clauses. For more information, see code analysis rule CA2219.\n\nSome methods, such as , , and methods, static constructors, and equality operators, shouldn't throw exceptions. For more information, see code analysis rule CA1065.\n\nIn task-returning methods, you should validate arguments and throw any corresponding exceptions, such as ArgumentException and ArgumentNullException, before entering the asynchronous part of the method. Exceptions that are thrown in the asynchronous part of the method are stored in the returned task and don't emerge until, for example, the task is awaited. For more information, see Exceptions in task-returning methods.\n\nThe following best practices concern custom exception types:\n\nWhen a custom exception is necessary, name it appropriately and derive it from the Exception class. For example:\n\nUse at least the three common constructors when creating your own exception classes: the parameterless constructor, a constructor that takes a string message, and a constructor that takes a string message and an inner exception.\n• Exception(String, Exception), which accepts a string message and an inner exception.\n\nFor an example, see How to: Create user-defined exceptions.\n\nProvide additional properties for an exception (in addition to the custom message string) only when there's a programmatic scenario where the additional information is useful. For example, the FileNotFoundException provides the FileName property."
    },
    {
        "link": "https://stackify.com/csharp-exception-handling-best-practices",
        "document": "Welcome to Stackify’s guide to C# exception handling. In this post, we cover the following topics:\n• How to Create Your Own Custom C# Exception Types\n• Why is this topic so important\n\nIn modern languages like C#, problems are typically modeled using exceptions. Jeff Atwood (of StackOverflow fame) once called exceptions “the bread and butter of modern programming languages.” That should give you an idea of how important this construct is.\n\nRegrettably, booming software developers overlook a crucial subject in their education – effectively managing errors and other code-related issues. In my personal experience, this topic receives insufficient attention.\n\nTutorials and lessons showcasing sample application development too often skip how you manage exceptions, omitting this step for brevity’s sake.\n\nAnd this is a shame, since we could argue that software development is all about handling errors and managing exceptions. When you prioritize brevity, too many programming students become programming professionals who lack an understanding of real-world exception-handling mechanisms.\n\nThis post is our humble contribution to changing that scenario. Let’s dig in.\n\nWhat is an Exception?\n\nExceptions are a type of error that occurs during the execution of an application. Typically, problems that are not anticipated result in errors, whereas the application’s code intentionally foresees exceptions due to various reasons.\n\nApplications use exception handling logic to explicitly handle the exceptions when they happen. Exceptions can occur for a wide variety of reasons. From the infamous NullReferenceException to a database query timeout.\n\nThe Anatomy of C# Exceptions\n\nExceptions allow an application to transfer control from one part of the code to another. When an exception occurs, it disrupts the ongoing code flow and returns control to a parent try-catch block. In C#, you handle exceptions using the following keywords:\n• try – A try block encloses a section of code. When code throws an exception within this block, the corresponding catch handles the exception\n• catch – When an exception happens, the code within the Catch block executes. This is where you are able to handle the exception, log it, or ignore it\n• finally – The finally block enables the execution of specific code irrespective of exception. For instance, it facilitates the disposal of an object that requires disposal\n\nThe C# try and catch keywords help establish a try-catch block, which surrounds code capable of throwing exceptions. This block serves to manage potential exceptions that might arise during execution.\n\nIn case an exception occurs, this try-catch block will manage the exception, which guarantees the application avoids triggering an unhandled exception, user errors, or application crash.\n\nHere, we present a straightforward instance of a method that might raise an exception. We’ll delve into the correct approach of employing a try-catch-finally construct to manage errors effectively.\n\nYour exception handling code can utilize multiple C# catch statements for different types of exceptions, which can be very useful depending on what your code is doing.\n\nIn the previous example, ArgumentNullException occurs only when the website URL passed in is null. A WebException is caused by a wide array of issues. Catching specific types of exceptions can help tailor how to handle them.\n\nException filters introduced in C# 6 enable you to have even more control over your catch blocks and further tailor how you handle specific exceptions. These features help you fine-tune exactly how you handle exceptions and which ones you want to catch.\n\nBefore C# 6, you would have had to catch all types of WebException and handle them. You can now select to manage them only in specific situations and allow different situations to rise to the calling code. Here is a modified example with filters:\n\nProper exception handling is critical to all application code. In the programming world, we often rely on numerous common exceptions that see frequent use. The most common being the dreaded null reference exception. Below are some of the common C# Exception types that you will see regularly.\n\nThe follow is a list of common .NET exceptions:\n• System.NullReferenceException – Very common exception related to calling a method on a null object reference\n• System.IndexOutOfRangeException – Occurs attempting to access an array element that does not exist\n• System.IO.IOException – Used around many file I/O type operations\n• System.StackOverflowException – If a method calls itself recursively, you may get this exception\n• System.OutOfMemoryException – If your app runs out of memory\n• System.InvalidCastException – When attempting to convert an object to an incompatible type\n• System.ObjectDisposedException – Attempting to utilize an object that has already undergone disposal\n\nHow to Create Your Own C# Custom Exception Types\n\nC# exceptions, akin to any other C# object, take the form of classes. All exceptions inherit from a base System.Exception class. You can use many common exceptions within your own code. Commonly, developers use the generic ApplicationException or Exception object to throw custom exceptions. However, you can also create your own type of exceptions.\n\nCrafting your unique C# custom exceptions are most beneficial when you intend to catch a particular exception type and manage it distinctively. Custom exceptions can also be helpful to track a very specific type of exception that you deem extremely critical. You can create a custom exception type to monitor application errors, then use an error monitoring tool to keep track of the logs.\n\nAt Stackify by Netreo, we have created a few custom exception types. One good example is a ClientBillingException. Billing is something we don’t want to mess up. And if it does happen, we want to prioritize handling those exceptions.\n\nUsing a custom exception type, we can write special code to handle that exception. We can also monitor our application for that specific type of exception and notify the on-call person when it happens.\n• Calling code can do custom handling of the custom exception type\n• Ability to do custom monitoring around that custom exception type\n\nHere is a simple example from our code:\n\nWhat Are First Chance Exceptions?\n\nExperiencing numerous exceptions is common; we often throw, catch and subsequently disregard them. The .NET Framework’s internals also throw exceptions that people simply discard. One of the features of C# is something called first chance exceptions, which gives you visibility into every single .NET Exception being thrown.\n\nThe usage of code like the one below is widespread in applications. This code can throw thousands of exceptions a minute and nobody would ever know it. This code is from another blog post about an app that had serious performance problems due to bad exception handling.\n\nIf the reader is null, exceptions will occur.\n\nIf columnName is null, exceptions will occur.\n\nIf columnName does not exist in the results, exceptions will occur.\n\nIf the value for the column is null, exceptions will occur.\n\nIf the value is not a proper DateTime, exceptions will occur.\n\nHow to Enable First Chance Exceptions with Visual Studio\n\nWhen you run your application in Visual Studio, the debugger is running. You can make Visual Studio pause if a C# Exception happens, which can help you find exceptions in your code that you did not know existed.\n\nTo access Exception Settings, go to Debug -> Windows -> Exception Settings\n\nUnder “Common Language Runtime Exceptions” you can select the exceptions you want the debugger to break for automatically. We would suggest just toggling the checkbox for all. When you break for an exception, you can instruct the system to ignore that specific type of exception,if you want to exclude it.\n\nHow to View All Exceptions with Prefix\n\nPrefix, Stackify by Netreo’s .NET profiler, can also show you all of your exceptions and more. Check out the latest on Prefix or start your free trial today!\n\nStackify by Netreo’s Retrace solution for your servers can also collect all first chance exceptions via the .NET profiler. Without any code or config changes, Retrace will automatically collect and show you all of your exceptions.\n\nHow to Subscribe to First Chance Exceptions in Your Code\n\nThe .NET Framework provides a way to subscribe to an event to get a callback anytime an Exception occurs. You could use this feature to capture all of the exceptions in your apps and output exceptions to your Debug window for easy visibility without cluttering your log files.\n\nWhen your console app first starts, you only want to do this once in the Main() method. Or, when an ASP.NET web app starts, you only want to do this once at startup.\n\nProper exception handling is critical for any application. A key part of this process is using a logging library, where you can log exceptions and keep a record of any that occur. Please check out our guide to C# Logging Best Practices to learn more on this subject.\n\nYou can also log your exceptions using NLog, Serilog or log4net. All three frameworks give you the ability to log your exceptions to a file. Each framework enables you to send your logs to various other targets, like a database, Windows Event Viewer, email or an error monitoring service.\n\nExceptions play a critical role in identifying issues within your code, so logging every exception in your application is crucial.\n\nLogging more contextual details helps with troubleshooting an exceptions,knowing the specific customer involved and understanding the key variables in use.\n\nTo learn more about logging contextual data, read this: What is structured logging and why developers need it\n\nWhy Logging Exceptions to a File Is Not Enough\n\nLogging your exceptions to a file is a good best practice. However, this is not enough once your application is running in production. If you don’t log into each server every day and check the log files, you won’t know the exceptions happen. That file becomes a black hole.\n\nAn error monitoring service is a key tool for any development team that allows you to collect all of your exceptions in a central location.\n• View and search all exceptions across all servers and applications\n• Receive email alerts on new exceptions or high error rates\n\nC# Exception Handling: What Comes Next?\n\nError management does not receive enough attention in software development education. This lack of focus is surprising, since handling errors is a basic concern when you write applications.\n\nC#, being a modern language, uses exceptions for handling problematic scenarios in the code. So, learning proper exception handling is essential when you use that language.\n\nIn this post, we’ve offered a comprehensive guide on C# exception handling, covered the basics, like what exceptions are and why they matter, and explored more advanced topics, specifically those related to C#.\n\nWhat should be your next step? For one, don’t stop studying. There is plenty of useful content on exceptions and related topics around the web. As a C# developer, you might find the Microsoft technical documentation portal particularly useful.\n\nAlso, keep reading the Stackify blog, where we often publish content on various tech topics that might be useful for you.\n\nFinally, leverage the power of tools available to you, including Prefix to monitor all exceptions happening in your web app, as they happen. Besides C#/.NET, Prefix is also available for Java. Download and try Prefix today."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/standard/io/handling-io-errors",
        "document": "In addition to the exceptions that can be thrown in any method call (such as an OutOfMemoryException when a system is stressed or an NullReferenceException due to programmer error), .NET file system methods can throw the following exceptions:\n• System.IO.IOException, the base class of all System.IO exception types. It is thrown for errors whose return codes from the operating system don't directly map to any other exception type.\n• System.ArgumentException, which is thrown for invalid path characters on .NET Framework and on .NET Core 2.0 and previous versions.\n• System.NotSupportedException, which is thrown for invalid colons in .NET Framework.\n• System.Security.SecurityException, which is thrown for applications running in limited trust that lack the necessary permissions on .NET Framework only. (Full trust is the default on .NET Framework.)\n\nBecause the file system is an operating system resource, I/O methods in both .NET Core and .NET Framework wrap calls to the underlying operating system. When an I/O error occurs in code executed by the operating system, the operating system returns error information to the .NET I/O method. The method then translates the error information, typically in the form of an error code, into a .NET exception type. In most cases, it does this by directly translating the error code into its corresponding exception type; it does not perform any special mapping of the error based on the context of the method call.\n\nFor example, on the Windows operating system, a method call that returns an error code of (or 0x02) maps to a FileNotFoundException, and an error code of (or 0x03) maps to a DirectoryNotFoundException.\n\nHowever, the precise conditions under which the operating system returns particular error codes is often undocumented or poorly documented. As a result, unexpected exceptions can occur. For example, because you are working with a directory rather than a file, you would expect that providing an invalid directory path to the DirectoryInfo constructor throws a DirectoryNotFoundException. However, it may also throw a FileNotFoundException.\n\nBecause of this reliance on the operating system, identical exception conditions (such as the directory not found error in our example) can result in an I/O method throwing any one of the entire class of I/O exceptions. This means that, when calling I/O APIs, your code should be prepared to handle most or all of these exceptions, as shown in the following table:\n\nAs the base class for exceptions in the System.IO namespace, IOException is also thrown for any error code that does not map to a predefined exception type. This means that it can be thrown by any I/O operation.\n\nIn addition, starting with .NET Core 2.1, validation checks for path correctness (for example, to ensure that invalid characters are not present in a path) have been removed, and the runtime throws an exception mapped from an operating system error code rather than from its own validation code. The most likely exception to be thrown in this case is an IOException, although any other exception type could also be thrown.\n\nNote that, in your exception handling code, you should always handle the IOException last. Otherwise, because it is the base class of all other IO exceptions, the catch blocks of derived classes will not be evaluated.\n\nIn the case of an IOException, you can get additional error information from the IOException.HResult property. To convert the HResult value to a Win32 error code, you strip out the upper 16 bits of the 32-bit value. The following table lists error codes that may be wrapped in an IOException.\n\nYou can handle these using a clause in a catch statement, as the following example shows.\n• How to use specific exceptions in a catch block"
    }
]