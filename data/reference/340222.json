[
    {
        "link": "https://javadoc.io/doc/org.json/json/latest/index.html",
        "document": ""
    },
    {
        "link": "https://baeldung.com/java-org-json",
        "document": "JSON (JavaScript Object Notation) is a lightweight data-interchange format, and we most commonly use it for client-server communication. Furthermore, it’s both easy to read/write and language-independent. A JSON value can be another JSON object, array, number, string, boolean (true/false) or null.\n\nIn this tutorial, we’ll see how to create, manipulate, and parse JSON using one of the available JSON processing libraries — JSON-Java library, also known as org.json.\n\nFirst, let’s add the following dependency in our pom.xml:\n\nWe can get the latest version from the Maven Central Repository.\n\nHowever, let’s not include the dependency explicitly when using the Android SDK, since it already includes the package.\n\nWe use classes from the JSON-Java library to parse and manipulate JSON in Java. We also know this library as org.json. However, let’s not confuse it with Google’s org.json.simple library.\n\nFurthermore, this library can also convert between JSON, XML, HTTP Headers, Cookies, Comma Delimited List or Text, etc.\n\nIn this tutorial, we’ll have a look at the following classes:\n• JSONArray – an ordered sequence of values similar to Java’s native Vector implementation\n• JSONTokener – a tool that breaks a piece of text into a series of tokens that can be used by JSONObject or JSONArray to parse JSON strings\n• CDL – a tool that provides methods to convert comma delimited text into a JSONArray and vice versa\n• Cookie – converts from JSON String to cookies and vice versa\n• HTTP – used to convert from JSON String to HTTP headers and vice versa\n\nA JSONObject is an unordered collection of key and value pairs, resembling Java’s native Map implementations.\n• Keys are unique Strings that cannot be null.\n• Values can be anything from a Boolean, Number, String, or JSONArray to even a JSONObject.NULL object.\n• A JSONObject can be represented by a String enclosed within curly braces with keys and values separated by a colon, and pairs separated by a comma.\n• It has several constructors with which to construct a JSONObject.\n\nIt also supports the following main methods:\n• get(String key) – gets the object associated with the supplied key, throws JSONException if the key is not found\n• opt(String key) – gets the object associated with the supplied key, null otherwise\n• put(String key, Object value) – inserts or replaces a key-value pair in current JSONObject.\n\nThe put() method is an overloaded method that accepts a key of type String and multiple types for the value.\n\nFor the complete list of methods supported by JSONObject, visit the official documentation.\n\nLet’s now discuss some of the main operations supported by this class.\n\nWe can use the put() method and supply the key and value as an argument:\n\nNow our JSONObject would look like this:\n\nThe JSONObject.put() method provides seven different overloaded signatures. While the key can only be a unique, non-null String, the value can be anything.\n\nInstead of directly putting key and values in a JSONObject, we can construct a custom Map and then pass it as an argument to JSONObject‘s constructor.\n\nThis example will produce same results as above:\n\nTo parse a JSON String to a JSONObject, we can just pass the String to the constructor.\n\nThis example will produce same results as above:\n\nThe passed String argument must be a valid JSON; otherwise, this constructor may throw a JSONException.\n\nOne of JSONObject’s constructors takes a POJO as its argument. In the example below, the package uses the getters from the DemoBean class and creates an appropriate JSONObject for the same.\n\nTo get a JSONObject from a Java Object, we’ll have to use a class that is a valid Java Bean:\n\nAlthough we have a way to serialize a Java object to JSON string, there is no way to convert it back using this library. If we want that kind of flexibility, we can switch to other libraries such as Jackson.\n\nA JSONArray is an ordered collection of values, resembling Java’s native Vector implementation:\n• Values can be anything from a Number, String, Boolean, JSONArray, or JSONObject to even a JSONObject.NULL object\n• It’s represented by a String wrapped within square brackets and consists of a collection of values separated by commas\n• Like JSONObject, it has a constructor that accepts a source String and parses it to construct a JSONArray\n\nThese are the primary methods of the JSONArray class:\n• get(int index) – returns the value at the specified index (between 0 and total length – 1), otherwise throws a JSONException\n• opt(int index) – returns the value associated with an index (between 0 and total length – 1). If there’s no value at that index, then a null is returned.\n• put(Object value) – append an object value to this JSONArray. This method is overloaded and supports a wide range of data types\n\nFor a complete list of methods supported by JSONArray, visit the official documentation.\n\nOnce we’ve initialized a JSONArray object, we can simply add and retrieve elements using the put() and get() methods:\n\nFollowing are the contents of our JSONArray (code is formatted for clarity):\n\nLike JSONObject, the JSONArray also has a constructor that creates a Java object directly from a JSON String:\n\nThis constructor may throw a JSONException if the source String isn’t a valid JSON String.\n\n5.3. Creating JSONArray Directly From a Collection or an Array\n\nThe constructor of JSONArray also supports collection and array objects as arguments.\n\nWe simply pass them as an argument to the constructor, and it will return a JSONArray object:\n\nNow our JSONArray consists of the following:\n\nWe can remove a particular element using the instance method remove(int index). Let’s continue with the example JSONArray called ja for states and remove the “Alaska” state element using the remove(int index) method:\n\nIndeed, it does not list the removed element:\n\nFurther, we can find the element removed from the remove(int index) method call itself since it returns the element that it removes:\n\nIndeed, it lists the removed element:\n\nFurthermore, the JSONArray reduces its size by 1 on removing an element. Notably, the index position in a JSONArray is zero-based. Therefore, the first element is at index 0. Accordingly, if we were to try removing the same element with the method call ja.remove(4), assuming the 4th element to be at index 4, the element won’t get removed. However, the method call with a non-existing index position doesn’t throw an exception/error. Therefore, we should verify the removal of an element, as we did.\n\nA JSONTokener takes a source String as input to its constructor and extracts characters and tokens from it. It’s used internally by classes of this package (like JSONObject, JSONArray) to parse JSON Strings.\n\nThere may not be many situations where we’ll directly use this class since we can achieve the same functionality using other simpler methods (like string.toCharArray()):\n\nNow we can access a JSONTokener like an iterator, using the more() method to check if there are any remaining elements and next() to access the next element.\n\nHere are the tokens received from the previous example:\n\nWe’re provided with a CDL (Comma Delimited List) class to convert comma delimited text into a JSONArray and vice versa.\n\nIn order to produce a JSONArray directly from the comma delimited text, we can use the static method rowToJSONArray(), which accepts a JSONTokener:\n\nHere’s what our JSONArray consists of now:\n\nLet’s see how to reverse of the previous step and get back the comma delimited text from JSONArray:\n\nThe String cdt now contains the following:\n\nTo produce a JSONArray of JSONObjects, we’ll use a text String containing both headers and data separated by commas.\n\nWe separate the different lines using a carriage return (\\r) or line feed (\n\n).\n\nThe first line is interpreted as a list of headers, and all the subsequent lines are treated as data:\n\nThe object JSONArray result now consists of the following (output formatted for the sake of clarity):\n\nNotice that both data and header were supplied within the same String. We have an alternative way of doing this where we can achieve the same functionality by supplying a JSONArray to get the headers and a comma delimited String working as the data.\n\nAgain, we separate different lines using a carriage return (\\r) or line feed (\n\n):\n\nHere we’ll get the contents of object result exactly as before.\n\nThe Cookie class deals with web browser cookies and has methods to convert a browser cookie into a JSONObject and vice versa.\n\nHere are the main methods of the Cookie class:\n• toString(JSONObject jo) – reverse of the previous method, converts a JSONObject into a cookie String\n\nTo convert a cookie String to a JSONObject, we’ll use the static method Cookie.toJSONObject():\n\nNow we’ll convert a JSONObject into cookie String. This is the reverse of the previous step:\n\nThe HTTP class contains static methods that are used to convert HTTP headers to JSONObject and vice versa.\n\nThis class also has two main methods:\n\nWe use the HTTP.toString() method to convert a JSONObject to an HTTP header String:\n\nHere is what our String httpStr will consist of:\n\nNote that while converting an HTTP request header, the JSONObject must contain “Method”, “Request-URI” and “HTTP-Version” keys. And for response header, the object must contain “HTTP-Version”, “Status-Code” and “Reason-Phrase” parameters.\n\nHere we will convert the HTTP string that we got in the previous step back to the very JSONObject we created in that step:\n\nAccordingly, the package-based applications throw the JSONException standard exception whenever any error is encountered.\n\nThe org.json package uses this class across all other classes. Furthermore, when an application throws this exception, it includes a message that states what exactly went wrong.\n\nIn this article, we looked at a JSON using Java — org.json — and we focused on some of the core functionality available here."
    },
    {
        "link": "https://stackoverflow.com/questions/58633466/read-json-data-in-java-using-the-org-json-json-20171018-repository",
        "document": "I'm trying to read a JSON file in my java application using the org/json/json/20171018 repository (http://central.maven.org/maven2/org/json/json/20171018/ -> json-20171018.jar). My JSON file looks like this:\n\nI'm interested in the section more specific in the links the to. So I've created first a of the whole file, then a of the section and then a of the type . But unfortunately I'm getting this error showing up when I run the program:\n\nMy java code looks like this:\n\n\n\nDoes anyone know where my mistake is?"
    },
    {
        "link": "https://stleary.github.io/JSON-java/index.html",
        "document": "JavaScript is disabled on your browser.\n\nThis document is designed to be viewed using the frames feature. If you see this message, you are using a non-frame-capable web client. Link to Non-frame version."
    },
    {
        "link": "https://docs.oracle.com/javame/8.0/api/json/api/com/oracle/json/JsonObject.html",
        "document": "class represents an immutable JSON object value (an unordered collection of zero or more name/value pairs). It also provides unmodifiable map view to the JSON object name/value mappings.\n\nA JsonObject instance can be created from an input source using . For example:\n\nIt can also be built from scratch using a\n\nFor example 1: An empty JSON object can be built as follows:\n\nFor example 2: The following JSONcan be built using :can be written to JSON as follows:values can be . These values can be accessed using various accessor methods.\n\nIn the above example 2, \"John\" can be got using\n\nThis map object provides read-only access to the JSON object data, and attempts to modify the map, whether direct or via its collection views, result in an\n\nThe map object's iteration ordering is based on the order in which name/value pairs are added to the corresponding builder or the order in which name/value pairs appear in the corresponding stream."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/java-read-file-line-by-line",
        "document": "In this article, you will learn about different ways to use Java to read the contents of a file line-by-line. This article uses methods from the following Java classes: , , , and .\n\nYou can use the method from to read a file line-by-line to String. This method returns when the end of the file is reached.\n\nHere is an example program to read a file line-by-line with :\n\nContinue your learning with the API Doc (Java SE 8).\n\nYou can use the class to open a file and then read its content line-by-line.\n\nHere is an example program to read a file line-by-line with :\n\nContinue your learning with the API Doc (Java SE 8).\n\nis a utility class that contains various useful methods. The method can be used to read all the file lines into a list of strings.\n\nHere is an example program to read a file line-by-line with :\n\nContinue your learning with the API Doc (Java SE 8).\n\nYou can use to open a file in read mode and then use its method to read a file line-by-line.\n\nHere is an example program to read a file line-by-line with :\n\nContinue your learning with the API Doc (Java SE 8).\n\nIf a file is stored in an encoding other than UTF-8, you should specify the correct encoding when reading it.\n\nFor massive files (GB-sized logs or datasets), Java’s NIO API ( ) is a high-performance alternative to standard file reading.\n\nHere is an example:\n\nUsing significantly reduces memory usage compared to loading a file into memory at once.\n\nFor more advanced file handling techniques, you can check out this tutorial on Java Files - java.nio.file.Files Class.\n\n1. How to read a file in Java using ?\n\nTo read a file in Java using , you can create an instance of and read character data from the file. However, is not the most efficient option as it does not buffer the input. A better alternative is to wrap it inside a .\n\nFor more efficient file reading, consider using BufferedReader instead.\n\n2. How to read a file line by line in Java?\n\nThe most common way to read a file line by line in Java is by using . This method is memory-efficient and performs well for large files.\n\nFor additional file handling methods, check out this tutorial on Java File Handling.\n\n3. What is the most efficient way to read a large file in Java?\n\nWhen dealing with large files, reading the entire file into memory is inefficient. Instead, use streams or Java NIO (Non-blocking I/O) APIs like for better performance.\n\nUsing BufferedReader with Streams (Efficient for Large Files)\n\nUsing (Best for Extremely Large Files)\n\nFor extremely large files, consider memory-mapped files or for improved performance as described in the section above.\n\n4. How to handle file reading errors in Java?\n\nError handling is crucial to avoid crashes due to file not found, permissions issues, or encoding mismatches.\n\n5. What is the difference between and ?\n\nTo handle large text files efficiently, always prefer over . Learn more about efficient file operations in tutorial on Java read text file.\n\nIn this comprehensive guide, you learned various methods to read the contents of a file line-by-line in Java, including the use of , , , and . You also learned how to handle file reading errors, the difference between and , and how to efficiently handle large files using or memory-mapped files.\n\nContinue your learning with more Java tutorials.\n\nYou can also refer to these tutorials on:"
    },
    {
        "link": "https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/BufferedReader.html",
        "document": "Reads text from a character-input stream, buffering characters so as to provide for the efficient reading of characters, arrays, and lines.\n\nThe buffer size may be specified, or the default size may be used. The default is large enough for most purposes.\n\nIn general, each read request made of a Reader causes a corresponding read request to be made of the underlying character or byte stream. It is therefore advisable to wrap a BufferedReader around any Reader whose read() operations may be costly, such as FileReaders and InputStreamReaders. For example,\n\nwill buffer the input from the specified file. Without buffering, each invocation of read() or readLine() could cause bytes to be read from the file, converted into characters, and then returned, which can be very inefficient.\n\nPrograms that use DataInputStreams for textual input can be localized by replacing each DataInputStream with an appropriate BufferedReader."
    },
    {
        "link": "https://geeksforgeeks.org/difference-between-bufferedreader-and-filereader-in-java",
        "document": "BufferedReader and FileReader both classes are used to read data from a given character stream. Both of them have some pros and some cons. In this article, we will discuss the differences between them. Though the most important difference is in the way they work, but we will discuss the other details also.\n\nA buffer is a small portion of the device memory storage used to temporarily store some amount of data. Usually, Buffers use the RAM of the device to store the temporary data, and hence, accessing data from the buffer is much faster than accessing the same amount of data from the hard drive.\n\nDifferences between BufferedReader and FileReader are illustrated over and discussed over major parameters taken into consideration as follows:\n\nFileReader is used to read a file from a disk drive whereas BufferedReader is not bound to only reading files. It can be used to read data from any character stream. FileReader class provides two constructors:\n• FileReader(File file): It takes a File object that represents a file in your disk and creates a new FileReader instance.\n• FileReader(FileDescriptor fd) : Creates a new FileReader, given the FileDescriptor to read from.\n• FileReader(String fileName): Takes the name of the file as the only parameter and creates a new FileReader instance to read the file.\n• BufferedReader(Reader rd): It uses a Reader to read data from the character input stream and creates a default sized input buffer.\n• BufferedReader(Reader rd, int size): Takes two parameters:\n• First: A Reader that is used to read the input stream data\n• Second: The size of the input buffer. It creates a new BufferedReader with the given sized input buffer.\n\nAs seen, BufferedReader accepts any type of Reader(StringReader, FileReader, etc.) and hence capable of reading from any character input stream. Whereas, FileReader is capable of reading characters from files only. Usually, we wrap a FileReader with BufferedReader to read characters from files.\n\nBufferedReader is much more efficient than FileReader in terms of performance. FileReader directly reads the data from the character stream that originates from a file. Each time, it reads a character, it directly accesses the disk drive and every time it takes some time for the disk drive to position the read head correctly which makes it very inefficient.\n\nWhereas BufferedReader creates an input buffer and allows the input to be read from the hard drive in large chunks of data rather than a byte at a time, resulting in a huge improvement in performance. The default buffer size is 8Kb( which is enough in most cases) though it can be customized. BufferedReader reads lots of data at a time and stores it in the created buffer memory. When java.io.BufferedReader#read() is called, it reads the data from the memory buffer. When data is not available in the buffer, it makes a corresponding read request of the underlying character stream and loads lots of data into the created buffer. As a result, we do not have to access the hard drive directly when reading each character, we can read from the buffer memory which is fast and much more efficient.\n\nAs BufferedReader uses buffer internally, this class is much faster than FileReader. BufferReader doesn’t need to access the hard drive every time like FileReader and hence faster.\n\nIn most cases, you would like to read a line at a time rather than reading a character at a time and only the BufferedReader provides a readLine() method that reads a whole line at a time. Simply, the given Reader(FileReader in this case) reads the characters and stores them in the buffer. When the java.io.BufferedReader#readLine() method is called, characters of a line stored in the buffer, are returned as a String. It saves lots of time and hence is faster than FileReader#read() method. Note that, BufferedReader is able to read a whole line at a time only because it uses a buffer memory, it can store the characters of a line in the buffer and read all the characters together directly from the buffer.\n\nOutput: From the file ‘geeks.txt’ in the local directory used in the above program\n\nBufferedReader uses a FileReader to read data from this file. BufferedReader creates a input buffer with the given size (if no such size given then the default size is 8Kb). If we use only the FileReader, then it reads one character at a time by directly accessing the disk drive. Each time it reads the data, it takes some time for the disk drive to position the read head correctly which makes it very inefficient. Accessing the disk drive every time for reading a single character affects the performance. Whereas, BufferedReader creates a buffer, and reads large amount of data using the given FileReader and loads it into a input buffer in the memory. Each time you want to read the file data, you can read it from the buffer( you don’t have to directly access the disk drive every time) and hence is faster than FileReader.\n\nExample 2: Reading lines using only the FileReader\n\nOutput: From the file ‘geeks.txt’ in the local directory used in the above program\n\nBufferedReader uses a FileReader to read data from this file. BufferedReader creates a input buffer with the given size (if no such size given then the default size is 8Kb). If we use only the FileReader, then it reads one character at a time by directly accessing the disk drive. Each time it reads the data, it takes some time for the disk drive to position the read head correctly which makes it very inefficient. Accessing the disk drive every time for reading a single character affects the performance. Whereas, BufferedReader creates a buffer, and reads large amount of data using the given FileReader and loads it into a input buffer in the memory. Each time you want to read the file data, you can read it from the buffer( you don’t have to directly access the disk drive every time) and hence is much more efficient than FileReader.\n• The time taken for the reading process might vary in your system, but the fact is that BufferedReader works faster and more efficiently than the FileReader.\n• If you want a good performance, then you would you use both of them together. BufferedReader itself does not read data from an input stream, it uses a Reader(usually a FileReader) that interacts with the native system APIs to read characters from the given input source( A file in case of a FileReader ). The BufferedReader class just adds a buffer to the character stream and reads characters from the buffer, not directly from the input source. So, you can read a file using only the FileReader because it has access to the hard drive to read data from. But you can not use “only BufferedReader” to read a file, as it doesn’t have the access to the hard drive, you have to provide a Reader( a FileReader) that has the access."
    },
    {
        "link": "https://javadoc.scijava.org/Java11/java.base/java/io/BufferedReader.html",
        "document": "Reads text from a character-input stream, buffering characters so as to provide for the efficient reading of characters, arrays, and lines.\n\nThe buffer size may be specified, or the default size may be used. The default is large enough for most purposes.\n\nIn general, each read request made of a Reader causes a corresponding read request to be made of the underlying character or byte stream. It is therefore advisable to wrap a BufferedReader around any Reader whose read() operations may be costly, such as FileReaders and InputStreamReaders. For example,\n\nwill buffer the input from the specified file. Without buffering, each invocation of read() or readLine() could cause bytes to be read from the file, converted into characters, and then returned, which can be very inefficient.\n\nPrograms that use DataInputStreams for textual input can be localized by replacing each DataInputStream with an appropriate BufferedReader."
    },
    {
        "link": "https://stackoverflow.com/questions/44792788/read-from-a-file-using-bufferedreader-and-filereader",
        "document": "I am relatively new to java, and am curious as to how to read from a file using buffered reader. the reason for this is i'm taking a class and was assigned to do a simple ceaser cipher, I'm supposed to decrypt a text file, create a new file, and put the decrypted text into that file. I was able to do this with the scanner, and a small 10KB file, but it was extremely slow when working with the big 100MB text file i'm gonna be tested with. here is the code i have which is supposed to read the file contents.\n\nif someone could point me in the right direction, that would be fantastic."
    }
]