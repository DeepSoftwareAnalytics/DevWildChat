[
    {
        "link": "https://embetronicx.com/tutorials/microcontrollers/8051/8051-uart-tutorial-serial-communication",
        "document": "Hi everyone, today we are going to transfer data using UART and how to use UART’s SFR (8051 UART Tutorial).\n\nThis article provides a comprehensive tutorial on UART communication with an 8051 microcontroller. It covers key aspects such as UART registers (SFRs), detailed explanations of register bits, configuration of UART modes, and baud rate generation using Timer 1.\n\nThis tutorial also includes practical programming examples for both sending and receiving data via UART.\n\nUART (Universal Asynchronous Receiver/Transmitter) is a fundamental protocol used for serial data exchange between devices.\n\nBut before that, you should know about basic Serial Communication.\n\nThe microcontroller MCS51 has an inbuilt UART for carrying out serial communication. The serial communication is done in the asynchronous mode.\n\nA serial port, like other PC ports, is a physical interface to establish data transfer between a computer and external hardware or device. This transfer, through a serial port, takes place bit by bit.\n\nBit Addressable: We can assign the values bit by bit. For example, for a single bit, we can set whether 1 or 0.\n\nByte Addressable: We can’t assign the values bit by bit. We can set only byte by byte.\n\nFirst, we will see the SFRs.\n\nThese Two bits are used to select the Mode of the UART.\n\nSM2: Multiprocessor communications bit. Set/cleared by the program to enable multiprocessor communications in modes 2 and 3. When set to 1 an interrupt is generated if bit 9 of the received data is a 1; no interrupt is generated if bit 9 is a 0. If set to 1 for mode 1, no interrupt will be generated unless a valid stop bit is received. Clear to 0 if mode 0 is in use.\n\nREN: Receive enable bit. Set to 1 to enable reception; cleared to 0 to disable reception.\n\nTB8: Transmitted bit 8. Set/cleared by the program in modes 2 and 3.\n\nRB8: Received bit 8. Bit 8 of received data in modes 2 and 3; stop bit in mode 1. Not used in mode 0.\n\nTI: Transmit Interrupt flag. Set to one at the end of bit 7 time in mode 0, and at the beginning of the stop bit for other modes. Must be cleared by the program.\n\nRI: Receive Interrupt flag. Set to one at the end of bit 7 time in mode 0, and halfway through the stop bit for other moves. Must be cleared by the program.\n\nThe first four bits (bits 4 through 7) are configuration bits. Bits SM0 and SM1 let us set the serial mode to a value between 0 and 3, inclusive. The four modes are defined in the chart immediately above.\n\nAs you can see, selecting the Serial Mode selects the mode of operation (8-bit/9-bit, UART, or Shift Register) and also determines how the baud rate will be calculated. In modes 0 and 2 the baud rate is fixed based on the oscillator’s frequency.\n\nIn modes 1 and 3 the baud rate is variable based on how often Timer 1 overflows. We’ll talk more about the various Serial Modes in a moment.\n\nThe next bit, SM2, is a flag for “Multiprocessor communication.” Generally, whenever a byte has been received the 8051 will set the “RI” (Receive Interrupt) flag.\n\nThis lets the program know that a byte has been received and that it needs to be processed. However, when SM2 is set the “RI” flag will only be triggered if the 9th bit received was a “1”. That is to say, if SM2 is set and a byte is received whose 9th bit is clear, the RI flag will never be set.\n\nThis can be useful in certain advanced serial applications. For now, it is safe to say that you will almost always want to clear this bit so that the flag is set upon reception of any character.\n\nThe next bit, REN, is “Receiver Enable.” This bit is very straightforward: If you want to receive data via the serial port, set this bit. You will almost always want to set this bit.\n\nThe last four bits (bits 0 through 3) are operational bits. They are used when actually sending and receiving data. They are not used to configure the serial port.\n\nThe TB8 bit is used in modes 2 and 3. In modes 2 and 3, a total of nine data bits are transmitted. The first 8 data bits are the 8 bits of the main value, and the ninth bit is taken from TB8.\n\nIf TB8 is set and a value is written to the serial port, the data’s bits will be written to the serial line followed by a “set” ninth bit. If TB8 is clear the ninth bit will be “clear.”\n\nThe RB8 also operates in modes 2 and 3 and functions essentially the same way as TB8 but on the reception side. When a byte is received in modes 2 or 3, a total of nine bits are received.\n\nIn this case, the first eight bits received are the data of the serial byte received and the value of the ninth bit received will be placed in RB8.\n\nTI means “Transmit Interrupt.” When a program writes a value to the serial port, a certain amount of time will pass before the individual bits of the byte are “clocked out” the serial port.\n\nIf the program were to write another byte to the serial port before the first byte was completely output, the data being sent would be garbled. Thus, the 8051 lets the program know that it has “clocked out” the last byte by setting the TI bit.\n\nWhen the TI bit is set, the program may assume that the serial port is “free” and ready to send the next byte.\n\nFinally, the RI bit means “Receive Interrupt.” It functions similarly to the “TI” bit, but it indicates that a byte has been received. That is to say, whenever the 8051 has received a complete byte, it will trigger the RI bit to let the program know that it needs to read the value quickly before another byte is read.\n• None SBUF Register: For a byte of data to be transferred via the TxD line, it must be placed in the SBUF.\n• None SBUF holds the byte of data when it is received by the MCS51’s RxD line.\n\nThis Register is not Bit Addressable.\n\nSMOD: Double baud rate bit. If Timer 1 is used to generate the baud rate and SMOD = 1, the baud rate is doubled when the serial port is used in modes 1, 2, or 3.\n\nPD: Power Down bit. Setting this bit activates the power-down operation in the 8051BH. (Available only in CHMOS).\n\nIDL: Idle Mode bit. Setting this bit activates the Idle Mode operation in the 8051BH. (Available only in CHMOS).\n\nThat’s all about Registers. When using the integrated serial port, obviously configure it. This lets us tell the 8051 how many data bits we want, the baud rate we will be using, and how the baud rate will be determined.\n\nHere we are going to use Mode 1 because that is an 8-bit UART, and we can generate Baudrate using Timer 1. If you don’t know about the timer, please check the timer counter tutorial.\n\nSo Mode 1 means we have to give 0x50 value to the SCON Register.\n\nOnce the Serial Port Mode has been configured, as explained above, the program must configure the serial port’s baud rate. This only applies to Serial Port modes 1 and 3.\n\nThe Baud Rate is determined based on the oscillator’s frequency when in modes 0 and 2.\n\nIn mode 0, the baud rate is always the oscillator frequency divided by 12. This means if your crystal is 11.0592Mhz, the mode 0 baud rate will always be 921,583 baud.\n\nIn mode 2 the baud rate is always the oscillator frequency divided by 64, so a 11.059Mhz crystal speed will yield a baud rate of 172,797.\n\nIn modes 1 and 3, the baud rate is determined by how frequently timer 1 overflows. The more frequently timer 1 overflows, the higher the baud rate.\n\nThere are many ways one can cause timer 1 to overflow at a rate that determines a baud rate, but the most common method is to put timer 1 in 8-bit auto-reload mode (timer mode 2) and set a reload value (TH1) that causes Timer 1 to overflow at a frequency appropriate to generate a baud rate.\n\nTo determine the value that must be placed in TH1 to generate a given baud rate, we may use the following equation (assuming PCON.7 is clear).\n\nIf PCON.7 is set then the baud rate is effectively doubled, thus the equation becomes:\n\nFor example, if we have an 11.0592Mhz crystal and we want to configure the serial port to 19,200 baud we try plugging it in the first equation:\n\nAs you can see, to obtain a 19,200 baud rate on an 11.059Mhz crystal, we’d have to set TH1 to 254.5. If we set it to 254, we will have achieved 14,400 baud and if we set it to 255, we will have achieved 28,800 baud. Thus we’re stuck…\n\nBut not quite… to achieve 19,200 baud, we simply need to set PCON.7 (SMOD). When we do this, we double the baud rate and utilize the second equation mentioned above. Thus we have:\n\nHere we are able to calculate a nice, even TH1 value. Therefore, to obtain 19,200 baud with an 11.059MHz crystal we must:\n• None Set TH1 to 253 to reflect the correct frequency for 19,200 baud.\n\nThis program is used to send the data “embetronicx” via a serial port to the computer.\n\nIn this program, I have added the receiver code also. This code sends the data to the 8051 microcontrollers whatever I’m typing on the keyboard of the computer. Then microcontroller again resends the data to the computer.\n\nThat’s all guys… Hope you have understood. If you have any doubt please ask us by commenting below.\n\nNow, let me give you a task…share in the comment if you are able to do it or not…\n• None Connect the 8 LEDs to P2. Whenever I send “ON” to the Microcontroller, those LEDs should be On. Whenever I send “OFF” to the microcontroller, That time it should be Off.\n• None Connect LCD and Serial port to 8051. I have to display the character in LCD, whatever I’m sending from UART.\n\nYou can also read the below tutorials."
    },
    {
        "link": "https://exploreembedded.com/wiki/A4.8051_Communication_Protocols:UART,_RS232",
        "document": "In this tutorial, we are going to discuss the serial/UART communication of 8051. After understating the basics of 8051 UART module, We will see how to use the ExploreEmbedded libraries to communicate with any of the UART devices.\n\n\n\n\n\nThe below table shows the registers associated with 8051 UART.\n\n\n\nNow lets see how to configure the individual registers for UART communication.\n• SM2 - Serial port mode 2 bit, also known as multiprocessor communication enable bit. When set, it enables multiprocessor communication in mode 2 and 3, and eventually mode 1. It should be cleared in mode 0.\n• REN - Reception Enable bit enables serial reception when set. When cleared, serial reception is disabled.\n• TB8 - Transmitter bit 8. Since all registers are 8-bit wide, this bit solves the problem of transmitting the 9th bit in modes 2 and 3. It is set to transmit a logic 1 in the 9th bit.\n• RB8 - Receiver bit 8 or the 9th bit received in modes 2 and 3. Cleared by hardware if 9th bit received is a logic 0. Set by hardware if 9th bit received is a logic 1.\n• TI - Transmit Interrupt flag is automatically set at the moment the last bit of one byte is sent. It's a signal to the processor that the line is available for a new byte to transmit. It must be cleared from within the software.\n• RI - Receive Interrupt flag is automatically set upon one-byte receive. It signals that byte is received and should be read quickly prior to being replaced by a new data. This bit is also cleared from within the software.\n\n0 = Timer has not overflowed/rolled over\n\n 1 = Timer has overflowed/rolled over\n\nThe main criteria for UART communication is its baud rate. Both the devices Rx/Tx should be set to same baud rate for successful communication.\n\n For the 8051 the Timer 1' is used to generate the baud rate in Auto reload mode.\n\nThe crystal frequency Fclk is divided by 12 internally which is used to execute instructions also known as Machine Clock. Mclk. The timer again divides the Mclk by 32 and uses it as the timer frequency, say Tclk.\n\nUsually, an 11.0592 Mhz crystal oscillator is used to provide the clock to 8051. The value seems to be odd but we see how it makes sense. From above discussion\n\n\n\nIf we look at the standard baud rates used for serial communication shown in the table below, we can observe that all the baud rates are factors or multiples of the Tclk (28.8K)! This results in low error rates and hence is a commonly used crystal with 8051.\n\nThe above factors should be loaded to Timer1(TH1) in Mode2 in order to generate the required baud rate. The final formula for baud rate is as below. Baudrate = Fosc/(32 * 12 * (256-TH1)) $$TH1 = 256 - (Fosc/(32 * 12 * Baudrate))$$ //If( SMOD==0 in PCON register) $$TH1 = 256 - (Fosc/(32 * 6 * Baudrate))$$ //If( SMOD==1 in PCON register)\n\nNow with Fosc = 11.0592Mhz, TH1 value for 9600 baudrate will be: TH1 = 256-(11.0592*10^6)/(32 * 12 * 9600) = 253 = 0xFD = -3\n• Select the 8-bit , 1-Start and 1-Stop bit mode in SMOD\n• Load the baud rate generator value to TH1\n• Load the new char to be transmitted int SBUF.\n• Wait till the char is transmitted. TI will be set when the data in SBUF is transmitted.\n• Clear the TI for next cycle.\n• Wait till the Data is received. RI will be set once the data is received in SBUF register.\n• Clear the receiver flag(RI) for next cycle.\n\nBelow is the sample code to Transmit and receive the chars at 9600 baudrate with 11.0592Mhz clock.\n\nIn the above tutorial we discussed how to configure and use the inbuilt 8051 UART.\n\n Now we will see how to use the ExploreEmbededd UART library.\n\n For this you have to include the uart.c/uart.h files and associated gpio/stdutils files.\n• Note:Refer the uart.h file for more info.\n\nDownload the sample code and design files from this link.\n\n\n\n Have an opinion, suggestion , question or feedback about the article let it out here!"
    },
    {
        "link": "https://ww1.microchip.com/downloads/aemDocuments/documents/OTH/ApplicationNotes/ApplicationNotes/doc4346.pdf",
        "document": ""
    },
    {
        "link": "https://keil.com/appnotes/files/apnt_268.pdf",
        "document": ""
    },
    {
        "link": "https://documentation-service.arm.com/static/63a05c9e1d698c4dc521cb03",
        "document": "%PDF-1.4 %���� 1 0 obj << /Title (Keil C51 Release Notes) /Author (Arm Ltd.) /Subject (This document contains the full release notes of the Keil C51 development tools.) /Keywords (640aa1e, Keil) /Creator (Arm DITA Open Toolkit v1.0.17) /Producer (Apache FOP Version 2.7) /CreationDate (D:20221219123815Z) >> endobj 2 0 obj << /N 3 /Length 3 0 R /Filter /FlateDecode >> stream x��gPTY��{� �M���I��$�$A��@w�i��AQdpFI� ���AFQŀ((��N#��2�\"**K�٭���U[�g��x�sO�s�[����1������M��:�1��C� H�( �JN���� �!���c ����sϑ��>��qy�v�y����%��. ��ʱlN2k�w�r4;�-�� 8=%1 �{�i��W�-��o�!�o\\�V��k��� ���Z�kL�0+�� �t�j� +���|iA/�o3���`?�(��O��f+�y�S/T�����7����o��r�L@�ʿr��`� Q�WN� �= t����8@W) ��X���o9��� Ȁ��"
    },
    {
        "link": "https://embeddedflakes.com/serial-communication-uart-with-8051",
        "document": "In the realm of microcontroller-based systems, effective communication is paramount. Among the various protocols available, UART (Universal Asynchronous Receiver/Transmitter) stands out as a versatile and reliable method for serial communication. When paired with the venerable 8051 microcontroller, UART opens up a world of possibilities for embedded system designers and hobbyists alike.\n\nUART communication is based on the principle of asynchronous data transfer. Unlike synchronous protocols, UART doesn’t require a separate clock signal, making it simpler to implement in many scenarios. The “universal” in UART refers to its flexibility in terms of data format and transmission speed.\n• Bidirectional communication: Allows for both sending and receiving data\n\nThe 8051 microcontroller family has been a staple in embedded systems for decades. Its longevity is a testament to its robust architecture and versatility. When it comes to UART communication, the 8051 shines with its built-in serial port, making implementation straightforward and efficient.\n\nTo harness the power of UART on the 8051, we need to follow these essential steps:\n• Configure the serial port: Set up the UART mode and baud rate\n• Enable interrupts: Set up interrupt handlers for transmit and receive operations\n• Implement transmit and receive functions: Write code to send and receive data\n\nLet’s dive deeper into each of these steps:\n\nThe 8051’s serial port is controlled by the SCON (Serial Control) register. We typically use Mode 1, which provides 8-bit UART communication with variable baud rate. Here’s a sample configuration:\n\nTimer 1 is commonly used to generate the baud rate for UART communication. We need to set it up in auto-reload mode:\n\nTo handle UART communication efficiently, we enable the serial interrupt:\n\nWith the configuration in place, we can now implement functions to send and receive data:\n\nTesting UART communication between the 8051 and a Windows PC is crucial for debugging and validating your implementation. We’ll explore the tools and techniques to ensure seamless communication.\n\nTo establish a connection between your 8051 board and a Windows PC, you’ll need:\n• USB-to-TTL converter: This device bridges the gap between the PC’s USB port and the 8051’s TTL-level UART pins.\n• Jumper wires: For connecting the USB-to-TTL converter to your 8051 board.\n\nSeveral software tools are available for UART testing on Windows. Here are some popular options:\n\nLet’s explore each of these tools in more detail:\n\nPuTTY is a free, open-source terminal emulator that’s widely used for various network protocols, including serial communication. Its key features for UART testing include:\n• Data logging: Option to log all received data to a file\n\nTo use PuTTY for UART testing:\n• Enter the appropriate COM port number\n• Set the baud rate to match your 8051 configuration\n\nTera Term is another popular open-source terminal emulator that excels in serial communication. Its advantages include:\n• SSH and Telnet support: Versatile for various communication protocols\n\nTo set up Tera Term for UART testing:\n\nRealTerm is designed specifically for serial data streams, making it an excellent choice for UART testing. Its features include:\n• Capture to file: Save received data for later analysis\n• Send string or file: Easily transmit test data to your 8051\n• In the “Port” tab, select the appropriate COM port and baud rate\n• Use the “Send” tab to transmit data\n\nTo get started with Advanced Serial Port Monitor:\n• Select “Add Port” and choose your COM port\n• Use the various analysis tools to examine the communication\n\nSerial Port Monitor provides a comprehensive set of tools for UART testing:\n• Click “New Session” and select your COM port\n• Set the appropriate baud rate and other parameters\n• Use the various views and tools to analyze the UART communication\n\nTo ensure reliable UART communication between your 8051 and PC, follow these best practices:\n• Match baud rates: Ensure the baud rate settings on both the 8051 and PC software are identical.\n• Use flow control: Implement hardware or software flow control to prevent data loss.\n• Verify connections: Double-check wiring between the USB-to-TTL converter and 8051 board.\n• Test with known data: Send predefined patterns to verify correct transmission and reception.\n\nEven with careful setup, you may encounter issues. Here are some common problems and solutions:\n• Check for noise on the communication lines\n• Check for conflicting software using the same COM port\n\nOnce you’ve mastered basic UART communication, consider these advanced techniques:\n• Circular buffers: Use ring buffers to manage data flow and prevent overruns.\n\nMastering UART communication with the 8051 microcontroller opens up a world of possibilities for embedded system design. By understanding the fundamentals, implementing robust code, and utilizing appropriate testing tools, you can create reliable and efficient serial communication systems. Remember to follow best practices, troubleshoot methodically, and explore advanced techniques to take your projects to the next level. With the knowledge gained from this guide, you’re well-equipped to harness the full potential of UART magic with the 8051 microcontroller."
    },
    {
        "link": "https://electro-tech-online.com/articles/8051-setting-up-the-uart-for-serial-communications.627",
        "document": "The Intel 8051, as old as it is, is still a very popular processor in use today. Some say it's due to the abundance of legacy code that is available for the 8051. Others say that there are so many products designed around it and it's cheaper to keep using the 8051 rather than redesign everything that originally used it. But still, there are others who are just in love with the 8051 (like myself) and its resources/abilities. One of the things that makes it a wonderful processor is the ALU's multiply/divide functions and its on chip Boolean processor. Throw in the fact that it uses vectored interrupts rather than a single IRQ like the PIC's do, and you have yourself a very powerful processor that is simple to use and program.Unlike modern processors that feature tristate I/O ports and high source/sink currents directly from its I/O pins, the 8051 can sink up to 15mA on each of its I/O pins, but cannot source very much. They are also bistate...they can either be high or low. In the case of the P0 I/O pins, they are either low or floating unless they have an external pull up resistor on them (they internally drive both high and low when used as the low order address/data port on external memory accesses).Here I will demonstrate how to set up the serial port on an 8051. The 8051 features a full duplex Universal Asynchronous Receiver Transmitter, or more simply, the UART. It can both transmit and receive serial data at the same time on two different I/O pins. These pins are P3.0 and P3.1, which function as RxD and TxD respectively. This allows the 8051 to communicate with other embedded processors as well as a serial port equipped PC on just two pins.The first thing that needs to be done is to write 1's to bits P3.0 and P3.1 in the P3 register. These pins are automatically 1's on any power up or reset condition.The UART on the 8051, unlike the PIC, does not have a dedicated baud rate timer. It must use one of its on chip timers as the baud rate generator. On the 8051, there are only two timers available while the 8052 has 3 timers available. Only timer 1 on the 8051 can be used as the baud rate generator while on the 8052, both timer 1 and timer 2 can be used as the baud rate generator. We will first cover using timer 1 as the baud rate generator.Timer 1 has 4 modes of operation. Of these 4 modes, we are only interested in mode 2, which is the 8-bit auto reload mode. A value is stored in timer register TH1 while TL1 is the 8-bit timer counter. On each overflow of TL1 (a rollover from 255-0, or 0xFF to 0x00), TL1 is automatically reloaded with the value stored in TH1 and the count repeats. Serial data is sent out on TxD and received in on RxD upon each overflow/reload of TL1.To set the timer modes for timer 1, we must write a value to the upper 4 bits of the TMOD SFR, which is the Timer Mode register. Writing the value 0x20 will disable timer 1 gating, set the timer up as an internally incremented timer, and set timer 1 for 8-bit auto reload -mov TMOD,#0x20 ;timer 1 in 8-bit auto reloadNow we must write a reload value to register TH1. In order to calculate this value, we need to know what our desired baud rate is. Also, for certain baud rates, we may need to set the double baud rate bit, which is bit 7 in the PCON SFR.To calculate the TH1 reload value for a given baud rate, there are two equations we can use. The first equation is used when PCON.7 = 0 -TH1 Value = 256 - ((Crystal MHz / 384) / Baud)The second equation is used when PCON.7 = 1 -TH1 Value = 256 - ((Crystal MHz / 192) / Baud)For a baud rate of 4800bps and a crystal frequency of 11.059MHz, we will first use the first equation to calculate it -256 - ((11059000 / 384) / 4800) = 250With a 11.059MHz crystal, we can simply write the value 250, or hex 0xFA, to register TH1 and not have to set bit PCON.7. But what if we were using a 12MHz crystal?256 - ((12000000 / 384) / 4800) = 249.49Register TH1 can only accept whole integer values, so we must round up to the nearest integer value, which would be 249, or hex 0xF9. But...this would give us a baud rate of -Actual Baud = Crystal MHz / 384(256-TH1 Value)12000000 / 384(256-249) = 4464.29Which results in an error percentage of -100((Actual Baud - Desired Baud) / Desired Baud) = 7%This is too great of an error percentage and will result in framing errors. But what if we set PCON.7? Let's see what happens there -PCON.7 = 1256-((12000000 / 192) / 4800) = 242.98This gives us a decimal value that is a bit closer to a whole integer value of 243, or hex 0xF3. What would our actual baud rate and error percentage be with that?12000000 / 192(256-243) = 4807.69100((4807.69 - 4800) / 4800 = 0.16%This reduces our baud rate error immensely, and we now have a forgivable baud rate that we can work with without having to use a different crystal.If, however, we were using a baud rate of 9600 with the 8051, we would be forced to use a 11.059MHz crystal. This is because the error percentage would be too great regardless of the PCON.7 bit setting. However, if we were using the 8052, we could use timer 2 in 16-bit autoreload mode, which offers greater baud rate tuning resolution and negates the need to change to a different crystal. By using a reload value of 65497 (0xFFD9 in hex), this would give us a baud rate of 9615.38 and an error percentage of 0.16%, again tolerable for 9600 baud. More on timer 2's baud rate generator capabilities later.So for our example baud rate of 4800 with a 12MHz crystal -Now we can configure the UART itself. For standard 8N1 asynchronous format (8 data bits/No parity/1 stop bit) -Once the UART is active, we can send data out by simply writing a character to register SBUF. The hardware takes over from there. Interrupt flag bit TI in register SCON, if previously cleared in software, will remain clear until the hardware resets it upon the character transferring to the shift register from the buffer. This means we can write one character to the SBUF buffer while another character is still shifting out of the shift register.To prevent overwriting a character that is waiting to shift out, we can clear the TI flag, then poll it until it returns high with the following instructions -A receive procedure would be similar to the above. The RI flag is high once a valid stop bit has been detected on the RxD pin. It must be cleared in software upon transferring the received character from SBUF. Assuming bit RI started out clear, we can receive data using the following instructions -Since data sent to the 8051 would be unpredictable (after all, how is it supposed to know when to expect data), making the processor sit and wait for an incoming character would be impractical as that would be all it would be able to do. Fortunately for us, the 8051 has an interrupt vector assigned to the UART. We can tie the processor to doing other tasks if we enable the serial interrupt.The serial IRQ vector is at program memory address 0x0023. At the top of our code, we must place these directives and instructions -"
    },
    {
        "link": "https://reddit.com/r/embedded/comments/1d45tel/what_are_your_best_practices_to_make_uart_comms",
        "document": "I have been doing uart comms the basic way for a loong time: start of packet byte, length byte, data with escaped control bytes and crc. But as time goes on, I'm running into more and more challenging situations where this fails in critical scenarios. Sometimes the HW RX FIFO can't be cleared in time, for example. Other things happen sometimes that make my comms lose synchronization for a random length of time.\n\nSo what techniques do you use to bullet-proof your uart comms? I have read about using sequence numbers, end of packet bytes, and longer start of packet sequences. How well do these work for people? Are they worth it to implement in critical scenarios? Is there a comms library out there that helps with this?"
    },
    {
        "link": "https://embeddedflakes.com/serial-communication-protocols",
        "document": "In the world of microcontrollers, the 8051 family stands as a testament to enduring design and versatility. At the heart of its functionality lies serial communication, a cornerstone of modern embedded systems. We’ll explore 10 groundbreaking 8051 serial communication protocols that are set to revolutionize your approach to microcontroller programming and design.\n\nUART remains the backbone of serial communication in 8051 microcontrollers. Its simplicity and reliability make it an indispensable tool for developers.\n\nThis code sets up UART communication at 9600 baud, a common speed for many applications.\n\nSerial Peripheral Interface (SPI) offers high-speed, full-duplex communication for 8051 systems. Its synchronous nature allows for faster data transfer compared to UART.\n\nInter-Integrated Circuit (I2C) protocol provides a versatile two-wire interface for connecting multiple devices. Its addressing scheme allows for easy expansion of your 8051 system.\n\nController Area Network (CAN) brings industrial-strength communication to 8051 systems. Its error-checking and priority-based messaging make it ideal for noisy environments.\n\nLocal Interconnect Network (LIN) offers a cost-effective alternative to CAN for automotive applications. Its single-wire design simplifies wiring harnesses.\n\nOneWire protocol allows multiple devices to communicate over a single wire, ideal for temperature sensing and simple networks.\n\nRS-485 extends the range of serial communication, allowing for networks spanning hundreds of meters. Its differential signaling provides excellent noise immunity.\n\nModbus brings standardized industrial communication to 8051 systems. Its simple structure makes it easy to implement and debug.\n\nSENT (Single Edge Nibble Transmission) protocol offers a simple, low-cost alternative for automotive sensor applications. Its unidirectional nature simplifies implementation.\n\nIrDA brings wireless communication to 8051 systems through infrared light. It’s perfect for short-range, line-of-sight applications.\n\nTo fully understand these protocols, let’s examine some basic circuit diagrams for common implementations.\n\nThis simple UART connection requires only two wires for bidirectional communication.\n\nThe SPI protocol uses four wires, allowing for full-duplex communication with multiple devices.\n\nI2C uses just two wires, with pull-up resistors typically required on both lines.\n\nNow that we’ve explored these 10 powerful serial communication protocols, let’s discuss how to effectively implement them in your 8051 projects.\n\nSelecting the appropriate protocol depends on several factors:\n• Communication distance: For short distances, UART or SPI may suffice. For longer ranges, consider RS-485 or CAN.\n• Number of devices: I2C and SPI excel at connecting multiple devices.\n• Speed requirements: SPI offers the highest speed, while protocols like LIN prioritize simplicity over speed.\n• Environmental conditions: In noisy industrial settings, CAN or RS-485 provide robust communication.\n\nTo get the most out of your chosen protocol, consider these optimization techniques:\n• Use interrupts: Implement interrupt-driven communication to free up CPU time for other tasks.\n• Error handling: Implement robust error detection and recovery mechanisms, especially for protocols like CAN and Modbus.\n• Clock synchronization: For synchronous protocols like SPI, ensure proper clock synchronization between devices.\n\nEffective debugging is crucial when working with serial protocols. Here are some tips:\n• Use a logic analyzer: This tool can help visualize the timing of your signals.\n• Add debug output: Use LEDs or additional UART outputs to indicate communication status.\n• Check termination: Ensure proper line termination, especially for protocols like RS-485.\n\nAs you become more proficient with these protocols, consider exploring these advanced topics:\n• Custom protocols: Develop your own protocol tailored to your specific application needs.\n• Protocol bridges: Create systems that can translate between different protocols, such as UART to I2C.\n• Wireless adaptations: Explore how to adapt wired protocols for wireless communication using RF modules.\n\nThese 10 8051 serial communication protocols offer a wealth of possibilities for your embedded systems projects. By mastering these protocols, you’ll be well-equipped to tackle a wide range of communication challenges in your 8051-based designs. Remember, the key to success lies not just in understanding the protocols, but in choosing the right one for your specific application and implementing it effectively.\n\nAs you continue to explore and experiment with these protocols, you’ll discover new ways to push the boundaries of what’s possible with 8051 microcontrollers. The versatility and power of these communication methods will undoubtedly change your approach to embedded system design, opening up new avenues for innovation and efficiency in your projects."
    },
    {
        "link": "https://embetronicx.com/tutorials/microcontrollers/8051/8051-uart-tutorial-serial-communication",
        "document": "Hi everyone, today we are going to transfer data using UART and how to use UART’s SFR (8051 UART Tutorial).\n\nThis article provides a comprehensive tutorial on UART communication with an 8051 microcontroller. It covers key aspects such as UART registers (SFRs), detailed explanations of register bits, configuration of UART modes, and baud rate generation using Timer 1.\n\nThis tutorial also includes practical programming examples for both sending and receiving data via UART.\n\nUART (Universal Asynchronous Receiver/Transmitter) is a fundamental protocol used for serial data exchange between devices.\n\nBut before that, you should know about basic Serial Communication.\n\nThe microcontroller MCS51 has an inbuilt UART for carrying out serial communication. The serial communication is done in the asynchronous mode.\n\nA serial port, like other PC ports, is a physical interface to establish data transfer between a computer and external hardware or device. This transfer, through a serial port, takes place bit by bit.\n\nBit Addressable: We can assign the values bit by bit. For example, for a single bit, we can set whether 1 or 0.\n\nByte Addressable: We can’t assign the values bit by bit. We can set only byte by byte.\n\nFirst, we will see the SFRs.\n\nThese Two bits are used to select the Mode of the UART.\n\nSM2: Multiprocessor communications bit. Set/cleared by the program to enable multiprocessor communications in modes 2 and 3. When set to 1 an interrupt is generated if bit 9 of the received data is a 1; no interrupt is generated if bit 9 is a 0. If set to 1 for mode 1, no interrupt will be generated unless a valid stop bit is received. Clear to 0 if mode 0 is in use.\n\nREN: Receive enable bit. Set to 1 to enable reception; cleared to 0 to disable reception.\n\nTB8: Transmitted bit 8. Set/cleared by the program in modes 2 and 3.\n\nRB8: Received bit 8. Bit 8 of received data in modes 2 and 3; stop bit in mode 1. Not used in mode 0.\n\nTI: Transmit Interrupt flag. Set to one at the end of bit 7 time in mode 0, and at the beginning of the stop bit for other modes. Must be cleared by the program.\n\nRI: Receive Interrupt flag. Set to one at the end of bit 7 time in mode 0, and halfway through the stop bit for other moves. Must be cleared by the program.\n\nThe first four bits (bits 4 through 7) are configuration bits. Bits SM0 and SM1 let us set the serial mode to a value between 0 and 3, inclusive. The four modes are defined in the chart immediately above.\n\nAs you can see, selecting the Serial Mode selects the mode of operation (8-bit/9-bit, UART, or Shift Register) and also determines how the baud rate will be calculated. In modes 0 and 2 the baud rate is fixed based on the oscillator’s frequency.\n\nIn modes 1 and 3 the baud rate is variable based on how often Timer 1 overflows. We’ll talk more about the various Serial Modes in a moment.\n\nThe next bit, SM2, is a flag for “Multiprocessor communication.” Generally, whenever a byte has been received the 8051 will set the “RI” (Receive Interrupt) flag.\n\nThis lets the program know that a byte has been received and that it needs to be processed. However, when SM2 is set the “RI” flag will only be triggered if the 9th bit received was a “1”. That is to say, if SM2 is set and a byte is received whose 9th bit is clear, the RI flag will never be set.\n\nThis can be useful in certain advanced serial applications. For now, it is safe to say that you will almost always want to clear this bit so that the flag is set upon reception of any character.\n\nThe next bit, REN, is “Receiver Enable.” This bit is very straightforward: If you want to receive data via the serial port, set this bit. You will almost always want to set this bit.\n\nThe last four bits (bits 0 through 3) are operational bits. They are used when actually sending and receiving data. They are not used to configure the serial port.\n\nThe TB8 bit is used in modes 2 and 3. In modes 2 and 3, a total of nine data bits are transmitted. The first 8 data bits are the 8 bits of the main value, and the ninth bit is taken from TB8.\n\nIf TB8 is set and a value is written to the serial port, the data’s bits will be written to the serial line followed by a “set” ninth bit. If TB8 is clear the ninth bit will be “clear.”\n\nThe RB8 also operates in modes 2 and 3 and functions essentially the same way as TB8 but on the reception side. When a byte is received in modes 2 or 3, a total of nine bits are received.\n\nIn this case, the first eight bits received are the data of the serial byte received and the value of the ninth bit received will be placed in RB8.\n\nTI means “Transmit Interrupt.” When a program writes a value to the serial port, a certain amount of time will pass before the individual bits of the byte are “clocked out” the serial port.\n\nIf the program were to write another byte to the serial port before the first byte was completely output, the data being sent would be garbled. Thus, the 8051 lets the program know that it has “clocked out” the last byte by setting the TI bit.\n\nWhen the TI bit is set, the program may assume that the serial port is “free” and ready to send the next byte.\n\nFinally, the RI bit means “Receive Interrupt.” It functions similarly to the “TI” bit, but it indicates that a byte has been received. That is to say, whenever the 8051 has received a complete byte, it will trigger the RI bit to let the program know that it needs to read the value quickly before another byte is read.\n• None SBUF Register: For a byte of data to be transferred via the TxD line, it must be placed in the SBUF.\n• None SBUF holds the byte of data when it is received by the MCS51’s RxD line.\n\nThis Register is not Bit Addressable.\n\nSMOD: Double baud rate bit. If Timer 1 is used to generate the baud rate and SMOD = 1, the baud rate is doubled when the serial port is used in modes 1, 2, or 3.\n\nPD: Power Down bit. Setting this bit activates the power-down operation in the 8051BH. (Available only in CHMOS).\n\nIDL: Idle Mode bit. Setting this bit activates the Idle Mode operation in the 8051BH. (Available only in CHMOS).\n\nThat’s all about Registers. When using the integrated serial port, obviously configure it. This lets us tell the 8051 how many data bits we want, the baud rate we will be using, and how the baud rate will be determined.\n\nHere we are going to use Mode 1 because that is an 8-bit UART, and we can generate Baudrate using Timer 1. If you don’t know about the timer, please check the timer counter tutorial.\n\nSo Mode 1 means we have to give 0x50 value to the SCON Register.\n\nOnce the Serial Port Mode has been configured, as explained above, the program must configure the serial port’s baud rate. This only applies to Serial Port modes 1 and 3.\n\nThe Baud Rate is determined based on the oscillator’s frequency when in modes 0 and 2.\n\nIn mode 0, the baud rate is always the oscillator frequency divided by 12. This means if your crystal is 11.0592Mhz, the mode 0 baud rate will always be 921,583 baud.\n\nIn mode 2 the baud rate is always the oscillator frequency divided by 64, so a 11.059Mhz crystal speed will yield a baud rate of 172,797.\n\nIn modes 1 and 3, the baud rate is determined by how frequently timer 1 overflows. The more frequently timer 1 overflows, the higher the baud rate.\n\nThere are many ways one can cause timer 1 to overflow at a rate that determines a baud rate, but the most common method is to put timer 1 in 8-bit auto-reload mode (timer mode 2) and set a reload value (TH1) that causes Timer 1 to overflow at a frequency appropriate to generate a baud rate.\n\nTo determine the value that must be placed in TH1 to generate a given baud rate, we may use the following equation (assuming PCON.7 is clear).\n\nIf PCON.7 is set then the baud rate is effectively doubled, thus the equation becomes:\n\nFor example, if we have an 11.0592Mhz crystal and we want to configure the serial port to 19,200 baud we try plugging it in the first equation:\n\nAs you can see, to obtain a 19,200 baud rate on an 11.059Mhz crystal, we’d have to set TH1 to 254.5. If we set it to 254, we will have achieved 14,400 baud and if we set it to 255, we will have achieved 28,800 baud. Thus we’re stuck…\n\nBut not quite… to achieve 19,200 baud, we simply need to set PCON.7 (SMOD). When we do this, we double the baud rate and utilize the second equation mentioned above. Thus we have:\n\nHere we are able to calculate a nice, even TH1 value. Therefore, to obtain 19,200 baud with an 11.059MHz crystal we must:\n• None Set TH1 to 253 to reflect the correct frequency for 19,200 baud.\n\nThis program is used to send the data “embetronicx” via a serial port to the computer.\n\nIn this program, I have added the receiver code also. This code sends the data to the 8051 microcontrollers whatever I’m typing on the keyboard of the computer. Then microcontroller again resends the data to the computer.\n\nThat’s all guys… Hope you have understood. If you have any doubt please ask us by commenting below.\n\nNow, let me give you a task…share in the comment if you are able to do it or not…\n• None Connect the 8 LEDs to P2. Whenever I send “ON” to the Microcontroller, those LEDs should be On. Whenever I send “OFF” to the microcontroller, That time it should be Off.\n• None Connect LCD and Serial port to 8051. I have to display the character in LCD, whatever I’m sending from UART.\n\nYou can also read the below tutorials."
    }
]