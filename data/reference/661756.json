[
    {
        "link": "https://docs.aiogram.dev",
        "document": "# Bot token can be obtained via https://t.me/BotFather # All handlers should be attached to the Router (or Dispatcher) # Most event objects have aliases for API methods that can be called in events' context # For example if you want to answer to incoming message you can use `message.answer(...)` alias # and the target chat will be passed to :ref:`aiogram.methods.send_message.SendMessage` Handler will forward receive a message back to the sender By default, message handler will handle all message types (like a text, photo, sticker etc.) # But not all the types is supported to be copied so need to handle it # Initialize Bot instance with default bot properties which will be passed to all API calls"
    },
    {
        "link": "https://aiogram.dev",
        "document": ""
    },
    {
        "link": "https://github.com/aiogram/aiogram",
        "document": "aiogram is a modern and fully asynchronous framework for Telegram Bot API written in Python 3.8+ using asyncio and aiohttp.\n\nMake your bots faster and more powerful!\n• Has type hints (PEP 484) and can be used with mypy\n• Supports Telegram Bot API 8.3 and gets fast updates to the latest versions of the Bot API\n• Telegram Bot API integration code was autogenerated and can be easily re-generated when API gets updated\n\nIt is strongly advised that you have prior experience working with asyncio before beginning to use aiogram. If you have any questions, you can visit our community chats on Telegram:"
    },
    {
        "link": "https://restack.io/p/aiogram-tutorial-answer-best-telegram-bot-frameworks-for-ai-cat-ai",
        "document": "Before you start setting up Aiogram, ensure your development environment meets the following requirements:\n• Python 3.8+: Download and install Python from Python's official website.\n• Preferred IDE: Use Visual Studio Code or PyCharm for a better development experience.\n\nHomebrew is a package manager for MacOS that simplifies the installation of software. To install Homebrew, run the following command in your terminal:\n\nPyEnv allows you to easily switch between multiple versions of Python. Install it using Homebrew:\n\nNow, install Python 3.10 (or any version 3.8+):\n\nPoetry is a dependency management tool for Python. Install it with:\n\nFollow the prompts to set up your project details. After initialization, install the dependencies:\n\nTo install Aiogram, use the following command within your Poetry environment:\n\nOnce Aiogram is installed, you can create a simple bot to test your setup. Here’s a basic example:\n\nReplace with your actual bot token. Run the script to start your bot and test if it responds to the command. This confirms that your Aiogram setup is successful and you are ready to develop your bot further."
    },
    {
        "link": "https://pypi.org/project/aiogram",
        "document": "A required part of this site couldn’t load. This may be due to a browser extension, network issues, or browser settings. Please check your connection, disable any ad blockers, or try using a different browser."
    },
    {
        "link": "http://docs.aiohttp.org/en/stable/client_quickstart.html",
        "document": "Eager to get started? This page gives a good introduction in how to get started with aiohttp client API.\n\nFirst, make sure that aiohttp is installed and up-to-date\n\nLet’s get started with some simple examples.\n\nBegin by importing the aiohttp module, and asyncio: Now, let’s try to get a web-page. For example let’s query : Now, we have a called and a object called . We can get all the information we need from the response. The mandatory parameter of coroutine is an HTTP url ( or class: instance). In order to make an HTTP POST request use coroutine: Other HTTP methods are available as well: To make several requests to the same site more simple, the parameter of constructor can be used. For example to request different endpoints of can be used the following code: Don’t create a session per request. Most likely you need a session per application which performs all requests together. More complex cases may require a session per site, e.g. one for Github and other one for Facebook APIs. Anyway making a session for every request is a very bad idea. A session contains a connection pool inside. Connection reusage and keep-alive (both are on by default) may speed up total performance. A session context manager usage is not mandatory but method should be called in this case, e.g.:\n\nYou often want to send some sort of data in the URL’s query string. If you were constructing the URL by hand, this data would be given as key/value pairs in the URL after a question mark, e.g. . Requests allows you to provide these arguments as a , using the keyword argument. As an example, if you wanted to pass and to , you would use the following code: You can see that the URL has been correctly encoded by printing the URL. For sending data with multiple values for the same key may be used; the library support nested lists ( ) alternative as well. It is also possible to pass a list of 2 item tuples as parameters, in that case you can specify multiple values for each key: You can also pass content as param, but beware – content is not encoded by library. Note that is not encoded: Canonicalization encodes host part by IDNA codec and applies requoting to path and query parts. For example is converted to . Sometimes canonicalization is not desirable if server accepts exact representation and does not requote URL itself. To disable canonicalization use parameter for URL construction: Passing params overrides , never use both options.\n\nWhile methods , and are very convenient you should use them carefully. All these methods load the whole response in memory. For example if you want to download several gigabyte sized files, these methods will load all the data in memory. Instead you can use the attribute. It is an instance of the class. The and transfer-encodings are automatically decoded for you: In general, however, you should use a pattern like this to save what is being streamed to a file: It is not possible to use , and after explicit reading from .\n\nTypically, you want to send some form-encoded data – much like an HTML form. To do this, simply pass a dictionary to the data argument. Your dictionary of data will automatically be form-encoded when the request is made: If you want to send data that is not form-encoded you can do it by passing a instead of a . This data will be posted directly and content-type set to ‘application/octet-stream’ by default: If you want to send JSON data: To send text with appropriate content-type just use argument:\n\nsupports multiple types of streaming uploads, which allows you to send large files without reading them into memory. As a simple case, simply provide a file-like object for your body: Or you can use asynchronous generator: # Then you can use file_sender as a data provider: Because the attribute is a (provides async iterator protocol), you can chain get and post requests together: Python 3.5 has no native support for asynchronous generators, use library as workaround. Deprecated since version 3.1: still supports decorator but this approach is deprecated in favor of asynchronous generators as shown above.\n\nYou have to use the coroutine for client websocket connection. It accepts a url as a first parameter and returns , with that object you can communicate with websocket server using response’s methods: You must use the only websocket task for both reading (e.g. or ) and writing but may have multiple writer tasks which can only send data asynchronously (by for example).\n\nBy default aiohttp uses a total 300 seconds (5min) timeout, it means that the whole operation should finish in 5 minutes. In order to allow time for DNS fallback, the default timeout is 30 seconds. The value could be overridden by timeout parameter for the session (specified in seconds): Timeout could be overridden for a request like : The maximal number of seconds for the whole operation including connection establishment, request sending and response reading. The maximal number of seconds for connection establishment of a new connection or for waiting for a free connection from a pool if pool connection limits are exceeded. The maximal number of seconds for connecting to a peer for a new connection, not given from a pool. The maximal number of seconds allowed for period between reading a new data portion from a peer. The threshold value to trigger ceiling of absolute timeout values. All fields are floats, or disables a particular timeout check, see the reference for defaults and additional details. Thus the default timeout is: aiohttp ceils timeout if the value is equal or greater than 5 seconds. The timeout expires at the next integer second greater than . The ceiling is done for the sake of optimization, when many concurrent tasks are scheduled to wake-up at the almost same but different absolute times. It leads to very many event loop wakeups, which kills performance. The optimization shifts absolute wakeup times by scheduling them to exactly the same time as other neighbors, the loop wakes up once-per-second for timeout expiration. Smaller timeouts are not rounded to help testing; in the real life network timeouts usually greater than tens of seconds. However, the default threshold value of 5 seconds can be configured using the parameter."
    },
    {
        "link": "https://stackoverflow.com/questions/77353402/aiohttp-posting-list-of-jsons",
        "document": "I saw in somebody's code that they are posting a list of requests in one aiohttp post call, and expecting to receive list of responses back. I have tried that myself and it worked (if you are curious what I'm requesting, those are blocks of Ethereum, I'm talking to a live node):\n\nand I actually got a list with two responses, however status is a single number 200. How is this possible? Documentation for aiohttp never mentions possibility of posting a list."
    },
    {
        "link": "https://scrapeops.io/python-web-scraping-playbook/python-aiohttp-post-requests",
        "document": "In this guide for The Python Web Scraping Playbook, we will look at how to make requests with the Python aiohttp library.\n\nIn this guide we will walk you through the most common ways of sending POST requests with Python aiohttp:\n\nA common scenario for using requests is to send JSON data to an API endpoint, etc. Doing this with Python aioHTTP is very simple.\n\nHere we will use Python aiohttp's Session functionality to send POST requests.\n\nWe need to use to create a new instance of the ClientSession class. The statement is used to create a context manager for the to manage the life cycle of the session object. Next, we make a POST request using the method. Then, We simply need to add the data to the request using the parameter of the request:\n\nThe aiohttp library will automatically encode the data as JSON and set the header to .\n\nThis approach can be simpler and more concise than manually encoding the data and setting the headers. Additionally, it may offer some performance benefits, as the Python aiohttp library can use a more efficient encoding method for JSON data.\n\nAnother common use case for using requests is to send form data to an endpoint.\n\nWe simply just need to add the data to the request using the parameter of the request:\n\nThe aiohttp library will automatically encode the data as JSON and set the header to so you don't have to set any headers.\n\nAs we've seen above when you use the data or parameter to send data with the request is defaults the header to either or .\n\nHowever, if you would like to override this or send data with another then you can do so by just adding the header to the request.\n\nIn the following example, we will send JSON data using the data parameter instead of the parameter as we did previously.\n\nSo that's how you can send POST requests using Python aiohttp.\n\nIf you would like to learn more about Web Scraping, then be sure to check out The Web Scraping Playbook.\n\nOr check out one of our more in-depth guides:\n• How to Scrape The Web Without Getting Blocked Guide"
    },
    {
        "link": "https://docs.aiohttp.org/en/v3.7.3/client_quickstart.html",
        "document": "Eager to get started? This page gives a good introduction in how to get started with aiohttp client API.\n\nFirst, make sure that aiohttp is installed and up-to-date\n\nLet’s get started with some simple examples.\n\nBegin by importing the aiohttp module, and asyncio: Now, let’s try to get a web-page. For example let’s query : Now, we have a called and a object called . We can get all the information we need from the response. The mandatory parameter of coroutine is an HTTP url ( or class: instance). In order to make an HTTP POST request use coroutine: Other HTTP methods are available as well: Don’t create a session per request. Most likely you need a session per application which performs all requests altogether. More complex cases may require a session per site, e.g. one for Github and other one for Facebook APIs. Anyway making a session for every request is a very bad idea. A session contains a connection pool inside. Connection reusage and keep-alives (both are on by default) may speed up total performance. A session context manager usage is not mandatory but method should be called in this case, e.g.:\n\nYou often want to send some sort of data in the URL’s query string. If you were constructing the URL by hand, this data would be given as key/value pairs in the URL after a question mark, e.g. . Requests allows you to provide these arguments as a , using the keyword argument. As an example, if you wanted to pass and to , you would use the following code: You can see that the URL has been correctly encoded by printing the URL. For sending data with multiple values for the same key may be used; the library support nested lists ( ) alternative as well. It is also possible to pass a list of 2 item tuples as parameters, in that case you can specify multiple values for each key: You can also pass content as param, but beware – content is not encoded by library. Note that is not encoded: Canonicalization encodes host part by IDNA codec and applies requoting to path and query parts. For example is converted to . Sometimes canonicalization is not desirable if server accepts exact representation and does not requote URL itself. To disable canonicalization use parameter for URL construction: Passing params overrides , never use both options.\n\nWhile methods , and are very convenient you should use them carefully. All these methods load the whole response in memory. For example if you want to download several gigabyte sized files, these methods will load all the data in memory. Instead you can use the attribute. It is an instance of the class. The and transfer-encodings are automatically decoded for you: In general, however, you should use a pattern like this to save what is being streamed to a file: It is not possible to use , and after explicit reading from .\n\nTypically, you want to send some form-encoded data – much like an HTML form. To do this, simply pass a dictionary to the data argument. Your dictionary of data will automatically be form-encoded when the request is made: If you want to send data that is not form-encoded you can do it by passing a instead of a . This data will be posted directly and content-type set to ‘application/octet-stream’ by default: If you want to send JSON data: To send text with appropriate content-type just use argument:\n\nsupports multiple types of streaming uploads, which allows you to send large files without reading them into memory. As a simple case, simply provide a file-like object for your body: Or you can use asynchronous generator: # Then you can use file_sender as a data provider: Because the attribute is a (provides async iterator protocol), you can chain get and post requests together: Python 3.5 has no native support for asynchronous generators, use library as workaround. Deprecated since version 3.1: still supports decorator but this approach is deprecated in favor of asynchronous generators as shown above.\n\nYou have to use the coroutine for client websocket connection. It accepts a url as a first parameter and returns , with that object you can communicate with websocket server using response’s methods: You must use the only websocket task for both reading (e.g. or ) and writing but may have multiple writer tasks which can only send data asynchronously (by for example).\n\nBy default aiohttp uses a total 300 seconds (5min) timeout, it means that the whole operation should finish in 5 minutes. The value could be overridden by timeout parameter for the session (specified in seconds): Timeout could be overridden for a request like : The maximal number of seconds for the whole operation including connection establishment, request sending and response reading. The maximal number of seconds for connection establishment of a new connection or for waiting for a free connection from a pool if pool connection limits are exceeded. The maximal number of seconds for connecting to a peer for a new connection, not given from a pool. The maximal number of seconds allowed for period between reading a new data portion from a peer. All fields are floats, or disables a particular timeout check, see the reference for defaults and additional details. Thus the default timeout is: aiohttp ceils timeout if the value is equal or greater than 5 seconds. The timeout expires at the next integer second greater than . The ceiling is done for the sake of optimization, when many concurrent tasks are scheduled to wake-up at the almost same but different absolute times. It leads to very many event loop wakeups, which kills performance. The optimization shifts absolute wakeup times by scheduling them to exactly the same time as other neighbors, the loop wakes up once-per-second for timeout expiration. Smaller timeouts are not rounded to help testing; in the real life network timeouts usually greater than tens of seconds."
    },
    {
        "link": "https://stackoverflow.com/questions/63847858/python-requests-session-post-to-aiohttp-session-post",
        "document": "I have a synchronous code with requests that I am trying to move to using aiohttp.ClientSession. Indeed, I have a class in which I set a aiohttp.ClientSession with various headers, among those an API key. The above code works for requesting data: (I deleted the init.... everything works but this function)\n\nFrom that, with the requests session, I obtain a valid response from the server.\n\nfor some reason, the code below, with aiohttp session does not work and I have no idea how to adapt it.\n\ndoes anybody knows my error please?"
    }
]