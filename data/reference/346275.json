[
    {
        "link": "https://docs.python.org/3/library/ctypes.html",
        "document": "is a foreign function library for Python. It provides C compatible data types, and allows calling functions in DLLs or shared libraries. It can be used to wrap these libraries in pure Python.\n\nNote: The code samples in this tutorial use to make sure that they actually work. Since some code samples behave differently under Linux, Windows, or macOS, they contain doctest directives in comments. Note: Some code samples reference the ctypes type. On platforms where it is an alias to . So, you should not be confused if is printed if you would expect — they are actually the same type. exports the cdll, and on Windows windll and oledll objects, for loading dynamic link libraries. You load libraries by accessing them as attributes of these objects. cdll loads libraries which export functions using the standard calling convention, while windll libraries call functions using the calling convention. oledll also uses the calling convention, and assumes the functions return a Windows error code. The error code is used to automatically raise an exception when the function call fails. Changed in version 3.3: Windows errors used to raise , which is now an alias of . Here are some examples for Windows. Note that is the MS standard C library containing most standard C functions, and uses the calling convention: Accessing the standard C library through will use an outdated version of the library that may be incompatible with the one being used by Python. Where possible, use native Python functionality, or else import and use the module. On Linux, it is required to specify the filename including the extension to load a library, so attribute access can not be used to load libraries. Either the method of the dll loaders should be used, or you should load the library by creating an instance of CDLL by calling the constructor: Functions are accessed as attributes of dll objects: Note that win32 system dlls like and often export ANSI as well as UNICODE versions of a function. The UNICODE version is exported with a appended to the name, while the ANSI version is exported with an appended to the name. The win32 function, which returns a module handle for a given module name, has the following C prototype, and a macro is used to expose one of them as depending on whether UNICODE is defined or not: windll does not try to select one of them by magic, you must access the version you need by specifying or explicitly, and then call it with bytes or string objects respectively. Sometimes, dlls export functions with names which aren’t valid Python identifiers, like . In this case you have to use to retrieve the function: On Windows, some dlls export functions not by name but by ordinal. These functions can be accessed by indexing the dll object with the ordinal number: You can call these functions like any other Python callable. This example uses the function, which takes no arguments and returns a pseudo-random integer: On Windows, you can call the function, which returns a win32 module handle (passing as single argument to call it with a pointer): is raised when you call an function with the calling convention, or vice versa: File , line , in : Procedure probably called with not enough arguments (4 bytes missing) File , line , in : Procedure probably called with too many arguments (4 bytes in excess) To find out the correct calling convention you have to look into the C header file or the documentation for the function you want to call. On Windows, uses win32 structured exception handling to prevent crashes from general protection faults when functions are called with invalid argument values: There are, however, enough ways to crash Python with , so you should be careful anyway. The module can be helpful in debugging crashes (e.g. from segmentation faults produced by erroneous C library calls). , integers, bytes objects and (unicode) strings are the only native Python objects that can directly be used as parameters in these function calls. is passed as a C pointer, bytes objects and strings are passed as pointer to the memory block that contains their data (char* or wchar_t*). Python integers are passed as the platform’s default C int type, their value is masked to fit into the C type. Before we move on calling functions with other parameter types, we have to learn more about data types.\n• None The constructor accepts any object with a truth value. All these types can be created by calling them with an optional initializer of the correct type and value: Since these types are mutable, their value can also be changed afterwards: Assigning a new value to instances of the pointer types , , and changes the memory location they point to, not the contents of the memory block (of course not, because Python string objects are immutable): You should be careful, however, not to pass them to functions expecting pointers to mutable memory. If you need mutable memory blocks, ctypes has a function which creates these in various ways. The current memory block contents can be accessed (or changed) with the property; if you want to access it as NUL terminated string, use the property: The function replaces the old function (which is still available as an alias). To create a mutable memory block containing unicode characters of the C type , use the function. Note that printf prints to the real standard output channel, not to , so these examples will only work at the console prompt, not from within IDLE or PythonWin: File , line , in : argument 2: TypeError: Don't know how to convert parameter 2 As has been mentioned before, all Python types except integers, strings, and bytes objects have to be wrapped in their corresponding type, so that they can be converted to the required C data type: On a lot of platforms calling variadic functions through ctypes is exactly the same as calling functions with a fixed number of parameters. On some platforms, and in particular ARM64 for Apple Platforms, the calling convention for variadic functions is different than that for regular functions. On those platforms it is required to specify the attribute for the regular, non-variadic, function arguments: Because specifying the attribute does not inhibit portability it is advised to always specify for all variadic functions. Calling functions with your own custom data types¶ You can also customize argument conversion to allow instances of your own classes be used as function arguments. looks for an attribute and uses this as the function argument. The attribute must be an integer, string, bytes, a instance, or an object with an attribute: If you don’t want to store the instance’s data in the instance variable, you could define a which makes the attribute available on request. It is possible to specify the required argument types of functions exported from DLLs by setting the attribute. must be a sequence of C data types (the function is probably not a good example here, because it takes a variable number and different types of parameters depending on the format string, on the other hand this is quite handy to experiment with this feature): Specifying a format protects against incompatible argument types (just as a prototype for a C function), and tries to convert the arguments to valid types: File , line , in : argument 2: TypeError: 'int' object cannot be interpreted as ctypes.c_char_p If you have defined your own classes which you pass to function calls, you have to implement a class method for them to be able to use them in the sequence. The class method receives the Python object passed to the function call, it should do a typecheck or whatever is needed to make sure this object is acceptable, and then return the object itself, its attribute, or whatever you want to pass as the C function argument in this case. Again, the result should be an integer, string, bytes, a instance, or an object with an attribute. By default functions are assumed to return the C int type. Other return types can be specified by setting the attribute of the function object. The C prototype of is . Because might be of a different type than the default return type int, you should specify the attribute: The argument types can be specified using : To call the function with a pointer as first argument, use : Here is a more advanced example, it uses the function, which expects a string pointer and a char, and returns a pointer to a string: If you want to avoid the calls above, you can set the attribute, and the second argument will be converted from a single character Python bytes object into a C char: You can also use a callable Python object (a function or a class for example) as the attribute, if the foreign function returns an integer. The callable will be called with the integer the C function returns, and the result of this call will be used as the result of your function call. This is useful to check for error return values and automatically raise an exception: File , line , in File , line , in : [Errno 126] The specified module could not be found. is a function which will call Windows api to get the string representation of an error code, and returns an exception. takes an optional error code parameter, if no one is used, it calls to retrieve it. Please note that a much more powerful error checking mechanism is available through the attribute; see the reference manual for details. Sometimes a C api function expects a pointer to a data type as parameter, probably to write into the corresponding location, or if the data is too large to be passed by value. This is also known as passing parameters by reference. exports the function which is used to pass parameters by reference. The same effect can be achieved with the function, although does a lot more work since it constructs a real pointer object, so it is faster to use if you don’t need the pointer object in Python itself: Structures and unions must derive from the and base classes which are defined in the module. Each subclass must define a attribute. must be a list of 2-tuples, containing a field name and a field type. The field type must be a type like , or any other derived type: structure, union, array, pointer. Here is a simple example of a POINT structure, which contains two integers named x and y, and also shows how to initialize a structure in the constructor: You can, however, build much more complicated structures. A structure can itself contain other structures by using a structure as a field type. Here is a RECT structure which contains two POINTs named upperleft and lowerright: Nested structures can also be initialized in the constructor in several ways: Field descriptors can be retrieved from the class, they are useful for debugging because they can provide useful information: does not support passing unions or structures with bit-fields to functions by value. While this may work on 32-bit x86, it’s not guaranteed by the library to work in the general case. Unions and structures with bit-fields should always be passed to functions by pointer. By default, Structure and Union fields are aligned in the same way the C compiler does it. It is possible to override this behavior by specifying a class attribute in the subclass definition. This must be set to a positive integer and specifies the maximum alignment for the fields. This is what also does in MSVC. It is also possible to set a minimum alignment for how the subclass itself is packed in the same way works in MSVC. This can be achieved by specifying a class attribute in the subclass definition. uses the native byte order for Structures and Unions. To build structures with non-native byte order, you can use one of the , , , and base classes. These classes cannot contain pointer fields. It is possible to create structures and unions containing bit fields. Bit fields are only possible for integer fields, the bit width is specified as the third item in the tuples: Arrays are sequences, containing a fixed number of instances of the same type. The recommended way to create array types is by multiplying a data type with a positive integer: Here is an example of a somewhat artificial data type, a structure containing 4 POINTs among other stuff: Instances are created in the usual way, by calling the class: The above code print a series of lines, because the array contents is initialized to zeros. Initializers of the correct type can also be specified: Pointer instances are created by calling the function on a type: Pointer instances have a attribute which returns the object to which the pointer points, the object above: Note that does not have OOR (original object return), it constructs a new, equivalent object each time you retrieve an attribute: Assigning another instance to the pointer’s contents attribute would cause the pointer to point to the memory location where this is stored: Pointer instances can also be indexed with integers: Assigning to an integer index changes the pointed to value: It is also possible to use indexes different from 0, but you must know what you’re doing, just as in C: You can access or change arbitrary memory locations. Generally you only use this feature if you receive a pointer from a C function, and you know that the pointer actually points to an array instead of a single item. Behind the scenes, the function does more than simply create pointer instances, it has to create pointer types first. This is done with the function, which accepts any type, and returns a new type: Calling the pointer type without an argument creates a pointer. pointers have a boolean value: checks for when dereferencing pointers (but dereferencing invalid non- pointers would crash Python): Usually, ctypes does strict type checking. This means, if you have in the list of a function or as the type of a member field in a structure definition, only instances of exactly the same type are accepted. There are some exceptions to this rule, where ctypes accepts other objects. For example, you can pass compatible array instances instead of pointer types. So, for , ctypes accepts an array of c_int: In addition, if a function argument is explicitly declared to be a pointer type (such as ) in , an object of the pointed type ( in this case) can be passed to the function. ctypes will apply the required conversion in this case automatically. To set a POINTER type field to , you can assign : Sometimes you have instances of incompatible types. In C, you can cast one type into another type. provides a function which can be used in the same way. The structure defined above accepts pointers or arrays for its field, but not instances of other types: For these cases, the function is handy. The function can be used to cast a ctypes instance into a pointer to a different ctypes data type. takes two parameters, a ctypes object that is or can be converted to a pointer of some kind, and a ctypes pointer type. It returns an instance of the second argument, which references the same memory block as the first argument: So, can be used to assign to the field of the structure: Incomplete Types are structures, unions or arrays whose members are not yet specified. In C, they are specified by forward declarations, which are defined later: The straightforward translation into ctypes code would be this, but it does not work: File , line , in File , line , in : name 'cell' is not defined because the new is not available in the class statement itself. In , we can define the class and set the attribute later, after the class statement: Let’s try it. We create two instances of , and let them point to each other, and finally follow the pointer chain a few times: allows creating C callable function pointers from Python callables. These are sometimes called callback functions. First, you must create a class for the callback function. The class knows the calling convention, the return type, and the number and types of arguments this function will receive. The factory function creates types for callback functions using the calling convention. On Windows, the factory function creates types for callback functions using the calling convention. Both of these factory functions are called with the result type as first argument, and the callback functions expected argument types as the remaining arguments. I will present an example here which uses the standard C library’s function, that is used to sort items with the help of a callback function. will be used to sort an array of integers: must be called with a pointer to the data to sort, the number of items in the data array, the size of one item, and a pointer to the comparison function, the callback. The callback will then be called with two pointers to items, and it must return a negative integer if the first item is smaller than the second, a zero if they are equal, and a positive integer otherwise. So our callback function receives pointers to integers, and must return an integer. First we create the for the callback function: To get started, here is a simple callback that shows the values it gets passed: Now we can actually compare the two items and return a useful result: As we can easily check, our array is sorted now: The function factories can be used as decorator factories, so we may as well write: Make sure you keep references to objects as long as they are used from C code. doesn’t, and if you don’t, they may be garbage collected, crashing your program when a callback is made. Also, note that if the callback function is called in a thread created outside of Python’s control (e.g. by the foreign code that calls the callback), ctypes creates a new dummy Python thread on every invocation. This behavior is correct for most purposes, but it means that values stored with will not survive across different callbacks, even when those calls are made from the same C thread. Some shared libraries not only export functions, they also export variables. An example in the Python library itself is the , Python runtime version number encoded in a single constant integer. can access values like this with the class methods of the type. pythonapi is a predefined symbol giving access to the Python C api: An extended example which also demonstrates the use of pointers accesses the pointer exported by Python. Quoting the docs for that value: This pointer is initialized to point to an array of records, terminated by one whose members are all or zero. When a frozen module is imported, it is searched in this table. Third-party code could play tricks with this to provide a dynamically created collection of frozen modules. So manipulating this pointer could even prove useful. To restrict the example size, we show only how this table can be read with : We have defined the data type, so we can get the pointer to the table: Since is a to the array of records, we can iterate over it, but we just have to make sure that our loop terminates, because pointers have no size. Sooner or later it would probably crash with an access violation or whatever, so it’s better to break out of the loop when we hit the entry: The fact that standard Python has a frozen module and a frozen package (indicated by the negative member) is not well known, it is only used for testing. Try it out with for example. There are some edges in where you might expect something other than what actually happens. Consider the following example: # now swap the two points Hm. We certainly expected the last statement to print . What happened? Here are the steps of the line above: Note that and are objects still using the internal buffer of the object above. So executing copies the buffer contents of into ‘s buffer. This, in turn, changes the contents of . So, the last assignment , doesn’t have the expected effect. Keep in mind that retrieving sub-objects from Structure, Unions, and Arrays doesn’t copy the sub-object, instead it retrieves a wrapper object accessing the root-object’s underlying buffer. Another example that may behave differently from what one would expect is this: Objects instantiated from can only have their value set to bytes or integers. Why is it printing ? ctypes instances are objects containing a memory block plus some descriptors accessing the contents of the memory. Storing a Python object in the memory block does not store the object itself, instead the of the object is stored. Accessing the contents again constructs a new Python object each time! provides some support for variable-sized arrays and structures. The function can be used to resize the memory buffer of an existing ctypes object. The function takes the object as first argument, and the requested size in bytes as the second argument. The memory block cannot be made smaller than the natural memory block specified by the objects type, a is raised if this is tried: This is nice and fine, but how would one access the additional elements contained in this array? Since the type still only knows about 4 elements, we get errors accessing other elements: Another way to use variable-sized data types with is to use the dynamic nature of Python, and (re-)define the data type after the required size is already known, on a case by case basis.\n\nWhen programming in a compiled language, shared libraries are accessed when compiling/linking a program, and when the program is run. The purpose of the function is to locate a library in a way similar to what the compiler or runtime loader does (on platforms with several versions of a shared library the most recent should be loaded), while the ctypes library loaders act like when a program is run, and call the runtime loader directly. The module provides a function which can help to determine the library to load. Try to find a library and return a pathname. name is the library name without any prefix like lib, suffix like , or version number (this is the form used for the posix linker option ). If no library can be found, returns . On Linux, tries to run external programs ( , , and ) to find the library file. It returns the filename of the library file. Changed in version 3.6: On Linux, the value of the environment variable is used when searching for libraries, if a library cannot be found by any other means. On macOS and Android, uses the system’s standard naming schemes and paths to locate the library, and returns a full pathname if successful: On Windows, searches along the system search path, and returns the full pathname, but since there is no predefined naming scheme a call like will fail and return . If wrapping a shared library with , it may be better to determine the shared library name at development time, and hardcode that into the wrapper module instead of using to locate the library at runtime. There are several ways to load shared libraries into the Python process. One way is to instantiate one of the following classes: Instances of this class represent loaded shared libraries. Functions in these libraries use the standard C calling convention, and are assumed to return int. On Windows creating a instance may fail even if the DLL name exists. When a dependent DLL of the loaded DLL is not found, a error is raised with the message “[WinError 126] The specified module could not be found”. This error message does not contain the name of the missing DLL because the Windows API does not return this information making this error hard to diagnose. To resolve this error and determine which DLL is not found, you need to find the list of dependent DLLs and determine which one is not found using Windows debugging and tracing tools. Changed in version 3.12: The name parameter can now be a path-like object. Instances of this class represent loaded shared libraries, functions in these libraries use the calling convention, and are assumed to return the windows specific code. values contain information specifying whether the function call failed or succeeded, together with additional error code. If the return value signals a failure, an is automatically raised. Changed in version 3.3: used to be raised, which is now an alias of . Changed in version 3.12: The name parameter can now be a path-like object. Instances of this class represent loaded shared libraries, functions in these libraries use the calling convention, and are assumed to return int by default. Changed in version 3.12: The name parameter can now be a path-like object. The Python global interpreter lock is released before calling any function exported by these libraries, and reacquired afterwards. Instances of this class behave like instances, except that the Python GIL is not released during the function call, and after the function execution the Python error flag is checked. If the error flag is set, a Python exception is raised. Thus, this is only useful to call Python C api functions directly. Changed in version 3.12: The name parameter can now be a path-like object. All these classes can be instantiated by calling them with at least one argument, the pathname of the shared library. If you have an existing handle to an already loaded shared library, it can be passed as the named parameter, otherwise the underlying platform’s or function is used to load the library into the process, and to get a handle to it. The mode parameter can be used to specify how the library is loaded. For details, consult the dlopen(3) manpage. On Windows, mode is ignored. On posix systems, RTLD_NOW is always added, and is not configurable. The use_errno parameter, when set to true, enables a ctypes mechanism that allows accessing the system error number in a safe way. maintains a thread-local copy of the system’s variable; if you call foreign functions created with then the value before the function call is swapped with the ctypes private copy, the same happens immediately after the function call. The function returns the value of the ctypes private copy, and the function changes the ctypes private copy to a new value and returns the former value. The use_last_error parameter, when set to true, enables the same mechanism for the Windows error code which is managed by the and Windows API functions; and are used to request and change the ctypes private copy of the windows error code. The winmode parameter is used on Windows to specify how the library is loaded (since mode is ignored). It takes any value that is valid for the Win32 API flags parameter. When omitted, the default is to use the flags that result in the most secure DLL load, which avoids issues such as DLL hijacking. Passing the full path to the DLL is the safest way to ensure the correct library and dependencies are loaded. Flag to use as mode parameter. On platforms where this flag is not available, it is defined as the integer zero. Flag to use as mode parameter. On platforms where this is not available, it is the same as RTLD_GLOBAL. The default mode which is used to load shared libraries. On OSX 10.3, this is RTLD_GLOBAL, otherwise it is the same as RTLD_LOCAL. Instances of these classes have no public methods. Functions exported by the shared library can be accessed as attributes or by index. Please note that accessing the function through an attribute caches the result and therefore accessing it repeatedly returns the same object each time. On the other hand, accessing it through an index returns a new object each time: The following public attributes are available, their name starts with an underscore to not clash with exported function names: The system handle used to access the library. The name of the library passed in the constructor. Shared libraries can also be loaded by using one of the prefabricated objects, which are instances of the class, either by calling the method, or by retrieving the library as attribute of the loader instance. Class which loads shared libraries. dlltype should be one of the , , , or types. has special behavior: It allows loading a shared library by accessing it as attribute of a library loader instance. The result is cached, so repeated attribute accesses return the same library each time. Load a shared library into the process and return it. This method always returns a new instance of the library. These prefabricated library loaders are available: For accessing the C Python api directly, a ready-to-use Python shared library object is available: An instance of that exposes Python C API functions as attributes. Note that all these functions are assumed to return C int, which is of course not always the truth, so you have to assign the correct attribute to use these functions. Loading a library through any of these objects raises an auditing event with string argument , the name used to load the library. Accessing a function on a loaded library raises an auditing event with arguments (the library object) and (the symbol’s name as a string or integer). In cases when only the library handle is available rather than the object, accessing a function raises an auditing event with arguments (the raw library handle) and . As explained in the previous section, foreign functions can be accessed as attributes of loaded shared libraries. The function objects created in this way by default accept any number of arguments, accept any ctypes data instances as arguments, and return the default result type specified by the library loader. They are instances of a private local class (not exposed in ) which inherits from the private class: Instances of foreign functions are also C compatible data types; they represent C function pointers. This behavior can be customized by assigning to special attributes of the foreign function object. Assign a ctypes type to specify the result type of the foreign function. Use for void, a function not returning anything. It is possible to assign a callable Python object that is not a ctypes type, in this case the function is assumed to return a C int, and the callable will be called with this integer, allowing further processing or error checking. Using this is deprecated, for more flexible post processing or error checking use a ctypes data type as and assign a callable to the attribute. Assign a tuple of ctypes types to specify the argument types that the function accepts. Functions using the calling convention can only be called with the same number of arguments as the length of this tuple; functions using the C calling convention accept additional, unspecified arguments as well. When a foreign function is called, each actual argument is passed to the class method of the items in the tuple, this method allows adapting the actual argument to an object that the foreign function accepts. For example, a item in the tuple will convert a string passed as argument into a bytes object using ctypes conversion rules. New: It is now possible to put items in argtypes which are not ctypes types, but each item must have a method which returns a value usable as argument (integer, string, ctypes instance). This allows defining adapters that can adapt custom objects as function parameters. Assign a Python function or another callable to this attribute. The callable will be called with three or more arguments: result is what the foreign function returns, as specified by the attribute. func is the foreign function object itself, this allows reusing the same callable object to check or post process the results of several functions. arguments is a tuple containing the parameters originally passed to the function call, this allows specializing the behavior on the arguments used. The object that this function returns will be returned from the foreign function call, but it can also check the result value and raise an exception if the foreign function call failed. This exception is raised when a foreign function call cannot convert one of the passed arguments. On Windows, when a foreign function call raises a system exception (for example, due to an access violation), it will be captured and replaced with a suitable Python exception. Further, an auditing event with argument will be raised, allowing an audit hook to replace the exception with its own. Some ways to invoke foreign function calls may raise an auditing event with arguments and . Foreign functions can also be created by instantiating function prototypes. Function prototypes are similar to function prototypes in C; they describe a function (return type, argument types, calling convention) without defining an implementation. The factory functions must be called with the desired result type and the argument types of the function, and can be used as decorator factories, and as such, be applied to functions through the syntax. See Callback functions for examples. The returned function prototype creates functions that use the standard C calling convention. The function will release the GIL during the call. If use_errno is set to true, the ctypes private copy of the system variable is exchanged with the real value before and after the call; use_last_error does the same for the Windows error code. The returned function prototype creates functions that use the calling convention. The function will release the GIL during the call. use_errno and use_last_error have the same meaning as above. The returned function prototype creates functions that use the Python calling convention. The function will not release the GIL during the call. Function prototypes created by these factory functions can be instantiated in different ways, depending on the type and number of the parameters in the call: Returns a foreign function at the specified address which must be an integer. Returns a foreign function exported by a shared library. func_spec must be a 2-tuple . The first item is the name of the exported function as string, or the ordinal of the exported function as small integer. The second item is the shared library instance. Returns a foreign function that will call a COM method. vtbl_index is the index into the virtual function table, a small non-negative integer. name is name of the COM method. iid is an optional pointer to the interface identifier which is used in extended error reporting. COM methods use a special calling convention: They require a pointer to the COM interface as first argument, in addition to those parameters that are specified in the tuple. The optional paramflags parameter creates foreign function wrappers with much more functionality than the features described above. paramflags must be a tuple of the same length as . Each item in this tuple contains further information about a parameter, it must be a tuple containing one, two, or three items. The first item is an integer containing a combination of direction flags for the parameter: Specifies an input parameter to the function. Output parameter. The foreign function fills in a value. Input parameter which defaults to the integer zero. The optional second item is the parameter name as string. If this is specified, the foreign function can be called with named parameters. The optional third item is the default value for this parameter. The following example demonstrates how to wrap the Windows function so that it supports default parameters and named arguments. The C declaration from the windows header file is this: Here is the wrapping with : The foreign function can now be called in these ways: A second example demonstrates output parameters. The win32 function retrieves the dimensions of a specified window by copying them into structure that the caller has to supply. Here is the C declaration: Here is the wrapping with : Functions with output parameters will automatically return the output parameter value if there is a single one, or a tuple containing the output parameter values when there are more than one, so the GetWindowRect function now returns a RECT instance, when called. Output parameters can be combined with the protocol to do further output processing and error checking. The win32 api function returns a to signal success or failure, so this function could do the error checking, and raises an exception when the api call failed: If the function returns the argument tuple it receives unchanged, continues the normal processing it does on the output parameters. If you want to return a tuple of window coordinates instead of a instance, you can retrieve the fields in the function and return them instead, the normal processing will no longer take place: Returns the address of the memory buffer as integer. obj must be an instance of a ctypes type. Returns the alignment requirements of a ctypes type. obj_or_type must be a ctypes type or instance. Returns a light-weight pointer to obj, which must be an instance of a ctypes type. offset defaults to zero, and must be an integer that will be added to the internal pointer value. corresponds to this C code: The returned object can only be used as a foreign function call parameter. It behaves similar to , but the construction is a lot faster. This function is similar to the cast operator in C. It returns a new instance of type which points to the same memory block as obj. type must be a pointer type, and obj must be an object that can be interpreted as a pointer. This function creates a mutable character buffer. The returned object is a ctypes array of . init_or_size must be an integer which specifies the size of the array, or a bytes object which will be used to initialize the array items. If a bytes object is specified as first argument, the buffer is made one item larger than its length so that the last element in the array is a NUL termination character. An integer can be passed as second argument which allows specifying the size of the array if the length of the bytes should not be used. This function creates a mutable unicode character buffer. The returned object is a ctypes array of . init_or_size must be an integer which specifies the size of the array, or a string which will be used to initialize the array items. If a string is specified as first argument, the buffer is made one item larger than the length of the string so that the last element in the array is a NUL termination character. An integer can be passed as second argument which allows specifying the size of the array if the length of the string should not be used. This function is a hook which allows implementing in-process COM servers with ctypes. It is called from the DllCanUnloadNow function that the _ctypes extension dll exports. This function is a hook which allows implementing in-process COM servers with ctypes. It is called from the DllGetClassObject function that the extension dll exports. Try to find a library and return a pathname. name is the library name without any prefix like , suffix like , or version number (this is the form used for the posix linker option ). If no library can be found, returns . Returns the filename of the VC runtime library used by Python, and by the extension modules. If the name of the library cannot be determined, is returned. If you need to free memory, for example, allocated by an extension module with a call to the , it is important that you use the function in the same library that allocated the memory. Returns a textual description of the error code code. If no error code is specified, the last error code is used by calling the Windows api function GetLastError. Returns the last error code set by Windows in the calling thread. This function calls the Windows function directly, it does not return the ctypes-private copy of the error code. Returns the current value of the ctypes-private copy of the system variable in the calling thread. Raises an auditing event with no arguments. Returns the current value of the ctypes-private copy of the system variable in the calling thread. Raises an auditing event with no arguments. Same as the standard C memmove library function: copies count bytes from src to dst. dst and src must be integers or ctypes instances that can be converted to pointers. Same as the standard C memset library function: fills the memory block at address dst with count bytes of value c. dst must be an integer specifying an address, or a ctypes instance. Create and return a new ctypes pointer type. Pointer types are cached and reused internally, so calling this function repeatedly is cheap. type must be a ctypes type. Create a new pointer instance, pointing to obj. The returned object is of the type . Note: If you just want to pass a pointer to an object to a foreign function call, you should use which is much faster. This function resizes the internal memory buffer of obj, which must be an instance of a ctypes type. It is not possible to make the buffer smaller than the native size of the objects type, as given by , but it is possible to enlarge the buffer. Set the current value of the ctypes-private copy of the system variable in the calling thread to value and return the previous value. Sets the current value of the ctypes-private copy of the system variable in the calling thread to value and return the previous value. Returns the size in bytes of a ctypes type or instance memory buffer. Does the same as the C operator. Return the byte string at void *ptr. If size is specified, it is used as size, otherwise the string is assumed to be zero-terminated. This function is probably the worst-named thing in ctypes. It creates an instance of . If code is not specified, is called to determine the error code. If descr is not specified, is called to get a textual description of the error. Changed in version 3.3: An instance of used to be created, which is now an alias of . Return the wide-character string at void *ptr. If size is specified, it is used as the number of characters of the string, otherwise the string is assumed to be zero-terminated. This non-public class is the common base class of all ctypes data types. Among other things, all ctypes type instances contain a memory block that hold C compatible data; the address of the memory block is returned by the helper function. Another instance variable is exposed as ; this contains other Python objects that need to be kept alive in case the memory block contains pointers. Common methods of ctypes data types, these are all class methods (to be exact, they are methods of the metaclass): This method returns a ctypes instance that shares the buffer of the source object. The source object must support the writeable buffer interface. The optional offset parameter specifies an offset into the source buffer in bytes; the default is zero. If the source buffer is not large enough a is raised. This method creates a ctypes instance, copying the buffer from the source object buffer which must be readable. The optional offset parameter specifies an offset into the source buffer in bytes; the default is zero. If the source buffer is not large enough a is raised. This method returns a ctypes type instance using the memory specified by address which must be an integer. This method, and others that indirectly call this method, raises an auditing event with argument . This method adapts obj to a ctypes type. It is called with the actual object used in a foreign function call when the type is present in the foreign function’s tuple; it must return an object that can be used as a function call parameter. All ctypes data types have a default implementation of this classmethod that normally returns obj if that is an instance of the type. Some types accept other objects as well. This method returns a ctypes type instance exported by a shared library. name is the name of the symbol that exports the data, library is the loaded shared library. Sometimes ctypes data instances do not own the memory block they contain, instead they share part of the memory block of a base object. The read-only member is the root ctypes object that owns the memory block. This read-only variable is true when the ctypes data instance has allocated the memory block itself, false otherwise. This member is either or a dictionary containing Python objects that need to be kept alive so that the memory block contents is kept valid. This object is only exposed for debugging; never modify the contents of this dictionary. This non-public class is the base class of all fundamental ctypes data types. It is mentioned here because it contains the common attributes of the fundamental ctypes data types. is a subclass of , so it inherits their methods and attributes. ctypes data types that are not and do not contain pointers can now be pickled. This attribute contains the actual value of the instance. For integer and pointer types, it is an integer, for character types, it is a single character bytes object or string, for character pointer types it is a Python bytes object or string. When the attribute is retrieved from a ctypes instance, usually a new object is returned each time. does not implement original object return, always a new object is constructed. The same is true for all other ctypes object instances. Fundamental data types, when returned as foreign function call results, or, for example, by retrieving structure field members or array items, are transparently converted to native Python types. In other words, if a foreign function has a of , you will always receive a Python bytes object, not a instance. Subclasses of fundamental data types do not inherit this behavior. So, if a foreign functions is a subclass of , you will receive an instance of this subclass from the function call. Of course, you can get the value of the pointer by accessing the attribute. These are the fundamental ctypes data types: Represents the C signed char datatype, and interprets the value as small integer. The constructor accepts an optional integer initializer; no overflow checking is done. Represents the C char datatype, and interprets the value as a single character. The constructor accepts an optional string initializer, the length of the string must be exactly one character. Represents the C char* datatype when it points to a zero-terminated string. For a general character pointer that may also point to binary data, must be used. The constructor accepts an integer address, or a bytes object. Represents the C double datatype. The constructor accepts an optional float initializer. Represents the C long double datatype. The constructor accepts an optional float initializer. On platforms where it is an alias to . Represents the C float datatype. The constructor accepts an optional float initializer. Represents the C signed int datatype. The constructor accepts an optional integer initializer; no overflow checking is done. On platforms where it is an alias to . Represents the C 8-bit signed int datatype. Usually an alias for . Represents the C 16-bit signed int datatype. Usually an alias for . Represents the C 32-bit signed int datatype. Usually an alias for . Represents the C 64-bit signed int datatype. Usually an alias for . Represents the C signed long datatype. The constructor accepts an optional integer initializer; no overflow checking is done. Represents the C signed long long datatype. The constructor accepts an optional integer initializer; no overflow checking is done. Represents the C signed short datatype. The constructor accepts an optional integer initializer; no overflow checking is done. Represents the C unsigned char datatype, it interprets the value as small integer. The constructor accepts an optional integer initializer; no overflow checking is done. Represents the C unsigned int datatype. The constructor accepts an optional integer initializer; no overflow checking is done. On platforms where it is an alias for . Represents the C 8-bit unsigned int datatype. Usually an alias for . Represents the C 16-bit unsigned int datatype. Usually an alias for . Represents the C 32-bit unsigned int datatype. Usually an alias for . Represents the C 64-bit unsigned int datatype. Usually an alias for . Represents the C unsigned long datatype. The constructor accepts an optional integer initializer; no overflow checking is done. Represents the C unsigned long long datatype. The constructor accepts an optional integer initializer; no overflow checking is done. Represents the C unsigned short datatype. The constructor accepts an optional integer initializer; no overflow checking is done. Represents the C void* type. The value is represented as integer. The constructor accepts an optional integer initializer. Represents the C datatype, and interprets the value as a single character unicode string. The constructor accepts an optional string initializer, the length of the string must be exactly one character. Represents the C wchar_t* datatype, which must be a pointer to a zero-terminated wide character string. The constructor accepts an integer address, or a string. Represent the C bool datatype (more accurately, _Bool from C99). Its value can be or , and the constructor accepts any object that has a truth value. Represents a value, which contains success or error information for a function or method call. Represents the C PyObject* datatype. Calling this without an argument creates a PyObject* pointer. The module provides quite some other Windows specific data types, for example , , or . Some useful structures like or are also defined. Abstract base class for unions in little endian byte order. Abstract base class for structures in little endian byte order. Structures and unions with non-native byte order cannot contain pointer type fields, or any other data types containing pointer type fields. Concrete structure and union types must be created by subclassing one of these types, and at least define a class variable. will create descriptors which allow reading and writing the fields by direct attribute accesses. These are the A sequence defining the structure fields. The items must be 2-tuples or 3-tuples. The first item is the name of the field, the second item specifies the type of the field; it can be any ctypes data type. For integer type fields like , a third optional item can be given. It must be a small positive integer defining the bit width of the field. Field names must be unique within one structure or union. This is not checked, only one field can be accessed when names are repeated. It is possible to define the class variable after the class statement that defines the Structure subclass, this allows creating data types that directly or indirectly reference themselves: The class variable must, however, be defined before the type is first used (an instance is created, is called on it, and so on). Later assignments to the class variable will raise an AttributeError. It is possible to define sub-subclasses of structure types, they inherit the fields of the base class plus the defined in the sub-subclass, if any. An optional small integer that allows overriding the alignment of structure fields in the instance. must already be defined when is assigned, otherwise it will have no effect. Setting this attribute to 0 is the same as not setting it at all. An optional small integer that allows overriding the alignment of the structure when being packed or unpacked to/from memory. Setting this attribute to 0 is the same as not setting it at all. An optional sequence that lists the names of unnamed (anonymous) fields. must be already defined when is assigned, otherwise it will have no effect. The fields listed in this variable must be structure or union type fields. will create descriptors in the structure type that allows accessing the nested fields directly, without the need to create the structure or union field. Here is an example type (Windows): The structure describes a COM data type, the field specifies which one of the union fields is valid. Since the field is defined as anonymous field, it is now possible to access the members directly off the TYPEDESC instance. and are equivalent, but the former is faster since it does not need to create a temporary union instance: It is possible to define sub-subclasses of structures, they inherit the fields of the base class. If the subclass definition has a separate variable, the fields specified in this are appended to the fields of the base class. Structure and union constructors accept both positional and keyword arguments. Positional arguments are used to initialize member fields in the same order as they are appear in . Keyword arguments in the constructor are interpreted as attribute assignments, so they will initialize with the same name, or create new attributes for names not present in . The recommended way to create concrete array types is by multiplying any data type with a non-negative integer. Alternatively, you can subclass this type and define and class variables. Array elements can be read and written using standard subscript and slice accesses; for slice reads, the resulting object is not itself an . A positive integer specifying the number of elements in the array. Out-of-range subscripts result in an . Will be returned by . Specifies the type of each element in the array. Array subclass constructors accept positional arguments, used to initialize the elements in order. Create an array. Equivalent to , where type is a data type and length an integer. This function is soft deprecated in favor of multiplication. There are no plans to remove it. Concrete pointer types are created by calling with the type that will be pointed to; this is done automatically by . If a pointer points to an array, its elements can be read and written using standard subscript and slice accesses. Pointer objects have no size, so will raise . Negative subscripts will read from the memory before the pointer (as in C), and out-of-range subscripts will probably crash with an access violation (if you’re lucky). Returns the object to which to pointer points. Assigning to this attribute changes the pointer to point to the assigned object."
    },
    {
        "link": "https://stackoverflow.com/questions/15195582/ctype-return-type-for-a-c-function",
        "document": "I have a C function as below :\n\nWhat I need is some functions like the one here, that will take in a char array and return a char array or a pointer to the char.\n\nI will compile these into a shared so and import it into python using ctypes.\n\nThis is how I have done so far :\n\nThe library does well, but I am not able to set the restype. When I do so, the code crashes with a seg fault.\n\nI need to call the functions in the c library one by one from python. The functions generally return encryptions. How can I define these functions so that they will accept strings from the ctype interface and return the encryptions in some storable form?\n\nAny help is appreciated. I am very weak with C pointers and related stuff. Thanks in advance\n\nThe segmentation fault was because of compilation error. If the function were to return an unsigned char, how would I have to declare the ctype variables in C?"
    },
    {
        "link": "https://svn.python.org/projects/ctypes/trunk/ctypes/docs/manual/tutorial.html",
        "document": "Note: The code samples in this tutorial uses to make sure that they actually work. Since some code samples behave differently under Linux, Windows, or Mac OS X, they contain doctest directives in comments.\n\nNote: Quite some code samples references the ctypes type. This type is an alias to the type on 32-bit systems. So, you should not be confused if is printed if you would expect - they are actually the same type.\n\nexports the , and on Windows also and objects to load dynamic link libraries. You load libraries by accessing them as attributes of these objects. loads libraries which export functions using the standard calling convention, while libraries call functions using the calling convention. also uses the calling convention, and assumes the functions return a Windows error code. The error code is used to automatically raise Python exceptions when the function call fails. Here are some examples for Windows, note that is the MS standard C library containing most standard C functions, and uses the cdecl calling convention: >>> from ctypes import * >>> print windll.kernel32 # doctest: +WINDOWS <WinDLL 'kernel32', handle ... at ...> >>> print cdll.msvcrt # doctest: +WINDOWS <CDLL 'msvcrt', handle ... at ...> >>> libc = cdll.msvcrt # doctest: +WINDOWS >>> On Linux, it is required to specify the filename including the extension to load a library, so attribute access does not work. Either the method of the dll loaders should be used, or you should load the library by creating an instance of CDLL by calling the constructor:\n\nFunctions are accessed as attributes of dll objects: >>> from ctypes import * >>> libc.printf <_FuncPtr object at 0x...> >>> print windll.kernel32.GetModuleHandleA # doctest: +WINDOWS <_FuncPtr object at 0x...> >>> print windll.kernel32.MyOwnFunction # doctest: +WINDOWS Traceback (most recent call last): File \"<stdin>\", line 1, in ? File \"ctypes.py\", line 239, in __getattr__ func = _StdcallFuncPtr(name, self) AttributeError: function 'MyOwnFunction' not found >>> Note that win32 system dlls like and often export ANSI as well as UNICODE versions of a function. The UNICODE version is exported with an appended to the name, while the ANSI version is exported with an appended to the name. The win32 function, which returns a module handle for a given module name, has the following C prototype, and a macro is used to expose one of them as depending on whether UNICODE is defined or not: does not try to select one of them by magic, you must access the version you need by specifying or explicitely, and then call it with normal strings or unicode strings respectively. Sometimes, dlls export functions with names which aren't valid Python identifiers, like . In this case you have to use to retrieve the function: On Windows, some dlls export functions not by name but by ordinal. These functions can be accessed by indexing the dll object with the ordinal number: >>> cdll.kernel32[1] # doctest: +WINDOWS <_FuncPtr object at 0x...> >>> cdll.kernel32[0] # doctest: +WINDOWS Traceback (most recent call last): File \"<stdin>\", line 1, in ? File \"ctypes.py\", line 310, in __getitem__ func = _StdcallFuncPtr(name, self) AttributeError: function ordinal 0 not found >>>\n\nYou can call these functions like any other Python callable. This example uses the function, which returns system time in seconds since the UNIX epoch, and the function, which returns a win32 module handle. This example calls both functions with a NULL pointer ( should be used as the NULL pointer): tries to protect you from calling functions with the wrong number of arguments or the wrong calling convention. Unfortunately this only works on Windows. It does this by examining the stack after the function returns, so although an error is raised the function has been called: >>> windll.kernel32.GetModuleHandleA() # doctest: +WINDOWS Traceback (most recent call last): File \"<stdin>\", line 1, in ? ValueError: Procedure probably called with not enough arguments (4 bytes missing) >>> windll.kernel32.GetModuleHandleA(0, 0) # doctest: +WINDOWS Traceback (most recent call last): File \"<stdin>\", line 1, in ? ValueError: Procedure probably called with too many arguments (4 bytes in excess) >>> The same exception is raised when you call an function with the calling convention, or vice versa: >>> cdll.kernel32.GetModuleHandleA(None) # doctest: +WINDOWS Traceback (most recent call last): File \"<stdin>\", line 1, in ? ValueError: Procedure probably called with not enough arguments (4 bytes missing) >>> >>> windll.msvcrt.printf(\"spam\") # doctest: +WINDOWS Traceback (most recent call last): File \"<stdin>\", line 1, in ? ValueError: Procedure probably called with too many arguments (4 bytes in excess) >>> To find out the correct calling convention you have to look into the C header file or the documentation for the function you want to call. On Windows, uses win32 structured exception handling to prevent crashes from general protection faults when functions are called with invalid argument values: >>> windll.kernel32.GetModuleHandleA(32) # doctest: +WINDOWS Traceback (most recent call last): File \"<stdin>\", line 1, in ? WindowsError: exception: access violation reading 0x00000020 >>> There are, however, enough ways to crash Python with , so you should be careful anyway. , integers, longs, byte strings and unicode strings are the only native Python objects that can directly be used as parameters in these function calls. is passed as a C pointer, byte strings and unicode strings are passed as pointer to the memory block that contains their data ( or ). Python integers and Python longs are passed as the platforms default C type, their value is masked to fit into the C type. Before we move on calling functions with other parameter types, we have to learn more about data types.\n\nAll these types can be created by calling them with an optional initializer of the correct type and value: Since these types are mutable, their value can also be changed afterwards: Assigning a new value to instances of the pointer types , , and changes the memory location they point to, not the contents of the memory block (of course not, because Python strings are immutable): >>> s = \"Hello, World\" >>> c_s = c_char_p(s) >>> print c_s c_char_p('Hello, World') >>> c_s.value = \"Hi, there\" >>> print c_s c_char_p('Hi, there') >>> print s # first string is unchanged Hello, World >>> You should be careful, however, not to pass them to functions expecting pointers to mutable memory. If you need mutable memory blocks, ctypes has a function which creates these in various ways. The current memory block contents can be accessed (or changed) with the property, if you want to access it as NUL terminated string, use the property: >>> from ctypes import * >>> p = create_string_buffer(3) # create a 3 byte buffer, initialized to NUL bytes >>> print sizeof(p), repr(p.raw) 3 '\\x00\\x00\\x00' >>> p = create_string_buffer(\"Hello\") # create a buffer containing a NUL terminated string >>> print sizeof(p), repr(p.raw) 6 'Hello\\x00' >>> print repr(p.value) 'Hello' >>> p = create_string_buffer(\"Hello\", 10) # create a 10 byte buffer >>> print sizeof(p), repr(p.raw) 10 'Hello\\x00\\x00\\x00\\x00\\x00' >>> p.value = \"Hi\" >>> print sizeof(p), repr(p.raw) 10 'Hi\\x00lo\\x00\\x00\\x00\\x00\\x00' >>> The function replaces the function (which is still available as an alias), as well as the function from earlier ctypes releases. To create a mutable memory block containing unicode characters of the C type use the function.\n\nIt is possible to specify the required argument types of functions exported from DLLs by setting the attribute. must be a sequence of C data types (the function is probably not a good example here, because it takes a variable number and different types of parameters depending on the format string, on the other hand this is quite handy to experiment with this feature): Specifying a format protects against incompatible argument types (just as a prototype for a C function), and tries to convert the arguments to valid types: >>> printf(\"%d %d %d\", 1, 2, 3) Traceback (most recent call last): File \"<stdin>\", line 1, in ? ArgumentError: argument 2: exceptions.TypeError: wrong type >>> printf(\"%s %d %f\", \"X\", 2, 3) X 2 3.00000012 12 >>> If you have defined your own classes which you pass to function calls, you have to implement a class method for them to be able to use them in the sequence. The class method receives the Python object passed to the function call, it should do a typecheck or whatever is needed to make sure this object is acceptable, and then return the object itself, it's attribute, or whatever you want to pass as the C function argument in this case. Again, the result should be an integer, string, unicode, a instance, or something having the attribute.\n\nBy default functions are assumed to return the C type. Other return types can be specified by setting the attribute of the function object. Here is a more advanced example, it uses the function, which expects a string pointer and a char, and returns a pointer to a string: >>> strchr = libc.strchr >>> strchr(\"abcdef\", ord(\"d\")) # doctest: +SKIP 8059983 >>> strchr.restype = c_char_p # c_char_p is a pointer to a string >>> strchr(\"abcdef\", ord(\"d\")) 'def' >>> print strchr(\"abcdef\", ord(\"x\")) None >>> If you want to avoid the calls above, you can set the attribute, and the second argument will be converted from a single character Python string into a C char: >>> strchr.restype = c_char_p >>> strchr.argtypes = [c_char_p, c_char] >>> strchr(\"abcdef\", \"d\") 'def' >>> strchr(\"abcdef\", \"def\") Traceback (most recent call last): File \"<stdin>\", line 1, in ? ArgumentError: argument 2: exceptions.TypeError: one character string expected >>> print strchr(\"abcdef\", \"x\") None >>> strchr(\"abcdef\", \"d\") 'def' >>> You can also use a callable Python object (a function or a class for example) as the attribute, if the foreign function returns an integer. The callable will be called with the the C function returns, and the result of this call will be used as the result of your function call. This is useful to check for error return values and automatically raise an exception: >>> GetModuleHandle = windll.kernel32.GetModuleHandleA # doctest: +WINDOWS >>> def ValidHandle(value): ... if value == 0: ... raise WinError() ... return value ... >>> >>> GetModuleHandle.restype = ValidHandle # doctest: +WINDOWS >>> GetModuleHandle(None) # doctest: +WINDOWS 486539264 >>> GetModuleHandle(\"something silly\") # doctest: +WINDOWS Traceback (most recent call last): File \"<stdin>\", line 1, in ? File \"<stdin>\", line 3, in ValidHandle WindowsError: [Errno 126] The specified module could not be found. >>> is a function which will call Windows api to get the string representation of an error code, and returns an exception. takes an optional error code parameter, if no one is used, it calls to retrieve it. Please note that a much more powerful error checking mechanism is available through the attribute; see the reference manual for details.\n\nPointer instances are created by calling the function on a type: Pointer instances have a attribute which returns the object to which the pointer points, the object above: Note that does not have OOR (original object return), it constructs a new, equivalent object each time you retrieve an attribute: Assigning another instance to the pointer's contents attribute would cause the pointer to point to the memory location where this is stored: Pointer instances can also be indexed with integers: Assigning to an integer index changes the pointed to value: It is also possible to use indexes different from 0, but you must know what you're doing, just as in C: You can access or change arbitrary memory locations. Generally you only use this feature if you receive a pointer from a C function, and you know that the pointer actually points to an array instead of a single item. Behind the scenes, the function does more than simply create pointer instances, it has to create pointer types first. This is done with the function, which accepts any type, and returns a new type: >>> PI = POINTER(c_int) >>> PI <class 'ctypes.LP_c_long'> >>> PI(42) Traceback (most recent call last): File \"<stdin>\", line 1, in ? TypeError: expected c_long instead of int >>> PI(c_int(42)) <ctypes.LP_c_long object at 0x...> >>> Calling the pointer type without an argument creates a pointer. pointers have a boolean value: checks for when dereferencing pointers (but dereferencing non- pointers would crash Python): >>> null_ptr[0] Traceback (most recent call last): .... ValueError: NULL pointer access >>> >>> null_ptr[0] = 1234 Traceback (most recent call last): .... ValueError: NULL pointer access >>>\n\nUsually, ctypes does strict type checking. This means, if you have in the list of a function or as the type of a member field in a structure definition, only instances of exactly the same type are accepted. There are some exceptions to this rule, where ctypes accepts other objects. For example, you can pass compatible array instances instead of pointer types. So, for , ctypes accepts an array of c_int: To set a POINTER type field to , you can assign : Sometimes you have instances of incompatible types. In , you can cast one type into another type. provides a function which can be used in the same way. The structure defined above accepts pointers or arrays for its field, but not instances of other types: >>> bar.values = (c_byte * 4)() Traceback (most recent call last): File \"<stdin>\", line 1, in ? TypeError: incompatible types, c_byte_Array_4 instance instead of LP_c_long instance >>> For these cases, the function is handy. The function can be used to cast a ctypes instance into a pointer to a different ctypes data type. takes two parameters, a ctypes object that is or can be converted to a pointer of some kind, and a ctypes pointer type. It returns an instance of the second argument, which references the same memory block as the first argument: So, can be used to assign to the field of the structure:\n\nallows to create C callable function pointers from Python callables. These are sometimes called callback functions. First, you must create a class for the callback function, the class knows the calling convention, the return type, and the number and types of arguments this function will receive. The CFUNCTYPE factory function creates types for callback functions using the normal cdecl calling convention, and, on Windows, the WINFUNCTYPE factory function creates types for callback functions using the stdcall calling convention. Both of these factory functions are called with the result type as first argument, and the callback functions expected argument types as the remaining arguments. I will present an example here which uses the standard C library's function, this is used to sort items with the help of a callback function. will be used to sort an array of integers: must be called with a pointer to the data to sort, the number of items in the data array, the size of one item, and a pointer to the comparison function, the callback. The callback will then be called with two pointers to items, and it must return a negative integer if the first item is smaller than the second, a zero if they are equal, and a positive integer else. So our callback function receives pointers to integers, and must return an integer. First we create the for the callback function: For the first implementation of the callback function, we simply print the arguments we get, and return 0 (incremental development ;-): >>> qsort(ia, len(ia), sizeof(c_int), cmp_func) # doctest: +WINDOWS py_cmp_func <ctypes.LP_c_long object at 0x00...> <ctypes.LP_c_long object at 0x00...> py_cmp_func <ctypes.LP_c_long object at 0x00...> <ctypes.LP_c_long object at 0x00...> py_cmp_func <ctypes.LP_c_long object at 0x00...> <ctypes.LP_c_long object at 0x00...> py_cmp_func <ctypes.LP_c_long object at 0x00...> <ctypes.LP_c_long object at 0x00...> py_cmp_func <ctypes.LP_c_long object at 0x00...> <ctypes.LP_c_long object at 0x00...> py_cmp_func <ctypes.LP_c_long object at 0x00...> <ctypes.LP_c_long object at 0x00...> py_cmp_func <ctypes.LP_c_long object at 0x00...> <ctypes.LP_c_long object at 0x00...> py_cmp_func <ctypes.LP_c_long object at 0x00...> <ctypes.LP_c_long object at 0x00...> py_cmp_func <ctypes.LP_c_long object at 0x00...> <ctypes.LP_c_long object at 0x00...> py_cmp_func <ctypes.LP_c_long object at 0x00...> <ctypes.LP_c_long object at 0x00...> >>> We know how to access the contents of a pointer, so lets redefine our callback: Here is what we get on Windows: It is funny to see that on linux the sort function seems to work much more efficient, it is doing less comparisons: Ah, we're nearly done! The last step is to actually compare the two items and return a useful result: It is quite interesting to see that the Windows function needs more comparisons than the linux version! As we can easily check, our array sorted now: Make sure you keep references to CFUNCTYPE objects as long as they are used from C code. doesn't, and if you don't, they may be garbage collected, crashing your program when a callback is made.\n\nSometimes, a dll not only exports functions, it also exports variables. An example in the Python library itself is the , an integer set to 0, 1, or 2, depending on the or flag given on startup. can access values like this with the class methods of the type. ìs a predefined symbol giving access to the Python C api: If the interpreter would have been started with , the sample would have printed , or if would have been specified. An extended example which also demonstrates the use of pointers accesses the pointer exported by Python. Quoting the Python docs: This pointer is initialized to point to an array of ``struct _frozen`` records, terminated by one whose members are all NULL or zero. When a frozen module is imported, it is searched in this table. Third-party code could play tricks with this to provide a dynamically created collection of frozen modules. So manipulating this pointer could even prove useful. To restrict the example size, we show only how this table can be read with : We have defined the data type, so we can get the pointer to the table: Since is a to the array of records, we can iterate over it, but we just have to make sure that our loop terminates, because pointers have no size. Sooner or later it would probably crash with an access violation or whatever, so it's better to break out of the loop when we hit the NULL entry: >>> for item in table: ... print item.name, item.size ... if item.name is None: ... break ... __hello__ 104 __phello__ -104 __phello__.spam 104 None 0 >>> The fact that standard Python has a frozen module and a frozen package (indicated by the negative size member) is not wellknown, it is only used for testing. Try it out with for example."
    },
    {
        "link": "https://stackoverflow.com/questions/33837641/working-with-ctypes-return-values",
        "document": "I am looking into calling C++ code from Python. I just learned about ctypes and have seen a few examples on the web. I am trying to call a C++ function that looks like the following:\n\nHaving no clue about c++, I am going to ask some basics. How should I be calling such a function from python using ctypes. I've decided to take a step back because I think I'm missing some fundamentals here.\n\nIn fact for any C++ function that takes an argument of type string and returns an integer see some examples\n\nThis function will return a status value(retvalue) that I can decode to know the status of the database e.g 10=running fine, 11=stropped, 12=pause, 404=fault, etc.\n\nWhile get_database_running_status_string will return the string and not just the number\n\nHow would I go about calling these? Not sure what that * symbol is all about though I hope it helps.\n\nMaybe once I understand how to correctly call C++ functions from python then my issue may resolve itself."
    },
    {
        "link": "https://python.readthedocs.io/fr/hack-in-language/library/ctypes.html",
        "document": "is a foreign function library for Python. It provides C compatible data types, and allows calling functions in DLLs or shared libraries. It can be used to wrap these libraries in pure Python.\n\nNote: The code samples in this tutorial use to make sure that they actually work. Since some code samples behave differently under Linux, Windows, or Mac OS X, they contain doctest directives in comments. Note: Some code samples reference the ctypes type. This type is an alias for the type on 32-bit systems. So, you should not be confused if is printed if you would expect — they are actually the same type. exports the cdll, and on Windows windll and oledll objects, for loading dynamic link libraries. You load libraries by accessing them as attributes of these objects. cdll loads libraries which export functions using the standard calling convention, while windll libraries call functions using the calling convention. oledll also uses the calling convention, and assumes the functions return a Windows error code. The error code is used to automatically raise a exception when the function call fails. Modifié dans la version 3.3: Windows errors used to raise , which is now an alias of . Here are some examples for Windows. Note that is the MS standard C library containing most standard C functions, and uses the cdecl calling convention: On Linux, it is required to specify the filename including the extension to load a library, so attribute access can not be used to load libraries. Either the method of the dll loaders should be used, or you should load the library by creating an instance of CDLL by calling the constructor: Functions are accessed as attributes of dll objects: Note that win32 system dlls like and often export ANSI as well as UNICODE versions of a function. The UNICODE version is exported with an appended to the name, while the ANSI version is exported with an appended to the name. The win32 function, which returns a module handle for a given module name, has the following C prototype, and a macro is used to expose one of them as depending on whether UNICODE is defined or not: windll does not try to select one of them by magic, you must access the version you need by specifying or explicitly, and then call it with bytes or string objects respectively. Sometimes, dlls export functions with names which aren’t valid Python identifiers, like . In this case you have to use to retrieve the function: On Windows, some dlls export functions not by name but by ordinal. These functions can be accessed by indexing the dll object with the ordinal number: You can call these functions like any other Python callable. This example uses the function, which returns system time in seconds since the Unix epoch, and the function, which returns a win32 module handle. This example calls both functions with a NULL pointer ( should be used as the NULL pointer): tries to protect you from calling functions with the wrong number of arguments or the wrong calling convention. Unfortunately this only works on Windows. It does this by examining the stack after the function returns, so although an error is raised the function has been called: The same exception is raised when you call an function with the calling convention, or vice versa: To find out the correct calling convention you have to look into the C header file or the documentation for the function you want to call. On Windows, uses win32 structured exception handling to prevent crashes from general protection faults when functions are called with invalid argument values: There are, however, enough ways to crash Python with , so you should be careful anyway. The module can be helpful in debugging crashes (e.g. from segmentation faults produced by erroneous C library calls). , integers, bytes objects and (unicode) strings are the only native Python objects that can directly be used as parameters in these function calls. is passed as a C pointer, bytes objects and strings are passed as pointer to the memory block that contains their data ( or ). Python integers are passed as the platforms default C type, their value is masked to fit into the C type. Before we move on calling functions with other parameter types, we have to learn more about data types. defines a number of primitive C compatible data types:\n• The constructor accepts any object with a truth value. All these types can be created by calling them with an optional initializer of the correct type and value: Since these types are mutable, their value can also be changed afterwards: Assigning a new value to instances of the pointer types , , and changes the memory location they point to, not the contents of the memory block (of course not, because Python bytes objects are immutable): You should be careful, however, not to pass them to functions expecting pointers to mutable memory. If you need mutable memory blocks, ctypes has a function which creates these in various ways. The current memory block contents can be accessed (or changed) with the property; if you want to access it as NUL terminated string, use the property: The function replaces the function (which is still available as an alias), as well as the function from earlier ctypes releases. To create a mutable memory block containing unicode characters of the C type use the function. Note that printf prints to the real standard output channel, not to , so these examples will only work at the console prompt, not from within IDLE or PythonWin: As has been mentioned before, all Python types except integers, strings, and bytes objects have to be wrapped in their corresponding type, so that they can be converted to the required C data type: You can also customize argument conversion to allow instances of your own classes be used as function arguments. looks for an attribute and uses this as the function argument. Of course, it must be one of integer, string, or bytes: If you don’t want to store the instance’s data in the instance variable, you could define a which makes the attribute available on request. It is possible to specify the required argument types of functions exported from DLLs by setting the attribute. must be a sequence of C data types (the function is probably not a good example here, because it takes a variable number and different types of parameters depending on the format string, on the other hand this is quite handy to experiment with this feature): Specifying a format protects against incompatible argument types (just as a prototype for a C function), and tries to convert the arguments to valid types: If you have defined your own classes which you pass to function calls, you have to implement a class method for them to be able to use them in the sequence. The class method receives the Python object passed to the function call, it should do a typecheck or whatever is needed to make sure this object is acceptable, and then return the object itself, its attribute, or whatever you want to pass as the C function argument in this case. Again, the result should be an integer, string, bytes, a instance, or an object with an attribute. By default functions are assumed to return the C type. Other return types can be specified by setting the attribute of the function object. Here is a more advanced example, it uses the function, which expects a string pointer and a char, and returns a pointer to a string: # c_char_p is a pointer to a string If you want to avoid the calls above, you can set the attribute, and the second argument will be converted from a single character Python bytes object into a C char: You can also use a callable Python object (a function or a class for example) as the attribute, if the foreign function returns an integer. The callable will be called with the integer the C function returns, and the result of this call will be used as the result of your function call. This is useful to check for error return values and automatically raise an exception: File , line , in File , line , in : [Errno 126] The specified module could not be found. is a function which will call Windows api to get the string representation of an error code, and returns an exception. takes an optional error code parameter, if no one is used, it calls to retrieve it. Please note that a much more powerful error checking mechanism is available through the attribute; see the reference manual for details. Sometimes a C api function expects a pointer to a data type as parameter, probably to write into the corresponding location, or if the data is too large to be passed by value. This is also known as passing parameters by reference. exports the function which is used to pass parameters by reference. The same effect can be achieved with the function, although does a lot more work since it constructs a real pointer object, so it is faster to use if you don’t need the pointer object in Python itself: Structures and unions must derive from the and base classes which are defined in the module. Each subclass must define a attribute. must be a list of 2-tuples, containing a field name and a field type. The field type must be a type like , or any other derived type: structure, union, array, pointer. Here is a simple example of a POINT structure, which contains two integers named x and y, and also shows how to initialize a structure in the constructor: You can, however, build much more complicated structures. A structure can itself contain other structures by using a structure as a field type. Here is a RECT structure which contains two POINTs named upperleft and lowerright: Nested structures can also be initialized in the constructor in several ways: Field descriptors can be retrieved from the class, they are useful for debugging because they can provide useful information: does not support passing unions or structures with bit-fields to functions by value. While this may work on 32-bit x86, it’s not guaranteed by the library to work in the general case. Unions and structures with bit-fields should always be passed to functions by pointer. By default, Structure and Union fields are aligned in the same way the C compiler does it. It is possible to override this behavior be specifying a class attribute in the subclass definition. This must be set to a positive integer and specifies the maximum alignment for the fields. This is what also does in MSVC. uses the native byte order for Structures and Unions. To build structures with non-native byte order, you can use one of the , , , and base classes. These classes cannot contain pointer fields. It is possible to create structures and unions containing bit fields. Bit fields are only possible for integer fields, the bit width is specified as the third item in the tuples: Arrays are sequences, containing a fixed number of instances of the same type. The recommended way to create array types is by multiplying a data type with a positive integer: Here is an example of an somewhat artificial data type, a structure containing 4 POINTs among other stuff: Instances are created in the usual way, by calling the class: The above code print a series of lines, because the array contents is initialized to zeros. Initializers of the correct type can also be specified: Pointer instances are created by calling the function on a type: Pointer instances have a attribute which returns the object to which the pointer points, the object above: Note that does not have OOR (original object return), it constructs a new, equivalent object each time you retrieve an attribute: Assigning another instance to the pointer’s contents attribute would cause the pointer to point to the memory location where this is stored: Assigning to an integer index changes the pointed to value: It is also possible to use indexes different from 0, but you must know what you’re doing, just as in C: You can access or change arbitrary memory locations. Generally you only use this feature if you receive a pointer from a C function, and you know that the pointer actually points to an array instead of a single item. Behind the scenes, the function does more than simply create pointer instances, it has to create pointer types first. This is done with the function, which accepts any type, and returns a new type: Calling the pointer type without an argument creates a pointer. pointers have a boolean value: Usually, ctypes does strict type checking. This means, if you have in the list of a function or as the type of a member field in a structure definition, only instances of exactly the same type are accepted. There are some exceptions to this rule, where ctypes accepts other objects. For example, you can pass compatible array instances instead of pointer types. So, for , ctypes accepts an array of c_int: In addition, if a function argument is explicitly declared to be a pointer type (such as ) in , an object of the pointed type ( in this case) can be passed to the function. ctypes will apply the required conversion in this case automatically. To set a POINTER type field to , you can assign : Sometimes you have instances of incompatible types. In C, you can cast one type into another type. provides a function which can be used in the same way. The structure defined above accepts pointers or arrays for its field, but not instances of other types: For these cases, the function is handy. The function can be used to cast a ctypes instance into a pointer to a different ctypes data type. takes two parameters, a ctypes object that is or can be converted to a pointer of some kind, and a ctypes pointer type. It returns an instance of the second argument, which references the same memory block as the first argument: So, can be used to assign to the field of the structure: Incomplete Types are structures, unions or arrays whose members are not yet specified. In C, they are specified by forward declarations, which are defined later: The straightforward translation into ctypes code would be this, but it does not work: because the new is not available in the class statement itself. In , we can define the class and set the attribute later, after the class statement: Lets try it. We create two instances of , and let them point to each other, and finally follow the pointer chain a few times: allows to create C callable function pointers from Python callables. These are sometimes called callback functions. First, you must create a class for the callback function. The class knows the calling convention, the return type, and the number and types of arguments this function will receive. The factory function creates types for callback functions using the calling convention. On Windows, the factory function creates types for callback functions using the calling convention. Both of these factory functions are called with the result type as first argument, and the callback functions expected argument types as the remaining arguments. I will present an example here which uses the standard C library’s function, that is used to sort items with the help of a callback function. will be used to sort an array of integers: must be called with a pointer to the data to sort, the number of items in the data array, the size of one item, and a pointer to the comparison function, the callback. The callback will then be called with two pointers to items, and it must return a negative integer if the first item is smaller than the second, a zero if they are equal, and a positive integer otherwise. So our callback function receives pointers to integers, and must return an integer. First we create the for the callback function: To get started, here is a simple callback that shows the values it gets passed: Now we can actually compare the two items and return a useful result: Make sure you keep references to objects as long as they are used from C code. doesn’t, and if you don’t, they may be garbage collected, crashing your program when a callback is made. Also, note that if the callback function is called in a thread created outside of Python’s control (e.g. by the foreign code that calls the callback), ctypes creates a new dummy Python thread on every invocation. This behavior is correct for most purposes, but it means that values stored with will not survive across different callbacks, even when those calls are made from the same C thread. Some shared libraries not only export functions, they also export variables. An example in the Python library itself is the , an integer set to 0, 1, or 2, depending on the or flag given on startup. can access values like this with the class methods of the type. pythonapi is a predefined symbol giving access to the Python C api: If the interpreter would have been started with , the sample would have printed , or if would have been specified. An extended example which also demonstrates the use of pointers accesses the pointer exported by Python. Quoting the docs for that value: This pointer is initialized to point to an array of records, terminated by one whose members are all NULL or zero. When a frozen module is imported, it is searched in this table. Third-party code could play tricks with this to provide a dynamically created collection of frozen modules. So manipulating this pointer could even prove useful. To restrict the example size, we show only how this table can be read with : We have defined the data type, so we can get the pointer to the table: Since is a to the array of records, we can iterate over it, but we just have to make sure that our loop terminates, because pointers have no size. Sooner or later it would probably crash with an access violation or whatever, so it’s better to break out of the loop when we hit the NULL entry: The fact that standard Python has a frozen module and a frozen package (indicated by the negative size member) is not well known, it is only used for testing. Try it out with for example. There are some edges in where you might expect something other than what actually happens. Hm. We certainly expected the last statement to print . What happened? Here are the steps of the line above: Note that and are objects still using the internal buffer of the object above. So executing copies the buffer contents of into “s buffer. This, in turn, changes the contents of . So, the last assignment , doesn’t have the expected effect. Keep in mind that retrieving sub-objects from Structure, Unions, and Arrays doesn’t copy the sub-object, instead it retrieves a wrapper object accessing the root-object’s underlying buffer. Another example that may behave different from what one would expect is this: Why is it printing ? ctypes instances are objects containing a memory block plus some descriptors accessing the contents of the memory. Storing a Python object in the memory block does not store the object itself, instead the of the object is stored. Accessing the contents again constructs a new Python object each time! The function can be used to resize the memory buffer of an existing ctypes object. The function takes the object as first argument, and the requested size in bytes as the second argument. The memory block cannot be made smaller than the natural memory block specified by the objects type, a is raised if this is tried: This is nice and fine, but how would one access the additional elements contained in this array? Since the type still only knows about 4 elements, we get errors accessing other elements: Another way to use variable-sized data types with is to use the dynamic nature of Python, and (re-)define the data type after the required size is already known, on a case by case basis.\n\nWhen programming in a compiled language, shared libraries are accessed when compiling/linking a program, and when the program is run. The purpose of the function is to locate a library in a way similar to what the compiler does (on platforms with several versions of a shared library the most recent should be loaded), while the ctypes library loaders act like when a program is run, and call the runtime loader directly. The module provides a function which can help to determine the library to load. Try to find a library and return a pathname. name is the library name without any prefix like lib, suffix like , or version number (this is the form used for the posix linker option ). If no library can be found, returns . On Linux, tries to run external programs ( , , and ) to find the library file. It returns the filename of the library file. Here are some examples: On OS X, tries several predefined naming schemes and paths to locate the library, and returns a full pathname if successful: On Windows, searches along the system search path, and returns the full pathname, but since there is no predefined naming scheme a call like will fail and return . If wrapping a shared library with , it may be better to determine the shared library name at development time, and hardcode that into the wrapper module instead of using to locate the library at runtime. There are several ways to loaded shared libraries into the Python process. One way is to instantiate one of the following classes: Instances of this class represent loaded shared libraries. Functions in these libraries use the standard C calling convention, and are assumed to return . Windows only: Instances of this class represent loaded shared libraries, functions in these libraries use the calling convention, and are assumed to return the windows specific code. values contain information specifying whether the function call failed or succeeded, together with additional error code. If the return value signals a failure, an is automatically raised. Modifié dans la version 3.3: used to be raised. Windows only: Instances of this class represent loaded shared libraries, functions in these libraries use the calling convention, and are assumed to return by default. On Windows CE only the standard calling convention is used, for convenience the and use the standard calling convention on this platform. The Python global interpreter lock is released before calling any function exported by these libraries, and reacquired afterwards. Instances of this class behave like instances, except that the Python GIL is not released during the function call, and after the function execution the Python error flag is checked. If the error flag is set, a Python exception is raised. Thus, this is only useful to call Python C api functions directly. All these classes can be instantiated by calling them with at least one argument, the pathname of the shared library. If you have an existing handle to an already loaded shared library, it can be passed as the named parameter, otherwise the underlying platforms or function is used to load the library into the process, and to get a handle to it. The mode parameter can be used to specify how the library is loaded. For details, consult the dlopen(3) manpage, on Windows, mode is ignored. The use_errno parameter, when set to True, enables a ctypes mechanism that allows to access the system error number in a safe way. maintains a thread-local copy of the systems variable; if you call foreign functions created with then the value before the function call is swapped with the ctypes private copy, the same happens immediately after the function call. The function returns the value of the ctypes private copy, and the function changes the ctypes private copy to a new value and returns the former value. The use_last_error parameter, when set to True, enables the same mechanism for the Windows error code which is managed by the and Windows API functions; and are used to request and change the ctypes private copy of the windows error code. Flag to use as mode parameter. On platforms where this flag is not available, it is defined as the integer zero. Flag to use as mode parameter. On platforms where this is not available, it is the same as RTLD_GLOBAL. The default mode which is used to load shared libraries. On OSX 10.3, this is RTLD_GLOBAL, otherwise it is the same as RTLD_LOCAL. Instances of these classes have no public methods. Functions exported by the shared library can be accessed as attributes or by index. Please note that accessing the function through an attribute caches the result and therefore accessing it repeatedly returns the same object each time. On the other hand, accessing it through an index returns a new object each time: The following public attributes are available, their name starts with an underscore to not clash with exported function names: The system handle used to access the library. The name of the library passed in the constructor. Shared libraries can also be loaded by using one of the prefabricated objects, which are instances of the class, either by calling the method, or by retrieving the library as attribute of the loader instance. Class which loads shared libraries. dlltype should be one of the , , , or types. has special behavior: It allows to load a shared library by accessing it as attribute of a library loader instance. The result is cached, so repeated attribute accesses return the same library each time. Load a shared library into the process and return it. This method always returns a new instance of the library. For accessing the C Python api directly, a ready-to-use Python shared library object is available: An instance of that exposes Python C API functions as attributes. Note that all these functions are assumed to return C , which is of course not always the truth, so you have to assign the correct attribute to use these functions. As explained in the previous section, foreign functions can be accessed as attributes of loaded shared libraries. The function objects created in this way by default accept any number of arguments, accept any ctypes data instances as arguments, and return the default result type specified by the library loader. They are instances of a private class: Instances of foreign functions are also C compatible data types; they represent C function pointers. This behavior can be customized by assigning to special attributes of the foreign function object. Assign a ctypes type to specify the result type of the foreign function. Use for , a function not returning anything. It is possible to assign a callable Python object that is not a ctypes type, in this case the function is assumed to return a C , and the callable will be called with this integer, allowing to do further processing or error checking. Using this is deprecated, for more flexible post processing or error checking use a ctypes data type as and assign a callable to the attribute. Assign a tuple of ctypes types to specify the argument types that the function accepts. Functions using the calling convention can only be called with the same number of arguments as the length of this tuple; functions using the C calling convention accept additional, unspecified arguments as well. When a foreign function is called, each actual argument is passed to the class method of the items in the tuple, this method allows to adapt the actual argument to an object that the foreign function accepts. For example, a item in the tuple will convert a string passed as argument into a bytes object using ctypes conversion rules. New: It is now possible to put items in argtypes which are not ctypes types, but each item must have a method which returns a value usable as argument (integer, string, ctypes instance). This allows to define adapters that can adapt custom objects as function parameters. Assign a Python function or another callable to this attribute. The callable will be called with three or more arguments: result is what the foreign function returns, as specified by the attribute. func is the foreign function object itself, this allows to reuse the same callable object to check or post process the results of several functions. arguments is a tuple containing the parameters originally passed to the function call, this allows to specialize the behavior on the arguments used. The object that this function returns will be returned from the foreign function call, but it can also check the result value and raise an exception if the foreign function call failed. This exception is raised when a foreign function call cannot convert one of the passed arguments. Foreign functions can also be created by instantiating function prototypes. Function prototypes are similar to function prototypes in C; they describe a function (return type, argument types, calling convention) without defining an implementation. The factory functions must be called with the desired result type and the argument types of the function. The returned function prototype creates functions that use the standard C calling convention. The function will release the GIL during the call. If use_errno is set to True, the ctypes private copy of the system variable is exchanged with the real value before and after the call; use_last_error does the same for the Windows error code. Windows only: The returned function prototype creates functions that use the calling convention, except on Windows CE where is the same as . The function will release the GIL during the call. use_errno and use_last_error have the same meaning as above. The returned function prototype creates functions that use the Python calling convention. The function will not release the GIL during the call. Function prototypes created by these factory functions can be instantiated in different ways, depending on the type and number of the parameters in the call: Returns a foreign function at the specified address which must be an integer. Create a C callable function (a callback function) from a Python callable. Returns a foreign function exported by a shared library. func_spec must be a 2-tuple . The first item is the name of the exported function as string, or the ordinal of the exported function as small integer. The second item is the shared library instance. Returns a foreign function that will call a COM method. vtbl_index is the index into the virtual function table, a small non-negative integer. name is name of the COM method. iid is an optional pointer to the interface identifier which is used in extended error reporting. COM methods use a special calling convention: They require a pointer to the COM interface as first argument, in addition to those parameters that are specified in the tuple. The optional paramflags parameter creates foreign function wrappers with much more functionality than the features described above. paramflags must be a tuple of the same length as . Each item in this tuple contains further information about a parameter, it must be a tuple containing one, two, or three items. The first item is an integer containing a combination of direction flags for the parameter: Specifies an input parameter to the function. Output parameter. The foreign function fills in a value. The optional second item is the parameter name as string. If this is specified, the foreign function can be called with named parameters. The optional third item is the default value for this parameter. This example demonstrates how to wrap the Windows function so that it supports default parameters and named arguments. The C declaration from the windows header file is this: Here is the wrapping with : The MessageBox foreign function can now be called in these ways: A second example demonstrates output parameters. The win32 function retrieves the dimensions of a specified window by copying them into structure that the caller has to supply. Here is the C declaration: Here is the wrapping with : Functions with output parameters will automatically return the output parameter value if there is a single one, or a tuple containing the output parameter values when there are more than one, so the GetWindowRect function now returns a RECT instance, when called. Output parameters can be combined with the protocol to do further output processing and error checking. The win32 api function returns a to signal success or failure, so this function could do the error checking, and raises an exception when the api call failed: If the function returns the argument tuple it receives unchanged, continues the normal processing it does on the output parameters. If you want to return a tuple of window coordinates instead of a instance, you can retrieve the fields in the function and return them instead, the normal processing will no longer take place: Returns the address of the memory buffer as integer. obj must be an instance of a ctypes type. Returns the alignment requirements of a ctypes type. obj_or_type must be a ctypes type or instance. Returns a light-weight pointer to obj, which must be an instance of a ctypes type. offset defaults to zero, and must be an integer that will be added to the internal pointer value. corresponds to this C code: The returned object can only be used as a foreign function call parameter. It behaves similar to , but the construction is a lot faster. This function is similar to the cast operator in C. It returns a new instance of type which points to the same memory block as obj. type must be a pointer type, and obj must be an object that can be interpreted as a pointer. This function creates a mutable character buffer. The returned object is a ctypes array of . init_or_size must be an integer which specifies the size of the array, or a bytes object which will be used to initialize the array items. If a bytes object is specified as first argument, the buffer is made one item larger than its length so that the last element in the array is a NUL termination character. An integer can be passed as second argument which allows to specify the size of the array if the length of the bytes should not be used. This function creates a mutable unicode character buffer. The returned object is a ctypes array of . init_or_size must be an integer which specifies the size of the array, or a string which will be used to initialize the array items. If a string is specified as first argument, the buffer is made one item larger than the length of the string so that the last element in the array is a NUL termination character. An integer can be passed as second argument which allows to specify the size of the array if the length of the string should not be used. Windows only: This function is a hook which allows to implement in-process COM servers with ctypes. It is called from the DllCanUnloadNow function that the _ctypes extension dll exports. Windows only: This function is a hook which allows to implement in-process COM servers with ctypes. It is called from the DllGetClassObject function that the extension dll exports. Try to find a library and return a pathname. name is the library name without any prefix like , suffix like , or version number (this is the form used for the posix linker option ). If no library can be found, returns . Windows only: return the filename of the VC runtime library used by Python, and by the extension modules. If the name of the library cannot be determined, is returned. If you need to free memory, for example, allocated by an extension module with a call to the , it is important that you use the function in the same library that allocated the memory. Windows only: Returns a textual description of the error code code. If no error code is specified, the last error code is used by calling the Windows api function GetLastError. Windows only: Returns the last error code set by Windows in the calling thread. This function calls the Windows function directly, it does not return the ctypes-private copy of the error code. Returns the current value of the ctypes-private copy of the system variable in the calling thread. Windows only: returns the current value of the ctypes-private copy of the system variable in the calling thread. Same as the standard C memmove library function: copies count bytes from src to dst. dst and src must be integers or ctypes instances that can be converted to pointers. Same as the standard C memset library function: fills the memory block at address dst with count bytes of value c. dst must be an integer specifying an address, or a ctypes instance. This factory function creates and returns a new ctypes pointer type. Pointer types are cached an reused internally, so calling this function repeatedly is cheap. type must be a ctypes type. This function creates a new pointer instance, pointing to obj. The returned object is of the type . Note: If you just want to pass a pointer to an object to a foreign function call, you should use which is much faster. This function resizes the internal memory buffer of obj, which must be an instance of a ctypes type. It is not possible to make the buffer smaller than the native size of the objects type, as given by , but it is possible to enlarge the buffer. Set the current value of the ctypes-private copy of the system variable in the calling thread to value and return the previous value. Windows only: set the current value of the ctypes-private copy of the system variable in the calling thread to value and return the previous value. Returns the size in bytes of a ctypes type or instance memory buffer. Does the same as the C operator. This function returns the C string starting at memory address address as a bytes object. If size is specified, it is used as size, otherwise the string is assumed to be zero-terminated. Windows only: this function is probably the worst-named thing in ctypes. It creates an instance of OSError. If code is not specified, is called to determine the error code. If descr is not specified, is called to get a textual description of the error. Modifié dans la version 3.3: An instance of used to be created. This function returns the wide character string starting at memory address address as a string. If size is specified, it is used as the number of characters of the string, otherwise the string is assumed to be zero-terminated. This non-public class is the common base class of all ctypes data types. Among other things, all ctypes type instances contain a memory block that hold C compatible data; the address of the memory block is returned by the helper function. Another instance variable is exposed as ; this contains other Python objects that need to be kept alive in case the memory block contains pointers. Common methods of ctypes data types, these are all class methods (to be exact, they are methods of the metaclass): This method returns a ctypes instance that shares the buffer of the source object. The source object must support the writeable buffer interface. The optional offset parameter specifies an offset into the source buffer in bytes; the default is zero. If the source buffer is not large enough a is raised. This method creates a ctypes instance, copying the buffer from the source object buffer which must be readable. The optional offset parameter specifies an offset into the source buffer in bytes; the default is zero. If the source buffer is not large enough a is raised. This method returns a ctypes type instance using the memory specified by address which must be an integer. This method adapts obj to a ctypes type. It is called with the actual object used in a foreign function call when the type is present in the foreign function’s tuple; it must return an object that can be used as a function call parameter. All ctypes data types have a default implementation of this classmethod that normally returns obj if that is an instance of the type. Some types accept other objects as well. This method returns a ctypes type instance exported by a shared library. name is the name of the symbol that exports the data, library is the loaded shared library. Sometimes ctypes data instances do not own the memory block they contain, instead they share part of the memory block of a base object. The read-only member is the root ctypes object that owns the memory block. This read-only variable is true when the ctypes data instance has allocated the memory block itself, false otherwise. This member is either or a dictionary containing Python objects that need to be kept alive so that the memory block contents is kept valid. This object is only exposed for debugging; never modify the contents of this dictionary. This non-public class is the base class of all fundamental ctypes data types. It is mentioned here because it contains the common attributes of the fundamental ctypes data types. is a subclass of , so it inherits their methods and attributes. ctypes data types that are not and do not contain pointers can now be pickled. This attribute contains the actual value of the instance. For integer and pointer types, it is an integer, for character types, it is a single character bytes object or string, for character pointer types it is a Python bytes object or string. When the attribute is retrieved from a ctypes instance, usually a new object is returned each time. does not implement original object return, always a new object is constructed. The same is true for all other ctypes object instances. Fundamental data types, when returned as foreign function call results, or, for example, by retrieving structure field members or array items, are transparently converted to native Python types. In other words, if a foreign function has a of , you will always receive a Python bytes object, not a instance. Subclasses of fundamental data types do not inherit this behavior. So, if a foreign functions is a subclass of , you will receive an instance of this subclass from the function call. Of course, you can get the value of the pointer by accessing the attribute. These are the fundamental ctypes data types: Represents the C datatype, and interprets the value as small integer. The constructor accepts an optional integer initializer; no overflow checking is done. Represents the C datatype, and interprets the value as a single character. The constructor accepts an optional string initializer, the length of the string must be exactly one character. Represents the C datatype when it points to a zero-terminated string. For a general character pointer that may also point to binary data, must be used. The constructor accepts an integer address, or a bytes object. Represents the C datatype. The constructor accepts an optional float initializer. Represents the C datatype. The constructor accepts an optional float initializer. On platforms where it is an alias to . Represents the C datatype. The constructor accepts an optional float initializer. Represents the C datatype. The constructor accepts an optional integer initializer; no overflow checking is done. On platforms where it is an alias to . Represents the C 8-bit datatype. Usually an alias for . Represents the C 16-bit datatype. Usually an alias for . Represents the C 32-bit datatype. Usually an alias for . Represents the C 64-bit datatype. Usually an alias for . Represents the C datatype. The constructor accepts an optional integer initializer; no overflow checking is done. Represents the C datatype. The constructor accepts an optional integer initializer; no overflow checking is done. Represents the C datatype. The constructor accepts an optional integer initializer; no overflow checking is done. Represents the C datatype, it interprets the value as small integer. The constructor accepts an optional integer initializer; no overflow checking is done. Represents the C datatype. The constructor accepts an optional integer initializer; no overflow checking is done. On platforms where it is an alias for . Represents the C 8-bit datatype. Usually an alias for . Represents the C 16-bit datatype. Usually an alias for . Represents the C 32-bit datatype. Usually an alias for . Represents the C 64-bit datatype. Usually an alias for . Represents the C datatype. The constructor accepts an optional integer initializer; no overflow checking is done. Represents the C datatype. The constructor accepts an optional integer initializer; no overflow checking is done. Represents the C datatype. The constructor accepts an optional integer initializer; no overflow checking is done. Represents the C type. The value is represented as integer. The constructor accepts an optional integer initializer. Represents the C datatype, and interprets the value as a single character unicode string. The constructor accepts an optional string initializer, the length of the string must be exactly one character. Represents the C datatype, which must be a pointer to a zero-terminated wide character string. The constructor accepts an integer address, or a string. Represent the C datatype (more accurately, from C99). Its value can be or , and the constructor accepts any object that has a truth value. Windows only: Represents a value, which contains success or error information for a function or method call. Represents the C datatype. Calling this without an argument creates a pointer. The module provides quite some other Windows specific data types, for example , , or . Some useful structures like or are also defined. Concrete structure and union types must be created by subclassing one of these types, and at least define a class variable. will create descriptors which allow reading and writing the fields by direct attribute accesses. These are the A sequence defining the structure fields. The items must be 2-tuples or 3-tuples. The first item is the name of the field, the second item specifies the type of the field; it can be any ctypes data type. For integer type fields like , a third optional item can be given. It must be a small positive integer defining the bit width of the field. Field names must be unique within one structure or union. This is not checked, only one field can be accessed when names are repeated. It is possible to define the class variable after the class statement that defines the Structure subclass, this allows to create data types that directly or indirectly reference themselves: The class variable must, however, be defined before the type is first used (an instance is created, is called on it, and so on). Later assignments to the class variable will raise an AttributeError. It is possible to defined sub-subclasses of structure types, they inherit the fields of the base class plus the defined in the sub-subclass, if any. An optional small integer that allows to override the alignment of structure fields in the instance. must already be defined when is assigned, otherwise it will have no effect. An optional sequence that lists the names of unnamed (anonymous) fields. must be already defined when is assigned, otherwise it will have no effect. The fields listed in this variable must be structure or union type fields. will create descriptors in the structure type that allows to access the nested fields directly, without the need to create the structure or union field. The structure describes a COM data type, the field specifies which one of the union fields is valid. Since the field is defined as anonymous field, it is now possible to access the members directly off the TYPEDESC instance. and are equivalent, but the former is faster since it does not need to create a temporary union instance: It is possible to defined sub-subclasses of structures, they inherit the fields of the base class. If the subclass definition has a separate variable, the fields specified in this are appended to the fields of the base class. Structure and union constructors accept both positional and keyword arguments. Positional arguments are used to initialize member fields in the same order as they are appear in . Keyword arguments in the constructor are interpreted as attribute assignments, so they will initialize with the same name, or create new attributes for names not present in . Not yet written - please see the sections Pointers and section Arrays in the tutorial."
    },
    {
        "link": "https://stackoverflow.com/questions/60198918/virtualalloc-and-python-access-violation",
        "document": "Hit the same issue. For me the reason was wrong size, defined as 32-bit value.\n\nIndeed, ctypes functions are not prototyped and return C default type: . On Windows, is an alias for which is a signed 32-bit integer. So when a system allocates a memory block above x32 limit the address returned by VirtualAlloc is cut.\n\nIn your case could return for example, but then only lower part was used as value for .\n\nAdd the next line before use:\n\nThe same stuff is about :"
    },
    {
        "link": "https://reddit.com/r/learnpython/comments/zskpwz/ctypes_with_kernel32virtualalloc_windows_memory",
        "document": "I'm going through the Black Hay Python book and I'm trying to make sure I understand every line. That gets a little challenging when you get into the Windows lower level programming, but I'm giving a good try.\n\nI believe I understand a line I'm working on while allocating memory, but I was looking for a conformation.\n\nIf you look at the MS documentation for the VirtualAlloc function they provide some documentation on acceptable values for the type of memory allocation.\n\nIn the book they use a type of memory allocation 0x3000\n\nin the documentation on the website it makes the following statement.\n\n\"To reserve and commit pages in one step, call VirtualAlloc with MEM_COMMIT | MEM_RESERVE.\"\n\nWhat \"I assume\", but you know what that means...\n\nIs that it's simply adding the values for: MEM_COMMIT and MEM_RESERVE\n\nIs this a thing you can just do? I have no experience in lower level programming languages like this besides some C++ courses back in college.\n\nCan anyone tell me if my \"assumption\" is correct?"
    },
    {
        "link": "https://bugs.python.org/issue44051",
        "document": "Created on 2021-05-05 16:04 by baptistecrepin, last changed 2022-04-11 14:59 by admin. This issue is now closed."
    },
    {
        "link": "https://github.com/ustayready/python-pentesting/blob/master/pyinjector.py",
        "document": "To see all available qualifiers, see our documentation .\n\nSaved searches Use saved searches to filter your results more quickly\n\nWe read every piece of feedback, and take your input very seriously.\n\nYou signed in with another tab or window. Reload to refresh your session.\n\nYou signed out in another tab or window. Reload to refresh your session.\n\nYou switched accounts on another tab or window. Reload to refresh your session."
    },
    {
        "link": "https://stackoverflow.com/questions/62152973/ctypes-access-violation-writing-with-python3-8-while-2-7-works",
        "document": "I create some shellcode to pop up calc.exe on Windows. The shellcode is in the variable (omitted here for space). With python2.7 it works and the calculator appears. With python 3, it fails with (memory location differs on each run).\n\nHere's the code. As I understand it, will automatically allocate space to match the length of and will use in place of python's .\n\nI've read and googled but have no idea on why it won't work in Python3. Any ideas?\n\nFWIW, here is how I created the shellcode:"
    }
]