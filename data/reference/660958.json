[
    {
        "link": "https://pkg.go.dev/encoding/csv",
        "document": "Package csv reads and writes comma-separated values (CSV) files. There are many kinds of CSV files; this package supports the format described in RFC 4180, except that Writer uses LF instead of CRLF as newline character by default. A csv file contains zero or more records of one or more fields per record. Each record is separated by the newline character. The final record may optionally be followed by a newline character. Blank lines are ignored. A line with only whitespace characters (excluding the ending newline character) is not considered a blank line. Fields which start and stop with the quote character \" are called quoted-fields. The beginning and ending quote are not part of the field. Within a quoted-field a quote character followed by a second quote character is considered a single quote. Newlines and commas may be included in a quoted-field\n\nA ParseError is returned for parsing errors. Line and column numbers are 1-indexed. As returned by NewReader, a Reader expects input conforming to RFC 4180. The exported fields can be changed to customize the details before the first call to Reader.Read or Reader.ReadAll. The Reader converts all \\r\n\n sequences in its input to plain \n\n, including in multiline field values, so that the returned data does not depend on which line-ending convention an input file uses. package main import ( \"encoding/csv\" \"fmt\" \"io\" \"log\" \"strings\" ) func main() { in := `first_name,last_name,username \"Rob\",\"Pike\",rob Ken,Thompson,ken \"Robert\",\"Griesemer\",\"gri\" ` r := csv.NewReader(strings.NewReader(in)) for { record, err := r.Read() if err == io.EOF { break } if err != nil { log.Fatal(err) } fmt.Println(record) } } This example shows how csv.Reader can be configured to handle other types of CSV files. package main import ( \"encoding/csv\" \"fmt\" \"log\" \"strings\" ) func main() { in := `first_name;last_name;username \"Rob\";\"Pike\";rob # lines beginning with a # character are ignored Ken;Thompson;ken \"Robert\";\"Griesemer\";\"gri\" ` r := csv.NewReader(strings.NewReader(in)) r.Comma = ';' r.Comment = '#' records, err := r.ReadAll() if err != nil { log.Fatal(err) } fmt.Print(records) } NewReader returns a new Reader that reads from r. FieldPos returns the line and column corresponding to the start of the field with the given index in the slice most recently returned by Reader.Read. Numbering of lines and columns starts at 1; columns are counted in bytes, not runes. If this is called with an out-of-bounds index, it panics. InputOffset returns the input stream byte offset of the current reader position. The offset gives the location of the end of the most recently read row and the beginning of the next row. Read reads one record (a slice of fields) from r. If the record has an unexpected number of fields, Read returns the record along with the error ErrFieldCount. If the record contains a field that cannot be parsed, Read returns a partial record along with the parse error. The partial record contains all fields read before the error. If there is no data left to be read, Read returns nil, io.EOF. If [Reader.ReuseRecord] is true, the returned slice may be shared between multiple calls to Read. ReadAll reads all the remaining records from r. Each record is a slice of fields. A successful call returns err == nil, not err == io.EOF. Because ReadAll is defined to read until EOF, it does not treat end of file as an error to be reported. As returned by NewWriter, a Writer writes records terminated by a newline and uses ',' as the field delimiter. The exported fields can be changed to customize the details before the first call to Writer.Write or Writer.WriteAll. If [Writer.UseCRLF] is true, the Writer ends each output line with \\r\n\n instead of \n\n. The writes of individual records are buffered. After all data has been written, the client should call the Writer.Flush method to guarantee all data has been forwarded to the underlying io.Writer. Any errors that occurred should be checked by calling the Writer.Error method. package main import ( \"encoding/csv\" \"log\" \"os\" ) func main() { records := [][]string{ {\"first_name\", \"last_name\", \"username\"}, {\"Rob\", \"Pike\", \"rob\"}, {\"Ken\", \"Thompson\", \"ken\"}, {\"Robert\", \"Griesemer\", \"gri\"}, } w := csv.NewWriter(os.Stdout) for _, record := range records { if err := w.Write(record); err != nil { log.Fatalln(\"error writing record to csv:\", err) } } // Write any buffered data to the underlying writer (standard output). w.Flush() if err := w.Error(); err != nil { log.Fatal(err) } } NewWriter returns a new Writer that writes to w. Error reports any error that has occurred during a previous Writer.Write or Writer.Flush. Flush writes any buffered data to the underlying io.Writer. To check if an error occurred during Flush, call Writer.Error. Write writes a single CSV record to w along with any necessary quoting. A record is a slice of strings with each string being one field. Writes are buffered, so Writer.Flush must eventually be called to ensure that the record is written to the underlying io.Writer. WriteAll writes multiple CSV records to w using Writer.Write and then calls Writer.Flush, returning any error from the Flush."
    },
    {
        "link": "https://twilio.com/en-us/blog/read-write-csv-file-go",
        "document": "Opinions expressed by Twilio contributors are their own\n\nOpinions expressed by Twilio contributors are their own\n\nHow to read and write data in CSV file using golang CSV files are a common format for storing and exchanging data. They are simple text files in which each line represents a data record, and the values of each record are separated by commas or other delimiters. This format is widely used for importing and exporting data between different applications. In this article, we'll explore how to read and write CSV files in Go. We'll cover the basics of handling CSV data, including reading from and writing to files, working with headers, handling errors, and formatting data. By the end, you should have a solid understanding of how to incorporate CSV file processing into your Go applications. Before diving into the details, ensure you have the following:\n• Go installed on your system. You can download it from the official website\n• A text editor or IDE of your choice to write and edit your Go code Go provides the encoding/csv package in its standard library to handle CSV operations. Open your terminal and create a directory for your project.\n\nOpen up the folder in your code editor. Add a CSV file named data.csv inside the project's top-level folder. You can use this CSV file for demonstration purposes. Then, create a file called main.go. Now, let’s break down the steps on how to read a CSV file in Go Before you start working with CSV files, you need to import the necessary packages namely:\n• The bytes package which provides functions for working with byte slices.\n• The encoding/csv package which provides functions for reading and writing CSV-encoded data.\n• The fmt package which provides functions for formatted printing and scanning.\n• The io package which provides basic interfaces for I/O operations.\n• The os package which provides functions for interacting with the operating system. In your main.go add the following:\n\nThe function uses a loop to repeatedly call the method on the CSV reader. This method returns a slice of strings representing the values in each record, along with an error value. We check for the error to determine when we've reached the end of the file, and handle any other errors that might occur during reading. Integrate the functions in the main function Finally, let's demonstrate how to use these functions together in the function. This part shows how to integrate everything and handle potential errors:\n\nUse the header for column mapping If you want to use the header row to map column names to values, you can read the header separately and create a mapping. To utilize the header row for column mapping in your Go application, you can modify the function to also read the header, and then use it to access specific columns by name. To do this, first, update the function to accept an additional parameter for the header:"
    },
    {
        "link": "https://pkg.go.dev/github.com/atotto/encoding/csv",
        "document": "You can use flat struct data type to recieve the csv data. This package are an extended version of encoding/csv package. See encoding/csv package : http://golang.org/pkg/encoding/csv/\n\nNewReader returns a new Reader that reads from r. An UnsupportedTypeError is returned by Writer when attempting to encode an unsupported value type. NewWriter returns a new Writer that writes to w. WriteStruct writes a single CSV record to w along with any necessary quoting. A record is a struct of flat structure."
    },
    {
        "link": "https://kelche.co/blog/go/csv",
        "document": "Working with CSV (Comma Separated Values) files is a common task in programming, particularly when working with large datasets. CSV files are lightweight, and easy to work with and create, making them a popular choice for data exchange and storage. In this article, we’ll look at how to work with CSV files in Golang.\n\nGolang comes with a built-in package for working with CSV files, . This package provides a and type that are used to read and write CSV files. Before we get started, let’s create a simple CSV file to work with. Create a file called and add the following data:\n\nThere are two ways to read a CSV file. The first is to read the entire file at once, or line by line. We’ll look at both methods.\n\nTo read a CSV file, we’ll use the type from the package. The type has a method that reads the entire CSV file and returns a nested slice of strings. Let’s look at an example:\n\nThe field on the type is used to specify the number of fields per record. If the number of fields per record is not known, we can set this field to to allow the to determine the number of fields per record.\n\nThe method reads all the rows in the CSV file and returns a nested slice of strings. If we were to access a single value, we could do so by using the row and column index:\n\nThe method on the type reads a single row from the CSV file and returns a slice of strings. Let’s look at an example:\n\nThis example reads the CSV file line by line. The method returns an error when it reaches the end of the file. We can use this error to break out of the loop.\n\nSome CSV files use different delimiter characters, such as or . To read these files, we can use the field on the type to specify the delimiter character. First, let’s create a new CSV file with a different delimiter:\n\nNow let’s read the file using the field:\n\nA CSV file can be written to using the type from the package. The type has a method that accepts a slice of strings and writes it to the CSV file. Let’s look at an example:\n\nThe method on the type is used to flush any buffered data to the underlying writer. If we don’t call the method, the data will not be written to the CSV file.\n\nThe type like the type has a method that accepts a nested slice of strings and writes it to the CSV file. Let’s look at an example:\n\nAppending is the same way as writing to a CSV file, except that we need to open the file in append mode.\n\nIn this article, we looked at how to read and write CSV files in Go. We also looked at how to append data to a CSV file. For more features of the package, check out the official documentation - ."
    },
    {
        "link": "https://golang.google.cn/pkg/encoding/csv",
        "document": "Package csv reads and writes comma-separated values (CSV) files. There are many kinds of CSV files; this package supports the format described in RFC 4180, except that Writer uses LF instead of CRLF as newline character by default. A csv file contains zero or more records of one or more fields per record. Each record is separated by the newline character. The final record may optionally be followed by a newline character. Blank lines are ignored. A line with only whitespace characters (excluding the ending newline character) is not considered a blank line. Fields which start and stop with the quote character \" are called quoted-fields. The beginning and ending quote are not part of the field. Within a quoted-field a quote character followed by a second quote character is considered a single quote. Newlines and commas may be included in a quoted-field\n\nThese are the errors that can be returned in [ParseError.Err].\n\nA ParseError is returned for parsing errors. Line and column numbers are 1-indexed.\n\nAs returned by NewReader, a Reader expects input conforming to RFC 4180. The exported fields can be changed to customize the details before the first call to Reader.Read or Reader.ReadAll.\n\nThe Reader converts all \\r\n\n sequences in its input to plain \n\n, including in multiline field values, so that the returned data does not depend on which line-ending convention an input file uses.\n\nNewReader returns a new Reader that reads from r.\n\nFieldPos returns the line and column corresponding to the start of the field with the given index in the slice most recently returned by Reader.Read. Numbering of lines and columns starts at 1; columns are counted in bytes, not runes.\n\nIf this is called with an out-of-bounds index, it panics.\n\nInputOffset returns the input stream byte offset of the current reader position. The offset gives the location of the end of the most recently read row and the beginning of the next row.\n\nRead reads one record (a slice of fields) from r. If the record has an unexpected number of fields, Read returns the record along with the error ErrFieldCount. If the record contains a field that cannot be parsed, Read returns a partial record along with the parse error. The partial record contains all fields read before the error. If there is no data left to be read, Read returns nil, io.EOF. If [Reader.ReuseRecord] is true, the returned slice may be shared between multiple calls to Read.\n\nReadAll reads all the remaining records from r. Each record is a slice of fields. A successful call returns err == nil, not err == io.EOF. Because ReadAll is defined to read until EOF, it does not treat end of file as an error to be reported.\n\nAs returned by NewWriter, a Writer writes records terminated by a newline and uses ',' as the field delimiter. The exported fields can be changed to customize the details before the first call to Writer.Write or Writer.WriteAll.\n\nIf [Writer.UseCRLF] is true, the Writer ends each output line with \\r\n\n instead of \n\n.\n\nThe writes of individual records are buffered. After all data has been written, the client should call the Writer.Flush method to guarantee all data has been forwarded to the underlying io.Writer. Any errors that occurred should be checked by calling the Writer.Error method.\n\nNewWriter returns a new Writer that writes to w.\n\nError reports any error that has occurred during a previous Writer.Write or Writer.Flush.\n\nFlush writes any buffered data to the underlying io.Writer. To check if an error occurred during Flush, call Writer.Error.\n\nWrite writes a single CSV record to w along with any necessary quoting. A record is a slice of strings with each string being one field. Writes are buffered, so Writer.Flush must eventually be called to ensure that the record is written to the underlying io.Writer.\n\nWriteAll writes multiple CSV records to w using Writer.Write and then calls Writer.Flush, returning any error from the Flush."
    },
    {
        "link": "https://stackoverflow.com/questions/63641383/how-this-error-handling-works-csv-file-reading-and-writing-case",
        "document": "I'm learning how to read and write CSV files and error handling in Go.\n\nI found a query whose answer I do not understand.\n\nUsing Golang to read csv, reorder columns then write result to a new csv with Concurrency\n\nWhy error equals the return of writer.Write()?\n\nI'm used to seeing only\n\nCould you explain it to me?"
    },
    {
        "link": "https://honeybadger.io/blog/comprehensive-guide-to-file-operations-in-go",
        "document": "Proper file management systems date to the 1800s, and it is safe to say that the internet and even computers would not be able to work properly if they could not store, read, write, and delete files. In this article, you will learn everything you need to know about file operations in Go, from writing, reading, and creating files to creating and deleting directories in Go applications.\n\nThe primary prerequisite to follow along with this article is a basic understanding of Go. You can check out my Go Beginners Series to get more familiar with it or for a quick brush-up on your Go skills.\n\nGo's file handling is quite straightforward due to its built-in package ; it provides access to most of the operating system's features, including the file system. It allows you to perform file operations without needing to change the code for it to work with different operating systems.\n\nThe packages enable you to perform various file operations in your applications, from writing, reading, and creating files to creating and deleting directories. It also provides helpful error messages whenever it encounters errors while performing file operations.\n\nWe’ll explore how to read files in Go in the next section.\n\nReading files is probably the most frequent file operation you'll perform in Go, as many use cases require it. In this section, we will explore how to read different types of files in Go.\n\nThe package provides a function that makes reading files straightforward in Go. For example, I have a data.txt file in my project folder, and I can read and print it out with the following code:\n\nThe code above defines a variable with a string value of the file that I'm trying to read, . It then reads the file with the function and stores the result and error in the and variables. Finally, it checks for errors before printing the result in string format by wrapping it with the helper function. It should return the following output in the terminal:\n\nAnd that's it! You've just read your first file in Go! Let's explore how to read a file line-by-line in the next section.\n\nIn this section, we will explore a real-life use case of reading files in Go. Let's imagine that you're building an application that helps users deploy Go applications. You need to have a way for users to see the deployment errors so that they have an idea of what to fix before trying to re-deploy their application.\n\nWe will write a code that reads a log file line-by-line and prints only the amount of lines requested by the user. This way, users can choose to see only the last five logs and don't have to scroll through all the logs to find the issue with their deployment.\n\nI have a sample file that looks like this:\n\nThe code for doing this will look like this:\n\nThe code above uses the ' package function to open the file, defers its function with the keyword, defines an empty slice, and uses the 's function to read the file line-by-line while appending each line to the array in a text format using the function. Finally, it uses the function to get the last lines of the array. is any number of the user's choosing. In this case, it is 3, and the code uses a loop to print each line with an horizontal line between each one.\n\nUsing the sample file, the code above should return the following:\n\nNext, let's explore how to read files in Go.\n\nReading and using data from files is also a popular use case in programming, so let's learn how to do that. For example, you have a configuration file that looks like the following:\n\nYou also need to read for your application to work correctly, which can be done by reading and decoding the file:\n\nThe code above uses the ' package function to open the file, defers its function with the keyword, and uses the 's function to read the file. It then uses the function to decode it into an object and checks for errors before printing the details in the terminal:\n\nThat's it! You can now split the object up and use it however you like in your application.\n\nNext, let's look at how to read a file.\n\nComma-separated values (CSV) is one of the most popular file formats. Let's explore how to read the following file in this section:\n\nGo provides an package that can be used to read files:\n\nThe code above uses the ' package function to open the file, defer its function with the keyword, and create a variable that stores the result of the function. It then uses the function to read the file, check for errors, and print the result in the terminal. The output should look like this:\n\nLet's explore how to read bytes from files in the next section.\n\nReading bytes from files in Go\n\nIn some cases, you might want to read a specific number of bytes from files in Go:\n\nThe code above uses the ' package function to open the file, defer its function with the keyword, and create a variable that has the value of 10 bytes using the function. It then checks for errors before printing the out in bytes and string formats:\n\nNow that we've explored how to perform various read operations on different file formats in Go, let's explore how to handle write operations.\n\nWriting and manipulating files in Go\n\nReading and writing files is relatively straightforward in Go, as it provides developers with a lot of functions to perform such tasks without needing to download a third-party library. In this section, we will explore different Go writing tasks and how to handle them properly.\n\nGo's package provides a function that creates files with any extension. For example, suppose you have an application that helps users to deploy applications. In this case, you might want to create an empty file containing the logs of the application immediately after the user creates a new project:\n\nThe code above uses the 's function to create an empty file, checks for any error, and prints a success message to the user. The user should see the following output in the terminal:\n\nBefore continuing with writing files in Go, let's explore the different file opening flags in Go, as we will use some of them in the later in the article.\n\nGo provides file-opening flags represented by constants defined in the package. These flags determine the behavior of file operations, such as opening, creating, and truncating files. The following is a list of the flags and what they do.\n• None : Opens the file as read-only. The file must exist.\n• None : Opens the file as write-only. If the file exists, its contents are truncated. If it doesn't exist, a new file is created.\n• None : Opens the file for reading and writing. If the file exists, its contents are truncated. If it doesn't exist, a new file is created.\n• None : Appends data to the file when writing. Writes occur at the end of the file.\n• None : Creates a new file if it doesn't exist.\n• None : Used with , it ensures that the file is created exclusively, preventing creation if it already exists.\n• None : Open the file for synchronous I/O operations. Write operations are completed before the call returns.\n• None : If the file exists and is successfully opened, its contents are truncated to zero length.\n• None : Opens the file in non-blocking mode. Operations like read or write may return immediately with an error if no data is available or the operation would block.\n\nThese flags can be combined using the bitwise OR ( ) operator. For example, would open the file for writing, creating it if it doesn't exist.\n\nWhen using these flags, it's important to check for errors returned by file operations to handle cases where the file cannot be opened or created as expected.\n\nLet's look at how to write text to files in the next section.\n\nWriting text to files in Go\n\nThe package also provides a function that helps you write strings to files. For example, you want to update the file with a log message:\n\nThe code above uses the function to open the file in write-only mode and creates it if it doesn't exist. It then creates a variable containing a string and uses the function to write string data to the file.\n\nAppending to a file in Go\n\nThe code in the previous section deletes the data inside the file before writing the new data every time the code is run, which is acceptable in some cases. However, for a log file, you want it to retain all the previous logs so that the user can refer to them as many times as needed to, for example, perform analytics.\n\nYou can open a file in append mode like this:\n\nThe code above uses the to open the file in append mode and will retain all the existing data before adding new data to the file. You should get an updated file each time you run the code instead of a new file.\n\nWriting bytes to files in Go\n\nGo allows you to write bytes to files as strings with the function. For example, if you are streaming data from a server and it is returning bytes, you can write the bytes to a file to be readable:\n\nThe code above opens the file in write-only and append mode and creates it if it doesn't already exist. The code above should return a file containing the following:\n\nNext, let's explore how to write formatted data to a file section.\n\nWriting formatted data to a file in Go\n\nThis is one of the most common file-writing tasks when building software applications. For example, if you are building an e-commerce website, you will need to build order confirmation receipts for each buyer, which will contain the details of the user's order. Here is how you can do this in Go:\n\nThe code above defines two variables, and , creates a based on the variables, checks for errors, and defers the function with the keyword. It then defines three variables, , , and , formats a message with the 's all the variables, and writes it to the file.\n\nThe code above then creates an file with the following contents:\n\nWriting to files in Go\n\nWith the help of the package, you can write data to files easily with Go. For example, you want to store new users' profile information in a file after they sign up:\n\nThe code above opens the file in write-only and append mode and creates it if it doesn't already exist. It will then use the function to create a variable, defer the function, create a variable with the slice, and write the data to the file with the function.\n\nThe code above will then return a file with the following contents:\n\nWriting JSON data to a file in Go\n\nWriting JSON data to files is a common use case in software development. For example, you are building a small application and want to use a simple file to store your application data:\n\nThe code above opens the file in write-only and append mode and creates it if it doesn't already exist, defers the function, and defines a variable containing the user data. It then creates an variable with the function and encodes it with the function.\n\nThe code above then returns a file containing the following:\n\nWriting XML data to files in Go\n\nYou can also write XML data to files in Go using the package:\n\nThe code above defines a struct with three fields, opens the file in write-only and append mode and creates it if it doesn't already exist, defers the function, and defines a variable that contains the user data. It then creates an variable with the function and encodes it with the function.\n\nThe code above should return a file that contains the following contents:\n\nGo enables you to rename files from your code using the function:\n\nThe code above renames the file created in the previous section to .\n\nGo enables you to delete files with the function:\n\nThe code above deletes the file from the specified path.\n\nNow that you understand how to write and manipulate different types of files in Go, let's explore how to work with directories.\n\nWorking with directories in Go\n\nIn addition to files, Go also provides functions that you can use to perform different tasks in applications. We will explore some of these tasks in the following sections.\n\nGo provides a function that you can use to create an empty directory:\n\nThe code above creates a folder in the current working directory.\n\nYou can create multiple directories in Go using the function:\n\nThe code above will create a directory and a directory inside it.\n\nChecking if a directory exists in Go\n\nTo avoid errors, checking if a directory exists before creating a file or directory inside is good practice. You can use the function and the function to do a quick check:\n\nThe code above returns a message based on the results of the check. In my case, it will return the following:\n\nYou can also use the function to rename directories:\n\nThe code above renames the directory to .\n\nDeleting an empty directory in Go\n\nYou can use the function to delete folders in your applications:\n\nThe code above removes the directory from the directory.\n\nDeleting a directory with all its content in Go\n\nGo provides a function that allows you to remove all the directories and everything inside them, including files and folders:\n\nThe code above deletes the directory and everything inside it.\n\nGet a list of files and directories in a directory in Go\n\nYou can retrieve a list of all the files and directories in a directory using the function:\n\nThe code above returns a list of all the directories and files inside the folder.\n\nNow that you know how to work with directories in Go applications, let's explore some of the advanced file operations in the next section.\n\nIn this section, we will explore some of the advanced file operations you might encounter in Go applications.\n\nWriting compressed data to a file in Go\n\nWorking with compressed files is uncommon, but here's how to create a file inside a compressed file using the package:\n\nThe code above creates a , which contains a file in the working directory.\n\nWriting encrypted data to a file in Go\n\nWhen building applications that require secure files, you can create an encrypted file with Go's and packages:\n\nThe code above creates an file containing an encrypted version of the string:\n\nCopying a file to another directory in Go\n\nCopying existing files to different locations is something we all do frequently. Here's how to do it in Go:\n\nThe code above copies the file in the directory and its contents and then creates another with the same in the root directory.\n\nGet file properties in Go\n\nGo allows you to get the properties of a file with the function:\n\nThe code above returns the name, size, permissions, and last modified date of the file:\n\nGet the current working directory path in Go\n\nYou can get the current working directory of your application in Go:\n\nThe code above will return the full path of my current working directory:\n\nThat's it! You now have the knowledge to tackle most of the file operations you'll encounter when building Go applications. In this article, we explored how to read, write and manipulate files and directories in Go.\n\nWe also explored how to solve many file operations problems by combining different Go packages and functions. Thank you so much for reading! If you have any questions, suggestions, or corrections, feel free to connect with me on Twitter and LinkedIn, and I'll try my best to work on them."
    },
    {
        "link": "https://earthly.dev/blog/golang-errors",
        "document": "This article explores Go error handling. Earthly is popular with Go developers for ensuring reproducible builds. Check it out.\n\nError handling in Go is a little different than other mainstream programming languages like Java, JavaScript, or Python. Go’s built-in errors don’t contain stack traces, nor do they support conventional / methods to handle them. Instead, errors in Go are just values returned by functions, and they can be treated in much the same way as any other datatype - leading to a surprisingly lightweight and simple design.\n\nIn this article, I’ll demonstrate the basics of handling errors in Go, as well as some simple strategies you can follow in your code to ensure your program is robust and easy to debug.\n\nThe error type in Go is implemented as the following interface:\n\nSo basically, an error is anything that implements the method, which returns an error message as a string. It’s that simple!\n\nErrors can be constructed on the fly using Go’s built-in or packages. For example, the following function uses the package to return a new error with a static error message:\n\nSimilarly, the package can be used to add dynamic data to the error, such as an , , or another . For example:\n\nNote that will prove extremely useful when used to wrap another error with the format verb - but I’ll get into more detail on that further down in the article.\n\nThere are a few other important things to note in the example above.\n• None Errors can be returned as , and in fact, it’s the default, or “zero”, value of on error in Go. This is important since checking is the idiomatic way to determine if an error was encountered (replacing the / statements you may be familiar with in other programming languages).\n• None Errors are typically returned as the last argument in a function. Hence in our example above, we return an and an , in that order.\n• None When we do return an error, the other arguments returned by the function are typically returned as their default “zero” value. A user of a function may expect that if a non-nil error is returned, then the other arguments returned are not relevant.\n• None Lastly, error messages are usually written in lower-case and don’t end in punctuation. Exceptions can be made though, for example when including a proper noun, a function name that begins with a capital letter, etc.\n\nAnother important technique in Go is defining expected Errors so they can be checked for explicitly in other parts of the code. This becomes useful when you need to execute a different branch of code if a certain kind of error is encountered.\n\nBuilding on the function from earlier, we can improve the error signaling by pre-defining a “Sentinel” error. Calling functions can explicitly check for this error using :\n\nMany error-handling use cases can be covered using the strategy above, however, there can be times when you might want a little more functionality. Perhaps you want an error to carry additional data fields, or maybe the error’s message should populate itself with dynamic values when it’s printed.\n\nYou can do that in Go by implementing custom errors type.\n\nBelow is a slight rework of the previous example. Notice the new type , which implements the . We can make use of to check and convert from a standard error to our more specific .\n\nIn these examples so far, the errors have been created, returned, and handled with a single function call. In other words, the stack of functions involved in “bubbling” up the error is only a single level deep.\n\nOften in real-world programs, there can be many more functions involved - from the function where the error is produced, to where it is eventually handled, and any number of additional functions in-between.\n\nIn Go 1.13, several new error APIs were introduced, including and , which are useful in applying additional context to an error as it “bubbles up”, as well as checking for particular error types, regardless of how many times the error has been wrapped.\n\nThe Old Way (Before Go 1.13)\n\nIt’s easy to see just how useful the new error APIs are in Go 1.13+ by looking at some examples where the old API was limiting.\n\nLet’s consider a simple program that manages a database of users. In this program, we’ll have a few functions involved in the lifecycle of a database error.\n\nFor simplicity’s sake, let’s replace what would be a real database with an entirely “fake” database that we import from .\n\nLet’s also assume that this fake database already contains some functions for finding and updating user records. And that the user records are defined to be a struct that looks something like:\n\nNow, what happens if one of our database operations fails with some error?\n\nThe error check in the function should catch that and print something like this:\n\nBut which of the two database operations produced the error? Unfortunately, we don’t have enough information in our error log to know if it came from or .\n\nGo 1.13 adds a simple way to add that information.\n\nThe snippet below is refactored so that is uses with a verb to “wrap” errors as they “bubble up” through the other function calls. This adds the context needed so that it’s possible to deduce which of those database operations failed in the previous example.\n\nIf we re-run the program and encounter the same error, the log should print the following:\n\nNow our message contains enough information that we can see the problem originated in the function. Phew! That definitely saved us some time debugging!\n\nIf used correctly, error wrapping can provide additional context about the lineage of an error, in ways similar to a traditional stack-trace.\n\nWrapping also preserves the original error, which means and continue to work, regardless of how many times an error has been wrapped. We can also call to return the previous error in the chain.\n\nGenerally, it’s a good idea to wrap an error with at least the function’s name, every time you “bubble it up” - i.e. every time you receive the error from a function and want to continue returning it back up the function chain.\n\nThere are some exceptions to the rule, however, where wrapping an error may not be appropriate.\n\nSince wrapping the error always preserves the original error messages, sometimes exposing those underlying issues might be a security, privacy, or even UX concern. In such situations, it could be worth handling the error and returning a new one, rather than wrapping it. This could be the case if you’re writing an open-source library or a REST API where you don’t want the underlying error message to be returned to the 3rd-party user.\n\nThat’s a wrap! In summary, here’s the gist of what was covered here:\n• Errors in Go are just lightweight pieces of data that implement the\n• Predefined errors will improve signaling, allowing us to check which error occurred\n• Wrap errors to add enough context to trace through function calls (similar to a stack trace)\n\nI hope you found this guide to effective error handling useful. If you’d like to learn more, I’ve attached some related articles I found interesting during my own journey to robust error handling in Go.\n\nAlso, checkout Earthly. I work on it and its written in go and is open source.\n• Go By Example: Errors\n• Go By Example: Panic"
    },
    {
        "link": "https://stackoverflow.com/questions/34008600/handle-a-specific-error-in-golang",
        "document": "I am trying to simply ignore the error in our code but cannot seem to only look at that one error. What am I doing wrong here?\n\nBut when I run the code the last line of the csv file gives me this error paniced"
    },
    {
        "link": "https://news.ycombinator.com/item?id=39943217",
        "document": ""
    }
]