[
    {
        "link": "https://geeksforgeeks.org/effectively-final-variable-in-java-with-examples",
        "document": "A final variable is a variable that is declared with a keyword known as ‘final‘.\n\nThe Effectively Final variable is a local variable that follows the following properties are listed below as follows:\n• Assigned to ONLY once.\n\nAny local variable or parameter that’s assigned a worth just one occasion right now(or updated only once). It may not remain effectively final throughout the program. so this suggests that effectively final variable might lose its effectively final property after immediately the time it gets assigned/updated a minimum of another assignment. Additionally, an effectively final variable may be a variable whose value isn’t changed, but it isn’t declared with the ultimate keyword.\n\nOutput: An error will be thrown as expected which can be perceived from the terminal output as shown below:\n\nWhen a lambda expression uses an assigned local variable from its enclosing space there’s a crucial restriction. A lambda expression may only use a local variable whose value doesn’t change. That restriction is referred to as “variable capture” which is described as; lambda expression capture values, not variables.\n\nThe local variables that a lambda expression may use are referred to as “effectively final”.\n\nAn effectively final variable is one whose value doesn’t change after it’s first assigned. There is no need to explicitly declare such a variable as final, although doing so would not be an error.\n\nImplementation: Consider we do have an area variable let it be ‘i’ which is initialized with the worth say be ‘7’, with within the lambda expression we try to vary that value by assigning a new value to i. This will end in compiler error – “Local variable i defined in an enclosing scope must be final or effectively final”."
    },
    {
        "link": "https://stackoverflow.com/questions/20938095/difference-between-final-and-effectively-final",
        "document": "I'm playing with lambdas in Java 8 and I came across warning local variables referenced from a lambda expression must be final or effectively final . I know that when I use variables inside anonymous class they must be final in outer class, but still - what is the difference between final and effectively final?\n\n... starting in Java SE 8, a local class can access local variables and parameters of the enclosing block that are final or effectively final. A variable or parameter whose value is never changed after it is initialized is effectively final. For example, suppose that the variable is not declared final, and you add the marked assignment statement in the constructor: public class OutterClass { int numberLength; // <== not *final* class PhoneNumber { PhoneNumber(String phoneNumber) { numberLength = 7; // <== assignment to numberLength String currentNumber = phoneNumber.replaceAll( regularExpression, \"\"); if (currentNumber.length() == numberLength) formattedPhoneNumber = currentNumber; else formattedPhoneNumber = null; } ... } ... } Because of this assignment statement, the variable numberLength is not effectively final anymore. As a result, the Java compiler generates an error message similar to \"local variables referenced from an inner class must be final or effectively final\" where the inner class PhoneNumber tries to access the numberLength variable:\n\nThis variable below is final, so we can't change it's value once initialised. If we try to we'll get a compilation error... But if we create a variable like this, we can change it's value... But in Java 8, all variables are final by default. But the existence of the 2nd line in the code makes it non-final. So if we remove the 2nd line from the above code, our variable is now \"effectively final\"... So.. Any variable that is assigned once and only once, is \"effectively final\".\n\nA variable or parameter whose value is never changed after it is initialized is effectively final. Basically, if the compiler finds a variable does not appear in assignments outside of its initialization, then the variable is considered effectively final. For example, consider some class: public class Foo { public void baz(int bar) { // While the next line is commented, bar is effectively final // and while it is uncommented, the assignment means it is not // effectively final. // bar = 2; } }\n\nWhen a lambda expression uses an assigned local variable from its enclosing space there is an important restriction. A lambda expression may only use local variable whose value doesn't change. That restriction is referred as \"variable capture\" which is described as; lambda expression capture values, not variables. \n\n The local variables that a lambda expression may use are known as \"effectively final\". \n\n An effectively final variable is one whose value does not change after it is first assigned. There is no need to explicitly declare such a variable as final, although doing so would not be an error.\n\n Let's see it with an example, we have a local variable i which is initialized with the value 7, with in the lambda expression we are trying to change that value by assigning a new value to i. This will result in compiler error - \"Local variable i defined in an enclosing scope must be final or effectively final\"\n\nfinal is a variable declare with key word , example: it remains through out the program, changing pi after this line is never allowed. effectively final : any local variable or parameter that is assigned a value only once right now(or updated only once). It may not remain effectively final throughout the program. so this means that effectively final variable might loses its effectively final property after immediately the time it gets assigned/updated at least one more assignment. example: class EffectivelyFinal { public static void main(String[] args) { calculate(124,53); } public static void calculate( int operand1, int operand2){ int rem = 0; // operand1, operand2 and rem are effectively final here rem = operand1%2 // rem lost its effectively final property here because it gets its second assignment // operand1, operand2 are still effectively final here class operators{ void setNum(){ operand1 = operand2%2; // operand1 lost its effectively final property here because it gets its second assignment } int add(){ return rem + operand2; // does not compile because rem is not effectively final } int multiply(){ return rem * operand1; // does not compile because both rem and operand1 are not effectively final } } } }\n\nDeclaring a variable or not declaring it , but keeping it effectively final may result (depends on compiler) in different bytecode. Let's have a look on a small example: public static void main(String[] args) { final boolean i = true; // 6 // final by declaration boolean j = true; // 7 // effectively final if (i) { // 9 System.out.println(i);// 10 } if (!i) { // 12 System.out.println(i);// 13 } if (j) { // 15 System.out.println(j);// 16 } if (!j) { // 18 System.out.println(j);// 19 } } The corresponding bytecode of the method (Java 8u161 on Windows 64 Bit): As we see the source code at lines , , doesn't appear in the byte code. That's because is and will not change it's state. Thus this code is unreachable (more in this answer). For the same reason the code at line misses too. The state of doesn't have to be evaluated since it is for sure. On the other hand though the variable is effectively final it's not processed in the same way. There are no such optimizations applied. The state of is evaluated two times. The bytecode is the same regardless of being effectively final.\n\nThere are three types of final variables declared in java. There are 3 kinds of Implicitly declared final variables. These are the variables declared with keyword. Variables are considered as a effectively final, if: i. A local variable declared in a statement and whose declarator has an initializer, OR a local variable declared by a pattern and it should be followed below rules:\n• never occur as value assignment\n• never occur as operand of a prefix or postfix increment or decrement operator ex: A local variable declared in a statement and whose declarator has an initializer. Here variable iterator is effectively final since it's follow above rules. Note: If variable is an effectively final, it can also declared with keyword. public String getStringfromObj(Object o){ if (o instanceof String s && s.startsWith(\"Java\")) { // can be declared as final String s return s; } return \"\"; } ii. A local variable declared in a statement and initialized later. This should be followed bellow rules.\n• never occur as value assignment before and after definite assignment\n• never occur as operand of a prefix or postfix increment or decrement operator List<String> ls = Arrays.asList(\"A\", \"B\", \"C\"); int k; // can be declared as final int k if ((k = ls.size()) > 0) { System.out.println(k); } iii. A method, constructor, lambda, or exception parameter whose declarator has an initializer."
    },
    {
        "link": "https://baeldung.com/java-effectively-final",
        "document": "One of the most interesting features introduced in Java 8 is effectively final. It allows us to not write the final modifier for variables, fields, and parameters that are effectively treated and used like final ones.\n\nIn this tutorial, we’ll explore this feature’s origin and how it’s treated by the compiler compared to the final keyword. Furthermore, we’ll explore a solution to use regarding a problematic use-case of effectively final variables.\n\nIn simple terms, objects or primitive values are effectively final if we do not change their values after initialization. In the case of objects, if we do not change the reference of an object, then it is effectively final — even if a change occurs in the state of the referenced object.\n\nPrior to its introduction, we could not use a non-final local variable in an anonymous class. We still cannot use variables that have more than one value assigned to them inside anonymous classes, inner classes, and lambda expressions. The introduction of this feature allows us to not have to use the final modifier on variables that are effectively final, saving us a few keystrokes.\n\nAnonymous classes are inner classes and they cannot access non-final or non-effectively-final variables or mutate them in their enclosing scopes as specified by JLS 8.1.3. The same limitation applies to lambda expressions, as having access can potentially produce concurrency issues.\n\nThe simplest way to understand whether a final variable is effectively final is to think whether removing the final keyword would allow the code to compile and run:\n\nReassigning a value or mutating the above effectively final variable would make the code invalid regardless of where it occurs.\n\nJLS 4.12.4 states that if we remove the final modifier from a parameter or a local variable in a valid program without introducing compile-time errors, then it becomes effectively final. Moreover, it’s also safe to add the final modifier to an effectively final variable or parameter.\n\nThe Java compiler doesn’t do additional optimization for effectively final variables, unlike it does for final variables.\n\nLet’s consider a simple example that declares two final String variables but only uses them for concatenation:\n\nThe compiler would change the code executed in the main method above to:\n\nOn the other hand, if we remove the final modifiers, the variables would be considered effectively final, but the compiler won’t remove them since they’re only used for concatenation.\n\nGenerally, it’s not a good practice to modify variables used in lambda expressions and anonymous classes. We cannot know how these variables are going to be used inside method blocks. Mutating them might lead to unexpected results in multithreading environments.\n\nWe already have a tutorial explaining the best practices when using lambda expressions and another that explains common anti-patterns when we modify them. But there’s an alternative approach that allows us to modify variables in such cases that achieves thread-safety through atomicity.\n\nThe package java.util.concurrent.atomic offers classes such as AtomicReference and AtomicInteger. We can use them to atomically modify variables inside lambda expressions:\n\nIn this tutorial, we learned about the most notable differences between final and effectively final variables. In addition, we provided a safe alternative that allows us to modify variables inside lambda functions."
    },
    {
        "link": "https://stackoverflow.com/questions/67065119/why-dont-instance-fields-need-to-be-final-or-effectively-final-to-be-used-in-la",
        "document": "The other answers already provide great context around why this is a limitation in Java. I'd like to offer some background on how other languages deal with this when they don't enforce the requirement that local variables be considered immutable (i.e. ).\n\nThe main point suggested is that \"heap\" values (i.e. fields) are intrinsically accessible from other threads, whereas \"stack\" values (i.e. local variables) are intrinsically accessible only from within the method that declared the values. This is true. So since fields are stored on the heap, they can be mutated after the method has completed. In contrast, stack values go away as soon as the method finishes.\n\nJava chooses to honor these semantics, so a local variable must never be modified after the method completes. This is a fair design decision. However, some languages do choose to allow mutation to local variables after the method exits. So how can that be?\n\nIn C# (the language I'm most familiar with, but other languages such as JavaScript also allow these constructs) when you reference a local variable inside of a lambda, the compiler detects that and behind the scenes actually generates a whole new class to store the local variable. So instead of the variable being declared on the stack, the compiler detects that it's been referenced inside of a lambda, and so instead instantiates that class to store the value. So this (behind the scenes) behavior turns the stack value into a heap value. (you can actually decompile such code and see these compiler generated classes)\n\nThis decision isn't without cost. It's obviously more expensive to instantiate a class just to house, for example, an integer. In Java, you are guaranteed this will never happen. In a language such as C#, it requires careful reasoning to know whether your variable has been \"lifted\" into that generated class.\n\nSo ultimately the rationale becomes one of a design decision. In Java you can't shoot yourself in the foot. In C# they decided that most of the time the performance consequences aren't that big of a deal.\n\nThat said, C#'s decision has often been a source of confusion and bugs, particularly around the loop iterator variable in a loop (the loop variable can (and must) be mutated) and passed to a lambda, as described in Eric Lippert's blog post. It was so problematic that they decided to introduce a (rare) breaking change to the compiler for the variant.\n\nOn the other hand, I've enjoyed the freedom to mutate local variables inside of a lamda in C#. But neither decision comes without cost.\n\nThis answer is definitely not trying to advocate on either decision, but I thought it was worthwhile to elaborate on some of these design choices."
    },
    {
        "link": "https://medium.com/@itsandip1/understanding-javas-effectively-final-variables-61e03a0be93a",
        "document": "In the world of Java programming, you might have come across the term “effectively final.” It’s a concept that plays a crucial role in the context of lambda expressions and anonymous inner classes. In this blog, we’ll explore what effectively final variables are, why they matter, and how they impact your Java code.\n\nBefore we dive into effectively final variables, let’s briefly review what a variable is in Java. A variable is a variable that can be assigned a value only once. Once a variable is assigned a value, it cannot be changed, making it constant throughout its lifetime. Here's a simple example:\n\nIn this example, myValue is a final variable, and it’s assigned the value 42. Any attempt to change the value of myValue will result in a compilation error.\n\nJava introduced the concept of “effectively final” in Java 8, primarily to allow lambda expressions and anonymous inner classes to access local variables. These constructs can only access final or effectively final variables from their enclosing scope.\n\nSo, what does “effectively final” mean? An effectively final variable is a non-final variable that is still treated as final if it satisfies the following conditions:\n• The variable is not explicitly declared as final.\n• The variable is never reassigned after its initial assignment.\n\nLet’s look at an example to illustrate this concept:\n\nIn this example, the variables and are effectively final because they are not explicitly declared as , but they are never reassigned after their initial assignment. Lambda expressions ( ) can access and use these variables without any issues.\n\nWhy Does It Matter?\n\nUnderstanding effectively final variables is crucial when working with lambda expressions and anonymous inner classes. By allowing these constructs to access local variables, Java promotes more concise and readable code.\n\nHere are some benefits of effectively final variables:\n\nUsing effectively final variables in lambda expressions and anonymous inner classes can lead to cleaner and more readable code. You don’t need to declare every local variable as , reducing boilerplate code.\n\nEffectively final variables promote encapsulation by encouraging you to declare variables in the narrowest possible scope. This helps prevent unintended changes to variables from other parts of your code.\n\nEffectively final variables are safer to use in multi-threaded environments because they are essentially read-only. This reduces the risk of data races and synchronization issues.\n\nTo make the most of effectively final variables in your Java code, consider the following best practices:\n\n1. Declare Variables in the Narrowest Scope: Declare variables in the smallest possible scope to limit their visibility and prevent unintended changes.\n\n2. Use When Appropriate: If you know that a variable should not be modified, consider declaring it as explicitly to document your intent.\n\n3. Avoid Unnecessary Mutability: Aim for immutability whenever possible. Immutable objects and effectively final variables lead to safer and more predictable code.\n\n4. Review Lambda Expressions: When using lambda expressions and anonymous inner classes, check that all accessed variables are effectively final or .\n\nEffectively final variables are a valuable addition to Java, making code cleaner, more readable, and safer. They allow lambda expressions and anonymous inner classes to access local variables while promoting good coding practices such as encapsulation and immutability. By understanding and using effectively final variables effectively, you can write more robust and maintainable Java code."
    },
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/awt/image/BufferedImage.html",
        "document": ". Returns a of objects that are the immediate sources, not the sources of these immediate sources, of image data for this\n\nSets a rectangular region of the image to the contents of the specified , which is assumed to be in the same coordinate space as the ."
    },
    {
        "link": "https://docs.oracle.com/javase/tutorial/2d/images/index.html",
        "document": "The Java Tutorials have been written for JDK 8. Examples and practices described in this page don't take advantage of improvements introduced in later releases and might use technology no longer available. See Dev.java for updated tutorials taking advantage of the latest releases. See Java Language Changes for a summary of updated language features in Java SE 9 and subsequent releases. See JDK Release Notes for information about new features, enhancements, and removed or deprecated options for all JDK releases.\n\nAs you have already learned from the Images lesson, s are described by a width and a height, measured in pixels, and have a coordinate system that is independent of the drawing surface.\n\nThere are a number of common tasks when working with images.\n• Loading an external GIF, PNG JPEG image format file into the internal image representation used by Java 2D.\n• Directly creating a Java 2D image and rendering to it.\n• Drawing the contents of a Java 2D image on to a drawing surface.\n• Saving the contents of a Java 2D image to an external GIF, PNG, or JPEG image file.\n\nThis lesson teaches you the basics of loading, displaying, and saving images.\n\nThe are two main classes that you must learn about to work with images:\n• The class is the superclass that represents graphical images as rectangular arrays of pixels.\n• The class, which extends the class to allow the application to operate directly with image data (for example, retrieving or setting up the pixel color). Applications can directly construct instances of this class.\n\nThe class is a cornerstone of the Java 2D immediate-mode imaging API. It manages the image in memory and provides methods for storing, interpreting, and obtaining pixel data. Since is a subclass of it can be rendered by the and methods that accept an parameter.\n\nA is essentially an with an accessible data buffer. It is therefore more efficient to work directly with . A has a ColorModel and a Raster of image data. The ColorModel provides a color interpretation of the image's pixel data.\n\nThe Raster performs the following functions:\n• Represents the rectangular coordinates of the image\n• Provides a mechanism for creating multiple subimages from a single image data buffer\n• Provides methods for accessing specific pixels within the image\n\nThe basic operations with images are represented in the following sections:\n\nThis section explains how to load an image from an external image format into a Java application using the Image I/O API\n\nThis section teaches how to display images using the method of the and classes.\n\nCreating and drawing To an image\n\nThis section describes how to create an image and how to use the image itself as a drawing surface.\n\nThis section explains how to save created images in an appropriate format."
    },
    {
        "link": "https://stackoverflow.com/questions/40439572/drawing-on-a-buffered-image",
        "document": "You're creating two BufferedImage objects -- one that you get the Graphics context from and draw text on, and the other that holds the picture obtained via ImageIO, that you don't draw text on. You return the latter, so it makes sense that the picture holds no new text.\n\nSolution: don't do this, create one BufferedImage only, say via ImageIO, get its Graphics context, draw with it, dispose the Graphics when done, and return it.\n\nOther problems with your code is here:\n• You're overriding the wrong painting method. You should override paintComponent, not paint, and in fact your question mentions paintComponent, so I'm not sure why you're doing this.\n• You're overriding a painting method but not calling the super's method, breaking the painting chain.\n• You're doing file I/O unnecessarily repeatedly within a painting method, a method that has the greatest effect on the perceived responsiveness of your GUI, and so something you don't want to do. Read the image in once store it to a variable, use the variable within paintComponent, and never do file I/O within a painting method.\n• You will want to learn and use Java naming conventions. Variable names should all begin with a lower letter while class names with an upper case letter. Learning this and following this will allow us to better understand your code, and would allow you to better understand the code of others."
    },
    {
        "link": "https://stackoverflow.com/questions/29335588/graphics2d-into-bufferedimage",
        "document": "I have found many ways to turn a image into a Graphics2d, but I am not sure how to turn my Graphics2d into a BufferedImage. How would I do this.\n\nNow how would I convert that Graphics into a Buffered Image?"
    },
    {
        "link": "https://github.com/sgoeschl/java-image-processing-survival-guide/blob/master/paper/README.md",
        "document": "This paper provides real-life experience in replacing an ImageMagick/JMagick image conversion & scaling with a pure Java implementation covering Apache PDFBox, Java Advanced Imaging API (JAI), TwelveMonkeys ImageIO plug ins and different Java-based image-scaling libraries.\n\nA day starting with a customer inquiry - \"How difficult is it to replace ImageMagick with a Java image processing library?!\". A few seconds to ponder over the question - Java has graphics support built in, there is the Java Advanced Imaging API around and some image processing shouldn't be too hard after all - \"Well, it depends on your exact requirements but not too difficult\".\n\nLet's have a closer look at the customer's system - it is a classified ads platform allowing their users to create adverts and upload images over the browser or iOS & Android apps as shown below\n\nThe heavy lifting is done by ImageMagick - a native image-processing command-line tool available for most platforms. JMagick exposes ImageMagick's native code over JNI (Java Native Interface) but this approach has a few short-comings\n• Any ImageMagick exceptions escaping through the JNI layer causes the JVM to terminate\n• Installing the ImageMagick binaries for different target platforms requires additional work\n• Getting ImageMagick/JMagick to run on Mac OS failed miserably\n• JMagick is no longer actively developed and does not support all ImageMagick features\n\nOn the other hand ImageMagick is a powerful and field-proven software used by the customer for many years in order to\n• Convert arbitrary image formats such as PNG, TIFF and BMP into JPEG\n• Convert PDF documents to a preview image using GhostScript under the hood\n• Create five thumbnail images with varying resolution based on the user-uploaded image\n• Handle a peak load of 45 image per minute and server (during batch processing)\n\nRegarding the customer inquiry - somehow replacing ImageMagick looks difficult now.\n\nThere are a number of common tasks when working with images\n• Reading a GIF, PNG, JPEG image into a java.awt.image.BufferedImage instance using an ImageReader\n• Apply one or more buffered image operations such as\n• Affine transformation preserving the \"straightness\" and \"parallelness\" of lines, e.g. rotation or scaling\n• Convolution operation, e.g. blurring or sharpening of an image\n• Lookup operation to translate source pixel into destination pixels colors using a lookup table, e.g. inverting the colors\n• Writing the BufferedImage to a GIF, PNG, or JPEG image using an ImageWriter\n\nThe BufferedImage is an accessible buffer of image data, essentially pixels, and their RGB colors. A BufferedImage object is made up of two parts a ColorModel object and a Raster object\n• The ColorModel object provides methods that translate an image's pixel data into color components that can be understood, such as RGB for a computer\n• The Raster represents a rectangular array of pixels. A Raster encapsulates a DataBuffer that stores the sample values and a SampleModel that describes how to locate a given sample value in a DataBuffer. Basically, the Raster holds two things, a DataBuffer, which contains the raw image data and a SampleModel, which describes how the data is organized in the buffer\n\nThe Java 2D API uses an Service Provider Interface (SPI) to utilize image readers & writers provided by extension libraries, e.g. the Java Advanced Imaging (JAI) library provides JPEG2000 and TIFF image readers & writers.\n\nTackling this project requires some \"divide and conquer\" to keep the tasks manageable\n• Use ImageIO to convert various image format to JPEG\n\nNowadays there is a strong focus on beautiful user interfaces - a simple list of file names and icons is not feasible in the Web 2.0 era. Converting a PDF to a list of images is done using Apache PDFBox - an open source Java tool to work with PDF documents. The server-side conversion requires a bit of code since the functionality is implemented as part of the PDFBox command line tools (see http://pdfbox.apache.org/commandline/#pdfToImage). With little effort the functionality was extracted in the Java code snippet shown below\n\nThe heavy lifting of image format conversion is provided by the Java ImageIO API (the javax.imageio package): \"This package contains the basic classes and interfaces for describing the contents of image files, including metadata and thumbnails (IIOImage); for controlling the image reading process (ImageReader, ImageReadParam, and ImageTypeSpecifier) and image writing process (ImageWriter and ImageWriteParam); for performing transcoding between formats (ImageTranscoder), and for reporting errors (IIOException).\" (http://docs.oracle.com/javase/7/docs/api/javax/imageio/package-summary.html#package_description)\n\nIn theory, it could be as simple as:\n\nIn reality it is more complicated\n• Some control is required regarding JPEG metadata and compression options\n• Some graphic formats are not supported out of the box Java ImageIO, e.g. TIFF\n\nThe Java ImageIO library has no TIFF or BMP support - this can be added using Java Advanced Imaging (JAI). Getting JAI installed & running is not as straight-forward as it could be\n• Due to licensing issues the JAI libraries are not available on Maven Central and won't be downloaded automatically during a Maven build\n• The official download links referenced by Maven Central are partly broken\n• The libraries are hard to find because the last release dates back to 10/2006\n\nUnfortunately JAI did not work as expected - the TIFFReader classes were found on the classpath but TIFFs were not automatically processed using ImageIO.read(). While preparing the article the solution was found - there is actually a third JAI library which was somehow missing from the initial setup, the jai_imageio.jar.\n\nThe following JAI libraries are used (and found in the code samples)\n\nIf you have ever wanted to rescale images or create thumbnails you have probably noticed a few things:\n• There seem to be too many ways to scale an image - Image.getScaledInstance(), Graphics.drawImage(), Graphics2D.drawImage(…), BufferImageOps and AffineTransforms\n• There's always a trade between speed and image quality implemented by different image scaling algorithm - Bicubic Interpolation, Bilinear interpolation, Nearest Neighbor Interpolation or Lanczos Resampling\n\nWhich one are you supposed to use? Which one performs the fastest? Which one scales and uses the least amount of memory? When searching the Internet you find a plethora of image scaling libraries - in order to make an informed decision a test driver was implemented to convert a fixed set of test images using the following libraries\n\nThe good news are that all of them work and show comparable performance so the decision comes down to image quality and additional features. At the end \"thumbnailator\" was chosen due to its watermark support - this feature is not immediately needed but it is good to know that watermarking can be added using two lines of code (see https://code.google.com/p/thumbnailator/wiki/Examples#Creating_a_thumbnail_with_a_watermark).\n\nThe CPU time needed for scaling depends mostly on the size of the source image and using a naive implementation could use the original image to create the five scaled down instances. Consequently the production code uses an already scaled image to create the next smaller image which has a dramatic impact on performance as shown below\n\nA common requirement for writing JPEGs is setting the compression options and/or DPIs this can be done with the code snippet shown below\n\nLooking at the code snippets raises a few concerns\n• A fair amount of knowledge is required to accomplish a simple tasks\n• The code is prone to NPEs when the JPEG metadata is not available\n\nWhen the overall implementation was mostly finished a few hundred production and a set of custom test images were used for a more thorough testing and the results were - well - interesting. A couple of images were either not converted at all or the resulting images were severely broken - in other words the current implementation was not ready for production\n\nThe following problems were identified:\n\nAn alpha channel stores transparency information and is used for the GIF and PNG image format on web pages so that images appear to have an arbitrary shape even on a non-uniform background. The alpha-channel handling is non-intuitive when loading transparent GIFs/PNGs and saving them to a JPEG because the colors are messed up - either all black or having a red tint as shown below\n\nThis problem is caused by ImageIO using a mismatched color model when writing the JPEG image (e.g. BufferedImage.TYPE_4BYTE_ABGR) and can be avoided by converting the color model to BufferedImage.TYPE_RGB type relying on Graphics2D.drawImage.\n\nPlease note that this problem might also occur when applying an AffineTransformOp since this results in a BufferedImage having a BufferedImage.TYPE_ARGB type [1].\n\nDuring image scaling the uploaded image is read and a BufferedImage instance is created containing the rastered and un-compressed pixels. In other words the memory foot-print can be 10-20 times larger than the compressed source image which makes the operations team uneasy - a huge source image could cause excessive memory consumption which in turn can be used for a \"Denial Of Service Attack\". And developers hate it to be considered as the root cause for an successful DOS attack - dutifully the original image conversion source code contained the following sanity check to avoid memory problems\n\nThe memory foot-print mostly depends on the image dimension - the file size of an uploaded image is misleading when compression is used. This observation leads directly to notion of \"decompression bomb vulnerabilities\" as described at http://www.aerasec.de/security/advisories/decompression-bomb-vulnerability.html. A hand-crafted unicolor PNG image containing 19.000 x 19.000 pixels uses only 44 KB of disk but potentially up to 1 GB of main memory - ooups.\n\nIn order to avoid such attacks the image metadata of the uploaded image file are retrieved - this is a fast operation which does not require to load the whole image file. The only thing missing are sensible limits regarding image size\n\nIt was decided to use 45 mega-pixels as upper limit but this is actually a solution for the wrong problem. Instead of worrying about the dimension of uploaded images it is much smarter to scale the image on the front-end before uploading to the server conserving bandwidth and server memory.\n\nThe CMYK color model is a subtractive color model used in color printing whereas most user-generated image uses the RGB additive color model. CMYK color space support is somewhat limited in Java, and there is no built-in CMYK color space, like it has for RGB. The main reason for this is that there is no standard CMYK color space. Unlike RGB that has standardized color profiles, like sRGB and AdobeRGB1998. CMYK color profiles originates from printer manufacturers and the printed press. Manufacturers and organizations have their own standardized profiles.\n\nGoogle for CMYK to RGB will come up with various mathematical formulas. Typically something like this (from http://www.rapidtables.com/convert/color/cmyk-to-rgb.htm):\n\nThe R,G,B values are given in the range of 0..255. The red (R) color is calculated from the cyan (C) and black (K) colors:\n\nThe green color (G) is calculated from the magenta (M) and black (K) colors:\n\nThe blue color (B) is calculated from the yellow (Y) and black (K) colors:\n\nThis formula \"works\", as in that it will produce an RGB image. But unfortunately, this rather naive implementation does not provide good results, because the color spaces have nonlinear response curves and different gamut.\n\nSo, the best way to satisfy demanding users, is to use a proper ICC color profile, and ICC color transform. This approach usually involves converting the CMYK values into a device independent color space (like Lab or CIEXyz), and then from the independent space to the destination color space (RGB). This will produce much better results.\n\nLuckily, most image files that use CMYK color space does have an embedded ICC profile, and when converting we should always use this profile. If there is no embedded ICC profile, we can look for a platform specific \"generic CMYK\" profile. \"Web coated SWOP\" or similar might also do in lack of a better alternative. And only fall back to the mathematical formula above as a worst case. [This is the \"algorithm\" used by TwelveMonkeys, anyway... :-)]\n\nTo complicate things slightly in Java land: The default ImageIO JPEGImageReader will not read CMYK images. The most common workaround for now, is to read the image as raster, then convert the YCCK to CMYK, before finally converting to RGB using ICC profile and then creating a BufferedImage from the resulting raster.\n\nConverting CMYK to RGB color space seemed non-trivial to implement considering that the release date was around the . A stackoverflow entry mentioned a \"TwelveMonekys\" library (see http://stackoverflow.com/questions/2408613/problem-reading-jpeg-image-using-imageio-readfile-file) which lead to a Github repository. The Twelvemonkeys libraries turned out to be a collection of plug-ins using the ImageIO's SPI mechanism - in other words a drop-in replacement for JAI. Running the regression test suite showed that CMYK color space was properly handled and - even more important - no new issues were introduced.\n\nThe Twelvemonkeys ImageIO was started when Harald was working for a Web CMS (Content Management System) vendor, that created CMS solutions targeted for the media industry (newspapers, broadcast). It's a web-centric CMS, and the initial version was created, because their web content management system needed support for more image formats.\n• Java (prior to J2SE 1.4) had only limited support for reading JPEG, PNG and GIF\n• And more importantly, no official API for writing images existed.\n• The APIs that existed was based around the java.awt.Image class, and not the more versatile BufferedImage class.\n• JMagick had support for many formats, but had no stream support, which is very bad when working with web architectures. Temporary writing to disk increases the response time, and slows down overall performance. Plus the lack of binary compatibility from version to version and being a nightmare to install.\n• JAI was around, but at the time reading & writing images using JAI required a different API.\n• None of the libraries had proper support for PSD format (JMagick didn't support reading individual layers)\n• The initial version had a simple read/write API, that dealt with BufferedImages.\n\nNowadays, the world is a little different, thus the goals have changed:\n• ImageIO (javax.imageio package) has become the standard API to read/write images in Java.\n• Thus the goal has been to help the Java platform read as many formats, as complete as possible, using the ImageIO API.\n• JAI ImageIO has rich support for formats:\n• However, it has bugs, and when you hit them: No-one listens. Seems to have no support from Oracle.\n• No official updates for the last years (last release was 2006)\n• Dying community for the same reasons\n• Requires native libraries for full format support/best performance. Which means more difficult installation. And worse, no native libraries exist for many modern popular architectures (ie, 64 bit architectures)\n• Some parts seems to be open source, some parts not (like the native code)\n• Multiple, semi-overlapping forks (GitHub, Google code, private) with the same + its own license issues, making matters worse...\n• That said, if you can deal with the license, and don't run into the bugs mentioned, JAI is still the most complete and mature packages for dealing with images in Java.\n• JMagick hasn't changed much. TwelveMonkeys has wrapper readers/writers to allow users to use ImageMagicks rich format support, while using the ImageIO API. However, due to the nature of the library, it will never have the same performance or rich features.\n• Apache Commons Imaging has emerged from Sanselan. A quite mature library, but unfortunately has its own API. Combined with the the fact that it doesn't support all the same formats as ImageIO, this means you either have to program against multiple APIs, create your own wrappers or even your own abstraction API on top of these multiple APIs.\n\nWe need something better! We deserver better. :-)\n• Just released (development/pre-release versions has been in use at customer sites for 2-3 years)\n• Very much improved JPEG (read) support (CMYK handling, improved color profile handling, JFIF and EXIF support) over the standard JPEGImageReader that comes with the (Oracle) JRE. Solves most of the issues that usually crops up at StackOverflow\n• Full TIFF baseline support + most de facto standards + many popular extensions (read-only for now)\n• Support for CMYK color space and proper ICC profile based CMYK to RGB conversion support throughout the project\n\nThe goal is to read everything that can be read by other software - currently not doing too bad - however\n• However, because the base JPEG decoding is done by the same JNI code that the standard Java JPEGImageReader uses, we \"only\" support Huffman encoded, lossy JPEG, either baseline or progressive (ie, no Arithmetic encoding, no lossless compression). These are the compressions used in roughly 90% of all JPEGs in the known universe, and most web browsers supports only these types of JPEG compression as well, so in a web environment it is not much of a problem.\n• Other software here, typically means libJPEG, but also Adobe Photoshop and others.\n\nAnother customer required a very similiar functionality mostly processing PDFs containing image scans. The code base was used for a couple of months by two customers each processing million of images but unsurprisingly real life is harsh on your code and exposes dormant issues. After 6 months in production the following problems were encountered\n\nWhen uploading an image file the file name and content type of the uploaded image is passed to the server and is stored on the server's local file system. The existing code base ignored the content type and only used the file name extension to determine if the image format is supported. That's fine if all your clients use proper file names but failed sometimes for Android apps sending \"image.bin\". In general there are three bits of information to determine the content type of an uploaded image\n• File names are brittle since they may end with \".bin\" or have no extension at all\n• Content types are a better choice but sometimes ambiguous, e.g. PDF files might be uploaded with content types of \"application/pdf\", \"text/plain\" or \"application/octet-stream\"\n• The content of the uploaded images can be analyzed to determine it content name using so-called \"magic\" byte sequence which is known as \"media type sniffing\" or \"content detection\".\n\nOut of the blue three production server went down due to a JRE crash as shown below\n\nSomething very similiar to an image decompression bomb had happened - a PDF containing a scan with 10200 x 13992 pixels bombed the JVM. The native code used by Java ImageIO fails to transform the image, the JRE crashes, the end-user is unhappy since the PDF upload failed multiple times (the error message saying \"The image upload failed - please try again\" did not work in our favour) and the operation team has a bad day.\n\nAgain an image size sanity check was added using the code snippet shown below which determines the size of embedded images.\n\nSharpening of an image is a simple convolution operation as shown below and therefore re-used for all sharpening operatins\n\nAfter some time customers started complaining about black borders around their uploaded & scaled images and initially Siegfried believed that the black border was caused by the image scaling library. Strangely enough the problem did not disappear when testing with a different library. The following link ([http://www.informit.com/articles/article.aspx?p=1013851&seqNum=5|http://www.informit.com/articles/article.aspx?p=1013851&seqNum=5]) shed some light on the problem\n• Convolution takes the neighbours as defined in the kernel matrix, e.g. the point in question and its eight neighbours\n• Points located at the borders have not enough neighbours\n• Java 2D uses a black pixel which naturally causes a black border around the sharpened image\n\nThis behaviour can be changed by using an additional paramter ConvolveOp.EDGE_NO_OP\n\nA real-estate agent complained that its pictures are of a very poor quality and the complaint was justified as shown below\n\nPDF is as flexible as TIFF and allows to add a wide variety of images. One PDF document contained a JBIG2 image which as converted to list if images using PDFBox. PDFBox relies on ImageIO and could not find a matching ImageIO plugin to convert the source image into a JPEG. So it complained loudly but tried to return a JPEG nevertheless.\n\nThis behavior is unfortunate since the caller has no way to throw an exception causing customer complaints and follow-up work.\n\nMany images of the customer's site are user-uploaded photos of real estate adverts. They often have a poor quality\n• Photos taken from inside an appartment often show a bright windowleaving the remaining image under-exposed\n• Photos taken from a house during bright daylight leaves the house under-exposed\n\nContrary to popular belief, JPEG is not a file format - it is a standardized image compression scheme. When someone says \"JPEG file\" most people refer to one of two main file formats that uses JPEG compression:\n• JFIF (JPEG Interchange File Format), the original format described by the Joint Photographic Experts Group (JPEG)\n\nStrictly, these are incompatible, as both standard specifies that their APP marker must be the first APP marker in the file. But most software happily reads either as a \"JPEG\" as they conform to the structure defined in JIF (JPEG Interchange Format).\n\nLarge software vendors (like one that starts with a capital 'A') have their own extensions, like CMYK-encoded JPEGs and many encoders also like to put Exif metadata inside an otherwise conforming JFIF file.\n\nThe standard Java JPEGImageReader on the other hand isn't always that happy with these extensions, so you might see exceptions like:\n\nJava has no good support for lossless JPEG (known as \"JPEG Lossless\") nor has it any good suport for or JPEG LS, but that is a completely different (!) compression scheme.\n\nAlso missing is support for \"Arithmetic coding\" (as opposed to the default \"Huffman coding\").\n\n(and combinations of the above).\n\nArithmetic coding yield a slightly better compression ratio (5-7% accoring to Wikipedia) than Huffman coding, but is far less widespread, probably due to licensing issues and also being more CPU-intensive for encoders/decoders.\n\nTrying to decode a JPEG Lossless using the default Java JPEGImageReader results in an exception, stating:\n\nTIFF stands mainly for \"Thousands of Incompatible File Formats\" wheras Wikipdia also mentions \"Tagged Image File Format\". TIFF was originally developed by Aldus, now owned by Adobe, and is not specified by an ISO or any other standards comitee. So TIFF mainly consists of TIFF 6.0 by Adobe plus some extra ammendments.\n\nThe key strength of TIFF - its flexibility based on header tags - is also it's greatest weakness (assuming that you have to process it)\n\nA TIFF can store the following image types\n\nIn addition TIFF supports the storage of\n• Multiple versions (sizes) of the same image (pyramidal TIFF)\n• In unsigned integer format using 1, 2, 4, 8, 16 or 32 bits per pixel\n\nTIFF supports the following compression formats in addition to uncompressed data\n• LZW (with or without prediction)\n• Deflate/Zip (with or without prediction)\n• the list goes on and on\n\nIt's virtually practically impossible to support all possible combinations of TIFF therefore the term Baseline TIFF was born. Baseline TIFF define a specific subset for specific needs such as\n• TIFF is also the basis of Exif, used in digital camera formats (JPEGs)\n\nInterestingly TIFF also has some limitations stemming from its age\n• Internal file lengths and offsets are recorded as 32 bit unsigned integers\n• BigTIFF proposal that removes this limitation, has been \"in progress\" for years, still no formal/approved specification.\n\nAs mentioned above, converting between color spaces, usually involves ICC color profiles and color transforms. Luckily for us, ICC profiles and conversion has good support in Java, although the functionality is somewhat hidden.\n\nThe Java class ColorSpace is used to represent color spaces in Java. It has a subclass, ICC_ColorSpace for color spaces based on ICC profiles, and a corresponding ICC_Profile class to represent the profile itself.\n\nColor conversion between color spaces and color profiles is handled by the ColorConvertOp. On most platforms, this class delegates to native code to do the actual transformation, making it very fast and efficient. In most cases, magnitudes faster than naive conversion implemented in Java.\n\nUnfortunately, certain profiles contains issues that causes crashes or exceptions in Java:\n• Why does loading this jpg using JavaIO give CMMException?\n\nThese profiles/issues must be recognized and dealt with before they are instantiated and passed to the ColorConvertOp filter.\n\nIn addition, Java 8 creates some new issues, as Oracle has been replacing the rather aging KCMS (developed by Kodak) with Little CMS (LCMS). The upside with the switch to LCMS though, is a more compatible, better maintained and robust CMM system. However, the short-term downside is that current benchmarks shows it is slower, and it's not 100% compatible with KCMS [as shown by various bugs, like haraldk/TwelveMonkeys#41].\n\nFortunately previous behavior can be restored for now, using a special switch:\n\nIt's probably a good idea to do so, until libraries and frameworks have been updated to work fully with LCMS or inconsistencies has been worked out. Will have to fix the library at some point.\n\nNote that loading Custom ColorSpaces will eat memory. When loading many images at once reusing ICC profiles is a good idea. Many images contains embedded standard profiles, that will already be loaded by the JVM. But, be aware! ICC_Profile objects are mutable. It's therefore important to use these mutation operations with care, and make sure you either work on a non-shared instance or create a local copy before making changes.\n\nThe ImageIO DOM-based metadata is hard to work with.\n\nOften, this is not the metadata you want. Humans typically wants Exif or IPCT metadata, containing copyright, date, photographer etc.\n\nServlet Filter based. Reads the image from source, writes the scaled version directly to the response stream (alternatively through a cache).\n• Saves up-front work that may slow down workflow\n• Needs more resources for the (first) request\n\nTwelveMonkeys comes with a set of chainable filters that allows different conversions and effects to be applied to images \"on-the-fly\".\n• Color conversion or effects (like grayscale, vintage/lomo look etc)\n• Format conversion (any format to web format like JPEG or PNG)"
    }
]