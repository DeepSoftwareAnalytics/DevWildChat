[
    {
        "link": "https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-working-with.websockets.html",
        "document": "Amazon CloudFront supports using WebSocket, a TCP-based protocol that is useful when you need long-lived bidirectional connections between clients and servers. A persistent connection is often a requirement with real-time applications. The scenarios in which you might use WebSockets include social chat platforms, online collaboration workspaces, multi-player gaming, and services that provide real-time data feeds like financial trading platforms. Data over a WebSocket connection can flow in both directions for full-duplex communication.\n\nWebSocket functionality is automatically enabled to work with any distribution. To use WebSockets, configure one of the following in the cache behavior that's attached to your distribution:\n\nThe WebSocket protocol is an independent, TCP-based protocol that allows you to avoid some of the overhead—and potentially increased latency—of HTTP.\n\nTo establish a WebSocket connection, the client sends a regular HTTP request that uses HTTP's upgrade semantics to change the protocol. The server can then complete the handshake. The WebSocket connection remains open and either the client or server can send data frames to each other without having to establish new connections each time.\n\nBy default, the WebSocket protocol uses port 80 for regular WebSocket connections and port 443 for WebSocket connections over TLS/SSL. The options that you choose for your CloudFront Viewer protocol policy and Protocol (custom origins only) apply to WebSocket connections as well as to HTTP traffic.\n\nWebSocket requests must comply with RFC 6455 in the following standard formats.\n\nIf the WebSocket connection is disconnected by the client or server, or by a network disruption, client applications are expected to re-initiate the connection with the server.\n\nTo avoid unexpected compression-related issues when using WebSockets, we recommend that you include the following headers in an origin request policy:"
    },
    {
        "link": "https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/GettingStarted.html",
        "document": "The topics in this section show you how to get started delivering your content with Amazon CloudFront.\n\nThe Set up your AWS account topic describes prerequisites for the following tutorials, such as creating an AWS account and creating a user with administrative access.\n\nThe basic distribution tutorial shows you how to set up origin access control (OAC) to send authenticated requests to an Amazon S3 origin.\n\nThe secure static website tutorial shows you how to create a secure static website for your domain name using OAC with an Amazon S3 origin. The tutorial uses an Amazon CloudFront (CloudFront) template for configuration and deployment."
    },
    {
        "link": "https://stackoverflow.com/questions/41330611/how-to-enable-websockets-on-aws-cloudfront",
        "document": "I have an Akka HTTP server running on AWS EC2 Autoscale cluster. This EC2 auto scale cluster has an ELB Application Load balancer in front. In addition to the ELB, we have a cloud front distribution that is set to serve static files.\n\nWe're facing an issue where all the websocket connection requests from browsers to the backend fail with error.\n\nUpon further investigation, we found that the clients are able to connect directly to the load balancer but any connection request via cloudfront fail. Eventually I came across this page on AWS Cloudfront documentation which says that cloudfront strips out any 'upgrade' headers which might be the reason clients are unable to connect.\n\nTo work around this issue, I enabled all \"header forwarding\" option (which disables caching), but it still didn't work. Moreover, I couldn't find any option to selective disable cloudfront caching or bypass cloudfront altogether for certain URLs.\n\nHow do I workaround this issue and ensure that websockets work through cloudfront? Or is this just not supported?"
    },
    {
        "link": "https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Introduction.html",
        "document": "Amazon CloudFront is a web service that speeds up distribution of your static and dynamic web content, such as .html, .css, .js, and image files, to your users. CloudFront delivers your content through a worldwide network of data centers called edge locations. When a user requests content that you're serving with CloudFront, the request is routed to the edge location that provides the lowest latency (time delay), so that content is delivered with the best possible performance.\n\nAs an example, suppose that you're serving an image from a traditional web server, not from CloudFront. For example, you might serve an image, sunsetphoto.png, using the URL .\n\nYour users can easily navigate to this URL and see the image. But they probably don't know that their request is routed from one network to another—through the complex collection of interconnected networks that comprise the internet—until the image is found.\n\nCloudFront speeds up the distribution of your content by routing each user request through the AWS backbone network to the edge location that can best serve your content. Typically, this is a CloudFront edge server that provides the fastest delivery to the viewer. Using the AWS network dramatically reduces the number of networks that your users' requests must pass through, which improves performance. Users get lower latency—the time it takes to load the first byte of the file—and higher data transfer rates.\n\nYou also get increased reliability and availability because copies of your files (also known as objects) are now held (or cached) in multiple edge locations around the world.\n\nHow you set up CloudFront to deliver content\n\nYou create a CloudFront distribution to tell CloudFront where you want content to be delivered from, and the details about how to track and manage content delivery. Then CloudFront uses computers—edge servers—that are close to your viewers to deliver that content quickly when someone wants to see it or use it.\n\nHow you configure CloudFront to deliver your content\n• You specify origin servers, like an Amazon S3 bucket or your own HTTP server, from which CloudFront gets your files which will then be distributed from CloudFront edge locations all over the world. An origin server stores the original, definitive version of your objects. If you're serving content over HTTP, your origin server is either an Amazon S3 bucket or an HTTP server, such as a web server. Your HTTP server can run on an Amazon Elastic Compute Cloud (Amazon EC2) instance or on a server that you manage; these servers are also known as custom origins.\n• You upload your files to your origin servers. Your files, also known as objects, typically include web pages, images, and media files, but can be anything that can be served over HTTP. If you're using an Amazon S3 bucket as an origin server, you can make the objects in your bucket publicly readable, so that anyone who knows the CloudFront URLs for your objects can access them. You also have the option of keeping objects private and controlling who accesses them. See Serve private content with signed URLs and signed cookies.\n• You create a CloudFront distribution, which tells CloudFront which origin servers to get your files from when users request the files through your web site or application. At the same time, you specify details such as whether you want CloudFront to log all requests and whether you want the distribution to be enabled as soon as it's created.\n• CloudFront assigns a domain name to your new distribution that you can see in the CloudFront console, or that is returned in the response to a programmatic request, for example, an API request. If you like, you can add an alternate domain name to use instead.\n• CloudFront sends your distribution's configuration (but not your content) to all of its edge locations or points of presence (POPs)— collections of servers in geographically-dispersed data centers where CloudFront caches copies of your files.\n\nAs you develop your website or application, you use the domain name that CloudFront provides for your URLs. For example, if CloudFront returns as the domain name for your distribution, the URL for logo.jpg in your Amazon S3 bucket (or in the root directory on an HTTP server) is .\n\nOr you can set up CloudFront to use your own domain name with your distribution. In that case, the URL might be .\n\nOptionally, you can configure your origin server to add headers to the files, to indicate how long you want the files to stay in the cache in CloudFront edge locations. By default, each file stays in an edge location for 24 hours before it expires. The minimum expiration time is 0 seconds; there isn't a maximum expiration time. For more information, see Manage how long content stays in the cache (expiration).\n\nCloudFront charges for data transfers out from its edge locations, along with HTTP or HTTPS requests. Pricing varies by usage type, geographical region, and feature selection.\n\nThe data transfer from your origin to CloudFront is always free when using AWS origins like Amazon Simple Storage Service (Amazon S3), Elastic Load Balancing, or Amazon API Gateway. You are only billed for the outbound data transfer from CloudFront to the viewer when using AWS origins.\n\nFor more information, see CloudFront pricing and the Billing and Savings Bundle FAQs .\n\nUse the following resources to get answers to technical questions about CloudFront:"
    },
    {
        "link": "https://repost.aws/questions/QUBiPTpSliSKuFJyoHa95jFg/socket-connection-cloudfront-apigateway",
        "document": "I'm using API Gateway with CloudFront. Since I configured my WebSocket domain \"chat.blabla.com\" under API Gateway, I can't establish the WebSocket connection anymore. The connection keeps retrying every second and returns a 200 status.\n\nI set the API Gateway as the origin in my CloudFront distribution and configured the behavior with HTTPS and header policy as described here: https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-working-with.websockets.html\n\nDoes anyone have any idea why I'm facing this issue?\n\nThanks for your help."
    },
    {
        "link": "https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/distribution-working-with.websockets.html",
        "document": "Amazon CloudFront supports using WebSocket, a TCP-based protocol that is useful when you need long-lived bidirectional connections between clients and servers. A persistent connection is often a requirement with real-time applications. The scenarios in which you might use WebSockets include social chat platforms, online collaboration workspaces, multi-player gaming, and services that provide real-time data feeds like financial trading platforms. Data over a WebSocket connection can flow in both directions for full-duplex communication.\n\nWebSocket functionality is automatically enabled to work with any distribution. To use WebSockets, configure one of the following in the cache behavior that's attached to your distribution:\n\nThe WebSocket protocol is an independent, TCP-based protocol that allows you to avoid some of the overhead—and potentially increased latency—of HTTP.\n\nTo establish a WebSocket connection, the client sends a regular HTTP request that uses HTTP's upgrade semantics to change the protocol. The server can then complete the handshake. The WebSocket connection remains open and either the client or server can send data frames to each other without having to establish new connections each time.\n\nBy default, the WebSocket protocol uses port 80 for regular WebSocket connections and port 443 for WebSocket connections over TLS/SSL. The options that you choose for your CloudFront Viewer protocol policy and Protocol (custom origins only) apply to WebSocket connections as well as to HTTP traffic.\n\nWebSocket requests must comply with RFC 6455 in the following standard formats.\n\nIf the WebSocket connection is disconnected by the client or server, or by a network disruption, client applications are expected to re-initiate the connection with the server.\n\nTo avoid unexpected compression-related issues when using WebSockets, we recommend that you include the following headers in an origin request policy:"
    },
    {
        "link": "https://medium.com/skillwell/setting-up-real-time-communication-with-websockets-using-aws-api-gateway-v2-and-amazon-cloudfront-c258078db9dd",
        "document": "In association with our collaboration with JAMK University of Applied Sciences, our team offers mentorship to students undertaking thesis projects. Among the diverse topics this spring, one thesis is dedicated to exploring the integration of WebSocket communication with Flux architecture within web applications. To support this particular study, it became necessary to implement AWS API Gateway v2 for WebSocket communication as the backend infrastructure. To go beyond basic requirements and create a more practical learning environment, we implemented a setup with also CloudFront and Cognito. This blog post describes our approach to developing an effective WebSocket communication system.\n\nLet’s start by highlighting the AWS services that collectively serve as the foundation of our solution. We chose a suite of AWS services beyond just AWS API Gateway v2 to craft a secure, scalable, and production-ready architecture.\n\nOur WebSocket communication system leverages a suite of AWS services, each contributing to a robust and scalable architecture:\n• AWS API Gateway v2 is a fully managed service that simplifies the process of creating, publishing, maintaining, monitoring, and securing both HTTP and WebSocket APIs at any scale.\n• Amazon Cognito User Pool reinforces our solution security by managing user authentication and access control through Cognito JWT authorizer in API Gateway for HTTP connections. For WebSocket connections, where direct integration with Cognito is not available, we architected a custom authentication mechanism within a Lambda function.\n• AWS Lambda functions serve as a powerful companion to AWS API Gateway v2, executing code in response to events like WebSocket messages and HTTP requests. This integration enables developers to efficiently handle real-time and standard web interactions without server management, facilitating the creation of responsive and scalable applications.\n• Amazon DynamoDB enhances our solution by offering a fully managed NoSQL database service, ideal for storing WebSocket connection information and application data.\n• Amazon CloudFront enhances our architecture by allowing a single custom domain name for both HTTP and WebSocket APIs via AWS API Gateway v2. Acting as a front-facing layer, CloudFront routes traffic to the correct API type, streamlining domain management while accelerating content delivery globally. It also simplifies SSL/TLS certificate management and bolsters security, enabling efficient and secure handling of diverse web traffic under one unified domain.\n• Amazon Certificate Manager secures our application by managing SSL/TLS certificates for our CloudFront distribution, automating the encryption process for our custom domain. Its seamless integration ensures continuous protection and hassle-free renewals.\n\nTo simplify setting up AWS architectures, we mainly use CloudFormation. This tool helps us automatically set up and manage our AWS services by using code to define the infrastructure. With CloudFormation, we can easily create, duplicate, and manage our system’s setup, making it perfect for quickly deploying the AWS resources.\n\nBefore setting up our AWS resources with CloudFormation, we needed to take two important steps in the AWS Console.\n• First, we set up a hosted zone in Amazon Route 53 for our domain. This lets us control our domain’s DNS records.\n• Next, we needed to request an SSL/TLS certificate through AWS Certificate Manager, crucial for data encryption. Because we’re using Amazon CloudFront, we had to get this certificate in the US East (N. Virginia) region, which is a requirement for CloudFront custom domains.\n\nThese steps are standard procedures and part of common AWS knowledge, so I won’t go into further detail about them in this blog post.\n\nOur API Gateways, acting as origin points for the CloudFront distribution, needed to be established first. We chose to initially define the core structure of the API Gateways using CloudFormation to set up the fundamental components. More detailed configurations were defined later using Serverless Application Model (SAM) templates. This is our normal approach and it allows us to methodically expand and refine the API Gateways.\n\nHere are the CloudFormation resource definitions for the HTTP and WebSocket API Gateways:\n\nPlease note how similar the definitions of HTTP and WebSocket API Gateways are. And despite WebSocket communication starting with an HTTP request that upgrades to a WebSocket connection, a single AWS API Gateway instance cannot function as both an HTTP and WebSocket API.\n\nSetting Up CloudFront Distribution and Route 53 RecordSet with CloudFormation\n\nFollowing the setup of the API Gateways, we crafted a CloudFormation template for configuring the CloudFront distribution and associated DNS record.\n\nHere’s the CloudFormation template that we used:\n\nThe key highlights of this template include:\n• We configured it to forward all headers except Host to both HTTP and WebSocket APIs, utilizing a custom origin request policy for this purpose.\n• We applied the cache policy ID 4135ea2d-6df8–44a3–9df3–4b5a84be39ad, a managed policy designed to disable caching, ensuring that requests to both API types are not stored in cache.\n• A default cache behavior is required for CloudFront distributions. Our default cache behavior returns web application that is served from S3 bucket.\n• The CloudFront distribution routes traffic based on request paths: /http/ prefixes direct to the HTTP API, while /ws/ prefixes route to the WebSocket API.\n• Lastly, we configured our chosen domain name to serve as an alias for the CloudFront distribution, facilitating domain-based access to the distributed content.\n\nTo secure our HTTP API and manage user authentication efficiently, we integrated Amazon Cognito into our architecture. Specifically, we defined very basic versions of Cognito User Pool and User Pool Client with the following CloudFormation template:\n\nFor full-scale production, we usually add more specific user details, set strong password rules, and use custom Lambda triggers for extra features. But for this case we wanted to have the simplest possible setup. We also used a pre-signup lambda function to automatically confirm all users, avoiding the need of email or phone number verification.\n\nTo manage WebSocket connections efficiently, we set up a DynamoDB table tailored for tracking active connections and supporting real-time communication. DynamoDB’s capability to scale and its high-performance nature suit the dynamic requirements of WebSocket connections perfectly, ensuring rapid reads and writes.\n\nThis is the CloudFormation template that we used for the connections table:\n\nThe main features of this template are:\n• A single user can maintain multiple concurrent connections, one for each active session.\n• Through a global secondary index, the table allows for querying data by connection ID.\n• A Time to Live (TTL) setting is configured to automatically purge data, maintaining table efficiency and relevance.\n\nTo define the business logic of the HTTP API, we deployed an AWS Lambda function, integrating it with API Gateway via AWS CloudFormation and the Serverless Application Model (SAM). In our approach, we specifically utilized SAM for the Lambda function definition due to its streamlined deployment capabilities.\n\nSAM’s package and deploy commands significantly simplify the deployment process, automating the manual steps typically required to deploy a Lambda function. This focused use of SAM, combined with CloudFormation for other needed resources, offered a balanced and effective strategy for managing our serverless application deployment.\n\nBelow is the template we used for deploying the lambda function and integrating it with the HTTP API Gateway.\n\nThe main features of this template are:\n• IAM Role for Lambda: Essential for granting execution permissions to the Lambda function, including logging and accessing other AWS services like DynamoDB. Please note that the policies that grant access to DynamoDB and other AWS resources are omitted for simplicity.\n• Lambda Function Configuration: Describes the setup for the serverless function, including its code, runtime environment, and operational parameters like memory and timeout settings. Environment variables are used to tailor the function’s behavior for different deployment stages.\n• API Gateway Integration: This component connects the Lambda function to the API Gateway, ensuring smooth request forwarding and responses. It’s key for making the function accessible online as an API, leveraging proxy integration to enable straightforward communication.\n• JWT Authorization: Establishes security for the API by integrating JWT-based user authentication, leveraging a user pool for token validation. This layer of security ensures that only authenticated requests can access the API, protecting it from unauthorized use.\n• Route Configuration: Establishes how API requests are directed to the Lambda function, creating a structured flow for handling incoming traffic.\n• Invocation Permission: Grants the API Gateway authority to trigger the Lambda function.\n\nWhile we typically employ a single Lambda function to handle all routes of an HTTP API through a proxy-type deployment, our approach with WebSocket APIs differs. For WebSocket functionality, we designate individual Lambda functions for various purposes within the WebSocket API.\n\nIn the structure of WebSocket APIs utilizing AWS API Gateway v2, three indispensable routes form the core framework for managing and facilitating connections effectively:\n• $connect route: Initiated with an HTTP request, this route is the first point of contact for clients attempting to establish a WebSocket connection.\n• $disconnect route: Triggered when a WebSocket connection comes to an end, this route is essential for performing clean-up operations and managing resources.\n• $default route: Acts as a catch-all for any messages sent over the WebSocket that do not correspond to other predefined routes.\n\nBeyond the three mandatory routes, we define an extra additional route specifically designed for ping/pong communication, which is initiated by the clients. Since CloudFront has a maximum idle connection timeout as low as 60 seconds, this heartbeat mechanism is important for keeping the WebSocket connection alive. Please note that while WebSocket API Gateway has a 10 minutes idle connection timeout, CloudFront has only maximum of 1 minute.\n\nThe deployment and configuration of these routes are efficiently managed through the Serverless Application Model (SAM) and AWS CloudFormation, similarly to HTTP API.\n\nBelow is the template we used for deploying the lambda functions and integrating those with the WebSocket API Gateway.\n\nThe main features of this template are:\n• Lambda functions are deployed for the needed WebSocket events ($connect, $disconnect, $default, ping), each with specific roles and integrated securely with API Gateway.\n• For WebSocket APIs, directly using JWT as the authorizer type is not supported. However, similar levels of security can be achieved by employing a custom Lambda authorizer to validate the JWT. I’ll write more of that in my follow-up blog post.\n\nThis blog post has focused primarily on setting up the foundational AWS resources necessary for enabling real-time communication through WebSockets using AWS API Gateway v2, alongside Amazon CloudFront.\n\nThe emphasis has been on the infrastructure setup — leveraging CloudFormation and the Serverless Application Model (SAM) for a streamlined deployment process. This groundwork lays the foundation for developing responsive and scalable applications, capable of handling real-time communication with ease.\n\nLooking ahead, a subsequent blog post will delve into the Lambda functions’ logic as well as details and noticeable caveats to take into account. Thank you for reading, and stay tuned for more in-depth articles on leveraging AWS services for your SaaS solutions."
    },
    {
        "link": "https://stackoverflow.com/questions/71105105/cloudfront-with-websocket-connection",
        "document": "The answer to my problem was a simple change to the Cloudfront Distribution.These headers needed be added so that my server (using express/express-ws) would receive the http request with the correct headers to validate the session and return with the upgraded protocol response for the client. (This was out of the box with express-ws and rxjs). I can post a coded example if needed."
    },
    {
        "link": "https://stackoverflow.com/questions/41330611/how-to-enable-websockets-on-aws-cloudfront",
        "document": "I have an Akka HTTP server running on AWS EC2 Autoscale cluster. This EC2 auto scale cluster has an ELB Application Load balancer in front. In addition to the ELB, we have a cloud front distribution that is set to serve static files.\n\nWe're facing an issue where all the websocket connection requests from browsers to the backend fail with error.\n\nUpon further investigation, we found that the clients are able to connect directly to the load balancer but any connection request via cloudfront fail. Eventually I came across this page on AWS Cloudfront documentation which says that cloudfront strips out any 'upgrade' headers which might be the reason clients are unable to connect.\n\nTo work around this issue, I enabled all \"header forwarding\" option (which disables caching), but it still didn't work. Moreover, I couldn't find any option to selective disable cloudfront caching or bypass cloudfront altogether for certain URLs.\n\nHow do I workaround this issue and ensure that websockets work through cloudfront? Or is this just not supported?"
    },
    {
        "link": "https://nickzamosenchuk.medium.com/configure-amazon-cloudfront-cdn-for-websocket-connection-43c44b3f877c",
        "document": "Whether you need IPv6 support for your API Gateway API, want to have more points of presence and utilise Amazon’s backbone network as much as possible, or want to transform the requests with Lambda@Edge — Amazon CloudFront CDN in front of API Gateway is your buddy.\n\nCloudFront also support WebSocket connections and becomes a handy tool with Lambda@Edge for solve the limitations of API Gateway with WebSocket endpoint, specifically the lack of path support. However, there are few things to configure before CloudFront can properly handle WebSocket connections.\n\nThe first a cache should be disabled completely, the second an origin request policy must allow-list WebSocket-specific headers and the last, requests to an origin must be over HTTPS not just HTTP, as API Gateway doesn’t allow plain HTTP.\n• Create a new Origin Request Policy that Whitelists the following headers:\n\nas shown on the image below:\n\n2. Create the distribution that uses API Gateway as an origin, sets HTTPS as protocol to talk to the origin, disables the cache and uses the policy created in the step 1.\n\nIf you are using AWS CDK, the distribution shall look like this:"
    }
]