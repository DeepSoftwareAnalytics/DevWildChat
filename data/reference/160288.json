[
    {
        "link": "https://geeksforgeeks.org/main-function-in-c",
        "document": "The main function is the entry point of a C program. It is a user-defined function where the execution of a program starts. Every C program must contain, and its return value typically indicates the success or failure of the program. In this article, we will learn more about the main function in C.\n\nExplanation: This basic example demonstrates a simple main() function. It prints “Hello, World!” and returns 0 to indicate that the program executed successfully.\n\nIf we try create a function with another name, the program wont be able to execute:\n\nThe syntax of the main() function can be written in two common forms:\n\nWe can write the main function in many ways in C language as follows:\n\nIn the above notations, int means integer return type, and void return type means that does not return any information, and (void) or () means that does not take any information.\n\nThe argument of main function is different from the rest of user defined functions. As main function is called by OS, the user has to provide arguments at the time of starting program from the command line. That is why these arguments are also called command line arguments.\n• argc: Stands for ARGument Count, it is an integer variable that stores the number of command-line arguments passed.\n• argv : Stands for ARGument Vector, it is an array of character pointers listing all the arguments.\n\nTypes of main() in C\n\nThere are 3 variations of main() in C:\n• None main() with No Arguments and void Return Type – Not Recommended\n• None main() with no arguments and int return type – Recommended\n\n1. main() with No Arguments and void Return Type – Not Recommended\n\nThis type of main() is rare and not commonly used. It doesn’t accept any command-line arguments and does not return any value. While it may be supported by some compilers, it’s not a standard practice in C, as the C standard expects main() to return an int.\n\n2. main() with No Arguments and int Return Type – Recommended\n\nThis is the most commonly used form of main() in C. It does not take any command-line arguments but returns an integer value to the operating system. By convention, returning 0 indicates successful execution, while returning a non-zero value signals an error or abnormal termination.\n\nExplanation: This basic example demonstrates a simple main() function. It prints “Hello, Geek!” and returns 0 to indicate that the program executed successfully.\n\nThis version of main() is used when a program needs to accept command-line arguments. The arguments are passed through argc (argument count) and argv (argument vector). argc holds the number of arguments, and argv is an array of strings representing the arguments.\n\nThis type is useful for programs that need to handle external input, such as filenames, options, or parameters passed at the time of execution.\n\nNow, run the programs in the command prompt or terminal as seen below screenshot and passed any arguments. main.exe is the name of the executable file created when the program runs for the first time. We passed three arguments “geeks for geeks” and print them using a loop.\n\nWhat is the purpose of the main() function in C?\n\nCan we have multiple main() functions in a C program?\n\nIs it mandatory to include return 0 in the main() function?\n\nWhat happens if we define main() with a different signature?"
    },
    {
        "link": "https://en.cppreference.com/w/c/language/main_function",
        "document": "Every C program coded to run in a hosted execution environment contains the definition (not the prototype) of a function named , which is the designated start of the program.\n\nThe names and stand for \"argument count\" and \"argument vector\", and are traditionally used, but other names may be chosen for the parameters, as well as different but equivalent declarations of their type: int main(int ac, char** av) is equally valid.\n\nA common implementation-defined form of main is int main(int argc, char *argv[], char *envp[]), where a third argument, of type char**, pointing at an array of pointers to the execution environment variables, is added.\n\nIf the return statement is used, the return value is used as the argument to the implicit call to exit() (see below for details). The values zero and EXIT_SUCCESS indicate successful termination, the value EXIT_FAILURE indicates unsuccessful termination.\n\nThe function is called at program startup, after all objects with static storage duration are initialized. It is the designated entry point to a program that is executed in a hosted environment (that is, with an operating system). The name and type of the entry point to any freestanding program (boot loaders, OS kernels, etc) are implementation-defined.\n\nThe parameters of the two-parameter form of the main function allow arbitrary multibyte character strings to be passed from the execution environment (these are typically known as command line arguments). The pointers argv[1] .. argv[argc-1] point at the first characters in each of these strings. argv[0] (if non-null) is the pointer to the initial character of a null-terminated multibyte string that represents the name used to invoke the program itself (or, if this is not supported by the host environment, argv[0][0] is guaranteed to be zero).\n\nIf the host environment cannot supply both lowercase and uppercase letters, the command line arguments are converted to lowercase.\n\nThe strings are modifiable, and any modifications made persist until program termination, although these modifications do not propagate back to the host environment: they can be used, for example, with strtok.\n\nThe size of the array pointed to by is at least , and the last element, , is guaranteed to be a null pointer.\n\nThe function has several special properties:\n\nA prototype for this function cannot be supplied by the program.\n\nIf the return type of the main function is , then the return from the initial call to main (but not the return from any subsequent, recursive, call) is equivalent to executing the function, with the value that the main function is returning passed as the argument (which then calls the functions registered with , flushes and closes all streams, and deletes the files created with , and returns control to the execution environment). If the return type of the main function is compatible with, then the return from the initial call to main (but not the return from any subsequent, recursive, call) is equivalent to executing thefunction, with the value that the main function is returning passed as the argument (which then calls the functions registered with, flushes and closes all streams, and deletes the files created with, and returns control to the execution environment)."
    },
    {
        "link": "https://simplilearn.com/tutorials/c-tutorial/function-in-c-programming",
        "document": ""
    },
    {
        "link": "https://learn.microsoft.com/en-us/cpp/c-language/main-function-and-program-execution?view=msvc-170",
        "document": "Every C program has a primary function that must be named . The function serves as the starting point for program execution. It usually controls program execution by directing the calls to other functions in the program.\n\nSeveral restrictions apply to the function that don't apply to any other C functions. The function:\n• Can't be declared as .\n• Can't be declared as .\n• Can't have its address taken.\n• Can't be called from your program.\n\nThe function doesn't have a declaration, because it's built into the language. If it did, the declaration syntax for would look like this:\n\nThe function is declared implicitly by using one of these signatures. You may use any of these signatures when you define your function. The Microsoft compiler also allows to have a return type of when no value is returned. The and parameters to can also be defined as type . For more information about the arguments, see Argument description.\n\nFunctions within the source program perform one or more specific tasks. The function can call these functions to perform their respective tasks. When calls another function, it passes execution control to the function, so that execution begins at the first statement in the function. A function returns control to when a statement is executed or when the end of the function is reached.\n\nYou can declare any function, including , to have parameters. The term \"parameter\" or \"formal parameter\" refers to the identifier that receives a value passed to a function. See Parameters for information on passing arguments to parameters. When one function calls another, the called function receives values for its parameters from the calling function. These values are called arguments. You can declare formal parameters to so that it can receive arguments from the command line using the format shown in the function signature.\n\nWhen you want to pass information to the function, the parameters are traditionally named and , although the C compiler doesn't require these names. Traditionally, if a third parameter is passed to , that parameter is named . The types for , , and are defined by the C language. You can also declare as and as . Examples later in this section show how to use these three parameters to access command-line arguments. The following sections explain these parameters.\n\nIf your code adheres to the Unicode programming model, you can use the Microsoft-specific wide-character version of , , as your program's entry point. For more information about this wide-character version of , see Using .\n\nA program usually stops executing when it returns from or reaches the end of , although it can terminate at other points in the program for various reasons. For example, you may want to force the termination of your program when some error condition is detected. To do so, you can use the function. For more information on and an example of usage, see ."
    },
    {
        "link": "https://geeksforgeeks.org/c-functions",
        "document": "A function in C is a set of statements that when called perform some specific tasks. It is the basic building block of a C program that provides modularity and code reusability. The programming statements of a function are enclosed within { } braces, having certain meanings and performing certain operations. They are also called subroutines or procedures in other languages.\n\nIn this article, we will learn about functions, function definition. declaration, arguments and parameters, return values, and many more.\n\nSyntax of Functions in C\n\nThe syntax of function can be divided into 3 aspects:\n\nIn a function declaration, we must provide the function name, its return type, and the number and type of its parameters. A function declaration tells the compiler that there is a function with the given name defined somewhere else in the program.\n\nThe parameter name is not mandatory while declaring functions. We can also declare the function without using the name of the data variables.\n\nThe function definition consists of actual statements which are executed when the function is called (i.e. when the program control comes to the function).\n\nA C function is generally defined and declared in a single step because the function definition always starts with the function declaration so we do not need to declare it explicitly. The below example serves as both a function definition and a declaration.\n\nA function call is a statement that instructs the compiler to execute the function. We use the function name and parameters in the function call.\n\nIn the below example, the first sum function is called and 10,30 are passed to the sum function. After the function call sum of a and b is returned and control is also returned back to the main function of the program.\n\nExample of C Function\n\nAs we noticed, we have not used explicit function declaration. We simply defined and called the function.\n\nFunction return type tells what type of value is returned after all function is executed. When we don’t want to return a value, we can use the void data type.\n\nThe above function will return an integer value after running statements inside the function.\n\nFunction Arguments (also known as Function Parameters) are the data that is passed to a function.\n\nIn C programming language, functions can be called either with or without arguments and might return values. They may or might not return values to the calling functions.\n• None Function with no arguments and no return value\n• None Function with no arguments and with return value\n• None Function with argument and with no return value\n• None Function with arguments and with return value\n\nTo know more about function Arguments and Return values refer to the article – Function Arguments & Return Values in C.\n\nHow Does C Function Work?\n\nWorking of the C function can be broken into the following steps as mentioned below:\n• Declaring a function: Declaring a function is a step where we declare a function. Here we specify the return types and parameters of the function.\n• Defining a function : This is where the function’s body is provided. Here, we specify what the function does, including the operations to be performed when the function is called.\n• Calling the function: Calling the function is a step where we call the function by passing the arguments in the function.\n• Executing the function: Executing the function is a step where we can run all the statements inside the function to get the final result.\n• Returning a value: Returning a value is the step where the calculated value after the execution of the function is returned. Exiting the function is the final step where all the allocated memory to the variables, functions, etc is destroyed before giving full control back to the caller.\n\nThere are two types of functions in C:\n\nA library function is also referred to as a “built-in function”. A compiler package already exists that contains these functions, each of which has a specific meaning and is included in the package. Built-in functions have the advantage of being directly usable without being defined, whereas user-defined functions must be declared and defined before being used.\n• None C Library functions are easy to use and optimized for better performance.\n• None C library functions are convenient as they always work.\n\nFunctions that the programmer creates are known as User-Defined functions or “tailor-made functions”. User-defined functions can be improved and modified according to the need of the programmer. Whenever we write a function that is case-specific and is not defined in any header file, we need to declare and define our own functions according to the syntax.\n• None Changeable functions can be modified as per need.\n• None The Code of these functions is reusable in other programs.\n• None These functions are easy to understand, debug and maintain.\n\nThe data passed when the function is being invoked is known as the Actual parameters. In the below program, 10 and 30 are known as actual parameters. Formal Parameters are the variable and the data type as mentioned in the function declaration. In the below program, a and b are known as formal parameters.\n\nWe can pass arguments to the C function in two ways:\n\nParameter passing in this method copies values from actual parameters into formal function parameters. As a result, any changes made inside the functions do not reflect in the caller’s parameters.\n\nThe caller’s actual parameters and the function’s actual parameters refer to the same locations, so any changes made inside the function are reflected in the caller’s actual parameters.\n\nAdvantages of Functions in C\n\nFunctions in C is a highly useful feature of C with many advantages as mentioned below:\n• None The function can reduce the repetition of the same statements in the program.\n• None The function makes code readable by providing modularity to our program.\n• None There is no fixed number of calling functions it can be called as many times as you want.\n• None The function reduces the size of the program.\n• None Once the function is declared you can just use it without thinking about the internal working of the function.\n\nDisadvantages of Functions in C\n\nThe following are the major disadvantages of functions in C:\n• None Memory and time overhead due to stack frame allocation and transfer of program control.\n\nIn this article, we discussed the following points about the function as mentioned below:\n• None The function is the block of code that can be reused as many times as we want inside a program.\n• None To use a function we need to call a function.\n• None Function definition includes the body of the function.\n• None The function is of two types user-defined function and library function.\n• None In function, we can according to two types call by value and call by reference according to the values passed.\n\nFAQs on Functions in C\n\nQ3. What is the difference between function declaration and definition?\n\nQ4. What is the difference between function arguments and parameters?\n\nQ5. Can we return multiple values from a C Function?\n\nQ6. What is the actual and formal parameter?"
    },
    {
        "link": "https://geeksforgeeks.org/header-files-in-c-cpp-and-its-uses",
        "document": "In C programming, a header file is a file that ends with the .h extension and contains features like functions, data types, macros, etc that can be used by any other C program by including that particular header file using “#include” preprocessor.\n\nC language uses header files to provide the standard libraries and their components for use in programs.\n\nWe can include header files in C by using one of the given two syntax whether it is a pre-defined or user-defined header file.\n\nThe “#include” preprocessor directs the compiler that the header file needs to be processed before compilation and includes all the necessary data types and function definitions.\n\nThere are two types of header files in C:\n\nStandard Header Files in C and Their Uses\n\nStandard header files contain the libraries defined in the ISO standard of the C programming language. They are stored in the default directory of the compiler and are present in all the C compilers from any vendor.\n\nThere are 31 standard header files in the latest version of C language. Following is the list of some commonly used header files in C:\n\nIt contains information for adding diagnostics that aid program debugging. It contains a set of various platform-dependent constants related to floating point values. These constants are proposed by ANSI C. They make programs more portable. Some examples of constants included in this header file are- e(exponent), b(base/radix), etc. It is used to perform mathematical operations like It is used to perform signal handling functions like signal() and raise(). It is used to perform standard argument functions like va_start() and va_arg(). It is also used to indicate start of the variable-length argument list and to fetch the arguments from the variable-length argument list in the program respectively. It contains function prototypes for functions that test characters for certain properties, and also function prototypes for functions that can be used to convert uppercase letters to lowercase letters and vice versa.\n\n It is used to perform input and output operations using functions like It contains standard utility functions like malloc(), realloc(), etc. It contains function prototypes for functions that allow bypassing of the usual function call and return sequence. It is used to perform various functionalities related to string manipulation like It determines the various properties of the various variable types. The macros defined in this header limits the values of various variable types like char, int, and long. These limits specify that a variable cannot store any value beyond these limits, for example, an unsigned character can store up to a maximum value of 255. It is used to perform functions related to date() and time() like setdate() and getdate(). It is also used to modify the system date and get the CPU time respectively. It contains common type definitions used by C for performing calculations. It contains function prototypes and other information that enables a program to be modified for the current locale on which it’s running. It enables the computer system to handle different conventions for expressing data such as times, dates, or large numbers throughout the world.\n\nThe below example demonstrates the use of some commonly used header files in C.\n\nNon-Standard Header Files in C and Their Uses\n\nNon-standard header files are not part of the language’s ISO standard. They are generally all the header files defined by the programmers for purposes like containing custom library functions etc. They are manually installed by the user or maybe part of the compiler by some specific vendor.\n\nThere are lots of non-standard libraries for C language. Some commonly used non-standard/user-defined header files are listed below:\n\nThe below example demonstrates the use of conio.h non-standard header file.\n\nCreate your own Header File in C\n\nInstead of writing a large and complex code again and again in different programs, we can create our own header files and include them in our program to use whenever we want. It enhances code functionality and readability. Below are the steps to create our own header file:\n\nStep 1: Write your own C code and save that file with the “.h” extension. Below is the illustration of the header file:\n\n\n\nStep 2: Include your header file with “#include” in your C program as shown below:\n\nYou can use various header files in a program. When a header file is included twice within a program, the compiler processes the contents of that header file twice. This leads to an error in the program. To eliminate this error, conditional preprocessor directives are used.\n\nThis construct is called wrapper “#ifndef”. When the header is included again, the conditional will become false, because HEADER_FILE_NAME is defined. The preprocessor will skip over the entire file contents, and the compiler will not see it twice.\n\nSometimes it’s essential to include several diverse header files based on the requirements of the program. For this, multiple conditionals are used."
    },
    {
        "link": "https://websites.umich.edu/~eecs381/handouts/CHeaderFileGuidelines.pdf",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/49099976/how-do-you-define-functions-in-header-files",
        "document": "You can define a function in header files if it's weak linkage like:\n\nwon't raise multiple definitions error and the output should be as expected, meaning , and share the same function. You can achieve the same result in c++ by using .\n\nMoreover, weak linkage can also be used on variable definition, allowing you to define and initialize a global variable in header files without source files (similar to in c++).\n\nSo be careful when using it in c. But in c++, and are portable form c++11 and c++17."
    },
    {
        "link": "https://unstop.com/blog/header-files-in-c",
        "document": "The header files in C contain prewritten codes that can be used in multiple programs. There are two primary types- standard library files and user-defined header files. Understanding how to use them is an integral part of programming in C.\n\nHeader files play a crucial role in C programming, enabling modularity and organization of code. They are essential components that facilitate code reusability, maintainability, and collaboration among programmers. In this article, we will explore header files in C, their structure, why we use header files, and some best practices to use them effectively.\n\nWhat Is A Header File In C?\n\nA header file in C langauge is a text file containing definitions of functions, variables, and macros that are shared among multiple source files. It provides an interface to the variety of functions and data structures that can be used by other parts of the program. Essentially, a header file serves as a contract that specifies what features/ operations are available to the rest of the program without exposing the implementation details.\n\nHeader files are typically named with the (.h) extension, and their content consists of function prototypes, type definitions, and constant values that can be shared across various source files. Both the user and the system header files are included using the preprocessing directive #include.\n\nSyntax Of Header Files In C\n\nIn C programming, header files serve as a way to declare function prototypes, types, and macros that can be shared across multiple source files. The syntax of header files typically consists of the following elements:\n• #ifndef HEADER_NAME_H: This is known as a header guard. It checks whether the name/ identifier HEADER_NAME_H has not been defined. If it's not defined, it means the file is being included for the first time, and the code inside the guard will be processed. The HEADER_NAME_H should be a unique identifier/ name based on the header file's name to prevent naming conflicts.\n• #define HEADER_NAME_H: Inside the header guard, you define the identifier HEADER_NAME_H. This marks the beginning of the header file.\n• // Declarations and definitions go here: This is where the declarations and definitions for standard library functions, types, macros, and global constants are placed for use. This section defines the interface provided by the header file.\n• #endif // HEADER_NAME_H: This marks the end of the header file. If HEADER_NAME_H has already been defined, this section is skipped, and the file is effectively excluded from further processing to prevent multiple inclusions.\n\nTypes Of Header Files In C\n\nThere are two different sorts of header files in C, i.e., Standard library header files and User-defined header files. In this section, we will discuss both types in greater detail.\n\nIncluded with the C compiler, these header files provide declarations and definitions for all variables and predefined functions or methods found in the C standard library. Examples include the header files <stdio.h>, <stdlib.h>, <string.h>, <math.h>, etc., each of which caters to specific functions/ operations. The header file names are enclosed in angular brackets <> inside the code to indicate that the file is located in the standard folder for header files in C.\n\nIn the sections ahead, we will discuss the purpose and functions included in the 25 standard header files. But first, look at the simple C program example below illustrating the use of one of the standard library header file <stdio.h>.\n\nIn the simple C code example, we first include the standard input-output library (i.e., stdio.h), which provides input-output stream/ operations functions.\n• We then define the main() function, which serves as the entry point for the C program's execution.\n• Next, we declare two integer variables, num0 and num1, using comma operator and initialize them with values 1 and 0.\n• Then, using the printf() function, we display the result of adding num0 and num1 to the console.\n• The %d format specifier in the format string is a placeholder for an integer, which is replaced with the result of the addition when printf is executed. The newline escape sequence (\n\n) shifts the cursor to the next line after printing.\n\nAs the name suggests, these header files are generated by users to contain declarations and definitions for custom variables and functions they use in their programs. Header files are often used to divide the code into distinct modules and increase the code's sustainability. The #include directive in the source code can be used to include user-defined headers. Let's take a look at an example of the same.\n\nSay you want to define a header file called myheader that includes a function to calculate the area of a rectangle. Then, the header file definition and its usage will be as given below.\n\nmain.c (Source file for using the header and function):\n\nIn this C program example:\n• We define the myheader.h file, which is the user-defined header file that contains the function prototype.\n• Then, myfunctions.c is the source file that contains the definition of the function declared in the header file.\n• Then, the section- main.c is another source file that includes the user-defined header file and uses the function to calculate the area of a rectangle.\n\nWhen you compile these source files together, they will create an executable that calculates and displays the area of a rectangle. You can compile them using a C compiler, such as GCC, with a command like this:\n\nAnd then you can run the executable:\n\nList Of Standard Header Files In C\n\nThe table below contains a list of commonly used standard header files in C, along with syntax and a brief description.\n\nStandard Header File In C & Their Uses\n\nIn C, there are many standard header files, each of which has a unique collection of utilities and methods. Naturally, there are a few standard C header files that are most typically used in applications/ C code. We have compiled a detailed explanation of all 25 standard header files in C.\n\nThe <stdio.h> Header File In C\n\nThe name stands for standard input/output header, and it contains functions for standard input and output operations such as printf() and scanf() and file operations like fopen(), fclose(), fseek(), fread(), and write(). This header file is used for printing information to the console, reading input from the keyboard, and reading and writing data to and from files.\n\nSome standard functions that form a part of this header file in C are:\n• printf(): Used to print formatted output to the console or a file.\n• scanf(): Used to read formatted input from the console or a file.\n• fgets(): Used to read a line of text from a file or the console.\n• fseek(): Used to set the file position indicator for a file.\n• fread(): Used to read data from a file.\n• fwrite(): Used to write data to a file.\n\nThe <stdlib.h> Header File In C\n\nThe term stdlib.h stands for standard library header, which contains functions for general-purpose tasks such as memory allocation, process control, type conversions, and searching.\n• It is mainly used to perform standard utility functions like malloc(), calloc(), realloc(), and free() for memory allocation and deallocation.\n• It also contains functions like rand() and srand() for generating random numbers and qsort() for sorting arrays.\n\nAll in all, this header file in C is used for memory management, number manipulation, and searching and sorting algorithms.\n\nSome standard functions that form a part of this header file in C are:\n• atoi(): Used to convert a string to an integer.\n• atof(): Used to convert a string to a floating-point number.\n• qsort(): Used to sort an array.\n\nThe <string.h> Header File In C\n\nThis header contains functions for string manipulation and memory manipulation. It includes functions like strlen(), strcpy(), strcat(), strstr(), and strtok() for string manipulation and memset(), memcpy(), and memcmp() for memory manipulation. In other words, it is used for working with strings and manipulating memory.\n\nSome standard functions that form a part of this header file in C are:\n• strlen(): Used to get the length of a string.\n• strcpy(): Used to copy one string to another.\n• strcat(): Used to concatenate two strings.\n• strstr(): Used to find a substring in a string.\n• memset(): Used to set the value of a block of memory to a specific value.\n• memcpy(): Used to copy a block of memory from one location to another.\n\nThe <math.h> Header File In C\n\nThis header file contains mathematical functions such as trigonometric functions, logarithmic functions, and exponential functions. This includes functions like sin(), cos(), tan(), sqrt(), pow(), and ceil() for performing mathematical operations. The primary purpose of this header is to help in performing complex mathematical operations.\n\nSome standard functions that form a part of this header file in C are:\n• sin(): Used to calculate the sine of an angle.\n• cos(): Used to calculate the cosine of an angle.\n• tan(): Used to calculate the tangent of an angle.\n• sqrt(): Used to calculate the square root of a number.\n• pow(): Used to raise a number to a power.\n• ceil(): Used to round a number up to the nearest integer.\n• floor(): Used to round a number down to the nearest integer.\n\nThe <time.h> Header File In C\n\nAs the name suggests, this header file contains functions for time manipulation and conversion. Such as functions like time(), localtime(), and strftime() for getting the current time, converting time to string, and formatting time. It makes it possible to work with dates and times.\n\nSome standard functions that form a part of this header file in C are:\n• time(): Used to get the current time in seconds since the Epoch.\n• localtime(): Used to convert a time value to a local time.\n• gmtime(): Used to convert a time value to a UTC time.\n• mktime(): Used to convert a local time to a time value.\n• strftime(): Used to format a time value as a string.\n\nThe <ctype.h> Header File In C\n\nThe header file contains functions for character type checking and case conversion. For example, isdigit(), isalpha(), toupper(), and tolower() for checking the type of characters and converting cases. It is used for working with characters and strings.\n\nSome standard functions that form a part of this header file in C are:\n• isdigit(): Used to check if a character is a digit.\n• isalpha(): Used to check if a character is an alphabetic character.\n• islower(): Used to check if a character is a lowercase letter.\n• toupper(): Used to convert a character to uppercase.\n• tolower(): Used to convert a character to lowercase.\n\nThe <errno.h> Header File In C\n\nThe errno.h header file consists of the global variable errno, which is used to indicate errors during program execution. It contains functions like perror(), which is used to print error messages based on the current value of errno. The primary purpose of this header is to facilitate the handling errors in a program.\n\nThe two primary standard functions that form a part of this header file in C are:\n• errno: This is a global variable set to a value that indicates the type of error that occurred during program execution.\n• perror(): Used to print an error message to the console based on the current value of the errno variable.\n\nThe <limits.h> Header File In C\n\nThis header file contains constants that represent the minimum and maximum values that can be stored in certain data types. Constants like CHAR_BIT, SCHAR_MIN, SCHAR_MAX, SHRT_MIN, and SHRT_MAX for different data types are a part of this header. It is used for checking the limits of data types.\n\nSome standard library macros that form a part of this header file in C are:\n• INT_MAX: The maximum value that can be stored in an int.\n• INT_MIN: The minimum value that can be stored in an int.\n• LONG_MAX: The maximum value that can be stored in a long int.\n• LONG_MIN: The minimum value that can be stored in a long int.\n\nThe <float.h> Header File In C\n\nThe float.h file contains constants representing the minimum and maximum values that can be stored in floating-point data types. These constants include FLT_MIN, FLT_MAX, DBL_MIN, and DBL_MAX for different floating-point data types. In short, the float. h file is used to check the limits of floating-point data types.\n\nSome standard functions/ library macros contained in this header file in C are:\n• FLT_MAX: The maximum value that can be stored in a float.\n• FLT_MIN: The minimum value that can be stored in a float.\n• DBL_MAX: The maximum value that can be stored in a double.\n• DBL_MIN: The minimum value that can be stored in a double.\n\nThe <assert.h> Header File In C\n\nThe file contains the assert() macro, which is used to check the validity of an expression during program execution. If the expression is evaluated to be false, the program terminates with an error message. This file is included for debugging purposes and error-checking during program execution. The primary function that is a part of this file is-\n• assert(): Used to check a condition and terminate the program if the condition is false.\n\nThe <setjmp.h> Header File In C\n\nThe two primary functions in this header are the setjmp() and longjmp() functions, which are used for non-local jumps in a program. It is used for handling exceptions and other error conditions in a program.\n\nThe purpose of the standard functions that form a part of this header file in C are:\n• setjmp(): This function saves the current execution state of a program in a buffer and returns zero.\n• longjmp(): This function restores the saved state to the point where setjmp() was called and returns control to that point in the program.\n\nThe <signal.h> Header File In C\n\nAs is evident by the name, this header contains signal handling functions, which are interrupts sent to a program by the operating system.\n\nThe standard functions that form a part of this header file are:\n• signal(): Used to handle signals received during runtime by registering a signal handler function\n• raise(): Used to simulate the sending of a signal to a process for testing purposes.\n\nThe <stdarg.h> Header File In C\n\nThis file is used to perform standard argument functions as it contains functions for handling variable arguments. These refer to the arguments passed to a function whose number and types are unknown at compile time. It contains macros like va_start(), va_arg(), and va_end() for handling variable arguments. In other words, this header is used when we want to work with functions that take variable arguments, like printf().\n\nThe standard functions contained in this header file in C are:\n• va_start(): This function initializes an argument list for access by the va_arg() macro.\n• va_arg(): This macro expands to an expression that retrieves the next argument from the argument list initialized by va_start().\n\nThe <stdbool.h> Header File In C\n\nThe <stdbool.h> stands for standard boolean header, and as is obvious, it is used when working with boolean data types. It contains definitions for boolean data types, which can only have the values true and false. In other words, it defines the macros for true and false.\n\nThe standard functions that form a part of this header file in C are:\n• bool: This is a data type that is defined in this header file, and it can take two values, i.e., true or false.\n• true and false: These are predefined constants of type bool that represent the boolean values.\n\nThe <stdint.h> Header File In C\n\nIt contains definitions for integer data types with specific bit widths. For example, types like int8_t, int16_t, int32_t, uint8_t, uint16_t, uint32_t, and others. In short, this header is included when we want to work with integer data types with specific bit widths.\n\nThe standard functions that form a part of this header file in C are:\n• Integer data types: This header file defines integer data types with a fixed width, such as int8_t, int16_t, uint32_t, etc. This ensures the size and range of these data types across different platforms and compilers.\n• Limits and constants: The stdint.h also defines various constants, such as INT_MAX, INT_MIN, UINT_MAX, etc., that provide information about the maximum and minimum values of integer data types.\n\nThe <locale.h> Header File In C\n\nThe primary purpose of this header is to facilitate and handle localization. This includes aspects like local languages and region-specific settings for formatting data like dates, times, and numbers. It contains two primary functions that help with the localization of data.\n\nThe standard functions contained in this header file in C are:\n• setlocale(): This function helps change or retrieve the current locale. The two inputs this function takes are the category of the locale to set or get and the locale name.\n• localeconv(): This function is used to obtain details about the formatting standards of the current locale, including the character for the decimal point and the currency sign. It gives back a pointer to a struct that has this data.\n\nThe <stddef.h> Header File In C\n\nThis header contains definitions for basic data types and macros for working with memory. It defines the types ptrdiff_t, size_t, wchar_t, etc., and the macros NULL and offsetof(). In short, it is used for purposes relating to the memory and basic data types.\n\nThe macros that belong to this header file in C are:\n• size_t: This is a type used to express an object's size. It is frequently used as the return type for functions like strlen() and sizeof() that return the size of an object or buffer.\n• NULL: This constant pointer value normally denotes a null pointer. It is frequently used to show that a valid pointer is missing, for example, when a function fails to allocate memory.\n\nThe <time.h> Header File In C\n\nThis header file is used when working with dates and times, as it contains functions for time manipulation and conversion. It defines variable types like size_t, clock_t, etc., and includes functions like time(), localtime(), and strftime() for getting the current time, converting time to string, and formatting time, respectively.\n\nThe standard functions that form a part of this header file in C are:\n• time(): This function calculates the current time as the duration of time since the Epoch (0:00:00 UTC, January 1, 1970) and returns that value. Its parameter is a pointer to a time_t object, where the returned time value is kept.\n• localtime(): This function is used when one wants to change a time value (expressed as the number of seconds since the Epoch) into local time, which corresponds to the time zone in which the program is currently running. It accepts a pointer to a time_t object as a parameter, and as a response, it returns a pointer to a struct object that holds the local time components.\n\nThe <wchar.h> Header File In C\n\nThe purpose of this header file is to facilitate working with wide characters, i.e., characters that use more than one byte to represent. It contains functions for working with wide characters such as fgetwc(), fputwc(), and wctype().\n\nThe common components of this header file in C are:\n• wchar_t: This data type is defined in wchar.h header file and is used to represent wide characters that cannot be represented by a regular char data type.\n• Functions for wide character handling: This library also provides a set of functions for wide character handling, such as converting between multibyte and wide character strings, formatting wide character strings, and more. For example, int wcscmp()function that compares two wide character strings.\n\nThe <wctype.h> Header File In C\n\nIt contains functions for classifying wide characters, which are characters that use more than one byte to represent. It is used to work with these wide characters and functions like iswalpha(), iswdigit(), and iswpunct() for checking the type of wide characters.\n\nSome standard functions that form a part of this header file in C are:\n• wctype(): Used to obtain a wide character classification object that represents a character class.\n• iswctype(): Used to test whether a given wide character belongs to a specific character class represented by a given wide character classification object.\n\nThe <complex.h> Header File In C\n\nThis header is used for performing complex mathematical operations with complex numbers, i.e., numbers that have both a real and imaginary part. It defines functions such as cabs(), cexp(), and cpow().\n\nSome standard functions that belong to this header file in C are:\n• creal() and cimag(): These functions are used to extract the real and imaginary parts of a complex number, respectively.\n• cexp() and cpow(): These functions are used to perform complex exponentiation and complex power operations, respectively.\n\nThe <fenv.h> Header File In C\n\nThe use of this header file helps control the behavior of floating-point operations. It contains functions for working with floating-point environments, which include things like rounding mode, floating-point exceptions, and floating-point precision. These functions include fesetround(), fegetround(), and feclearexcept().\n\nCommon standard functions from this header file in C are:\n• fegetenv(): This function saves the current floating-point environment into the provided fenv_t object.\n• fesetround(): This function sets the rounding direction mode for floating-point arithmetic operations.\n\nThe <inttypes.h> Header File In C\n\nAnother important header file, it consists of definitions for integer data types with specific bit widths, along with their corresponding printf() format specifiers. In other words, it is used when working with integer data types with specific bit widths and formatting them for output.\n\nCommon components of the inttypes.h header file in C are:\n• PRId64: A format specifier used for int64_t data type in the printf() statements to print a signed 64-bit integer.\n• strtoimax(): A function that converts a string to an integer of type intmax_t, which is a signed integer type with the maximum width supported by the implementation.\n\nThe <stdalign.h> Header File In C\n\nThis header file deals with the process of specifying how memory should be aligned. It contains definitions for alignment control with macros like alignas() and alignof() for specifying and querying alignment. Its primary purpose is to control the alignment of memory.\n\nThe common components that belong to this header file in C are:\n• alignof: This macro returns the required alignment of a type in bytes.\n• alignas: This specifier is used to specify the alignment of a variable or a structure field.\n\nThe <tgmath.h> Header File In C\n\nThe <tgmath.h> file defines macros for performing mathematical operations that work with both real and complex numbers. These macros include acos(), asin(), atan(), cos(), sin().\n\nSome standard functions that form a part of this header file are:\n• sin(x): which returns the sine of x, where x is a floating-point number of any type.\n• sqrt(x): which returns the square root of x, where x is a floating-point number of any type.\n\nFor the most part, these standard header files offer a large range of utilities and functions that are crucial for C programming. These header files give you access to a wealth of functionality that can make programming chores easier. You can use this capability by including these header files in your code.\n\nExamples Of Using Header Files In C\n\nUsing standard header files in C gives us access to a wide range of capabilities when included in the code/ program, thus making the job of a programmer easier. Let's look at examples showcasing the application of all the header files we discussed above.\n\nIn this C code example, we have demonstrated the usage of various standard library headers in C programming, including-\n\nAfter including all the header files, we initiate the main() function. Inside the function-\n• We use the printf() function from <stdio.h> to print Hello world! to the console.\n• Then, we declare an array of integers and allocate memory to it, using the malloc() function from the <stdlib.h> file.\n• Next, we use the <string.h> header to declare two character arrays/ string, i.e., s1 (initialized to Hello) and s2[6].\n• We use functions strcpy() to manipulate character arrays, i.e., copy content from one array to another.\n• And the printf() function to display the result.\n• After that, we use the sqrt() function from <math.h> to calculate the square root of a number (variable a=4.0) and display the result using printf.\n• Lastly, we use the function from <time.h> file to get and display the current time in a human-readable format.\n\nThe code comments in the example above indicate the name of the header file being used for the respective operation/ purpose. Let's look at another example C program illustrating the use of some other header files.\n\nIn this example C code, we have demonstrated the use of standard C libraries for character classification, boolean data types, limits, floating-point constants, assertion checks, and error handling. We begin by including the header files and then inside the main() function-\n• We use the function from <ctype.h> to check if the character variable (c) declared and initialized to Z is an alphabetic character and print a message accordingly.\n• Next, we use the <stdbool.h> file to define a boolean variable x, initialize it as true, and print a message based on its value.\n• Then, using the <limits.h> and <float.h> header files, we print the maximum value of an integer (INT_MAX) and the minimum value of a floating-point number (FLT_MIN).\n• After that, we declare an integer variable a and assign the value 2. We then use the assert() function from the <assert.h> header, to check if the value of integer variable a is greater than 10.\n• An assertion failure will occur if the condition is not met, and the program prints a message to that effect.\n• Since the condition is not met here, we get a failure message in the output.\n• Lastly, we use <errno.h> header operations in conjunction with file operations.\n• We attempt to open a file named nonexistent_file.txt using the fopen() function to read (r).\n• Then, we use an if-statement to check if an error occurs when opening the file by equating the file to NULL value.\n• If an error occurs, the if-block is executed printing an error message with details using the strerror() function and errno global variable.\n\nNon-Standard Header Files In C & Their Uses\n\nNon-standard header files are those produced by programmers for particular purposes, such as including customized library functions, and are not part of the language ISO standard. Also referred to as user-defined header files, these do not come automatically installed with the language. Instead, they must be installed individually by the user or may be provided as part of the compiler by specific vendors.\n\nLook at the sample C program below, which illustrates the use of non-standard/ user-defined header files.\n\nWe begin the sample C code by including the standard C library for input/output operations, i.e., <stdio.h>. Also included is a non-standard <conio.h> library, which is used for console-based operations in older C environments but may not be supported in modern compilers.\n• We then define the main() function, the program's entry point.\n• Next, we use the printf() function two times to print text to the console.\n• After that, we use the clrscr() function from <conio.h> to clear the console screen and once again use printf() to print another phrase to the console.\n• The program ends, returning 0 to indicate successful execution.\n\nNote: The code includes the <conio.h> header, which is not a standard C library and may not be available on all systems.\n\nHow To Create Your Own Header File In C?\n\nProgrammers can make their own personalized header files in addition to the pre-existing header files in C. These are often referred to as user-defined header files. It is easy to develop custom header files and incorporate them into C programs whenever needed. This eliminated the need to write extensive and complex code over and over again while also enhancing code functionality and readability.\n\nGiven below is a step-by-step description of the process for making ones own header file in C.\n\nStep 1: The first step is to add your personalized/ customer code to the file with the (.h) extension. This is important since you are developing a header file for usage in your program code.\n\nStep 2: Once the code is added, the next step is to declare the code below as the factorial.h. In other words, your program's source code should include the factorial.h header file. There are two ways to do this-\n\nStep 3: After including the header file in the code, the next step is to run the program code after compilation. Take a look at the example below.\n\nHow The Include Operation Work With Header Files In C?\n\nThe C preprocessor is instructed to scan the file given as input before moving on to the remaining part of the current source file using the #include directive. Before continuing with the rest of your current source file, C's #include directive statement seeks to search through the C preprocessor for a particular file, such as input. The output generated by the preprocessor is composed of the output that has previously been produced, the output from the included file, the output from the text following the #include directive, and finally, the output.\n\nLet's use a scenario where you consider having a header file called file.h. The following sentence appears in the code/ syntax-\n\nThe primary C source program then appears to be something as follows:\n\nWe start the C code sample by including the <stdio.h> header file. Then-\n• We declare a global variable z, of integer type without initialization.\n• Next, we include the header file, i.e., file.h, declared locally in the program or in a separate file.\n• In the main() function, we call the printf() function and pass a string to it as input. This prints the message 'Completed' to the output window.\n\nWe begin the C program sample with the header file stdio.h, after which we declare a global variable q of type int.\n• Next, we declare a function called file() that returns a pointer to a character, but this function is not called in the main function.\n• In the main() function, we call the printf() function to print the message/ strong 'Successfully' to the output window.\n• Since there are no errors in the code, the program will execute successfully.\n\nProgrammers utilize the once-only method to avoid redefinition mistakes and conflicting declarations that might occur when header files are included numerous times in the same source code file (Entire file contents).\n• If a header file's contents are included more than once, the compiler will process them twice, leading to a compilation error.\n• This method is implemented using preprocessor directives like #ifndef, #define, and #endif to ensure that a header file is included only once.\n• The conventional method for preventing this is to enclose the complete real contents of the executable file with a conditional, as seen below.\n\nThis is frequently referred to as a wrapper #ifndef. Because HEADER_FILE is defined, the conditional will be false when the header is included again. The preprocessor will skip through the entire file contents, and the compiler will not see it twice.\n\nWe can use a variety of header files in a single C program, but this must be done with caution since a header file's contents are processed twice by the compiler if it is included more than once in a program. This will most likely lead the program to malfunction.\n\nHowever, there is an easy solution to adding multiple header files in a program, and that is the conditional preprocessor directives. When you include several header files, the order in which they appear in your code determines how they are handled. If headers contain contradictory declarations or definitions, it is extremely crucial to include them in the right order. Now, let's understand the concept of single and multiple header files in C.\n• Single-use header files are those that are only included in a single source file. These headers typically contain declarations and definitions specific to that source file. Examples of single-use header files in C might include <my_file_utils.h> or <my_math_utils.h>. These headers would contain functions and constants specific to a particular program or module\n• Multiple-use header files can be included in multiple source files. Examples of multiple-use header files in C include <stdio.h>, <stdlib.h>, and <string.h>. These headers contain commonly used functions such as printf(), malloc(), and strcpy(), respectively.\n\nBest Practices For Using Header Files In C\n\nTo make the best use of header files in C programs, consider the following best practices:\n• Self-Containment: Ensure that each header file includes all the dependencies it needs, making it self-contained and reducing the risk of naming conflicts.\n• Commenting: Document your functions, types, and macros with comments to explain their purpose and usage, making it easier for developers who use your header file in C programs.\n• Minimalism: Keep header files minimal. Avoid including unnecessary dependencies to reduce compilation time and complexity.\n• Consistent Naming: Follow a consistent naming convention for your header files and their content to maintain code readability.\n• Namespace Prefix: Add a namespace prefix to your function names and type definitions to avoid naming conflicts with other libraries.\n• Header File Location: Place header files in a separate directory or a designated location to maintain a clean and organized project structure.\n\nIn conclusion, header files in C are invaluable tools for enhancing code organization, facilitating code reusability, and enabling seamless collaboration among developers. These files provide a clear separation between the interface and implementation of functions, data structures, and macros, promoting modularization and maintaining code readability in projects of varying complexity.\n\nBy following best practices such as self-containment, clear documentation, and minimalism, programmers can harness the full potential of header files in C programs, creating well-structured and efficient codebases that are easier to manage and maintain. Header files are an indispensable asset in the C programmer's toolkit, supporting the development of robust and maintainable software systems.\n\nAlso read- 100+ Top C Interview Questions With Answers (2023)\n\nQ. What should be written in the header file in C?\n\nA header file in a C program often contains declarations of functions, macros, constants, and data types that are utilized throughout several source files and output files.\n\nTypical components you could discover in an entire header file include-\n• Preprocessor instructions are known as header guards that prevent the header file from being included more than once.\n• Function prototypes are declarations of functions that are utilized in the present file but are defined in other source files.\n• Constants: These are typically defined by the preprocessor instruction #define.\n• Macros enable one to define brief and reusable chunks of code.They are often defined using the #define preprocessor command.\n\nQ. What is the header file in C for Windows?\n\nThe two main categories of header files in C are-\n• Standard/ System header files: These are the default header files that the C compiler supplies and are normally kept in the included directory of the compiler. They are referred to by the #include command and are enclosed in angular brackets. These files contain the declarations for the common C library functions, constants, and macros. For example, system header files in C.\n• User-defined header files: These are created by the programmer and used to declare custom functions, constants, and data types that can be utilized throughout numerous source files of a program. The #include directive includes them by enclosing them in double quotes and placing them in the same directory as the source files. Some examples of user-defined header files include \"myheader.h\", \"constants.h\", and \"types.h\".\n\nQ. What is void main in C?\n\nThe C function declaration void main() indicates that the main function has no return value. Usually, we write int main() indicating that the return value is an integer type. The use of void type is discouraged because it is not a common or scalable method of writing a main function.\n• The main() function is required by the C standard to have an int return type and return an integer value to represent the program's exit state.\n• The exit status is often used to inform the operating system if the program was successful or unsuccessful, with a value of 0 indicating success and non-zero values indicating failure.\n\nQ. What is the main function in C programs?\n\nThe main function is a unique function in the C programming language that acts as a program's starting point. Every C program must include it as it is the first function to be called when the program is run.\n\nThe main function returns an int, which represents the program's exit state. While non-zero values signal problems or other factors that prevent the program from running correctly, return values of 0 normally indicate the program's successful execution.\n\nQ What is the full form of Conio.h header file in C?\n\nThe <conio.h> header file in C contains functions for carrying out input and output operations on consoles. The abbreviation conio stands for console input/output. The <conio.h> header file has functions for reading keyboard input, adjusting the text color and other text properties, and doing other console-related tasks. This header file is not included in the standard C library and is not supported by all operating systems and compilers. It is frequently used in code or in applications that, for whatever reason, demand direct console access.\n\nIn the C programming language, the preprocessor directive, i.e., #include, is used to include the contents of one file in the current file.\n• Before the compilation process starts, the compiler replaces any #include directives it finds in source files with the contents of the chosen file.\n• It also makes your code more modular and easier to maintain by allowing you to reuse code across various source files.\n\nBoth system and user-defined header files can be included using the #include directive. User-defined header files are normally included using double quotes, such as #include \"myheader.h,\" but system header files in C are typically included using angle brackets, such as #include <stdio.h>.\n\nYou might also be interested in reading the following:\n• Understanding Looping Statements In C [With Examples]\n• Operators In C Programming: Explained With Examples\n• Control Statements In C | The Beginner's Guide (With Examples)\n• Union In C | Declare, Initialize, Access Member & More (Examples)\n• Recursion In C | Components, Working, Types & More (+Examples)\n• Array Of Pointers In C & Dereferencing With Detailed Examples"
    },
    {
        "link": "https://doc.ic.ac.uk/lab/cplus/cstyle.html",
        "document": ""
    }
]