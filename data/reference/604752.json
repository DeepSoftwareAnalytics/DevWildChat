[
    {
        "link": "https://vuejs.org/guide/essentials/watchers.html",
        "document": "Computed properties allow us to declaratively compute derived values. However, there are cases where we need to perform \"side effects\" in reaction to state changes - for example, mutating the DOM, or changing another piece of state based on the result of an async operation.\n\nWith the Options API, we can use the option to trigger a function whenever a reactive property changes: // whenever question changes, this function will run 'Error! Could not reach the API. ' The option also supports a dot-delimited path as the key: // Note: only simple paths. Expressions are not supported.\n\nWith Composition API, we can use the function to trigger a callback whenever a piece of reactive state changes: 'Error! Could not reach the API. ' 's first argument can be different types of reactive \"sources\": it can be a ref (including computed refs), a reactive object, a getter function, or an array of multiple sources: Do note that you can't watch a property of a reactive object like this: // this won't work because we are passing a number to watch()\n\nWhen you call directly on a reactive object, it will implicitly create a deep watcher - the callback will be triggered on all nested mutations: // Note: `newValue` will be equal to `oldValue` here // because they both point to the same object! This should be differentiated with a getter that returns a reactive object - in the latter case, the callback will only fire if the getter returns a different object: // fires only when state.someObject is replaced You can, however, force the second case into a deep watcher by explicitly using the option: // Note: `newValue` will be equal to `oldValue` here // *unless* state.someObject has been replaced\n\nIn Vue 3.5+, the option can also be a number indicating the max traversal depth - i.e. how many levels should Vue traverse an object's nested properties.\n\nis lazy by default: the callback won't be called until the watched source has changed. But in some cases we may want the same callback logic to be run eagerly - for example, we may want to fetch some initial data, and then re-fetch the data whenever relevant state changes.\n\nWatcher's callback will execute whenever the watched source changes. If you want the callback to trigger only once when the source changes, use the option.\n\nIt is common for the watcher callback to use exactly the same reactive state as the source. For example, consider the following code, which uses a watcher to load a remote resource whenever the ref changes: In particular, notice how the watcher uses twice, once as the source and then again inside the callback. This can be simplified with . allows us to track the callback's reactive dependencies automatically. The watcher above can be rewritten as: Here, the callback will run immediately, there's no need to specify . During its execution, it will automatically track as a dependency (similar to computed properties). Whenever changes, the callback will be run again. With , we no longer need to pass explicitly as the source value. You can check out this example of and reactive data-fetching in action. For examples like these, with only one dependency, the benefit of is relatively small. But for watchers that have multiple dependencies, using removes the burden of having to maintain the list of dependencies manually. In addition, if you need to watch several properties in a nested data structure, may prove more efficient than a deep watcher, as it will only track the properties that are used in the callback, rather than recursively tracking all of them. only tracks dependencies during its synchronous execution. When using it with an async callback, only properties accessed before the first tick will be tracked. and both allow us to reactively perform side effects. Their main difference is the way they track their reactive dependencies:\n‚Ä¢ None only tracks the explicitly watched source. It won't track anything accessed inside the callback. In addition, the callback only triggers when the source has actually changed. separates dependency tracking from the side effect, giving us more precise control over when the callback should fire.\n‚Ä¢ None , on the other hand, combines dependency tracking and side effect into one phase. It automatically tracks every reactive property accessed during its synchronous execution. This is more convenient and typically results in terser code, but makes its reactive dependencies less explicit.\n\nSometimes we may perform side effects, e.g. asynchronous requests, in a watcher:\n\nBut what if changes before the request completes? When the previous request completes, it will still fire the callback with an ID value that is already stale. Ideally, we want to be able to cancel the stale request when changes to a new value.\n\nWe can use the API to register a cleanup function that will be called when the watcher is invalidated and is about to re-run:\n\nNote that is only supported in Vue 3.5+ and must be called during the synchronous execution of a effect function or callback function: you cannot call it after an statement in an async function.\n\nAlternatively, an function is also passed to watcher callbacks as the 3rd argument, and to the effect function as the first argument:\n\nThis works in versions before 3.5. In addition, passed via function argument is bound to the watcher instance so it is not subject to the synchronously constraint of .\n\nWhen you mutate reactive state, it may trigger both Vue component updates and watcher callbacks created by you.\n\nSimilar to component updates, user-created watcher callbacks are batched to avoid duplicate invocations. For example, we probably don't want a watcher to fire a thousand times if we synchronously push a thousand items into an array being watched.\n\nBy default, a watcher's callback is called after parent component updates (if any), and before the owner component's DOM updates. This means if you attempt to access the owner component's own DOM inside a watcher callback, the DOM will be in a pre-update state.\n\nIf you want to access the owner component's DOM in a watcher callback after Vue has updated it, you need to specify the option:\n\nIt's also possible to create a watcher that fires synchronously, before any Vue-managed updates:\n\nWatchers declared synchronously inside or are bound to the owner component instance, and will be automatically stopped when the owner component is unmounted. In most cases, you don't need to worry about stopping the watcher yourself. The key here is that the watcher must be created synchronously: if the watcher is created in an async callback, it won't be bound to the owner component and must be stopped manually to avoid memory leaks. Here's an example: // this one will be automatically stopped To manually stop a watcher, use the returned handle function. This works for both and : // ...later, when no longer needed Note that there should be very few cases where you need to create watchers asynchronously, and synchronous creation should be preferred whenever possible. If you need to wait for some async data, you can make your watch logic conditional instead: // do something when data is loaded"
    },
    {
        "link": "https://stackoverflow.com/questions/42133894/vue-js-how-to-properly-watch-for-nested-data",
        "document": "I'm trying to understand how to properly watch for some prop variation. I have a parent component (.vue files) that receive data from an ajax call, put the data inside an object and use it to render some child component through a v-for directive, below is a simplification of my implementation:\n\nitem objects are like this:\n\nNow, inside my child \"player\" component I'm trying to watch for any item's property variation and I use:\n\nIt works but it seems a bit tricky to me and I was wondering if this is the right way to do it. My goal is to perform some action every time changes or gets new elements or there is some variation inside existing ones. Any suggestions will be appreciated."
    },
    {
        "link": "https://medium.com/@muhammadaqibawan37/navigating-vue-js-watch-insights-for-experienced-developers-e6785cfccac6",
        "document": "This article covers the reasons, and situations in which you should utilize Vue.js watch. Whether you‚Äôre a seasoned Vue.js developer or have some prior experience with Vue.js, this post serves as a valuable resource.\n‚Ä¢ The role of watch in Vue.js üé•\n‚Ä¢ When to use? üïµÔ∏è‚Äç‚ôÇÔ∏è\n\n‚íà Asynchronous operations üîÑ\n\n 1.1. Example Scenario üßê\n‚Ä¢ When to avoid? ‚ö†Ô∏è\n\n1. Avoid Assigning values inside watch üö´ \n\n1.1. Example Scenario ü§ñ\n\n2. Avoid Directly Mutating Other Data Properties ‚ùå\n\n3. Avoid Heavy Logic/Control Flow in Watch Handlers ü§Ø\n\nWith Vue.js Watch, we can create custom reactions to changes in reactive state, ensuring our app‚Äôs user interface is up-to-date and dynamic. Since Vue.js encourages a declarative approach to UI development, the watch option aligns more with an imperative programming style. Therefore, it‚Äôs advisable to use watchers cautiously or applying them only when the requirements align with their primary purpose\n\nThe Role of Watch in Vue.js üé•\n\nThe primary role of the watch option in Vue.js is to monitor changes in reactive state or data properties and trigger a callback to execute side effects or asynchronous actions in response to those changes. However, the term ‚Äúside effects‚Äù can be ambiguous, and not all side effects are welcomed to be run in watch. It‚Äôs essential to clarify what kinds of side effects are recommended and what should be avoided.\n\nWhen to Use Vue.js Watch? üïµÔ∏è‚Äç‚ôÇÔ∏è\n\nThe watch feature offers versatility in monitoring different types of data changes. It can be applied to a reactive state, prop, route, specific reactive state, or changes in nested properties and perform side effects or actions in response to those changes. However, the term ‚Äúside effects‚Äù is broad and covers a range of actions, including simple tasks like assigning a variable or displaying a notification. Yet, it‚Äôs not welcomed to use watches for such actions. So performing asynchronous tasks, such as making API calls or fetching data from a server, should be the primary use case for watch.\n\nSuppose we encounter a situation requiring the use of the watch option to initiate API calls then best would be to create a dedicated function for handling data/assigning some variables and data assigning must be done in a separate function.\n\nFor instance, in a user reporting dashboard, there is a parent component called UserReportDashboard responsible for managing user selections, and a child component named UserReportDetails responsible for displaying detailed reports for the selected user. The UserReportDetails component receives the userId prop and watches for changes in the selected userId using the watch option. When the userId changes, it triggers the fetchUserReport method.\n\nHere we watch for changes in a prop userId. When the property changes, instead of directly mutating or assigning fetchUserReport response to some variable in watch, we call the function to do it indirectly. This way, it would be in a more predictable and efficient manner.\n\nIn certain parent-child communication scenarios, deriving local state from received props is common. While using a watch to update these derived properties or assign values to other variables when a prop changes is possible, it might not align with the primary idea of working with reactive state in Vue.js and could lead to losing the single source of truth.\n\nVue.js offers computed properties tailored for this purpose, presenting a more efficient and readable alternative.\n\nTake, for example, a PageItem component receiving a prop named someValue from its parent PageList. By utilizing computed properties to derive local data from this prop maintains a single source of truth. With computed properties‚Äô getter/setter, changes in someValue ensure the parent always retains the most up-to-date prop value\n\nThe ideal solution in such scenarios depends on the specific context, example scenario could be as follows.\n\nFor this scenario we have better alternative\n\nUsing computed properties ensures maintaining a single source of truth and enhances code readability as well.\n\nWe should not directly mutate or assign values to other data properties within a watch handler:\n\nIt‚Äôs better to create separate functions for better readability and maintainability:\n\nThank you for reading! These practices are commonly followed in our day-to-day coding when working with Vue.js and its watch feature. However, it‚Äôs important to note that every project or team may have its own coding guidelines, so usage should be adapted accordingly.\n\nFeel free to share your approaches and experiences in using Vue.js watch. Your feedback on this post is also welcome!"
    },
    {
        "link": "https://vuejs.org/v2/style-guide",
        "document": "This is the official style guide for Vue-specific code. If you use Vue in a project, it‚Äôs a great reference to avoid errors, bikeshedding, and anti-patterns. However, we don‚Äôt believe that any style guide is ideal for all teams or projects, so mindful deviations are encouraged based on past experience, the surrounding tech stack, and personal values.\n\nFor the most part, we also avoid suggestions about JavaScript or HTML in general. We don‚Äôt mind whether you use semicolons or trailing commas. We don‚Äôt mind whether your HTML uses single-quotes or double-quotes for attribute values. Some exceptions will exist however, where we‚Äôve found that a particular pattern is helpful in the context of Vue.\n\nThese rules help prevent errors, so learn and abide by them at all costs. Exceptions may exist, but should be very rare and only be made by those with expert knowledge of both JavaScript and Vue.\n\nThese rules have been found to improve readability and/or developer experience in most projects. Your code will still run if you violate them, but violations should be rare and well-justified.\n\nWhere multiple, equally good options exist, an arbitrary choice can be made to ensure consistency. In these rules, we describe each acceptable option and suggest a default choice. That means you can feel free to make a different choice in your own codebase, as long as you‚Äôre consistent and have a good reason. Please do have a good reason though! By adapting to the community standard, you will:\n‚Ä¢ train your brain to more easily parse most of the community code you encounter\n‚Ä¢ be able to copy and paste most community code examples without modification\n‚Ä¢ often find new hires are already accustomed to your preferred coding style, at least in regards to Vue\n\nSome features of Vue exist to accommodate rare edge cases or smoother migrations from a legacy code base. When overused however, they can make your code more difficult to maintain or even become a source of bugs. These rules shine a light on potentially risky features, describing when and why they should be avoided.\n\nComponent names should always be multi-word, except for root components, and built-in components provided by Vue, such as or .\n\nThis prevents conflicts with existing and future HTML elements, since all HTML elements are a single word.\n\nWhen using the property on a component (i.e. anywhere except on ), the value must be a function that returns an object.\n\nProp definitions should be as detailed as possible.\n\nIn committed code, prop definitions should always be as detailed as possible, specifying at least type(s).\n\nAlways use with .\n\nwith is always required on components, in order to maintain internal component state down the subtree. Even for elements though, it‚Äôs a good practice to maintain predictable behavior, such as object constancy in animations.\n\nNever use on the same element as .\n\nThere are two common cases where this can be tempting:\n‚Ä¢ None To filter items in a list (e.g. ). In these cases, replace with a new computed property that returns your filtered list (e.g. ).\n‚Ä¢ None To avoid rendering a list if it should be hidden (e.g. ). In these cases, move the to a container element (e.g. , ).\n\nFor applications, styles in a top-level component and in layout components may be global, but all other components should always be scoped.\n\nThis is only relevant for single-file components. It does not require that the attribute be used. Scoping could be through CSS modules, a class-based strategy such as BEM, or another library/convention.\n\nComponent libraries, however, should prefer a class-based strategy instead of using the attribute.\n\nThis makes overriding internal styles easier, with human-readable class names that don‚Äôt have too high specificity, but are still very unlikely to result in a conflict.\n\nUse module scoping to keep private functions inaccessible from the outside. If that‚Äôs not possible, always use the prefix for custom private properties in a plugin, mixin, etc that should not be considered public API. Then to avoid conflicts with code by other authors, also include a named scope (e.g. ).\n\nWhenever a build system is available to concatenate files, each component should be in its own file.\n\nThis helps you to more quickly find a component when you need to edit it or review how to use it.\n\nFilenames of single-file components should either be always PascalCase or always kebab-case.\n\nPascalCase works best with autocompletion in code editors, as it‚Äôs consistent with how we reference components in JS(X) and templates, wherever possible. However, mixed case filenames can sometimes create issues on case-insensitive file systems, which is why kebab-case is also perfectly acceptable.\n\nBase components (a.k.a. presentational, dumb, or pure components) that apply app-specific styling and conventions should all begin with a specific prefix, such as , , or .\n\nComponents that should only ever have a single active instance should begin with the prefix, to denote that there can be only one.\n\nThis does not mean the component is only used in a single page, but it will only be used once per page. These components never accept any props, since they are specific to your app, not their context within your app. If you find the need to add props, it‚Äôs a good indication that this is actually a reusable component that is only used once per page for now.\n\nChild components that are tightly coupled with their parent should include the parent component name as a prefix.\n\nIf a component only makes sense in the context of a single parent component, that relationship should be evident in its name. Since editors typically organize files alphabetically, this also keeps these related files next to each other.\n\nComponent names should start with the highest-level (often most general) words and end with descriptive modifying words.\n\nComponents with no content should be self-closing in single-file components, string templates, and JSX - but never in DOM templates.\n\nComponents that self-close communicate that they not only have no content, but are meant to have no content. It‚Äôs the difference between a blank page in a book and one labeled ‚ÄúThis page intentionally left blank.‚Äù Your code is also cleaner without the unnecessary closing tag.\n\nUnfortunately, HTML doesn‚Äôt allow custom elements to be self-closing - only official ‚Äúvoid‚Äù elements. That‚Äôs why the strategy is only possible when Vue‚Äôs template compiler can reach the template before the DOM, then serve the DOM spec-compliant HTML.\n\nIn most projects, component names should always be PascalCase in single-file components and string templates - but kebab-case in DOM templates.\n\nPascalCase has a few advantages over kebab-case:\n‚Ä¢ Editors can autocomplete component names in templates, because PascalCase is also used in JavaScript.\n‚Ä¢ is more visually distinct from a single-word HTML element than , because there are two character differences (the two capitals), rather than just one (a hyphen).\n‚Ä¢ If you use any non-Vue custom elements in your templates, such as a web component, PascalCase ensures that your Vue components remain distinctly visible.\n\nUnfortunately, due to HTML‚Äôs case insensitivity, DOM templates must still use kebab-case.\n\nAlso note that if you‚Äôve already invested heavily in kebab-case, consistency with HTML conventions and being able to use the same casing across all your projects may be more important than the advantages listed above. In those cases, using kebab-case everywhere is also acceptable.\n\nComponent names in JS/JSX should always be PascalCase, though they may be kebab-case inside strings for simpler applications that only use global component registration through .\n\nThe autocompletion in editors make the cost of writing longer names very low, while the clarity they provide is invaluable. Uncommon abbreviations, in particular, should always be avoided.\n\nProp names should always use camelCase during declaration, but kebab-case in templates and JSX.\n\nWe‚Äôre simply following the conventions of each language. Within JavaScript, camelCase is more natural. Within HTML, kebab-case is.\n\nElements with multiple attributes should span multiple lines, with one attribute per line.\n\nIn JavaScript, splitting objects with multiple properties over multiple lines is widely considered a good convention, because it‚Äôs much easier to read. Our templates and JSX deserve the same consideration.\n\nComponent templates should only include simple expressions, with more complex expressions refactored into computed properties or methods.\n\nComplex expressions in your templates make them less declarative. We should strive to describe what should appear, not how we‚Äôre computing that value. Computed properties and methods also allow the code to be reused.\n\nComplex computed properties should be split into as many simpler properties as possible.\n\nNon-empty HTML attribute values should always be inside quotes (single or double, whichever is not used in JS).\n\nWhile attribute values without any spaces are not required to have quotes in HTML, this practice often leads to avoiding spaces, making attribute values less readable.\n\nDirective shorthands ( for , for and for ) should be used always or never.\n\nThis is the default order we recommend for component options. They‚Äôre split into categories, so you‚Äôll know where to add new properties from plugins.\n‚Ä¢ None Component Type (changes the type of the component)\n‚Ä¢ None Template Modifiers (changes the way templates are compiled)\n‚Ä¢ None Template Dependencies (assets used in the template)\n‚Ä¢ None Interface (the interface to the component)\n‚Ä¢ \n‚Ä¢ Lifecycle Events (in the order they are called)\n‚Ä¢ None Rendering (the declarative description of the component output)\n\nThe attributes of elements (including components) should be ordered consistently.\n\nThis is the default order we recommend for component options. They‚Äôre split into categories, so you‚Äôll know where to add custom attributes and directives.\n‚Ä¢ None List Rendering (creates multiple variations of the same element)\n‚Ä¢ None Conditionals (whether the element is rendered/shown)\n‚Ä¢ None Render Modifiers (changes the way the element renders)\n‚Ä¢ None Content (overrides the content of the element)\n\nYou may want to add one empty line between multi-line properties, particularly if the options can no longer fit on your screen without scrolling.\n\nWhen components begin to feel cramped or difficult to read, adding spaces between multi-line properties can make them easier to skim again. In some editors, such as Vim, formatting options like this can also make them easier to navigate with the keyboard.\n\nSingle-file components should always order , , and tags consistently, with last, because at least one of the other two is always necessary.\n\n/ / without use with caution\n\nIt‚Äôs usually best to use with + , if they are the same element type (e.g. both elements).\n\nBy default, Vue updates the DOM as efficiently as possible. That means when switching between elements of the same type, it simply patches the existing element, rather than removing it and adding a new one in its place. This can have unintended consequences if these elements should not actually be considered the same.\n\nElement selectors with use with caution\n\nElement selectors should be avoided with .\n\nPrefer class selectors over element selectors in styles, because large numbers of element selectors are slow.\n\nProps and events should be preferred for parent-child component communication, instead of or mutating props.\n\nAn ideal Vue application is props down, events up. Sticking to this convention makes your components much easier to understand. However, there are edge cases where prop mutation or can simplify two components that are already deeply coupled.\n\nThe problem is, there are also many simple cases where these patterns may offer convenience. Beware: do not be seduced into trading simplicity (being able to understand the flow of your state) for short-term convenience (writing less code).\n\nVuex should be preferred for global state management, instead of or a global event bus.\n\nManaging state on and/or using a global event bus can be convenient for very simple cases, but it is not appropriate for most applications.\n\nVuex is the official flux-like implementation for Vue, and offers not only a central place to manage state, but also tools for organizing, tracking, and debugging state changes. It integrates well in the Vue ecosystem (including full Vue DevTools support)."
    },
    {
        "link": "https://stackoverflow.com/questions/59163859/best-practice-for-vue-typescript-component-class-property-initializers",
        "document": "I am seeing a lot of conflicting documentation about Vue + Typescript component classes.\n\nWhere does one define properties? In the annotation as outlined here? As annotated instance properties as outlined here?\n\nWhere does one initialized defined properties? In the constructor? In the field-level property definition?\n\nIs there a definitive, up-to-date reference for these things, or an up-to-date sample app?\n\nHere's what I have now:\n\nThis works, but I'm receiving these warnings in the browser:\n\n[Vue warn]: Avoid mutating a prop directly since the value will be overwritten whenever the parent component re-renders. Instead, use a data or computed property based on the prop's value. Prop being mutated: \"q\""
    },
    {
        "link": "https://vuejs.org/guide/essentials/watchers.html",
        "document": "Computed properties allow us to declaratively compute derived values. However, there are cases where we need to perform \"side effects\" in reaction to state changes - for example, mutating the DOM, or changing another piece of state based on the result of an async operation.\n\nWith the Options API, we can use the option to trigger a function whenever a reactive property changes: // whenever question changes, this function will run 'Error! Could not reach the API. ' The option also supports a dot-delimited path as the key: // Note: only simple paths. Expressions are not supported.\n\nWith Composition API, we can use the function to trigger a callback whenever a piece of reactive state changes: 'Error! Could not reach the API. ' 's first argument can be different types of reactive \"sources\": it can be a ref (including computed refs), a reactive object, a getter function, or an array of multiple sources: Do note that you can't watch a property of a reactive object like this: // this won't work because we are passing a number to watch()\n\nWhen you call directly on a reactive object, it will implicitly create a deep watcher - the callback will be triggered on all nested mutations: // Note: `newValue` will be equal to `oldValue` here // because they both point to the same object! This should be differentiated with a getter that returns a reactive object - in the latter case, the callback will only fire if the getter returns a different object: // fires only when state.someObject is replaced You can, however, force the second case into a deep watcher by explicitly using the option: // Note: `newValue` will be equal to `oldValue` here // *unless* state.someObject has been replaced\n\nIn Vue 3.5+, the option can also be a number indicating the max traversal depth - i.e. how many levels should Vue traverse an object's nested properties.\n\nis lazy by default: the callback won't be called until the watched source has changed. But in some cases we may want the same callback logic to be run eagerly - for example, we may want to fetch some initial data, and then re-fetch the data whenever relevant state changes.\n\nWatcher's callback will execute whenever the watched source changes. If you want the callback to trigger only once when the source changes, use the option.\n\nIt is common for the watcher callback to use exactly the same reactive state as the source. For example, consider the following code, which uses a watcher to load a remote resource whenever the ref changes: In particular, notice how the watcher uses twice, once as the source and then again inside the callback. This can be simplified with . allows us to track the callback's reactive dependencies automatically. The watcher above can be rewritten as: Here, the callback will run immediately, there's no need to specify . During its execution, it will automatically track as a dependency (similar to computed properties). Whenever changes, the callback will be run again. With , we no longer need to pass explicitly as the source value. You can check out this example of and reactive data-fetching in action. For examples like these, with only one dependency, the benefit of is relatively small. But for watchers that have multiple dependencies, using removes the burden of having to maintain the list of dependencies manually. In addition, if you need to watch several properties in a nested data structure, may prove more efficient than a deep watcher, as it will only track the properties that are used in the callback, rather than recursively tracking all of them. only tracks dependencies during its synchronous execution. When using it with an async callback, only properties accessed before the first tick will be tracked. and both allow us to reactively perform side effects. Their main difference is the way they track their reactive dependencies:\n‚Ä¢ None only tracks the explicitly watched source. It won't track anything accessed inside the callback. In addition, the callback only triggers when the source has actually changed. separates dependency tracking from the side effect, giving us more precise control over when the callback should fire.\n‚Ä¢ None , on the other hand, combines dependency tracking and side effect into one phase. It automatically tracks every reactive property accessed during its synchronous execution. This is more convenient and typically results in terser code, but makes its reactive dependencies less explicit.\n\nSometimes we may perform side effects, e.g. asynchronous requests, in a watcher:\n\nBut what if changes before the request completes? When the previous request completes, it will still fire the callback with an ID value that is already stale. Ideally, we want to be able to cancel the stale request when changes to a new value.\n\nWe can use the API to register a cleanup function that will be called when the watcher is invalidated and is about to re-run:\n\nNote that is only supported in Vue 3.5+ and must be called during the synchronous execution of a effect function or callback function: you cannot call it after an statement in an async function.\n\nAlternatively, an function is also passed to watcher callbacks as the 3rd argument, and to the effect function as the first argument:\n\nThis works in versions before 3.5. In addition, passed via function argument is bound to the watcher instance so it is not subject to the synchronously constraint of .\n\nWhen you mutate reactive state, it may trigger both Vue component updates and watcher callbacks created by you.\n\nSimilar to component updates, user-created watcher callbacks are batched to avoid duplicate invocations. For example, we probably don't want a watcher to fire a thousand times if we synchronously push a thousand items into an array being watched.\n\nBy default, a watcher's callback is called after parent component updates (if any), and before the owner component's DOM updates. This means if you attempt to access the owner component's own DOM inside a watcher callback, the DOM will be in a pre-update state.\n\nIf you want to access the owner component's DOM in a watcher callback after Vue has updated it, you need to specify the option:\n\nIt's also possible to create a watcher that fires synchronously, before any Vue-managed updates:\n\nWatchers declared synchronously inside or are bound to the owner component instance, and will be automatically stopped when the owner component is unmounted. In most cases, you don't need to worry about stopping the watcher yourself. The key here is that the watcher must be created synchronously: if the watcher is created in an async callback, it won't be bound to the owner component and must be stopped manually to avoid memory leaks. Here's an example: // this one will be automatically stopped To manually stop a watcher, use the returned handle function. This works for both and : // ...later, when no longer needed Note that there should be very few cases where you need to create watchers asynchronously, and synchronous creation should be preferred whenever possible. If you need to wait for some async data, you can make your watch logic conditional instead: // do something when data is loaded"
    },
    {
        "link": "https://stackoverflow.com/questions/69979113/vue-js-watch-particular-properties-of-the-object-and-load-data-on-change",
        "document": "I have Vue component with prop named , it is an object with a bunch of properties. And it changes often.\n\nThe component should load new data when only properties and of are changed. The one approach is to watch the whole product and load data when it is changed. But it produces unnecessary requests because and may not have changed.\n\nAnother idea is to watch and , and call the same function to load data in each watcher. But it may happen that both and changed in the new version of the product, it would trigger 2 calls.\n\nWill it be a good solution to use a debounced function for data load?\n\nOr rather use single watcher for the whole and compare new and stringified with their old stringified versions to determine if data loading should be triggered?"
    },
    {
        "link": "https://medium.com/@muhammadaqibawan37/navigating-vue-js-watch-insights-for-experienced-developers-e6785cfccac6",
        "document": "This article covers the reasons, and situations in which you should utilize Vue.js watch. Whether you‚Äôre a seasoned Vue.js developer or have some prior experience with Vue.js, this post serves as a valuable resource.\n‚Ä¢ The role of watch in Vue.js üé•\n‚Ä¢ When to use? üïµÔ∏è‚Äç‚ôÇÔ∏è\n\n‚íà Asynchronous operations üîÑ\n\n 1.1. Example Scenario üßê\n‚Ä¢ When to avoid? ‚ö†Ô∏è\n\n1. Avoid Assigning values inside watch üö´ \n\n1.1. Example Scenario ü§ñ\n\n2. Avoid Directly Mutating Other Data Properties ‚ùå\n\n3. Avoid Heavy Logic/Control Flow in Watch Handlers ü§Ø\n\nWith Vue.js Watch, we can create custom reactions to changes in reactive state, ensuring our app‚Äôs user interface is up-to-date and dynamic. Since Vue.js encourages a declarative approach to UI development, the watch option aligns more with an imperative programming style. Therefore, it‚Äôs advisable to use watchers cautiously or applying them only when the requirements align with their primary purpose\n\nThe Role of Watch in Vue.js üé•\n\nThe primary role of the watch option in Vue.js is to monitor changes in reactive state or data properties and trigger a callback to execute side effects or asynchronous actions in response to those changes. However, the term ‚Äúside effects‚Äù can be ambiguous, and not all side effects are welcomed to be run in watch. It‚Äôs essential to clarify what kinds of side effects are recommended and what should be avoided.\n\nWhen to Use Vue.js Watch? üïµÔ∏è‚Äç‚ôÇÔ∏è\n\nThe watch feature offers versatility in monitoring different types of data changes. It can be applied to a reactive state, prop, route, specific reactive state, or changes in nested properties and perform side effects or actions in response to those changes. However, the term ‚Äúside effects‚Äù is broad and covers a range of actions, including simple tasks like assigning a variable or displaying a notification. Yet, it‚Äôs not welcomed to use watches for such actions. So performing asynchronous tasks, such as making API calls or fetching data from a server, should be the primary use case for watch.\n\nSuppose we encounter a situation requiring the use of the watch option to initiate API calls then best would be to create a dedicated function for handling data/assigning some variables and data assigning must be done in a separate function.\n\nFor instance, in a user reporting dashboard, there is a parent component called UserReportDashboard responsible for managing user selections, and a child component named UserReportDetails responsible for displaying detailed reports for the selected user. The UserReportDetails component receives the userId prop and watches for changes in the selected userId using the watch option. When the userId changes, it triggers the fetchUserReport method.\n\nHere we watch for changes in a prop userId. When the property changes, instead of directly mutating or assigning fetchUserReport response to some variable in watch, we call the function to do it indirectly. This way, it would be in a more predictable and efficient manner.\n\nIn certain parent-child communication scenarios, deriving local state from received props is common. While using a watch to update these derived properties or assign values to other variables when a prop changes is possible, it might not align with the primary idea of working with reactive state in Vue.js and could lead to losing the single source of truth.\n\nVue.js offers computed properties tailored for this purpose, presenting a more efficient and readable alternative.\n\nTake, for example, a PageItem component receiving a prop named someValue from its parent PageList. By utilizing computed properties to derive local data from this prop maintains a single source of truth. With computed properties‚Äô getter/setter, changes in someValue ensure the parent always retains the most up-to-date prop value\n\nThe ideal solution in such scenarios depends on the specific context, example scenario could be as follows.\n\nFor this scenario we have better alternative\n\nUsing computed properties ensures maintaining a single source of truth and enhances code readability as well.\n\nWe should not directly mutate or assign values to other data properties within a watch handler:\n\nIt‚Äôs better to create separate functions for better readability and maintainability:\n\nThank you for reading! These practices are commonly followed in our day-to-day coding when working with Vue.js and its watch feature. However, it‚Äôs important to note that every project or team may have its own coding guidelines, so usage should be adapted accordingly.\n\nFeel free to share your approaches and experiences in using Vue.js watch. Your feedback on this post is also welcome!"
    },
    {
        "link": "https://vuejs.org/guide/essentials/reactivity-fundamentals.html",
        "document": "With the Options API, we use the option to declare reactive state of a component. The option value should be a function that returns an object. Vue will call the function when creating a new component instance, and wrap the returned object in its reactivity system. Any top-level properties of this object are proxied on the component instance ( in methods and lifecycle hooks): // `mounted` is a lifecycle hook which we will explain later // `this` refers to the component instance. // data can be mutated as well These instance properties are only added when the instance is first created, so you need to ensure they are all present in the object returned by the function. Where necessary, use , or some other placeholder value for properties where the desired value isn't yet available. It is possible to add a new property directly to without including it in . However, properties added this way will not be able to trigger reactive updates. Vue uses a prefix when exposing its own built-in APIs via the component instance. It also reserves the prefix for internal properties. You should avoid using names for top-level properties that start with either of these characters. In Vue 3, data is made reactive by leveraging JavaScript Proxies. Users coming from Vue 2 should be aware of the following edge case: When you access after assigning it, the value is a reactive proxy of the original . Unlike in Vue 2, the original is left intact and will not be made reactive: make sure to always access reactive state as a property of .\n\nIn Composition API, the recommended way to declare reactive state is using the function: takes the argument and returns it wrapped within a ref object with a property: To access refs in a component's template, declare and return them from a component's function: // `setup` is a special hook dedicated for the Composition API. // expose the ref to the template Notice that we did not need to append when using the ref in the template. For convenience, refs are automatically unwrapped when used inside templates (with a few caveats). You can also mutate a ref directly in event handlers: For more complex logic, we can declare functions that mutate refs in the same scope and expose them as methods alongside the state: // .value is needed in JavaScript // don't forget to expose the function as well. Exposed methods can then be used as event handlers: Here's the example live on Codepen, without using any build tools. Manually exposing state and methods via can be verbose. Luckily, it can be avoided when using Single-File Components (SFCs). We can simplify the usage with : Top-level imports, variables and functions declared in are automatically usable in the template of the same component. Think of the template as a JavaScript function declared in the same scope - it naturally has access to everything declared alongside it. For the rest of the guide, we will be primarily using SFC + syntax for the Composition API code examples, as that is the most common usage for Vue developers. If you are not using SFC, you can still use Composition API with the option. You might be wondering why we need refs with the instead of plain variables. To explain that, we will need to briefly discuss how Vue's reactivity system works. When you use a ref in a template, and change the ref's value later, Vue automatically detects the change and updates the DOM accordingly. This is made possible with a dependency-tracking based reactivity system. When a component is rendered for the first time, Vue tracks every ref that was used during the render. Later on, when a ref is mutated, it will trigger a re-render for components that are tracking it. In standard JavaScript, there is no way to detect the access or mutation of plain variables. However, we can intercept the get and set operations of an object's properties using getter and setter methods. The property gives Vue the opportunity to detect when a ref has been accessed or mutated. Under the hood, Vue performs the tracking in its getter, and performs triggering in its setter. Conceptually, you can think of a ref as an object that looks like this: Another nice trait of refs is that unlike plain variables, you can pass refs into functions while retaining access to the latest value and the reactivity connection. This is particularly useful when refactoring complex logic into reusable code. The reactivity system is discussed in more details in the Reactivity in Depth section.\n\nTo add methods to a component instance we use the option. This should be an object containing the desired methods: // methods can be called in lifecycle hooks, or other methods! Vue automatically binds the value for so that it always refers to the component instance. This ensures that a method retains the correct value if it's used as an event listener or callback. You should avoid using arrow functions when defining , as that prevents Vue from binding the appropriate value: // BAD: no `this` access here! Just like all other properties of the component instance, the are accessible from within the component's template. Inside a template they are most commonly used as event listeners: In the example above, the method will be called when the is clicked.\n\nRefs can hold any value type, including deeply nested objects, arrays, or JavaScript built-in data structures like . A ref will make its value deeply reactive. This means you can expect changes to be detected even when you mutate nested objects or arrays: // these will work as expected. Non-primitive values are turned into reactive proxies via , which is discussed below. It is also possible to opt-out of deep reactivity with shallow refs. For shallow refs, only access is tracked for reactivity. Shallow refs can be used for optimizing performance by avoiding the observation cost of large objects, or in cases where the inner state is managed by an external library.\n\nWhen you mutate reactive state, the DOM is updated automatically. However, it should be noted that the DOM updates are not applied synchronously. Instead, Vue buffers them until the \"next tick\" in the update cycle to ensure that each component updates only once no matter how many state changes you have made.\n\nTo wait for the DOM update to complete after a state change, you can use the nextTick() global API:\n\nThere is another way to declare reactive state, with the API. Unlike a ref which wraps the inner value in a special object, makes an object itself reactive: Reactive objects are JavaScript Proxies and behave just like normal objects. The difference is that Vue is able to intercept the access and mutation of all properties of a reactive object for reactivity tracking and triggering. converts the object deeply: nested objects are also wrapped with when accessed. It is also called by internally when the ref value is an object. Similar to shallow refs, there is also the API for opting-out of deep reactivity. It is important to note that the returned value from is a Proxy of the original object, which is not equal to the original object: // proxy is NOT equal to the original. Only the proxy is reactive - mutating the original object will not trigger updates. Therefore, the best practice when working with Vue's reactivity system is to exclusively use the proxied versions of your state. To ensure consistent access to the proxy, calling on the same object always returns the same proxy, and calling on an existing proxy also returns that same proxy: // calling reactive() on the same object returns the same proxy This rule applies to nested objects as well. Due to deep reactivity, nested objects inside a reactive object are also proxies: The API has a few limitations:\n‚Ä¢ None Limited value types: it only works for object types (objects, arrays, and collection types such as and ). It cannot hold primitive types such as , or .\n‚Ä¢ None Cannot replace entire object: since Vue's reactivity tracking works over property access, we must always keep the same reference to the reactive object. This means we can't easily \"replace\" a reactive object because the reactivity connection to the first reference is lost: // the above reference ({ count: 0 }) is no longer being tracked\n‚Ä¢ None Not destructure-friendly: when we destructure a reactive object's primitive type property into local variables, or when we pass that property into a function, we will lose the reactivity connection: // count is disconnected from state.count when destructured. // won't be able to track changes to state.count // we have to pass the entire object in to retain reactivity Due to these limitations, we recommend using as the primary API for declaring reactive state. A ref is automatically unwrapped when accessed or mutated as a property of a reactive object. In other words, it behaves like a normal property: If a new ref is assigned to a property linked to an existing ref, it will replace the old ref: // original ref is now disconnected from state.count Ref unwrapping only happens when nested inside a deep reactive object. It does not apply when it is accessed as a property of a shallow reactive object. Unlike reactive objects, there is no unwrapping performed when the ref is accessed as an element of a reactive array or a native collection type like : Ref unwrapping in templates only applies if the ref is a top-level property in the template render context. In the example below, and are top-level properties, but is not: Therefore, this expression works as expected: ...while this one does NOT: The rendered result will be because is not unwrapped when evaluating the expression and remains a ref object. To fix this, we can destructure into a top-level property: Now the render result will be . Another thing to note is that a ref does get unwrapped if it is the final evaluated value of a text interpolation (i.e. a tag), so the following will render : This is just a convenience feature of text interpolation and is equivalent to ."
    },
    {
        "link": "https://vueschool.io/articles/vuejs-tutorials/mastering-reactivity-and-data-updates-in-vue-js-3",
        "document": "Vue.js 3 goes beyond the standard reactive approach, offering a more granular and efficient system for managing your application's state. In this article, we'll unveil the secrets behind Vue.js 3's reactivity magic, empowering you to craft web applications that feel truly alive.\n\nAt its core, Vue leverages JavaScript's Proxies API to track changes in your data structures. These data structures, specifically objects and arrays, become \"reactive\" when wrapped using Vue's built-in APIs like and . Any modifications made to the properties within these reactive structures are automatically detected by Vue, triggering a re-render of the affected components.\n\nDeciding which to use between ref and reactive is completely up to you. Both APIs are achieving reactivity but each has its unique use-cases. But as a rule of thumb, ref is suitable for the majority of use-cases so it‚Äôs recommended to just always use ref.\n\nIn this code example, watch is used to execute a callback whenever the reactive property changes. The callback function logs the old and new values of whenever it changes.\n\nIn this example, watchEffect is used to reactively compute the sum based on changes to both firstNumber and secondNumber. The callback function inside accesses both and , demonstrating the ability to work with multiple reactive dependencies within the same callback function.\n\nComputed properties in Vue.js are functions that calculate values based on reactive data sources, such as or . Whenever these data sources change, computed properties automatically recalculate their values, ensuring that the template reflects the most up-to-date information. This feature eliminates the need for manual calculations, streamlining development and guaranteeing that the UI stays synchronized with the underlying data.\n\nOne key advantage of computed properties is their caching mechanism. They only recalculate when their dependencies change. While this feature helps in optimizing performance by avoiding unnecessary computations, it also leads to some limitations.\n\nThe property attempts to retrieve the current time using or . At the first glimpse, you would think that the computed property will update its value every time has changed. However, there's a catch: computed properties only re-evaluate when their reactive dependencies change.\n\nIn this case, both methods (Date.now() and new Date()) are not reactive, meaning Vue doesn't automatically detect changes within them. As a result, the computed property won't update with the current time at regular intervals, rendering the clock static.\n\nThis article delved into the heart of Vue.js 3: its reactivity system. We explored the fundamentals of and for managing reactive data, ensuring your UI seamlessly reflects data changes. We distinguished between properties, ideal for deriving values from reactive sources, and / , suited for side effects and complex scenarios."
    }
]