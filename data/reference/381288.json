[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API",
        "document": "The WebSocket API makes it possible to open a two-way interactive communication session between the user's browser and a server. With this API, you can send messages to a server and receive responses without having to poll the server for a reply.\n\nThe WebSocket API provides two alternative mechanisms for creating and using web socket connections: the interface and the interface.\n• The interface is stable and has good browser and server support. However it doesn't support backpressure. As a result, when messages arrive faster than the application can process them it will either fill up the device's memory by buffering those messages, become unresponsive due to 100% CPU usage, or both.\n• The interface is a -based alternative to . It uses the Streams API to handle receiving and sending messages, meaning that socket connections can take advantage of stream backpressure automatically, regulating the speed of reading or writing to avoid bottlenecks in the application. However, is non-standard and currently only supported in one rendering engine.\n\nAdditionally, the WebTransport API is expected to replace the WebSocket API for many applications. WebTransport is a versatile, low-level API that provides backpressure and many other features not supported by either or , such as unidirectional streams, out-of-order delivery, and unreliable data transmission via datagrams. WebTransport is more complex to use than WebSockets and its cross-browser support is not as wide, but it enables the implementation of sophisticated solutions. If standard WebSocket connections are a good fit for your use case and you need wide browser compatibility, you should employ the WebSockets API to get up and running quickly. However, if your application requires a non-standard custom solution, then you should use the WebTransport API."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_client_applications",
        "document": "In order to communicate using the WebSocket protocol, you need to create a object; this will automatically attempt to open the connection to the server. The WebSocket constructor accepts one required and one optional parameter: The URL to which to connect; this should be the URL to which the WebSocket server will respond. This should use the URL scheme , although some software may allow you to use the insecure for a local connection. Relative URL values and and schemes are also allowed in most recent browser versions. Either a single protocol string or an array of protocol strings. These strings are used to indicate sub-protocols, so that a single server can implement multiple WebSocket sub-protocols (for example, you might want one server to be able to handle different types of interactions depending on the specified ). If you don't specify a protocol string, an empty string is assumed. The constructor will throw a if the destination doesn't allow access. This may happen if you attempt to use an insecure connection (most user agents now require a secure link for all WebSocket connections unless they're on the same device or possibly on the same network).\n\nIf an error occurs while attempting to connect, an event is first sent to the object (thereby invoking any handlers), followed by a event that indicates the reason for the connection's closing. The browser may also output to its console a more descriptive error message as well as a closing code as defined in RFC 6455, Section 7.4 through the .\n\nThis simple example creates a new WebSocket, connecting to the server at . A custom protocol of \"protocolOne\" is named in the request for the socket in this example, though this can be omitted. On return, is . The will become once the connection is ready to transfer data. If you want to open a connection and are flexible about the protocols you support, you can specify an array of protocols: Once the connection is established (that is, is ), will tell you which protocol the server selected. Establishing a WebSocket relies on the HTTP Upgrade mechanism, so the request for the protocol upgrade is implicit when we address the web server as or .\n\nOnce you've opened your connection, you can begin transmitting data to the server. To do this, call the object's method for each message you want to send: exampleSocket.send(\"Here's some text that the server is urgently awaiting!\"); You can send data as a string, , or . As establishing a connection is asynchronous and prone to failure there is no guarantee that calling the method immediately after creating a WebSocket object will be successful. We can at least be sure that attempting to send data only takes place once a connection is established by defining an event handler to do the work: exampleSocket.onopen = (event) => { exampleSocket.send(\"Here's some text that the server is urgently awaiting!\"); };\n\nLet's consider the chat client application first alluded to in Using JSON to transmit objects. There are assorted types of data packets the client might receive, such as: The code that interprets these incoming messages might look like this: exampleSocket.onmessage = (event) => { const f = document.getElementById(\"chat-box\").contentDocument; let text = \"\"; const msg = JSON.parse(event.data); const time = new Date(msg.date); const timeStr = time.toLocaleTimeString(); switch (msg.type) { case \"id\": clientID = msg.id; setUsername(); break; case \"username\": text = `User <em>${msg.name}</em> signed in at ${timeStr}<br>`; break; case \"message\": text = `(${timeStr}) ${msg.name} : ${msg.text} <br>`; break; case \"reject-username\": text = `Your username has been set to <em>${msg.name}</em> because the name you chose is in use.<br>`; break; case \"user-list\": document.getElementById(\"user-list-box\").innerText = msg.users.join(\"\n\n\"); break; } if (text.length) { f.write(text); document.getElementById(\"chat-box\").contentWindow.scrollByPages(1); } }; Here we use to convert the JSON object back into the original object, then examine and act upon its contents."
    },
    {
        "link": "https://javascript.info/websocket",
        "document": "The protocol, described in the specification RFC 6455, provides a way to exchange data between browser and server via a persistent connection. The data can be passed in both directions as “packets”, without breaking the connection and the need of additional HTTP-requests.\n\nWebSocket is especially great for services that require continuous data exchange, e.g. online games, real-time trading systems and so on.\n\nTo open a websocket connection, we need to create using the special protocol in the url:\n\nThere’s also encrypted protocol. It’s like HTTPS for websockets.\n\nOnce the socket is created, we should listen to events on it. There are totally 4 events:\n\n…And if we’d like to send something, then will do that.\n\nFor demo purposes, there’s a small server server.js written in Node.js, for the example above, running. It responds with “Hello from server, John”, then waits 5 seconds and closes the connection.\n\nThat’s actually it, we can talk WebSocket already. Quite simple, isn’t it?\n\nWhen is created, it starts connecting immediately.\n\nDuring the connection, the browser (using headers) asks the server: “Do you support Websocket?” And if the server replies “yes”, then the talk continues in WebSocket protocol, which is not HTTP at all.\n\nHere’s an example of browser headers for a request made by .\n• – the origin of the client page, e.g. . WebSocket objects are cross-origin by nature. There are no special headers or other limitations. Old servers are unable to handle WebSocket anyway, so there are no compatibility issues. But the header is important, as it allows the server to decide whether or not to talk WebSocket with this website.\n• – signals that the client would like to change the protocol.\n• – a random browser-generated key, used to ensure that the server supports WebSocket protocol. It’s random to prevent proxies from caching any following communication.\n• – WebSocket protocol version, 13 is the current one.\n\nIf the server agrees to switch to WebSocket, it should send code 101 response:\n\nHere is , recoded using a special algorithm. Upon seeing it, the browser understands that the server really does support the WebSocket protocol.\n\nAfterwards, the data is transferred using the WebSocket protocol, we’ll see its structure (“frames”) soon. And that’s not HTTP at all.\n\nThere may be additional headers and that describe extensions and subprotocols.\n• means that the browser supports data compression. An extension is something related to transferring the data, functionality that extends the WebSocket protocol. The header is sent automatically by the browser, with the list of all extensions it supports.\n• means that we’d like to transfer not just any data, but the data in SOAP or WAMP (“The WebSocket Application Messaging Protocol”) protocols. WebSocket subprotocols are registered in the IANA catalogue. So, this header describes the data formats that we’re going to use. This optional header is set using the second parameter of . That’s the array of subprotocols, e.g. if we’d like to use SOAP or WAMP:\n\nThe server should respond with a list of protocols and extensions that it agrees to use.\n\nFor example, the request:\n\nHere the server responds that it supports the extension “deflate-frame”, and only SOAP of the requested subprotocols.\n\nWebSocket communication consists of “frames” – data fragments, that can be sent from either side, and can be of several kinds:\n• “text frames” – contain text data that parties send to each other.\n• “binary data frames” – contain binary data that parties send to each other.\n• “ping/pong frames” are used to check the connection, sent from the server, the browser responds to these automatically.\n• there’s also “connection close frame” and a few other service frames.\n\nIn the browser, we directly work only with text or binary frames.\n\nWebSocket method can send either text or binary data.\n\nA call allows in string or a binary format, including , , etc. No settings are required: just send it out in any format.\n\nWhen we receive the data, text always comes as string. And for binary data, we can choose between and formats.\n\nThat’s set by property, it’s by default, so binary data comes as objects.\n\nBlob is a high-level binary object, it directly integrates with , and other tags, so that’s a sane default. But for binary processing, to access individual data bytes, we can change it to :\n\nImagine, our app is generating a lot of data to send. But the user has a slow network connection, maybe on a mobile internet, outside of a city.\n\nWe can call again and again. But the data will be buffered (stored) in memory and sent out only as fast as network speed allows.\n\nThe property stores how many bytes remain buffered at this moment, waiting to be sent over the network.\n\nWe can examine it to see whether the socket is actually available for transmission.\n\nNormally, when a party wants to close the connection (both browser and server have equal rights), they send a “connection close frame” with a numeric code and a textual reason.\n\nThe method for that is:\n• is a string that describes the reason of closing (optional)\n\nThen the other party in the event handler gets the code and the reason, e.g.:\n• – the default, normal closure (used if no supplied),\n• – no way to set such code manually, indicates that the connection was lost (no close frame).\n\nThere are other codes like:\n• – the party is going away, e.g. server is shutting down, or a browser leaves the page,\n• – the message is too big to process,\n\nThe full list can be found in RFC6455, §7.4.1.\n\nWebSocket codes are somewhat like HTTP codes, but different. In particular, codes lower than are reserved, there’ll be an error if we try to set such a code.\n\nTo get connection state, additionally there’s property with values:\n• – “CONNECTING”: the connection has not yet been established,\n\nLet’s review a chat example using browser WebSocket API and Node.js WebSocket module https://github.com/websockets/ws. We’ll pay the main attention to the client side, but the server is also simple.\n\nHTML: we need a to send messages and a for incoming messages:\n\nFrom JavaScript we want three things:\n• On form submission – for the message.\n• On incoming message – append it to .\n\nServer-side code is a little bit beyond our scope. Here we’ll use Node.js, but you don’t have to. Other platforms also have their means to work with WebSocket.\n\nThe server-side algorithm will be:\n• For each accepted websocket, add it to the set and set event listener to get its messages.\n• When a message is received: iterate over clients and send it to everyone.\n\nYou can also download it (upper-right button in the iframe) and run it locally. Just don’t forget to install Node.js and before running.\n\nWebSocket is a modern way to have persistent browser-server connections.\n• They are well-supported in browsers.\n\nWebSocket by itself does not include reconnection, authentication and many other high-level mechanisms. So there are client/server libraries for that, and it’s also possible to implement these capabilities manually.\n\nSometimes, to integrate WebSocket into existing projects, people run a WebSocket server in parallel with the main HTTP-server, and they share a single database. Requests to WebSocket use , a subdomain that leads to the WebSocket server, while goes to the main HTTP-server.\n\nSurely, other ways of integration are also possible."
    },
    {
        "link": "https://apidog.com/blog/javascript-websockets",
        "document": "Have you ever wondered how some apps can update their data in real-time, without requiring you to refresh the page or click a button?\n\nIn this blog post, We will explain what WebSocket is, how it works, and how to use it with JavaScript. We will also show you how to use Apidog to test and debug your APIs.\n\nWebSockets are a powerful tool for real-time communication between a client and a server. They allow for bidirectional communication, which means that data can be sent and received simultaneously. This is in contrast to traditional HTTP requests, which are unidirectional and require a new request to be made for each piece of data.\n\nWebSockets are faster and more efficient than traditional HTTP-based communication methods. They offer low latency, bidirectional communication, scalability, and support for real-time data streaming. WebSockets can handle multiple data streams over one connection, unlike HTTP/1.1, which only allows one stream of structured data at a time.\n\nWebSocket works by establishing a connection between the client and the server using a handshake. The handshake is done using HTTP, where the client sends an upgrade request and the server responds with an upgrade response. The upgrade request and response contain some special headers that indicate that the client and the server want to switch from HTTP to WebSocket.\n\nOnce the handshake is done, the connection is upgraded to WebSocket and the client and the server can exchange messages. The messages are sent and received using a binary format, which is more efficient and faster than HTTP. The messages can be text or binary, and they can have any size and content.\n\nThe connection is kept alive until either the client or the server closes it. The client or the server can close the connection by sending a close frame, which is a special type of message that indicates the end of the communication. The close frame can also contain a reason code and a message that explain why the connection is closed.\n\nWebSockets are a technology that enables continuous, bidirectional, and low-latency communication between web clients and web servers. Some of the benefits of using WebSockets are:\n• They reduce the data transmission overhead compared to HTTP, which uses a request/response cycle and adds headers, cookies, etc. to each message.\n• They are widely adopted and supported by many libraries, frameworks, and browsers, making them easy to use and integrate.\n• They are flexible and allow for the implementation of application-level protocols and extensions, such as pub/sub messaging.\n• They are event-driven and allow the server to push data to the client as soon as it becomes available, without the need for polling. This is useful for realtime applications that need to react quickly to events, such as chat rooms or stock updates.\n• They are full-duplex and allow both the server and the client to send data at the same time, enabling two-way, multi-user communication.\n\nHow to use WebSocket with JavaScript\n\nWebSocket with JavaScript is very easy to use with JavaScript, the most popular scripting language for the web. JavaScript has a built-in object called that provides a simple and intuitive API to create and manage WebSocket connections.\n\nTo use WebSocket with JavaScript, you need to create a WebSocket object with the URL of the server, and then listen to events such as , , , and . You can also send data to the server using the method. Here is a simple example of how to use WebSocket with JavaScript:\n\nThe code uses the WebSocket API to create and manage a WebSocket connection to a server, as well as to send and receive data on the connection. Here is a line-by-line breakdown of the code:\n\nThis line creates a new WebSocket object with the URL of the server that supports the WebSocket protocol. The URL starts with or for secure connections.\n\nThis block of code defines a function that will be executed when the event is fired on the WebSocket object. The event indicates that the connection between the browser and the server is successfully established. The function logs a message to the console and then sends a message to the server using the method of the WebSocket object.\n\nThis block of code defines a function that will be executed when the event is fired on the WebSocket object. The event contains the data received from the server in the property. The function logs the data to the console.\n\nThis block of code defines a function that will be executed when the event is fired on the WebSocket object. The event indicates that the connection between the browser and the server is closed. The function logs a message to the console.\n\nThis block of code defines a function that will be executed when the event is fired on the WebSocket object. The event indicates that there is an error with the connection, such as when some data couldn’t be sent or received. The function logs the error to the console.\n\nHow to use Apidog to debug JavaScript WebSocket?\n\nDebugging WebSockets can be challenging because they use a persistent connection. However, there are several tools available that can help you debug your WebSocket code. One such tool is Apidog, an all-in-one collaborative API development platform. With Apidog, you can learn effective debugging techniques, set up your debugging environment, and leverage advanced tools for a seamless debugging experience.\n\nHere’s how you can use Apidog to debug a WebSocket client:\n• Open Apidog: First, start the Apidog application and click on the \"+\" button on the left side, A new drop-down will be opened. From there choose \"New WebSocket API\":\n\n2. Establish a Connection: Begin by inputting the WebSocket API URL into Apidog's address bar. Then, click the \"Connect\" button to start the handshake process and create a connection. Apidog enables you to customize parameters such as Params, Headers, and Cookies during the handshake.\n\n3. Send and Receive Messages: You can send and receive messages after the connection is established by accessing the \"Message\" tab. You have the option to compose text, JSON, XML, HTML, and other text format messages, as well as binary format messages using Base64 or Hexadecimal. Apidog's new timeline view displays the connection status, sent messages, and received messages in chronological order. Clicking on a message allows you to easily view its details.\n\n4. API Documentation: Apidog inherits powerful API documentation functionality for WebSocket APIs, enabling effective documentation of your WebSocket interactions.\n\nApidog is a simple and powerful tool that allows you to test and debug WebSocket connections. Apidog has a web side and a client side. If you're using the web side and need to debug local services, you'll need to install the Google plugin for Apidog.\n\nWebSocket is awesome because it enables real-time communication between the browser and the server. It allows you to create interactive and engaging web applications that can update their content in real time, without reloading the page. WebSocket can be used for various purposes, such as:\n• Chat: WebSocket can be used to create chat applications that allow users to send and receive messages, emojis, images, videos, or audio in real time. WebSocket can also be used to create group chat, video chat, or voice chat applications that allow users to communicate with multiple people at the same time.\n• Notifications: WebSocket can be used to create notification systems that alert users about important events, such as new messages, new followers, new likes, new comments, or new orders. WebSocket can also be used to create push notifications that can reach users even when they are not on the website, using service workers and web push APIs.\n• Live Data: WebSocket can be used to create live data applications that display dynamic and real-time data, such as stock prices, weather updates, sports scores, news headlines, or social media feeds. WebSocket can also be used to create live data visualization applications that display charts, graphs, maps, or dashboards that can update in real time.\n• Gaming: WebSocket can be used to create gaming applications that allow users to play online games with other users, using real-time graphics, audio, or video. WebSocket can also be used to create multiplayer gaming applications that allow users to join rooms, chat with other players, or share their scores and achievements.\n\nBest Practices for Using Javascript WebSockets\n\nWhen using WebSockets, it is important to follow best practices to ensure that your code is secure and efficient. Here are some best practices to keep in mind:\n\nUse a WebSocket Library: Leverage existing WebSocket libraries to simplify the development process and ensure compatibility across different browsers and devices.\n• Secure Your WebSockets: Always prefer using (WebSocket Secure) over to encrypt data and prevent eavesdropping. This is similar to using HTTPS for secure HTTP connections.\n• Avoid Chatty Protocols: Minimize the number of messages sent over the WebSocket connection to reduce network traffic and improve performance.\n• Consider Network Topology: Be mindful of the network topology of your application, including firewalls and proxy servers, which may affect WebSocket connections.\n• Browser Limitations: Be aware of browser limitations and test your WebSocket implementation across different browsers to ensure consistent behavior.\n• Avoid Blocking Operations: In JavaScript, avoid blocking operations that can freeze the browser’s main thread and disrupt the WebSocket communication.\n• Monitor Memory Usage: Keep an eye on memory usage, as WebSocket connections can potentially lead to memory leaks if not managed properly.\n• Use TLS to Secure Connections: Employ TLS (Transport Layer Security) to secure all connections, ensuring data integrity and privacy.\n• Handle Broken Connections: Implement logic to detect and handle broken WebSocket connections, allowing for automatic reconnection when possible.\n• Scalability: Design your WebSocket infrastructure for scalability, considering the number of open connections and message throughput.\n\nBy following these best practices, you can create robust and efficient WebSocket applications that provide real-time functionality with enhanced security and performance. Remember to always test your implementation thoroughly and keep up with the latest developments in WebSocket technology.\n\nIn conclusion, WebSockets are a powerful tool for real-time communication between a client and server. They allow for bidirectional communication, which is useful for real-time applications like chat rooms and online games.\n\nBy following best practices and using tools like Apidog, you can ensure that your WebSocket code is secure and efficient. So, what are you waiting for? Start using WebSockets in your web applications today!\n\nHere are some additional resources to help you learn more about WebSockets:\n• How to create a WebSocket client in Python? (2024 Tutorial)\n• WebSockets vs HTTP: Which to choose for your project in 2024\n• How to Check If WebSocket Server is Running"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/WebSocket",
        "document": "This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015 .\n\n* Some parts of this feature may have varying levels of support."
    },
    {
        "link": "https://stackoverflow.com/questions/36832241/error-handling-over-websockets-a-design-dessision",
        "document": "Here's a scheme for doing request/response over socket.io. You could do this over plain webSocket, but you'd have to build a little more of the infrastructure yourself. This same library can be used in client and server:\n\nThis works by wrapping every message sent in a wrapper object that contains a unique id value. Then, when the other end sends it's response, it includes that same id value. That id value can then be matched up with a particular callback response handler for that specific message. It works both ways from client to server or server to client.\n\nYou use this by calling once on a socket.io socket connection on each end. If you wish to receive requests, then you pass a requestHandler function which gets called each time there is a request. If you are only sending requests and receiving responses, then you don't have to pass in a requestHandler on that end of the connection.\n\nTo send a message and wait for a response, you do this:\n\nIf you're receiving requests and sending back responses, then you do this:\n\nAs for error handling, you can monitor for a loss of connection and you could build a timeout into this code so that if a response doesn't arrive in a certain amount of time, then you'd get an error back.\n\nHere's an expanded version of the above code that implements a timeout for a response that does not come within some time period:"
    },
    {
        "link": "https://medium.com/voodoo-engineering/websockets-on-production-with-node-js-bdc82d07bb9f",
        "document": "In this article, we will use the ”ws” module to illustrate some points but the principles remain the same regardless of the library used. I wrote this article to create a kind of checklist about what to keep in mind before release a project using Websocket and Node.js.\n\nMost of the time you will find a lot of great articles to learn how to implement and use Websockets. It shows you examples of very basic applications using real-time communication.\n\nBut what happens in real life? When you release an API on your production you must take into account more than just if your code works. You monitor your production, you use CI, a logging system (I really hope you do!), etc.\n\nThis is the same thing for Websockets. You should be careful about some important points.\n\nJWT is a powerful tool to manage security on API but it works for Websocket based system too. It’s as simple as :\n• Server-side: before each connection, check the token inside headers.\n\nLike HTTP, WS protocol has its secure version, called WSS. On your server, you should configure SSL and a different port as you do for HTTPS. On the client-side just use wss:// instead of ws://.\n\nMost of the time, a WS connection will stay idle after the connection is established. Except when you use it for business logic, and for the keep-alive protocol (ping/pong requests), a Websocket doesn’t use a lot of resources.\n\nSetting up an autoscaling system based on memory and/or CPU is not always the best idea and this is why automatically scaling a WebSocket application is not really easy.\n\nEven the number of requests per server is not a good indicator because your connections are stateful, and every user will not reconnect very often. The best way to do it is to scale on open connections per server. You can have access to this value with CloudWatch if you use AWS for example.\n\nAnother thing to keep in mind is the tuning of your instances. The best way to handle a lot of persistent connections is to increase some values of your operating system and/or your application. For Node.js under a Linux based OS, you can refer to this great article: https://blog.jayway.com/2015/04/13/600k-concurrent-websocket-connections-on-aws-using-node-js/\n\nWhen working with Websockets, you build an event-based system. The best solution to scale your backend with such a system is to use a message broker. It will allow you to work with a powerful messaging pattern called Pub/Sub. A lot of technologies support this kind of pattern like Redis, RabbitMQ or Kafka. The good news is most of them are managed by Cloud providers and can scale automatically.\n\nA common issue when you work with WebSocket is broken connections. It appears when one of the endpoints (client or server) does not respond, or when it’s not reachable anymore. To manage this we need a logic on both server-side and client-side to gracefully close the connection. The idea is very simple: create a kind of heartbeat function to check periodically if a connection is still alive. Otherwise, close the connection.\n\nSome libraries, like WS, do not always provide a mechanism to automatically reconnect to the server. You will probably need this feature if your backend unexpectedly restarts (which can happen after each deployment ;)). Here we just need to automatically reconnect the client after it catches a close event.\n\nIf your connections have a long life, which is probably the case if you use Websocket, then you should refresh them (basically close them and open a new one). This is useful when you do some stuff when the connection is established and if you want the client to be up to date with the server. Or if you want to use another token if it expires soon.\n\nThere is no advice here on how to do it because it highly depends on your business logic. Anyway, a good recommendation is to refresh the connection every hour then you can change this interval if necessary.\n\nMost APM solutions don’t support WebSocket monitoring, they are mainly focused on classical request/response through HTTP protocol. They are well designed for API and web servers.\n\nAnyway, even if your APM doesn’t support Websocket instrumentation, you can use custom transactions and/or custom attributes to do it.\n\nSee how with elastic APM or with NewRelic agent.\n\nNow you can see your events in Kibana:"
    },
    {
        "link": "https://discourse.julialang.org/t/best-practices-for-managing-websocket-http-server-lifecycle/124434",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/31002592/javascript-doesnt-catch-error-in-websocket-instantiation",
        "document": "The 's connection-time error causes a dispatched event, not a thrown value. This is because operations must be synchronous. In order to handle all connection-time errors as thrown errors, the constructor would need to completely suspend all script execution and UI interaction until the entire WebSocket handshake had completed. Instead, the connection process runs asynchronously, thereby allowing the browser thread to continue working while the WebSocket connection initializes in the background. Because of the connection's asynchronous nature, the must report errors via events, since the synchronous operation has already finished by the time the asynchronous connection task encounters an error.\n\nThe message you see is purely for the benefit of developers; it is not accessible to the script in any way. It does not have any representation within the JavaScript environment. It's just a red-colored message that appears in your console to inform you, the human looking at the browser, about an error.\n\nThe handler event is the correct place to respond to failure, but the lack of script-readable connection-time error information is by design. From the WHATWG spec for the WebSocket API:\n\nUser agents must not convey any failure information to scripts in a way that would allow a script to distinguish the following situations:\n• A server whose host name could not be resolved.\n• A server to which packets could not successfully be routed.\n• A server that refused the connection on the specified port.\n• A server that failed to correctly perform a TLS handshake (e.g., the server certificate can't be verified).\n• A server that did not complete the opening handshake (e.g. because it was not a WebSocket server).\n• A WebSocket server that sent a correct opening handshake, but that specified options that caused the client to drop the connection (e.g. the server specified a subprotocol that the client did not offer).\n• A WebSocket server that abruptly closed the connection after successfully completing the opening handshake. [...] Allowing a script to distinguish these cases would allow a script to probe the user's local network in preparation for an attack.\n\nThe browser is deliberately omitting any useful information as required by the spec. The spec authors are concerned that access to this information could allow a malicious Web page to gain information about your network, so they require browsers report all connection-time errors in an indistinguishable way."
    },
    {
        "link": "https://tutorialspoint.com/websockets/websockets_handling_errors.htm",
        "document": "Once a connection has been established between the client and the server, an open event is fired from the Web Socket instance. Error are generated for mistakes, which take place during the communication. It is marked with the help of onerror event. Onerror is always followed by termination of connection.\n\nThe onerror event is fired when something wrong occurs between the communications. The event onerror is followed by a connection termination, which is a close event.\n\nA good practice is to always inform the user about the unexpected error and try to reconnect them.\n\nWhen it comes to error handling, you have to consider both internal and external parameters.\n• None Internal parameters include errors that can be generated because of the bugs in your code, or unexpected user behavior.\n• None External errors have nothing to do with the application; rather, they are related to parameters, which cannot be controlled. The most important one is the network connectivity.\n• None Any interactive bidirectional web application requires, well, an active Internet connection.\n\nImagine that your users are enjoying your web app, when suddenly the network connection becomes unresponsive in the middle of their task. In modern native desktop and mobile applications, it is a common task to check for network availability.\n\nThe most common way of doing so is simply making an HTTP request to a website that is supposed to be up (for example, http://www.google.com). If the request succeeds, the desktop or mobile device knows there is active connectivity. Similarly, HTML has XMLHttpRequest for determining network availability.\n\nHTML5, though, made it even easier and introduced a way to check whether the browser can accept web responses. This is achieved via the navigator object −\n\nOffline mode means that either the device is not connected or the user has selected the offline mode from browser toolbar.\n\nHere is how to inform the user that the network is not available and try to reconnect when a WebSocket close event occurs −\n\nThe following program explains how to show error messages using Web Sockets −\n\nThe output is as follows −"
    }
]