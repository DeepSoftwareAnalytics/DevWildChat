[
    {
        "link": "https://geeksforgeeks.org/scp-command-in-linux-with-examples",
        "document": "Secure file transfer is a crucial part of Linux systems administration. Whether moving sensitive files between local machines or transferring data between servers, SCP (Secure Copy Protocol) provides a fast, secure, and efficient way to copy files over a network. By utilizing SSH (Secure Shell), SCP ensures that your file transfers are encrypted and protected against eavesdropping.\n\nIn this article, we’ll cover everything you need to know about how to securely copy files in Linux using the SCP command. We’ll explain the command syntax, the most commonly used options, practical examples, and troubleshooting tips to ensure you can use SCP to its full potential.\n\nWhat is the Secure Copy Protocol (SCP)\n\nIt’s a command-line tool that allows transfer files securely between hosts over a network built on SSH protocol that encrypts data during the transfer to protect it from potential interception. Whether copying files from your local machine to a remote server or transferring files from one Linux machine to another, SCP ensures that the process is safe and fast.\n\nThe SCP command is used to copy files between local and remote systems securely. It has a simple syntax:\n• None : These are various options that modify the behavior of the SCP command, such as for specifying an identity file, for specifying a custom SSH port, and for specifying a program to use for the encrypted connection.\n• None : This represents the source file or directory. It can be local or on a remote machine specified by\n• None : This indicates that you can specify multiple source files or directories.\n• None : This is the destination where the files or directories will be copied. It can be local or on a remote machine specified by\n\nTo copy a file named file.tx from your local machine to a remote server:\n\nIn this example:\n• /home/username/ is the destination directory on the remote server.\n\nThese are some of the most commonly used Options in scp Command in Linux:\n\nHow to Securely Copy Files from Local to Remote Machine\n• file_name = The name of the file that needs to be copied.\n• remoteuser =The username of the remote host.\n• remotehost = The IP address or hostname of the remote host.\n• /remote/directory = The directory where the file should be copied on the remote machine.\n\nFor example: If we want to copy a file name “test.txt” from local system to a\n\nTo Verify: Use `ls` command in the location we copied file.\n\nHow to Securely Copy Files From Remote Machine to Local Machine\n\nTo copy a file from a remote machine to your local system, you just reverse the source and destination, let’s check out the syntax below:\n• “/home/user/file_name” = path of file that has to be copied.\n• “.” = this means that we are copying that file in current location in local system.\n\nFor Example: If we have\n\nTo verify: use dir (in windows cmd)\n\nIt is used to Securely Copy File to a Remote Machine on a Non-Standard SSH Port and specify the port to connect on the remote host. It is useful when our SSH server is listening on a non-standard port.\n\nIf we want to copy a file “test2.txt” from local machine to a remote machine with IP address “10.143.90.2” on port 2222 , user = “jayesh” and location = “/home/jayesh/”. \n\nBy default, the scp uses ssh over port 22 for transferring the files. Changing the port might be necessary if the designated port 22 is not open on the remote host.\n\nTo Verify: Use `ls` command in remote system in the location we have copied the file.\n\nThis option is used when we want the original metadata of the file that has been transferred. Basically, it preserves modification time, access time, and modes from the original file.\n\nFor Example: If we want to copy a file “test3.txt” from local machine to a remote machine with IP address “10.143.90.2”, user = “jayesh” and location = “/home/jayesh/”\n\nIt Securely Copy File with Quiet Mode – Disabling Progress Meter .This option hides the progress of the file transfer on the terminal.\n\nFor Example: If we want to copy a file “test4.txt” from local machine to a remote machine with IP address “10.143.90.2”, user = “jayesh” and location = “/home/jayesh/”\n\nTo Verify: Use `ls` command in remote system in the location we have copied the file.\n\nThis option is used when we want to copy an entire directory and its contents. Which basically means copying entire directory recursively.\n\nFor Example: If we want to copy a Directory content name “new” from local machine to a remote machine with IP address “10.143.90.2”, user = “jayesh” and location = “/home/jayesh/new1/”\n\nTo Verify: Use `ls` command in remote system in the location we have copied the file.\n\nHow to Improve the Security of SCP File Transfer\n\nYou must follow these practices to ensure that you’re performing a secure file transfer using the SCP:\n\n1. Ensure to use a strong and unique SSH key to authenticate file transfers.\n\n2. Always ensure that you’re transferring files to a trusted remote hosts by checking its fingerprints.\n\n3. Ensure that you’re using a non-default SSH port (if possible) to prevent from any attacks.\n\n4. Cross verify that you’re only transferring files to directories with limited access.\n\nWhile performing this action, there are certain challenges that you might face, let’s address them for better clarity:\n\nIf such issue persists, ensure that all the permissions to read/write to both source and destination (or directories) are coreect. Here’s how you can check it:\n\nEnsure that the remote server is onlinr and reachable and in case of custom SSH port, always make sure that you’re using the correct port. You may verify it by using the -P option.\n\nCheck if the source file exists and is accessible, also ensure to have sufficient storage disk space on the remote server so that the files can be stored.\n\nThe SCP command is one of the most essential tool for anyone who like working on the Linux Systems. It provides a seamless method of copying files between local and remote machines. By folloiwng the above steps and methods, you can easily transfer files in a secured way, and troubleshoot common SCP issues with ease.\n\nEnsure to follow the safe practice for secrity, use SSH keys for authentication. and ensure that your system’s networking settings are onfigured properly for seamless file transferring.\n\nHow to Securely Copy Files in Linux | scp command in Linux – FAQs\n\nWhat is the scp -r command in Linux?\n\nWhat is scp command in Linux.?\n\nWhat is the reverse scp command in Linux?\n\nHow do I use the scp command to copy files between two Linux machines securely?\n\nWhat are the common options used with scp for secure file transfer?\n\nHow can I copy files from a local machine to a remote server using scp?\n\nHow do I improve the security of scp file transfers?\n\nHow to specify the SSH port in Linux for scp?"
    },
    {
        "link": "https://ssh.com/academy/ssh/scp",
        "document": "is a program for copying files between computers. It uses the SSH protocol. It is included by default in most Linux and Unix distributions. It is also included in the Tectia SSH and OpenSSH packages.\n\nThe basic usage of is as follows:\n\nThis copies the file to the remote host. The destination is optional, but can be a directory on the server, or even a file name if copying a single file. It is possible to specify multiple files; the last one is the destination.\n\nTo copy a file from the remote host, use:\n\nThis fetches the file from the host, and puts it in the directory indicated by . Often, is just , meaning the current working directory.\n\nTo cpoy entire directory trees instead of single files, add the option. For example:\n\nThis would fetch from the host, copying it to the current working directory (creating in current working directory).\n\nNormally, asks for a password. To avoid this, or to automate file copying in scripts, public key authentication is usually used.\n\nThe basic idea is to create a key pair on the client and copy the public key to the server into an authorized keys file. See how to set up public key authentication.\n\nDon't forget to establish proper SSH key management practices. See how to manage SSH keys."
    },
    {
        "link": "https://linux.die.net/man/1/scp",
        "document": ""
    },
    {
        "link": "https://redhat.com/en/blog/secure-file-transfer-scp-sftp",
        "document": "Moving files between systems is one of a Linux system administrator's regular activities. When transferring data across a network, one important consideration is the security of the medium you're using. There are several tools are available for this.\n\nOn Red Hat Enterprise Linux (RHEL), SFTP (Secure File Transfer Protocol) and SCP (secure copy) are handy commands to move files between systems securely. As part of the OpenSSH suite, these tools rely on Secure Shell (SSH) to transfer the files. This means they use the same authentication and provide the same security as SSH does.\n\nTo transfer files with SCP, specify the remote server's IP address or hostname and the destination path where you want it to copy the file or directory. Use the same username and credentials for SCP as you use for SSH. No other credentials are needed. If the file already exists at the destination, SCP replaces or overwrites the content. It's also wise to use absolute path names for the destination path.\n\nTo transfer a file with the command, use the following syntax:\n\nThis example copies on the local server to on the remote server at 192.168.1.3.\n\nIn instances where the SSH server uses a different port, say 2390, the command to copy the files looks like this:\n\nNote: The is uppercase instead of lowercase (as when using SSH).\n\nYou need to specify the path to the public and private keys if they are stored in nonstandard locations. For example, if the private key is stored at , the command is:\n\nIt's also possible to copy a directory by using the parameter. To copy a directory named , use:\n\nThis command copies the entire directory to . Please note that you need to ensure the user you are connecting with has permission to do the operation you want to do.\n\nSFTP is a secure file transfer program that also relies on SSH and is interactive. The tool is similar to FTP, but it uses SSH port 22.\n\nWhen you initiate an SFTP connection, it connects to its destination and enters an interactive mode on the remote server. You can then transfer files using commands such as , , , and .\n\nTo establish an SFTP connection, use:\n\nYou should have a command prompt similar to the one below:\n\nIf SSH is running on an alternate port, use:\n\nWhen using a passwordless connection and if the private key is named differently or stored in a different location than the default, use:\n\nThe example above connects to 192.168.1.3 using the private key at .\n\n[ Linux provides a dozen ways to perform any given task, including installing apps. For a refresher, download the guide to installing applications on Linux. ]\n\nWhat if you want to transfer the file file to on the remote server? In that case, use:\n\nTo download a file named from the remote server to the local system, do:\n\nYou can upload and download directories by using the parameter.\n\nFor additional options, use the command or consult the man pages by typing .\n\nUsing secure file copy commands such as and are an important part of network hardening and general security initiatives. The commands are straightforward and rely on the familiar and trusted SSH utility. Practice using both tools for a more responsible sysadmin stance."
    },
    {
        "link": "https://cmich.teamdynamix.com/TDClient/664/Portal/KB/ArticleDet?ID=37369",
        "document": "SCP (Secure Copy Protocol) allows you to securely transfer files between your computer and a remote server. SCP uses SSH (man/wiki) to copy files, and is typically available on any computer running ssh. SCP can operate in either a push (local --> remote) or pull (remote --> local) mode, specified by the ordering of options. It is assumed that most visitors of this article are here to learn how to copy homework to/from teaching and learning systems, usually small programs and text files. It is also assumed that you are probably running windows on your personal or lab computer. SCP is available on most modern windows/mac/linux computers, and will work very similarly on each. As with most GNU/Linux utilities, there are extensive man pages that you can and are encouraged to read if you have a desired usecase beyond the basic examples below.\n\nAuthentication will be different for each system. Some general-access systems like cps-sshd-student are AD-based (globalID and password), and access is controlled through automation that checks student groups in whitelisted course IDs for the current term. Other external or more specialized services might use local accounts that are not polled from active directory. Defer to your instructor or research sponsor for which authentication method your service uses.\n• Any domain-bound, ethernet connected computer (with an ssh client installed)\n• A virtual machine in the Citrix virtual lab (with an ssh client installed)\n• A personal computer connected to the CMU vpn (with an ssh client installed)\n\nThe basic command structure of an scp push command is as follows:\n\nThe basic command structure of an scp pull command is as follows:\n\nNote that in both cases, the destination follows the source. The major difference between the two is where the \"user@host\" component goes. In the case of a push, the source is a local file. In the case of a pull, the source is a remote file. The [-P (port)] component is optional if ssh on your remote service is listening on port 22, mandatory if your remote service is listening on any other port. In the case of CMU services, it is common for ssh to use nonstandard ports. Once you enter an scp command you will be prompted for your password; upon successfully entering your password the file transfer will begin.\n\nSuppose you have the following situation:\n• You would like to push a file from your personal windows computer to the remote service cps-sshd-student.se.cmich.edu\n• This service runs an ssh daemon on port 30001\n• your local file is in \"C:\\Users\\local_username\\Documents\\\" and is called \"cps-999-homework1.py\"\n• you would like to push this file to your home directory (~/) on the remote server.\n• you are currently connected to the vpn\n\nOn your windows laptop, you would open powershell or the windows terminal, and probably see something like the following:\n\nyou might type the following to change directory into your Documents directory:\n\nIn the directory you want to push from, you can now type the following scp command:\n\nAfter entering your Global ID's password at the system prompt, the file transfer will begin.\n\nSuppose you have the following situation:\n• You would like to pull a file from the remote service cps-sshd-student.se.cmich.edu to your U drive via a lab computer\n• This service runs an ssh daemon on port 30001\n• your remote file is in ~/cps-999/ and is called \"cps-999-homework1.py\"\n• you would like to pull this file to your U drive in a directory U:/cps-999/\n• you are currently connected to the vpn\n\nOn your windows laptop, you would open powershell or the windows terminal, and probably see something like the following:\n\nyou might type the following to change directory to the desired subdirectory within your personal U drive:\n\nIn the directory you want to pull to, you can now type the following scp command:\n\nAfter entering your Global ID's password at the system prompt, the file transfer will begin.\n\nBy default, many windows text editors will save files by default in an encoding schema of \"UTF-8 w/BOM\" and/or with \"CR LF\" line endings. Many Linux utilities, most notably bash, are incompatible with Byte Order Marks and CR LF line endings. It is recommended that you encode your scripts as plan UTF-8, using LF line endings. Once you save a file with these encoding standards, subsequent saves should respect and retain this formatting.\n\nin scp commands, file paths on both the source and destination can be relative or absolute. Relative pathing is faster to type, but more prone to mental errors. Absolute pathing is longer to type but more prone to typing errors.\n\n An absolute path is a path defined from the \"root\" of a drive e.g\n\nA relative path is a path defined from the current working directory. If your active terminal is currently in your user's home directory on windows or linux, a file C:\\Users\\local_user\\Documents\\cps-999\\file.txt or /home/central/globa1id/cps-999/file.txt could be referenced like\n\nOn Linux, Mac, and Unix systems, path barriers are typically naively referenced using a forward slash /\n• Most systems will only accept a forward slash to reference directory boundaries, as backward slashes are reserved for escape characters in strings.\n\nOn Windows, path barriers are naively referenced using a backward slash \\\n• Older windows systems will only accept \\, modern windows systems will typically accept either \\ or / interchangeably.\n\nThis is the reason most the examples above uniformly use /, and why we recomend using \"windows terminal\" or \"powershell\" instead of \"cmd\" to run these commands.\n\nThere are other ways to make edits to text files on remote systems. You do not necessarily have to upload/download via scp.\n\nWhile logged in via ssh: vim and nano are common cli-based text editors that many business-world workflows will expect you to know. They are simple, time-tested editors and are much more powerful than they appear on the surface.\n• is the simplest, but least powerful by far.\n• It's major advantage is that it dedicates a bottom section to permanently display hotkeys and their associated functions so that you don't have to memorize them.\n• is more complex, but much more powerful.\n• \"vimtutor\" is available on most CMU managed Linux-based systems, and is how many faculty and staff got started with vim themselves.\n• is a halfway-decent operating system, perpetually in search of a passable text editor\n\nSome IDEs like vscode/vscodium have plugins for remote development directly to an ssh-backed system\n\nSome ftp clients like FileZilla support sftp (very similar to, and compatible with ssh hosts the same way scp is)\n\nWhile configuration for these utilities are out of scope for this article (and not officially supported) IT always encourages students, especially CPS/ITC students, to take ownership of their data and develop personal workflows that work for them. The philosophy behind open source, and open protocols, is that all programs supporting the same protocols should work intercompatibily with each other."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/how-to-use-rsync-to-sync-local-and-remote-directories",
        "document": "Rsync, which stands for remote sync, is a remote and local file synchronization tool. It uses an algorithm to minimize the amount of data copied by only moving the portions of files that have changed.\n\nIn this tutorial, we’ll define Rsync, review the syntax when using , explain how to use Rsync to sync with a remote system, and other options available to you.\n\nIn order to practice using to sync files between a local and remote system, you will need two machines to act as your local computer and your remote machine, respectively. These two machines could be virtual private servers, virtual machines, containers, or personal computers as long as they’ve been properly configured.\n\nIf you plan to follow this guide using servers, it would be prudent to set them up with administrative users and to configure a firewall on each of them. To set up these servers, follow our Initial Server Setup Guide.\n\nRegardless of what types of machines you use to follow this tutorial, you will need to have created SSH keys on both of them. Then, copy each server’s public key to the other server’s file as outlined in Step 2 of that guide.\n\nThis guide was validated on machines running Ubuntu 20.04, although it should generally work with any computers running a Linux-based operating system that have installed.\n\nRsync is a very flexible network-enabled syncing tool. Due to its ubiquity on Linux and Unix-like systems and its popularity as a tool for system scripts, it’s included on most Linux distributions by default.\n\nThe syntax for operates similar to other tools, such as , , and .\n\nFirst, change into your home directory by running the following command:\n\nThere’s now a directory called with 100 empty files in it. Confirm by listing out the files:\n\nYou also have an empty directory called . To sync the contents of to on the same system, you will run and use the flag, which stands for “recursive” and is necessary for directory syncing:\n\nAnother option is to use the flag, which is a combination flag and stands for “archive”. This flag syncs recursively and preserves symbolic links, special and device files, modification times, groups, owners, and permissions. It’s more commonly used than and is the recommended flag to use. Run the same command as the previous example, this time using the flag:\n\nPlease note that there is a trailing slash ( ) at the end of the first argument in the syntax of the the previous two commands and highlighted here:\n\nThis trailing slash signifies the contents of . Without the trailing slash, , including the directory, would be placed within . The outcome would create a hierarchy like the following:\n\nAnother tip is to double-check your arguments before executing an command. Rsync provides a method for doing this by passing the or options. The flag, which means “verbose”, is also necessary to get the appropriate output. You’ll combine the , , and flags in the following command:\n\nNow compare that output to the one you receive when removing the trailing slash, as in the following:\n\nThis output now demonstrates that the directory itself was transferred, rather than only the files within the directory.\n\nUsing Rsync to Sync with a Remote System\n\nTo use to sync with a remote system, you only need SSH access configured between your local and remote machines, as well as installed on both systems. Once you have SSH access verified between the two machines, you can sync the folder from the previous section to a remote machine by using the following syntax. Please note in this case, that you want to transfer the actual directory, so you’ll omit the trailing slash:\n\nThis process is called a push operation because it “pushes” a directory from the local system to a remote system. The opposite operation is pull, and is used to sync a remote directory to the local system. If the directory were on the remote system instead of your local system, the syntax would be the following:\n\nLike and similar tools, the source is always the first argument, and the destination is always the second.\n\nRsync provides many options for altering the default behavior of the utility, such as the flag options you learned about in the previous section.\n\nIf you’re transferring files that have not already been compressed, like text files, you can reduce the network transfer by adding compression with the option:\n\nThe flag is also helpful. It combines the flags and . This first flag provides a progress bar for the transfers, and the second flag allows you to resume interrupted transfers:\n\nIf you run the command again, you’ll receive a shortened output since no changes have been made. This illustrates Rsync’s ability to use modification times to determine if changes have been made:\n\nSay you were to update the modification time on some of the files with a command like the following:\n\nThen, if you were to run with again, you’ll notice in the output how Rsync intelligently re-copies only the changed files:\n\nIn order to keep two directories truly in sync, it’s necessary to delete files from the destination directory if they are removed from the source. By default, does not delete anything from the destination directory.\n\nYou can change this behavior with the option. Before using this option, you can use , the option, to perform a test to prevent unwanted data loss:\n\nIf you prefer to exclude certain files or directories located inside a directory you are syncing, you can do so by specifying them in a comma-separated list following the option:\n\nIf you have a specified pattern to exclude, you can override that exclusion for files that match a different pattern by using the option:\n\nFinally, Rsync’s option can be used to store backups of important files. It’s used in conjunction with the option, which specifies the directory where the backup files should be stored:\n\nRsync can streamline file transfers over networked connections and add robustness to local directory syncing. The flexibility of Rsync makes it a good option for many different file-level operations.\n\nA mastery of Rsync allows you to design complex backup operations and obtain fine-grained control over how and what is transferred."
    },
    {
        "link": "https://phoenixnap.com/kb/rsync-command-linux-examples",
        "document": "Rsync is a free command-line tool for transferring files within your local system and between local and remote systems. It offers many customization options and is often used for mirroring, performing backups, or migrating data to other servers.\n\nRsync only copies changes from the source, making transfers fast and efficient.\n\nLearn how to use rsync with 20 command examples that cover the most common use cases in Linux.\n\nRsync is preinstalled on most modern Linux distributions. Use the command for your distribution to verify the installation or install if necessary:\n\nThe simplest form of the rsync command is used for copying files or directories from one location to another on the same system:\n\nThe source and destination are a directory or file path.\n\nWhen performing remote data transfers, you must specify the address of the remote host. Use the following syntax to synchronize local files and directories to a remote server:\n\nYou can also synchronize files and directories from a remote system to your local machine:\n\nThe following table includes some of the most common rsync options:\n\nRsync is a versatile synchronization tool that can be customized for specific use cases. The following examples cover the most common scenarios.\n\nTo copy one file to another directory on a local machine, enter the source file's path, followed by the target destination. For example:\n\nThis command transfers the sample.txt file to the rsync directory. If the destination directory does not exist, add a slash at the end, and will create it, as shown in the example.\n\nThe option is used to display the transfer details.\n\nTo copy multiple files with a single command, list the full paths of the source files followed by the destination directory:\n\nThe command transfers the sample.txt and sample2.txt files to the rsync directory. Use this method when copying a smaller number of files. If you want to transfer a larger list of files, use the --exclude option instead.\n\nTo copy a directory and its contents to another location on your machine, use the (archive) or (recursive) option. This example shows how to use the archive option:\n\nThe rsync tool copies the test_project directory to the rsync directory. Note that we did not use a trailing slash after test_project. As a result, rsync created the test_project directory and placed it and its content inside the rsync directory.\n\n4. Transfer a File or Directory from Local to Remote Machine\n\nTo copy the test_project directory to the remote_project directory on a remote machine, specify the destination IP address or hostname. Add the IP address and the full destination path after the source directory, separated by a colon ( ). For example:\n\nIf you want to use another account for the remote connection, enter the username before the IP address:\n\nTo transfer a single file to a remote host, specify the file's path followed by the destination path:\n\nAfter entering the command, you are prompted to enter the password for the remote user account to proceed with the transfer.\n\n5. Transfer Multiple Files or Directories from Local to Remote Machine\n\nTo copy multiple files or directories to a remote machine, list their paths followed by the destination directory:\n\nIn this example, the test_project directory and the local_dir1 directory are transferred to the remote_project directory on the remote machine at . The option ensures the transfer is recursive and preserves file attributes, while the option displays transfer details.\n\nThe option specifies the shell program for file transfers. Append to the command to transfer files securely over SSH:\n\nIn this example, the sample2.txt file is transferred from your local desktop to the remote desktop via SSH. The flag displays details about the transfer process.\n\n7. Retrieve File or Directory from Remote to Local Machine\n\nRsync can also transfer files from a remote server to your local machine. To pull a directory from a remote server, specify it's IP address:\n\nThe remote_project directory from the remote server at IP was copied to the /home/pnap/Downloads directory on the local server.\n\nTo copy a specific file from a remote host, enter the full path of the source file and the destination on your local machine. For example:\n\nThe sample7.txt file from the remote server is copied to the Downloads directory on the local machine.\n\n8. Retrieve Multiple Files or Directories from Local to Remote Machine\n\nTo transfer multiple files or directories from a remote server, list the paths using curly brackets after the remote server's IP address. Separate the paths with a comma. For example:\n\nThe command can be applied to individual files. List as many files as you need inside the curly brackets.\n\nWhen performing a large data backup, you can track the transfer's progress. Add the flag to view the amount of data transferred, transfer speed, and remaining time.\n\nFor example, to back up backup1.zip to a remote server and show the progress, enter:\n\nThe output shows the file size, progress, transfer speed, and ETA.\n\nUsers can perform a dry run to test if will behave as expected before syncing files. To do a dry run, add the option to your command:\n\nThe output looks the same as syncing files, except no data will be synced or deleted. To confirm the operation was a test and not the actual transfer, the terminal displays (DRY RUN) at the bottom.\n\nYou can use the option to remove any file or directory at the destination that does not exist in the source:\n\nIn this example, the content of the remote_project directory on your local machine is synchronized with the remote_project directory on the remote machine. Files or directories in the remote destination that are not present in the local source directory are deleted to ensure the destination is an exact mirror of the source.\n\nUsers sometimes need to delete source files after the transfer. For example, when moving a weekly backup to a new server, you may no longer need the source file on the old server.\n\nUse the flag to transfer and delete the specified source file:\n\nThe command transfers the backup file backup1.zip to the Desktop directory on the remote machine. Once the transfer is complete, the source file on the local machine is deleted.\n\nThe flag sets the maximum size of the file to be transferred. This option allows users to avoid large file transfers and conserve resources. For example, the following command instructs to only transfer files that are smaller than 500KB:\n\nFiles in the test_project directory that exceed the defined size are not transferred to the remote server.\n\nUse with to skip the transfer of files smaller than a specified size. This option is useful, for example, when you want to skip small log or thumbnail files. For example:\n\nThis command ensures that only files larger than 10KB are transferred to the remote server.\n\nTo limit bandwidth usage during data transfers, use the flag. To set the maximum transfer speed to 50KB/s, enter:\n\nThis example also uses the option to illustrate how controls the transfer speed.\n\nYou can use to copy only a specific file type. To do so, use the asterisk ( ) symbol instead of the file name and add the extension.\n\nFor example, to copy only .txt files, enter:\n\nThe command transfers all text files from the Documents directory to the rsync directory on your desktop.\n\nRsync allows users to mirror the directory structure without transferring the actual files. To do so, add filters before the source directory:\n\nThe test_project directory structure was copied to the Documents directory, while no files were transferred.\n\nYou can add a date stamp to a directory name during the transfer. This option helps you track when transfers took place without opening directory properties. To do this, append to the destination directory name:\n\nIn this example, the destination directory name includes the current date in the specified format (YYYY-MM-DD).\n\n19. Do Not Copy Source File If Destination File is Modified\n\nSometimes, you may modify a file at the destination and want to prevent rsync from overwriting it with a file from the source. To avoid overwriting modified destination files, use the (update) option:\n\nIn this example, if the sample4.txt file in the rsync directory is modified, the rsync tool will not overwrite it with the version from the test_project directory.\n\nYou can use the flag with the command to check for differences between the source and the destination:\n\nIn this example, the output indicates that the sample11.txt file is missing at the destination.\n\nOther possible letters in the output are:\n\nThis guide provided 20 command examples for transferring files and directories locally and remotely.\n\nNext, learn to use the sync command to synchronize cache data to permanent system memory, save important files, and prevent data loss."
    },
    {
        "link": "https://tecmint.com/rsync-local-remote-file-synchronization-commands",
        "document": "Rsync (Remote Sync) is the most commonly used command for copying and synchronizing files and directories remotely as well as locally in Linux/Unix systems.\n\nWith the help of the rsync command, you can copy and synchronize your data remotely and locally across directories, disks, and networks, perform data backups, and mirror between two Linux machines.\n\nThis article explains 16 basic and advanced uses of the rsync command to transfer your files remotely and locally in Linux-based machines. You don’t need to be a root user to run the rsync command.\n• Efficient File Transfer – rsync uses a delta transfer algorithm, which means it only transfers the differences between source and destination files, which significantly reduces the amount of data transferred, making it efficient for syncing large files or directories.\n• Remote File Synchronization – rsync supports both local and remote file transfers over SSH, which allows synchronization between local and remote systems or mirroring directories across multiple machines.\n• Incremental Backups – rsync is well-suited for incremental backups, as it create and update backups efficiently by transferring only new or modified files.\n• Preserves File Permissions – rsync can preserve various file attributes, such as permissions, ownership, timestamps, and symbolic links, which ensures that the copied files retain their original characteristics on the destination.\n• Bandwidth Control – rsync allows you to limit the bandwidth usage during file transfers, as it uses compression and decompression method while sending and receiving data on both ends.\n• Faster – rsync can be faster than scp (Secure Copy) for transferring files, especially when syncing large directories or when dealing with files that have already been partially transferred or exist on the destination.\n\nThe rsync command follows the following syntax:\n\nHere’s an explanation of the different components and options used with rsync commands:\n• – copies data recursively (but doesn’t preserve timestamps and permission while transferring data.\n• – archive mode, which allows copying files recursively and it also preserves symbolic links, file permissions, user & group ownerships, and timestamps.\n• – Specifies the source file(s) or directory to be transferred, which can be a local or a remote location.\n• – Specifies the destination path where the files or directories will be copied. Similar to the source, it can be a local path or a remote location.\n\nWe can install the rsync package with the help of the following package manager as per your Linux distribution.\n\nTo copy or sync a file locally, you can use the following command that will sync a single file on a local machine from one location to another location.\n\nHere in this example, a file name backup.tar needs to be copied or synced to /tmp/backups/ folder.\n\nIn the above example, you can see that if the destination is not already existed rsync will create a directory automatically for the destination.\n\nThe following command will transfer or sync all the files from one directory to a different directory in the same machine.\n\nHere in this example, /root/rpmpkgs contains some rpm package files and you want that directory to be copied inside /tmp/backups/ folder.\n\nTo copy a directory from a local server to a remote server, you can use the following command, which will sync a directory from a local to a remote machine.\n\nFor example, if there is a folder in your local computer “rpmpkgs” that contains some RPM packages and if you want that local directory’s content sends to a remote server, you can use the following command.\n\nThis command will help you sync a remote directory to a local directory. Here in this example, a directory /root/rpmpkgs which is on a remote server is being copied into your local computer in /tmp/myrpms.\n\nWith rsync, we can use SSH (Secure Shell) for data transfer, using SSH protocol while transferring our data you can be ensured that your data is being transferred in a secured connection with encryption so that nobody can read your data while it is being transferred over the wire on the internet.\n\nAlso when we use rsync we need to provide the user/root password to accomplish that particular task, so using the SSH option will send your logins in an encrypted manner so that your password will be safe.\n\nTo use rsync over SSH, you can use the option to specify the remote shell command, which is typically ssh as shown.\n\n6. Copy a File from a Remote Server to a Local Server with SSH\n\nTo synchronize a file from a remote server to a local server, you can specify a protocol with rsync using the “-e” option with the protocol name you want to use.\n\nHere in this example, We will be using the “ssh” with the “-e” option and perform data transfer.\n\n7. Copy a File from a Local Server to a Remote Server with SSH\n\nTo synchronize a file from a local server to a remote server using SSH, you can leverage the following command as shown.\n\nTo show the progress while transferring the data from one machine to a different machine, we can use the ‘ option, which displays the files and the time remaining to complete the transfer.\n\n9. Include Files with Particular Extension with Rsync\n\nTo include specific files or patterns during a rsync operation, you can use the option with an extension that matches all files.\n\nIn the provided example, rsync will include only files with the extension from the /path/to/source/ directory during the transfer.\n\n10. Exclude Files with Particular Extension with Rsync\n\nSimilarly, to exclude a specific extension during a rsync operation, you can use the option with a wildcard pattern.\n\nIn the provided example, rsync will exclude files with the specified extension during the transfer, while including all other files and directories.\n\nTo include and exclude specific files or patterns during a rsync operation, you can use both the and options with appropriate wildcard patterns.\n\nThese two options allow us to include and exclude files by specifying parameters these option helps us to specify those files or directories which you want to include in your sync and exclude files and folders with which you don’t want to be transferred.\n\nHere in this example, the rsync command will include those files and directories only which starts with and exclude all other files and directories.\n\n12. Use of –delete Option with Rsync\n\nIf a file or directory does not exist at the source, but already exists at the destination, you might want to delete that existing file/directory at the target while syncing.\n\nWe can use the ‘ ‘ option to delete files that are not there in the source directory.\n\nThe source and target are in sync. Now create a new file test.txt at the target.\n\nTarget has the new file called test.txt when synchronizing with the source with the ‘ ‘ option, it removed the file test.txt.\n\nYou can specify the Max file size to be transferred or synced. You can do it with the “ ” option. Here in this example, the Max file size is 200k, so this command will transfer only those files which are equal to or smaller than 200k.\n\nNow, suppose you have the main web server and a data backup server, you created a daily backup and synced it with your backup server, but now you don’t want to keep that local copy of the backup in your web server.\n\nSo, will you wait for the transfer to complete and then delete that local backup file manually? Of Course NO. This automatic deletion can be done using the ‘ ‘ option.\n\nIf you are a newbie using rsync and don’t know what exactly your command going to do. Rsync could really mess up the things in your destination folder and then doing an undo can be a tedious job.\n\nUse of this option will not make any changes to the files and shows the output of the command, if the output shows exactly the same as you want to do then you can remove the ‘ ‘ option from your command and run on the terminal.\n\nYou can set the bandwidth limit while transferring data from one machine to another machine with the help of ‘ ‘ option. This option helps us to limit I/O bandwidth.\n\nAlso, by default rsync syncs changed blocks and bytes only, if you explicitly want to sync the whole file then you use the ‘-W‘ option with it.\n\nThat concludes our overview of rsync and its capabilities. For further exploration of its extensive options and functionalities, I encourage you to refer to the comprehensive manual pages (man pages) available."
    },
    {
        "link": "https://medium.com/itversity/efficient-syncing-with-rsync-command-2b5a9dd9e13c",
        "document": "(Remote Sync) is a command-line utility used to synchronize files and directories between two locations over a network or locally. It is designed to minimize data transfer by only copying the differences between the source and destination, making it highly efficient.\n\nHistorical Background: Developed by Andrew Tridgell in 1996, was created to address the need for a fast and reliable method of synchronizing files. Its ability to transfer only changed data, rather than entire files, marked a significant advancement over existing tools.\n\nReal-World Analogy: Imagine you need to update your friend’s copy of a book with new information you’ve added. Instead of sending the entire book again, you only send the new pages and the specific changes. works similarly by updating only the changed parts, saving time and bandwidth.\n• Source: The file or directory you want to copy from.\n• Destination: The location where you want to copy the files or directories to.\n• Delta Transfer Algorithm: The method uses to transfer only the changed parts of files, rather than the entire file.\n• Checksum: A value used to verify data integrity by detecting errors in the transferred files.\n• Synchronization: The process of ensuring that two or more locations contain the same data.\n• Incremental Backup: A type of backup that only copies the data that has changed since the last backup.\n• Bandwidth: The amount of data that can be transmitted over a network in a given amount of time.\n\nTo synchronize a local directory with a remote directory, use the following command:\n\nThis command copies the contents of the source directory to the destination directory on the remote host.\n\nThis option preserves the permissions, timestamps, symbolic links, and other attributes of the files.\n\nThis option provides detailed output during the synchronization process.\n\nThis option compresses the data during transfer to save bandwidth.\n\n💡 Pro Tip: Use the option to show progress during the transfer and allow resuming of partial transfers.\n\nTo exclude specific files from syncing, use the option:\n\nTo exclude multiple files and directories, create an exclude file:\n\nThen use the option:\n\ncan be used to create incremental backups by using the option:\n\nThis command creates a new backup that only includes the changes since the previous backup.\n\nTo synchronize files over SSH, simply include the SSH protocol in the command:\n\nTo preview the changes will make without actually performing the synchronization, use the or option:\n\nTo delete files in the destination that are not present in the source, use the option:\n• Data Backup: System administrators use to create regular backups of critical data, ensuring that they have up-to-date copies in case of data loss.\n• Website Deployment: Developers use to deploy website updates, ensuring that only the changed files are transferred to the server, reducing downtime.\n• Directory Mirroring: is used to maintain identical copies of directories across multiple machines, such as synchronized project directories for collaborative work.\n• Remote File Transfer: is employed to efficiently transfer large files between remote servers, minimizing bandwidth usage and transfer time.\n\nHands-On Exercise: Setting Up and Using\n\nStep Two: Synchronize the sample directory to a new destination:\n\nSet up an incremental backup system using and cron jobs.\n\nIn this comprehensive guide, we explored the utility, its key concepts, practical examples, and advanced techniques. We also discussed real-world applications and provided a hands-on exercise to get you started. By mastering , you can efficiently synchronize files and directories, create incremental backups, and optimize data transfers.\n• is a powerful tool for synchronizing files and directories, offering efficiency and flexibility.\n• Understanding key concepts such as delta transfer, synchronization, and incremental backups is crucial for effective use of .\n• Advanced techniques, including excluding files, synchronizing over SSH, and creating incremental backups, enhance the utility of .\n• Hands-on practice is essential to mastering and leveraging its full potential.\n\nNext Steps for Further Learning 💪\n• The man pages ( ) for more advanced options.\n• Online tutorials and courses on Linux system administration and file synchronization.\n• Experiment with different options and configurations to see their effects.\n• Set up for regular data backups and directory synchronization.\n• Use in combination with other command-line tools for more powerful data management tasks.\n\nBy mastering , you'll be well-equipped to handle data synchronization tasks efficiently, ensuring optimal resource utilization and streamlined workflows. Happy syncing! 🎉"
    },
    {
        "link": "https://redhat.com/en/blog/sync-rsync",
        "document": "Admins (or normal users) often need to back up files or keep them in sync between multiple places (including local and remote) without transferring and overwrite all files on the target every time. One of the most useful tools in a sysadmin’s belt for this kind of task is .\n\nThe tool can recursively navigate a directory structure and update a second location with any new/changed/removed files. It checks to see if files exist in the destination before sending them, saving bandwidth and time for everything it skips. Also, provides the ability to synchronize a directory structure (or even a single file) with another destination, local or remote. To accomplish this efficiently, by default, it will check the modification times of files. It can also do a quick hash check of files on the source and destination to determine whether or not it needs to transfer a new copy, possibly saving significant time and bandwidth.\n\n[ You might also like: 5 advanced rsync tips for Linux sysadmins ]\n\nSince it comes packaged with most Linux distributions by default, it should be easy to get started. This is also the case with macOS, *BSDs, and other Unix-like operating systems. Working with is easy and can be used on the command line, in scripts, and some tools wrap it in a nice UI for managing tasks.\n\nOn the command line, is generally invoked using a handful of parameters to define how it should behave since it’s a flexible tool. In its simplest form, can be told to ensure that a file in one location should be the same in a second location in a filesystem.\n\nIt’s ordinarily desirable to pass a few parameters to ensure things behave the way a human would expect them to. Passing parameters such as for “archive” is quite common as it is a “meta-parameter” that automatically invokes a handful of others for you. The is equivalent to , which breaks down to:\n• : Recurse through directories (as opposed to only working on files in the current directory)\n• : Preserve user ownership (which is restricted to only superusers when dealing with other user’s files)\n\nOften this works how the user wants and no significant changes are necessary. But, some of those might be contrary to what a user needs, so breaking it out into the specific functionality might be the right answer.\n• : Only show the list of files that would transfer\n• : Show progress overall, outputting information about each file as it completes it\n• : Skip updating target files if they are newer than the source\n• : Quiet mode. Useful for inclusion in scripting when the terminal output is not required\n• : Use a checksum value to determine which files to skip, rather than the modification time and size\n• : Only update files, but don’t create new ones that are missing\n• : Use PATTERN to exclude files from the sync\n• : Same as above, but read from a file\n• : Also used to negate the exclusion rules\n• : Same as above, but read from a file\n\nMy personal default set of parameters for end up being (archive, verbose output, update only new files, and show the progress of the work being done).\n\nThe source and target for the sync are files and directories. Also, provides the functionality to interact with remote systems over SSH, which keeps the user from needing to set up network shares to be able to sync files from one place to another. This means you can easily script jobs after configuring SSH keys on both ends, removing the need to manually login in for remote file sync.\n\nBreaking down the syntax here:\n• With the parameters described above\n• Using steve as a user on the remote system\n• Where the remote system is called fileserver and can be reached by that name\n• And the relative path from steve's home is shown after the : - and in this case, it means to put this in steve’s home directory itself\n\nThis copies over everything from steve’s Documents folder to the Documents directory on the remote system, only updating files that have changed or are new. Running this once is sufficient (until there are new changes). Running it again immediately afterward should produce relatively the same amount of output but be much faster because it skips all the files.\n\n[ The API owner's manual: 7 best practices of effective API programs ]\n\nThere are many useful ways to take advantage of the power of . It's often as simple as running it from the command line on a one-off basis to copy over a set of files without worrying about wasting time copying things that already exist on the destination. Scripting this, adding it to jobs, and experimenting with different parameters helps accomplish even more goals for the average sysadmin."
    }
]