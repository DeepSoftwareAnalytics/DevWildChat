[
    {
        "link": "https://docs.python.org/3/library/random.html",
        "document": "This module implements pseudo-random number generators for various distributions.\n\nFor integers, there is uniform selection from a range. For sequences, there is uniform selection of a random element, a function to generate a random permutation of a list in-place, and a function for random sampling without replacement.\n\nOn the real line, there are functions to compute uniform, normal (Gaussian), lognormal, negative exponential, gamma, and beta distributions. For generating distributions of angles, the von Mises distribution is available.\n\nAlmost all module functions depend on the basic function , which generates a random float uniformly in the half-open range . Python uses the Mersenne Twister as the core generator. It produces 53-bit precision floats and has a period of 2**19937-1. The underlying implementation in C is both fast and threadsafe. The Mersenne Twister is one of the most extensively tested random number generators in existence. However, being completely deterministic, it is not suitable for all purposes, and is completely unsuitable for cryptographic purposes.\n\nThe functions supplied by this module are actually bound methods of a hidden instance of the class. You can instantiate your own instances of to get generators that don’t share state.\n\nClass can also be subclassed if you want to use a different basic generator of your own devising: see the documentation on that class for more details.\n\nThe module also provides the class which uses the system function to generate random numbers from sources provided by the operating system.\n\nReturn a random element from the non-empty sequence seq. If seq is empty, raises . Return a k sized list of elements chosen from the population with replacement. If the population is empty, raises . If a weights sequence is specified, selections are made according to the relative weights. Alternatively, if a cum_weights sequence is given, the selections are made according to the cumulative weights (perhaps computed using ). For example, the relative weights are equivalent to the cumulative weights . Internally, the relative weights are converted to cumulative weights before making selections, so supplying the cumulative weights saves work. If neither weights nor cum_weights are specified, selections are made with equal probability. If a weights sequence is supplied, it must be the same length as the population sequence. It is a to specify both weights and cum_weights. The weights or cum_weights can use any numeric type that interoperates with the values returned by (that includes integers, floats, and fractions but excludes decimals). Weights are assumed to be non-negative and finite. A is raised if all weights are zero. For a given seed, the function with equal weighting typically produces a different sequence than repeated calls to . The algorithm used by uses floating-point arithmetic for internal consistency and speed. The algorithm used by defaults to integer arithmetic with repeated selections to avoid small biases from round-off error. Changed in version 3.9: Raises a if all weights are zero. To shuffle an immutable sequence and return a new shuffled list, use instead. Note that even for small , the total number of permutations of x can quickly grow larger than the period of most random number generators. This implies that most permutations of a long sequence can never be generated. For example, a sequence of length 2080 is the largest that can fit within the period of the Mersenne Twister random number generator. Return a k length list of unique elements chosen from the population sequence. Used for random sampling without replacement. Returns a new list containing elements from the population while leaving the original population unchanged. The resulting list is in selection order so that all sub-slices will also be valid random samples. This allows raffle winners (the sample) to be partitioned into grand prize and second place winners (the subslices). Members of the population need not be hashable or unique. If the population contains repeats, then each occurrence is a possible selection in the sample. Repeated elements can be specified one at a time or with the optional keyword-only counts parameter. For example, is equivalent to . To choose a sample from a range of integers, use a object as an argument. This is especially fast and space efficient for sampling from a large population: . If the sample size is larger than the population size, a is raised. Changed in version 3.11: The population must be a sequence. Automatic conversion of sets to lists is no longer supported.\n\nThe following functions generate specific real-valued distributions. Function parameters are named after the corresponding variables in the distribution’s equation, as used in common mathematical practice; most of these equations can be found in any statistics text. Return the next random floating-point number in the range Return a random floating-point number N such that for and for . The end-point value may or may not be included in the range depending on floating-point rounding in the expression . Return a random floating-point number N such that and with the specified mode between those bounds. The low and high bounds default to zero and one. The mode argument defaults to the midpoint between the bounds, giving a symmetric distribution. Beta distribution. Conditions on the parameters are and . Returned values range between 0 and 1. Exponential distribution. lambd is 1.0 divided by the desired mean. It should be nonzero. (The parameter would be called “lambda”, but that is a reserved word in Python.) Returned values range from 0 to positive infinity if lambd is positive, and from negative infinity to 0 if lambd is negative. Changed in version 3.12: Added the default value for . Gamma distribution. (Not the gamma function!) The shape and scale parameters, alpha and beta, must have positive values. (Calling conventions vary and some sources define ‘beta’ as the inverse of the scale). Normal distribution, also called the Gaussian distribution. mu is the mean, and sigma is the standard deviation. This is slightly faster than the function defined below. Multithreading note: When two threads call this function simultaneously, it is possible that they will receive the same return value. This can be avoided in three ways. 1) Have each thread use a different instance of the random number generator. 2) Put locks around all calls. 3) Use the slower, but thread-safe function instead. Changed in version 3.11: mu and sigma now have default arguments. Log normal distribution. If you take the natural logarithm of this distribution, you’ll get a normal distribution with mean mu and standard deviation sigma. mu can have any value, and sigma must be greater than zero. Normal distribution. mu is the mean, and sigma is the standard deviation. Changed in version 3.11: mu and sigma now have default arguments. mu is the mean angle, expressed in radians between 0 and 2*pi, and kappa is the concentration parameter, which must be greater than or equal to zero. If kappa is equal to zero, this distribution reduces to a uniform random angle over the range 0 to 2*pi. Weibull distribution. alpha is the scale parameter and beta is the shape parameter.\n\n# Even integer from 0 to 100 inclusive ['four', 'two', 'ace', 'three'] # of 52 playing cards, and determine the proportion of cards # Estimate the probability of getting 5 or more heads from 7 spins # of a biased coin that settles on heads 60% of the time. # Probability of the median of 5 samples being in middle two quartiles Example of statistical bootstrapping using resampling with replacement to estimate a confidence interval for the mean of a sample: Example of a resampling permutation test to determine the statistical significance or p-value of an observed difference between the effects of a drug versus a placebo: # Example from \"Statistics is Easy\" by Dennis Shasha and Manda Wilson 'at least as extreme as the observed difference of leads us to reject the null' 'hypothesis that there is no difference between the drug and the placebo.' Simulation of arrival times and service deliveries for a multiserver queue: # time when each server becomes available Statistics for Hackers a video tutorial by Jake Vanderplas on statistical analysis using just a few fundamental concepts including simulation, sampling, shuffling, and cross-validation. Economics Simulation a simulation of a marketplace by Peter Norvig that shows effective use of many of the tools and distributions provided by this module (gauss, uniform, sample, betavariate, choice, triangular, and randrange). A Concrete Introduction to Probability (using Python) a tutorial by Peter Norvig covering the basics of probability theory, how to write simulations, and how to perform data analysis using Python.\n\nThese recipes show how to efficiently make random selections from the combinatoric iterators in the module: \"Choose r elements with replacement. Order the result to match the iterable.\" # Result will be in set(itertools.combinations_with_replacement(iterable, r)). The default returns multiples of 2⁻⁵³ in the range 0.0 ≤ x < 1.0. All such numbers are evenly spaced and are exactly representable as Python floats. However, many other representable floats in that interval are not possible selections. For example, isn’t an integer multiple of 2⁻⁵³. The following recipe takes a different approach. All floats in the interval are possible selections. The mantissa comes from a uniform distribution of integers in the range 2⁵² ≤ mantissa < 2⁵³. The exponent comes from a geometric distribution where exponents smaller than -53 occur half as often as the next larger exponent. All real valued distributions in the class will use the new method: The recipe is conceptually equivalent to an algorithm that chooses from all the multiples of 2⁻¹⁰⁷⁴ in the range 0.0 ≤ x < 1.0. All such numbers are evenly spaced, but most have to be rounded down to the nearest representable Python float. (The value 2⁻¹⁰⁷⁴ is the smallest positive unnormalized float and is equal to .) Generating Pseudo-random Floating-Point Values a paper by Allen B. Downey describing ways to generate more fine-grained floats than normally generated by ."
    },
    {
        "link": "https://w3schools.com/python/ref_random_choices.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://docs.python.org/2/library/random.html",
        "document": "This module implements pseudo-random number generators for various distributions.\n\nFor integers, uniform selection from a range. For sequences, uniform selection of a random element, a function to generate a random permutation of a list in-place, and a function for random sampling without replacement.\n\nOn the real line, there are functions to compute uniform, normal (Gaussian), lognormal, negative exponential, gamma, and beta distributions. For generating distributions of angles, the von Mises distribution is available.\n\nAlmost all module functions depend on the basic function , which generates a random float uniformly in the semi-open range [0.0, 1.0). Python uses the Mersenne Twister as the core generator. It produces 53-bit precision floats and has a period of 2**19937-1. The underlying implementation in C is both fast and threadsafe. The Mersenne Twister is one of the most extensively tested random number generators in existence. However, being completely deterministic, it is not suitable for all purposes, and is completely unsuitable for cryptographic purposes.\n\nThe functions supplied by this module are actually bound methods of a hidden instance of the class. You can instantiate your own instances of to get generators that don’t share state. This is especially useful for multi-threaded programs, creating a different instance of for each thread, and using the method to make it likely that the generated sequences seen by each thread don’t overlap.\n\nClass can also be subclassed if you want to use a different basic generator of your own devising: in that case, override the , , , and methods. Optionally, a new generator can supply a method — this allows to produce selections over an arbitrarily large range.\n\nAs an example of subclassing, the module provides the class that implements an alternative generator in pure Python. The class provides a backward compatible way to reproduce results from earlier versions of Python, which used the Wichmann-Hill algorithm as the core generator. Note that this Wichmann-Hill generator can no longer be recommended: its period is too short by contemporary standards, and the sequence generated is known to fail some stringent randomness tests. See the references below for a recent variant that repairs these flaws.\n\nThe module also provides the class which uses the system function to generate random numbers from sources provided by the operating system.\n\nReturn a k length list of unique elements chosen from the population sequence. Used for random sampling without replacement. Returns a new list containing elements from the population while leaving the original population unchanged. The resulting list is in selection order so that all sub-slices will also be valid random samples. This allows raffle winners (the sample) to be partitioned into grand prize and second place winners (the subslices). Members of the population need not be hashable or unique. If the population contains repeats, then each occurrence is a possible selection in the sample. To choose a sample from a range of integers, use an object as an argument. This is especially fast and space efficient for sampling from a large population: .\n\nThe following functions generate specific real-valued distributions. Function parameters are named after the corresponding variables in the distribution’s equation, as used in common mathematical practice; most of these equations can be found in any statistics text."
    },
    {
        "link": "https://w3schools.com/python/module_random.asp",
        "document": "Python has a built-in module that you can use to make random numbers.\n\nThe module has a set of methods:"
    },
    {
        "link": "https://geeksforgeeks.org/random-choices-method-in-python",
        "document": "The choices() method returns multiple random elements from the list with replacement. Unlike random.choice(), which selects a single item, random.choices() allows us to select multiple items making it particularly useful for tasks like sampling from a population or generating random data.\n• None The code uses random.choices() to select 5 items from the list a = [“geeks”, “for”, “python”].\n• Weights: The item “geeks” has a weight of 10, making it 10 times more likely to be selected than “for” and “python”, which each have a weight of 1.\n• k = 5: Specifies that 5 items will be selected, with replacement (meaning duplicates are possible).\n\nNote: Every time output will be different as the system returns random elements.\n\nLet’s take a closer look at random.choices() method:\n• Example 2: Selects 3 elements from items with specified weights, making some items more likely to be selected.\n• Example 3: Selects 3 elements with cumulative weights, ensuring that selection probabilities are proportionally distributed.\n• Example 4: Selects 5 random characters from the alphabet string, demonstrating the flexibility of random.choices() with strings.\n\nIt allows for sampling with replacement, meaning the same item can be selected multiple times. Common practical applications include:\n• Lottery or Prize Draws: Randomly selecting winners from a pool of entries, where some participants may have more chances based on certain conditions.\n• Simulating Weighted Outcomes: For example, simulating biased coin flips or biased random events (e.g., selecting between different items in a game where certain items are rarer).\n• Random Sampling: Selecting items from a list for tasks like A/B testing, survey sampling, or testing combinations."
    },
    {
        "link": "https://automatetheboringstuff.com/2e/chapter8",
        "document": "Input validation code checks that values entered by the user, such as text from the input() function, are formatted correctly. For example, if you want users to enter their ages, your code shouldn’t accept nonsensical answers such as negative numbers (which are outside the range of acceptable integers) or words (which are the wrong data type). Input validation can also prevent bugs or security vulnerabilities. If you implement a withdrawFromAccount() function that takes an argument for the amount to subtract from an account, you need to ensure the amount is a positive number. If the withdrawFromAccount() function subtracts a negative number from the account, the “withdrawal” will end up adding money!\n\nTypically, we perform input validation by repeatedly asking the user for input until they enter valid text, as in the following example:\n\nwhile True:\n\n print('Enter your age:')\n\n age = input()\n\n try:\n\n age = int(age)\n\n except:\n\n print('Please use numeric digits.')\n\n continue\n\n if age < 1:\n\n print('Please enter a positive number.')\n\n continue\n\n break\n\n\n\n print(f'Your age is {age}.')\n\nWhen you run this program, the output could look like this:\n\nEnter your age:\n\n five\n\n Please use numeric digits.\n\n Enter your age:\n\n -2\n\n Please enter a positive number.\n\n Enter your age:\n\n 30\n\n Your age is 30.\n\nWhen you run this code, you’ll be prompted for your age until you enter a valid one. This ensures that by the time the execution leaves the while loop, the age variable will contain a valid value that won’t crash the program later on.\n\nHowever, writing input validation code for every input() call in your program quickly becomes tedious. Also, you may miss certain cases and allow invalid input to pass through your checks. In this chapter, you’ll learn how to use the third-party PyInputPlus module for input validation.\n\nPyInputPlus contains functions similar to input() for several kinds of data: numbers, dates, email addresses, and more. If the user ever enters invalid input, such as a badly formatted date or a number that is outside of an intended range, PyInputPlus will reprompt them for input just like our code in the previous section did. PyInputPlus also has other useful features like a limit for the number of times it reprompts users and a timeout if users are required to respond within a time limit.\n\nPyInputPlus is not a part of the Python Standard Library, so you must install it separately using Pip. To install PyInputPlus, run pip install --user pyinputplus from the command line. Appendix A has complete instructions for installing third-party modules. To check if PyInputPlus installed correctly, import it in the interactive shell:\n\nIf no errors appear when you import the module, it has been successfully installed.\n\nPyInputPlus has several functions for different kinds of input:\n\ninputStr() Is like the built-in input() function but has the general PyInputPlus features. You can also pass a custom validation function to it\n\ninputNum() Ensures the user enters a number and returns an int or float, depending on if the number has a decimal point in it\n\ninputChoice() Ensures the user enters one of the provided choices\n\ninputMenu() Is similar to inputChoice(), but provides a menu with numbered or lettered options\n\ninputBool() Is similar to inputYesNo(), but takes a “True” or “False” response and returns a Boolean value\n\ninputFilepath() Ensures the user enters a valid file path and filename, and can optionally check that a file with that name exists\n\ninputPassword() Is like the built-in input(), but displays * characters as the user types so that passwords, or other sensitive information, aren’t displayed on the screen\n\nThese functions will automatically reprompt the user for as long as they enter invalid input:\n\n>>> import pyinputplus as pyip\n\n >>> response = pyip.inputNum()\n\n five\n\n 'five' is not a number.\n\n 42\n\n >>> response\n\n 42\n\nThe as pyip code in the import statement saves us from typing pyinputplus each time we want to call a PyInputPlus function. Instead we can use the shorter pyip name. If you take a look at the example, you see that unlike input(), these functions return an int or float value: 42 and 3.14 instead of the strings '42' and '3.14'.\n\nJust as you can pass a string to input() to provide a prompt, you can pass a string to a PyInputPlus function’s prompt keyword argument to display a prompt:\n\n>>> response = input('Enter a number: ')\n\n Enter a number: 42\n\n >>> response\n\n '42'\n\n >>> import pyinputplus as pyip\n\n >>> response = pyip.inputInt(prompt='Enter a number: ')\n\n Enter a number: cat\n\n 'cat' is not an integer.\n\n Enter a number: 42\n\n >>> response\n\n 42\n\nUse Python’s help() function to find out more about each of these functions. For example, help(pyip.inputChoice) displays help information for the inputChoice() function. Complete documentation can be found at https://pyinputplus.readthedocs.io/.\n\nUnlike Python’s built-in input(), PyInputPlus functions have several additional features for input validation, as shown in the next section.\n\nThe inputNum(), inputInt(), and inputFloat() functions, which accept int and float numbers, also have min, max, greaterThan, and lessThan keyword arguments for specifying a range of valid values. For example, enter the following into the interactive shell:\n\n>>> import pyinputplus as pyip\n\n >>> response = pyip.inputNum('Enter num: ', min=4)\n\n Enter num:3\n\n Input must be at minimum 4.\n\n Enter num:4\n\n >>> response\n\n 4\n\n >>> response = pyip.inputNum('Enter num: ', greaterThan=4)\n\n Enter num: 4\n\n Input must be greater than 4.\n\n Enter num: 5\n\n >>> response\n\n 5\n\n >>> response = pyip.inputNum('>', min=4, lessThan=6)\n\n Enter num: 6\n\n Input must be less than 6.\n\n Enter num: 3\n\n Input must be at minimum 4.\n\n Enter num: 4\n\n >>> response\n\n 4\n\nThese keyword arguments are optional, but if supplied, the input cannot be less than the min argument or greater than the max argument (though the input can be equal to them). Also, the input must be greater than the greaterThan and less than the lessThan arguments (that is, the input cannot be equal to them).\n\nBy default, blank input isn’t allowed unless the blank keyword argument is set to True:\n\n>>> import pyinputplus as pyip\n\n >>> response = pyip.inputNum('Enter num: ')\n\n Enter num:(blank input entered here)\n\n Blank values are not allowed.\n\n Enter num: 42\n\n >>> response\n\n 42\n\n >>> response = pyip.inputNum(blank=True)\n\n (blank input entered here)\n\n >>> response\n\n ''\n\nUse blank=True if you’d like to make input optional so that the user doesn’t need to enter anything.\n\nBy default, the PyInputPlus functions will continue to ask the user for valid input forever (or for as long as the program runs). If you’d like a function to stop asking the user for input after a certain number of tries or a certain amount of time, you can use the limit and timeout keyword arguments. Pass an integer for the limit keyword argument to determine how many attempts a PyInputPlus function will make to receive valid input before giving up, and pass an integer for the timeout keyword argument to determine how many seconds the user has to enter valid input before the PyInputPlus function gives up.\n\nIf the user fails to enter valid input, these keyword arguments will cause the function to raise a RetryLimitException or TimeoutException, respectively. For example, enter the following into the interactive shell:\n\n>>> import pyinputplus as pyip\n\n >>> response = pyip.inputNum(limit=2)\n\n blah\n\n 'blah' is not a number.\n\n Enter num: number\n\n 'number' is not a number.\n\n Traceback (most recent call last):\n\n --snip--\n\n pyinputplus.RetryLimitException\n\n >>> response = pyip.inputNum(timeout=10)\n\n 42 (entered after 10 seconds of waiting)\n\n Traceback (most recent call last):\n\n --snip--\n\n pyinputplus.TimeoutException\n\nWhen you use these keyword arguments and also pass a default keyword argument, the function returns the default value instead of raising an exception. Enter the following into the interactive shell:\n\n>>> response = pyip.inputNum(limit=2, default='N/A')\n\n hello\n\n 'hello' is not a number.\n\n world\n\n 'world' is not a number.\n\n >>> response\n\n 'N/A'\n\nInstead of raising RetryLimitException, the inputNum() function simply returns the string 'N/A'.\n\nYou can also use regular expressions to specify whether an input is allowed or not. The allowRegexes and blockRegexes keyword arguments take a list of regular expression strings to determine what the PyInputPlus function will accept or reject as valid input. For example, enter the following code into the interactive shell so that inputNum() will accept Roman numerals in addition to the usual numbers:\n\nOf course, this regex affects only what letters the inputNum() function will accept from the user; the function will still accept Roman numerals with invalid ordering such as 'XVX' or 'MILLI' because the r'(I|V|X|L|C|D|M)+' regular expression accepts those strings.\n\nYou can also specify a list of regular expression strings that a PyInputPlus function won’t accept by using the blockRegexes keyword argument. Enter the following into the interactive shell so that inputNum() won’t accept even numbers:\n\n>>> import pyinputplus as pyip\n\n >>> response = pyip.inputNum(blockRegexes=[r'[02468]$'])\n\n 42\n\n This response is invalid.\n\n 44\n\n This response is invalid.\n\n 43\n\n >>> response\n\n 43\n\nIf you specify both an allowRegexes and blockRegexes argument, the allow list overrides the block list. For example, enter the following into the interactive shell, which allows 'caterpillar' and 'category' but blocks anything else that has the word 'cat' in it:\n\n>>> import pyinputplus as pyip\n\n >>> response = pyip.inputStr(allowRegexes=[r'caterpillar', 'category'],\n\n blockRegexes=[r'cat'])\n\n cat\n\n This response is invalid.\n\n catastrophe\n\n This response is invalid.\n\n category\n\n >>> response\n\n 'category'\n\nThe PyInputPlus module’s functions can save you from writing tedious input validation code yourself. But there’s more to the PyInputPlus module than what has been detailed here. You can examine its full documentation online at https://pyinputplus.readthedocs.io/.\n\nYou can write a function to perform your own custom validation logic by passing the function to inputCustom(). For example, say you want the user to enter a series of digits that adds up to 10. There is no pyinputplus.inputAddsUpToTen() function, but you can create your own function that:\n• Accepts a single string argument of what the user entered\n• Raises an exception if the string fails validation\n• Returns (or has no statement) if should return the string unchanged\n• Returns a non- value if should return a different string from the one the user entered\n• Is passed as the first argument to\n\nFor example, we can create our own addsUpToTen() function, and then pass it to inputCustom(). Note that the function call looks like inputCustom(addsUpToTen) and not inputCustom(addsUpToTen()) because we are passing the addsUpToTen() function itself to inputCustom(), not calling addsUpToTen() and passing its return value.\n\n>>> import pyinputplus as pyip\n\n >>> def addsUpToTen(numbers):\n\n ... numbersList = list(numbers)\n\n ... for i, digit in enumerate(numbersList):\n\n ... numbersList[i] = int(digit)\n\n ... if sum(numbersList) != 10:\n\n ... raise Exception('The digits must add up to 10, not %s.' %\n\n (sum(numbersList)))\n\n ... return int(numbers) # Return an int form of numbers.\n\n ...\n\n >>> response = pyip.inputCustom(addsUpToTen) # No parentheses after\n\n addsUpToTen here.\n\n 123\n\n The digits must add up to 10, not 6.\n\n 1235\n\n The digits must add up to 10, not 11.\n\n 1234\n\n >>> response # inputStr() returned an int, not a string.\n\n 1234\n\n >>> response = pyip.inputCustom(addsUpToTen)\n\n hello\n\n invalid literal for int() with base 10: 'h'\n\n 55\n\n >>> response\n\nThe inputCustom() function also supports the general PyInputPlus features, such as the blank, limit, timeout, default, allowRegexes, and blockRegexes keyword arguments. Writing your own custom validation function is useful when it’s otherwise difficult or impossible to write a regular expression for valid input, as in the “adds up to 10” example.\n\nProject: How to Keep an Idiot Busy for Hours\n\nLet’s use PyInputPlus to create a simple program that does the following:\n• Ask the user if they’d like to know how to keep an idiot busy for hours.\n• If the user answers no, quit.\n• If the user answers yes, go to Step 1.\n\nOf course, we don’t know if the user will enter something besides “yes” or “no,” so we need to perform input validation. It would also be convenient for the user to be able to enter “y” or “n” instead of the full words. PyInputPlus’s inputYesNo() function will handle this for us and, no matter what case the user enters, return a lowercase 'yes' or 'no' string value.\n\nWhen you run this program, it should look like the following:\n\nWant to know how to keep an idiot busy for hours?\n\n sure\n\n 'sure' is not a valid yes/no response.\n\n Want to know how to keep an idiot busy for hours?\n\n yes\n\n Want to know how to keep an idiot busy for hours?\n\n y\n\n Want to know how to keep an idiot busy for hours?\n\n Yes\n\n Want to know how to keep an idiot busy for hours?\n\n YES\n\n Want to know how to keep an idiot busy for hours?\n\n YES!!!!!!\n\n 'YES!!!!!!' is not a valid yes/no response.\n\n Want to know how to keep an idiot busy for hours?\n\n TELL ME HOW TO KEEP AN IDIOT BUSY FOR HOURS.\n\n 'TELL ME HOW TO KEEP AN IDIOT BUSY FOR HOURS.' is not a valid yes/no response.\n\n Want to know how to keep an idiot busy for hours?\n\n no\n\n Thank you. Have a nice day.\n\nOpen a new file editor tab and save it as idiot.py. Then enter the following code:\n\nThis imports the PyInputPlus module. Since pyinputplus is a bit much to type, we’ll use the name pyip for short.\n\nwhile True:\n\n prompt = 'Want to know how to keep an idiot busy for hours?\n\n'\n\n response = pyip.inputYesNo(prompt)\n\nNext, while True: creates an infinite loop that continues to run until it encounters a break statement. In this loop, we call pyip.inputYesNo() to ensure that this function call won’t return until the user enters a valid answer.\n\nThe pyip.inputYesNo() call is guaranteed to only return either the string yes or the string no. If it returned no, then our program breaks out of the infinite loop and continues to the last line, which thanks the user:\n\nOtherwise, the loop iterates once again.\n\nYou can also make use of the inputYesNo() function in non-English languages by passing yesVal and noVal keyword arguments. For example, the Spanish version of this program would have these two lines:\n\nNow the user can enter either sí or s (in lower- or uppercase) instead of yes or y for an affirmative answer.\n\nPyInputPlus’s features can be useful for creating a timed multiplication quiz. By setting the allowRegexes, blockRegexes, timeout, and limit keyword argument to pyip.inputStr(), you can leave most of the implementation to PyInputPlus. The less code you need to write, the faster you can write your programs. Let’s create a program that poses 10 multiplication problems to the user, where the valid input is the problem’s correct answer. Open a new file editor tab and save the file as multiplicationQuiz.py.\n\nFirst, we’ll import pyinputplus, random, and time. We’ll keep track of how many questions the program asks and how many correct answers the user gives with the variables numberOfQuestions and correctAnswers. A for loop will repeatedly pose a random multiplication problem 10 times:\n\nimport pyinputplus as pyip\n\n import random, time\n\n\n\n numberOfQuestions = 10\n\n correctAnswers = 0\n\n for questionNumber in range(numberOfQuestions):\n\nInside the for loop, the program will pick two single-digit numbers to multiply. We’ll use these numbers to create a #Q: N × N = prompt for the user, where Q is the question number (1 to 10) and N are the two numbers to multiply.\n\nThe pyip.inputStr() function will handle most of the features of this quiz program. The argument we pass for allowRegexes is a list with the regex string '^%s$', where %s is replaced with the correct answer. The ^ and % characters ensure that the answer begins and ends with the correct number, though PyInputPlus trims any whitespace from the start and end of the user’s response first just in case they inadvertently pressed the spacebar before or after their answer. The argument we pass for blocklistRegexes is a list with ('.*', 'Incorrect!'). The first string in the tuple is a regex that matches every possible string. Therefore, if the user response doesn’t match the correct answer, the program will reject any other answer they provide. In that case, the 'Incorrect!' string is displayed and the user is prompted to answer again. Additionally, passing 8 for timeout and 3 for limit will ensure that the user only has 8 seconds and 3 tries to provide a correct answer:\n\ntry:\n\n # Right answers are handled by allowRegexes.\n\n # Wrong answers are handled by blockRegexes, with a custom message.\n\n pyip.inputStr(prompt, allowRegexes=['^%s$' % (num1 * num2)],\n\n blockRegexes=[('.*', 'Incorrect!')],\n\n timeout=8, limit=3)\n\nIf the user answers after the 8-second timeout has expired, even if they answer correctly, pyip.inputStr() raises a TimeoutException exception. If the user answers incorrectly more than 3 times, it raises a RetryLimitException exception. Both of these exception types are in the PyInputPlus module, so pyip. needs to prepend them:\n\nexcept pyip.TimeoutException:\n\n print('Out of time!')\n\n except pyip.RetryLimitException:\n\n print('Out of tries!')\n\nRemember that, just like how else blocks can follow an if or elif block, they can optionally follow the last except block. The code inside the following else block will run if no exception was raised in the try block. In our case, that means the code runs if the user entered the correct answer:\n\nelse:\n\n # This block runs if no exceptions were raised in the try block.\n\n print('Correct!')\n\n correctAnswers += 1\n\nNo matter which of the three messages, “Out of time!”, “Out of tries!”, or “Correct!”, displays, let’s place a 1-second pause at the end of the for loop to give the user time to read it. After the program has asked 10 questions and the for loop continues, let’s show the user how many correct answers they made:\n\ntime.sleep(1) # Brief pause to let user see the result.\n\n print('Score: %s / %s' % (correctAnswers, numberOfQuestions))\n\nPyInputPlus is flexible enough that you can use it in a wide variety of programs that take keyboard input from the user, as demonstrated by the programs in this chapter.\n\nIt’s easy to forget to write input validation code, but without it, your programs will almost certainly have bugs. The values you expect users to enter and the values they actually enter can be completely different, and your programs need to be robust enough to handle these exceptional cases. You can use regular expressions to create your own input validation code, but for common cases, it’s easier to use an existing module, such as PyInputPlus. You can import the module with import pyinputplus as pyip so that you can enter a shorter name when calling the module’s functions.\n\nPyInputPlus has functions for entering a variety of input, including strings, numbers, dates, yes/no, True/False, emails, and files. While input() always returns a string, these functions return the value in an appropriate data type. The inputChoice() function allow you to select one of several pre-selected options, while inputMenu() also adds numbers or letters for quick selection.\n\nAll of these functions have the following standard features: stripping whitespace from the sides, setting timeout and retry limits with the timeout and limit keyword arguments, and passing lists of regular expression strings to allowRegexes or blockRegexes to include or exclude particular responses. You'll no longer need to write your own tedious while loops that check for valid input and reprompt the user.\n\nIf none of the PyInputPlus module’s, functions fit your needs, but you’d still like the other features that PyInputPlus provides, you can call inputCustom() and pass your own custom validation function for PyInputPlus to use. The documentation at https://pyinputplus.readthedocs.io/en/latest/ has a complete listing of PyInputPlus’s functions and additional features. There’s far more in the PyInputPlus online documentation than what was described in this chapter. There’s no use in reinventing the wheel, and learning to use this module will save you from having to write and debug code for yourself.\n\nNow that you have expertise manipulating and validating text, it’s time to learn how to read from and write to files on your computer’s hard drive.\n\n1. Does PyInputPlus come with the Python Standard Library?\n\n2. Why is PyInputPlus commonly imported with import pyinputplus as pyip?\n\n3. What is the difference between inputInt() and inputFloat()?\n\n4. How can you ensure that the user enters a whole number between 0 and 99 using PyInputPlus?\n\n5. What is passed to the allowRegexes and blockRegexes keyword arguments?\n\n6. What does inputStr(limit=3) do if blank input is entered three times?\n\n7. What does inputStr(limit=3, default='hello') do if blank input is entered three times?\n\nFor practice, write programs to do the following tasks.\n\nWrite a program that asks users for their sandwich preferences. The program should use PyInputPlus to ensure that they enter valid input, such as:\n• Using for a bread type: wheat, white, or sourdough.\n• Using for a protein type: chicken, turkey, ham, or tofu.\n• Using to ask if they want cheese.\n• If so, using to ask for a cheese type: cheddar, Swiss, or mozzarella.\n• Using to ask if they want mayo, mustard, lettuce, or tomato.\n• Using to ask how many sandwiches they want. Make sure this number is 1 or more.\n\nCome up with prices for each of these options, and have your program display a total cost after the user enters their selection.\n\nTo see how much PyInputPlus is doing for you, try re-creating the multiplication quiz project on your own without importing it. This program will prompt the user with 10 multiplication questions, ranging from 0 × 0 to 9 × 9. You’ll need to implement the following features:\n• If the user enters the correct answer, the program displays “Correct!” for 1 second and moves on to the next question.\n• The user gets three tries to enter the correct answer before the program moves on to the next question.\n• Eight seconds after first displaying the question, the question is marked as incorrect even if the user enters the correct answer after the 8-second limit.\n\nCompare your code to the code using PyInputPlus in “Project: Multiplication Quiz” on page 196."
    },
    {
        "link": "https://geeksforgeeks.org/input-validation-in-python",
        "document": "Input validation ensures that data entered by the user is correct, safe, and in the expected format. In Python, input validation is essential for creating robust, error free programs that can handle incorrect or unexpected inputs. This article will cover the importance of input validation, common methods for validating input and practical examples in Python.\n\nPython provides several ways to validate user inputs.\n\nOne of the simplest methods to ensure the input is of the correct type is to use a try-except block. For example, when accepting numeric input, we can ensure that the user enters a valid integer.\n\nHere, if the user enters something that cannot be converted to an integer (like a string), a ValueError is raised, and the user is prompted again.\n\nUsing if Statements for Range Validation\n\nFor situations where you need to ensure the input is within a certain range, you can use a simple if statement.\n\nIn this case, the function will repeatedly prompt the user until they enter a valid age.\n\nFor more complex input validation, such as ensuring an email address or phone number follows a particular format, regular expressions (regex) are useful.\n\nHere, the regular expression pattern ensures that the input matches the typical structure of an email address."
    },
    {
        "link": "https://p-kane.medium.com/input-validation-with-python-570953d5d297",
        "document": "Getting user inputs is one of the most crucial part of any program. What’s more important is to get the right type of input so that the program continues to run without problem.\n\nJust like any other programming language, you can easily write a block of code to validate and filter a user input to ensure the program takes the only correct type of input with Python. You can even create a loop that keeps sending a message to inform the user to input correctly before going to the next step.\n\nFor example, assuming that you need to create a program which takes an integer from the user to perform further operations, you’ll write the following block of code to transform any whole number input into an integer:\n\nTry an input any whole number with the above code and there’s no problem. The variable num stored any whole number you typed in as an integer. Great! The first layer of input validation is successfully pealed. Did I say layer? Yes. That’s because there can be many layers stacked on top of an input validation process, depending solely on what is needed for it to perform.\n\nThe code above will work fine as long as the user inptut a whole number. It breaks easily, however, when it gets something that is not a whole number such as ‘3.14’ or ‘pi’. In other words, the code above will throw an error message if the user give it anything but a whole number:\n\nWe can easily avoid the above error by using try and except as shown in the following code block to catch the error:\n\nAs we already know, without the try except block, the code will throw a ValueError error if the input is anything that can’t be converted into an integer by the int() function, so we specifically tell the try except block to catch this type of error in the code above. However, the program just ends and we need to restart the program again if we are to give it another input.\n\nA while loop can ease this pain. We can create a loop that will never stop telling the user to give the correct type of input until he/she does so:\n\nBasically, the above code tells the program to keep asking the user for a valid integer until it gets one. Once the input is correct, the loop is terminated with the break command. However, it will keep telling the user “Please input a valid integer.” until it gets one. This way, we don’t have to restart the program every time we give it a wrong input. And there’s no error message. The program keeps running (validating the input) smoothly even when we give wrong types of inputs. The second layer of the input validation process is cracked!\n\nIn general, the more specific an input, the more smoothly the program (or data processing) in the later phases will perform. Let’s say, for example, that we need to validate the input so that it’s an integer with the value ranges from 1 to 10 only, we can tweak the above code so that it will take only the said values like the following:\n\nSimply adding an if block that will tell the user to input a valid integer anytime when the value of the variable num is out of the 1–10 range does the trick of letting the program be even more specific about ingesting any input from the user based on the condition(s) in the if block.\n\nThe third layer is cracked!\n\nYou can also apply this knowledge in validating inputs of string type without having to down-cast it to any other data type as well, since the initial data type of the input() function is already string.\n\nLet’s say that, for some reason, you need a program to input a string with only 3 characters in length, you can write a block of code to validate the input according to the said condition like so:\n\nThe above code will keep asking the user for any input with specifically 3 characters in length. Anything less or more than 3-character long will be disregarded.\n\nThere you have it, some easy tricks to validate inputs and negate errors with Python.\n\nIn summary, there are basically 3 main layers for input validation:\n• Type-cast the input as needed just as the example of casting a string to an integer with the int() function.\n• Use the while loop to negate error, let the process of data validation runs smoothly until the program gets the correct type of input.\n• Create conditions so that the input is more tailored to what the user reallly needed. This layer is very important for the future data processing and operations. It minimalizes the chances of future possible errors!\n\nYou see how we can specifically handle the ValueError with the try except block. What if we don’t know what type of error will happen and we just want to handle an error? We can do so with the following code:\n\nIn the code above, we can use Exception to handle a variety of types of unexpected (or unknown) errors.\n\nI do hope you find this short article about input validation with Python useful an applicable with your works. Enjoy coding. Until next time!"
    },
    {
        "link": "https://stackoverflow.com/questions/70723101/user-input-validation-using-functions",
        "document": "To learn more, see our tips on writing great answers .\n\nThanks for contributing an answer to Stack Overflow!\n\nBy clicking “Post Your Answer”, you agree to our terms of service and acknowledge you have read our privacy policy."
    },
    {
        "link": "https://analyticsvidhya.com/blog/2024/01/how-to-effectively-handle-user-input-in-python-programming",
        "document": "How to Effectively Handle User Input in Python Programming?\n\nUser input is an essential aspect of programming as it allows users to interact with the program and provide data or instructions. There are various methods and techniques for taking user input in Python programming. This article will explore different methods, syntax, and usage for handling user input in Python.\n\nUser input stands as a vital component in Python programming, offering the key to creating dynamic and interactive programs. This input feature allows programs to adapt to various scenarios, process personalized data, and generate customized outputs. Whether it’s a basic command-line tool or a sophisticated graphical interface, the incorporation of user input enables programs to cater to the specific needs and preferences of individual users.\n\nEnroll in our free Python Course today.\n\nDifferent Methods for Obtaining User Input in Python\n\nThe most common method, prompting users for input and returning it as a string.\n\nUtilizing the module to read input from command line arguments.\n\nLeveraging methods like , , and for input from files.\n\nUtilizing GUI libraries such as Tkinter for interactive user interfaces.\n\nThe function takes an optional prompt and returns user input as a string.\n\nTo manage varied data types, use type casting or conversion functions.\n\nEnsure input validity with conditional statements and loops for error handling.\n\nGUI libraries such as Tkinter facilitate the development of interactive user interfaces.\n\nFailing to handle such input can lead to program crashes or security vulnerabilities.\n\nLack of validation and sanitization can expose programs to security risks.\n\nKeeping the logic simple and modular enhances code readability and maintainability.\n\nUser input is fundamental in Python programming, allowing for interaction and personalized data processing. This guide provided insights into various methods, syntax, usage, and best practices for handling user input in Python. By following these techniques and avoiding common mistakes, developers can create robust and user-friendly programs.\n\nYou can also refer our other articles to learn and explore about Python:\n• How To Merge Two Lists in Python?\n• How can I Manipulate Python List Elements Using Indexing?\n\nSeasoned AI enthusiast with a deep passion for the ever-evolving world of artificial intelligence. With a sharp eye for detail and a knack for translating complex concepts into accessible language, we are at the forefront of AI updates for you. Having covered AI breakthroughs, new LLM model launches, and expert opinions, we deliver insightful and engaging content that keeps readers informed and intrigued. With a finger on the pulse of AI research and innovation, we bring a fresh perspective to the dynamic field, allowing readers to stay up-to-date on the latest developments."
    }
]