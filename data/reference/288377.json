[
    {
        "link": "https://stackoverflow.com/questions/6718209/when-should-you-use-friend-classes",
        "document": "Friend is used for granting selective access, just like the protected access specifier. It's also hard to come up with proper use case where use of protected is really useful.\n\nIn general, friend classes are useful in designs where there is intentional strong coupling: you need to have a special relationship between two classes. More specifically, one class needs access to another classes's internals and you don't want to grant access to everyone by using the public access specifier.\n\nThe rule of thumb: If public is too weak and private is too strong, you need some form of selected access: either protected or friend (the package access specifier in Java serves the same kind of role).\n\nFor instance, I once wrote a simple stopwatch class where I wanted to have the native stopwatch resolution to be hidden, yet to let the user query the elapsed time with a single method and the units to be specified as some sort of variable (to be selected by user preferences, say). Rather than, have say , , etc. methods, I wanted to have something like . To achive both of these goals, I can't make the native resolution public nor private, so I came up with the following design.\n\nAs you can see, this design achieves both goals:\n• desired time unit can be stored, etc.\n\nI really like this design because the original implementation stored the multiple of native time units and performed a division to compute the elapsed time. After someone complained the division was too slow, I changed the class to cache the dividend, making the method (a little) faster.\n\nIn general, you should strive for strong cohesion and weak coupling. This is why friend is so little used, it is recommended to reduce coupling between classes. However, there are situations where strong coupling gives better encapsulation. In those cases, you probably need a ."
    },
    {
        "link": "https://geeksforgeeks.org/friend-class-function-cpp",
        "document": "A friend class can access private and protected members of other classes in which it is declared as a friend. It is sometimes useful to allow a particular class to access private and protected members of other classes. For example, a LinkedList class may be allowed to access private members of Node.\n\nWe can declare a friend class in C++ by using the friend keyword.\n\nLike a friend class, a friend function can be granted special access to private and protected members of a class in C++. They are not the member functions of the class but can access and manipulate the private and protected members of that class for they are declared as friends.\n\nWe can declare any global function as a friend function. The following example demonstrates how to declare a global function as a friend function in C++:\n\nIn the above example, we have used a global function as a friend function. In the next example, we will use a member function of another class as a friend function.\n\n2. Member Function of Another Class as Friend Function\n\nWe can also declare a member function of another class as a friend function in C++. The following example demonstrates how to use a member function of another class as a friend function in C++:\n• None A friend function is a special function in C++ that in spite of not being a member function of a class has the privilege to access private and protected data\n• None A friend function is a non-member function or ordinary function of a class, which is declared as a friend using the keyword “ friend ” inside the class. By declaring a function as a friend, all the access permissions are given to the function.\n• None The keyword “friend” is placed only in the function declaration of the friend function and not function definition or call.\n• None A friend function is called like an ordinary function. It cannot be called using the object name and dot operator. However, it may accept the object as an argument whose value it wants to access.\n• None A friend function can be declared in any section of the class i.e. public or private or protected.\n\nBelow are some more examples of friend functions in different scenarios:\n\nThe friend function provides us with a way to access private data but it also has its demerits. Following is the list of advantages and disadvantages of friend functions in C++:\n• None A friend function is able to access members without the need of inheriting the class.\n• None The friend function acts as a bridge between two classes by accessing their private data.\n• None It can be used to increase the versatility of overloaded operators.\n• None It can be declared either in the public or private or protected part of the class.\n• None Friend functions have access to private members of a class from outside the class which violates the law of data hiding.\n• None Friend functions cannot do any run-time polymorphism in their members.\n• None Friends should be used only for limited purposes. Too many functions or external classes are declared as friends of a class with protected or private data access lessens the value of encapsulation of separate classes in object-oriented programming.\n• not mutual . If class A is a friend of B, then B doesn’t become a friend of A automatically.\n• None Friendship is not inherited. (See\n• None The concept of friends is not in Java."
    },
    {
        "link": "https://stackoverflow.com/questions/73731425/are-friend-function-a-good-practice-in-this-case",
        "document": "I have a few questions about good practices, I have this piece of code in c++:\n\nWith some operators overloaded like:\n\nIf I can get the real and imaginary private variables using Re() and Im() functions that return them, should I use friend functions that use private variables, or should I write the operators in terms of these functions, something like\n\nAlso, is there a point in making real, and imaginary variables private if I'm gonna use them outside class anyway with those functions?\n\nAnother question, I don't see the propourse in overload = operator like this:\n\nIf I don't do it, I can do something like with A and B complex clases, in the main anyway.\n\nAnd last question, what is the best practice? To declare functions with variables like this?:\n\nor should I declare without them like this?:"
    },
    {
        "link": "https://web.stanford.edu/class/cs106b/section/section5",
        "document": ""
    },
    {
        "link": "https://medium.com/@lokeshbihani99/understanding-friend-functions-and-const-methods-in-c-part-4-3c7ad2c6a6ee",
        "document": "This is the fourth part of my 6-part series on object-oriented programming in C++. In this part I’ll discuss Friend and Const functions.\n\nIt’s a special function that isn’t a member of any class but it can still access any member of that class (including private and protected members). This is done by declaring that function as of that class.\n\nSince it’s a non-member function, so it’s always declared inside a class but defined outside the class without the membership label.\n\nIn order to access the data members of the class(es) it’s friend of, you need to pass the reference of the objects of those class(es) as arguments to the friend function.\n\nclass Ball{\n\n double radius;\n\n string color;\n\n \n\npublic:\n\n Ball() : Ball(0, \"\") { }\n\n \n\n Ball(double r, string c) : radius(r), color(c) { }\n\n \n\n void printVolume();\n\n \n\n // The friend keyword specifies that this is a friend function\n\n friend void setRadius(Ball &b, double r); \n\n};\n\n\n\n// This is a member function that calculates the volume.\n\nvoid Ball::printVolume(){\n\n cout << (4/3) * 3.142 * radius * radius * radius << endl;\n\n}\n\n// The implementation of friend function\n\n/*\n\n Had we not used the reference of the object, calling this function \n\n would've actually created a new object initialized using copy constructor\n\n and all the changes made inside `setRadius` function would have been made\n\n to this new object instead of the originally passed object.\n\n*/\n\nvoid setRadius(Ball &b, double r){\n\n // 'radius' is private but still this function can directly access it.\n\n b.radius = r;\n\n}\n\nThe primary use case of friend functions is to allow non-member functions or other classes to access private or protected members of a class in situations where making those members public would compromise the encapsulation and data hiding principles.\n\nSuppose you have a class called that is responsible for encrypting and decrypting data using a private key. The private key should be kept hidden and should not be directly accessible from outside the class. However, you want to implement a function that performs encryption using the private key.\n\nUsing getters and setters in this scenario would unnecessarily expose the private key, violating the principle of encapsulation and compromising the security of the class. Therefore, using a friend function is the correct solution to ensure encapsulation and data hiding while allowing the necessary operation to be performed.\n\nIn C++, const functions are member functions of a class that are declared with the keyword. These functions promise not to modify the state of the object on which they are called. It can be applied to member functions of both classes and structures.\n• Const functions can be invoked on both const objects and non-const objects of a class.\n• Within a const function, the object on which it is called is treated as const, regardless of whether the object itself is const or non-const.\n• A const function can only call other const member functions of the same class. This is because a non const function can change the object’s state. If a non const function is called from a const function then we cannot guarantee that object’s state won’t change. It is for this reason compiler doesn’t allow calling non-const functions from a const function.\n• A const member function can access both const and non-const data members of the class.\n• Const functions cannot modify any data members of the object, whether they are declared as const or not. Attempting to modify non-const data members or call non-const member functions within a const function will result in a compilation error. This is useful for enforcing immutability guarantees and preventing accidental modifications to objects."
    },
    {
        "link": "https://stackoverflow.com/questions/1143936/pragma-once-vs-include-guards",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/787533/is-pragma-once-a-safe-include-guard",
        "document": "Should I be concerned? Should I expend any further mental energy on this?\n\nI want to avoid platform compilation issues, but also want to avoid the extra work of fallback guards:\n\nIs this something that is supported by most modern compilers on non-windows platforms (gcc)?\n\nI've read that there is some compiler optimization when using #pragma once which can result in faster compilation. I recognize that is non-standard, and thus could pose a cross-platform compatibility issue.\n\nI wish (or something like it) had been in the standard. Include guards aren't a real big deal (but they do seem to be a little difficult to explain to people learning the language), but it seems like a minor annoyance that could have been avoided. In fact, since 99.98% of the time, the behavior is the desired behavior, it would have been nice if preventing multiple inclusion of a header was automatically handled by the compiler, with a or something to allow double including. But we have what we have (except that you might not have ).\n\nGCC supports since 3.4, see http://en.wikipedia.org/wiki/Pragma_once for further compiler support. The big upside I see on using as opposed to include guards is to avoid copy/paste errors. Let's face it: most of us hardly start a new header file from scratch, but rather just copy an existing one and modify it to our needs. It is much easier to create a working template using instead of include guards. The less I have to modify the template, the less I am likely to run into errors. Having the same include guard in different files leads to strange compiler errors and it takes some time to figure out what went wrong. TL;DR: is easier to use.\n\nI use it and I'm happy with it, as I have to type much less to make a new header. It worked fine for me in three platforms: Windows, Mac and Linux. I don't have any performance information but I believe that the difference between #pragma and the include guard will be nothing comparing to the slowness of parsing the C++ grammar. That's the real problem. Try to compile the same number of files and lines with a C# compiler for example, to see the difference. In the end, using the guard or the pragma, won't matter at all.\n\nUsing ' ' might not have any effect (it is not supported everywhere - though it is increasingly widely supported), so you need to use the conditional compilation code anyway, in which case, why bother with ' '? The compiler probably optimizes it anyway. It does depend on your target platforms, though. If all your targets support it, then go ahead and use it - but it should be a conscious decision because all hell will break loose if you only use the pragma and then port to a compiler that does not support it.\n\nThe performance benefit is from not having to reopen the file once the #pragma once have been read. With guards, the compiler have to open the file (that can be costly in time) to get the information that it shouldn't include it's content again. That is theory only because some compilers will automatically not open files that didn't have any read code in, for each compilation unit. Anyway, it's not the case for all compilers, so ideally #pragma once have to be avoided for cross-platform code has it's not standard at all / have no standardized definition and effect. However, practically, it's really better than guards. In the end, the better suggestion you can get to be sure to have the best speed from your compiler without having to check the behavior of each compiler in this case, is to use both pragma once and guards. That way you get the best of both (cross-platform and help compilation speed). As it's longer to type, I personally use a tool to help generate all that in a very wick way (Visual Assist X).\n\nUsing gcc 3.4 and 4.1 on very large trees (sometimes making use of distcc), I have yet to see any speed up when using #pragma once in lieu of, or in combination with standard include guards. I really don't see how its worth potentially confusing older versions of gcc, or even other compilers since there's no real savings. I have not tried all of the various de-linters, but I'm willing to bet it will confuse many of them. I too wish it had been adopted early on, but I can see the argument \"Why do we need that when ifndef works perfectly fine?\". Given C's many dark corners and complexities, include guards are one of the easiest, self explaining things. If you have even a small knowledge of how the preprocessor works, they should be self explanatory. If you do observe a significant speed up, however, please update your question.\n\nJust about the faster compilation: If you use include guards using ifdef/define, in theory the compiler would have to read the header file and check every time it is included. But in practice, the compiler sees that you have the structure “white space” - “#if condition” - lots of code - “#endif” - “white space”. With tha pattern present, the compiler will remember just the path of the file, and the condition. If it encounters another #include for the same file path, it just checks the condition and only opens the file if at this point the condition is false. This works, whether you use an include guard, or if the whole file is not used depending on some feature flag. And it works if you manually undefine the include guard because you want it included twice. So the time difference compared to “pragma once” is minimal. And this is so common today, you really don’t have to use “pragma once” for compiler performance."
    },
    {
        "link": "https://64.github.io/cpp-faq/include-guards-pragma-once",
        "document": "Include guards, or sometimes called macro guards, header guards, or file guards are a common C/C++ idiom that allows including a header file multiple times safely. The non-standard preprocessor directive is an almost equivalent alternative to this idiom.\n\nThe preprocessor directive effectively copies the named header into our source file. If we a header file more than once, this will result in redefinitions and possibly compiler errors. Consider this example:\n\nThis code does not compile, because we have included twice. After these two includes are processed by the preprocessor, (ignoring comments) will be the following:\n\nThe program is ill-formed and we get a compiler error:\n\nAt this point you might think: “Okay then just don’t include it twice and the problem is solved.\". But including headers multiple times is not always easy to avoid. We could have two more header files and , both of which . The include-tree would look as follows:\n\nindirectly includes twice. And this is by no means unusual. Smaller standard library headers such as or are included by many other headers like , so each source file may have many copies of .\n\nInclude guards are put around the entirety of the header file:\n\nThis idiom works by letting the preprocessor skip the entirety of the header file if has already been defined. Only the first time we include the header file, will be undefined. We this macro inside of the block, so all subsequent copies of the header will not be processed. Here is how this works if we process the first two includes in :\n\nAfter processing the blocks, the code will effectively look like this:\n\nWe could now include our header as many times as we want in as many headers as we want without worrying about redefining our functions and receiving compiler errors.\n\nNote: is an arbitrary definition, we could name it something else too. But the name should be long and unique so we don’t accidentally use the same guard twice.\n\nis a non-standard preprocessor directive which tells the preprocessor to skip the current header if it has already been included. The goal is to achieve the same effect as our include guards, but more concisely. We can use it like this:\n\nAt first glance, this is much more elegant than include guards and we could just use in all cases. However, as already mentioned, directives are not part of the C or C++ standard, so the behavior is dependent on the compiler.\n\nOne alleged advantage of is that it can be faster, since the preprocessor doesn’t need to read the entire file to find a matching for the directive. The file contents can be skipped at an earlier stage. However, these claims are hard to reproduce with modern compilers and practical examples.\n\nIt is worth noting that identifying whether a file is included multiple times is not a trival problem. In modern file systems, many symbolic links or hardlinks can lead to the same file. Usually the file contents and sometimes the timestamp are used by preprocessor to test for duplicates.\n\nIn most cases and with virtually every compiler, will work as intended. But it is the subject of scepticism because it is neither fully standardized nor perfectly reliable. An example where fails can be seen here:\n\nThe contents of and are completely identical (ignoring the comments at the top). When we attempt to , the preprocessor will falsely believe that has already been included, because it is identical to . Arguably, this is an unusual example and including inside of a is considered bad practice by many. However, it shows that is not quite as reliable as include guards.\n\nInclude guards are a tried and tested, fully standardized, and efficient idiom which allows including a header file multiple times. Headers should be wrapped in include guards, ideally right when creating the file. Many IDEs can be configured so that they automatically add include guards when you create a new header file.\n\nis a viable, but non-standard alternative for simple projects and will work most of the time, but it can produce cryptic and very hard-to-track errors. If you do measure a significant difference in compile times and want to use anyways, you can use both include guards and . Because include guards are unique for each file, the previously shown error would have been prevented:"
    },
    {
        "link": "https://quora.com/Is-it-time-to-dump-include-guards-and-use-just-pragma-once",
        "document": "Something went wrong. Wait a moment and try again."
    },
    {
        "link": "https://reddit.com/r/cpp/comments/rxb6r2/include_guards_or_pragma_once",
        "document": ""
    }
]