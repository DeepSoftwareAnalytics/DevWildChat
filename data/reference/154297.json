[
    {
        "link": "https://stackoverflow.com/questions/1403150/how-do-you-dynamically-allocate-a-matrix",
        "document": "Using the double-pointer is by far the best compromise between execution speed/optimisation and legibility. Using a single array to store matrix' contents is actually what a double-pointer does.\n\nI have successfully used the following templated creator function (yes, I know I use old C-style pointer referencing, but it does make code more clear on the calling side with regards to changing parameters - something I like about pointers which is not possible with references. You will see what I mean):\n\nTo de-allocate the memory created using the abovementioned utility, one simply has to de-allocate in reverse.\n\nTo use these abovementioned template functions is then very easy (e.g.):"
    },
    {
        "link": "https://stackoverflow.com/questions/9858649/matrices-vs-arrays-of-arrays-in-c-and-their-dynamic-allocation",
        "document": "There is something I still don't quite understand about the way matrices and other multidimensional arrays are represented in C and C+ and how to allocate them dynamically.\n\nConsider the following code segment:\n\nIf I understand correctly, this allocates an n by n matrix of integers on the stack. The (i,j)-th element of the matrix can be accessed using a[i][j]. The compiler automatically converts this into an access into the (n*i+j)-th element of a one dimensional array actually allocated.\n\nSuppose now that I would like to allocate the n by n matrix a on the heap, instead of the stack. I can then do the following:\n\nI can now access the (i,j)-th element again as a[i][j]. However, this is not exactly equivalent to the situation above as I actually had to allocate space for n*n int's, plus n pointers to int. Also, accessing a[i][j] now entails two accesses to memory instead of just one. On the other hand, the index computation n*i+j is avoided.\n\nSuppose now that I am interested in n by m matrices where m is small, e.g., m=2. Using the array of row pointers then wastes 33% of the space. Is there any way of avoiding that?\n\nI can of course allocate a one-dimensional array and do the index arithmetic myself, but this does not seem to be the best solution to me.\n\nAny information would be appreciated!"
    },
    {
        "link": "https://reddit.com/r/cpp_questions/comments/zxs3fu/when_to_use_dynamic_memory_allocation",
        "document": "I notice that lots of std containers (e.g. vector) internally use a dynamically allocated array on the heap for storing elements. Initially, I don't get the motivations behind this design\n\nUnlike C, C++ does not support variable length arrays, so before creating any kind of object, the compiler first needs to figure out the size that is needed for that object, regardless of whether it is going to be allocated on heap or stack. Once an object is created, its memory is **fixed** and cannot be further enlarged\n\nAs a result, the only way to work around this is to dynamically allocate an array that allows the size to be determined at runtime\n\nSo is it a safe assertion to say that if we want to create any kind of data structure where the number of elements it can hold is not known ahead of time, ultimately we have to rely on some form of a dynamic array?\n\nI'm asking this because I was told that in modern C++ development dynamic memory allocation should be avoided at all costs. But I still think there must be some valid use cases"
    },
    {
        "link": "https://geeksforgeeks.org/how-to-dynamically-allocate-an-array-in-cpp",
        "document": "How to Dynamically Allocate an Array in C++?\n\nIn C++, dynamic memory allocation allows us to allocate memory during runtime. Dynamic allocation in an array is particularly useful when the size of an array is not known at compile time and needs to be specified during runtime. In this article, we will learn how to dynamically allocate an array in C++.\n\nDynamic Allocation of Arrays in C++\n\nIn C++, we use the for . To allocate an dynamically,\n• None that will store the base address of the allocated array.\n• None Next, use the new operator to reserve memory space to accommodate an array of a particular data type.\n• None When making this allocation specify the size of the array that indicates how many elements it can contain. This specified size determines the amount of memory to be allocated.\n\nBelow is the general syntax for dynamically allocating an array in C++.\n• None is the type of data that we want to store in the array.\n• None is a keyword used for dynamic memory allocation.\n• None is the size of the array we want to allocate.\n\nC++ Program to Dynamically Allocate an Array\n\nThe below program demonstrates the dynamic array allocation in C++.\n\nTime Complexity: O(1)\n\nAuxilliary Space: O(n), where n is the size of the dynamically allocated array."
    },
    {
        "link": "https://softwareengineering.stackexchange.com/questions/382082/is-there-a-best-practice-for-allocation-deallocating-multiple-dynamic-arrays-in",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://cplusplus.com/doc/tutorial/basic_io",
        "document": "std; main () { i; cout << \"Please enter an integer value: \" ; cin >> i; cout << \"The value you entered is \" << i; cout << \" and its double is \" << i*2 << ; 0; }\n\nPlease enter an integer value: 702 The value you entered is 702 and its double is 1404."
    },
    {
        "link": "https://geeksforgeeks.org/basic-input-output-c",
        "document": "In C++, input and output are performed in the form of a sequence of bytes or more commonly known as streams.\n• Input Stream: If the direction of flow of bytes is from the device (for example, Keyboard) to the main memory then this process is called input.\n• Output Stream: If the direction of flow of bytes is opposite, i.e. from main memory to device (display screen) then this process is called output.\n\nAll of these streams are defined inside the <iostream> header file which contains all the standard input and output tools of C++. The two instances cout and cin of iostream class are used very often for printing outputs and taking inputs respectively. These two are the most basic methods of taking input and printing output in C++.\n\nThe C++ cout is the instance of the ostream class used to produce output on the standard output device which is usually the display screen. The data needed to be displayed on the screen is inserted in the standard output stream (cout) using the insertion operator(<<).\n\nFor example, if we want to print text “GeeksforGeeks” on the display, we can use the cout as shown:\n\nExplanation: In the above program, cout is used to output the text “GeeksforGeeks” to the standard output stream. It works in conjunction with the insertion operator (<<) to send the specified data to the output stream.\n\nWe can also print the variable values using cout.\n\nUnderstanding input and output operations is essential for any C++ programmer. The C++ Course includes comprehensive lessons on basic I/O operations, ensuring you can manage user interaction in your programs.\n\nThe C++ cin statement is the instance of the class istream and is used to read input from the standard input device which is usually a keyboard. The extraction operator (>>) is used along with the object cin for extracting the data from the input stream and store it in some variable in the program.\n\nFor example, if we want to ask user for his/her age, then we can use cin as shown:\n\nExplanation: The above program asks the user to input the age. The object cin is connected to the input device (keyboard). The age entered by the user is extracted from cin using the extraction operator(>>) and the extracted data is then stored in the variable age present on the right side of the extraction operator.\n\nAlso, while taking text as input using cin, we need to remember that cin stops reading input as soon as it encounters a whitespace (space, tab, or newline). This means it only captures the first word or characters until the first whitespace. It is shown in the below example:\n\nThe C++ cerr is the standard error stream that is used to output the errors. This is also an instance of the iostream class. As cerr in C++ is un-buffered so it is used when one needs to display the error message immediately. It does not have any buffer to store the error message and display it later.\n\nThe main difference between cerr and cout comes when you would like to redirect output using “cout” that gets redirected to file if you use “cerr” the error doesn’t get stored in file.(This is what un-buffered means ..It cant store the message)\n\nThis is also an instance of ostream class and used to display errors but unlike cerr the error is first inserted into a buffer and is stored in the buffer until it is not fully filled. or the buffer is not explicitly flushed (using flush()). The error message will be displayed on the screen too."
    },
    {
        "link": "https://cplusplus.com/doc/tutorial/files",
        "document": "std; main () { ofstream myfile ( ); (myfile.is_open()) { myfile << ; myfile << \"This is another line.\n\n\" ; myfile.close(); } cout << ; 0; }\n\n[file example.txt] This is a line. This is another line."
    },
    {
        "link": "https://en.cppreference.com/w/cpp/io/cin",
        "document": "The global objects and control input from a stream buffer of implementation-defined type (derived from std::streambuf), associated with the standard C input stream stdin.\n\nThese objects are guaranteed to be initialized during or before the first time an object of type std::ios_base::Init is constructed and are available for use in the constructors and destructors of static objects with ordered initialization (as long as is included before the object is defined).\n\nUnless sync_with_stdio(false) has been issued, it is safe to concurrently access these objects from multiple threads for both formatted and unformatted input.\n\nThe “c” in the name refers to “character” (stroustrup.com FAQ); means “character input” and means “wide character input”."
    },
    {
        "link": "https://home.csulb.edu/~pnguyen/cecs282/lecnotes/inputoutput.pdf",
        "document": ""
    }
]