[
    {
        "link": "https://geeksforgeeks.org/microcontrollers-8051-interrupts",
        "document": "8051 Microcontroller is a widely used embedded system, that incorporates a robust interrupt system which are important for external communications and real-time applications. Interrupts are the important feature of a microcontroller which enables the microcontroller to respond to the external events and requests, which enhances the multitasking abilities of the microcontroller. An interrupt is an external or internal event/command that interrupts the normal processing of an event and informs the microcontroller that a device needs its service. Whenever a device needs its service, the device sends an interrupt signal to the microcontroller to send a notification. Upon receiving the interrupt signal, the microcontroller stops its existing program and serves the external device request. The program which is associated with the interrupt is known as interrupt Service Routine (IRS) or interrupt handler.\n\nThe 8051 features two main types of interrupts, i.e. Hardware interrupts and software interrupts. The hardware interrupts are triggered by external signal such as peripheral events or external devices. The microcontroller can be configured to respond to specific events, allowing for efficient event-driven programming. Whereas, the Software interrupts, are initiated by specific instructions in the program code. They provide a mechanism for the programmer to force the microcontroller to interrupt its normal execution and execute a predefined routine.\n\nThe address of the corresponding interrupt service routine (ISR) is included in the suitable interrupt vector associated with every interrupt source in the 8051. The microcontroller automatically maintains its state on interrupt, fetches the interrupt vector's ISR address, and executes the ISR's operation. Once the ISR is finished, the microcontroller restarts the task which has been interrupted.\n\nWhat is an 8051 Microcontroller?\n\n8051 microcontroller is an 8-bit data bus and 16-bit address bus Microcontroller. A 64K (216) byte code memory space and an additional 64K byte data memory space can be addressed using the 16-bit address bus. It has 40 pins and 4K on-chip read only code memory and 128 bytes of internal RAM. It also has various Special Function Registers (SFR) such as the accumulator, the B register, and many other control registers. At a time, the ALU executes an 8-bit operation. It also has two 16-bit counter timers and 3 internal interrupts and 2 external interrupts and four 8 bit I/O ports.\n\nThe timer and serial interrupts are internally generated by the microcontroller whereas, the external interrupts are generated by additional peripheral devices or switches that are connected to the microcontroller externally. There are two types of external interrupts: edge-triggered and level-triggered. The interrupt service routine is carried out by the microcontroller as a reaction to an interrupt, enabling memory locations to coincide with interrupts.\n\nAll of the interrupts are disabled by \"RESET\" thus software is required to enable all of these interrupts. If any one of these five interrupts or all five are activated, the relevant interrupt flags are set. The priority, which is managed by the IP interrupt priority register, determines which of these interrupts can be set or cleared bit by bit in a specific function register that is Interrupt Enabled (IE).\n\nTwo SFRs controls the function of interrupts in 8051 microcontrollers. IE is Responsible for disable/enable the function and IP is Responsible for priority assignment: The priority list offers 3 levels of interrupt priority: Reset: When a reset request arrives, everything is stopped and the microcontroller restarts. Reset can be used to disable the interrupt priority 1. Interrupt priority 0 can be disabled by both Reset and interrupt.\n\nSome of the registers used in this microcontroller are :\n\nInterrupts can be enabled and disabled using IE Register. It is a register in the 8051 microcontroller that controls interrupt prioritization and triggering. It includes many bits, such as:\n\nEA-Global Interrupt Enable/Disable - When it is set it enables all interrupt, if cleared disables all interrupts\n\nES (Serial Communication Interrupt Enable)- This bit enables or disables the interrupt for serial communication.\n• None 0-Interrupt cannot be generated by UART system\n• None 0-Interrupt cannot be generated by the timer 0\n• None These bits control the interrupts from external devices.\n• None EX0 - bit enables or disables external 0 interrupt: 0 - change of the INT1 pin logic state cannot generate an interrupt and 1 - enables an external interrupt on the pin INT1 state change.\n• None EX1 - bit enables or disables external 1 interrupt: 0 - change of the pin INT0 logic state cannot generate an interrupt and 1 - enables an external interrupt on the pin INT0 state change.\n\nIT0 and IT1 (External Interrupt 0 and External Interrupt 1 Type)- These bits determine the type of trigger for external interrupts (level or edge-triggered).\n\nOne cannot predict when one may receive an interrupt request. If multiple interrupts are enabled, it can happen that a request for another interrupt is made while the first one is ongoing. There is a priority list that tells the microcontroller what to do in order to determine whether to respond to a new interrupt request or to carry on with existing operations. The microcontroller restarts once everything stops in response to a reset request. Only Reset has the ability to disable Interrupt priority 1. Both Reset and interrupt priority 1 have the ability to disable interrupt priority 0. The interrupt priority register, or IP Register, indicates which of the current interrupt sources is more significant than other. The program's start typically defines the interrupt priority. An interrupt will be immediately paused and given preference over any other interrupt if the one with greater priority comes while the other is still in progress. Whenever two interrupt requests that have different priorities occurs simultaneously, the higher priority interrupt is handled first. If two interrupt requests with the same priority level arise one after the other, the subsequent request needs to wait until the entire process is accomplished.\n\nBit 5,6 & 7- These bits are called as the Reserved bits.\n\nThe interruptions that the microcontroller interfaces with (external) devices are known as external interrupts. They are received by the controller's INTx pins. These may be triggered by edges or levels. Interrupt is enabled for a low at the INTx pin when it is level triggered, and for a high to low transition at the INTx pin when it is edge triggered. The TCON register determines whether the triggering is edge or level trigger. The INTx pin for a level trigger interrupt needs to remain low until the interrupt begins and needs to go back to high prior to the interrupt terminating. An interrupt won't be produced if the low at the INTx pin rises to a high value before the ISR begins. Additionally, the interrupt will be created once more if the INTx pin is low even after the ISR has ended. The level trigger interrupt (low) at the INTx pin must therefore be four machine cycles long, neither longer nor shorter than this.\n• IE0- External interrupt 0 edge flag- When an external interrupt edge is detected, hardware sets it. Cleared by the device upon processing the interrupt.\n• IE1- External interrupt 1 edge flag- Set by hardware when external interrupt edge is detected. Cleared by hardware when the interrupt is processed.\n• TF0- Timer 0 overflow flag- This bit is set whenever timer 0 overflows and is processed by the hardware.\n• TF1- Timer 1 overflow flag - This bit is set whenever timer 1 overflows and is processed by the hardware.\n• TR0- Timer 0 Run Control- Set this bit to start Timer 0 and clear it to stop the timer. This is important because the timer needs to be running for it to generate interrupts.\n• TR1 Timer 1 Run Control - S imilar to TR0, this bit controls the running state of Timer 1.\n• IT0- Interrupt 0 type control bit- Set/cleared by the device or software to indicate falling edge/low-level triggered external interrupts.\n• IT1- Interrupt 1 type control bit- Set/cleared by the device or software to indicate falling edge/low-level triggered external interrupts. Whenever the IT0 and IT1 bits are set, the external interrupts 0 and 1 edge-triggered respectively. These bits are cleared by default, which causes the external interrupt to be level triggered.\n\n8051 Microcontroller suffers five different types of interrupts that hampers the main program execution. These five types of interrupts are:\n\nThe 8051 microcontrollers are able to respond to external events through its external interrupts, INT0 and INT1.\n• None It is connected to the 8051's pin PORT3.2.\n• None An interrupt request is issued when this pin transitions from low to high in response to an external signal.\n• None It is possible to program the microcontroller to carry out a particular Interrupt Service Routine (ISR) in response to this interrupt.\n• None Set the IE (Interrupt Enable) bit for INT0 in the TCON register and configure the IT0 (Interrupt Type 0) bit in the TCON register corresponding to the desired triggering condition (edge or level-triggered) in order to enable and configure INT0.\n• None It is connected to the 8051's pin PORT3.3\n• None When that particular pin encounters a low-to-high transitions, INT1, like INT0, creates an interrupt request.\n• None By configuring the IT1 (Interrupt Type 1) bit in the TCON register and setting the IE bit for INT1 in the TCON register, one can enable and configure INT1.\n• None A specific ISR can be executed by the microcontroller in response to INT1.\n\nTimer 0 and Timer 1 are hardware timers with internal timer interrupts featured in the 8051 microcontrollers. In microcontroller applications, these timers are used to measure time intervals and generate precise delays. The interrupt system of the microcontroller enables it to react quickly to outside events. Interrupts for Timer 0 and Timer 1 are produced when their respective timers exceed their limit. The microcontroller will run the interrupt service routine (ISR) for that timer if the related interrupt is enabled, and the associated interrupt flag is set upon overflow.\n• None Since Timer 0 is an 8-bit timer, its count range is 0 to 255.\n• None There are two modes of operation for it, 13-bit and 16-bit. It employs the TH0 (Timer 0 High) and TL0 (Timer 0 Low) registers in 13-bit mode and only the TH0 register in 16-bit mode.\n• None It is possible to set timer 0 to interrupt when it approaches zero instead of staying at its maximum value. The microcontroller can perform a particular interrupt service routine (ISR) in response to the interrupt request that this overflow generates.\n• None Timer 1 is a 16-bit timer with a counting range of 0 to 65,535.\n• None It can operate in 16- or 8-bit mode. It employs the TL1 (Timer 1 Low) and TH1 (Timer 1 High) registers in 8-bit mode and only the TH1 register in 16-bit mode.\n• None Timer 1 can be set up to produce an interrupt when it overflows, just like Timer 0. This interruption may cause a certain ISR to be executed.\n\nUART (Universal Asynchronous Receiver/Transmitter) is a serial communication protocol used with 8051 microcontrollers. Data is sent over a single cable, bit by bit, in serial transmission. In this sense, \"interrupts\" refers to the processes that enable the microcontroller to react quickly to external events.\n• Initialization of UART- Set the data format, baud rate, and enable the UART module by configuring the UART registers.\n• Interrupt Enable - Depending on the operation you wish to interrupt for, enable the UART's transmit interrupt (TI) or receive interrupt (RI).\n• ISR (interrupt service routine)- To handle the interrupt, write an ISR. The ISR in UART communication normally verifies whether the transmit buffer is ready (TI) or whether data has been received (RI).\n• Clearing the Flag- To recognize the interrupt and get ready for the next one, in the ISR, clear the associated interrupt flag (RI or TI).\n\nThe addresses of different interrupt service routines (ISRs) are stored in a table called the Interrupt Vector Table (IVT) in an 8051 microcontroller. It is a vital aspect of the interrupt handling mechanism in the microcontroller. When an interrupt occurs the interrupt specific ISR is executed by jumping the program counter to the corresponding address in the IVT. There are memory areas set aside specifically for the IVT in the 8051 microprocessors. Every interrupt has a specific place in the IVT, and the addresses kept there point to the program memory's associated ISR's start. By guiding the program flow to the proper place, the IVT enables the microcontroller to respond to external events like hardware interrupts or external signals quickly and effectively.\n• None In real-time systems, interrupts are essential for speedy responses to external occurrences. Due to its ability to swap tasks fast through interrupts, the 8051 is a good choice for applications that need exact timing.\n• None Interrupts serve in the control of incoming data in communication applications, assuring timely transmission or rapid handling of received information.\n• None In embedded systems, 8051 interrupts are frequently utilized for activities like sensor interfacing, where the microcontroller must react quickly to environmental changes.\n• None Interruptions assist in ensuring timely data sampling and processing in situations when data must be obtained from\n• None By enabling instantaneous reactions to sensor triggers or alarm situations, interrupts in security systems can ensure prompt alerting and suitable responses.\n\n1. Write an 8051 program to enable external interrupts’0’ and ‘1’, configure it to receive edge triggered interrupt request and keep waiting for the interrupt.\n\n2. Write a program to flash LEDs connected at port 2 With delay of 10 msec. Read data from PORT O continuously and send it to PORT 1 .Use timer 0 in mode 1 with interrupt.\n• None By quickly resolving problems, interrupts can be used for error detection and handling, improving the system's robustness and reliability.\n• None The 8051's capability to operate in a low-power mode and wake up only in response to an interrupt helps battery-powered applications operate more energy-efficiently.\n• None Interrupts make it possible to break up large, complicated processes into smaller, more manageable subroutines, which improves the readability and organization of the code.\n• None By allowing the microcontroller to be interrupted in response to a predetermined event, the interrupt system minimizes CPU overhead and boosts overall system performance. This eliminates the requirement for constant input polling.\n• None A few 8051 variations enable interrupt priority levels, which give important tasks the upper hand over less important ones and improve responsiveness and control of the system.\n• None The number of interrupt sources that can be supported is limited by the 8051 microcontroller's two external interrupt pins (INT0 and INT1).\n• None The 8051's interrupt priority cannot be dynamically adjusted; it is fixed. This could render handling several interruption sources with different priorities difficult.\n• None Variations in the microcontroller's response time to an interrupt might affect real-time applications where reliable and consistent response times are essential.\n• None Careful programming is necessary to prevent unexpected behavior while handling interrupts, particularly when working with nested interruptions or crucial portions.\n• None Since the 8051 lacks vectored interrupts, unlike some other modern microcontrollers, it is required to manually examine interrupt flags in order to identify the interrupt's source.\n\nThe 8051 Microcontroller has the ability to handle interrupts both external as well as internal interrupts. This helps the microcontroller to interface with the external peripherals devices and can be used for real time applications. These interrupts increase the productivity of the microcontroller and can be used for various purposes. interrupts are essential to the operation of 8051 microcontrollers because they give the processor a way to react to outside events quickly and without the need for continuous polling. They improve system efficiency by enabling the microcontroller to manage several tasks at once. Because of their capacity to manage a variety of interrupt sources and prioritize tasks, 8051 microcontrollers provide an adaptable platform for embedded systems, which makes them ideal for applications that demand multitasking and real-time responsiveness. Comprehending and executing interrupt-driven programming efficiently is imperative to fully utilize 8051 microcontrollers in diverse electronic uses.\n\nWhat is the role of the interrupt Service Routine (ISR) in handling 8051 Interrupt?\n\nWhat are the limitations of Vector Address Table?"
    },
    {
        "link": "https://engineersgarage.com/interrupts-programming-8051-hardware-interrupts",
        "document": "The interrupts refer to a notification, communicated to the controller, by a hardware device or software, on receipt of which controller momentarily stops and responds to the interrupt. Whenever an interrupt occurs the controller completes the execution of the current instruction and starts the execution of an Interrupt Service Routine (ISR) or Interrupt Handler. ISR is a piece of code that tells the processor or controller what to do when the interrupt occurs. After the execution of ISR, controller returns back to the instruction it has jumped from (before the interrupt was received). The interrupts can be either hardware interrupts or software interrupts.\n\nIn polling, the microcontroller keeps checking the status of other devices; and while doing so it does no other operation and consumes all its processing time for monitoring. This problem can be addressed by using interrupts. In interrupt method, the controller responds to only when an interruption occurs. Thus in interrupt method, controller is not required to regularly monitor the status (flags, signals etc.) of interfaced and inbuilt devices.\n\nTo understand the difference better, consider the following. The polling method is very much similar to a salesperson. The salesman goes door-to-door requesting to buy its product or service. Like controller keeps monitoring the flags or signals one by one for all devices and caters to whichever needs its service. Interrupt, on the other hand, is very similar to a shopkeeper. Whosoever needs a service or product goes to him and apprises him of his/her needs. In our case, when the flags or signals are received, they notify the controller that they need its service.\n\nThe interrupts in a controller can be either hardware or software. If the interrupts are generated by the controller’s inbuilt devices, like timer interrupts; or by the interfaced devices, they are called the hardware interrupts. If the interrupts are generated by a piece of code, they are termed as software interrupts.\n\nWhat would happen if multiple interrupts are received by a microcontroller at the same instant? In such a case, the controller assigns priorities to the interrupts. Thus the interrupt with the highest priority is served first. However the priority of interrupts can be changed configuring the appropriate registers in the code.\n\nThe 8051 controller has six hardware interrupts of which five are available to the programmer. These are as follows:\n\n– This is also known as Power on Reset (POR). When the RESET interrupt is received, the controller restarts executing code from 0000H location. This is an interrupt which is not available to or, better to say, need not be available to the programmer.\n\n– Each Timer is associated with a Timer interrupt. A timer interrupt notifies the microcontroller that the corresponding Timer has finished counting.\n\nHow is an interrupt serviced?\n\nHow is an interrupt serviced?\n\nEvery interrupt is assigned a fixed memory area inside the processor/controller. The Interrupt Vector Table (IVT) holds the starting address of the memory area assigned to it (corresponding to every interrupt).\n\nThe interrupt vector table (IVT) for AT89C51 interrupts is as follows :\n\nWhen an interrupt is received, the controller stops after executing the current instruction. It transfers the content of program counter into stack. It also stores the current status of the interrupts internally but not on stack. After this, it jumps to the memory location specified by Interrupt Vector Table (IVT). After that the code written on that memory area gets executed. This code is known as the Interrupt Service Routine (ISR) or interrupt handler. ISR is a code written by the programmer to handle or service the interrupt.\n\nWhile programming interrupts, first thing to do is to specify the microcontroller which interrupts must be served. This is done by configuring the Interrupt Enable (IE) register which enables or disables the various available interrupts. The Interrupt Enable register has following bits to enable/disable the hardware interrupts of the 8051 controller.\n\nTo enable any of the interrupts, first the EA bit must be set to 1. After that the bits corresponding to the desired interrupts are enabled. ET0, ET1 and ET2 bits are used to enable the Timer Interrupts 0, 1 and 2, respectively. In AT89C51, there are only two timers, so ET2 is not used. EX0 and EX1 are used to enable the external interrupts 0 and 1. ES is used for serial interrupt.\n\nEA bit acts as a lock bit. If any of the interrupt bits are enabled but EA bit is not set, the interrupt will not function. By default all the interrupts are in disabled mode.\n\nNote that the IE register is bit addressable and individual interrupt bits can also be accessed.\n\nSetting the bits of IE register is necessary and sufficient to enable the interrupts. Next step is to specify the controller what to do when an interrupt occurs. This is done by writing a subroutine or function for the interrupt. This is the ISR and gets automatically called when an interrupt occurs. It is not required to call the Interrupt Subroutine explicitly in the code.\n\nAn important thing is that the definition of a subroutine must have the keyword interrupt followed by the interrupt number. A subroutine for a particular interrupt is identified by this number. These subroutine numbers corresponding to different interrupts are tabulated below.\n\nFor example : Interrupt routine for Timer1\n\nFor example : Interrupt routine for External Interrupt0 (EX0)\n\nNote that the interrupt subroutines always have void return type. They never return a value.\n\nLoad initial values in THx and TLx for mode 0 and 1; or in THx only for mode 2.\n\nWrite subroutine for Timer Interrupt. The interrupt number is 1 for Timer0 and 3 for Timer1.\n\nNote that it is not required to clear timer flag TFx.\n\nTo stop the timer, clear TRx in the end of subroutine. Otherwise it will restart from 0000H in case of modes 0 or 1 and from initial values in case of mode 2.\n\nIf the Timer has to run again and again, it is required to reload initial values within the routine itself (in case of mode 0 and 1). Otherwise after one cycle timer will start counting from 0000H.\n\nTimer interrupt to blink an LED; Time delay in mode1 using interrupt method\n\nThe external interrupts are the interrupts received from the (external) devices interfaced with the microcontroller. They are received at INTx pins of the controller. These can be level triggered or edge triggered. In level triggered, interrupt is enabled for a low at INTx pin; while in case of edge triggering, interrupt is enabled for a high to low transition at INTx pin. The edge or level trigger is decided by the TCON register. The TCON register has following bits:\n\nSetting the IT0 and IT1 bits make the external interrupt 0 and 1 edge triggered respectively. By default these bits are cleared and so external interrupt is level triggered.\n\nNote : For a level trigger interrupt, the INTx pin must remain low until the start of the ISR and should return to high before the end of ISR. If the low at INTx pin goes high before the start of ISR, interrupt will not be generated. Also if the INTx pin remains low even after the end of ISR, the interrupt will be generated once again. This is the reason why level trigger interrupt (low) at INTx pin must be four machine cycles long and not greater than or smaller than this.\n\nFollowing are the steps for using external interrupt :\n\nWrite routine for external interrupt. The interrupt number is 0 for EX0 and 2 for EX1 respectively.\n\nTo use the serial interrupt the ES bit along with the EA bit is set. Whenever one byte of data is sent or received, the serial interrupt is generated and the TI or RI flag goes high. Here, the TI or RI flag needs to be cleared explicitly in the interrupt routine (written for the Serial Interrupt).\n\nThe programming of the Serial Interrupt involves the following steps:\n\nWrite routine or function for the Serial Interrupt. The interrupt number is 4.\n\nClear the RI or TI flag within the routine.\n\nSend ‘A’ from serial port with the use of interrupt\n\nMultiple interrupts can be enabled by setting more than one interrupts in the IE register. If more than one interrupts occur at the same time, the interrupts will be serviced in order of their priority. By default the interrupts have the following priorities in descending order:\n\nThe priority of the interrupts can be changed by programming the bits of Interrupt Priority (IP) register. The IP register has the following bit configuration:\n\nFirst two MSBs are reserved. The remaining bits are the priority bits for the available interrupts.\n\nSetting a particular bit in IP register makes the corresponding interrupt of the higher priority.\n\nFor example, IP = 0x08; will make Timer1 priority higher. So the interrupt priority order will change as follows (in descending order):\n\nMore than one bit in IP register can also be set. In such a case, the higher priority interrupts will follow the sequence as they follow in default case.\n\nFor example, IP = 0x0A; will make Timer0 and Timer1 priorities higher. So the interrupt priority order will change as follows (in descending order):\n\nNote that the Timer 0 and 1 have been assigned higher priorities in the same sequence as they follow in default case."
    },
    {
        "link": "https://embetronicx.com/tutorials/microcontrollers/8051/8051-interrupts-tutorial",
        "document": "In this post, we are going to discuss the 8051 Interrupts Tutorial. Before that, you should know about the Interrupt basics. For Basics, you can go here. Let’s start…\n\nThere are five interrupt sources for the 8051. Since the main RESET input can also be considered as an interrupt, six interrupts in the order of priority can be listed as follows:\n\nWhen an interrupt is received, the controller stops after executing the current instruction. It transfers the content of the program counter into the stack. It also stores the current status of the interrupts internally but not on the stack.\n\nThis is also known as Power-on Reset (POR). When the RESET interrupt is received, the controller restarts executing code from the 0000H location. This is an interrupt that is not available to or, better to say, need not be available to the programmer.\n\nEach Timer is associated with a Timer interrupt. A timer interrupt notifies the microcontroller that the corresponding Timer has finished counting.\n\nThere are two external interrupts EX0 and EX1 to serve external devices. Both these interrupts are active low. In AT89C51, P3.2 (INT0) and P3.3 (INT1) pins are available for external interrupts 0 and 1 respectively. An external interrupt notifies the microcontroller that an external device needs its service.\n\nThis interrupt is used for serial communication. When enabled, it notifies the controller whether a byte has been received or transmitted.\n\nBefore going into programming we have to go through the registers used in the Interrupt.\n• None TCON Register (Timer Control Register) – This is used for External Interrupts only.\n\nThis register is responsible for enabling and disabling the interrupt. EA register is set to one for enabling interrupts and set to 0 for disabling the interrupts. Its bit sequence and its meanings are shown in the following figure.\n\nTo enable any of the interrupts, first, the EA bit must be set to 1. After that, the bits corresponding to the desired interrupts are enabled. , , and bits are used to enable the Timer Interrupts 0, 1, and 2, respectively. In AT89C51, there are only two timers, so is not used. EX0 and EX1 are used to enable the external interrupts 0 and 1. ES is used for the serial interrupt.\n\nEA bit acts as a lock bit. If any of the interrupt bits are enabled but bit is not set, the interrupt will not function. By default, all the interrupts are in disabled mode.\n\nNote that the register is a bit addressable and individual interrupt bits can also be accessed.\n\nThe 8051 offers two levels of interrupt priority: High and Low. By using interrupt priorities you may assign higher priority to certain interrupt conditions. We can change the priority levels of the interrupts by changing the corresponding bit in the Interrupt Priority (IP) register as shown in the following figure.\n• None A low priority interrupt can only be interrupted by the high priority interrupt, but not interrupted by another low priority interrupt.\n• None If two interrupts of different priority levels are received simultaneously, the request of a higher priority level is served.\n• None If the requests of the same priority levels are received simultaneously, then the internal polling sequence determines which request is to be serviced.\n\nThe external interrupts are the interrupts received from the (external) devices interfaced with the microcontroller. They are received at pins of the controller. These can be level-triggered or edge-triggered. In level triggered, interrupt is enabled for a low at pin; while in case of edge triggering, interrupt is enabled for a high to low transition at pin. The edge or level trigger is decided by the register. We have already discussed this register in our Timer/Counter session. The register has the following bits:\n\nHere MSB four bits are used for Timers. But LSB four bits are used for External Interrupts. We will see that bits.\n\nSetting the and bits make the external interrupt 0 and 1 edge-triggered respectively. By default, these bits are cleared and so the external interrupt is level triggered.\n\nNote: For a level trigger interrupt, the pin must remain low until the start of the ISR and should return to high before the end of the ISR. If the low at pin goes high before the start of ISR, an interrupt will not be generated. Also if the pin remains low even after the end of ISR, the interrupt will be generated once again. This is the reason why the level trigger interrupt (low) at the pin must be four machine cycles long and not greater than or smaller than this.\n\nSo, these all are the registers used in the Interrupt. These registers are not enough for play with interrupt. We have to write the ISR or Interrupt Handler.\n\nSetting the bits of register is necessary and sufficient to enable the interrupts. The next step is to specify to the controller what to do when an interrupt occurs. This is done by writing a subroutine or function for the interrupt. This is the ISR and gets automatically called when an interrupt occurs. It is not required to call the Interrupt Subroutine explicitly in the code.\n\nAn important thing is that the definition of a subroutine must have the keyword interrupt followed by the interrupt number. A subroutine for a particular interrupt is identified by this number.\n\nTimer interrupts to blink an LED; Time delays in mode 1 using interrupt method.\n\nSend ‘A’ from the serial port when it receives anything via Rx.\n\nMultiple interrupts can be enabled by setting more than one interrupts in the IE register. If more than one interrupts occurs at the same time, the interrupts will be serviced in order of their priority. The priority of the interrupts can be changed by programming the bits of the Interrupt Priority ( ) register.\n\nSetting a particular bit in register makes the corresponding interrupt of the higher priority. For example, IP = 0x08; will make Timer1 priority higher. So the interrupt priority order will change. More than one bit in register can also be set. In such a case, the higher priority interrupts will follow the sequence as they follow in the default case.\n\nNote that in the below example external interrupt 1 is set to be a higher priority than the Timer 0 and external 0 in this case.\n\nI hope you have enjoyed this tutorial. Please comment below if you have any doubt. Thank you.\n\nYou can also read the below tutorials."
    },
    {
        "link": "https://teachmemicro.com/using-timers-in-8051",
        "document": "Timers are among the most essential peripherals in any microcontroller, and the 8051 is no exception. With two built-in 16-bit timers (Timer 0 and Timer 1), the 8051 can perform a variety of timing tasks, such as creating delays, measuring time intervals, and generating pulses. In this tutorial, we’ll discuss the configuration and usage of these timers, complete with an example code in C using Keil C51.\n\nThe 8051 microcontroller has two timers, Timer 0 and Timer 1. Both timers are 16-bit registers, meaning they can count from 0 to 65,535. They can operate in several modes, allowing for different functionalities:\n\nEach timer has the following associated registers:\n• TMOD : Timer Mode register for selecting the mode of operation.\n• TCON : Timer Control register for starting, stopping, and monitoring the timer.\n\nThe steps to use a timer in 8051 are as follows:\n• Select the Mode register to configure the desired mode for the timer.\n• None register, as it controls both Timer 0 and Timer 1. Instead, use a bitwise operation to preserve the settings of the other timer. For example, to set Timer 0 to Mode 1 without affecting Timer 1:\n• None clears the lower 4 bits (related to Timer 0) while retaining the upper 4 bits (related to Timer 1).\n• Load Initial Value : Load the initial count value into the\n• Start the Timer : Set the appropriate bit in the\n• Monitor or Interrupt : Poll the timer overflow flag or use an interrupt to handle the overflow event.\n\nIn this example, we’ll create a delay of approximately 1 millisecond using Timer 0 in Mode 1.\n• Timer Mode Selection register is set using bitwise operations to select Timer 0 in Mode 1 (16-bit timer mode) without affecting Timer 1.\n• Timer Initialization , respectively. This corresponds to a delay of 1 millisecond at a 12 MHz clock frequency.\n• Starting and Stopping the Timer register is used to start and stop Timer 0.\n• Overflow Flag register is polled to check when the timer overflows.\n\nTimers in the 8051 can be used for:\n• Creating Time Delays : As demonstrated in the example above.\n• Baud Rate Generation : Used in conjunction with serial communication for baud rate control.\n• Mode 0 : A 13-bit timer that counts from 0x0000 to 0x1FFF.\n• Mode 1 : A full 16-bit timer that counts from 0x0000 to 0xFFFF.\n• Mode 2 : An 8-bit timer with auto-reload. The value in\n• Mode 3 : Splits Timer 0 into two 8-bit timers. Timer 1 remains inactive in this mode.\n\nTimers are versatile peripherals that greatly enhance the functionality of the 8051 microcontroller. Whether you’re creating delays, measuring time intervals, or generating pulses, understanding how to configure and use timers is essential for embedded development. Experiment with different timer modes and applications to fully harness the power of the 8051 microcontroller!"
    },
    {
        "link": "https://ww1.microchip.com/downloads/aemDocuments/documents/OTH/ApplicationNotes/ApplicationNotes/doc4345.pdf",
        "document": ""
    },
    {
        "link": "https://scribd.com/document/464697820/Embedded-System-Interfacing-with-8051",
        "document": "The document discusses interfacing keyboards and displays with the 8051 microcontroller. It covers various keyboard configurations like lead-per-key and matrix keypads. It also discusses robust keyboard operations through hardware debouncing, software debouncing, and interrupt-based scanning. The document also covers interfacing analog to digital converters, digital to analog converters, 7-segment LED displays, and LCD displays. It provides circuit diagrams and algorithms for reading keyboard inputs and driving various displays with the 8051."
    },
    {
        "link": "https://electro-tech-online.com/threads/matrix-keypad-programming.152897",
        "document": ""
    },
    {
        "link": "https://iust.ac.ir/files/ee/pages/az/mazidi.pdf",
        "document": ""
    },
    {
        "link": "https://embetronicx.com/tutorials/tech_devices/matrix_keypad",
        "document": "Most of the applications of embedded systems require keypads to take the user inputs, especially in the case where an application requires more keys. With simple architecture and easy interfacing procedure, matrix keypads are replacing normal push buttons by offering more inputs to the user with the lesser I/O pins. As a Human Machine Interface (HMI) keypad plays a major role in vital microprocessor and microcontroller-based projects and equipment. Therefore, this article gives you a brief idea about the matrix keypad.\n\nA Matrix keypad is the most commonly used input device in many of the application areas like digital circuits, telephone communications, calculators, ATMs, and so on. A matrix keypad consists of a set of push-button or switches which are arranged in a matrix format of rows and columns. These keypads are available in configurations like 3×4 and 4×4 based on the application it is implemented for.\n\nWe have our own EmbeTronicX store called ChipTronicX. You can purchase the hardware from there.\n\nAt the lowest level, keyboards are organized in a matrix of rows and columns. The CPU accesses both rows and columns through ports. When a key is pressed, a row and a column make a contact. otherwise, there is no connection between rows and columns. So this is the logic we are going to use.\n\nThe status of each key can be determined by a process called Scanning. There are many methods depending on how you connect your keypad with your controller, but the basic logic is the same. For the sake of explanation, let’s assume that all the column pins (Col1 – Col4) are connected to the inputs pins and all the row pins are connected to the output pins of the microcontroller. In the normal case, all the column pins are pulled up (HIGH state) by internal or external pull-up resistors. Now we can read the status of each switch through scanning.\n• None A logic LOW is given to Row1 and others (Row2 – Row-4) HIGH\n• None Now each Column is scanned. If any switch belongs to the 1st row is pressed the corresponding column will pull down (logic LOW) and we can detect the pressed key.\n• None This process is repeated for all rows.\n\nThat’s all guys. I think you could understand the operation of the keypad. Here I show a 4×4 matrix keypad. But if you take a 3×3 or 4×3 keypad the operation will be the same. If you got an idea you can try to write coding. Thank you.\n\nYou can also read the below tutorials."
    },
    {
        "link": "https://quora.com/Im-new-to-embedded-systems-programming-in-C-using-Code-Composer-Studio-Can-anyone-help-me-with-how-to-configure-my-code-composer-studio-environment-so-I-can-program-for-an-8051-microcontroller",
        "document": "Something went wrong. Wait a moment and try again."
    },
    {
        "link": "https://reddit.com/r/EngineeringStudents/comments/b6usid/any_input_to_making_a_synthesizer_using_an_8051",
        "document": "Our task is to build a musical synthesizer using an 8051 microcontroller. The input is a 12-key Printed Circuit Board designed to mimic an octave of a keyboard. The coding is C based (keil uvision 5).\n\nMy understanding is that I would have 12 separate infinite while loops creating a sin wave. Each button would trigger its repective loop and the loop will terminate when the button is released. A note would require setting the signal to +-127,5 in increments. The frequency would just be changing the time period of the wave."
    },
    {
        "link": "https://stackoverflow.com/questions/13736780/8051-c-interrupts",
        "document": "I'm using C to write a program on an 8051 microcontroller. The compiler I'm using is Keil Microvision. I'm stuck and having trouble figuring out what is missing from my code. I know it's very basic code I just can't figure out what I'm supposed to do.\n\nSo pretty much what I am doing is taking sending a sentence out to the user and having them answer yes or no through the serial port and I used a serial interrupt. That part works fine. If I get a no from the person I want to generate a square wave 5kHz by a timer interrupt. I want this square wave to be controlled by an external interrupt turning it on and off when the external interrupt on pin P3.2 is either on or off. Here is all my code\n\nThe part I'm having trouble with is these two interrupt from the previous code\n\nAny hints in the right direction would be greatly appreciated! Thanks. Sorry about formatting"
    },
    {
        "link": "https://embetronicx.com/tutorials/microcontrollers/8051/8051-interrupts-tutorial",
        "document": "In this post, we are going to discuss the 8051 Interrupts Tutorial. Before that, you should know about the Interrupt basics. For Basics, you can go here. Let’s start…\n\nThere are five interrupt sources for the 8051. Since the main RESET input can also be considered as an interrupt, six interrupts in the order of priority can be listed as follows:\n\nWhen an interrupt is received, the controller stops after executing the current instruction. It transfers the content of the program counter into the stack. It also stores the current status of the interrupts internally but not on the stack.\n\nThis is also known as Power-on Reset (POR). When the RESET interrupt is received, the controller restarts executing code from the 0000H location. This is an interrupt that is not available to or, better to say, need not be available to the programmer.\n\nEach Timer is associated with a Timer interrupt. A timer interrupt notifies the microcontroller that the corresponding Timer has finished counting.\n\nThere are two external interrupts EX0 and EX1 to serve external devices. Both these interrupts are active low. In AT89C51, P3.2 (INT0) and P3.3 (INT1) pins are available for external interrupts 0 and 1 respectively. An external interrupt notifies the microcontroller that an external device needs its service.\n\nThis interrupt is used for serial communication. When enabled, it notifies the controller whether a byte has been received or transmitted.\n\nBefore going into programming we have to go through the registers used in the Interrupt.\n• None TCON Register (Timer Control Register) – This is used for External Interrupts only.\n\nThis register is responsible for enabling and disabling the interrupt. EA register is set to one for enabling interrupts and set to 0 for disabling the interrupts. Its bit sequence and its meanings are shown in the following figure.\n\nTo enable any of the interrupts, first, the EA bit must be set to 1. After that, the bits corresponding to the desired interrupts are enabled. , , and bits are used to enable the Timer Interrupts 0, 1, and 2, respectively. In AT89C51, there are only two timers, so is not used. EX0 and EX1 are used to enable the external interrupts 0 and 1. ES is used for the serial interrupt.\n\nEA bit acts as a lock bit. If any of the interrupt bits are enabled but bit is not set, the interrupt will not function. By default, all the interrupts are in disabled mode.\n\nNote that the register is a bit addressable and individual interrupt bits can also be accessed.\n\nThe 8051 offers two levels of interrupt priority: High and Low. By using interrupt priorities you may assign higher priority to certain interrupt conditions. We can change the priority levels of the interrupts by changing the corresponding bit in the Interrupt Priority (IP) register as shown in the following figure.\n• None A low priority interrupt can only be interrupted by the high priority interrupt, but not interrupted by another low priority interrupt.\n• None If two interrupts of different priority levels are received simultaneously, the request of a higher priority level is served.\n• None If the requests of the same priority levels are received simultaneously, then the internal polling sequence determines which request is to be serviced.\n\nThe external interrupts are the interrupts received from the (external) devices interfaced with the microcontroller. They are received at pins of the controller. These can be level-triggered or edge-triggered. In level triggered, interrupt is enabled for a low at pin; while in case of edge triggering, interrupt is enabled for a high to low transition at pin. The edge or level trigger is decided by the register. We have already discussed this register in our Timer/Counter session. The register has the following bits:\n\nHere MSB four bits are used for Timers. But LSB four bits are used for External Interrupts. We will see that bits.\n\nSetting the and bits make the external interrupt 0 and 1 edge-triggered respectively. By default, these bits are cleared and so the external interrupt is level triggered.\n\nNote: For a level trigger interrupt, the pin must remain low until the start of the ISR and should return to high before the end of the ISR. If the low at pin goes high before the start of ISR, an interrupt will not be generated. Also if the pin remains low even after the end of ISR, the interrupt will be generated once again. This is the reason why the level trigger interrupt (low) at the pin must be four machine cycles long and not greater than or smaller than this.\n\nSo, these all are the registers used in the Interrupt. These registers are not enough for play with interrupt. We have to write the ISR or Interrupt Handler.\n\nSetting the bits of register is necessary and sufficient to enable the interrupts. The next step is to specify to the controller what to do when an interrupt occurs. This is done by writing a subroutine or function for the interrupt. This is the ISR and gets automatically called when an interrupt occurs. It is not required to call the Interrupt Subroutine explicitly in the code.\n\nAn important thing is that the definition of a subroutine must have the keyword interrupt followed by the interrupt number. A subroutine for a particular interrupt is identified by this number.\n\nTimer interrupts to blink an LED; Time delays in mode 1 using interrupt method.\n\nSend ‘A’ from the serial port when it receives anything via Rx.\n\nMultiple interrupts can be enabled by setting more than one interrupts in the IE register. If more than one interrupts occurs at the same time, the interrupts will be serviced in order of their priority. The priority of the interrupts can be changed by programming the bits of the Interrupt Priority ( ) register.\n\nSetting a particular bit in register makes the corresponding interrupt of the higher priority. For example, IP = 0x08; will make Timer1 priority higher. So the interrupt priority order will change. More than one bit in register can also be set. In such a case, the higher priority interrupts will follow the sequence as they follow in the default case.\n\nNote that in the below example external interrupt 1 is set to be a higher priority than the Timer 0 and external 0 in this case.\n\nI hope you have enjoyed this tutorial. Please comment below if you have any doubt. Thank you.\n\nYou can also read the below tutorials."
    },
    {
        "link": "https://circuitbread.com/tutorials/embedded-c-programming-with-the-pic18f14k50-16-digital-piano-with-the-matrix-keypad-and-passive-buzzer",
        "document": ""
    },
    {
        "link": "https://embeddedflakes.com/8051-keyboard-interface",
        "document": "In the realm of microcontroller-based systems, the 8051 microcontroller remains a popular choice for many applications. One crucial aspect of these systems is user input, often facilitated through keyboard interfaces. In this comprehensive guide, we’ll explore 15 advanced tricks for implementing lightning-fast keyboard interfaces with the 8051 microcontroller. Whether you’re a seasoned engineer or an enthusiastic hobbyist, these techniques will help you optimize your keyboard input systems for maximum efficiency and responsiveness.\n\nWhen it comes to keyboard interfacing, interrupt-driven scanning is a game-changer. By utilizing the 8051’s interrupt capabilities, we can significantly reduce CPU overhead and improve overall system responsiveness. Here’s a simple code snippet to illustrate this technique:\n\nThis approach allows the microcontroller to focus on other tasks while waiting for keyboard input, resulting in a more efficient system overall.\n\nKey bouncing is a common issue in keyboard interfaces that can lead to erroneous inputs. To combat this, we can implement software debounce techniques. Here’s an effective method:\n\nBy adding a small delay and rechecking the pin state, we can effectively filter out spurious signals caused by mechanical switch bouncing.\n\nFor rapid key mapping, look-up tables (LUTs) are an excellent solution. They allow for quick translation of scanned key values to their corresponding ASCII codes or custom values. Here’s a simple implementation:\n\nThis approach significantly reduces processing time compared to using multiple conditional statements.\n\nN-key rollover is a crucial feature for applications requiring simultaneous key presses. Here’s a basic implementation for 2-key rollover:\n\nThis allows the system to handle multiple key presses simultaneously, greatly enhancing user input capabilities.\n\nFor matrix keyboards, an efficient scanning algorithm is crucial. Here’s an optimized approach:\n\nThis algorithm minimizes the number of I/O operations, resulting in faster scanning times.\n\nA keyboard buffer can significantly improve system responsiveness by allowing the main program to process keystrokes at its own pace. Here’s a circular buffer implementation:\n\nThis buffer allows the system to store multiple keystrokes, preventing input loss during high-speed typing or when the main program is busy.\n\nTimer interrupts can be used to implement precise key timing for features like auto-repeat or double-click detection. Here’s a basic setup:\n\nThis setup allows for precise timing of key events, enabling advanced keyboard features.\n\nFor keyboards with many keys, shift registers can expand the 8051’s I/O capabilities. Here’s a simple interface:\n\nThis technique allows for interfacing with larger keyboards without using additional microcontroller pins.\n\nDetecting key combinations can greatly enhance the functionality of your keyboard interface. Here’s a simple implementation:\n\nThis allows for the implementation of complex keyboard shortcuts and commands.\n\nEfficient key release detection is crucial for responsive keyboard interfaces. Here’s an optimized approach:\n\nThis method efficiently tracks key states and allows for immediate detection of key releases.\n\nKeyboard mode switching can greatly expand the functionality of your interface. Here’s a simple implementation:\n\nThis allows for dynamic reconfiguration of key mappings based on the current input mode.\n\nFor keyboards with backlighting, the 8051 can be used to control the illumination. Here’s a basic PWM implementation:\n\nThis allows for smooth control of keyboard backlighting intensity.\n\nKeyboard locking can be a useful security feature. Here’s a simple implementation:\n\nThis feature adds an extra layer of security to your keyboard interface.\n\nThis allows users to record and playback complex key sequences with a single button press.\n\nAdaptive key repeat can greatly improve typing speed and comfort. Here’s an implementation that adjusts repeat rate based on key hold time:\n\nThis adaptive repeat functionality provides a more natural and efficient typing experience.\n\nBy implementing these 15 advanced tricks, we can create a highly responsive and efficient keyboard interface for the 8051 microcontroller. From optimized scanning algorithms to advanced features like macros and adaptive key repeat, these techniques push the boundaries of what’s possible with 8051-based keyboard systems. As we continue to innovate in the field of embedded systems, the humble keyboard interface remains a critical component, bridging the gap between human input and digital processing.\n\nRemember, the key to a successful keyboard interface lies not just in the individual techniques, but in how they are combined and tailored to meet the specific needs of your application. By carefully considering factors such as power consumption, processing speed, and user experience, we can create keyboard interfaces that not only meet but exceed user expectations.\n\nAs we look to the future, the principles outlined here will continue to evolve, adapting to new technologies and user needs. The 8051 microcontroller, with its robust architecture and wide support, will undoubtedly remain a valuable platform for implementing these advanced keyboard interfacing techniques for years to come."
    }
]