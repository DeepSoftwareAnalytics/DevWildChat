[
    {
        "link": "http://cs.caltech.edu/courses/cs11/material/cpp/donnie/cpp-ops.html",
        "document": ""
    },
    {
        "link": "https://geeksforgeeks.org/cpp-assignment-operator-overloading",
        "document": "The assignment operator,”=”, is the operator used for Assignment. It copies the right value into the left value. Assignment Operators are predefined to operate only on built-in Data types.\n• None Overloading assignment operator in C++ copies all values of one object to another object.\n• None Only a non-static member function should be used to overload the assignment operator.\n\nIn C++, the compiler automatically provides a default assignment operator for classes. This operator performs a shallow copy of each member of the class from one object to another. This means that if we don’t explicitly overload the assignment operator, the compiler will still allow us to assign one object to another using the assignment operator ( ), and it won’t generate an error.\n\nSo, when we should perform assignment operator overloading? when our class involves dynamic memory allocation (e.g., pointers) and we need to perform a deep copy to prevent issues like double deletion or data corruption.\n\nhere, a and b are of type integer, which is a built-in data type. Assignment Operator can be used directly on built-in data types.\n\nc1 and c2 are variables of type “class C”.\n\nThe above example can be done by implementing methods or functions inside the class, but we choose operator overloading instead. The reason for this is, operator overloading gives the functionality to use the operator directly which makes code easy to understand, and even code size decreases because of it. Also, operator overloading does not affect the normal working of the operator but provides extra functionality to it.\n\nNow, if the user wants to use the assignment operator “=” to assign the value of the class variable to another class variable then the user has to redefine the meaning of the assignment operator “=”. Redefining the meaning of operators really does not change their original meaning, instead, they have been given additional meaning along with their existing ones.\n\nAlso, always check if the object is not being assigned to itself (e.g., if (this != &other)), as assigning an object to itself does not make sense and may cause runtime issues.\n\nWhile managing dynamic resources, the above approach of assignment overloading have few flaws and there is more efficient approach that is recommended. See this article for more info – Copy-and-Swap Idiom in C++"
    },
    {
        "link": "https://stackoverflow.com/questions/4421706/what-are-the-basic-rules-and-idioms-for-operator-overloading",
        "document": "Most of the work in overloading operators is boilerplate code. That is little wonder, since operators are merely syntactic sugar. Their actual work could be done by (and often is forwarded to) plain functions. But it is important that you get this boilerplate code right. If you fail, either your operator’s code won’t compile, your users’ code won’t compile, or your users’ code will behave surprisingly.\n\nThere's a lot to be said about assignment. However, most of it has already been said in GMan's famous Copy-And-Swap FAQ, so I'll skip most of it here, only listing the perfect assignment operator for reference:\n\nThe bitwise shift operators and , although still used in hardware interfacing for the bit-manipulation functions they inherit from C, have become more prevalent as overloaded stream input and output operators in most applications.\n\nThe stream operators, among the most commonly overloaded operators, are binary infix operators for which the syntax does not specify any restriction on whether they should be members or non-members. However, their left operands are streams from the standard library, and you cannot add member functions to those1, so you need to implement these operators for your own types as non-member functions2. The canonical forms of the two are these:\n\nWhen implementing , manually setting the stream’s state is only necessary when the reading itself succeeded, but the result is not what would be expected.\n\n1 Note that some of the overloads of the standard library are implemented as member functions, and some as free functions. Only the locale-dependent functions are member functions, such as .\n\n2 According to the rules of thumb, the insertion/extraction operators should be member functions because they modify the left operand. However, we cannot follow the rules of thumb here.\n\nThe function call operator, used to create function objects, also known as functors, must be defined as a member function, so it always has the implicit argument of member functions. Other than this, it can be overloaded to take any number of additional arguments, including zero.\n\nHere's an example of the syntax:\n\nThroughout the C++ standard library, function objects are always copied. Your own function objects should therefore be cheap to copy. If a function object absolutely needs to use data which is expensive to copy, it is better to store that data elsewhere and have the function object refer to it.\n\nIn the most simple case, you can overload all comparison comparison operators by defaulting in C++20:\n\nIf you can't do this, continue to the linked answer.\n\nThe unary prefix negation should be implemented as a member function. It is usually not a good idea to overload it because of how rare and surprising it is.\n\nThe remaining binary logical operators ( , ) should be implemented as free functions. However, it is very unlikely that you would find a reasonable use case for these1.\n\n1 It should be noted that the built-in version of and use shortcut semantics. While the user defined ones (because they are syntactic sugar for method calls) do not use shortcut semantics. User will expect these operators to have shortcut semantics, and their code may depend on it, Therefore it is highly advised NEVER to define them.\n\nThe unary increment and decrement operators come in both prefix and postfix flavor. To tell one from the other, the postfix variants take an additional dummy int argument. If you overload increment or decrement, be sure to always implement both prefix and postfix versions.\n\nHere is the canonical implementation of increment, decrement follows the same rules:\n\nNote that the postfix variant is implemented in terms of prefix. Also note that postfix does an extra copy.1\n\nOverloading unary minus and plus is not very common and probably best avoided. If needed, they should probably be overloaded as member functions.\n\n1 Also note that the postfix variant does more work and is therefore less efficient to use than the prefix variant. This is a good reason to generally prefer prefix increment over postfix increment. While compilers can usually optimize away the additional work of postfix increment for built-in types, they might not be able to do the same for user-defined types (which could be something as innocently looking as a list iterator). Once you got used to do , it becomes very hard to remember to do instead when is not of a built-in type (plus you'd have to change code when changing a type), so it is better to make a habit of always using prefix increment, unless postfix is explicitly needed.\n\nFor the binary arithmetic operators, do not forget to obey the third basic rule operator overloading: If you provide , also provide , if you provide , do not omit , etc. Andrew Koenig is said to have been the first to observe that the compound assignment operators can be used as a base for their non-compound counterparts. That is, operator is implemented in terms of , is implemented in terms of , etc.\n\nAccording to our rules of thumb, and its companions should be non-members, while their compound assignment counterparts ( , etc.), changing their left argument, should be a member. Here is the exemplary code for and ; the other binary arithmetic operators should be implemented in the same way:\n\nreturns its result per reference, while returns a copy of its result. Of course, returning a reference is usually more efficient than returning a copy, but in the case of , there is no way around the copying. When you write , you expect the result to be a new value, which is why has to return a new value.1\n\nAlso note that can be slightly shortened by passing by value, not by reference. However, this would be leaking implementation details, make the function signature asymmetric, and would prevent named return value optimization where is the same object as the one being returned.\n\nSometimes, it's impractical to implement in terms of , such as for matrix multiplication. In that case, you can also delegate to :\n\nThe bit manipulation operators should be implemented in the same way as the arithmetic operators. However, (except for overloading and for output and input) there are very few reasonable use cases for overloading these.\n\n1 Again, the lesson to be taken from this is that is, in general, more efficient than and should be preferred if possible.\n\nThe subscript operator is a binary operator which must be implemented as a class member. It is used for container-like types that allow access to their data elements by a key. The canonical form of providing these is this:\n\nUnless you do not want users of your class to be able to change data elements returned by (in which case you can omit the non-const variant), you should always provide both variants of the operator.\n\nFor defining your own iterators or smart pointers, you have to overload the unary prefix dereference operator and the binary infix pointer member access operator :\n\nNote that these, too, will almost always need both a const and a non-const version. For the operator, if is of (or or ) type, another is called recursively, until an returns a value of non-class type.\n\nThe unary address-of operator should never be overloaded.\n\nFor (and more details about ) see this question. is rarely used and thus rarely ever overloaded. In fact, even iterators do not overload it."
    },
    {
        "link": "https://en.cppreference.com/w/cpp/language/operators",
        "document": "Customizes the C++ operators for operands of user-defined types.\n\nThe behaviors of non-punctuation operators are described in their own respective pages. Unless otherwise specified, the remaining description in this page does not apply to these functions.\n\nWhen an operator appears in an expression, and at least one of its operands has a class type or an enumeration type, then overload resolution is used to determine the user-defined function to be called among all the functions whose signatures match the following:\n\nOverloaded operators (but not the built-in operators) can be called using function notation:\n• An operator function must have at least one function parameter or implicit object parameter whose type is a class, a reference to a class, an enumeration, or a reference to an enumeration.\n• The operators (scope resolution), (member access), (member access through pointer to member), and (ternary conditional) cannot be overloaded.\n• New operators such as , , or cannot be created.\n• It is not possible to change the precedence, grouping, or number of operands of operators.\n• The overload of operator must either return a raw pointer, or return an object (by reference or by value) for which operator is in turn overloaded.\n• The overloads of operators and lose short-circuit evaluation.\n\nBesides the restrictions above, the language puts no other constraints on what the overloaded operators do, or on the return type (it does not participate in overload resolution), but in general, overloaded operators are expected to behave as similar as possible to the built-in operators: operator+ is expected to add, rather than multiply its arguments, operator= is expected to assign, etc. The related operators are expected to behave similarly (operator+ and operator+= do the same addition-like operation). The return types are limited by the expressions in which the operator is expected to be used: for example, assignment operators return by reference to make it possible to write a = b = c = d, because the built-in operators allow that.\n\nCommonly overloaded operators have the following typical, canonical forms:[1]\n\nThe assignment operator operator= has special properties: see copy assignment and move assignment for details.\n\nThe canonical copy-assignment operator is expected to be safe on self-assignment, and to return the lhs by reference:\n\nIn those situations where copy assignment cannot benefit from resource reuse (it does not manage a heap-allocated array and does not have a (possibly transitive) member that does, such as a member std::vector or std::string), there is a popular convenient shorthand: the copy-and-swap assignment operator, which takes its parameter by value (thus working as both copy- and move-assignment depending on the value category of the argument), swaps with the parameter, and lets the destructor clean it up.\n\nThis form automatically provides strong exception guarantee, but prohibits resource reuse.\n\nThe overloads of and that take a std::istream& or std::ostream& as the left hand argument are known as insertion and extraction operators. Since they take the user-defined type as the right argument ( in ), they must be implemented as non-members.\n\nThese operators are sometimes implemented as friend functions.\n\nWhen a user-defined class overloads the function call operator operator(), it becomes a FunctionObject type.\n\nAn object of such a type can be used in a function call expression:\n\nMany standard library algorithms accept FunctionObjects to customize behavior. There are no particularly notable canonical forms of operator(), but to illustrate the usage:\n\nWhen the postfix increment or decrement operator appears in an expression, the corresponding user-defined function (operator++ or operator--) is called with an integer argument ​0​. Typically, it is declared as T operator++(int) or T operator--(int), where the argument is ignored. The postfix increment and decrement operators are usually implemented in terms of the prefix versions:\n\nAlthough the canonical implementations of the prefix increment and decrement operators return by reference, as with any operator overload, the return type is user-defined; for example the overloads of these operators for std::atomic return by value.\n\nBinary operators are typically implemented as non-members to maintain symmetry (for example, when adding a complex number and an integer, if operator+ is a member function of the complex type, then only complex + integer would compile, and not integer + complex). Since for every binary arithmetic operator there exists a corresponding compound assignment operator, canonical forms of binary operators are implemented in terms of their compound assignments:\n\nStandard library algorithms such as std::sort and containers such as std::set expect operator< to be defined, by default, for the user-provided types, and expect it to implement strict weak ordering (thus satisfying the Compare requirements). An idiomatic way to implement strict weak ordering for a structure is to use lexicographical comparison provided by std::tie:\n\nTypically, once operator< is provided, the other relational operators are implemented in terms of operator<.\n\nLikewise, the inequality operator is typically implemented in terms of operator==:\n\nWhen three-way comparison (such as std::memcmp or std::string::compare) is provided, all six two-way comparison operators may be expressed through that:\n\nUser-defined classes that provide array-like access that allows both reading and writing typically define two overloads for operator[]: const and non-const variants:\n\nIf the value type is known to be a scalar type, the const variant should return by value.\n\nWhere direct access to the elements of the container is not wanted or not possible or distinguishing between lvalue c[i] = v; and rvalue v = c[i]; usage, operator[] may return a proxy. See for example std::bitset::operator[].\n\nUser-defined classes and enumerations that implement the requirements of BitmaskType are required to overload the bitwise arithmetic operators operator&, operator|, operator^, operator~, operator&=, operator|=, and operator^=, and may optionally overload the shift operators operator<< operator>>, operator>>=, and operator<<=. The canonical implementations usually follow the pattern for binary arithmetic operators described above.\n\nThe following operators are rarely overloaded:\n• The address-of operator, . If the unary & is applied to an lvalue of incomplete type and the complete type declares an overloaded , it is unspecified whether the operator has the built-in meaning or the operator function is called. Because this operator may be overloaded, generic libraries use to obtain addresses of objects of user-defined types. The best known example of a canonical overloaded is the Microsoft class . An example of this operator's use in EDSL can be found in boost.spirit.\n• The boolean logic operators, and . Unlike the built-in versions, the overloads cannot implement short-circuit evaluation. Also unlike the built-in versions, they do not sequence their left operand before the right one. In the standard library, these operators are only overloaded for .\n• The comma operator, . Unlike the built-in version, the overloads do not sequence their left operand before the right one. Because this operator may be overloaded, generic libraries use expressions such as instead of to sequence execution of expressions of user-defined types. The boost library uses in boost.assign, boost.spirit, and other libraries. The database access library SOCI also overloads .\n• The member access through pointer to member . There are no specific downsides to overloading this operator, but it is rarely used in practice. It was suggested that it could be part of a smart pointer interface, and in fact is used in that capacity by actors in boost.phoenix. It is more common in EDSLs such as cpp.react.\n\nThe following behavior-changing defect reports were applied retroactively to previously published C++ standards."
    },
    {
        "link": "https://stackoverflow.com/questions/46385084/c-overloading-addition-operator-to-add-objects",
        "document": "I'm working on a project where I need to add two objects together by overloading the addition operator, 99% of it makes sense to me, but I can't figure out how to do the actual addition process.\n\nMy code is currently\n\nThen I call it like so\n\nI thought using would allow me to access 's int variable but it won't allow me.\n\nBasically my question is how do I access the time variable on the left of the + operator since I only pass the operator+ function one object of Time? (t2)"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.button?view=windowsdesktop-9.0",
        "document": "Some information relates to prerelease product that may be substantially modified before it’s released. Microsoft makes no warranties, express or implied, with respect to the information provided here.\n\nThe following code example creates a Button, sets its DialogResult property to DialogResult.OK, and adds it to a Form.\n\nA Button can be clicked by using the mouse, ENTER key, or SPACEBAR if the button has focus.\n\nSet the AcceptButton or CancelButton property of a Form to allow users to click a button by pressing the ENTER or ESC keys even if the button does not have focus. This gives the form the behavior of a dialog box.\n\nWhen you display a form using the ShowDialog method, you can use the DialogResult property of a button to specify the return value of ShowDialog.\n\nYou can change the button's appearance. For example, to make it appear flat for a Web look, set the FlatStyle property to FlatStyle.Flat. The FlatStyle property can also be set to FlatStyle.Popup, which appears flat until the mouse pointer passes over the button; then the button takes on the standard Windows button appearance.\n\nIf the control that has focus accepts and processes the ENTER key press, the Button does not process it. For example, if a multiline TextBox or another button has focus, that control processes the ENTER key press instead of the accept button.\n\nGets the AccessibleObject assigned to the control. (Inherited from Control) Gets or sets the default action description of the control for use by accessibility client applications. (Inherited from Control) Gets or sets the description of the control used by accessibility client applications. (Inherited from Control) Gets or sets the name of the control used by accessibility client applications. (Inherited from Control) Gets or sets the accessible role of the control. (Inherited from Control) Gets or sets a value indicating whether the control can accept data that the user drags onto it. (Inherited from Control) Gets or sets the edges of the container to which a control is bound and determines how a control is resized with its parent. (Inherited from Control) Gets or sets a value indicating whether the ellipsis character (...) appears at the right edge of the control, denoting that the control text extends beyond the specified length of the control. (Inherited from ButtonBase) Gets or sets where this control is scrolled to in ScrollControlIntoView(Control). (Inherited from Control) Gets or sets a value that indicates whether the control resizes based on its contents. (Inherited from ButtonBase) Gets or sets the mode by which the Button automatically resizes itself. Gets or sets the background color of the control. (Inherited from ButtonBase) Gets or sets the background image displayed in the control. (Inherited from Control) Gets or sets the background image layout as defined in the ImageLayout enumeration. (Inherited from Control) Gets or sets the BindingContext for the control. (Inherited from Control) Gets the distance, in pixels, between the bottom edge of the control and the top edge of its container's client area. (Inherited from Control) Gets or sets the size and location of the control including its nonclient elements, in pixels, relative to the parent control. (Inherited from Control) Gets a value indicating whether the ImeMode property can be set to an active value, to enable IME support. (Inherited from Control) Gets a value indicating whether the control can receive focus. (Inherited from Control) Determines if events can be raised on the control. (Inherited from Control) Gets a value indicating whether the control can be selected. (Inherited from Control) Gets or sets a value indicating whether the control has captured the mouse. (Inherited from Control) Gets or sets a value indicating whether the control causes validation to be performed on any controls that require validation when it receives focus. (Inherited from Control) Gets the rectangle that represents the client area of the control. (Inherited from Control) Gets or sets the height and width of the client area of the control. (Inherited from Control) Gets or sets the ICommand whose Execute(Object) method will be called when the Click event is invoked. (Inherited from ButtonBase) Gets or sets the parameter that is passed to the ICommand that's assigned to the Command property. (Inherited from ButtonBase) Gets the name of the company or creator of the application containing the control. (Inherited from Control) Gets the IContainer that contains the Component. (Inherited from Component) Gets a value indicating whether the control, or one of its child controls, currently has the input focus. (Inherited from Control) Gets or sets the shortcut menu associated with the control. (Inherited from Control) Gets or sets the ContextMenuStrip associated with this control. (Inherited from Control) Gets the collection of controls contained within the control. (Inherited from Control) Gets a value indicating whether the control has been created. (Inherited from Control) Gets a CreateParams on the base class when creating a window. Gets or sets the cursor that is displayed when the mouse pointer is over the control. (Inherited from Control) Gets the data bindings for the control. (Inherited from Control) Gets or sets the data context for the purpose of data binding. This is an ambient property. (Inherited from Control) Gets or sets the default cursor for the control. (Inherited from Control) Gets the default Input Method Editor (IME) mode supported by this control. (Inherited from ButtonBase) Gets the space, in pixels, that is specified by default between controls. (Inherited from Control) Gets the length and height, in pixels, that is specified as the default maximum size of a control. (Inherited from Control) Gets the length and height, in pixels, that is specified as the default minimum size of a control. (Inherited from Control) Gets the default internal spacing, in pixels, of the contents of a control. (Inherited from Control) Gets the default size of the control. (Inherited from ButtonBase) Gets a value that indicates whether the Component is currently in design mode. (Inherited from Component) Gets the DPI value for the display device where the control is currently being displayed. (Inherited from Control) Gets or sets a value that is returned to the parent form when the button is clicked. Gets the rectangle that represents the display area of the control. (Inherited from Control) Gets a value indicating whether the base Control class is in the process of disposing. (Inherited from Control) Gets or sets which control borders are docked to its parent control and determines how a control is resized with its parent. (Inherited from Control) Gets or sets a value indicating whether this control should redraw its surface using a secondary buffer to reduce or prevent flicker. (Inherited from Control) Gets or sets a value indicating whether the control can respond to user interaction. (Inherited from Control) Gets the list of event handlers that are attached to this Component. (Inherited from Component) Gets the appearance of the border and the colors used to indicate check state and mouse state. (Inherited from ButtonBase) Gets or sets the flat style appearance of the button control. (Inherited from ButtonBase) Gets a value indicating whether the control has input focus. (Inherited from Control) Gets or sets the font of the text displayed by the control. (Inherited from Control) Gets or sets the height of the font of the control. (Inherited from Control) Gets or sets the foreground color of the control. (Inherited from Control) Gets the window handle that the control is bound to. (Inherited from Control) Gets a value indicating whether the control contains one or more child controls. (Inherited from Control) Gets or sets the height of the control. (Inherited from Control) Gets or sets the image that is displayed on a button control. (Inherited from ButtonBase) Gets or sets the alignment of the image on the button control. (Inherited from ButtonBase) Gets or sets the image list index value of the image displayed on the button control. (Inherited from ButtonBase) Gets or sets the key accessor for the image in the ImageList. (Inherited from ButtonBase) Gets or sets the ImageList that contains the Image displayed on a button control. (Inherited from ButtonBase) Gets or sets the Input Method Editor (IME) mode supported by this control. This property is not relevant for this class. (Inherited from ButtonBase) Gets or sets the IME mode of a control. (Inherited from Control) Gets a value indicating whether the caller must call an invoke method when making method calls to the control because the caller is on a different thread than the one the control was created on. (Inherited from Control) Gets or sets a value indicating whether the control is visible to accessibility applications. (Inherited from Control) Indicates if one of the Ancestors of this control is sited and that site in DesignMode. This property is read-only. (Inherited from Control) Gets or sets a value indicating whether the button control is the default button. (Inherited from ButtonBase) Gets a value indicating whether the control has been disposed of. (Inherited from Control) Gets a value indicating whether the control has a handle associated with it. (Inherited from Control) Gets a value indicating whether the control is mirrored. (Inherited from Control) Gets a cached instance of the control's layout engine. (Inherited from Control) Gets or sets the distance, in pixels, between the left edge of the control and the left edge of its container's client area. (Inherited from Control) Gets or sets the coordinates of the upper-left corner of the control relative to the upper-left corner of its container. (Inherited from Control) Gets or sets the space between controls. (Inherited from Control) Gets or sets the size that is the upper limit that GetPreferredSize(Size) can specify. (Inherited from Control) Gets or sets the size that is the lower limit that GetPreferredSize(Size) can specify. (Inherited from Control) Gets or sets the name of the control. (Inherited from Control) Gets or sets padding within the control. (Inherited from Control) Gets or sets the parent container of the control. (Inherited from Control) Gets the size of a rectangular area into which the control can fit. (Inherited from Control) Gets the product name of the assembly containing the control. (Inherited from Control) Gets the version of the assembly containing the control. (Inherited from Control) Gets a value indicating whether the control is currently re-creating its handle. (Inherited from Control) Gets or sets the window region associated with the control. (Inherited from Control) This property is now obsolete. (Inherited from Control) Gets or sets a value indicating whether the control redraws itself when resized. (Inherited from Control) Gets the distance, in pixels, between the right edge of the control and the left edge of its container's client area. (Inherited from Control) Gets or sets a value indicating whether control's elements are aligned to support locales using right-to-left fonts. (Inherited from Control) Gets a value that determines the scaling of child controls. (Inherited from Control) Gets a value indicating whether the control should display focus rectangles. (Inherited from Control) Gets a value indicating whether the user interface is in the appropriate state to show or hide keyboard accelerators. (Inherited from Control) Gets or sets the site of the control. (Inherited from Control) Gets or sets the height and width of the control. (Inherited from Control) Gets or sets the tab order of the control within its container. (Inherited from Control) Gets or sets a value indicating whether the user can give the focus to this control using the TAB key. (Inherited from Control) Gets or sets the object that contains data about the control. (Inherited from Control) Gets or sets the text associated with this control. (Inherited from ButtonBase) Gets or sets the alignment of the text on the button control. (Inherited from ButtonBase) Gets or sets the position of text and image relative to each other. (Inherited from ButtonBase) Gets or sets the distance, in pixels, between the top edge of the control and the top edge of its container's client area. (Inherited from Control) Gets the parent control that is not parented by another Windows Forms control. Typically, this is the outermost Form that the control is contained in. (Inherited from Control) Gets or sets a value that determines whether to use the Graphics class (GDI+) or the TextRenderer class (GDI) to render text. (Inherited from ButtonBase) Gets or sets a value indicating whether the first character that is preceded by an ampersand (&) is used as the mnemonic key of the control. (Inherited from ButtonBase) Gets or sets a value that determines if the background is drawn using visual styles, if supported. (Inherited from ButtonBase) Gets or sets a value indicating whether to use the wait cursor for the current control and all child controls. (Inherited from Control) Gets or sets a value indicating whether the control and all its child controls are displayed. (Inherited from Control) Gets or sets the width of the control. (Inherited from Control) This property is not relevant for this class. (Inherited from Control)\n\nOccurs when the value of the AutoSize property changes. (Inherited from ButtonBase) Occurs when the value of the BackColor property changes. (Inherited from Control) Occurs when the value of the BackgroundImage property changes. (Inherited from Control) Occurs when the BackgroundImageLayout property changes. (Inherited from Control) Occurs when the value of the BindingContext property changes. (Inherited from Control) Occurs when the value of the CausesValidation property changes. (Inherited from Control) Occurs when the focus or keyboard user interface (UI) cues change. (Inherited from Control) Occurs when the control is clicked. (Inherited from Control) Occurs when the value of the ClientSize property changes. (Inherited from Control) Occurs when the CanExecute(Object) status of the ICommand that's assigned to the Command property has changed. (Inherited from ButtonBase) Occurs when the assigned ICommand of the Command property has changed. (Inherited from ButtonBase) Occurs when the value of the CommandParameter property has changed. (Inherited from ButtonBase) Occurs when the value of the ContextMenu property changes. (Inherited from Control) Occurs when the value of the ContextMenuStrip property changes. (Inherited from Control) Occurs when a new control is added to the Control.ControlCollection. (Inherited from Control) Occurs when a control is removed from the Control.ControlCollection. (Inherited from Control) Occurs when the value of the Cursor property changes. (Inherited from Control) Occurs when the value of the DataContext property changes. (Inherited from Control) Occurs when the component is disposed by a call to the Dispose() method. (Inherited from Component) Occurs when the value of the Dock property changes. (Inherited from Control) Occurs when the user double-clicks the Button control. Occurs when the DPI setting for a control is changed programmatically after the DPI of its parent control or form has changed. (Inherited from Control) Occurs when the DPI setting for a control is changed programmatically before a DPI change event for its parent control or form has occurred. (Inherited from Control) Occurs when an object is dragged into the control's bounds. (Inherited from Control) Occurs when an object is dragged out of the control's bounds. (Inherited from Control) Occurs when an object is dragged over the control's bounds. (Inherited from Control) Occurs when the Enabled property value has changed. (Inherited from Control) Occurs when the control is entered. (Inherited from Control) Occurs when the Font property value changes. (Inherited from Control) Occurs when the ForeColor property value changes. (Inherited from Control) Occurs when a handle is created for the control. (Inherited from Control) Occurs when the control's handle is in the process of being destroyed. (Inherited from Control) Occurs when the user requests help for a control. (Inherited from Control) Occurs when the ImeMode property is changed. This event is not relevant for this class. (Inherited from ButtonBase) Occurs when a key is pressed while the control has focus. (Inherited from Control) Occurs when a character, space, or backspace key is pressed while the control has focus. (Inherited from Control) Occurs when a key is released while the control has focus. (Inherited from Control) Occurs when a control should reposition its child controls. (Inherited from Control) Occurs when the input focus leaves the control. (Inherited from Control) Occurs when the Location property value has changed. (Inherited from Control) Occurs when the control's margin changes. (Inherited from Control) Occurs when the control is clicked by the mouse. (Inherited from Control) Occurs when the user double-clicks the Button control with the mouse. Occurs when the mouse pointer is over the control and a mouse button is pressed. (Inherited from Control) Occurs when the mouse pointer enters the control. (Inherited from Control) Occurs when the mouse pointer rests on the control. (Inherited from Control) Occurs when the mouse pointer leaves the control. (Inherited from Control) Occurs when the mouse pointer is moved over the control. (Inherited from Control) Occurs when the mouse pointer is over the control and a mouse button is released. (Inherited from Control) Occurs when the mouse wheel moves while the control has focus. (Inherited from Control) Occurs when the control is moved. (Inherited from Control) Occurs when the control's padding changes. (Inherited from Control) Occurs when the control is redrawn. (Inherited from Control) Occurs when the Parent property value changes. (Inherited from Control) Occurs before the KeyDown event when a key is pressed while focus is on this control. (Inherited from Control) Occurs when AccessibleObject is providing help to accessibility applications. (Inherited from Control) Occurs during a drag-and-drop operation and enables the drag source to determine whether the drag-and-drop operation should be canceled. (Inherited from Control) Occurs when the value of the Region property changes. (Inherited from Control) Occurs when the control is resized. (Inherited from Control) Occurs when the RightToLeft property value changes. (Inherited from Control) Occurs when the Size property value changes. (Inherited from Control) Occurs when the control style changes. (Inherited from Control) Occurs when the TabIndex property value changes. (Inherited from Control) Occurs when the TabStop property value changes. (Inherited from Control) Occurs when the Text property value changes. (Inherited from Control) Occurs when the control is finished validating. (Inherited from Control) Occurs when the control is validating. (Inherited from Control) Occurs when the Visible property value changes. (Inherited from Control)"
    },
    {
        "link": "https://learn.microsoft.com/en-us/cpp/overview/visual-cpp-samples?view=msvc-170",
        "document": ""
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/desktop/winforms/controls/controls-to-use-on-windows-forms?view=netframeworkdesktop-4.8",
        "document": "Controls to Use on Windows Forms\n\nThe following is an alphabetic list of controls and components that can be used on Windows Forms. In addition to the Windows Forms controls covered in this section, you can add ActiveX and custom controls to Windows Forms. If you do not find the control you need listed here, you can also create your own. For details, see Developing Windows Forms Controls at Design Time. For more information about choosing the control you need, see Windows Forms Controls by Function.\n\nWindows Forms Controls by Function\n\n Lists and describes Windows Forms controls based on the .NET Framework.\n\nControls with Built-In Owner-Drawing Support\n\n Describes how to alter aspects of a control's appearance that are not available through properties.\n\nBackgroundWorker Component\n\n Enables a form or control to run an operation asynchronously.\n\nBindingNavigator Control\n\n Provides the navigation and manipulation user interface (UI) for controls that are bound to data.\n\nButton Control\n\n Presents a standard button that the user can click to perform actions.\n\nCheckBox Control\n\n Indicates whether a condition is on or off.\n\nCheckedListBox Control\n\n Displays a list of items with a check box next to each item.\n\nColorDialog Component\n\n Allows the user to select a color from a palette in a pre-configured dialog box and to add custom colors to that palette.\n\nContextMenu Component\n\n Provides users with an easily accessible menu of frequently used commands that are associated with the selected object. Although ContextMenuStrip replaces and adds functionality to the ContextMenu control of previous versions, ContextMenu is retained for both backward compatibility and future use if so desired.\n\nContextMenuStrip Control\n\n Represents a shortcut menu. Although ContextMenuStrip replaces and adds functionality to the ContextMenu control of previous versions, ContextMenu is retained for both backward compatibility and future use if so desired.\n\nDataGrid Control\n\n Displays tabular data from a dataset and allows for updates to the data source.\n\nDataGridView Control\n\n Provides a flexible, extensible system for displaying and editing tabular data.\n\nDateTimePicker Control\n\n Allows the user to select a single item from a list of dates or times.\n\nDialog-Box Controls and Components\n\n Describes a set of controls that allow users to perform standard interactions with the application or system.\n\nDomainUpDown Control\n\n Displays text strings that a user can browse through and select from.\n\nErrorProvider Component\n\n Displays error information to the user in a non-intrusive way.\n\nFlowLayoutPanel Control\n\n Represents a panel that dynamically lays out its contents horizontally or vertically.\n\nFolderBrowserDialog Component\n\n Displays an interface with which users can browse and select a directory or create a new one.\n\nFontDialog Component\n\n Exposes the fonts that are currently installed on the system.\n\nGroupBox Control\n\n Provides an identifiable grouping for other controls.\n\nHelpProvider Component\n\n Associates an HTML Help file with a Windows-based application.\n\nHScrollBar and VScrollBar Controls\n\n Provide navigation through a list of items or a large amount of information by scrolling either horizontally or vertically within an application or control.\n\nLabel Control\n\n Displays text that cannot be edited by the user.\n\nLinkLabel Control\n\n Allows you to add Web-style links to Windows Forms applications.\n\nListBox Control\n\n Allows the user to select one or more items from a predefined list.\n\nListView Control\n\n Displays a list of items with icons, in the manner of Windows Explorer.\n\nMainMenu Component\n\n Displays a menu at run time. Although MenuStrip replaces and adds functionality to the MainMenu control of previous versions, MainMenu is retained for both backward compatibility and future use if you choose.\n\nMaskedTextBox Control\n\n Constrains the format of user input in a form.\n\nMenuStrip Control\n\n Provides a menu system for a form. Although MenuStrip replaces and adds functionality to the MainMenu control of previous versions, MainMenu is retained for both backward compatibility and future use if you choose.\n\nMonthCalendar Control\n\n Presents an intuitive graphical interface for users to view and set date information.\n\nNotifyIcon Component\n\n Displays icons for processes that run in the background and would not otherwise have user interfaces.\n\nNumericUpDown Control\n\n Displays numerals that a user can browse through and select from.\n\nOpenFileDialog Component\n\n Allows users to open files by using a pre-configured dialog box.\n\nPanel Control\n\n Provide an identifiable grouping for other controls, and allows for scrolling.\n\nPrintDialog Component\n\n Selects a printer, chooses the pages to print, and determines other print-related settings.\n\nPrintDocument Component\n\n Sets the properties that describe what to print, and prints the document in Windows-based applications.\n\nPrintPreviewControl Control\n\n Allows you to create your own component or dialog box instead of using the pre-configured version.\n\nPrintPreviewDialog Control\n\n Displays a document as it will appear when it is printed.\n\nProgressBar Control\n\n Graphically indicates the progress of an action towards completion.\n\nRadioButton Control\n\n Presents a set of two or more mutually exclusive options to the user.\n\nRichTextBox Control\n\n Allows users to enter, display, and manipulate text with formatting.\n\nSaveFileDialog Component\n\n Selects files to save and where to save them.\n\nSoundPlayer Class Enables you to easily include sounds in your applications.\n\nSplitContainer Control\n\n Allows the user to resize a docked control.\n\nSplitter Control\n\n Allows the user to resize a docked control (.NET Framework version 1.x).\n\nStatusBar Control\n\n Displays status information related to the control that has focus. Although StatusStrip replaces and extends the StatusBar control of previous versions, StatusBar is retained for both backward compatibility and future use if you choose.\n\nStatusStrip Control\n\n Represents a Windows status bar control. Although StatusStrip replaces and extends the StatusBar control of previous versions, StatusBar is retained for both backward compatibility and future use if you choose.\n\nTabControl Control\n\n Displays multiple tabs that can contain pictures or other controls.\n\nTableLayoutPanel Control\n\n Represents a panel that dynamically lays out its contents in a grid composed of rows and columns.\n\nTextBox Control\n\n Allows editable, multiline input from the user.\n\nToolBar Control\n\n Displays menus and bitmapped buttons that activate commands. You can extend the functionality of the control and modify its appearance and behavior. Although ToolStrip replaces and adds functionality to the ToolBar control of previous versions, ToolBar is retained for both backward compatibility and future use if you choose.\n\nToolStrip Control\n\n Creates custom toolbars and menus in your Windows Forms applications. Although ToolStrip replaces and adds functionality to the ToolBar control of previous versions, ToolBar is retained for both backward compatibility and future use if you choose.\n\nToolStripContainer Control\n\n Provides panels on each side of a form for docking, rafting, and arranging ToolStrip controls, and a central ToolStripContentPanel for traditional controls.\n\nToolStripPanel Control\n\n Provides one panel for docking, rafting and arranging ToolStrip controls.\n\nToolStripProgressBar Control Overview\n\n Graphically indicates the progress of an action towards completion. The ToolStripProgressBar is typically contained in a StatusStrip.\n\nToolTip Component\n\n Displays text when the user points at other controls.\n\nTrackBar Control\n\n Allows navigation through a large amount of information or visually adjusting a numeric setting.\n\nTreeView Control\n\n Displays a hierarchy of nodes that can be expanded or collapsed.\n\nWebBrowser Control\n\n Hosts Web pages and provides Internet Web browsing capabilities to your application.\n\nWindows Forms Controls Used to List Options\n\n Describes a set of controls used to provide users with a list of options to choose from.\n\nWindows Forms Controls\n\n Explains the use of Windows Forms controls, and describes important concepts for working with them.\n\nDeveloping Windows Forms Controls at Design Time\n\n Provides links to step-by-step topics, recommendations for which kind of control to create, and other information about creating your own control.\n\nControls and Programmable Objects Compared in Various Languages and Libraries\n\n Provides a table that maps controls in Visual Basic 6.0 to the corresponding control in Visual Basic .NET. Note that controls are now classes in the .NET Framework.\n\nHow to: Add ActiveX Controls to Windows Forms\n\n Describes how to use ActiveX controls on Windows Forms."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/desktop/winforms?view=netdesktop-9.0",
        "document": "This browser is no longer supported.\n\nUpgrade to Microsoft Edge to take advantage of the latest features, security updates, and technical support."
    },
    {
        "link": "https://learn.microsoft.com/en-us/visualstudio/ide/create-csharp-winform-visual-studio?view=vs-2022",
        "document": "Tutorial: Create a Windows Forms app in Visual Studio with C#\n\nIn this tutorial, you create a simple C# application that has a Windows-based user interface (UI). The app has a button that changes the text of a label. This simple app has all the components used for more complicated Windows Forms programs.\n\nFirst, create a C# application project. The project type comes with all the template files you need to create your application.\n\nAfter you select your C# project template and name your project, Visual Studio opens a form for you. A form is a Windows user interface. Create a Hello World application by adding controls to the form. Then run the app.\n• If you don't see the Toolbox option, you can open it from the menu bar. Select View > Toolbox or Ctrl+Alt+X.\n• None Select the Pin icon to dock the Toolbox window.\n• None Select the Button control and then drag it onto the form.\n• None In the Properties window, locate Text, change the name from Button1 to , and then select Enter. If you don't see the Properties window, you can open it from the menu bar. Select View > Properties Window or F4.\n• None In the Design section of the Properties window, change the name from Button1 to , and then select Enter. If you alphabetized the list in the Properties window, Button1 appears in the (DataBindings) section, instead. You can dock or anchor the controls on your form to help with automatic placement and sizing, when the form changes size. After you add a button control to create an action, add a label control to receive the text.\n• None Select the Label control from the Toolbox. Then drag it onto the form and drop it beneath the Click this button.\n• None In either the Design section or the (DataBindings) section of the Properties window, change the name of Label1 to . Then select Enter.\n• None In the Form1.cs [Design] window, double-click the Click this button to open the Form1.cs window. Alternatively, you can expand Form1.cs in Solution Explorer, and then choose View Code or select F7 from the shortcut menu on Form1.cs.\n• None In the Form1.cs window, after the private void line, type or enter as shown in the following screenshot.\n\nAfter you select your C# project template and name your project, Visual Studio opens a form for you. A form is a Windows user interface. Create a Hello World application by adding controls to the form. Then run the app.\n• If you don't see the Toolbox option, you can open it from the menu bar. Select View > Toolbox or Ctrl+Alt+X.\n• None Expand Common Controls and select the Pin icon to dock the Toolbox window.\n• None Select the Button control and then drag it onto the form.\n• None In the Properties window, locate Text. Change the name from button1 to , and then select Enter. If you don't see the Properties window, you can open it from the menu bar. Select View > Properties Window or F4.\n• None In the Design section of the Properties window, change the name from button1 to , and then select Enter. If you alphabetized the list in the Properties window, Button1 appears in the (DataBindings) section, instead. You can dock or anchor the controls on your form to help with automatic placement and sizing, when the form changes size. After you add a button control to create an action, add a label control to receive the text.\n• None Select the Label control from the Toolbox. Then drag it onto the form and drop it beneath the Click this button.\n• None In either the Design section or the (DataBindings) section of the Properties window, change the name of label1 to . Then select Enter.\n• None In the Form1.cs [Design] window, double-click the Click this button to open the Form1.cs window. Alternatively, you can expand Form1.cs in Solution Explorer, and then choose Form1.\n• None In the Form1.cs window, after the private void line, type or enter as shown in the following screenshot.\n• None Select the Start button to run the application. Several things happen. In the Visual Studio IDE, the Diagnostics Tools window opens, and an Output window opens, too. But outside of the IDE, a Form1 dialog box appears. It includes your Click this button and text that says label1.\n• None Select the Click this button in the Form1 dialog box. Notice that the label1 text changes to Hello World!.\n• None Close the Form1 dialog box to stop running the app.\n\nCongratulations on completing this tutorial. To learn more, continue with the following tutorial:\n\nOr try these other tutorials:"
    }
]