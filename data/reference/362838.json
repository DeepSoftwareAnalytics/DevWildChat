[
    {
        "link": "https://howtoforge.com/linux-xxd-command",
        "document": "Need a hex dump for a text file? Looking for a command-line utility that can do this? Well, you are in luck, as there exists a command dubbed xxd that can do this for you. In this tutorial, we will discuss xxd using some easy-to-understand examples. But before we do that, it's worth mentioning that all examples here have been tested on an Ubuntu 22.04 LTS machine.\n\nWhat is the Linux xxd command used for?\n\nThe xxd command in Linux lets you create a hexdump or even do the reverse. Following is its syntax:\n\nAnd here's how the tool's man page explains it:\n\nFollowing are some Q&A-styled examples that should give you a better idea of how xxd works.\n\nQ1. How to use xxd command?\n\nIt's simple. For example, suppose you have a text file 'test.txt' with contents as shown below:\n\nHere's how you can use xxd to convert the file contents into hex:\n\nQ2. How to skip a few lines with xxd?\n\nSuppose you don't want hex dump of the complete file. Instead, you want the tool to start converting from a specific line. Then this can be achieved using the -s command.\n\nFor example, if you want xxd to produce hex dump from line 3 onwards, then here's how you tell xxd to do this:\n\nSo you can see the hex dump is produced from line 3 onwards in this case.\n\nQ3. How to limit xxd output to a particular length?\n\nIn the previous section, we discussed how to make xxd start converting from a particular point. But there's also a way to limit its conversion to a particular point. This can be done using the -l command-line option.\n\nFor example, to make sure xxd creates a dump for only the first three lines of test.txt, use it in the following way:\n\nIf you want xxd to produce fewer or more columns in the output, use the -c option and specify the number of columns there. Here's an example command using this option:\n\nSo you can see only 5 columns were produced in output.\n\nYes, this is also possible. The -b command-line option makes xxd produce dump in binary digits. Here's what the man page says about this tool:\n\nAs you can see, the xxd command is useful if you deal in hex and binary file contents. Here, in this tutorial, we've just discussed some basic options xxd offers. Once you're done practicing these, head to the tool's man page to learn more about it."
    },
    {
        "link": "https://geeksforgeeks.org/xxd-command-in-linux",
        "document": "xxd is a command-line tool that is primarily used for creating and analyzing hexadecimal dumps from files. It can also be used to reverse the process and convert a hexadecimal dump back into binary form. In this article, let's uncover the practical applications of the \"xxd\" command in the Linux ecosystem.\n\nA hexadecimal dump, often called a hex dump, is a representation of binary data in a human-readable format using hexadecimal notation. Each byte of binary data is displayed as a pair of hexadecimal digits, making it easier to understand the data.\n\nHere's an example of the phrase \"How are you\" in a hexadecimal dump:\n\nHere, \"48\" represents 'H,' \"6f\" represents 'o,' and so on.\n\nWhile most Linux distributions come with the \"xxd\" command pre-installed, if you encounter an error when attempting to use it, you may need to install it based on your specific distribution.\n\nHere's a table that summarizes some of the most common options of the \"xxd\" command and their descriptions:\n\nTo create a hexadecimal dump of a file, you can use the following command:\n\nThe binary output on the left side represents a hexadecimal memory address or offset, which indicates the position of each line's data in memory or a binary file, then there are two columns:\n• The right column contains the hexadecimal representation of the binary data.\n\nHere we can see, that the hexadecimal representation for 'H' is 48, for 'e' it is 65, the and so on.\n\nWe can store the generated hexadecimal dump using the redirection operator '>', type the following command:\n\nHere, the hexadecimal dump from standard output is stored in a file named hexdump.txt using the the redirection operator.\n\nThe hexadecimal dump was saved in a file called \"hexdump.txt,\" and we used the '-r' option to reverse this process, converting the hex dump back into its original format. The resulting data has been stored in a file named \"reversed.txt.\"\n\nThe xxd command allows you to specify an offset, effectively skipping a certain number of lines or bytes in the input file when generating a hexadecimal dump.\n\n\n\nHere, xxd skipped 5 bytes of the word 'Hello' and generated a hexadecimal dump for the remaining text.\n\nThe \"xxd -s\" option allows you to specify an offset or skip a certain number of bytes at the beginning of a file when generating a hexadecimal dump.\n\nBy using the '-' operator in the offset, the resulting hexadecimal dump is generated for the last 5 bytes of the file.\n\nThe \"xxd -l\" option permits you to limit the number of bytes processed or displayed when generating a hexadecimal dump.\n\nWe are generating a hex dump of the the first 20 bytes (0x14 is hexadecimal equivalent of 20).\n\nHere's another example where we skip lines in the hexadecimal dump by specifying offsets like 0x10 (which is equivalent to 16 in decimal) and 0x20 (equivalent to 32 in decimal). It's the same as skipping bytes, we are just omitting the display of 16 bytes of data per skipped line.\n\nThe -g option allows us to organize the output by grouping a certain number of bytes.\n\nHere, we have generated a hexadecimal dump with 4 bytes per group.\n\nLimiting the number of columns (-c)\n\nWe can use the -c option to limit the number of columns per line in the output dump.\n\nHere, we are limiting the output to 5 columns per line, you can use 0x05 instead of 5 to get the same output.\n\nFor example: To display the first 20 bytes of the file the commands can be:\n\nHere, the number of bytes is 20 in decimal, 0x14 in hexadecimal, and 024 in octal.\n\nInstead of generating a hexadecimal dump, the use of the \"-b\" option allows us to create a dump that represents the binary digits of the data.\n\nThe above binary dump, generated using the -b option, shows that the character 'H' is converted to the binary sequence '01001000', the character 'e' is converted to the binary sequence '01100101', and so on.\n\nThe \"xxd -ps\" option is used to generate a hexadecimal postscript-style dump, also known as plain hexdump style. It provides a specific output format where the bytes are displayed continuously without line breaks, suitable for certain applications or requirements.\n\nThe \"xxd -u\" option in the xxd command is used to specify that the hexadecimal output should use uppercase characters instead of the default lowercase characters.\n\nWhile the primary purpose of xxd is to create hexadecimal dumps, xxd -i takes it a step further by generating a C include file that contains the binary data as an array.\n\nThe generated output.c file includes an array with the binary data from hello.txt. For example, you might get something like this in output.c:\n• unsigned char hello_txt[] is an array of unsigned characters, which represents the binary data of hello.txt.\n• None The array is initialized with a list of hexadecimal values Each hexadecimal value represents a byte of data 0x prefix denoting a hexadecimal number . The values correspond to the ASCII codes of the characters in \"hello.txt.\"\n• unsigned int hello_txt_len is an additional variable that stores the length of the array . In this case, it's set to 30, indicating that the array contains 30 bytes of data\n\nNow, you can easily use this array in your C or C++ code, making it convenient for embedding binary data, such as images or other resources, directly into your applications.\n\nC program to utilize the output of xxd -i:\n\nYou can use the generated C code to display the text from hello.txt as follows:\n\nThis C code includes the generated data array hello_txt and its length hello_txt_len. The program iterates through the array and uses the putchar function to display the data, printing the original content of \"hello.txt.\"\n\nWhat is the primary purpose of the \"xxd\" command in Linux?\n\nHow can I generate a hexadecimal dump of a binary file using \"xxd\"?\n\nCan I convert a hexadecimal dump back into binary data with \"xxd\"?\n\nWhat is the significance of the hexadecimal addresses displayed on the left side of the \"xxd\" output?\n\nCan \"xxd\" be used to analyze non-binary files, such as text files or images?\n\nWhat is the purpose of the \"-i\" option in \"xxd\"?\n\nThe \"xxd\" command in Linux is a versatile tool that allows users to work with binary data easily. Whether you need to analyze binary files, edit them with a text editor, or convert between hexadecimal dumps and binary data, \"xxd\" provides a valuable solution. Understanding and utilizing this command can be a significant asset for anyone dealing with binary data in the Linux environment."
    },
    {
        "link": "https://simplilearn.com/xxd-command-in-linux-article",
        "document": ""
    },
    {
        "link": "https://linux.die.net/man/1/xxd",
        "document": ""
    },
    {
        "link": "https://tutorialspoint.com/unix_commands/xxd.htm",
        "document": "- make a hexdump or do the reverse.-h[elp][options] [infile [outfile]]-r[evert] [options] [infile [outfile]]creates a hex dump of a given file or standard input. It can also convert a hex dump back to its original binary form. Like(1) and(1) it allows the transmission of binary data in a mail-safe ASCII representation, but has the advantage of decoding to standard output. Moreover, it can be used to perform binary file patching.If nois given, standard input is read. Ifis specified as a ` character, then input is taken from standard input. If nois given (or a ` character is in its place), results are sent to standard output.\n\nNote that a \"lazy\" parser is used which does not check for more than the first option letter, unless the option is followed by a parameter. Spaces between a single option letter and its parameter are optional. Parameters to options can be specified in decimal, hexadecimal or octal notation. Thus -c8, -c 8, -c 010 and -cols 8 are all equivalent.\n\nxxd -r has some builtin magic while evaluating line number information. If the output file is seekable, then the linenumbers at the start of each hexdump line may be out of order, lines may be missing, or overlapping. In these cases xxd will lseek(2) to the next position. If the output file is not seekable, only gaps are allowed, which will be filled by null-bytes.\n\nWhen editing hexdumps, please note that xxd -r skips everything on the input line after reading enough columns of hexadecimal data (see option -c). This also means, that changes to the printable ascii (or ebcdic) columns are always ignored. Reverting a plain (or postscript) style hexdump with xxd -r -p does not depend on the correct number of columns. Here anything that looks like a pair of hex-digits is interpreted.\n\nNote the difference between \n\n % xxd -i file \n\n and \n\n % xxd -i < file\n\nxxd -s +seek may be different from xxd -s seek, as lseek(2) is used to \"rewind\" input. A + makes a difference if the input source is stdin, and if stdins file position is not at the start of the file by the time xxd is started and given its input. The following examples may help to clarify (or further confuse!)...\n\nRewind stdin before reading; needed because the cat has already read to the end of stdin. \n\n % sh -c \"cat > plain_copy; xxd -s 0 > hex_copy\" < file\n\nHexdump from file position 0x480 (=1024+128) onwards. The + sign means \"relative to the current position\", thus the 128 adds to the 1k where dd left off. \n\n % sh -c \"dd of=plain_snippet bs=1k count=1; xxd -s +128 > hex_snippet\" < file\n\nHexdump from file position 0x100 ( = 1024-768) on. \n\n % sh -c \"dd of=plain_snippet bs=1k count=1; xxd -s +-768 > hex_snippet\" < file\n\nHowever, this is a rare situation and the use of + is rarely needed. The author prefers to monitor the effect of xxd with strace(1) or truss(1), whenever -s is used.\n\nPrint everything but the first three lines (hex 0x30 bytes) of file. \n\n % xxd -s 0x30 file\n\nPrint 3 lines (hex 0x30 bytes) from the end of file. \n\n % xxd -s -0x30 file\n\nPrint 120 bytes as continuous hexdump with 40 octets per line. \n\n % xxd -l 120 -ps -c 20 xxd.1 \n\n 2e54482058584420312022417567757374203139 \n\n 39362220224d616e75616c207061676520666f72 \n\n 20787864220a2e5c220a2e5c222032317374204d \n\n 617920313939360a2e5c22204d616e2070616765 \n\n 20617574686f723a0a2e5c2220202020546f6e79 \n\n 204e7567656e74203c746f6e79407363746e7567\n\nHexdump the first 120 bytes of this man page with 12 octets per line. \n\n % xxd -l 120 -c 12 xxd.1 \n\n 0000000: 2e54 4820 5858 4420 3120 2241 .TH XXD 1 \"A \n\n 000000c: 7567 7573 7420 3139 3936 2220 ugust 1996\" \n\n 0000018: 224d 616e 7561 6c20 7061 6765 \"Manual page \n\n 0000024: 2066 6f72 2078 7864 220a 2e5c for xxd\"..\\ \n\n 0000030: 220a 2e5c 2220 3231 7374 204d \"..\\\" 21st M \n\n 000003c: 6179 2031 3939 360a 2e5c 2220 ay 1996..\\\" \n\n 0000048: 4d61 6e20 7061 6765 2061 7574 Man page aut \n\n 0000054: 686f 723a 0a2e 5c22 2020 2020 hor:..\\\" \n\n 0000060: 546f 6e79 204e 7567 656e 7420 Tony Nugent \n\n 000006c: 3c74 6f6e 7940 7363 746e 7567 <tony@sctnug\n\nDisplay just the date from the file xxd.1 \n\n % xxd -s 0x36 -l 13 -c 13 xxd.1 \n\n 0000036: 3231 7374 204d 6179 2031 3939 36 21st May 1996\n\nCopy input_file to output_file and prepend 100 bytes of value 0x00. \n\n % xxd input_file | xxd -r -s 100 > output_file\n\nPatch the date in the file xxd.1 \n\n % echo \"0000037: 3574 68\" | xxd -r - xxd.1 \n\n % xxd -s 0x36 -l 13 -c 13 xxd.1 \n\n 0000036: 3235 7468 204d 6179 2031 3939 36 25th May 1996\n\nCreate a 65537 byte file with all bytes 0x00, except for the last one which is A (hex 0x41). \n\n % echo \"010000: 41\" | xxd -r > file\n\nHexdump this file with autoskip. \n\n % xxd -a -c 12 file \n\n 0000000: 0000 0000 0000 0000 0000 0000 ............ \n\n * \n\n 000fffc: 0000 0000 40 ....A\n\nCreate a 1 byte file containing a single A character. The number after -r -s adds to the linenumbers found in the file; in effect, the leading bytes are suppressed. \n\n % echo \"010000: 41\" | xxd -r -s -0x10000 > file\n\nUse xxd as a filter within an editor such as vim(1) to hexdump a region marked between a and z. \n\n :a,z!xxd\n\nUse xxd as a filter within an editor such as vim(1) to recover a binary hexdump marked between a and z. \n\n :a,z!xxd -r\n\nUse xxd as a filter within an editor such as vim(1) to recover one line of a hexdump. Move the cursor over the line and type: \n\n !!xxd -r\n\nThe following error values are returned:The tools weirdness matches its creators brain. Use entirely at your own risk. Copy files. Trace it. Become a wizard.This manual page documents xxd version 1.7(c) 1990-1997 by Juergen Weigert\n\nDistribute freely and credit me, \n\n make money and share with me, \n\n lose money and dont ask me.\n\nManual page started by Tony Nugent \n\n <tony@sctnugen.ppp.gu.edu.au> <T.Nugent@sct.gu.edu.au> \n\n Small changes by Bram Moolenaar. Edited by Juergen Weigert."
    },
    {
        "link": "https://stackoverflow.com/questions/7826526/transform-hexadecimal-information-to-binary-using-a-linux-command",
        "document": "I have this binary file on my Linux system...\n\nUsing the hexdump command, I see its information like this:\n\nNow I am given a file on some other system whose contents are like this:\n\nAnd I need to find out that same exact binary information from this hexdump.\n\nHow can I proceed for that?\n\nIf there isn't any switch for that then C code will also work fine.\n\nThe binary information in the file is output of an encryption algorithm, so contents should exactly match..."
    },
    {
        "link": "https://unix.stackexchange.com/questions/279505/convert-hexadecimal-to-binary-on-linux-cli",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://unix.stackexchange.com/questions/82561/convert-a-hex-string-to-binary-and-send-with-netcat",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://geeksforgeeks.org/xxd-command-in-linux",
        "document": "xxd is a command-line tool that is primarily used for creating and analyzing hexadecimal dumps from files. It can also be used to reverse the process and convert a hexadecimal dump back into binary form. In this article, let's uncover the practical applications of the \"xxd\" command in the Linux ecosystem.\n\nA hexadecimal dump, often called a hex dump, is a representation of binary data in a human-readable format using hexadecimal notation. Each byte of binary data is displayed as a pair of hexadecimal digits, making it easier to understand the data.\n\nHere's an example of the phrase \"How are you\" in a hexadecimal dump:\n\nHere, \"48\" represents 'H,' \"6f\" represents 'o,' and so on.\n\nWhile most Linux distributions come with the \"xxd\" command pre-installed, if you encounter an error when attempting to use it, you may need to install it based on your specific distribution.\n\nHere's a table that summarizes some of the most common options of the \"xxd\" command and their descriptions:\n\nTo create a hexadecimal dump of a file, you can use the following command:\n\nThe binary output on the left side represents a hexadecimal memory address or offset, which indicates the position of each line's data in memory or a binary file, then there are two columns:\n• The right column contains the hexadecimal representation of the binary data.\n\nHere we can see, that the hexadecimal representation for 'H' is 48, for 'e' it is 65, the and so on.\n\nWe can store the generated hexadecimal dump using the redirection operator '>', type the following command:\n\nHere, the hexadecimal dump from standard output is stored in a file named hexdump.txt using the the redirection operator.\n\nThe hexadecimal dump was saved in a file called \"hexdump.txt,\" and we used the '-r' option to reverse this process, converting the hex dump back into its original format. The resulting data has been stored in a file named \"reversed.txt.\"\n\nThe xxd command allows you to specify an offset, effectively skipping a certain number of lines or bytes in the input file when generating a hexadecimal dump.\n\n\n\nHere, xxd skipped 5 bytes of the word 'Hello' and generated a hexadecimal dump for the remaining text.\n\nThe \"xxd -s\" option allows you to specify an offset or skip a certain number of bytes at the beginning of a file when generating a hexadecimal dump.\n\nBy using the '-' operator in the offset, the resulting hexadecimal dump is generated for the last 5 bytes of the file.\n\nThe \"xxd -l\" option permits you to limit the number of bytes processed or displayed when generating a hexadecimal dump.\n\nWe are generating a hex dump of the the first 20 bytes (0x14 is hexadecimal equivalent of 20).\n\nHere's another example where we skip lines in the hexadecimal dump by specifying offsets like 0x10 (which is equivalent to 16 in decimal) and 0x20 (equivalent to 32 in decimal). It's the same as skipping bytes, we are just omitting the display of 16 bytes of data per skipped line.\n\nThe -g option allows us to organize the output by grouping a certain number of bytes.\n\nHere, we have generated a hexadecimal dump with 4 bytes per group.\n\nLimiting the number of columns (-c)\n\nWe can use the -c option to limit the number of columns per line in the output dump.\n\nHere, we are limiting the output to 5 columns per line, you can use 0x05 instead of 5 to get the same output.\n\nFor example: To display the first 20 bytes of the file the commands can be:\n\nHere, the number of bytes is 20 in decimal, 0x14 in hexadecimal, and 024 in octal.\n\nInstead of generating a hexadecimal dump, the use of the \"-b\" option allows us to create a dump that represents the binary digits of the data.\n\nThe above binary dump, generated using the -b option, shows that the character 'H' is converted to the binary sequence '01001000', the character 'e' is converted to the binary sequence '01100101', and so on.\n\nThe \"xxd -ps\" option is used to generate a hexadecimal postscript-style dump, also known as plain hexdump style. It provides a specific output format where the bytes are displayed continuously without line breaks, suitable for certain applications or requirements.\n\nThe \"xxd -u\" option in the xxd command is used to specify that the hexadecimal output should use uppercase characters instead of the default lowercase characters.\n\nWhile the primary purpose of xxd is to create hexadecimal dumps, xxd -i takes it a step further by generating a C include file that contains the binary data as an array.\n\nThe generated output.c file includes an array with the binary data from hello.txt. For example, you might get something like this in output.c:\n• unsigned char hello_txt[] is an array of unsigned characters, which represents the binary data of hello.txt.\n• None The array is initialized with a list of hexadecimal values Each hexadecimal value represents a byte of data 0x prefix denoting a hexadecimal number . The values correspond to the ASCII codes of the characters in \"hello.txt.\"\n• unsigned int hello_txt_len is an additional variable that stores the length of the array . In this case, it's set to 30, indicating that the array contains 30 bytes of data\n\nNow, you can easily use this array in your C or C++ code, making it convenient for embedding binary data, such as images or other resources, directly into your applications.\n\nC program to utilize the output of xxd -i:\n\nYou can use the generated C code to display the text from hello.txt as follows:\n\nThis C code includes the generated data array hello_txt and its length hello_txt_len. The program iterates through the array and uses the putchar function to display the data, printing the original content of \"hello.txt.\"\n\nWhat is the primary purpose of the \"xxd\" command in Linux?\n\nHow can I generate a hexadecimal dump of a binary file using \"xxd\"?\n\nCan I convert a hexadecimal dump back into binary data with \"xxd\"?\n\nWhat is the significance of the hexadecimal addresses displayed on the left side of the \"xxd\" output?\n\nCan \"xxd\" be used to analyze non-binary files, such as text files or images?\n\nWhat is the purpose of the \"-i\" option in \"xxd\"?\n\nThe \"xxd\" command in Linux is a versatile tool that allows users to work with binary data easily. Whether you need to analyze binary files, edit them with a text editor, or convert between hexadecimal dumps and binary data, \"xxd\" provides a valuable solution. Understanding and utilizing this command can be a significant asset for anyone dealing with binary data in the Linux environment."
    },
    {
        "link": "https://stackoverflow.com/questions/51351081/convert-hex-dump-to-binary-file-use-xxd",
        "document": "It seems that your hex file is not a plain hex file as it has the\"offsets\" listed in the file as well.\n\nxxd will do the correct conversion if you have a plaing hex file without any offset in it.\n\nIf you can generate again your hex file please do it in the plain format, otherwise, you can open this Hex file using notepad++ and delete the entire column with the address."
    }
]