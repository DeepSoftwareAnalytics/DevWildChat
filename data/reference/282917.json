[
    {
        "link": "https://learn.microsoft.com/en-us/windows/win32/api/_tsf",
        "document": "To develop Text Services Framework, you need these headers:\n\nFor programming guidance for this technology, see:"
    },
    {
        "link": "https://learn.microsoft.com/en-us/windows/win32/tsf/language-bar",
        "document": "To support adding an item to the language bar, a text service must implement an object that supports the ITfSource interface and one of the ITfLangBarItem control elements. When the item is installed, the language bar installs an ITfLangBarItemSink sink by calling the item's ITfSource::AdviseSink with IID_ITfLangBarItemSink. The item uses the ITfLangBarItemSink interface to notify the language bar of changes, for example when the item is hidden, shown, enabled, or disabled.\n\nFour types of language bar items can be installed and each of the required interfaces is created from ITfLangBarItem. The following are possible ITfLangBarItem control elements.\n\nA button element can function as any of the following. The function of the button item is determined by the flags set in the dwStyle member of the TF_LANGBARITEMINFO structure in the ITfLangBarItem::GetInfo method.\n\nWhen the user clicks a menu button, the language bar calls ITfLangBarItemButton::InitMenu. The item adds items to the menu using the ITfMenu interface passed to InitMenu.\n\nTo add a submenu to the menu, call ITfMenu::AddMenuItem with TF_LBMENUF_SUBMENU. When this is done, a new ITfMenu object that represents the submenu is returned in the ppMenu parameter of AddMenuItem. This new menu object is used to add items to the submenu.\n\nWhen the user selects an item in the menu, the language bar calls ITfLangBarItemButton::OnMenuSelect with the identifier of the selected menu item.\n\nA text service should add its items to the language bar when its ITfTextInputProcessor::Activate method is called and remove them when its ITfTextInputProcessor::Deactivate is called.\n\nTo add an item to the language bar, the text service obtains an ITfLangBarItemMgr interface by calling ITfThreadMgr::QueryInterface with IID_ITfLangBarItemMgr. The text service then calls ITfLangBarItemMgr::AddItem with the pointer to the language bar item object.\n\nThe text service must remove the item when deactivated. The text service either uses the same ITfLangBarItemMgr interface used to add the items or obtains another instance of the interface. The text service then calls ITfLangBarItemMgr::RemoveItem with the interface pointer of the item to remove.\n\nTSF provides the ability to add menu items to existing language bar menus. This enables a text service to add items to the menu of another text service without having to add a separate button to the toolbar. This also enables the menu items to be organized into logical groups. For example, a text service that provides additional features to the standard speech text service can add items to the speech text service menu rather than adding its own top-level menu button.\n\nA text service provides a language bar menu extension by implementing an object that supports the ITfSystemLangBarItemSink interface. This interface works exactly like the ITfLangBarItemButton interface for a menu button. When the menu is displayed, the text service being extended calls ITfSystemLangBarItemSink::InitMenu. The extension adds items to the menu using the ITfMenu interface passed to InitMenu. When the user selects an item added by the extension, the text service being extended calls ITfSystemLangBarItemSink::OnMenuSelect with the identifier of the selected menu item.\n\nTo install a language bar menu extension, the text service completes the following steps.\n• Obtain the ITfLangBarItem interface for the item to extend by calling ITfLangBarItemMgr::GetItem with the GUID for the item to be extended.\n• Obtain the ITfSource interface for the item to extend by calling ITfLangBarItem::QueryInterface with IID_ITfSource.\n• Call ITfSource::AdviseSink with IID_ITfSystemLangBarItemSink and the pointer to the ITfSystemLangBarItemSink object. If ITfSource::AdviseSink fails, the text service does not support menu extensions.\n\nA text service can enable other text services to add items to its language bar menus as shown above. The text service that must publish its GUID so that the item can be obtained by calling ITfLangBarItemMgr::GetItem.\n\nTo support menu extensions, the text service must support the ITfSource interface. The following steps enable support for one or more menu extensions.\n• When ITfSource::AdviseSink with IID_ITfSystemLangBarItemSink is called, the text service must store the ITfSystemLangBarItemSink interface and return a cookie value that will identify the extension.\n• When ITfLangBarItemButton::InitMenu is called, the text service calls the extension's ITfSystemLangBarItemSink::InitMenu method. The text service must implement a way to identify the menu items added by the extension as opposed to the items added by the text service itself.\n• When ITfLangBarItemButton::OnMenuSelect is called with a menu item identifier that belongs to an extension, the text service calls the extensions's ITfSystemLangBarItemSink::OnMenuSelect method.\n• When ITfSource::UnadviseSink is called with the appropriate cookie, the text service removes the menu extension."
    },
    {
        "link": "https://github.com/MicrosoftDocs/win32/blob/docs/desktop-src/TSF/language-bar.md",
        "document": "To support adding an item to the language bar, a text service must implement an object that supports the ITfSource interface and one of the ITfLangBarItem control elements. When the item is installed, the language bar installs an ITfLangBarItemSink sink by calling the item's ITfSource::AdviseSink with IID_ITfLangBarItemSink. The item uses the ITfLangBarItemSink interface to notify the language bar of changes, for example when the item is hidden, shown, enabled, or disabled.\n\nFour types of language bar items can be installed and each of the required interfaces is created from ITfLangBarItem. The following are possible ITfLangBarItem control elements.\n\nA button element can function as any of the following. The function of the button item is determined by the flags set in the dwStyle member of the TF_LANGBARITEMINFO structure in the ITfLangBarItem::GetInfo method.\n\nWhen the user clicks a menu button, the language bar calls ITfLangBarItemButton::InitMenu. The item adds items to the menu using the ITfMenu interface passed to InitMenu.\n\nTo add a submenu to the menu, call ITfMenu::AddMenuItem with TF_LBMENUF_SUBMENU. When this is done, a new ITfMenu object that represents the submenu is returned in the ppMenu parameter of AddMenuItem. This new menu object is used to add items to the submenu.\n\nWhen the user selects an item in the menu, the language bar calls ITfLangBarItemButton::OnMenuSelect with the identifier of the selected menu item.\n\nA text service should add its items to the language bar when its ITfTextInputProcessor::Activate method is called and remove them when its ITfTextInputProcessor::Deactivate is called.\n\nTo add an item to the language bar, the text service obtains an ITfLangBarItemMgr interface by calling ITfThreadMgr::QueryInterface with IID_ITfLangBarItemMgr. The text service then calls ITfLangBarItemMgr::AddItem with the pointer to the language bar item object.\n\nThe text service must remove the item when deactivated. The text service either uses the same ITfLangBarItemMgr interface used to add the items or obtains another instance of the interface. The text service then calls ITfLangBarItemMgr::RemoveItem with the interface pointer of the item to remove.\n\nTSF provides the ability to add menu items to existing language bar menus. This enables a text service to add items to the menu of another text service without having to add a separate button to the toolbar. This also enables the menu items to be organized into logical groups. For example, a text service that provides additional features to the standard speech text service can add items to the speech text service menu rather than adding its own top-level menu button.\n\nA text service provides a language bar menu extension by implementing an object that supports the ITfSystemLangBarItemSink interface. This interface works exactly like the ITfLangBarItemButton interface for a menu button. When the menu is displayed, the text service being extended calls ITfSystemLangBarItemSink::InitMenu. The extension adds items to the menu using the ITfMenu interface passed to InitMenu. When the user selects an item added by the extension, the text service being extended calls ITfSystemLangBarItemSink::OnMenuSelect with the identifier of the selected menu item.\n\nTo install a language bar menu extension, the text service completes the following steps.\n• Obtain the ITfLangBarItem interface for the item to extend by calling ITfLangBarItemMgr::GetItem with the GUID for the item to be extended.\n• Obtain the ITfSource interface for the item to extend by calling ITfLangBarItem::QueryInterface with IID_ITfSource.\n• Call ITfSource::AdviseSink with IID_ITfSystemLangBarItemSink and the pointer to the ITfSystemLangBarItemSink object. If ITfSource::AdviseSink fails, the text service does not support menu extensions.\n\nA text service can enable other text services to add items to its language bar menus as shown above. The text service that must publish its GUID so that the item can be obtained by calling ITfLangBarItemMgr::GetItem.\n\nTo support menu extensions, the text service must support the ITfSource interface. The following steps enable support for one or more menu extensions.\n• When ITfSource::AdviseSink with IID_ITfSystemLangBarItemSink is called, the text service must store the ITfSystemLangBarItemSink interface and return a cookie value that will identify the extension.\n• When ITfLangBarItemButton::InitMenu is called, the text service calls the extension's ITfSystemLangBarItemSink::InitMenu method. The text service must implement a way to identify the menu items added by the extension as opposed to the items added by the text service itself.\n• When ITfLangBarItemButton::OnMenuSelect is called with a menu item identifier that belongs to an extension, the text service calls the extensions's ITfSystemLangBarItemSink::OnMenuSelect method.\n• When ITfSource::UnadviseSink is called with the appropriate cookie, the text service removes the menu extension."
    },
    {
        "link": "https://learn.microsoft.com/en-us/windows/win32/tsf/text-services-framework",
        "document": "Microsoft Windows Text Services Framework (TSF) is a system service available as a redistributable for Windows. TSF provides a simple and scalable framework for the delivery of advanced text input and natural language technologies. TSF can be enabled in applications, or as a TSF text service. A TSF text service provides multilingual support and delivers text services such as keyboard processors, handwriting recognition, and speech recognition.\n\nText Services Framework is applicable for Windows-based computers using text services and Windows XP or later versions of the operating system.\n\nText Services Framework is designed for use by Component Object Model (COM) programmers using the C/C++ programming languages. Programmers should be familiar with text services for Windows-based computers. Knowledge of handwriting recognition, speech recognition, and programming for multilingual support is recommended.\n\nFor the latest redistributable, download the Windows 10 platform SDK.\n\nFor more information about the requirements of specific API elements, see the Requirements section in the TFS reference documentation.\n\nWhat You Should Know Before Reading This Guide\n\nFor the purposes of the Text Services Framework Help, the term \"application\" refers to a TSF-enabled application, the term \"text service\" refers to a TSF text service, and the term \"manager\" refers to the TSF manager. Each term applies as stated herein unless otherwise specified. Text service providers should provide digital signatures with their binary executables."
    },
    {
        "link": "https://learn.microsoft.com/en-us/windows/win32/tsf/text-services-framework-interfaces",
        "document": "This browser is no longer supported.\n\nUpgrade to Microsoft Edge to take advantage of the latest features, security updates, and technical support."
    },
    {
        "link": "https://stackoverflow.com/questions/172942/implementation-of-isupporterrorinfo-what-does-it-mean",
        "document": "My understanding of it (based on some related MSDN pages) is that by implementing , you are indicating that one or more interfaces on your class returns error information by calling , as opposed to just returning a failure .\n\nTo that end, your implementation of should return only for those interfaces on your class that actually use to return error information to the caller, and only those interfaces.\n\nFor example, say you have a class that implements an interface you wrote called that has a method. If someone else creates an instance of your class and calls , they are supposed to do the following if returns a failure (paraphrasing from various MSDN pages, but I started from here: http://msdn.microsoft.com/en-us/library/ms221510.aspx):\n• None Call on the pointer to get the interface for the object that is implementing\n• None If the called object doesn't implement , then the caller will have to handle the error based on the value, or pass it up the call stack.\n• None If the called object does implement , then the caller should call , passing in a for the interface that returned the error. In this case, the method of the interface returned an error, so you would pass (assuming it's defined) to .\n• None If returns , then the caller knows at this point that it can retrieve more detailed information about the error by calling . If returns , the caller can assume the called interface doesn't supply detailed error information, and will have to rely on the returned HRESULT to figure out what happened.\n\nThe reason for this somewhat confusing/convoluted error-handling API seems to be for flexibility (as far I as I can tell anyway. This is COM after all ;). With this design, a class can support multiple interfaces, but not every interface is required to use to return error information from its methods. You can have certain, select interfaces on your class return detailed error information via , while other interfaces can continue to use normal s to indicate errors.\n\nIn summary, the interface is a way to inform the calling code that at least one of the interfaces your class implements can return detailed error information, and the method tells the caller whether a given interface is one of those interfaces. If so, then the caller can retrieve the detailed error information by calling ."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.exception.hresult?view=net-9.0",
        "document": "Some information relates to prerelease product that may be substantially modified before it’s released. Microsoft makes no warranties, express or implied, with respect to the information provided here.\n\nThe following code example defines a derived class that sets the property to a custom value in its constructor.\n\nHRESULT is a 32-bit value, divided into three different fields: a severity code, a facility code, and an error code. The severity code indicates whether the return value represents information, warning, or error. The facility code identifies the area of the system responsible for the error. The error code is a unique number that is assigned to represent the exception. Each exception is mapped to a distinct HRESULT. When managed code throws an exception, the runtime passes the HRESULT to the COM client. When unmanaged code returns an error, the HRESULT is converted to an exception, which is then thrown by the runtime. For information about HRESULT values and their corresponding .NET Framework exceptions, see How to: Map HRESULTs and Exceptions. See Common HRESULT Values in the Windows documentation for a list of the values you are most likely to encounter.\n\nStarting with the .NET Framework 4.5, the HResult property's setter is protected, whereas its getter is public. In previous versions of the .NET Framework, both getter and setter are protected.\n• How to: Map HRESULTs and Exceptions"
    },
    {
        "link": "https://stackoverflow.com/questions/9415257/how-can-i-implement-static-methods-on-an-interface",
        "document": "I have a 3rd party C++ DLL that I call from C#. The methods are static. I want to abstract it out to do some unit testing so I created an interface with the static methods in it but now my program errors with: The modifier 'static' is not valid for this item MyMethod cannot be accessed with an instance reference; qualify it with a type name instead How can I achieve this abstraction?"
    },
    {
        "link": "https://learn.microsoft.com/en-us/visualstudio/ide/reference/implement-interface?view=vs-2022",
        "document": "What: Lets you immediately generate the code required to implement an interface.\n\nWhen: You want to inherit from an interface.\n\nWhy: You could manually implement all interface one-by-one, however this feature will generate all method signatures automatically.\n• None Place your cursor on the line where there is a red squiggle that indicates you have referenced an interface, but have not implemented all required members.\n• None Next, do one of the following:\n• Keyboard\n• Press Ctrl+. to trigger the Quick Actions and Refactorings menu.\n• Mouse\n• Right-click and select the Quick Actions and Refactorings menu.\n• Hover over the red squiggle and click the icon that appears.\n• Click the icon that appears in the left margin if the text cursor is already on the line with the red squiggle.\n• \n• Use the Preview changes link at the bottom of the preview window to see all of the changes that will be made before making your selection.\n• Use the Document, Project, and Solution links at the bottom of the preview window to create the proper method signatures across multiple classes that implement the interface. The interface's method signatures is created, and is ready to be implemented. (C# only) Use the Implement interface explicitly option to preface each generated method with the interface name to avoid name collisions."
    },
    {
        "link": "https://softwareengineering.stackexchange.com/questions/237631/how-to-enforce-implementation-of-interface-to-behave-a-certain-way",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    }
]