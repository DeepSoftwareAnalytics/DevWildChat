[
    {
        "link": "https://stackoverflow.com/questions/19234209/perl-subroutine-arguments",
        "document": "You are wary of the Perl environment because it is quite different from the languages you have come across before.\n\nThe people who believe in strong typing and function prototypes will disagree here, but I believe that restrictions like that are rarely useful. Has C really caught you passing the wrong number of parameters to a function often enough to be useful?\n\nIt is most common in modern Perl to copy the contents of to a list of lexical scalar variables, so you will often see subroutines starting with\n\nthat way, all parameters that are passed will be available as elements of ( , etc.) while the expected ones are named and appear in and (although I hope you understand that those names should be chosen appropriately).\n\nIn the particular case that the subroutine is a method, the first parameter is special. In other languages it is or , but in Perl it is simply the first parameter in and you may call it what you like. In those circumstances you would see\n\nso that the context object (or the name of the class if it is a class method) is extracted into (a name assumed by convention) and the rest of the parameters remain in to be accessed either directly or, more usually, copied to local scalar variables as , etc.\n\nMost often the complaint is that there is no type checking either, so I can pass any scalar I like as a subroutine parameter. As long as and are in context, even this is generally simple to debug, simply because the operations that the subroutine can perform on one form of scalar are usually illegal on another.\n\nAlthough it was originally more to do with encapsulation with respect to object-oriented Perl, this quote from Larry Wall is very relevant\n\nC was designed and implemented in the days when it was a major efficiency boost if you could get a faulty program to fail during compilation rather than at run time. That has changed now, although a similar situation has arisen with client-side JavaScript where it actually would be useful to know that the code is wrong before fetching the data from the internet that it has to deal with. Sadly, JavaScript parameter checking is now looser than it should be.\n\nFor those who doubt the usefulness of Perl for teaching purposes, I suggest that it is precisely because Perl's mechanisms are so simple and direct that they are ideal for such purposes.\n• None When you call a Perl subroutine all of the parameters in the call are aliased in . You can use them directly to affect the actual parameters, or copy them to prevent external action\n• None If you call a Perl subroutine as a method then the calling object or class is provided as the first parameter. Again, the subroutine (method) can do what it likes with"
    },
    {
        "link": "https://perldoc.perl.org/perlsub",
        "document": "\n• DESCRIPTION\n• Lexical Subroutines\n• state sub vs my sub\n• When to Still Use local()\n\nTo define an anonymous subroutine at runtime:\n\nLike many languages, Perl provides for user-defined subroutines. These may be located anywhere in the main program, loaded in from other files via the , , or keywords, or generated on the fly using or anonymous subroutines. You can even call a function indirectly using a variable containing its name or a CODE reference.\n\nThe Perl model for function call and return values is simple: all functions are passed as parameters one single flat list of scalars, and all functions likewise return to their caller one single flat list of scalars. Any arrays or hashes in these call and return lists will collapse, losing their identities--but you may always use pass-by-reference instead to avoid this. Both call and return lists may contain as many or as few scalar elements as you'd like. (Often a function without an explicit return statement is called a subroutine, but there's really no difference from Perl's perspective.)\n\nIn a subroutine that uses signatures (see \"Signatures\" below), arguments are assigned into lexical variables introduced by the signature. In the current implementation of Perl they are also accessible in the array in the same way as for non-signature subroutines, but accessing them in this manner is now discouraged inside such a signature-using subroutine.\n\nIn a subroutine that does not use signatures, any arguments passed in show up in the array . Therefore, if you called a function with two arguments, those would be stored in and . The array is a local array, but its elements are aliases for the actual scalar parameters. In particular, if an element is updated, the corresponding argument is updated (or an error occurs if it is not updatable). If an argument is an array or hash element which did not exist when the function was called, that element is created only when (and if) it is modified or a reference to it is taken. (Some earlier versions of Perl created the element whether or not the element was assigned to.) Assigning to the whole array removes that aliasing, and does not update any arguments.\n\nWhen not using signatures, Perl does not otherwise provide a means to create named formal parameters. In practice all you do is assign to a list of these. Variables that aren't declared to be private are global variables. For gory details on creating private variables, see \"Private Variables via my()\" and \"Temporary Values via local()\". To create protected environments for a set of functions in a separate package (and probably a separate file), see \"Packages\" in perlmod.\n\nA statement may be used to exit a subroutine, optionally specifying the returned value, which will be evaluated in the appropriate context (list, scalar, or void) depending on the context of the subroutine call. If you specify no return value, the subroutine returns an empty list in list context, the undefined value in scalar context, or nothing in void context. If you return one or more aggregates (arrays and hashes), these will be flattened together into one large indistinguishable list.\n\nIf no is found and if the last statement is an expression, its value is returned. If the last statement is a loop control structure like a or a , the returned value is unspecified. The empty sub returns the empty list.\n\nAssigning to a list of private variables to name your arguments:\n\nBecause the assignment copies the values, this also has the effect of turning call-by-reference into call-by-value. Otherwise a function is free to do in-place modifications of and change its caller's values.\n\nYou aren't allowed to modify constants in this way, of course. If an argument were actually literal and you tried to change it, you'd take a (presumably fatal) exception. For example, this won't work:\n\nIt would be much safer if the function were written to return a copy of its parameters instead of changing them in place:\n\nNotice how this (unprototyped) function doesn't care whether it was passed real scalars or arrays. Perl sees all arguments as one big, long, flat parameter list in . This is one area where Perl's simple argument-passing style shines. The function would work perfectly well without changing the definition even if we fed it things like this:\n\nDo not, however, be tempted to do this:\n\nLike the flattened incoming parameter list, the return list is also flattened on return. So all you have managed to do here is stored everything in and made empty. See \"Pass by Reference\" for alternatives.\n\nA subroutine may be called using an explicit prefix. The is optional in modern Perl, as are parentheses if the subroutine has been predeclared. The is not optional when just naming the subroutine, such as when it's used as an argument to defined() or undef(). Nor is it optional when you want to do an indirect subroutine call with a subroutine name or reference using the or constructs, although the notation solves that problem. See perlref for more about all that.\n\nSubroutines may be called recursively. If a subroutine is called using the form, the argument list is optional, and if omitted, no array is set up for the subroutine: the array at the time of the call is visible to subroutine instead. This is an efficiency mechanism that new users may wish to avoid.\n\nNot only does the form make the argument list optional, it also disables any prototype checking on arguments you do provide. This is partly for historical reasons, and partly for having a convenient way to cheat if you know what you're doing. See \"Prototypes\" below.\n\nSince Perl 5.16.0, the token is available under and . It will evaluate to a reference to the currently-running sub, which allows for recursive calls without knowing your subroutine's name.\n\nThe behavior of within a regex code block (such as ) is subject to change.\n\nSubroutines whose names are in all upper case are reserved to the Perl core, as are modules whose names are in all lower case. A subroutine in all capitals is a loosely-held convention meaning it will be called indirectly by the run-time system itself, usually due to a triggered event. Subroutines whose name start with a left parenthesis are also reserved the same way. The following is a list of some subroutines that currently do special, pre-defined things.\n\nThe , , , and subroutines are not so much subroutines as named special code blocks, of which you can have more than one in a package, and which you can not call explicitly. See \"BEGIN, UNITCHECK, CHECK, INIT and END\" in perlmod\n\nPerl has a facility to allow a subroutine's formal parameters to be declared by special syntax, separate from the procedural code of the subroutine body. The formal parameter list is known as a signature.\n\nThis facility must be enabled before it can be used. It is enabled automatically by a (or higher) declaration, or more directly by , in the current scope.\n\nThe signature is part of a subroutine's body. Normally the body of a subroutine is simply a braced block of code, but when using a signature, the signature is a parenthesised list that goes immediately before the block, after any name or attributes.\n\nThe signature declares lexical variables that are in scope for the block. When the subroutine is called, the signature takes control first. It populates the signature variables from the list of arguments that were passed. If the argument list doesn't meet the requirements of the signature, then it will throw an exception. When the signature processing is complete, control passes to the block.\n\nPositional parameters are handled by simply naming scalar variables in the signature. For example,\n\ntakes two positional parameters, which must be filled at runtime by two arguments. By default the parameters are mandatory, and it is not permitted to pass more arguments than expected. So the above is equivalent to\n\nAn argument can be ignored by omitting the main part of the name from a parameter declaration, leaving just a bare sigil. For example,\n\nAlthough the ignored argument doesn't go into a variable, it is still mandatory for the caller to pass it.\n\nA positional parameter is made optional by giving a default value, separated from the parameter name by :\n\nThe above subroutine may be called with either one or two arguments. The default value expression is evaluated when the subroutine is called, so it may provide different default values for different calls. It is only evaluated if the argument was actually omitted from the call. For example,\n\nautomatically assigns distinct sequential IDs to things for which no ID was supplied by the caller. A default value expression may also refer to parameters earlier in the signature, making the default for one parameter vary according to the earlier parameters. For example,\n\nA default value expression can also be written using the operator, where it will be evaluated and used if the caller omitted a value or the value provided was .\n\nSimilarly, the operator can be used to provide a default expression to be used whenever the caller provided a false value (and remember that a missing or value are also false).\n\nAn optional parameter can be nameless just like a mandatory parameter. For example,\n\nThe parameter's default value will still be evaluated if the corresponding argument isn't supplied, even though the value won't be stored anywhere. This is in case evaluating it has important side effects. However, it will be evaluated in void context, so if it doesn't have side effects and is not trivial it will generate a warning if the \"void\" warning category is enabled. If a nameless optional parameter's default value is not important, it may be omitted just as the parameter's name was:\n\nOptional positional parameters must come after all mandatory positional parameters. (If there are no mandatory positional parameters then an optional positional parameters can be the first thing in the signature.) If there are multiple optional positional parameters and not enough arguments are supplied to fill them all, they will be filled from left to right.\n\nAfter positional parameters, additional arguments may be captured in a slurpy parameter. The simplest form of this is just an array variable:\n\nWith a slurpy parameter in the signature, there is no upper limit on how many arguments may be passed. A slurpy array parameter may be nameless just like a positional parameter, in which case its only effect is to turn off the argument limit that would otherwise apply:\n\nA slurpy parameter may instead be a hash, in which case the arguments available to it are interpreted as alternating keys and values. There must be as many keys as values: if there is an odd argument then an exception will be thrown. Keys will be stringified, and if there are duplicates then the later instance takes precedence over the earlier, as with standard hash construction.\n\nA slurpy hash parameter may be nameless just like other kinds of parameter. It still insists that the number of arguments available to it be even, even though they're not being put into a variable.\n\nA slurpy parameter, either array or hash, must be the last thing in the signature. It may follow mandatory and optional positional parameters; it may also be the only thing in the signature. Slurpy parameters cannot have default values: if no arguments are supplied for them then you get an empty array or empty hash.\n\nA signature may be entirely empty, in which case all it does is check that the caller passed no arguments:\n\nPrior to Perl 5.36 these were considered experimental, and emitted a warning in the category. From Perl 5.36 onwards this no longer happens, though the warning category still exists for back-compatibility with code that attempts to disable it with a statement such as:\n\nIn the current Perl implementation, when using a signature the arguments are still also available in the special array variable . However, accessing them via this array is now discouraged, and should not be relied upon in newly-written code as this ability may change in a future version. Code that attempts to access the array will produce warnings in the category when compiled:\n\nThere is a difference between the two ways of accessing the arguments: aliases the arguments, but the signature variables get copies of the arguments. So writing to a signature variable only changes that variable, and has no effect on the caller's variables, but writing to an element of modifies whatever the caller used to supply that argument.\n\nThere is a potential syntactic ambiguity between signatures and prototypes (see \"Prototypes\"), because both start with an opening parenthesis and both can appear in some of the same places, such as just after the name in a subroutine declaration. For historical reasons, when signatures are not enabled, any opening parenthesis in such a context will trigger very forgiving prototype parsing. Most signatures will be interpreted as prototypes in those circumstances, but won't be valid prototypes. (A valid prototype cannot contain any alphabetic character.) This will lead to somewhat confusing error messages.\n\nTo avoid ambiguity, when signatures are enabled the special syntax for prototypes is disabled. There is no attempt to guess whether a parenthesised group was intended to be a prototype or a signature. To give a subroutine a prototype under these circumstances, use a prototype attribute. For example,\n\nIt is entirely possible for a subroutine to have both a prototype and a signature. They do different jobs: the prototype affects compilation of calls to the subroutine, and the signature puts argument values into lexical variables at runtime. You can therefore write\n\nThe prototype attribute, and any other attributes, must come before the signature. The signature always immediately precedes the block of the subroutine's body.\n\nWARNING: The use of attribute lists on declarations is still evolving. The current semantics and interface are subject to change. See attributes and Attribute::Handlers.\n\nThe operator declares the listed variables to be lexically confined to the enclosing block, conditional ( / / / ), loop ( / / / / ), subroutine, , or / / 'd file. If more than one value is listed, the list must be placed in parentheses. All listed elements must be legal lvalues. Only alphanumeric identifiers may be lexically scoped--magical built-ins like must currently be ized with instead to limit their scope dynamically.\n\nUnlike global or package variables localized by the operator, lexical variables declared with are totally hidden from the outside world, including any called subroutines. This is true if it's the same subroutine called from itself or elsewhere--every call gets its own copy.\n\nThis doesn't mean that a variable declared in a statically enclosing lexical scope would be invisible. Only dynamic scopes are cut off. For example, the function below has access to the lexical $x variable because both the and the occurred at the same scope, presumably file scope.\n\nAn , however, can see lexical variables of the scope it is being evaluated in, so long as the names aren't hidden by declarations within the itself. See perlref.\n\nThe parameter list to my() may be assigned to if desired, which allows you to initialize your variables. (If no initializer is given for a particular variable, it is created with the undefined value.) Commonly this is used to name input parameters to a subroutine. Examples:\n\nThe is simply a modifier on something you might assign to. So when you do assign to variables in its argument list, doesn't change whether those variables are viewed as a scalar or an array. So\n\nboth supply a list context to the right-hand side, while\n\nsupplies a scalar context. But the following declares only one variable:\n\nThat has the same effect as\n\nThe declared variable is not introduced (is not visible) until after the current statement. Thus,\n\ncan be used to initialize a new $x with the value of the old $x, and the expression\n\nis false unless the old $x happened to have the value .\n\nLexical scopes of control structures are not bounded precisely by the braces that delimit their controlled blocks; control expressions are part of that scope, too. Thus in the loop\n\nthe scope of $line extends from its declaration throughout the rest of the loop construct (including the clause), but not beyond it. Similarly, in the conditional\n\nthe scope of $answer extends from its declaration through the rest of that conditional, including any and clauses, but not beyond it. See \"Simple Statements\" in perlsyn for information on the scope of variables in statements with modifiers.\n\nThe loop defaults to scoping its index variable dynamically in the manner of . However, if the index variable is prefixed with the keyword , or if there is already a lexical by that name in scope, then a new lexical is created instead. Thus in the loop\n\nthe scope of $i extends to the end of the loop, but not beyond it, rendering the value of $i inaccessible within .\n\nSome users may wish to encourage the use of lexically scoped variables. As an aid to catching implicit uses to package variables, which are always global, if you say\n\nthen any variable mentioned from there to the end of the enclosing block must either refer to a lexical variable, be predeclared via or , or else must be fully qualified with the package name. A compilation error results otherwise. An inner block may countermand this with .\n\nA has both a compile-time and a run-time effect. At compile time, the compiler takes notice of it. The principal usefulness of this is to quiet , but it is also essential for generation of closures as detailed in perlref. Actual initialization is delayed until run time, though, so it gets executed at the appropriate time, such as each time through a loop, for example.\n\nVariables declared with are not part of any package and are therefore never fully qualified with the package name. In particular, you're not allowed to try to make a package variable (or other global) lexical:\n\nIn fact, a package or global variable is still accessible using the fully qualified notation even while a lexical of the same name is also visible:\n\nThat will print out and .\n\nYou may declare variables at the outermost scope of a file to hide any such identifiers from the world outside that file. This is similar in spirit to C's static variables when they are used at the file level. To do this with a subroutine requires the use of a closure (an anonymous function that accesses enclosing lexicals). If you want to create a private subroutine that cannot be called from outside that block, it can declare a lexical variable containing an anonymous sub reference:\n\nAs long as the reference is never returned by any function within the module, no outside module can see the subroutine, because its name is not in any package's symbol table. Remember that it's not REALLY called or anything; it's just $secret_version, unqualified and unqualifiable.\n\nThis does not work with object methods, however; all object methods have to be in the symbol table of some package to be found. See \"Function Templates\" in perlref for something of a work-around to this.\n\nThere are two ways to build persistent private variables in Perl 5.10. First, you can simply use the feature. Or, you can use closures, if you want to stay compatible with releases older than 5.10.\n\nBeginning with Perl 5.10.0, you can declare variables with the keyword in place of . For that to work, though, you must have enabled that feature beforehand, either by using the pragma, or by using on one-liners (see feature). Beginning with Perl 5.16, the form does not require the pragma.\n\nThe keyword creates a lexical variable (following the same scoping rules as ) that persists from one subroutine call to the next. If a state variable resides inside an anonymous subroutine, then each copy of the subroutine has its own copy of the state variable. However, the value of the state variable will still persist between calls to the same copy of the anonymous subroutine. (Don't forget that creates a new subroutine each time it is executed.)\n\nFor example, the following code maintains a private counter, incremented each time the gimme_another() function is called:\n\nAnd this example uses anonymous subroutines to create separate counters:\n\nAlso, since is lexical, it can't be reached or modified by any Perl code outside.\n\nWhen combined with variable declaration, simple assignment to variables (as in ) is executed only the first time. When such statements are evaluated subsequent times, the assignment is ignored. The behavior of assignment to declarations where the left hand side of the assignment involves any parentheses is currently undefined.\n\nJust because a lexical variable is lexically (also called statically) scoped to its enclosing block, , or FILE, this doesn't mean that within a function it works like a C static. It normally works more like a C auto, but with implicit garbage collection.\n\nUnlike local variables in C or C++, Perl's lexical variables don't necessarily get recycled just because their scope has exited. If something more permanent is still aware of the lexical, it will stick around. So long as something else references a lexical, that lexical won't be freed--which is as it should be. You wouldn't want memory being free until you were done using it, or kept around once you were done. Automatic garbage collection takes care of this for you.\n\nThis means that you can pass back or save away references to lexical variables, whereas to return a pointer to a C auto is a grave error. It also gives us a way to simulate C's function statics. Here's a mechanism for giving a function private variables with both lexical scoping and a static lifetime. If you do want to create something like C's static variables, just enclose the whole function in an extra block, and put the static variable outside the function but in the block.\n\nIf this function is being sourced in from a separate file via or , then this is probably just fine. If it's all in the main program, you'll need to arrange for the to be executed early, either by putting the whole block above your main program, or more likely, placing merely a code block around it to make sure it gets executed before your program starts to run:\n\nSee \"BEGIN, UNITCHECK, CHECK, INIT and END\" in perlmod about the special triggered code blocks, , , , and .\n\nIf declared at the outermost scope (the file scope), then lexicals work somewhat like C's file statics. They are available to all functions in that same file declared below them, but are inaccessible from outside that file. This strategy is sometimes used in modules to create private variables that the whole module can see.\n\nWARNING: In general, you should be using instead of , because it's faster and safer. Exceptions to this include the global punctuation variables, global filehandles and formats, and direct manipulation of the Perl symbol table itself. is mostly used when the current value of a variable must be visible to called subroutines.\n\nA modifies its listed variables to be \"local\" to the enclosing block, , or --and to any subroutine called from within that block. A just gives temporary values to global (meaning package) variables. It does not create a local variable. This is known as dynamic scoping. Lexical scoping is done with , which works more like C's auto declarations.\n\nSome types of lvalues can be localized as well: hash and array elements and slices, conditionals (provided that their result is always localizable), and symbolic references. As for simple variables, this creates new, dynamically scoped values.\n\nIf more than one variable or expression is given to , they must be placed in parentheses. This operator works by saving the current values of those variables in its argument list on a hidden stack and restoring them upon exiting the block, subroutine, or eval. This means that called subroutines can also reference the local variable, but not the global one. The argument list may be assigned to if desired, which allows you to initialize your local variables. (If no initializer is given for a particular variable, it is created with an undefined value.)\n\nBecause is a run-time operator, it gets executed each time through a loop. Consequently, it's more efficient to localize your variables outside the loop.\n\nA is simply a modifier on an lvalue expression. When you assign to a ized variable, the doesn't change whether its list is viewed as a scalar or an array. So\n\nboth supply a list context to the right-hand side, while\n\nIf you localize a special variable, you'll be giving a new value to it, but its magic won't go away. That means that all side-effects related to this magic still work with the localized value.\n\nThis feature allows code like this to work :\n\nNote, however, that this restricts localization of some values ; for example, the following statement dies, as of Perl 5.10.0, with an error Modification of a read-only value attempted, because the $1 variable is magical and read-only :\n\nOne exception is the default scalar variable: starting with Perl 5.14 will always strip all magic from $_, to make it possible to safely reuse $_ in a subroutine.\n\nWARNING: Localization of tied arrays and hashes does not currently work as described. This will be fixed in a future release of Perl; in the meantime, avoid code that relies on any particular behavior of localising tied arrays or hashes (localising individual elements is still okay). See \"Localising Tied Arrays and Hashes Is Broken\" in perl58delta for more details.\n\ncreates a whole new symbol table entry for the glob in the current package. That means that all variables in its glob slot ($name, @name, %name, &name, and the filehandle) are dynamically reset.\n\nThis implies, among other things, that any magic eventually carried by those variables is locally lost. In other words, saying will not have any effect on the internal value of the input record separator.\n\nIt's also worth taking a moment to explain what happens when you ize a member of a composite type (i.e. an array or hash element). In this case, the element is ized by name. This means that when the scope of the ends, the saved value will be restored to the hash element whose key was named in the , or the array element whose index was named in the . If that element was deleted while the was in effect (e.g. by a from a hash or a of an array), it will spring back into existence, possibly extending an array and filling in the skipped elements with . For instance, if you say\n\nThe behavior of local() on non-existent members of composite types is subject to change in future. The behavior of local() on array elements specified using negative indexes is particularly surprising, and is very likely to change.\n\nYou can use the and constructs to delete a composite type entry for the current block and restore it when it ends. They return the array/hash value before the localization, which means that they are respectively equivalent to\n\nexcept that for those the is scoped to the block. Slices are also accepted.\n\nThis construct is supported since Perl v5.12.\n\nIt is possible to return a modifiable value from a subroutine. To do this, you have to declare the subroutine to return an lvalue.\n\nThe scalar/list context for the subroutine and for the right-hand side of assignment is determined as if the subroutine call is replaced by a scalar. For example, consider:\n\nBoth subroutines here are called in a scalar context, while in:\n\nall the subroutines are called in a list context.\n\nLvalue subroutines are convenient, but you have to keep in mind that, when used with objects, they may violate encapsulation. A normal mutator can check the supplied argument before setting the attribute it is protecting, an lvalue subroutine cannot. If you require any special processing when storing and retrieving the values, consider using the CPAN module Sentinel or something similar.\n\nBeginning with Perl 5.18, you can declare a private subroutine with or . As with state variables, the keyword is only available under or or higher.\n\nPrior to Perl 5.26, lexical subroutines were deemed experimental and were available only under the pragma. They also produced a warning unless the \"experimental::lexical_subs\" warnings category was disabled.\n\nThese subroutines are only visible within the block in which they are declared, and only after that declaration:\n\nThis example fails because refers to the package/global subroutine , not the lexical subroutine currently being defined.\n\nThe solution is to use :\n\nIt is possible to predeclare a lexical subroutine. The subroutine definition syntax respects any previous or declaration. Using this to define recursive subroutines is a bad idea, however:\n\nJust like , this example leaks memory. The name is a reference to the subroutine, and the subroutine uses the name ; they keep each other alive (see \"Circular References\" in perlref).\n\nWhat is the difference between \"state\" subs and \"my\" subs? Each time that execution enters a block when \"my\" subs are declared, a new copy of each sub is created. \"State\" subroutines persist from one execution of the containing block to the next.\n\nSo, in general, \"state\" subroutines are faster. But \"my\" subs are necessary if you want to create closures:\n\nIn this example, a new is created when is called, and also a new , which can see the new . A \"state\" sub will only see the from the first call to .\n\nLike , creates a lexical alias to the package subroutine of the same name.\n\nThe two main uses for this are to switch back to using the package sub inside an inner scope:\n\nand to make a subroutine visible to other packages in the same scope:\n\nWARNING: The mechanism described in this section was originally the only way to simulate pass-by-reference in older versions of Perl. While it still works fine in modern versions, the new reference mechanism is generally easier to work with. See below.\n\nSometimes you don't want to pass the value of an array to a subroutine but rather the name of it, so that the subroutine can modify the global copy of it rather than working with a local copy. In Perl you can refer to all objects of a particular name by prefixing the name with a star: . This is often known as a \"typeglob\", because the star on the front can be thought of as a wildcard match for all the funny prefix characters on variables and subroutines and such.\n\nWhen evaluated, the typeglob produces a scalar value that represents all the objects of that name, including any filehandle, format, or subroutine. When assigned to, it causes the name mentioned to refer to whatever value was assigned to it. Example:\n\nScalars are already passed by reference, so you can modify scalar arguments without using this mechanism by referring explicitly to etc. You can modify all the elements of an array by passing all the elements as scalars, but you have to use the mechanism (or the equivalent reference mechanism) to , , or change the size of an array. It will certainly be faster to pass the typeglob (or reference).\n\nEven if you don't want to modify an array, this mechanism is useful for passing multiple arrays in a single LIST, because normally the LIST mechanism will merge all the array values so that you can't extract out the individual arrays. For more on typeglobs, see \"Typeglobs and Filehandles\" in perldata.\n\n#When to Still Use local()\n\nDespite the existence of , there are still three places where the operator still shines. In fact, in these three places, you must use instead of .\n• None You need to give a global variable a temporary value, especially $_. The global variables, like or the punctuation variables, must be ized with . This block reads in /etc/motd, and splits it up into chunks separated by lines of equal signs, which are placed in . It particular, it's important to ize $_ in any routine that assigns to it. Look out for implicit assignments in conditionals.\n• None You need to create a local file or directory handle or a local function. A function that needs a filehandle of its own must use on a complete typeglob. This can be used to create new symbol table entries: sub ioqueue { local (*READER, *WRITER); # not my! pipe (READER, WRITER) or die \"pipe: $!\"; return (*READER, *WRITER); } ($head, $tail) = ioqueue(); See the Symbol module for a way to create anonymous symbol table entries. Because assignment of a reference to a typeglob creates an alias, this can be used to create what is effectively a local function, or at least, a local alias. { local *grow = \\&shrink; # only until this block exits grow(); # really calls shrink() move(); # if move() grow()s, it shrink()s too } grow(); # get the real grow() again See \"Function Templates\" in perlref for more about manipulating functions by name in this way.\n• None You want to temporarily change just one element of an array or hash. You can ize just one element of an aggregate. Usually this is done on dynamics: But it also works on lexically declared aggregates.\n\nIf you want to pass more than one array or hash into a function--or return them from it--and have them maintain their integrity, then you're going to have to use an explicit pass-by-reference. Before you do that, you need to understand references as detailed in perlref. This section may not make much sense to you otherwise.\n\nHere are a few simple examples. First, let's pass in several arrays to a function and have it all of then, returning a new list of all their former last elements:\n\nHere's how you might write a function that returns a list of keys occurring in all the hashes passed to it:\n\nSo far, we're using just the normal list return mechanism. What happens if you want to pass or return a hash? Well, if you're using only one of them, or you don't mind them concatenating, then the normal calling convention is ok, although a little expensive.\n\nWhere people get into trouble is here:\n\nThat syntax simply won't work. It sets just or and clears the or . Plus the function didn't get passed into two separate arrays or hashes: it got one long list in , as always.\n\nIf you can arrange for everyone to deal with this through references, it's cleaner code, although not so nice to look at. Here's a function that takes two array references as arguments, returning the two array elements in order of how many elements they have in them:\n\nIt turns out that you can actually do this also:\n\nHere we're using the typeglobs to do symbol table aliasing. It's a tad subtle, though, and also won't work if you're using variables, because only globals (even in disguise as s) are in the symbol table.\n\nIf you're passing around filehandles, you could usually just use the bare typeglob, like , but typeglobs references work, too. For example:\n\nIf you're planning on generating new filehandles, you could do this. Notice to pass back just the bare *FH, not its reference.\n\nPerl supports a very limited kind of compile-time argument checking using function prototyping. This can be declared in either the PROTO section or with a prototype attribute. If you declare either of\n\nthen takes arguments exactly like does.\n\nIf subroutine signatures are enabled (see \"Signatures\"), then the shorter PROTO syntax is unavailable, because it would clash with signatures. In that case, a prototype can only be declared in the form of an attribute.\n\nThe function declaration must be visible at compile time. The prototype affects only interpretation of regular calls to the function, where regular is defined as not using the sigil. In other words, if you call it like a built-in function, then it behaves like a built-in function. If you call it like an old-fashioned (perl4) subroutine, then it behaves like an old-fashioned subroutine. It naturally falls out from this rule that prototypes have no influence on subroutine references like or on indirect subroutine calls like or .\n\nMethod calls are not influenced by prototypes either, because the function to be called is indeterminate at compile time, since the exact code called depends on inheritance.\n\nBecause the intent of this feature is primarily to let you define subroutines that work like built-in functions, here are prototypes for some other functions that parse almost exactly like the corresponding built-in.\n\nAny backslashed prototype character represents an actual argument that must start with that character (optionally preceded by , or ), with the exception of , which will accept any scalar lvalue expression, such as or . The value passed as part of will be a reference to the actual argument given in the subroutine call, obtained by applying to that argument.\n\nYou can use the backslash group notation to specify more than one allowed argument type. For example:\n\nwill allow calling myref() as\n\nand the first argument of myref() will be a reference to a scalar, an array, a hash, a subroutine, or a glob.\n\nUnbackslashed prototype characters have special meanings. Any unbackslashed or eats all remaining arguments, and forces list context. An argument represented by forces scalar context. An requires an anonymous subroutine, which, if passed as the first argument, may look like a bare block: It does not require the keyword or a subsequent comma.\n\nA allows the subroutine to accept a bareword, constant, scalar expression, typeglob, or a reference to a typeglob in that slot. The value will be available to the subroutine either as a simple scalar, or (in the latter two cases) as a reference to the typeglob. If you wish to always convert such arguments to a typeglob reference, use Symbol::qualify_to_ref() as follows:\n\nThe prototype is a special alternative to that will act like when given a literal array or hash variable, but will otherwise force scalar context on the argument. This is useful for functions which should accept either a literal array or an array reference as the argument:\n\nWhen using the prototype, your function must check that the argument is of an acceptable type.\n\nA semicolon ( ) separates mandatory arguments from optional arguments. It is redundant before or , which gobble up everything else.\n\nAs the last character of a prototype, or just before a semicolon, a or a , you can use in place of : if this argument is not provided, will be used instead.\n\nNote how the last three examples in the table above are treated specially by the parser. is parsed as a true list operator, is parsed as a true unary operator with unary precedence the same as , and is truly without arguments, just like . That is, if you say\n\nyou'll get , not , which is how it would be parsed without a prototype. If you want to force a unary function to have the same precedence as a list operator, add to the end of the prototype:\n\nThe interesting thing about is that you can generate new syntax with it, provided it's in the initial position:\n\nThat prints . (Yes, there are still unresolved issues having to do with visibility of . I'm ignoring that question for the moment. (But note that if we make lexically scoped, those anonymous subroutines can act like closures... (Gee, is this sounding a little Lispish? (Never mind.))))\n\nAnd here's a reimplementation of the Perl operator:\n\nSome folks would prefer full alphanumeric prototypes. Alphanumerics have been intentionally left out of prototypes for the express purpose of someday in the future adding named, formal parameters. The current mechanism's main goal is to let module writers provide better diagnostics for module users. Larry feels the notation quite understandable to Perl programmers, and that it will not intrude greatly upon the meat of the module, nor make it harder to read. The line noise is visually encapsulated into a small pill that's easy to swallow.\n\nIf you try to use an alphanumeric sequence in a prototype you will generate an optional warning - \"Illegal character in prototype...\". Unfortunately earlier versions of Perl allowed the prototype to be used as long as its prefix was a valid prototype. The warning may be upgraded to a fatal error in a future version of Perl once the majority of offending code is fixed.\n\nIt's probably best to prototype new functions, not retrofit prototyping into older ones. That's because you must be especially careful about silent impositions of differing list versus scalar contexts. For example, if you decide that a function should take just one parameter, like this:\n\nand someone has been calling it with an array or expression returning a list:\n\nThen you've just supplied an automatic in front of their argument, which can be more than a bit surprising. The old which used to hold one thing doesn't get passed in. Instead, now gets passed in a ; that is, the number of elements in . And the gets called in scalar context so instead of a list of words it returns a boolean result and advances . Ouch!\n\nIf a sub has both a PROTO and a BLOCK, the prototype is not applied until after the BLOCK is completely defined. This means that a recursive function with a prototype has to be predeclared for the prototype to take effect, like so:\n\nThis is all very powerful, of course, and should be used only in moderation to make the world a better place.\n\nFunctions with a prototype of are potential candidates for inlining. If the result after optimization and constant folding is either a constant or a lexically-scoped scalar which has no other references, then it will be used in place of function calls made without . Calls made using are never inlined. (See constant for an easy way to declare most constants.)\n\nThe following functions would all be inlined:\n\n(Be aware that the last example was not always inlined in Perl 5.20 and earlier, which did not behave consistently with subroutines containing inner scopes.) You can countermand inlining by using an explicit :\n\nAs alluded to earlier you can also declare inlined subs dynamically at BEGIN time if their body consists of a lexically-scoped scalar which has no other references. Only the first example here will be inlined:\n\nA not so obvious caveat with this (see [RT #79908]) is what happens if the variable is potentially modifiable. For example:\n\nFrom Perl 5.22 onwards this gave a deprecation warning, and from Perl 5.32 onwards it became a run-time error. Previously the variable was immediately inlined, and stopped behaving like a normal lexical variable; so it printed , not .\n\nIf you still want such a subroutine to be inlined (with no warning), make sure the variable is not used in a context where it could be modified aside from where it is declared.\n\nPerl 5.22 also introduced the \"const\" attribute as an alternative. It was initially experimental, but made stable in Perl 5.40. When applied to an anonymous subroutine, it forces the sub to be called when the expression is evaluated. The return value is captured and turned into a constant subroutine:\n\nThe return value of in this example will always be 54321, regardless of later modifications to $x. You can also put any arbitrary code inside the sub, at it will be executed immediately and its return value captured the same way.\n\nIf you really want a subroutine with a prototype that returns a lexical variable you can easily force it to not be inlined by adding an explicit :\n\nThe easiest way to tell if a subroutine was inlined is by using B::Deparse. Consider this example of two subroutines returning , one with a prototype causing it to be inlined, and one without (with deparse output truncated for clarity):\n\nIf you redefine a subroutine that was eligible for inlining, you'll get a warning by default. You can use this warning to tell whether or not a particular subroutine is considered inlinable, since it's different than the warning for overriding non-inlined subroutines:\n\nThe warning is considered severe enough not to be affected by the -w switch (or its absence) because previously compiled invocations of the function will still be using the old value of the function. If you need to be able to redefine the subroutine, you need to ensure that it isn't inlined, either by dropping the prototype (which changes calling semantics, so beware) or by thwarting the inlining mechanism in some other way, e.g. by adding an explicit , as mentioned above:\n\nMany built-in functions may be overridden, though this should be tried only occasionally and for good reason. Typically this might be done by a package attempting to emulate missing built-in functionality on a non-Unix system.\n\nOverriding may be done only by importing the name from a module at compile time--ordinary predeclaration isn't good enough. However, the pragma lets you, in effect, predeclare subs via the import syntax, and these names may then override built-in ones:\n\nTo unambiguously refer to the built-in form, precede the built-in name with the special package qualifier . For example, saying always refers to the built-in , even if the current package has imported some other subroutine called from elsewhere. Even though it looks like a regular function call, it isn't: the prefix in that case is part of Perl's syntax, and works for any keyword, regardless of what is in the package. Taking a reference to it, that is, , only works for some keywords. See CORE.\n\nLibrary modules should not in general export built-in names like or as part of their default list, because these may sneak into someone else's namespace and change the semantics unexpectedly. Instead, if the module adds that name to , then it's possible for a user to import the name explicitly, but not implicitly. That is, they could say\n\nand it would import the override. But if they said\n\nthey would get the default imports without overrides.\n\nThe foregoing mechanism for overriding built-in is restricted, quite deliberately, to the package that requests the import. There is a second method that is sometimes applicable when you wish to override a built-in everywhere, without regard to namespace boundaries. This is achieved by importing a sub into the special namespace . Here is an example that quite brazenly replaces the operator with something that understands regular expressions.\n\nAnd here's how it could be (ab)used:\n\nThe initial comment shows a contrived, even dangerous example. By overriding globally, you would be forcing the new (and subversive) behavior for the operator for every namespace, without the complete cognizance or cooperation of the modules that own those namespaces. Naturally, this should be done with extreme caution--if it must be done at all.\n\nThe example above does not implement all the support needed to cleanly override Perl's operator. The built-in has different behaviors depending on whether it appears in a scalar or list context, but our doesn't. Indeed, many Perl built-ins have such context sensitive behaviors, and these must be adequately supported by a properly written override. For a fully functional example of overriding , study the implementation of in the standard library.\n\nWhen you override a built-in, your replacement should be consistent (if possible) with the built-in native syntax. You can achieve this by using a suitable prototype. To get the prototype of an overridable built-in, use the function with an argument of (see \"prototype\" in perlfunc).\n\nNote however that some built-ins can't have their syntax expressed by a prototype (such as or ). If you override them you won't be able to fully mimic their original syntax.\n\nThe built-ins , and can also be overridden, but due to special magic, their original syntax is preserved, and you don't have to define a prototype for their replacements. (You can't override the syntax, though).\n\nhas special additional dark magic: if you invoke your replacement as , it will actually receive the argument in @_. See \"require\" in perlfunc.\n\nAnd, as you'll have noticed from the previous example, if you override , the glob operator is overridden as well.\n\nIn a similar fashion, overriding the function also overrides the equivalent I/O operator . Also, overriding also overrides the operators and .\n\nFinally, some built-ins (e.g. or ) can't be overridden.\n\nIf you call a subroutine that is undefined, you would ordinarily get an immediate, fatal error complaining that the subroutine doesn't exist. (Likewise for subroutines being used as methods, when the method doesn't exist in any base class of the class's package.) However, if an subroutine is defined in the package or packages used to locate the original subroutine, then that subroutine is called with the arguments that would have been passed to the original subroutine. The fully qualified name of the original subroutine magically appears in the global $AUTOLOAD variable of the same package as the routine. The name is not passed as an ordinary argument because, er, well, just because, that's why. (As an exception, a method call to a nonexistent or method is just skipped instead. Also, if the AUTOLOAD subroutine is an XSUB, there are other ways to retrieve the subroutine name. See \"Autoloading with XSUBs\" in perlguts for details.)\n\nMany routines load in a definition for the requested subroutine using eval(), then execute that subroutine using a special form of goto() that erases the stack frame of the routine without a trace. (See the source to the standard module documented in AutoLoader, for example.) But an routine can also just emulate the routine and never define it. For example, let's pretend that a function that wasn't defined should just invoke with those arguments. All you'd do is:\n\nIn fact, if you predeclare functions you want to call that way, you don't even need parentheses:\n\nA more complete example of this is the Shell module on CPAN, which can treat undefined subroutine calls as calls to external programs.\n\nMechanisms are available to help modules writers split their modules into autoloadable files. See the standard AutoLoader module described in AutoLoader and in AutoSplit, the standard SelfLoader modules in SelfLoader, and the document on adding C functions to Perl code in perlxs.\n\nA subroutine declaration or definition may have a list of attributes associated with it. If such an attribute list is present, it is broken up at space or colon boundaries and treated as though a had been seen. See attributes for details about what attributes are currently supported. Unlike the limitation with the obsolescent , the syntax works to associate the attributes with a pre-declaration, and not just with a subroutine definition.\n\nThe attributes must be valid as simple identifier names (without any punctuation other than the '_' character). They may have a parameter list appended, which is only checked for whether its parentheses ('(',')') nest properly.\n\nExamples of valid syntax (even though the attributes are unknown):\n\nThe attribute list is passed as a list of constant strings to the code which associates them with the subroutine. In particular, the second example of valid syntax above currently looks like this in terms of how it's parsed and invoked:\n\nFor further details on attribute lists and their manipulation, see attributes and Attribute::Handlers.\n\nSee \"Function Templates\" in perlref for more about references and closures. See perlxs if you'd like to learn about calling C subroutines from Perl. See perlembed if you'd like to learn about calling Perl subroutines from C. See perlmod to learn about bundling up your functions in separate files. See perlmodlib to learn what library modules come standard on your system. See perlootut to learn how to make object method calls."
    },
    {
        "link": "https://perl101.org/subroutines.html",
        "document": "A subroutine's arguments come in via the special array. The without an argument defaults to .\n\nYou can also assign arguments en masse with list assignment:\n\nIn some cases, but we hope very few, you can access arguments directly in the array.\n\nThe arguments passed to a subroutine are aliases to the real arguments.\n\nThis can be good if you want it to be:\n\nYou can pass any anything to a subroutine that you want.\n\nOnly the first argument is used by the function. For that matter, you can call the function with any number of arguments, even no arguments:\n\nThe module Params::Validate solves many of these validation problems.\n\nSomewhere along the way, prototypes got added, so you can do things like this:\n\nHowever, don't use them. They don't work on objects, and they require that the subroutines be declared before they're called. They're a nice idea, but just not practical.\n\nMake things happen at compile time with the block\n\nis a special type of code block. It allows programmers to execute code during Perl's compile phase, allowing for initializations and other things to happen.\n\nPerl uses any time you a module; the following two statements are equivalent:\n\nPass in arrays and hashes as references\n\nRemember that the parameters passed into a subroutine are passed as one big array. If you do something like the following:\n\nThen what's passed in to is the list\n\nInside , how can you tell where the stooges end and the sandwiches begin? You can't. If you try this:\n\nthen all six elements go into and gets nothing.\n\nThe answer is to use references, as in:"
    },
    {
        "link": "https://perlmonks.org?node_id=225840",
        "document": "I heartily disagree Abigail's comment that people who document every sub are wrong. There is no such thing as too much documentation, no matter how redundant it may be. Abigail's a pretty smart person, and I think the slip from \"comment\" to \"document\" was unintentional. Yes, you should always document your whole public API. Otherwise it's not really public, is it? But don't waste my limited screen real estate on crap like this: # # Class->foo() - returns the value of foo for the object # sub foo { $_[0]->{foo} } Another commenting pet peeve: # if $x is bigger than 10 if ( $x > 10 ) { # set $x to $y modulus 50 $x = $y % 50; } # otherwise, if $y is not equal to 50 elsif ( $y != 50 ) { ... } Argh! I hate that so incredibly much. Comments that simply tell me _what_ the code is doing are absolutely, utterly useless. Always assume that the next person does understand programming logic, assume that they understand Perl, etc. Don't assume they know why something is the way it is, however. In the above code, I want to know why it's important to set $x to the $y modulus 50 only when $x is greater than 10. There are a few exceptions to the \"no walk-through comments\" rule. Very complicated algorithms may deserve very careful step by step comments. This can help you as you code, in making sure that you're actually following the algorithm, and it helps future readers. And if you deliberately write less-than-clear code, for example as an optimization (after benchmarking and profiling, please), then it may be worthwhile to comment the what of the code. But a good rule to follow is that if you think the what of the code is too hard to follow without comments, then you need to rewrite the code in a clearer manner.\n\nCode should be self-documenting in the way that it should be obvious what you are doing. If it's not (e.g. a hairy regexp, or an effective but maybe-too-advanced-for-your-colleagues Perl idiom), a comment is useful. Or, if the code is too opaque, a comment can provide guide to what happens. But there are other cases. Why you do things are sometimes not obvious. Or it may be obvious to you, but it won't be to the maintenance programmer (that's you, in six months). But why is different from what. Code the what and comment the why. Some things are by definition not obvious. The interface (what you have in your example) should be explicitly documented for two reasons; it defines what the method/function actually does, and; before using a method you shouldn't have to spend time to understand how the code works, only what it does. And with a weakly typed language like Perl, it may not even be possible to deduce what kind of object to pass a method just by reading the code. The following example is from a program for replicating subsets of a Wiki to other Wikis. =head2 replicateSelection() Replicate the selected pages in the local oWireLocal to this remote Wiki, if appropriate (i.e. this remote Wiki owns it). Return 1 on success, else 0. =cut sub replicateSelection { my $self = shift; logDebug(\"Replicating to (\" . $self->urlWikiRemote() . \")\"); for my $name (@{$self->oWireLocal()->raNameSelection()}) { if($self->rhNameOwner()->{$name}) { #Do we own this page? $self->replicatePage($name) or return( logError(\"Could not replicate page ($name)\") ); } } return(1); } The POD defines what the method does, and what it returns. If it was possible for it to die, that would be mentioned. The comment explains in user-level terms what the hash ref indicates. =head2 raExtractNamePageRecent([$html]) Return array ref with names of recently changed nodes/pages. Order: unique, most recent first. If $html isn't passed, get the input from the Wiki. Return undef on errors. =cut sub raExtractNamePageRecent { my $self = shift; my ($html) = @_; defined($html) or $html = get( $self->urlFromName(\"RecentChanges\") ) or return(undef); my @aName = ($html =~ m| </td><td><a href=\"[^\"]+\">([^<]+)</a> </td>|gs); #Already unique, because they are unique on the web page return(\\@aName); } The POD says what the method expects as input, what it does, and what it returns. The comment explains why duplicate names are ignored--there are none. I find it very useful to write the interface before coding the method. Yes, I know pretty well what I intend to accomplish when I start out, but writing the POD first gives me ten more seconds thinking about the problem, including the important things like what goes in and out, what boundary conditions there are, and how to handle errors. I wish to think that this improves the quality of the code. Documenting the interface using POD instead of Perl comments makes is easy to extract the class definition programmatically, e.g. using (warning, shameless plug ahead) Perl Oasis:\n\nhttp://www.bahnhof.se/~johanl/perl/Oasis/pic/screenshots/image017.gif\n\nCommenting subs/methods are the something I feel that everyone should do. Those comments save me tons of time every day. Commenting in the code is nice as well (an I am not implying that one should be done in favor of the other, do both), but if I just want to use a sub that someone else has written I don’t want to have read the code to discover what it does (some time the function name is just not enough) and what I need to pass to it / what it will give back to me. This is what comments at the beginning of subs are for. From an ease of use standpoint, I don’t have to guess at what the sub does and I don’t have to care about how it does it, I only have to know what to give it in order to use it. This encourages code reuse because it makes the function easy to use. Comments in the code don’t really provide this abstraction for the programmer who has to come along and use these functions. Another point about inline comments is that they don’t really provide a general overview of what the function is doing. Inline comments are more often to document how something is done and explain trickery for certain lines / small blocks of code, not give an overview of the whole function. With a header comment you are forced (well sort of anyway) to do that. A general synopsis of a sub, its parameters and its return values is invaluable, epically in a large program that more than one person works on. Think how frustrating it would be to run into subs doing shifts all over the place to get parameters and such. One header comment about the required parameters and everyone else who uses the code is spared that work. All that said there are thousands of trivial subs that do exactly what the function name describes and are all of about five lines long etc… These proably do not need super indepth comments, but I still think it’s a good idea to comment these as well. Small subs are obviously less likely to confuse people (most of the time) than a huge, possibly epic sub. \n\nJosh \n\n \n\n UPDATE: After lauging my arse off at the AM reply I have decided to make it a little more readable \n\n\n\nPersonally, I try to use self explanatory names wherever possible, use my ($various, $param, $here) = @_; for positional arguments, and generally try to write the code in such a way that such information is contained in the code wherever possible. This also impacts the surrounding code - if your functions and methods are well named, the code using them will also be easier to read. My maxime is that if you feel the need to add a lot of comments, then something's fishy about your structuring and naming style. Between the public documentation and the code, not much room should be left for comments on the code. Write code with as few indentation levels as possible (but break this rule when it makes the code read more naturally), mostly using and friends. Always name variables sensibly. Avoid having more than two or three subexpressions in a single condition. Do things Once And Only Once, so that you take up less screen space and end up with fewer but more expressive distinct things to understand. Capture regularities in code, irregularities in data. Do the tersest and simplest thing that can possibly work. These and more, similar ones are the things to strive for when writing code. Follow them well, and you will find that even scarcely commented code is comprehensible. you should meticulously document your data structures. The clarity of the code hinges on your understanding of the data it manipulates. That is something you should pay very close attention to. In essence, good programming skills means good data structure design skills. Show me your flowcharts and conceal your tables, and I shall continue to be mystified. Show me your tables, and I won't usually need your flowcharts; they'll be obvious.\n\n -- Frederick P. Brooks, Jr., The Mythical Man-Month If the data structures are well designed, the code to manipulate them will suggest itself. If they are well documented, the code that manipulates them will suggest its intent with hardly any commentary."
    },
    {
        "link": "https://tutorialspoint.com/perl/perl_subroutines.htm",
        "document": "A Perl subroutine or function is a group of statements that together performs a task. You can divide up your code into separate subroutines. How you divide up your code among different subroutines is up to you, but logically the division usually is so each function performs a specific task.\n\nPerl uses the terms subroutine, method and function interchangeably.\n\nThe general form of a subroutine definition in Perl programming language is as follows −\n\nThe typical way of calling that Perl subroutine is as follows −\n\nIn versions of Perl before 5.0, the syntax for calling subroutines was slightly different as shown below. This still works in the newest versions of Perl, but it is not recommended since it bypasses the subroutine prototypes.\n\nLet's have a look into the following example, which defines a simple function and then call it. Because Perl compiles your program before executing it, it doesn't matter where you declare your subroutine.\n\nWhen above program is executed, it produces the following result −\n\nYou can pass various arguments to a subroutine like you do in any other programming language and they can be acessed inside the function using the special array @_. Thus the first argument to the function is in $_[0], the second is in $_[1], and so on.\n\nYou can pass arrays and hashes as arguments like any scalar but passing more than one array or hash normally causes them to lose their separate identities. So we will use references ( explained in the next chapter ) to pass any array or hash.\n\nLet's try the following example, which takes a list of numbers and then prints their average −\n\nWhen above program is executed, it produces the following result −\n\nBecause the @_ variable is an array, it can be used to supply lists to a subroutine. However, because of the way in which Perl accepts and parses lists and arrays, it can be difficult to extract the individual elements from @_. If you have to pass a list along with other scalar arguments, then make list as the last argument as shown below −\n\nWhen above program is executed, it produces the following result −\n\nWhen you supply a hash to a subroutine or operator that accepts a list, then hash is automatically translated into a list of key/value pairs. For example −\n\nWhen above program is executed, it produces the following result −\n\nYou can return a value from subroutine like you do in any other programming language. If you are not returning a value from a subroutine then whatever calculation is last performed in a subroutine is automatically also the return value.\n\nYou can return arrays and hashes from the subroutine like any scalar but returning more than one array or hash normally causes them to lose their separate identities. So we will use references ( explained in the next chapter ) to return any array or hash from a function.\n\nLet's try the following example, which takes a list of numbers and then returns their average −\n\nWhen above program is executed, it produces the following result −\n\nBy default, all variables in Perl are global variables, which means they can be accessed from anywhere in the program. But you can create private variables called lexical variables at any time with the my operator.\n\nThe my operator confines a variable to a particular region of code in which it can be used and accessed. Outside that region, this variable cannot be used or accessed. This region is called its scope. A lexical scope is usually a block of code with a set of braces around it, such as those defining the body of the subroutine or those marking the code blocks of if, while, for, foreach, and eval statements.\n\nFollowing is an example showing you how to define a single or multiple private variables using my operator −\n\nLet's check the following example to distinguish between global and private variables −\n\nWhen above program is executed, it produces the following result −\n\nThe local is mostly used when the current value of a variable must be visible to called subroutines. A local just gives temporary values to global (meaning package) variables. This is known as dynamic scoping. Lexical scoping is done with my, which works more like C's auto declarations.\n\nIf more than one variable or expression is given to local, they must be placed in parentheses. This operator works by saving the current values of those variables in its argument list on a hidden stack and restoring them upon exiting the block, subroutine, or eval.\n\nLet's check the following example to distinguish between global and local variables −\n\nWhen above program is executed, it produces the following result −\n\nThere are another type of lexical variables, which are similar to private variables but they maintain their state and they do not get reinitialized upon multiple calls of the subroutines. These variables are defined using the state operator and available starting from Perl 5.9.4.\n\nLet's check the following example to demonstrate the use of state variables −\n\nWhen above program is executed, it produces the following result −\n\nPrior to Perl 5.10, you would have to write it like this −\n\nThe context of a subroutine or statement is defined as the type of return value that is expected. This allows you to use a single function that returns different values based on what the user is expecting to receive. For example, the following localtime() returns a string when it is called in scalar context, but it returns a list when it is called in list context.\n\nIn this example, the value of $timestr is now a string made up of the current date and time, for example, Thu Nov 30 15:21:33 2000. Conversely −\n\nNow the individual variables contain the corresponding values returned by localtime() subroutine."
    },
    {
        "link": "https://stackoverflow.com/questions/2922618/how-do-i-escape-special-characters-for-a-substitution-in-a-perl-one-liner",
        "document": "You have several problems:\n• You are using incorrectly\n• You are replacing code with shell variables\n• You need to quote metacharacters\n\nNeither of the characters or are characters. So your match is guaranteed to fail. You may want to use something like\n\nsays to match either the start of the string ( )or a whitespace character ( ).\n\nsays to match either the end of the string ( ) or a whitespace character ( ).\n\nTo solve the second problem, you should use .\n\nTo solve the third problem, you should use the and escape sequences to escape the value in .\n\nPutting it all together we get:"
    },
    {
        "link": "https://stackoverflow.com/questions/2156731/how-do-i-escape-special-chars-in-a-string-i-interpolate-into-a-perl-regex",
        "document": "I have a string which may hold special characters like: , , , etc. I need to be able to perform regular expressions on that string.\n\nRight now if my string has any of these characters the regex seems to break since these are reserved characters for regex.\n\nDoes anybody knows a good subroutine that would escape nicely any of these characters for me so that later I could do something like:"
    },
    {
        "link": "https://perlmonks.org?node_id=1125928",
        "document": "The regex you showed us is using a backslash escape for \"#\" (which doesn't really need to be escaped), whereas you need escapes for open the parens. (Also, you're using a backslash in the replacement string, which would only be needed for getting a literal $ or @.) And maybe it's just a typo in your post, but you seem to be using the =~ operator twice, which seems wrong - since you're modifying $_, you don't need it at all. Yet another point: since you are only changing one character (# to *), you should use a \"look-ahead assertion\" for the other characters in the pattern. Finally, to top it off, you put a backslash escape in front of the forward-slash character that was supposed to be the middle delimiter for the \"s///' operator, so perl only sees two of the three forward-slashes as delimiters. (Update: Admittedly, using the look-ahead assertion in this case feels a bit uncomfortable, because you might get it confused with the look-behind syntax:\n\nYou also want to make up your mind on whether is being modified in place. If so, then you don't need at all and it's just Otherwise, if you need to keep both versions around, then it's (it being somewhat more efficient to allocate in one swell foop).\n\nThere are a lot of special regex characters in your string which need to be escaped to be properly matched.\n\n\n\n Something like this is probably what you are looking for\n\n\n\n \n\n\n\n Adding the ^ (beginning of the line anchor) and $ (end of the line anchor) is important so you don't get any partial matches\n\n# XXX this modifies the input @lines ! my ($from, $to) = ( '#<-(0N<-(s3T' => '*<-(0N<-(s3T' ); for (@lines) { s/\\Q$from\\E/$to/g; } my @newlines = @lines; # XXX this modifies the input @lines ! for (@lines) { s{\\Q#<-(0N<-(s3T\\E}{*<-(0N<-(s3T}g; } my @newlines = @lines; # don't modify @input, copy it my @newlines = @lines; for (@newlines) { s{\\Q#<-(0N<-(s3T\\E}{*<-(0N<-(s3T}g; } # or, work on a copied my($var) my @newlines; for (@lines) { my $str = $_; $str =~ s{\\Q#<-(0N<-(s3T\\E}{*<-(0N<-(s3T}g; push @newlines, $str; } # or, use non-destructive s///r my @newlines; for (@lines) { push @newlines, s{\\Q#<-(0N<-(s3T\\E}{*<-(0N<-(s3T}gr; } # and again, more concise using a map: my @newlines = map s{\\Q#<-(0N<-(s3T\\E}{*<-(0N<-(s3T}gr, @lines;"
    },
    {
        "link": "https://perldoc.perl.org/perlrebackslash",
        "document": "\n• DESCRIPTION\n• All the sequences and escapes\n\nThe top level documentation about Perl regular expressions is found in perlre.\n\nThis document describes all backslash and escape sequences. After explaining the role of the backslash, it lists all the sequences that have a special meaning in Perl regular expressions (in alphabetical order), then describes each of them.\n\nMost sequences are described in detail in different documents; the primary purpose of this document is to have a quick reference guide describing all backslash and escape sequences.\n\nIn a regular expression, the backslash can perform one of two tasks: it either takes away the special meaning of the character following it (for instance, matches a vertical bar, it's not an alternation), or it is the start of a backslash or escape sequence.\n\nThe rules determining what it is are quite simple: if the character following the backslash is an ASCII punctuation (non-word) character (that is, anything that is not a letter, digit, or underscore), then the backslash just takes away any special meaning of the character following it.\n\nIf the character following the backslash is an ASCII letter or an ASCII digit, then the sequence may be special; if so, it's listed below. A few letters have not been used yet, so escaping them with a backslash doesn't change them to be special. A future version of Perl may assign a special meaning to them, so if you have warnings turned on, Perl issues a warning if you use such a sequence. [1].\n\nIt is however guaranteed that backslash or escape sequences never have a punctuation character following the backslash, not now, and not in a future version of Perl 5. So it is safe to put a backslash in front of a non-word character.\n\nNote that the backslash itself is special; if you want to match a backslash, you have to escape the backslash with a backslash: matches a single backslash.\n\n#All the sequences and escapes\n\nThose not usable within a bracketed character class (like ) are marked as\n\nA handful of characters have a dedicated character escape. The following table shows them, along with their ASCII code points (in decimal and hex), their ASCII name, the control escape on ASCII platforms and a short description. (For EBCDIC platforms, see \"OPERATOR DIFFERENCES\" in perlebcdic.)\n\nis used to denote a control character; the character following determines the value of the construct. For example the value of is , and the value of is , etc. The gory details are in \"Regexp Quote-Like Operators\" in perlop. A complete list of what , etc. means for ASCII and EBCDIC platforms is in \"OPERATOR DIFFERENCES\" in perlebcdic.\n\nNote that alone at the end of a regular expression (or doubled-quoted string) is not valid. The backslash must be followed by another character. That is, means for all characters X.\n\nTo write platform-independent code, you must use instead, like or , see charnames.\n\nUnicode characters have a Unicode name and numeric code point (ordinal) value. Use the construct to specify a character by either of these values. Certain sequences of characters also have names.\n\nTo specify by name, the name of the character or character sequence goes between the curly braces.\n\nTo specify a character by Unicode code point, use the form , where code point is a number in hexadecimal that gives the code point that Unicode has assigned to the desired character. It is customary but not required to use leading zeros to pad the number to 4 digits. Thus means , and you will rarely see it written without the two leading zeros. means \"A\" even on EBCDIC machines (where the ordinal value of \"A\" is not 0x41).\n\nBlanks may freely be inserted adjacent to but within the braces enclosing the name or code point. So is perfectly legal.\n\nIt is even possible to give your own names to characters and character sequences by using the charnames module. These custom names are lexically scoped, and so a given code point may have different names in different scopes. The name used is what is in effect at the time the is expanded. For patterns in double-quotish context, that means at the time the pattern is parsed. But for patterns that are delimitted by single quotes, the expansion is deferred until pattern compilation time, which may very well have a different translator in effect.\n\nNote that a character or character sequence expressed as a named or numbered character is considered a character without special meaning by the regex engine, and will match \"as is\".\n\nThere are two forms of octal escapes. Each is used to specify a character by its code point specified in base 8.\n\nOne form, available starting in Perl 5.14 looks like , where the dots represent one or more octal digits. It can be used for any Unicode character.\n\nIt was introduced to avoid the potential problems with the other form, available in all Perls. That form consists of a backslash followed by three octal digits. One problem with this form is that it can look exactly like an old-style backreference (see \"Disambiguation rules between old-style octal escapes and backreferences\" below.) You can avoid this by making the first of the three digits always a zero, but that makes \\077 the largest code point specifiable.\n\nIn some contexts, a backslash followed by two or even one octal digits may be interpreted as an octal escape, sometimes with a warning, and because of some bugs, sometimes with surprising results. Also, if you are creating a regex out of smaller snippets concatenated together, and you use fewer than three digits, the beginning of one snippet may be interpreted as adding digits to the ending of the snippet before it. See \"Absolute referencing\" for more discussion and examples of the snippet problem.\n\nNote that a character expressed as an octal escape is considered a character without special meaning by the regex engine, and will match \"as is\".\n\nTo summarize, the form is always safe to use, and the other form is safe to use for code points through \\077 when you use exactly three digits to specify them.\n\nOctal escapes of the form outside of bracketed character classes potentially clash with old-style backreferences (see \"Absolute referencing\" below). They both consist of a backslash followed by numbers. So Perl has to use heuristics to determine whether it is a backreference or an octal escape. Perl uses the following rules to disambiguate:\n• None If the backslash is followed by a single digit, it's a backreference.\n• None If the first digit following the backslash is a 0, it's an octal escape.\n• None If the number following the backslash is N (in decimal), and Perl already has seen N capture groups, Perl considers this a backreference. Otherwise, it considers it an octal escape. If N has more than three digits, Perl takes only the first three for the octal escape; the rest are matched as is. my $pat = \"(\" x 999; $pat .= \"a\"; $pat .= \")\" x 999; /^($pat)\\1000$/; # Matches 'aa'; there are 1000 capture groups. /^$pat\\1000$/; # Matches 'a@0'; there are 999 capture groups # and \\1000 is seen as \\100 (a '@') and a '0'.\n\nYou can force a backreference interpretation always by using the form. You can the force an octal interpretation always by using the form, or for numbers up through \\077 (= 63 decimal), by using three digits, beginning with a \"0\".\n\nLike octal escapes, there are two forms of hexadecimal escapes, but both start with the sequence . This is followed by either exactly two hexadecimal digits forming a number, or a hexadecimal number of arbitrary length surrounded by curly braces. The hexadecimal number is the code point of the character you want to express.\n\nNote that a character expressed as one of these escapes is considered a character without special meaning by the regex engine, and will match \"as is\".\n\nA number of backslash sequences have to do with changing the character, or characters following them. will lowercase the character following it, while will uppercase (or, more accurately, titlecase) the character following it. They provide functionality similar to the functions and .\n\nTo uppercase or lowercase several characters, one might want to use or , which will lowercase/uppercase all characters following them, until either the end of the pattern or the next occurrence of , whichever comes first. They provide functionality similar to what the functions and provide.\n\nis used to quote (disable) pattern metacharacters, up to the next or the end of the pattern. adds a backslash to any character that could have special meaning to Perl. In the ASCII range, it quotes every character that isn't a letter, digit, or underscore. See \"quotemeta\" in perlfunc for details on what gets quoted for non-ASCII code points. Using this ensures that any character between and will be matched literally, not interpreted as a metacharacter by the regex engine.\n\ncan be used to casefold all characters following, up to the next or the end of the pattern. It provides the functionality similar to the function.\n\nPerl regular expressions have a large range of character classes. Some of the character classes are written as a backslash sequence. We will briefly discuss those here; full details of character classes can be found in perlrecharclass.\n\nis a character class that matches any single word character (letters, digits, Unicode marks, and connector punctuation (like the underscore)). is a character class that matches any decimal digit, while the character class matches any whitespace character. New in perl 5.10.0 are the classes and which match horizontal and vertical whitespace characters.\n\nThe exact set of characters matched by , , and varies depending on various pragma and regular expression modifiers. It is possible to restrict the match to the ASCII range by using the regular expression modifier. See perlrecharclass.\n\nThe uppercase variants ( , , , , and ) are character classes that match, respectively, any character that isn't a word character, digit, whitespace, horizontal whitespace, or vertical whitespace.\n\n(where is a single letter) and are used to match a character that matches the given Unicode property; properties include things like \"letter\", or \"thai character\". Capitalizing the sequence to and make the sequence match a character that doesn't match the given Unicode property. For more details, see \"Backslash sequences\" in perlrecharclass and \"Unicode Character Properties\" in perlunicode.\n\nIf capturing parenthesis are used in a regular expression, we can refer to the part of the source string that was matched, and match exactly the same thing. There are three ways of referring to such backreference: absolutely, relatively, and by name.\n\nEither (starting in Perl 5.10.0), or (old-style) where N is a positive (unsigned) decimal number of any length is an absolute reference to a capturing group.\n\nN refers to the Nth set of parentheses, so refers to whatever has been matched by that set of parentheses. Thus refers to the first capture group in the regex.\n\nThe form can be equivalently written as which avoids ambiguity when building a regex by concatenating shorter strings. Otherwise if you had a regex , and contained , and contained , you would get which is probably not what you intended.\n\nIn the form, N must not begin with a \"0\", and there must be at least N capturing groups, or else N is considered an octal escape (but something like is the same as ; that is, the octal escape followed by a literal digit ).\n\n(starting in Perl 5.10.0) is used for relative addressing. (It can be written as .) It refers to the Nth group before the .\n\nThe big advantage of this form is that it makes it much easier to write patterns with references that can be interpolated in larger patterns, even if the larger pattern also contains capture groups.\n\n(starting in Perl 5.10.0) can be used to back refer to a named capture group, dispensing completely with having to think about capture buffer positions.\n\nTo be compatible with .Net regular expressions, may also be written as , or .\n\nTo prevent any ambiguity, name must not start with a digit nor contain a hyphen.\n\nAssertions are conditions that have to be true; they don't actually match parts of the substring. There are six assertions that are written as backslash sequences.\n\nonly matches at the beginning of the string. If the modifier isn't used, then is equivalent to . However, if the modifier is used, then matches internal newlines, but the meaning of isn't changed by the modifier. matches at the beginning of the string regardless whether the modifier is used. and match at the end of the string. If the modifier isn't used, then is equivalent to ; that is, it matches at the end of the string, or one before the newline at the end of the string. If the modifier is used, then matches at internal newlines, but the meaning of isn't changed by the modifier. matches at the end of the string (or just before a trailing newline) regardless whether the modifier is used. is just like , except that it does not match before a trailing newline. matches at the end of the string only, regardless of the modifiers used, and not just before a newline. It is how to anchor the match to the true end of the string under all conditions. is usually used only in combination with the modifier. If the modifier is used and the match is done in scalar context, Perl remembers where in the source string the last match ended, and the next time, it will start the match from where it ended the previous time. matches the point where the previous match on that string ended, or the beginning of that string if there was no previous match. , available starting in v5.22, matches a boundary (between two characters, or before the first character of the string, or after the final character of the string) based on the Unicode rules for the boundary type specified inside the braces. The boundary types are given a few paragraphs below. matches at any place between characters where of the same type doesn't match. when not immediately followed by a is available in all Perls. It matches at any place between a word (something matched by ) and a non-word character ( ); when not immediately followed by a matches at any place between characters where doesn't match. To get better word matching of natural language text, see \"\\b{wb}\" below. and assume there's a non-word character before the beginning and after the end of the source string; so will match at the beginning (or end) of the source string if the source string begins (or ends) with a word character. Otherwise, will match. Do not use something like and expect it to match the beginning of a line. It can't, because for there to be a boundary before the non-word \"=\", there must be a word character immediately previous. All plain and boundary determinations look for word characters alone, not for non-word characters nor for string ends. It may help to understand how and work by equating them as follows: In contrast, and may or may not match at the beginning and end of the line, depending on the boundary type. These implement the Unicode default boundaries, specified in https://www.unicode.org/reports/tr14/ and https://www.unicode.org/reports/tr29/. The boundary types are: This matches a Unicode \"Grapheme Cluster Boundary\". (Actually Perl always uses the improved \"extended\" grapheme cluster\"). These are explained below under . In fact, is another way to get the same functionality. It is equivalent to . Use whichever is most convenient for your situation. This matches according to the default Unicode Line Breaking Algorithm (https://www.unicode.org/reports/tr14/), as customized in that document (Example 7 of revision 35) for better handling of numeric expressions. This is suitable for many purposes, but the Unicode::LineBreak module is available on CPAN that provides many more features, including customization. This matches a Unicode \"Sentence Boundary\". This is an aid to parsing natural language sentences. It gives good, but imperfect results. For example, it thinks that \"Mr. Smith\" is two sentences. More details are at https://www.unicode.org/reports/tr29/. Note also that it thinks that anything matching \"\\R\" (except form feed and vertical tab) is a sentence boundary. works with text designed for word-processors which wrap lines automatically for display, but hard-coded line boundaries are considered to be essentially the ends of text blocks (paragraphs really), and hence the ends of sentences. doesn't do well with text containing embedded newlines, like the source text of the document you are reading. Such text needs to be preprocessed to get rid of the line separators before looking for sentence boundaries. Some people view this as a bug in the Unicode standard, and this behavior is quite subject to change in future Perl versions. This matches a Unicode \"Word Boundary\", but tailored to Perl expectations. This gives better (though not perfect) results for natural language processing than plain (without braces) does. For example, it understands that apostrophes can be in the middle of words and that parentheses aren't (see the examples below). More details are at https://www.unicode.org/reports/tr29/. The current Unicode definition of a Word Boundary matches between every white space character. Perl tailors this, starting in version 5.24, to generally not break up spans of white space, just as plain has always functioned. This allows to be a drop-in replacement for , but with generally better results for natural language processing. (The exception to this tailoring is when a span of white space is immediately followed by something like U+0303, COMBINING TILDE. If the final space character in the span is a horizontal white space, it is broken out so that it attaches instead to the combining character. To be precise, if a span of white space that ends in a horizontal space has the character immediately following it have any of the Word Boundary property values \"Extend\", \"Format\" or \"ZWJ\", the boundary between the final horizontal space character and the rest of the span matches . In all other cases the boundary between two white space characters matches .) It is important to realize when you use these Unicode boundaries, that you are taking a risk that a future version of Perl which contains a later version of the Unicode Standard will not work precisely the same way as it did when your code was written. These rules are not considered stable and have been somewhat more subject to change than the rest of the Standard. Unicode reserves the right to change them at will, and Perl reserves the right to update its implementation to Unicode's new rules. In the past, some changes have been because new characters have been added to the Standard which have different characteristics than all previous characters, so new rules are formulated for handling them. These should not cause any backward compatibility issues. But some changes have changed the treatment of existing characters because the Unicode Technical Committee has decided that the change is warranted for whatever reason. This could be to fix a bug, or because they think better results are obtained with the new rule. It is also important to realize that these are default boundary definitions, and that implementations may wish to tailor the results for particular purposes and locales. For example, some languages, such as Japanese and Thai, require dictionary lookup to accurately determine word boundaries.\n\nHere we document the backslash sequences that don't fall in one of the categories above. These are:"
    },
    {
        "link": "https://perlmonks.org?node_id=759892",
        "document": "msk_0984 has asked for the wisdom of the Perl Monks concerning the following question:\n\nI have problem with the regular expression while using the substitution operator.\n\nPrints the output asThe problem is that when I have special characters in the variable and try to substitute the variable it is getting interpolated and thinking it as a perl variable.\n\nI need to escape the special characters in the variable and it should be replaced. Actually my main requirement is that I am storing user passwords in a file for a small web-application in encrypted format.\n\nWhen the user needs to update his password and use some special characters in it. The record is not getting updated since I am using the same above logic i.e the substitution operator to replace the existing record with the new record.\n\nIs there any way to escape the special characters in the variable.\n\nPlease help me out in this regard. Thanks In Advance."
    }
]