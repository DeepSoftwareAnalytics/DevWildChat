[
    {
        "link": "https://pygame.org/docs/ref/event.html",
        "document": "Pygame handles all its event messaging through an event queue. The routines in this module help you manage that event queue. The input queue is heavily dependent on the pygame module to control the display window and screen module. If the display has not been initialized and a video mode not set, the event queue may not work properly.\n\nThe event queue has an upper limit on the number of events it can hold. When the queue becomes full new events are quietly dropped. To prevent lost events, especially input events which signal a quit command, your program must handle events every frame (with , , , or ) and process them. Not handling events may cause your system to decide your program has locked up. To speed up queue processing use control which events are allowed on the queue to limit which events get queued.\n\nTo get the state of various input devices, you can forego the event queue and access the input devices directly with their appropriate modules: pygame module to work with the mouse, pygame module to work with the keyboard, and Pygame module for interacting with joysticks, gamepads, and trackballs.. If you use this method, remember that pygame requires some form of communication with the system window manager and other parts of the platform. To keep pygame in sync with the system, you will need to call internally process pygame event handlers to keep everything current. Usually, this should be called once per game loop. Note: Joysticks will not send any events until the device has been initialized.\n\nThe event queue contains pygame object for representing events event objects. There are a variety of ways to access the queued events, from simply checking for the existence of events, to grabbing them directly off the stack. The event queue also offers some simple filtering which can slightly help performance by blocking certain event types from the queue. Use control which events are allowed on the queue and control which events are allowed on the queue to change this filtering. By default, all event types can be placed on the queue.\n\nAll pygame object for representing events instances contain an event type identifier and attributes specific to that event type. The event type identifier is accessible as the event type identifier. property. Any of the event specific attributes can be accessed through the event attribute dictionary attribute or directly as an attribute of the event object (as member lookups are passed through to the object's dictionary values). The event object has no method functions. Users can create their own new events with the pygame object for representing events function.\n\nThe event type identifier is in between the values of and . User defined events should have a value in the inclusive range of to . User defined events can get a custom event number with make custom user event type. It is recommended all user events follow this system.\n\nEvents support equality and inequality comparisons. Two events are equal if they are the same type and have identical attribute values.\n\nWhile debugging and experimenting, you can print an event object for a quick display of its type and members. The function get the string name from an event id can be used to get a string representing the name of the event type.\n\nEvents that come from the system will have a guaranteed set of member attributes based on the type. The following is a list event types with their specific attributes.\n\nNote that , and are considered as \"legacy\" events, the use of pygame2 API is recommended over the use of this older API.\n\nYou can also find a list of constants for keyboard keys here.\n\nA keyboard event occurs when a key is pressed ( ) and when a key is released ( ) The attribute of keyboard events contains the value of what key was pressed or released. The attribute contains information about the state of keyboard modifiers (SHIFT, CTRL, ALT, etc.). The attribute stores the 16-bit unicode value of the key that was pressed or released. The attribute represents the physical location of a key on the keyboard.\n\nThe contains information about the application gaining or losing focus. The attribute will be 1 if the mouse enters the window, otherwise will be 0. The attribute will have a value of if mouse focus was gained/lost, if the application loses or gains keyboard focus, or if the application is minimized ( will be 0) or restored.\n\nWhen compiled with SDL2, pygame has these additional events and their attributes.\n\nThe attribute of events indicates whether or not the events were generated by a touch input device, and not a real mouse. You might want to ignore such events, if your application already handles , and events.\n\nevent occurs whenever the mouse wheel is moved. The attribute determines if the event was generated from a touch input device vs an actual mousewheel. The attribute contains a float with the amount scrolled horizontally (positive to the right, negative to the left). The attribute contains a float with the amount scrolled vertically (positive away from user, negative towards user). The attribute determines if the values in x and y will be opposite or not. If is defined, the direction of x and y will be opposite.\n\nevent is triggered when a user activates an input method via hotkey or selecting an input method in a GUI and starts typing\n\nThe attribute for events is an integer representing the index for new audio devices that are added. events are used to update audio settings or device list.\n\npygame can recognize text or files dropped in its window. If a file is dropped, event will be sent, will be its path. The event is only supported on X11.\n\nand are events reserved for pygame module for interacting with midi input and output. use. events differ from events in that AUDIODEVICE events are triggered when there is a state change related to an audio input/output device.\n\nAlso in this version, attributes were added to joystick events, and the attribute was deprecated.\n\nis a type of an event sent when keymap changes due to a system event such as an input language or keyboard layout change.\n\nis an event sent when clipboard changes. This can still be considered as an experimental feature, some kinds of clipboard changes might not trigger this event.\n\nSince pygame 2.0.1, there are a new set of events, called window events. Here is a list of all window events, along with a short description\n\n, and have and attributes, has a attribute. All windowevents have a attribute.\n\nOn Android, the following events can be generated"
    },
    {
        "link": "https://pygame.org/docs",
        "document": "Welcome to pygame! Once you've got pygame installed ( or for most people), the next question is how to get a game loop running. Pygame, unlike some other libraries, gives you full control of program execution. That freedom means it is easy to mess up in your initial steps.\n\nHere is a good example of a basic setup (opens the window, updates the screen, and handles events)--\n\nHere is a slightly more fleshed out example, which shows you how to move something (a circle in this case) around on screen--\n\nFor more in depth reference, check out the Tutorials section below, check out a video tutorial (I'm a fan of this one), or reference the API documentation by module."
    },
    {
        "link": "https://pygame.org/docs/ref/event.html?highlight=event%20unicode",
        "document": "Pygame handles all its event messaging through an event queue. The routines in this module help you manage that event queue. The input queue is heavily dependent on the pygame module to control the display window and screen module. If the display has not been initialized and a video mode not set, the event queue may not work properly.\n\nThe event queue has an upper limit on the number of events it can hold. When the queue becomes full new events are quietly dropped. To prevent lost events, especially input events which signal a quit command, your program must handle events every frame (with , , , or ) and process them. Not handling events may cause your system to decide your program has locked up. To speed up queue processing use control which events are allowed on the queue to limit which events get queued.\n\nTo get the state of various input devices, you can forego the event queue and access the input devices directly with their appropriate modules: pygame module to work with the mouse, pygame module to work with the keyboard, and Pygame module for interacting with joysticks, gamepads, and trackballs.. If you use this method, remember that pygame requires some form of communication with the system window manager and other parts of the platform. To keep pygame in sync with the system, you will need to call internally process pygame event handlers to keep everything current. Usually, this should be called once per game loop. Note: Joysticks will not send any events until the device has been initialized.\n\nThe event queue contains pygame object for representing events event objects. There are a variety of ways to access the queued events, from simply checking for the existence of events, to grabbing them directly off the stack. The event queue also offers some simple filtering which can slightly help performance by blocking certain event types from the queue. Use control which events are allowed on the queue and control which events are allowed on the queue to change this filtering. By default, all event types can be placed on the queue.\n\nAll pygame object for representing events instances contain an event type identifier and attributes specific to that event type. The event type identifier is accessible as the event type identifier. property. Any of the event specific attributes can be accessed through the event attribute dictionary attribute or directly as an attribute of the event object (as member lookups are passed through to the object's dictionary values). The event object has no method functions. Users can create their own new events with the pygame object for representing events function.\n\nThe event type identifier is in between the values of and . User defined events should have a value in the inclusive range of to . User defined events can get a custom event number with make custom user event type. It is recommended all user events follow this system.\n\nEvents support equality and inequality comparisons. Two events are equal if they are the same type and have identical attribute values.\n\nWhile debugging and experimenting, you can print an event object for a quick display of its type and members. The function get the string name from an event id can be used to get a string representing the name of the event type.\n\nEvents that come from the system will have a guaranteed set of member attributes based on the type. The following is a list event types with their specific attributes.\n\nNote that , and are considered as \"legacy\" events, the use of pygame2 API is recommended over the use of this older API.\n\nYou can also find a list of constants for keyboard keys here.\n\nA keyboard event occurs when a key is pressed ( ) and when a key is released ( ) The attribute of keyboard events contains the value of what key was pressed or released. The attribute contains information about the state of keyboard modifiers (SHIFT, CTRL, ALT, etc.). The attribute stores the 16-bit unicode value of the key that was pressed or released. The attribute represents the physical location of a key on the keyboard.\n\nThe contains information about the application gaining or losing focus. The attribute will be 1 if the mouse enters the window, otherwise will be 0. The attribute will have a value of if mouse focus was gained/lost, if the application loses or gains keyboard focus, or if the application is minimized ( will be 0) or restored.\n\nWhen compiled with SDL2, pygame has these additional events and their attributes.\n\nThe attribute of events indicates whether or not the events were generated by a touch input device, and not a real mouse. You might want to ignore such events, if your application already handles , and events.\n\nevent occurs whenever the mouse wheel is moved. The attribute determines if the event was generated from a touch input device vs an actual mousewheel. The attribute contains a float with the amount scrolled horizontally (positive to the right, negative to the left). The attribute contains a float with the amount scrolled vertically (positive away from user, negative towards user). The attribute determines if the values in x and y will be opposite or not. If is defined, the direction of x and y will be opposite.\n\nevent is triggered when a user activates an input method via hotkey or selecting an input method in a GUI and starts typing\n\nThe attribute for events is an integer representing the index for new audio devices that are added. events are used to update audio settings or device list.\n\npygame can recognize text or files dropped in its window. If a file is dropped, event will be sent, will be its path. The event is only supported on X11.\n\nand are events reserved for pygame module for interacting with midi input and output. use. events differ from events in that AUDIODEVICE events are triggered when there is a state change related to an audio input/output device.\n\nAlso in this version, attributes were added to joystick events, and the attribute was deprecated.\n\nis a type of an event sent when keymap changes due to a system event such as an input language or keyboard layout change.\n\nis an event sent when clipboard changes. This can still be considered as an experimental feature, some kinds of clipboard changes might not trigger this event.\n\nSince pygame 2.0.1, there are a new set of events, called window events. Here is a list of all window events, along with a short description\n\n, and have and attributes, has a attribute. All windowevents have a attribute.\n\nOn Android, the following events can be generated"
    },
    {
        "link": "https://geeksforgeeks.org/pygame-event-handling",
        "document": "An event is an action that is performed by the user in order to get the desired result. For instance, if a user clicks a button then it is known as a click event. Now, all the events that are performed by the user are inserted into a queue known as an event queue. Since it is a queue, it follows the First In First Out rule i.e. element inserted first will come out first. In this case, when an event is created it is added to the back of the queue and when the event is processed then it comes out from the front. Every element in this queue is associated with an attribute which is nothing but an integer that represents what type of event it is. Let us learn a few important attributes of the common event types.\n\nOwing to the fact that you have understood what an event in pygame is now let us dive deep into this topic. It is essential to know that the processing of an event must be done within the main function. This is because if in case if it is done, then there is a chance of having an input lag which can result in a poor user experience. The processing is done using pygame.event.get(). This is a function that will return the list of events that can be processed one after another.\n\nAs mentioned above, an event is an action conducted by the user. So let us wonder, what actions can be performed on the keyboard? The simple answer is either pressing the key or releasing it. Pressing the key is known as KEYDOWN and releasing it is known as KEYUP. The attribute associated with these events is known as the key of type integer. Its use is to represent the key of the keyboard. The common keys are represented by a pre-defined integer constant which is a capital K. This K is followed by an underscore and then the name of the key is written. For example K_s, K_F7.\n\nThe fact of the matter is that capital letters do not have an integer constant. The solution to this problem is something known as a modifier also known as a mod which is the modifier such as for shift, alt, ctrl, etc. that are being pressed simultaneously as the key. The integer value of mod is stored in something known as KMOD_ which is followed by the name of the key. For example KMOD_RSHIFT, KMOD_CTRL, etc. Let us revise the concepts that we have learned in the keyboard event topic with the help of a small code.\n\nLet us now understand the different types of mouse events. The first two are MOUSEBUTTONDOWN and MOUSEBUTTONUP which are similar to KEYDOWN and KEYUP except for the fact that here we are using a mouse. In addition to them, there is another mouse event known as MOUSEMOTION. Let us understand all 3 mouse events in detail.\n\ni) MOUSEBUTTONDOWN: The MOUSEBUTTONDOWN event occurs when the user presses the mouse button. It has a couple of attributes which are as follows :\n• button: It is an integer that represents the button that has been pressed. The left button of the mouse is represented by 1, for mouse-wheel the integer is 2, and integer 3 is when the right button of the mouse is pressed.\n• pos: It is the absolute position of the mouse (x, y) when the user presses the mouse button.\n\nii) MOUSEBUTTONUP: The MOUSEBUTTONUP event occurs when the user releases the mouse button. It has the same button and pos attributes that the MOUSEBUTTONDOWN has which have been mentioned above.\n\niii) MOUSEMOTION: This event occurs when the user moves his mouse in the display window. It has the attributes buttons, pos, and rel.\n• buttons: It is a tuple that represents whether the mouse buttons (left, mouse-wheel, right) are pressed or not.\n• pos: It is the absolute position (x, y) of the cursor in pixels.\n• rel: It represents the relative position to the previous position (rel_x, rel_y) in pixels.\n\nLet us revise the values for every mouse button attribute with the help of the following table:\n\nLet us revise the concepts that we have learned in the mouse event topic with the help of a small code.\n\nLet us now have a look at a couple of pygame programs related to event handling.\n\nThe following program will check whether we have pressed the left key or the right key and display output accordingly.\n\nThe following program will check whether we are moving the mouse or pressing the mouse button or releasing it and display output accordingly."
    },
    {
        "link": "https://pg1.readthedocs.io/en/latest/ref/event.html",
        "document": "Pygame handles all its event messaging through an event queue. The routines in this module help you manage that event queue. The input queue is heavily dependent on the pygame module to control the display window and screen module. If the display has not been initialized and a video mode not set, the event queue may not work properly.\n\nThe event queue has an upper limit on the number of events it can hold. When the queue becomes full new events are quietly dropped. To prevent lost events, especially input events which signal a quit command, your program must handle events every frame (with , , , or ) and process them. Not handling events may cause your system to decide your program has locked up. To speed up queue processing use control which events are allowed on the queue to limit which events get queued.\n\nTo get the state of various input devices, you can forego the event queue and access the input devices directly with their appropriate modules: pygame module to work with the mouse, pygame module to work with the keyboard, and Pygame module for interacting with joysticks, gamepads, and trackballs.. If you use this method, remember that pygame requires some form of communication with the system window manager and other parts of the platform. To keep pygame in sync with the system, you will need to call internally process pygame event handlers to keep everything current. Usually, this should be called once per game loop. Note: Joysticks will not send any events until the device has been initialized.\n\nThe event queue contains pygame object for representing events event objects. There are a variety of ways to access the queued events, from simply checking for the existence of events, to grabbing them directly off the stack. The event queue also offers some simple filtering which can slightly help performance by blocking certain event types from the queue. Use control which events are allowed on the queue and control which events are allowed on the queue to change this filtering. By default, all event types can be placed on the queue.\n\nAll pygame object for representing events instances contain an event type identifier and attributes specific to that event type. The event type identifier is accessible as the event type identifier. property. Any of the event specific attributes can be accessed through the event attribute dictionary attribute or directly as an attribute of the event object (as member lookups are passed through to the object's dictionary values). The event object has no method functions. Users can create their own new events with the pygame object for representing events function.\n\nThe event type identifier is in between the values of and . User defined events should have a value in the inclusive range of to . User defined events can get a custom event number with make custom user event type. It is recommended all user events follow this system.\n\nEvents support equality and inequality comparisons. Two events are equal if they are the same type and have identical attribute values.\n\nWhile debugging and experimenting, you can print an event object for a quick display of its type and members. The function get the string name from an event id can be used to get a string representing the name of the event type.\n\nEvents that come from the system will have a guaranteed set of member attributes based on the type. The following is a list event types with their specific attributes.\n\nNote that , and are considered as \"legacy\" events, the use of pygame2 API is recommended over the use of this older API.\n\nYou can also find a list of constants for keyboard keys here.\n\nWhen compiled with SDL2, pygame has these additional events and their attributes.\n\nThe attribute of events indicates whether or not the events were generated by a touch input device, and not a real mouse. You might want to ignore such events, if your application already handles , and events.\n\nMany new events were introduced in pygame 2.\n\npygame can recognize text or files dropped in its window. If a file is dropped, event will be sent, will be its path. The event is only supported on X11.\n\nand are events reserved for pygame module for interacting with midi input and output. use.\n\nAlso in this version, attributes were added to joystick events, and the attribute was deprecated.\n\nis a type of an event sent when keymap changes due to a system event such as an input language or keyboard layout change.\n\nis an event sent when clipboard changes. This can still be considered as an experimental feature, some kinds of clipboard changes might not trigger this event.\n\nis an event sent when user locale changes\n\nSince pygame 2.0.1, there are a new set of events, called window events. Here is a list of all window events, along with a short description\n\n, and have and attributes, has a attribute. All windowevents have a attribute.\n\nOn Android, the following events can be generated"
    },
    {
        "link": "https://python-chess.readthedocs.io",
        "document": "python-chess is a chess library for Python, with move generation, move validation, and support for common formats. This is the Scholar’s mate in python-chess:\n\n# Black to move is losing in 53 half moves (distance to zero) in this\n\nWith the new rules from July 2014, a game ends as a draw (even without a claim) once a fivefold repetition occurs or if there are 75 moves without a pawn push or capture. Other ways of ending a game take precedence.\n\nan accessible chessboard that allows blind and visually impaired players to play chess against Stockfish – https://github.com/blindpandas/chessmart\n\nA highly customizable way to play chess in your terminal\n\nOppinionated wrapper to use python-chess from the R programming language\n\nIf you like, share interesting things you are using python-chess for, for example:\n\nThanks to the Stockfish authors and thanks to Sam Tannous for publishing his approach to avoid rotated bitboards with direct lookup (PDF) alongside his GPL2+ engine Shatranj. Some move generation ideas are taken from these sources.\n\nThanks to Ronald de Man for his Syzygy endgame tablebases. The probing code in python-chess is very directly ported from his C probing code.\n\nThanks to Kristian Glass for transferring the namespace on PyPI."
    },
    {
        "link": "https://github.com/niklasf/python-chess",
        "document": "python-chess is a chess library for Python, with move generation, move validation, and support for common formats. This is the Scholar's mate in python-chess:\n• With the new rules from July 2014, a game ends as a draw (even without a claim) once a fivefold repetition occurs or if there are 75 moves without a pawn push or capture. Other ways of ending a game take precedence.\n• None Reads and writes PGNs. Supports headers, comments, NAGs and a tree of variations. Docs.\n• . . . ( ) # Black to move is losing in 53 half moves (distance to zero) in this . ( ) . ( ) . ()\n\nIf you like, share interesting things you are using python-chess for, for example:\n• an accessible chessboard that allows blind and visually impaired players to play chess against Stockfish – https://github.com/blindpandas/chessmart\n\nThanks to the Stockfish authors and thanks to Sam Tannous for publishing his approach to avoid rotated bitboards with direct lookup (PDF) alongside his GPL2+ engine Shatranj. Some move generation ideas are taken from these sources.\n\nThanks to Ronald de Man for his Syzygy endgame tablebases. The probing code in python-chess is very directly ported from his C probing code.\n\nThanks to Kristian Glass for transferring the namespace on PyPI.\n\npython-chess is licensed under the GPL 3 (or any later version at your option). Check out for the full text."
    },
    {
        "link": "https://python-chess.readthedocs.io/en/v1.9.4",
        "document": "python-chess is a chess library for Python, with move generation, move validation, and support for common formats. This is the Scholar’s mate in python-chess:\n\n# Black to move is losing in 53 half moves (distance to zero) in this\n\nWith the new rules from July 2014, a game ends as a draw (even without a claim) once a fivefold repetition occurs or if there are 75 moves without a pawn push or capture. Other ways of ending a game take precedence.\n\nan accessible chessboard that allows blind and visually impaired players to play chess against Stockfish – https://github.com/blindpandas/chessmart\n\nOppinionated wrapper to use python-chess from the R programming language\n\nIf you like, share interesting things you are using python-chess for, for example:\n\nThanks to the Stockfish authors and thanks to Sam Tannous for publishing his approach to avoid rotated bitboards with direct lookup (PDF) alongside his GPL2+ engine Shatranj. Some move generation ideas are taken from these sources.\n\nThanks to Ronald de Man for his Syzygy endgame tablebases. The probing code in python-chess is very directly ported from his C probing code.\n\nThanks to Kristian Glass for transferring the namespace on PyPI."
    },
    {
        "link": "https://geeksforgeeks.org/chess-library-in-python",
        "document": "The chess module is a pure Python chess library with move generation, move validation and support for common formats. We can play chess with it. It will help us to move the king queen, pawn, bishops and knights. We need to know the basics of chess to play chess with it. This module does every task in python that is possible in the real game.\n\nWe just have to import the chess library and with it, we can play chess. When we will import the chess library we have to call the function named board so that we can see the status of the chess board.\n\nHere is the code for making calling the function board of chess library.\n\nWe can find out what are the legal moves using the below code:\n\nIf we have to move any piece, we can check with above command that which moves we can do.\n\nTo check If it is a stalemate:\n\nStalemate is a situation in the game of chess where the player whose turn it is to move is not in check but has no legal move. The rules of chess provide that when stalemate occurs, the game ends as a draw.\n\nWe can detect check also with help of above function:\n\nWith the new rules from July 2014, a game ends as a draw (even without a claim) once a fivefold repetition occurs or if there are 75 moves without a pawn push or capture. Other ways of ending a game take precedence. So there methods for checking these things also="
    },
    {
        "link": "https://stackoverflow.com/questions/58256450/python-chess-program",
        "document": "I'm attempting to make a fairly simple chess game for my a coding project, hoping to implement a computer opponent at some point too, a bit stuck on how to add move limits and functions to detect the game ending at this point. The body was designed by @sloth and I've added to it.\n\nI've done the fairly simple stuff, load all the pieces and change the board colour but I'm not too sure on what to do at this point. Any help would be appreciated!"
    }
]