[
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/net/HttpURLConnection.html",
        "document": "A URLConnection with support for HTTP-specific features. See the spec for details.\n\nEach HttpURLConnection instance is used to make a single request but the underlying network connection to the HTTP server may be transparently shared by other instances. Calling the close() methods on the InputStream or OutputStream of an HttpURLConnection after a request may free network resources associated with this instance but has no effect on any shared persistent connection. Calling the disconnect() method may close the underlying socket if a persistent connection is otherwise idle at that time.\n\nThe HTTP protocol handler has a few settings that can be accessed through System Properties. This covers Proxy settings as well as various other settings.\n\nIf a security manager is installed, and if a method is called which results in an attempt to open a connection, the caller must possess either:-\n• a \"connect\" to the host/port combination of the destination URL or\n\nIf automatic redirection is enabled, and this request is redirected to another destination, then the caller must also have permission to connect to the redirected host/URL."
    },
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/index.html?java/net/HttpURLConnection.html",
        "document": "JavaScript is disabled on your browser.\n\nThis document is designed to be viewed using the frames feature. If you see this message, you are using a non-frame-capable web client. Link to Non-frame version."
    },
    {
        "link": "https://developer.android.com/reference/java/net/HttpURLConnection",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/10119067/java-httpurlconnection-class-program",
        "document": ""
    },
    {
        "link": "https://download.java.net/java/early_access/jdk24/docs/api/java.base/java/net/class-use/HttpURLConnection.html",
        "document": ""
    },
    {
        "link": "https://digitalocean.com/community/tutorials/java-httpurlconnection-example-java-http-request-get-post",
        "document": "The class from package can be used to send a Java HTTP Request programmatically. In this article, you will learn how to use in a Java program to send and requests and then print the response.\n\nFor this example, you should have completed the Spring MVC Tutorial because it has URLs for and HTTP methods.\n\nThe HTML of the login page contains the following form:\n\nYou can construct a request to:\n\nThis will serve as the basis for the example.\n\nHere are the steps for sending Java HTTP requests using class:\n• Create a object from the or URL String.\n• Call the method on the URL object that returns an instance of .\n• Set the request method in instance (default value is ).\n• Call method on instance to set request header values (such as , , etc).\n• We can call to get the response HTTP code. This way, we know if the request was processed successfully or if there was any HTTP error message thrown.\n• For , use and to read the response and process it accordingly.\n• For , before the code handles the response, it needs to get the from the instance and write parameters into it.\n\nHere is an example program that uses to send Java and requests:\n\nCompile and run the code. It will produce the following output:\n\nCompare this output to the browser HTTP response.\n\nIf you have to send and requests over HTTPS protocol, then you need to use instead of . will handle the SSL handshake and encryption.\n\nIn this article, you learned how to use in a Java program to send and requests and then print the response.\n\nContinue your learning with more Java tutorials."
    },
    {
        "link": "https://stackoverflow.com/questions/2793150/how-to-use-java-net-urlconnection-to-fire-and-handle-http-requests",
        "document": "First a disclaimer beforehand: the posted code snippets are all basic examples. You'll need to handle trivial s and s like , and consorts yourself.\n\nIn case you're developing for Android instead of Java, note also that since introduction of API level 28, cleartext HTTP requests are disabled by default. You are encouraged to use . When really necessary, cleartext can be enabled in the Application Manifest.\n\nIn case you're already on Java 11 or newer, then it's good to know that there's next to another API to deal with HTTP requests in a less verbose manner: .\n\nWe first need to know at least the URL and the charset. The parameters are optional and depend on the functional requirements.\n\nThe query parameters must be in format and be concatenated by . You would normally also URL-encode the query parameters with the specified charset using .\n\nThe is just for convenience. I prefer it when I would need the String concatenation operator more than twice.\n\nFiring an HTTP GET request with (optionally) query parameters\n\nIt's a trivial task. It's the default request method.\n\nAny query string should be concatenated to the URL using . The header may hint the server what encoding the parameters are in. If you don't send any query string, then you can leave the header away. If you don't need to set any headers, then you can even use the shortcut method.\n\nEither way, if the other side is an , then its method will be called and the parameters will be available by .\n\nFor testing purposes, you can print the response body to standard output as below:\n\nSetting the to implicitly sets the request method to POST. The standard HTTP POST as web forms do is of type wherein the query string is written to the request body.\n\nNote: whenever you'd like to submit a HTML form programmatically, don't forget to take the pairs of any elements into the query string and of course also the pair of the element which you'd like to \"press\" programmatically (because that's usually been used in the server side to distinguish if a button was pressed and if so, which one).\n\nYou can also cast the obtained to and use its instead. But if you're trying to use the connection for output you still need to set to .\n\nEither way, if the other side is an , then its method will be called and the parameters will be available by .\n\nYou can fire the HTTP request explicitly with , but the request will automatically be fired on demand when you want to get any information about the HTTP response, such as the response body using and so on. The above examples does exactly that, so the call is in fact superfluous.\n\nYou can use to set the connect timeout and to set the read timeout.\n\nThe default is basically \"no timeout\". So you'd like to set these yourself. For example:\n\nThere's however a caveat with the read timeout when using Sun/Oracle based JRE. It will silently retry the reading before throwing the timeout exception, most probably merely to have any successfull reading ready in the cache. See also Android (Java) HttpURLConnection silent retry on 'read' timeout This is okayish for GET, but absolutely wrong for POST. In case you're using a Sun/Oracle based JRE, you'll want to turn off that as follows:\n\nIn case you're writing for Android, above will not work, you'll need this work around on POST:\n\nThis will only slightly impact the performance. In case that's undesireable, then consider switching to a different HTTP client such as OkHttp.\n\nYou need an here. Cast it first if necessary.\n\nWhen the contains a parameter, then the response body is likely text based and we'd like to process the response body with the server-side specified character encoding then.\n\nThe server side session is usually backed by a cookie. Some web forms require that you're logged in and/or are tracked by a session. You can use the API to maintain cookies. You need to prepare a with a of before sending all HTTP requests.\n\nNote that this is known to not always work properly in all circumstances. If it fails for you, then best is to manually gather and set the cookie headers. You basically need to grab all headers from the response of the login or the first request and then pass this through the subsequent requests.\n\nThe is there to get rid of cookie attributes which are irrelevant for the server side like , , etc. Alternatively, you could also use instead of .\n\nThe will by default buffer the entire request body before actually sending it, regardless of whether you've set a fixed content length yourself using . This may cause s whenever you concurrently send large POST requests (e.g. uploading files). To avoid this, you would like to set the .\n\nBut if the content length is really not known beforehand, then you can make use of chunked streaming mode by setting the accordingly. This will set the HTTP header to which will force the request body being sent in chunks. The below example will send the body in chunks of 1 KB.\n\nIt can happen that a request returns an unexpected response, while it works fine with a real web browser. The server side is probably blocking requests based on the request header. The will by default set it to where the last part is obviously the JRE version. You can override this as follows:\n\nUse the User-Agent string from a recent browser.\n\nIf the HTTP response code is (Client Error) or (Server Error), then you may want to read the to see if the server has sent any useful error information.\n\nIf the HTTP response code is -1, then something went wrong with connection and response handling. The implementation is in older JREs somewhat buggy with keeping connections alive. You may want to turn it off by setting the system property to . You can do this programmatically in the beginning of your application by:\n\nYou'd normally use encoding for mixed POST content (binary and character data). The encoding is in more detail described in RFC2388.\n\nIf the other side is an , then its method will be called and the parts will be available by (note, thus not and so on!). Also see this answer for examples.\n\nIn case you're developing for Android instead of Java, be careful: the workaround below may save your day if you don't have correct certificates deployed during development. But you should not use it for production. These days (April 2021) Google will not allow your app be distributed on Play Store if they detect insecure hostname verifier, see https://support.google.com/faqs/answer/7188426.\n\nSometimes you need to connect an HTTPS URL, perhaps because you're writing a web scraper. In that case, you may likely face a on some HTTPS sites who doesn't keep their SSL certificates up to date, or a or on some misconfigured HTTPS sites.\n\nThe following one-time-run initializer in your web scraper class should make more lenient as to those HTTPS sites and thus not throw those exceptions anymore.\n\nIf all you want is parsing and extracting data from HTML, then better use a HTML parser like Jsoup.\n• What are the pros/cons of leading HTML parsers in Java\n• How to scan and extract a webpage in Java"
    },
    {
        "link": "https://stackoverflow.com/questions/25011927/how-to-get-response-body-using-httpurlconnection-when-code-other-than-2xx-is-re",
        "document": "I have problem with retrieving Json response in case when server returns error. See details below.\n\nI use . I setup request properties, then I do:\n\nAfter that, when request is successful, I get response Json:\n\n... and the problem is:\n\nI can't retrieve Json received when the server returns some error like 50x or 40x,. Following line throws IOException:\n\nThe server sends body for sure, I see it in external tool Burp Suite:\n\nI can get response message (i.e. \"Internal Server Error\") and code (i.e. \"500\") using following methods:\n\nBut I can't retrieve request body... maybe there is some method I didn't notice in the library?"
    },
    {
        "link": "https://twilio.com/en-us/blog/5-ways-to-make-http-requests-in-java",
        "document": "Making HTTP requests is a core feature of modern programming, and is often one of the first things you want to do when learning a new programming language. For Java programmers there are many ways to do it - core libraries in the JDK and third-party libraries. This post will introduce you to the Java HTTP clients that I reach for. If you use other ones, that’s great! Let me know about it. In this post I’ll cover:\n\n I’ll use the Astronomy Picture of the Day API from the NASA APIs for the code samples, and the code is all on GitHub in a project based on Java 11. Since Java 1.1 there has been an HTTP client in the core libraries provided with the JDK. With Java 11 a new client was added. One of these might be a good choice if you are sensitive about adding extra dependencies to your project. First of all, do we capitalize acronyms in class names or not? Make your mind up. Anyway, close your eyes and center yourself in 1997. Titanic was rocking the box office and inspiring a thousand memes, Spice Girls had a best-selling album, but the biggest news of the year was surely HttpURLConnection being added to Java 1.1. Here’s how you would use it to make a request to get the APOD data:\n\nThis seems quite verbose, and I find the order that we have to do things is confusing (why do we set headers after opening the URL?). If you need to make more complex requests with bodies, or custom timeouts etc then it’s all possible but I never found this API intuitive at all. When would you use , then? If you are supporting clients who are using older versions of Java, and you can’t add a dependency then this might be for you. I suspect that’s only a small minority of developers, but you might see it in older codebases - for more modern approaches, read on. More than twenty years after we had Black Panther in the cinemas and a new HTTP client added to Java 11: . This has a much more logical API and can handle HTTP/2, and Websockets. It also has the option to make requests synchronously or asynchronously by using the API. 99 times out of 100 when I make an HTTP request I want to read the response body into my code. Libraries that make this difficult will not spark joy in me. HttpClient accepts a which can convert an HTTP response into a class of your choosing. There are some built-in handlers: , for binary data, which splits by lines, and a few others. You can also define your own, which might be helpful as there isn’t a built-in for parsing JSON. I’ve written one (here) based on Jackson following an example from Java Docs. It returns a for the APOD class, so we call when we need the result.\n\nIf the built-in clients don’t work for you, don’t worry! There are plenty of libraries you can bring into your project which will do the job. The Apache Software Foundation’s HTTP clients have been around for a long time. They’re widely-used and are the foundation for a lot of higher-level libraries. The history is a little confusing. The old Commons HttpClient is no longer being developed, and the new version (also called HttpClient), is under the HttpComponents project. Version 5.0 was released in early 2020, adding HTTP/2 support. The library also supports synchronous and asynchronous requests. Overall the API is rather low-level - you are left to implement a lot for yourself. The following code calls the NASA API. It doesn’t look too hard to use but I have skipped a lot of the error handling which you would want in production code and again I had to add Jackson code to parse the JSON response. You might also want to configure a logging framework to avoid warnings on stdout (no big deal, but it does irk me a bit). Anyway here’s the code:\n\nThis is fine, but the real power of OkHttp is clear when you add Retrofit over the top. Retrofit is another library from Square, built on top of OkHttp. Along with all the low-level features of OkHttp it adds a way to build Java classes which abstract the HTTP details and present a nice Java-friendly API. First, we need to create an interface which declares the methods we want to call against the APOD API, with annotations defining how those correspond to HTTP requests:"
    },
    {
        "link": "https://techforum.ewon.biz/printthread.php?tid=1047",
        "document": "Using JAVA to send HTTPS POST and GET requests - AndreasABB - 17-10-2019 \n\n \n\n Hi,\n\n \n\n I've been working with an eWON Flexy 205 for a short amount of time now. I have an application (Java 11) which obviously needs to be refactored to Java 1.4.4. So far I've managed to adapt. However, I cannot find any usefull information about how to send HTTPS POST and HTTPS GET requests. I've been told it's possible, but so far I've had no luck. \n\n \n\n I've read all eWON Java pdf's I could find, as well as the BASIC User Guide.\n\n \n\n I need to be able to read the HTTPS response as well.\n\n \n\n Kind regards,\n\n Andreas\n\n \n\n TL;DR:\n\n How to send HTTPS GET and POST requests and how to read them using java? \n\n \n\n RE: Using JAVA to send HTTPS POST and GET requests - simon - 17-10-2019 \n\n \n\n Andreas,\n\n \n\n The only way to do is to use the REQUESTHTTPX function (in ScheduleActionManager class).\n\n This function allows you to customize the header and the body to send and you get the response into a file.\n\n \n\n Simon \n\n \n\n RE: Using JAVA to send HTTPS POST and GET requests - AndreasABB - 18-10-2019 \n\n \n\n Hi Simon,\n\n \n\n First of all, thanks for the quick reply.\n\n \n\n Second, is there an example somewhere that I could look into or an API of some sort regarding both using RequestHttpX() and retrieving data from a HTTPS Response?\n\n \n\n Thanks in advance, \n\n Kind regards,\n\n Andreas \n\n \n\n RE: Using JAVA to send HTTPS POST and GET requests - simon - 30-10-2019 \n\n \n\n Andreas,\n\n \n\n The function usage is the same as in BASIC except that the RESPONSEHTTPX is not implemented in JAVA.\n\n So, you should have a look at the BASIC manual : https://developer.ewon.biz/content/basic-1\n\n \n\n Simon \n\n \n\n RE: Using JAVA to send HTTPS POST and GET requests - AndreasABB - 31-10-2019 \n\n \n\n Simon,\n\n \n\n I've tried that, but I cannot figure out how it works.\n\n \n\n Perhaps some code of what I'm trying to do helps:\n\n try {\n\n java.net.URL url = new URL(URL);\n\n HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n\n connection.setRequestMethod(\"POST\");\n\n connection.setRequestProperty(\"Content-Type\", \"application/json\");\n\n connection.setDoOutput(true);\n\n \n\n connection.connect();\n\n //write request body with JSON\n\n OutputStreamWriter wr = new OutputStreamWriter(connection.getOutputStream());\n\n \n\n wr.write(RequestJSONAuthBody);\n\n wr.close();\n\n \n\n System.out.println(connection.getResponseCode());\n\n \n\n //read response body\n\n InputStream in = connection.getInputStream();\n\n BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n\n StringBuilder result = new StringBuilder();\n\n String line;\n\n while ((line = reader.readLine()) != null) {\n\n result.append(line);\n\n }\n\n connection.disconnect();\n\n \n\n JSONParser parser = new JSONParser();\n\n \n\n Object o = parser.parse(result.toString());\n\n JSONObject data = (JSONObject) o;\n\n authToken = (String) data.get(\"authToken\");\n\n organizationID = (Long) data.get(\"organizationID\");\n\n \n\n } catch (Exception e) {\n\n System.out.println(e.getMessage());\n\n } This is what I have accomplished with HttpUrlConnection, obviously I cannot use it on an eWON.\n\n \n\n Thanks in advance,\n\n Andreas \n\n \n\n RE: Using JAVA to send HTTPS POST and GET requests - simon - 07-11-2019 \n\n \n\n Andreas,\n\n \n\n \n\n \n\n The equivalent should be :\n\n \n\n int status = com.ewon.ewonitf.ScheduledActionManager.RequestHttpX(\"https://web.com\", \n\n \"POST\", \n\n \"Content-Type=application/json\", \n\n \"{data:test}\", \n\n \"\", \n\n \"/usr/response.txt\");\n\n \n\n if (status == 0)\n\n {\n\n FileConnection File = (FileConnection) Connector.open(\"file:////usr/response.txt\");\n\n if (!File.exists()) {\n\n Utils.realTimeLog(\"File \" + Path + \" not found\", 1, param_logLevel);\n\n return;\n\n }\n\n \n\n InputStream reader = File.openInputStream();\n\n String line = null;\n\n \n\n while ((line = Utils.readLine(reader)) != null) {\n\n \n\n //Read Response\n\n }\n\n reader.close();\n\n File.close();\n\n }\n\n \n\n public static String readLine(InputStream reader) throws IOException {\n\n // Test whether the end of file has been reached. If so, return null.\n\n int readChar = reader.read();\n\n if (readChar == -1) {\n\n return null;\n\n }\n\n StringBuffer string = new StringBuffer(\"\");\n\n // Read until end of file or new line\n\n while (readChar != -1 && readChar != '\n\n') {\n\n if (readChar != '\\r') {\n\n string.append((char)readChar);\n\n }\n\n // Read the next character\n\n readChar = reader.read();\n\n }\n\n return string.toString();\n\n } \n\n Hope it helps\n\n \n\n Simon \n\n \n\n RE: Using JAVA to send HTTPS POST and GET requests - LewisH304 - 29-11-2019 \n\n \n\n package com.journaldev.utils;\n\n \n\n import java.io.BufferedReader;\n\n import java.io.IOException;\n\n import java.io.InputStreamReader;\n\n import java.io.OutputStream;\n\n import java.net.HttpURLConnection;\n\n import java.net.URL;\n\n \n\n public class HttpURLConnectionExample {\n\n \n\n private static final String USER_AGENT = \"Mozilla/5.0\";\n\n \n\n private static final String GET_URL = \"http://localhost:9090/SpringMVCExample\";\n\n \n\n private static final String POST_URL = \"http://localhost:9090/SpringMVCExample/home\";\n\n \n\n private static final String POST_PARAMS = \"userName=Pankaj\";\n\n \n\n public static void main(String[] args) throws IOException {\n\n \n\n sendGET();\n\n System.out.println(\"GET DONE\");\n\n sendPOST();\n\n System.out.println(\"POST DONE\");\n\n }\n\n \n\n private static void sendGET() throws IOException {\n\n URL obj = new URL(GET_URL);\n\n HttpURLConnection con = (HttpURLConnection) obj.openConnection();\n\n con.setRequestMethod(\"GET\");\n\n con.setRequestProperty(\"User-Agent\", USER_AGENT);\n\n int responseCode = con.getResponseCode();\n\n System.out.println(\"GET Response Code :: \" + responseCode);\n\n if (responseCode == HttpURLConnection.HTTP_OK) { // success\n\n BufferedReader in = new BufferedReader(new InputStreamReader(\n\n con.getInputStream()));\n\n String inputLine;\n\n StringBuffer response = new StringBuffer();\n\n \n\n while ((inputLine = in.readLine()) != null) {\n\n response.append(inputLine);\n\n }\n\n in.close();\n\n \n\n // print result\n\n System.out.println(response.toString());\n\n } else {\n\n System.out.println(\"GET request not worked\");\n\n }\n\n \n\n }\n\n \n\n private static void sendPOST() throws IOException {\n\n URL obj = new URL(POST_URL);\n\n HttpURLConnection con = (HttpURLConnection) obj.openConnection();\n\n con.setRequestMethod(\"POST\");\n\n con.setRequestProperty(\"User-Agent\", USER_AGENT);\n\n \n\n // For POST only - START\n\n con.setDoOutput(true);\n\n OutputStream os = con.getOutputStream();\n\n os.write(POST_PARAMS.getBytes());\n\n os.flush();\n\n os.close();\n\n // For POST only - END\n\n \n\n int responseCode = con.getResponseCode();\n\n System.out.println(\"POST Response Code :: \" + responseCode);\n\n \n\n if (responseCode == HttpURLConnection.HTTP_OK) { //success\n\n BufferedReader in = new BufferedReader(new InputStreamReader(\n\n con.getInputStream()));\n\n String inputLine;\n\n StringBuffer response = new StringBuffer();\n\n \n\n while ((inputLine = in.readLine()) != null) {\n\n response.append(inputLine);\n\n }\n\n in.close();\n\n \n\n // print result\n\n System.out.println(response.toString());\n\n } else {\n\n System.out.println(\"POST request not worked\");\n\n }\n\n }\n\n \n\n } Try this code! Hope they help you!\n\n Regards,\n\n Lewis \n\n \n\n RE: Using JAVA to send HTTPS POST and GET requests - simon - 03-12-2019 \n\n \n\n Hi Lewis,\n\n \n\n The java.net.HttpURLConnection class is unfortunately not supported by our JVM.\n\n You must use the proprietary function REQUESTHTTPX.\n\n \n\n Simon \n\n \n\n RE: Using JAVA to send HTTPS POST and GET requests - LewisH304 - 04-04-2020 \n\n \n\n Below are the steps we need to follow for sending Java HTTP requests using HttpURLConnection class.\n\n \n\n Create URL object from the GET/POST URL String.\n\n Call openConnection() method on URL object that returns instance of HttpURLConnection\n\n Set the request method in HttpURLConnection instance, default value is GET.\n\n Call setRequestProperty() method on HttpURLConnection instance to set request header values, such as “User-Agent” and “Accept-Language” etc.\n\n We can call getResponseCode() to get the response HTTP code. This way we know if the request was processed successfully or there was any HTTP error message thrown.\n\n For GET, we can simply use Reader and InputStream to read the response and process it accordingly.\n\n For POST, before we read response we need to get the OutputStream from HttpURLConnection instance and write POST parameters into it. \n\n \n\n RE: Using JAVA to send HTTPS POST and GET requests - simon - 08-04-2020 \n\n \n\n Again, this class is NOT supported by the Ewon Flexy JVM.\n\n Use the ScheduleActionsManager to get the proper functions to send or read data through HTTP(S) \n\n \n\n RE: Using JAVA to send HTTPS POST and GET requests - esp70 - 07-05-2020 \n\n \n\n Again, this class is NOT supported by the Ewon Flexy JVM.\n\n Use the ScheduleActionsManager to get the proper functions to send or read data through HTTP(S) Hey Simon-\n\n \n\n New user here and I am trying to organize my project goals. HTTP POST/GETs are a priority to understand if there are limitations with the Flexy. \n\n \n\n I see you say that the HttpURLConnection is not supported by the Ewon Flexy JVM, yet it is a part of the java.net package that is included in the javaetk.jar (java 1.4). \n\n \n\n I do not have access to an eWON Flexy at all times of development, and if you are correct, then how do I know what the JVM will run without testing each and every Java class individually within Flexy? I would think that the Flexy JVM could run every class that is within the javaetk.jar?? I am hoping that I misunderstood your answer but it sure does seem like we should be able to use all classes within the javaetk.jar that compiles to it in eclipse. \n\n \n\n Best Regards,\n\n Eric \n\n \n\n RE: Using JAVA to send HTTPS POST and GET requests - simon - 07-05-2020 \n\n \n\n Hi Eric,\n\n \n\n I have finally tested the class by myself and it partially works.\n\n Actually I have used an example based on https://www.journaldev.com/7148/java-httpurlconnection-example-java-http-request-get-post\n\n I have tried to connect to an url with a name (http://mysite.com) and it returned a DNS error.\n\n By using an IP it worked. So it seems there is a problem with the DNS resolution when using this class.\n\n If I use an HTTPS link, it clearly states that the HTTPS is NOT implemented.\n\n \n\n So, in short, if you want to use HTTPS and/or a name into the url, you must use the RequestHttpX() function.\n\n \n\n 2020-05-07_19-01-41.png (Size: 35,61 KB / Downloads: 20) \n\n \n\n See also https://hmsnetworks.blob.core.windows.net/www/docs/librariesprovider10/downloads-monitored/manuals/knowledge-base/kb-0256-00-en-get-put-https-request-using-basic-script-or-java.pdf?sfvrsn=166256d7_6\n\n \n\n So, yes, everything that is in the javaetk.jar should be supported, but that is not always true unfortunately.\n\n If you tell me more about the project, I may be able to tell you if it is possible and what functions to use.\n\n \n\n Simon \n\n \n\n RE: Using JAVA to send HTTPS POST and GET requests - esp70 - 08-05-2020 \n\n \n\n Hi Eric,\n\n \n\n I have finally tested the class by myself and it partially works.\n\n Actually I have used an example based on https://www.journaldev.com/7148/java-httpurlconnection-example-java-http-request-get-post\n\n I have tried to connect to an url with a name (http://mysite.com) and it returned a DNS error.\n\n By using an IP it worked. So it seems there is a problem with the DNS resolution when using this class.\n\n If I use an HTTPS link, it clearly states that the HTTPS is NOT implemented.\n\n \n\n So, in short, if you want to use HTTPS and/or a name into the url, you must use the RequestHttpX() function.\n\n \n\n \n\n See also https://hmsnetworks.blob.core.windows.net/www/docs/librariesprovider10/downloads-monitored/manuals/knowledge-base/kb-0256-00-en-get-put-https-request-using-basic-script-or-java.pdf?sfvrsn=166256d7_6\n\n \n\n So, yes, everything that is in the javaetk.jar should be supported, but that is not always true unfortunately.\n\n If you tell me more about the project, I may be able to tell you if it is possible and what functions to use.\n\n \n\n Simon \n\n Simon,\n\n \n\n Thank you for the quick reply!\n\n For the HTTP portion of my project, I have to make sure that we can push zipped files (hopefully the zip libraries work!!) to a HTTP server. In fact, I would like to stream the files with Multipart form data or as an Octet stream if possible.\n\n Again, I do not have a Flexy currently to test this, I would just setup my eclipse to perform the testing on my server.\n\n \n\n On a side note...is there any source code for javaetk that are posted? It seems like that would go a long way at understanding the system?\n\n \n\n Regards,\n\n Eric \n\n \n\n RE: Using JAVA to send HTTPS POST and GET requests - simon - 11-05-2020 \n\n \n\n Hi Eric,\n\n \n\n Yes, zipping a file should work.\n\n \n\n I have already tested that and it worked (but it may take some time according to the size of the file to zip):\n\n public static void main(String[] args) throws Exception {\n\n \n\n \n\n System.out.println(\"zip starting\");\n\n \n\n FileWriter fileWriter = new FileWriter(\"/usr/t.txt\", true);\n\n fileWriter.write(\"test2\");\n\n fileWriter.close();\n\n \n\n File f = new File(\"/usr/events.txt\");\n\n \n\n zipFile(f, \"/usr/t.zip\"); \n\n System.out.println(\"zip end\");\n\n \n\n }\n\n \n\n public static void zipFile(File inputFile, String zipFilePath) {\n\n \n\n try {\n\n \n\n \n\n \n\n // Wrap a FileOutputStream around a ZipOutputStream\n\n // to store the zip stream to a file. Note that this is\n\n // not absolutely necessary\n\n FileOutputStream fileOutputStream = new FileOutputStream(zipFilePath);\n\n ZipOutputStream zipOutputStream = new ZipOutputStream(fileOutputStream);\n\n \n\n // a ZipEntry represents a file entry in the zip archive\n\n // We name the ZipEntry after the original file's name\n\n ZipEntry zipEntry = new ZipEntry(inputFile.getName());\n\n zipOutputStream.putNextEntry(zipEntry);\n\n FileInputStream fileInputStream = new FileInputStream(inputFile);\n\n \n\n byte[] buf = new byte[(int)(inputFile.length()/2)];\n\n int bytesRead;\n\n \n\n // Read the input file by chucks of 1024 bytes\n\n // and write the read bytes to the zip stream\n\n \n\n while ((bytesRead = fileInputStream.read(buf)) > 0) {\n\n \n\n zipOutputStream.write(buf, 0, bytesRead);\n\n }\n\n // close ZipEntry to store the stream to the file\n\n zipOutputStream.closeEntry();\n\n \n\n zipOutputStream.close();\n\n fileOutputStream.close();\n\n \n\n // System.out.println(\"Regular file :\" + inputFile.getCanonicalPath()+\" is zipped to archive :\"+zipFilePath);\n\n \n\n } catch (IOException e) {\n\n \n\n e.printStackTrace();\n\n \n\n }\n\n \n\n } \n\n Regarding the Data post, the multipart form data is what the PUTHTTP or REQUESTHTTPX functions do when you define some files to upload (4th arg of PUTHTTP function and 5th arg of the RequesHttpX function). You can refer to the BASIC manual for that (functions definition are very similar) https://developer.ewon.biz/system/files_force/rg-0006-01-en-basic-programming.pdf?download=1.\n\n \n\n Simon"
    }
]