[
    {
        "link": "https://dev.epicgames.com/documentation/en-us/unreal-engine/smart-pointers-in-unreal-engine",
        "document": "The Unreal Smart Pointer Library is a custom implementation of C++11 smart pointers designed to ease the burden of memory allocation and tracking. This implementation includes the industry standard Shared Pointers, Weak Pointers, and Unique Pointers. It also adds Shared References which act like non-nullable Shared Pointers. These classes cannot be used with the system because Unreal Objects use a separate memory-tracking system that is better-tuned for game code.\n\nSmart Pointers can affect the lifespan of the object they contain or reference. Different Smart Pointers have different limitations and effects on the object. The following table can be used to help determine when it is appropriate to use each type of Smart Pointer:\n\nThe Unreal Smart Pointer Library provides several helper classes and functions to make using Smart Pointers easier and more intuitive.\n\nSmart Pointers in the Unreal Smart Pointer Library all share some general characteristics in terms of functionality and efficiency.\n\nAlways keep performance in mind when considering using Smart Pointers. Smart Pointers are well-suited for certain high-level systems, resource management, or tools programming. However, some Smart Pointer types are slower than raw C++ pointers, and this overhead makes them less useful in low-level engine code, such as rendering.\n\nSome of the general performance benefits of Smart Pointers are:\n• Dereferencing most Smart Pointers is just as fast as raw C++ pointers (in shipping builds).\n• Creating and copying Smart Pointers involves more overhead than creating and copying raw C++ pointers.\n• Some Smart Pointers use more memory than raw C++ pointers.\n• There are two heap allocations for reference controllers. Using instead of avoids the second allocation, and can improve performance.\n\nShared pointers are non-intrusive, which means the object does not know whether or not a Smart Pointer owns it. This is usually acceptable, but there may be cases in which you want to access the object as a Shared Reference or Shared Pointer. To do this, derive the object's class from , using the object's class as the template parameter. provides two functions, and , that can convert the object to a Shared Reference (and from there, to a Shared Pointer). This can be useful with class factories that always return Shared References, or when you need to pass your object to a system that expects a Shared Reference or Shared Pointer. will return your class as the type originally passed as the template argument to , which may be a parent type to the calling object, while will derive the type directly from this and return a Smart Pointer referencing an object of that type. The following example code demonstrates both functions:\n\nDo not call or from constructors, since the shared reference is not initialized at that time and will cause a crash or assert.\n\nYou can cast Shared Pointers (and Shared References) through several support functions included in the Unreal Smart Pointer Library. Up-casting is implicit, as with C++ pointers. You can const cast with the function, and static cast (often to downcast to derived class pointers) with . Dynamic casting is not supported, as there is no run-type type information (RTTI); static casting should be used instead, as in the following code:\n\nBy default, Smart Pointers are only safe to access on a single thread. If you need multiple threads to have access, use the thread-safe versions of Smart Pointer classes:\n\nThese thread-safe versions are a bit slower than the defaults due to atomic reference counting, but their behavior is consistent with regular C++ pointers:\n• Reads and copies are always thread-safe.\n• Writes and resets must be synchronized to be safe.\n• Avoid passing data to functions as or parameters where possible, as these will incur overhead by dereferencing and reference-counting. Instead, pass the referenced object, preferably as a .\n• You can forward-declare Shared Pointers to incomplete types.\n• Shared Pointers are not compatible with Unreal objects ( and its derived classes). The Engine has a separate memory management system (see Object Handling documentation) for management, and the two systems have no overlap with each other."
    },
    {
        "link": "https://forums.unrealengine.com/t/smart-pointers/156129",
        "document": "In the first link there is a section that shows why to use them as succinctly as possible. **Prevents memory leaks** Smart Pointers (other than Weak Pointers) automatically delete objects when there are no more shared references. **Weak referencing** Weak Pointers break reference cycles and prevent dangling pointers. **Optional Thread safety** The Unreal Smart Pointer Library includes thread-safe code that manages reference counting across multiple threads. Thread safety can be traded out for better performance if it isn't needed. **Runtime safety** Shared References are never null and can always be dereferenced. **Confers intent** You can easily tell an object owner from an observer. **Memory** Smart Pointers are only twice the size of a C++ pointer in 64-bit (plus a shared 16-byte reference controller). The exception to this is Unique Pointers, which are the same size as C++ pointers.\n\nIn C++ you need to manage the objects on the heap manually. But depending on where your objects are used, its not possible to know if it is valid to delete the objekt yet. Also you need to remember to delete them. Smart pointers simply prevent those issues by wrapping the pointer in a class with management functionality. Smart Pointers are not spefic to Unreal. C++ has smart pointer classes per default. There is enough documentation on them online.\n\nI know this kind of thing is not very well-explained. Here is a quick rundown on the ones you asked about: TSharedPtr is a hard reference to an object that multiple other objects share communally. UE keeps track of the number of references to a given object this way and when all references to an object are released (manually) then the referenced object is destroyed. This type of reference can be null. TSharedRef works similarly but is always expected to be valid. Use TSharedPtr when declaring a variable in a class that will reference something else, like a widget perhaps, but make sure you check a TSharedPtr for validity before using it. If you’re declaring a defining a reference at the same time you can use TSharedRef. If it’s a local ref inside a function, it will be destroyed at the end of the function. If it’s a class variable, make sure you release TSharedPtrs manually at the end of the container class’ life cycle to avoid dangling pointers. TWeakObjectPtr works like TSharedPtr but it doesn’t increment the reference count. If all other TSharedPtrs to an object are released or destroyed but you still have a TWeakObjectPtr to that object then the object in question will still be destroyed because its reference count will be 0 because the TWeakObjectPtr doesn’t count. You should still release TWeakObjectPtrs when you’re done with them, but the lifetime of the referenced object will not be affected by a TWeakObjectPtr. A weak pointer is basically an object that tells you information about a raw pointer, like whether or not it’s been deallocated, without affecting the lifetime of the object the raw pointer points to. TUniquePtr sort of locks an object to a single reference that manages it. If an object has a TUniquePtr wrapped around it, no other object can reference it unless ownership is explicitly passed to another managing object. You can use this to make sure only one object controls the lifetime of another. When a TUniquePtr is destroyed or reassigned, the wrapped object is also destroyed. Try not to pass smart pointers as parameters, though. Just pass raw pointers. Save smart pointers as class or function members depending on your needs.\n\nI know this kind of thing is not very well-explained. Here is a quick rundown on the ones you asked about: TSharedPtr is a hard reference to an object that multiple other objects share communally. UE keeps track of the number of references to a given object this way and when all references to an object are released (manually) then the referenced object is destroyed. This type of reference can be null. TSharedRef works similarly but is always expected to be valid. Use TSharedPtr when declaring a variable in a class that will reference something else, like a widget perhaps, but make sure you check a TSharedPtr for validity before using it. If you’re declaring a defining a reference at the same time you can use TSharedRef. If it’s a local ref inside a function, it will be destroyed at the end of the function. If it’s a class variable, make sure you release TSharedPtrs manually at the end of the container class’ life cycle to avoid dangling pointers. TWeakObjectPtr works like TSharedPtr but it doesn’t increment the reference count. If all other TSharedPtrs to an object are released or destroyed but you still have a TWeakObjectPtr to that object then the object in question will still be destroyed because its reference count will be 0 because the TWeakObjectPtr doesn’t count. You should still release TWeakObjectPtrs when you’re done with them, but the lifetime of the referenced object will not be affected by a TWeakObjectPtr. A weak pointer is basically an object that tells you information about a raw pointer, like whether or not it’s been deallocated, without affecting the lifetime of the object the raw pointer points to. TUniquePtr sort of locks an object to a single reference that manages it. If an object has a TUniquePtr wrapped around it, no other object can reference it unless ownership is explicitly passed to another managing object. You can use this to make sure only one object controls the lifetime of another. When a TUniquePtr is destroyed or reassigned, the wrapped object is also destroyed. Try not to pass smart pointers as parameters, though. Just pass raw pointers. Save smart pointers as class or function members depending on your needs. I couldn’t thank you enough for all of this information, I now understand much more than I thought I could about this topic"
    },
    {
        "link": "https://unrealcommunity.wiki/6100e8119c9d1a89e0c319c4",
        "document": "There are a few different memory management systems in UE4: garbage collection, smart pointers, and standard C++ memory management.\n\n, UE4 will automatically add them to its internal objects list, so even with improper use, it's not easy to have memory leaks, but it is easy to cause crashes. UObjects should never be created with\n\n, but only with their default creation methods (\n\nObjects are primarily kept alive in 3 ways:\n• By having a strong reference ( ) to them (from objects or structs that are also referenced)\n• By adding them to the list of (from objects or structs that are also referenced)\n• By adding them to the root set with (typically unnecessary)\n\nWhen objects do not fulfill any of the above conditions, on the next GC cycle they will be marked as unreachable and garbage collected (destroyed).\n\n Having an object as an Outer of another object does automatically not mean it will be kept alive, the same goes for default subobjects.\n\nTo force the destruction of objects that are still reachable, you can call\n\non them, and it will force their destruction on the next GC cycle (you generally want to avoid doing this as that is what the garbage collection is for, and some classes, like\n\ndo not support it).\n\n The destruction of an object doesn't necessarily all happen in the same frame, when garbage collection starts on it, it will first call\n\n(do not call this yourself), then, when ready\n\n.\n\n The GC runs in the game thread so it won't ever run as you are accessing an object from the game thread.\n\nWhile the most common way of keeping alive objects is through a\n\n, actors and components work differently:\n\n levels reference their actors and actors reference their components. Both work by overriding the\n\nimplementation and collecting what they do not want to be garbage collected. This means that even if there are no strong references to actors and components with an owner, they won't be garbage collected until manually destroyed, or their level is unloaded.\n\nThe garbage collector will clear references to garbage collected objects in any of these cases[1]:\n• A raw pointer declared with (it will be set as nullptr)\n• In a compatible container, such as , , or , if declared with (the affected elements will be set as nullptr but not removed)\n• In a (the reference isn't exactly cleared in this case but calling will now return nullptr)\n\n, it has to deal with the possibility that\n\nis called on the actor or\n\nis called on the component. These functions will mark them for pending kill, thus triggering their garbage collection at the first chance it gets (note that destroying an actor also destroys all its component). Since the garbage collector automatically nulls out\n\npointers when it actually gets to destroy them, null-checking an actor or component pointer is sufficient to know it's safe to use, though you might also want to check\n\non them to avoid accessing them after they have been marked for destruction (\n\nalready checks for this when retrieving the raw pointer).\n\nis a global function that automatically checks if an object pointer is non-null and not pending kill.\n\nshould not be used for GC checks, as on\n\npointers it will always return true, while on raw pointer it will return true or false depending whether the object had already been destroyed, but in the latter case it's also likely to crash the application as the pointed memory could have been overwritten.\n\nIf you write your own non-garbage classes that references garbage collected objects, you may want to sub-class\n\nThe GC will run every x seconds, though it's possible to force it's execution at any time. Given that for technical reasons the GC needs to go through every UObject in the same pass (it can't split reference counting over multiple frames), the bigger is the number of UObjects and the more UPROPERTY pointers these objects have, the slower the GC pass will be. The time taken by a pass will also be determined by the amount of objects it needs to destroy.\n\nThe Unreal Smart Pointer Library is for code that is not based on the UObject system. It is similar in function to the C++11 standard library smart pointers. Unreal Smart Pointers cannot be used to reference UObjects, because the garbage collector isn't aware of smart pointers[2].\n• Objects - Explanations of the basic gameplay elements, Actors and Objects\n• Unreal Object Handling - Overview of the features of the UObject system"
    },
    {
        "link": "https://incredibuild.com/blog/modern-memory-management-using-smart-pointers-in-c23-part-2",
        "document": ""
    },
    {
        "link": "https://educatedguesswork.org/posts/memory-management-3",
        "document": "This is the third post in my planned multipart series on memory management. In part I we covered the basics of memory allocation and how it works in C, and in part II we covered the basics of C++ memory management, including the RAII idiom for memory management. In this post, we'll be looking at a powerful technique called \"smart pointers\" that lets you use RAII-style idioms but for pointers rather than objects.\n\nWhy do you want pointers? #\n\nRecall from before that I said that if you want to use RAII you need to store an actual object on the stack, not a pointer to the object, because if the object is on the heap, it won't be cleaned up when the function exits. This is an annoying limitation.\n\nFor example, suppose we want to write a function which hashes the contents of the file, returning a single string containing the hash. With just one hash function, that might look like this:\n\nOur hash function is just an object with two methods:\n• which returns the hash value.\n\nThis works fine, but what happens if we want to support more than one hash function, for instance SHA-1, SHA-256, etc. One way to do this is to have the caller of the function provide the name in a string, i.e.,\n\nInternally, we'd have what's called a factory functionthat makes a hashing object given the string name. I.e.,\n\nAll of the concrete hashers (e.g., ) inherit from and returns an instance of the desired hash object. Because of inheritance, we can just assign all of them to . This gives us a function like the following:\n\nSo far so good, but now instead of having an instance of on the stack we have an instance of on the heap and it leaks when the function returns. So much for RAII. Fortunately, it's possible to recover RAII semantics in a generic way using a \"smart pointer\".\n\nWhat's a smart pointer and why is it smart? #\n\nAt a high level, a smart pointer is an object that can be used as if it were a pointer but has better semantics. For instance, C++ provides stack-like RAII properties for objects on the heap. It gets used like this:\n\nThis is literally the only change we have to make. From there on, we can use , which is actually a holding ,as if it were a . When goes out of scope out the end of the function, the pointer it's holding will be freed, just as if the hasher object itself were on the stack.\n\nC++ has a number of different smart pointer types built into it, but first I want to look at how you actually implement a smart pointer.\n\nSuppose, for example, we want to implement a -like for . For starters, we need a class that holds a and destroys it on destruction:\n\nThis is actually enough to give us RAII behavior: we can create a in the usual way and when it goes out of scope it will be destroyed along with the hasher object inside:\n\nThis isn't really a smart pointer, though, it's just a container for the object. If we want to do anything with object inside, we somehow need to get at the pointer. The obvious thing is to just provide a function called that gives you the pointer:\n\nThis is called \"unboxing\" because we have the pointer in a box (the smart pointer) but now we take it out to use it. Unboxing will work, but now we have to change all the code which previously used as if it were a pointer to use :\n\nYuck! Not only is this a pain in the ass, but it undercuts the whole thing we are trying to do here, which is to avoid having to work with the raw pointer.\n\nFortunately, C++ has a feature that makes this unnecessary because we can use operator overloading. In part II, we overloaded the copy assignment operator but here we are going to overload the operator instead so that acts like . The code for that looks like this:\n\nYou don't need to worry too much about the syntax, but the net effect is that when you use with it acts like you were using with the internal pointer, which is what we want. Here's our new code:\n\nThe only line that's changed from our original code is the one marked where we create the but now we've eliminated the memory leak.\n\nThis is a smart pointer after the fact, but it's kind of a dumb one. There are at least two big problems:\n\nIt's good to be unique #\n\nConsider the following code:\n\nAs we saw in part I, this will invoke the copy constructor. Because we haven't defined a copy constructor, we end up with the default one which makes a shallow copy, with the result that and both point to the same instance of . When the function ends they will both try to it, which leads to a double free, with the following error:\n\nAs expected, the destructor for fires twice, but with the same pointer ( ). In this case, the implementation has chosen to generate an error and crash the program for the double (note that the error is in because this C++ implementation of is based on ), but that's just whoever wrote it doing you a favor. As noted in post I, anything could happen at this point, but whatever it is is likely to be bad. This is definitely a defect and quite possibly a vulnerability.\n\nWhat we want to do is make this case impossible, which is to say to make actually unique. By this point it should be clear how to do this: we're going to overload the copy constructor and the copy assignment operator. With what we know now, the obvious thing to do is to just make them abort, like so:\n\nThis works in some sense, but it's a runtime error, which means that our program will crash if we try to copy a but that the compiler won't catch it so the program will still compile. Moreover, there's no guarantee that the failure will be this safe; it could easily be a serious vulnerability via use after free.\n\nWhat we really want is a compile time guarantee. The old way to do this was to make the copy constructor so that it wasn't possible to call it, but the new way (as of C++-11) is to mark it with :\n\nIf we then try to construct a new from an existing one, we get the somewhat helpful error:\n\nIf we do the same thing for the copy assignment operator, we've then prevented anyone from making a second pointing to the same underling object. Well, sort of.\n\nIt's true that if we do all of this you can't make another from an existing one, but nothing stops you from making two s from the same pointer:\n\nThe obvious answer is \"don't do that then\" but we're just depending on programmer discipline, because the compiler won't stop you. How is it to know you didn't want that outcome (and later we'll see an example of where this kind of thing is totally legitimate, if slightly inadvisable)?\n\nOK, so now have a unique pointer, but this is pretty limited. While we don't want to be able to make a copy of a unique pointer (that's what makes it unique), sometimes we want to move an object from one unique pointer to another. For example, suppose we have created an object but we want to store it in a container, like a vector. This presents two problems:\n• We want the vector to own it so our destructor doesn't destroy it when it goes out of scope.\n• The vector may need to move the object around when it reallocates its own memory to grow or shrink.\n\nThe key thing here is that we want to preserve the uniqueness guarantee. After we do , we want to be holding the pointer and not to be.\n\nUnsurprisingly, we're going to do this with the move assignment operator, which we saw in part I. It looks something like this:\n\nThe move assignment operator does two things:\n• It sets the field in the new smart pointer (the one being moved to) to point to the object that is being held.\n• It invalidates the field in the original pointer (the one being moved away from) by setting it to .\n\nPut together, these will prevent the object from being destroyed when the source smart pointer is destroyed. We also want to make sure that any use of the old smart pointer fails cleanly, so we should add a check in the implementation:\n\nWe'll also need to implement the move constructor, which is basically the same as the move assignment operator.\n\nThis is all fine, but note that we haven't written a generic unique pointer class, but instead one that only works for . If we want one for a new class called we need to write it all again, or rather we need to take the class and globally replace with (and better hope you don't have anything called because it will become ). Fortunately, C++ offers a better way of doing this: templates.\n\nThe idea with templates is to let the compiler do that search and replace for you, which obviously works a lot better than text replacement. We do this by making a version of the class with a placeholder typename (conventionally ) instead of the actual concrete typename, like so:\n\nNote that we're going to call this rather than to avoid confusing it with C++'s built-in implementation.\n\nThe syntax tells C++ that this is a template and that the name of the placeholder type is (as an aside, you can have multiple placeholder types). When you actually go to use the template class, you tell it what type you want to make a unique pointer for and the compiler replaces the s with that typename, producing a new version of the class that is customized just for that type (technical term: instantiating the template).\n\nThe syntax should be familiar by now:\n\nImportantly, and are totally different classes, as you can see if you try to stuff a into , provoking the following super-helpful compiler error message:\n\nThis isn't a complete implementation of a unique pointer, but it illustrates the essential features.\n\nThe good news is that if you only use smart pointers and not regular pointers, then your programs will be a lot safer. This isn't to say that there can't be any memory errors because there are other ways to do unsafe stuff, but to a first order you won't have to worry about memory leaks or use after free. The problem here is that nothing in C++ restricts you to just using smart pointers.\n\nFor example, with unique pointers:\n• You can create a raw pointer and then add it to a smart pointer, but this doesn't invalidate the original raw pointer; you just end up with both the copy in the smart pointer (the \"boxed\" version) and the original one in the raw pointer (the \"unboxed\" version).\n• You can get an unboxed copy of the pointer just by doing . This doesn't invalidate the boxed version the way that does.\n\nBoth of these violate the uniqueness guarantee of , so if you do either of them, then you're back in the situation where you have to worry about manually managing memory and C++ won't protect you.\n\nThe natural thing to say is \"I'll just work with boxed pointers\", and to some extent you can do that (though again, C++ won't stop you from unboxing stuff, you just have to not do it) but it's very common to have to work with code that doesn't know about smart pointers, and then you end up unboxing them, at which point you're back in the soup.\n\nOne common situation where you end up having to sort of unbox unique pointers is when you want to pass them to a function, as in:\n\nAs expected, this fails because passing by value would require making a copy of , which would violate the uniqueness invariant. We could move but then we couldn't use it later, when what we really want is to just let do something with temporarily but keep ownership. One way around this would just be to pass a pointer to , like so:\n\nThis will work, but what it's really doing is working around the uniqueness rule: we only have one object holding onto the inner but we've got multiple variables pointing at the , one in and one passed as a pointer to . So, technically we haven't unboxed the inner pointer, but we've unboxed which has all the same problems as before. C++ also has a feature called \"references\", where the callee (in this case ) can just ask for what's effectively a pointer to the object without modifying the call site, and you could ask for a reference to but this still has the problem that you can copy the references around, so it's possible to have a reference to outlive . This isn't to say that it's not possible to safely use references or pointers to a , just that you have to be careful to follow the rules because the compiler won't help you out. (Aside: in production code you should use references rather than pointers, but I'm trying to keep new syntax to a minimum).\n\nIt's also quite common to have situations where you actually want to have two pointers to the same underlying object. For example, suppose that we're building an HR application and we want to keep track of people's managers. It's normal for two people to have two managers, but we can't copy so things get tricky. Fortunately, isn't the only type of smart pointer. For this task, the tool we want is called .\n\nUnlike a , multiple instances can point to a given object, just like with a regular pointer (or, if you're used to a programming language like Python, JavaScript, or Go, just like you happens all the time). keeps track of how many instances there are (the \"reference count\"). When you copy a the reference count increases by one. When a instance is destroyed the reference count decreases by one. If the reference count reaches zero, that means that there are no s to the object and it's destroyed.\n\nFor example, consider the following code:\n\nWhen run, this produces the output:\n\nNote that when both and point to the object, then they also share the same reference count (2). When we reset , telling it to forget about the object, then the reference count drops to 1 and then when we reset , then the reference count drops to zero and the object is destroyed.\n\nOnce we have a shared pointer we can use it to pass an object around without unboxing it:\n\nWhen we pass to , it makes a copy of , incrementing the reference count. Then when returns, that copy is destroyed, decrementing the reference count. The same thing happens when we want to have multiple pointers to the same object, as in the case of storing a pointer to an employee's manager.\n\nIt's worth taking a quick look at how works. The code below shows the core of a homegrown implementation, focusing on the new stuff.\n\nThe key intuition is that we need somewhere to store the reference count, and that needs to be shared between the different instances of so that they have the same view of the reference. This means that it can't be stored in any one copy in case that copy goes out of scope. Instead, we allocate a new object which stores the reference count and every instance of just points to the single instance, as shown here:\n\nIn this case, it also stores the pointer to the owned object, though that could in principle also go in the class, with each one having its own copy of the pointer, which is what Windows seems to do.\n\nConsider the following (potentially more complicated than necessary) code, which models a trivial family with one parent and one child. We want each parent to know its own child and and each child to know its own parent so that we can go from parent to child and vice versa.\n\nWhen we run code, we would expect to get the following output:\n\nHowever, in practice we get nothing. The reason is simple: and aren't actually being destroyed. But why not? To debug this, let's add some instrumentation:\n\nIt's a little tricky to print out the reference counts after has completed, because if we return then we'll have a reference to it in the caller and don't expect it to be destroyed. What we want is to somehow keep ahold of without having a reference to it. We can do this if we unbox via and return it, allowing us to look inside:\n\nYou may have figured out what's going on here, but if not, it's helpful to walk through things step by step and look at the structure, as shown in the following diagram.\n• First, we allocate a new instance of , storing a pointer to it in the shared pointer local variable , with reference count=1.\n• We then allocate a new instance of , passing it a shared pointer to . The constructor for copies the pointer to to its own internal shared pointer, incrementing the reference count to 2. We then assign the new to the local shared pointer .\n• We then tell our instance of about our new instance of with the function, which copies the shared pointer into its own internal shared pointer, incrementing the reference count to 2.\n• Finally, when returns, both local shared pointer instances are destroyed, decrementing the corresponding reference counts, with the result that each shared pointer now has reference count 1.\n\nThe reason that neither nor is being destroyed is that each is being owned by a shared pointer with reference count 1, held by the other: holding a shared pointer to and holding a shared pointer to parent. Nothing else is pointing to either, except for the the unboxed pointer to the that we leaked for debugging purposes, which you can ignore as it has no effect on the reference count (you can easily reproduce this effect without returning that as we did in the original program). Each object is keeping the other alive, but they're not otherwise relevant.\n\nWhat we've done here is reproduce the classic problem with reference counting for memory management: circular references. The basic assumption behind a reference counting system like shared pointers is that it assumes that the shared pointers are laid out in what programmers call a directed acyclic graph (DAG), which is to say that there are no loops where if you follow the shared pointers from object A you eventually get back to A. If there are, then you can end up with objects which can't be freed even if all the references external to the loop are destroyed. In this case, the memory will be inaccessible but can't be freed.\n\nOK, so we have some data which can't be freed? Is that such a big deal. It's important to recognize that when you are using RAII, this kind of error is not just a matter of wasted resource but a correctness issue because object destruction can have visible side effects.\n\nAs a simple, consider the following trivial code:\n\nThis just writes to the file . However, there's a lot hiding under that \"just\", because the program doesn't address the disk hardware directly. Instead, it uses the \"system call\" to ask the operating system to write some stuff to the disk, which sets off a long chain of other events which I won't go into here. Each call to is somewhat expensive, so programs typically will buffer up individual writes internally and then flush the buffer when it gets full or, critically, when the file is closed. In this code, that is hidden by the use of RAII, which just magically takes care of things when the function returns, but what's really happening is something like this:\n\nIf something interferes with being destroyed, then some data may be left in the buffers, with the result that will be truncated. We can reproduce this by calling at the end of .\n\nAs the name suggests, causes the program to exit, and it never returns, which means that never returns, which means that is never destroyed (or, rather, that the destructor never runs, because of course all the program memory is freed), which means that anything still in the buffers is never written to disk. On my computer (a Mac) the result of this program is a file containing only the letter , so presumably is still in the buffer, lost to us forever. The same thing would happen if instead we had some bug that prevented the object from being destroyed, such as it was held by some circular reference as above.\n\nNote that the exact behavior you observe will depend on the precise buffering strategy employed by your C++ implementation, as the standard doesn't appear to prescribe one behavior. In fact, the astute observer will note that I didn't end the write with a , which adds a line feed to the end of the line; on my machine this seems to cause the buffer to flush.\n\nThe key point here is that many nontrivial uses of RAII depend on the destructors actually executing at the right time, so defects like circular references, while not precisely a memory leak in the technical sense (each object is being pointed to by something), can lead to serious correctness issues.\n\nIt's totally reasonable to want to make data structures which have reference loops, so if we can't just use shared pointers, what do we do? One option would be to have one of the pointers just be unboxed, but this undercuts the whole purpose of using smart pointers in the first place. What we instead need is a different kind of smart pointer called a \"weak pointer\".\n\nUnlike other types of smart pointer, a weak pointer doesn't keep the pointed to object alive (in C++ jargon, it doesn't \"own\" it). This means that the object might be destroyed while you are holding the weak pointer. This means that you can have circular references as long as the reference in one direction is a weak pointer, because that breaks the cycle.\n\nBecause the object might be destroyed out from under you, in order to ensure that a weak pointer is safely used, then, you need to temporarily convert the weak pointer into a shared pointer using the method. This shared pointer keeps the object while you use it and when it goes out of scope, you're still holding the weak pointer. For example:\n\nImportantly, if the underlying object has already been destroyed (because the shared pointer reference count went to 0), the method can fail, in which case the resulting shared pointer will have the value (pointing to nothing). This is an inherent consequence of the fact that the weak pointer doesn't keep the object alive.\n\nWhile I'm not going to go into all the details of how to implement weak pointers here (there are a number of techniques) I do want to note that one way to implement it is for the shared pointer object to maintain two reference counts, one strong, one weak. When the strong reference count goes to zero, you destroy the object being held. When both the strong and weak pointer counts are zero, you destroy the object itself; this allows the weak pointer to continue to exist and point to valid memory—though just to the object—even if all the shared pointers have been destroyed. This doesn't violate the RAII correctness guarantees described above because the object is still destroyed, but it does mean that there is some overhead from a weak pointer hanging around even if the shared pointers are all gone.\n\nWhen you have to unbox #\n\nWe now have , , and , which means we're all set, right? Well, maybe. If you're writing totally new code, then these three smart pointers are basically all you need, but if you have to deal with older code which doesn't use smart pointers, then you can run into problems.\n\nConsider the following simple C-style API for timers.\n\nThis is a bit abstruse, due to a combination of C's limited semantics and arcane syntax, but what it says is that you pass in three arguments:\n• A function to call when the timeout expires\n• An argument to pass to the function\n\nIn a modern language, you would either pass a object that encapsulated the callback and the context or, even better, a closure that encapsulated all the relevant state, but neither of these is available in C, so instead we have this.\n\nYou use this API this way:\n\nWhen the timer expires, gets called with a pointer to the string provided as the third argument. Note that this can actually be a pointer to any type of object (that's what ) means, and it's the job of the callback to know what type of pointer it actually is and use it appropriately. The means \"treat this as if it contains a string\", which better be true or things can turn very ugly very fast.\n\nThis is all fine, though a bit fiddly, but what happens if we want to pass some dynamically allocated object to the callback? In C, static strings are stored in the data segment so you don't need to allocate or free them, but what if we had a dynamically constructed string? In that case, we may need to free the object in the callback, like so:\n\nWe're back to C-style memory management here, but what if we want to work with an object which is owned by a smart pointer? We could unbox the pointer, like so:\n\nThis works as long as outlives the timer, but there are situations where you don't know the respective lifetimes. For instance, consider what happens if you are making some kind of network request and want to set a timer in case the request takes too long. In this case, it could be either the request error handler or the timer that is the last use of the object, which is exactly the kind of problem that shared pointers are designed to help you manage! What you actually want to do is to pass the shared pointer to the callback handler, but this impoverished API precludes that.\n\nOne way to manage this situation is to move the reference count from outside the object (as in shared pointer) to inside the object. For instance, we can require that any managed object expose a reference counting interface like so:\n\nInternally, the object has to maintain a reference counter which is incremented whenever is called. When is called, the reference counter is decremented. If the reference count reaches 0, will destroy the object using , which is safe to do as long as you are super-careful. The implementation of the smart pointer itself looks sort of like , except that it calls the and functions rather than directly incrementing and decrementing its own reference count.\n\nIf we adapt our program to use a reference counted pointer it looks like this:\n\nNote that unlike shared pointers, this still requires some attention to the reference count. In particular, before we unbox the pointer and pass it to we need to manually increment the reference counter. The reason for this is that the object is essentially being owned by the timer infrastructure, and if we didn't do that, then when returned, the object would be destroyed as the smart pointer went out of scope.\n\nPerhaps less obviously, we have to manage what happens when the takes ownership of an object: does it increment the reference count or not? You need an option to have it leave the reference count alone so that when it takes ownership in the callback we don't end up with a reference count of 2 rather than 1 (because it's being handed off from the timer infrastructure to the callback). In this code I've opted to only have that variant and force objects to self-initialize with a reference count of 1, but another alternative is to have a flag of some kind that tells the constructor whether to increment or not.\n\nC++ doesn't have a standard implementation of this kind of reference counted pointer, but the popular Boost C++ library project provides a version called intrusive_ptr, though it works a little differently than what I've sketched above.\n\nFirefox makes very extensive use of internally reference counted counted pointers using the template (the sketch above is sort of modeled on Firefox's implementation). The decision to use this design is very old (long predating my time at Mozilla) and dates from a time when C++ didn't have good smart pointers. Once that changed and good smart pointers were widely available, there were a number of debates about which type to use (I was on Team use the C++ standard) and so now Firefox contains a mix of both styles. I don't know what decisions people would have been made starting from scratch (though Chrome seems to use the standard smart pointers a lot more, which is where I got used to it).\n\nAs should be clear from the discussion above, unless you're writing totally greenfield code, it's very hard to avoid having to unbox pointers sometime. In my experience, engineers seem to have two attitudes towards this reality:\n• Discourage it and make you work if you want to unbox.\n• Lean into it and make it as easy as possible to unbox.\n\nOne of the core loci of this debate is whether you should be able to implicitly convert a smart pointer to a raw pointer, like so.\n\nNote that basically all smart pointers in C++ implement some unboxing method like and so that you can access methods and properties; the question is whether you automatically convert to in other contexts. Ordinarily this wouldn't work in C or C++ because and are totally different types and you can't just assign one to the other. However, you can make it work by implementing it explicitly as part of .\n\nThe argument for implementing automatic conversion this is that it makes it easy when you inevitably have to unbox; the argument against it is that it's all too easy to unbox accidentally and that you should have to do it explicitly. C++'s smart pointers force you to call . Firefox's do not and in fact discourage calling . I think this is the wrong answer but was not able to persuade enough people to get it changed; it's easy to add affordances like this, but much harder to remove them once people start to rely on them and you need to change all the relying code.\n\nThis is all baked in #\n\nOne important thing to realize is that smart pointers aren't some new piece of C++ syntax; they're just a new combination of a number of existing C++ features, namely:\n• Overloading the copy constructor, copy assignment operator, etc. provide the appropriate functionality for copying and assignment.\n• Overloading (and sometimes automatic conversation) to make the smart pointer act like a regular pointer.\n\nThat's why we're able to implement our own smart pointers that do the same thing as the ones shipped with the C++ library. This kind of thing is something you see a lot with powerful languages like C++: people realize that they can put together existing features in new ways to produce new functionality that wasn't built into the language.\n\nThe major reason this is all so messy is that smart pointers are layered onto C++'s previously existing unsafe memory management system. This means that you can always opt out of smart pointers and use unboxed pointers, at which point you've given up all your safety guarantees. This is actually something you have to do sometimes—especially when you are working with legacy code—but the lack of compiler enforcement encourages you to do that rather than figuring out how to do things safely without unboxing. Next up, we'll be looking at a language which was built to be safe from the ground up: Rust."
    },
    {
        "link": "https://forums.unrealengine.com/t/question-about-ue4-memory-management/152437",
        "document": "Overview of the features of the UObject system."
    },
    {
        "link": "https://stackoverflow.com/questions/7286486/how-to-sync-lua-and-c-garbage-collection",
        "document": "In general, virtually every Lua wrapper has some way to decide who owns what memory. That is, whether an object is owned by (and therefore will be deleted by) Lua or by your application.\n\nIf you have given Lua a pointer to an object that C++ owns, then you must find a way to ensure that Lua does not use this pointer past the point where C++ deletes it. There are several ways to avoid this. One way is to transfer ownership to Lua.\n\nAnother way is to use a , which allows you to share ownership between C++ and Lua. If you're manually doing this, then you are creating some non-light userdata which is the size of a in Lua. You attach a cleanup metamethod to it that will destroy the , and you use placement-new to construct the shared_ptr on the Lua userdata. Luabind actually has this built-in as a feature: if you pass a to Lua, then they both share ownership of the memory.\n\nYou could also use a . This is an object that you query to get a . The idea is that you're not supposed to keep the pointer around; you query it temporarily as needed, but you only store the permanently. If the object has lost all of its references, then querying the will return a null pointer."
    },
    {
        "link": "https://forums.unrealengine.com/t/what-is-the-best-practice-for-garbage-collection-uproperty-with-without-tobjectptr/2255994",
        "document": "A general question about best practices and garbage collection.\n\nWhen working with C++ with Rider and adding to a class an object pointer it will give the next warning:\n\n Object member 'CapsuleComp' can be destroyed during garbage collection, resulting in a stale pointer\n\nSo to fix that I have two options:\n• Add a macro, expose it to Blueprints and to the UE Garbage Collection.\n• Wrap the type with an which also marks it for UE’s Garbage Collection (as the documentation states “When resolved, its participation in garbage collection is identical to a raw pointer to a UObject”.\n\nBut what I’ve noticed is that the UE API uses both, UPROPERTY marco and TObjectPtr, for example the class has:\n\nI’m wondering what is the best practice here?\n\n When should I just use macro and when should I use both? Or only ?"
    },
    {
        "link": "https://mikelis.net/memory-management-garbage-collection-in-unreal-engine",
        "document": "All you need to know to master garbage collection and memory management in your Unreal Engine 5 projects.\n\nIf you are a bit like me, in learning to program for Unreal Engine, you have eventually bumped into the garbage collector (GC). For some, this first encounter is agreeable — it’s a relief that GC looks after us and prevents memory leaks by design. For others, rubbing shoulders with the garbage collector isn’t that great. If we do not play nice with its rules, it will not play nice with our objects. This post is all about running through the basics of being on the right side of the garbage collector.\n\nWhat is and isn’t Collected\n\nBefore we dive into some concrete examples, let’s familiarize ourselves with the core design of the Unreal Engine’s garbage collector. The principal idea is straightforward — the garbage collection mechanism in the engine keeps track of hard-referenced UObjects directly or indirectly by the root set. Once a UObject becomes unreferenced (\"unreachable\" in the engine's terms), it will be destroyed, and its memory will be freed up. This will happen when GC purges run periodically.\n\nIn practice, there are many different ways to create a hard reference to a UObject in Unreal Engine and preventing the GC of the referenced object. Here are the common ones:\n• None Holding a regular (not soft) reference to a UObject in an instance of a blueprint class.\n• None Holding a reference to a UObject through a raw C++ pointer declared a class as a member field and decorated with UPROPERTY(): // If this points to an object at runtime, there will be a hard reference between // an instance of this class and that object.\n• None Using a raw C++ pointer in a container that's a member field decorated with UPROPERTY:\n• None Adding the object/instance to a Root Set, ensuring that this UObject and all other ones with hard references from it will not be garbage collected: // At this point, MyObject will not be garbage collected until it's removed from\n\nAdditionally, there are also ways to hold on to UObject in weak ways that will not prevent their garbage collection. Commonly this is done by:\n• None Passing around a raw C++ pointer in function arguments, or using it in function bodies: // At this point, the object pointed to by MyObject can be garbage-collected // practically as soon as UMyFunction() finishes executing.\n• None Using raw C++ pointers as members in classes and structs - although smarter IDEs like JetBrains Rider will warn us annoyingly that it will be garbage collected as they think we might intend the objects not to be.\n• None Using a weak UObject pointer such as TWeakObjectPtr // This one can only point to objects in memory. // This one can point to objects in memory or unloaded assets, and it's useful in\n\nGarbage collection only works with UObjects and not other types like structs. Usually, memory management for structs and object instances not derived from the UObject class is handled with the Unreal Smart Pointer Library which provides the basic C++ 11 smart pointer alternatives. In some parts of the engine that are quickly being deprecated now, we can still find some memory management with raw pointers to structs. It is not advisable to do our own memory management in Unreal Engine when we have both garbage collection and smart poitners at our disposal.\n\nEven though the core design is simple, there are some implications and concepts that might not be immediately obvious. Here are a few of those:\n• None Hard references generally imply object ownership, and soft references imply association. Generally, one UObject in Unreal Engine tends to only have one owner (this is called single ownership in object-oriented programming), although many other UObjects could be associated with it through weak pointers.\n• None There are certain UObjects, such as the UWorld, that are guaranteed by the engine to be hard-referenced from the Root Set when a world is used.\n• None There are some types of objects that have a mechanism to register with their owners, and automatically create a hard reference to them. For example, actor components. Actors also have a similar mechanism - after spawning them, they will remain referenced by the level they are in.\n• None Some raw pointers to a garbage-collected UObject will be nulled, but not all. Raw pointers that are member variables decorated with UPROPERTY and that are in containers decorated with UPROPERTY will be nulled when they are garbage-collected. All other raw pointers will continue to point to where the UObject was in memory. In contrast, all templated weak object pointers will be invalidated when objects they point to are garbage-collected. // This will be nulled. IsValid(ExampleOne) will return false as soon as the object // this pointer points to starts being GC'd. // Elements of this will be nulled as they are garbage-collected. IsValid(ExampleTwo[i]) // will likewise return false as soon as the object the element points to starts // This will NOT be nulled (except for some very rare, specific and advanced cases). // There is simply no way for the engine to know that this pointer exists by default. // For debugging, testing and development build purposes, we can check this pointer // with ExampleThree->IsValidLowLevel() but this is too unreliable and slow for // This will be nulled. ExampleFour.IsValid() will become false as soon as the object // starts being GC'd. ExampleFour.IsStale() will in that case become true. This happens // irregardless of whether the member variable is decorated with UPROPERTY or not. // This will also be nulled. This happens irregardless of whether the member variable // is decorated with UPROPERTY or not. Finally, remember that raw pointers captured and used in a lambda function will not be nulled, and this is especially important for lambdas used as call-backs. The general advice for that use case is to use a TWeakObjectPtr\n\nSometimes we have a class that needs to listen to UObject creation and destruction for UObjects that it does not own, nor is associated with. In those cases, we can use the GUObjectArray which is a global symbol of FUObjectArray type that can inform all other objects implementing the FUObjectCreateListener and FUObjectDeleteListener interfaces about all UObject creations and deletions happening in the entire process.\n\nIt will generally always be more efficient to use a TWeakObjectPtr<> to understand when a particular object is destroyed, but the following pseudocode example demonstrates doing that without any knowledge of the instance destroyed.\n\nSo far, we have been talking about the practical rules and principles of garbage collection in Unreal. But what really happens in a garbage collection purge?\n\nTo give a high-level overview, the purge consists of two main steps:\n• Building a garbage-collection graph - a tree of objects hard-referenced by something starting at the Root Set,\n\nStarting at step 1, the engine will start with the Root Set of objects and see what they are hard-referencing and pointing to through the reflection system. Whatever is being pointed to or referenced will be added to the “untouchable list” - the GC graph. Then it will examine what these added objects hard-reference, and it will add all of that to the graph as well. Moving along the graph this way, eventually, the garbage collection system builds a tree of all untouchable objects, and it will just delete everything else.\n\nSeeing this “parent — child” relationship in the graph, one might reasonably think that there must be some logical overlap with Unreal Engine’s outer objects. When a new object is created, we have an opportunity to specify which object is its outer (parent, in a way), or whether our new object should be in the transient package. These relationships are not the same as hard references. Although sometimes a hard reference will be created automatically by specific classes when their outers are what they expect.\n\nAs briefly mentioned above, we have a series of tools to see if the hard and soft pointers we have point to valid, non-garbage-collected UObjects, and we should do so often in code to provide alternative code paths or throw assertions when our game is executing outside of a safe state.\n\nHow we do this depends on the pointer type. For example, here are some assertion code samples for testing various pointers:\n• None A raw C++ pointer can be tested using IsValid() and IsValidLowLevel(): \"Uh oh! MyObject has been garbage collected or will be imminently\" \"MyObject pointer seems to point to a memory location which doesn't seem to have a UObject\" A lot of new Unreal Engine programmers make the mistake and assume that checking whether a raw C++ pointer is null like is always sufficient to know whether the pointer points to a valid UObject. This is not true. For example, the UObject might have already begun destruction, or the pointer might be stale if it hasn't been decorated by UPROPERTY and reflected in Unreal Engine. Use IsValid() - - for reflected pointers (those member pointers decorated by UPROPERTY or in member containers decorated by UPROPERTY). Use IsValidLowLevel() - - for non-reflected raw C++ pointers, but generally try and move away from non-reflected raw pointers as IsValidLowLevel() is slow and has some edge cases where it might return false positives.\n• None A TWeakObjectPtr<> can be tested using .IsExplicitlyNull(), .IsValid() and .IsStale(): \"MyObject was Reset() or never initialized to point to a UObject. In other words, it's == nullptr.\" \"MyObject used to point to a UObject, but that UObject has been destroyed.\"\n• None A TSoftObjectPointer<> can be tested using .IsNull(), .IsValid() and .IsPending(): \"MyObject is not initialized or was Reset().\" \"MyObject is not pointing to a UObject in memory, although it might point to an unloaded asset.\" \"MyObject is not pointing to a UObject in memory, but it may later.\"\n\nIn summation, the garbage collection system is a robust part of Unreal Engine that affords C++ programmers a lot of safety from memory leaks, as well as convenience. With this high-level discussion, I was aiming to introduce the system at a conceptual level, and I hope I have achieved that.\n\nIf you’d like to read more about the Garbage Collection in Unreal Engine, I suggest browsing the Unreal Engine Architecture Documentation as well as Unreal Engine Scripting with C++ Cookbook by William Sherif and Stephen Whittle. The latter recommendation will have a less conceptual overview with a focus on code examples.\n\nAn older version of this article was published on Devlog on 11 Jul, 2020. It was reviewed on 16 Oct, 2022."
    },
    {
        "link": "https://stackoverflow.com/questions/11905357/luaplus-and-c-callback-for-garbage-collection-event",
        "document": "I've been working with LuaPlus to expose the functionality of a module with a scripting language. For that, LuaPlus has been really awesome but i'm stuck with the cleanup of my exposed objects because I don't know how to handle the deletion of the lua object representing my c++ object so i can correctly free the c++ resource.\n\nI'm using lua tables and metatables to represent cpp objects, passing the pointer to the cpp object as the lightuserdata parameter \"__object\" of the table, so i can do things like\n\nAfter the exit of the function (or some time later), i expected to get the call to the metatable method \"__gc\", where i call the delete for the internal cpp object, but i don't see my cpp callback being called at all. I tried forcing the the garbagecollection using lua's function collectgarbage, called my function a ton of times to force lua to collect my objects and i can't see my callback executing. On top of it, i see that the result of calling collectgarbage(\"count\") decreases sometimes so something is getting deleted somewhere, but i don't know what. I've checked the lua documentation and i don't see what i'm doing wrong :(\n\nAny comment is appreciated! Thanks!\n\nUpdate: Added c++ code side + added local as Mud pointed out + sample of my test\n\nI created this small sample of my program. The LuaShell object is simply a wrapper for the state + the loop of reading a command line and executing the string read from std::cin\n\nIn the lua side, i run this to test.\n\nAs you see, there is \"some\" garbage collecting according to the lua runtime, but when i see the top report of my process the memory only goes up, and never down. Also i never see the message from the point destructor (expected as i'm not really calling it) or the one from inside \"my_gc_event\" (unexpected, because i'd think it got called at some point during the collectgarbage work)."
    }
]