[
    {
        "link": "https://docs.python.org/3/library/random.html",
        "document": "This module implements pseudo-random number generators for various distributions.\n\nFor integers, there is uniform selection from a range. For sequences, there is uniform selection of a random element, a function to generate a random permutation of a list in-place, and a function for random sampling without replacement.\n\nOn the real line, there are functions to compute uniform, normal (Gaussian), lognormal, negative exponential, gamma, and beta distributions. For generating distributions of angles, the von Mises distribution is available.\n\nAlmost all module functions depend on the basic function , which generates a random float uniformly in the half-open range . Python uses the Mersenne Twister as the core generator. It produces 53-bit precision floats and has a period of 2**19937-1. The underlying implementation in C is both fast and threadsafe. The Mersenne Twister is one of the most extensively tested random number generators in existence. However, being completely deterministic, it is not suitable for all purposes, and is completely unsuitable for cryptographic purposes.\n\nThe functions supplied by this module are actually bound methods of a hidden instance of the class. You can instantiate your own instances of to get generators that don’t share state.\n\nClass can also be subclassed if you want to use a different basic generator of your own devising: see the documentation on that class for more details.\n\nThe module also provides the class which uses the system function to generate random numbers from sources provided by the operating system.\n\nReturn a random element from the non-empty sequence seq. If seq is empty, raises . Return a k sized list of elements chosen from the population with replacement. If the population is empty, raises . If a weights sequence is specified, selections are made according to the relative weights. Alternatively, if a cum_weights sequence is given, the selections are made according to the cumulative weights (perhaps computed using ). For example, the relative weights are equivalent to the cumulative weights . Internally, the relative weights are converted to cumulative weights before making selections, so supplying the cumulative weights saves work. If neither weights nor cum_weights are specified, selections are made with equal probability. If a weights sequence is supplied, it must be the same length as the population sequence. It is a to specify both weights and cum_weights. The weights or cum_weights can use any numeric type that interoperates with the values returned by (that includes integers, floats, and fractions but excludes decimals). Weights are assumed to be non-negative and finite. A is raised if all weights are zero. For a given seed, the function with equal weighting typically produces a different sequence than repeated calls to . The algorithm used by uses floating-point arithmetic for internal consistency and speed. The algorithm used by defaults to integer arithmetic with repeated selections to avoid small biases from round-off error. Changed in version 3.9: Raises a if all weights are zero. To shuffle an immutable sequence and return a new shuffled list, use instead. Note that even for small , the total number of permutations of x can quickly grow larger than the period of most random number generators. This implies that most permutations of a long sequence can never be generated. For example, a sequence of length 2080 is the largest that can fit within the period of the Mersenne Twister random number generator. Return a k length list of unique elements chosen from the population sequence. Used for random sampling without replacement. Returns a new list containing elements from the population while leaving the original population unchanged. The resulting list is in selection order so that all sub-slices will also be valid random samples. This allows raffle winners (the sample) to be partitioned into grand prize and second place winners (the subslices). Members of the population need not be hashable or unique. If the population contains repeats, then each occurrence is a possible selection in the sample. Repeated elements can be specified one at a time or with the optional keyword-only counts parameter. For example, is equivalent to . To choose a sample from a range of integers, use a object as an argument. This is especially fast and space efficient for sampling from a large population: . If the sample size is larger than the population size, a is raised. Changed in version 3.11: The population must be a sequence. Automatic conversion of sets to lists is no longer supported.\n\nThe following functions generate specific real-valued distributions. Function parameters are named after the corresponding variables in the distribution’s equation, as used in common mathematical practice; most of these equations can be found in any statistics text. Return the next random floating-point number in the range Return a random floating-point number N such that for and for . The end-point value may or may not be included in the range depending on floating-point rounding in the expression . Return a random floating-point number N such that and with the specified mode between those bounds. The low and high bounds default to zero and one. The mode argument defaults to the midpoint between the bounds, giving a symmetric distribution. Beta distribution. Conditions on the parameters are and . Returned values range between 0 and 1. Exponential distribution. lambd is 1.0 divided by the desired mean. It should be nonzero. (The parameter would be called “lambda”, but that is a reserved word in Python.) Returned values range from 0 to positive infinity if lambd is positive, and from negative infinity to 0 if lambd is negative. Changed in version 3.12: Added the default value for . Gamma distribution. (Not the gamma function!) The shape and scale parameters, alpha and beta, must have positive values. (Calling conventions vary and some sources define ‘beta’ as the inverse of the scale). Normal distribution, also called the Gaussian distribution. mu is the mean, and sigma is the standard deviation. This is slightly faster than the function defined below. Multithreading note: When two threads call this function simultaneously, it is possible that they will receive the same return value. This can be avoided in three ways. 1) Have each thread use a different instance of the random number generator. 2) Put locks around all calls. 3) Use the slower, but thread-safe function instead. Changed in version 3.11: mu and sigma now have default arguments. Log normal distribution. If you take the natural logarithm of this distribution, you’ll get a normal distribution with mean mu and standard deviation sigma. mu can have any value, and sigma must be greater than zero. Normal distribution. mu is the mean, and sigma is the standard deviation. Changed in version 3.11: mu and sigma now have default arguments. mu is the mean angle, expressed in radians between 0 and 2*pi, and kappa is the concentration parameter, which must be greater than or equal to zero. If kappa is equal to zero, this distribution reduces to a uniform random angle over the range 0 to 2*pi. Weibull distribution. alpha is the scale parameter and beta is the shape parameter.\n\n# Even integer from 0 to 100 inclusive ['four', 'two', 'ace', 'three'] # of 52 playing cards, and determine the proportion of cards # Estimate the probability of getting 5 or more heads from 7 spins # of a biased coin that settles on heads 60% of the time. # Probability of the median of 5 samples being in middle two quartiles Example of statistical bootstrapping using resampling with replacement to estimate a confidence interval for the mean of a sample: Example of a resampling permutation test to determine the statistical significance or p-value of an observed difference between the effects of a drug versus a placebo: # Example from \"Statistics is Easy\" by Dennis Shasha and Manda Wilson 'at least as extreme as the observed difference of leads us to reject the null' 'hypothesis that there is no difference between the drug and the placebo.' Simulation of arrival times and service deliveries for a multiserver queue: # time when each server becomes available Statistics for Hackers a video tutorial by Jake Vanderplas on statistical analysis using just a few fundamental concepts including simulation, sampling, shuffling, and cross-validation. Economics Simulation a simulation of a marketplace by Peter Norvig that shows effective use of many of the tools and distributions provided by this module (gauss, uniform, sample, betavariate, choice, triangular, and randrange). A Concrete Introduction to Probability (using Python) a tutorial by Peter Norvig covering the basics of probability theory, how to write simulations, and how to perform data analysis using Python.\n\nThese recipes show how to efficiently make random selections from the combinatoric iterators in the module: \"Choose r elements with replacement. Order the result to match the iterable.\" # Result will be in set(itertools.combinations_with_replacement(iterable, r)). The default returns multiples of 2⁻⁵³ in the range 0.0 ≤ x < 1.0. All such numbers are evenly spaced and are exactly representable as Python floats. However, many other representable floats in that interval are not possible selections. For example, isn’t an integer multiple of 2⁻⁵³. The following recipe takes a different approach. All floats in the interval are possible selections. The mantissa comes from a uniform distribution of integers in the range 2⁵² ≤ mantissa < 2⁵³. The exponent comes from a geometric distribution where exponents smaller than -53 occur half as often as the next larger exponent. All real valued distributions in the class will use the new method: The recipe is conceptually equivalent to an algorithm that chooses from all the multiples of 2⁻¹⁰⁷⁴ in the range 0.0 ≤ x < 1.0. All such numbers are evenly spaced, but most have to be rounded down to the nearest representable Python float. (The value 2⁻¹⁰⁷⁴ is the smallest positive unnormalized float and is equal to .) Generating Pseudo-random Floating-Point Values a paper by Allen B. Downey describing ways to generate more fine-grained floats than normally generated by ."
    },
    {
        "link": "https://w3schools.com/python/ref_random_shuffle.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://geeksforgeeks.org/random-shuffle-function-in-python",
        "document": "The shuffle() is an inbuilt method of the random module. It is used to shuffle a sequence (list). Shuffling a list of objects means changing the position of the elements of the sequence using Python.\n\nThe order of the items in a sequence, such as a list, is rearranged using the shuffle() method. This function modifies the initial list rather than returning a new one.\n\nThe shuffle() method cannot be used to shuffle immutable DataTypes like strings."
    },
    {
        "link": "https://pynative.com/python-random-shuffle",
        "document": "In this lesson, you will learn how to shuffle a list in Python using the function. Also, learn how to shuffle string, dictionary, or any sequence in Python.\n\nWhen we say shuffle a list, it means a change in the order of list items. For example, shuffle a list of cards.\n\nYou’ll learn the following functions of a random module to randomize a list in Python.\n\nThe function takes two parameters. Out of the two, is an optional parameter.\n• : It is a sequence you want to shuffle such as list.\n• : The optional argument random is a function returning a random float number between 0.1 to 1.0. This function decides how to shuffle a sequence. If not specified, by default Python uses the function. \n\nNote: this parameter deprecated since version 3.9, will be removed in version 3.11\n\nIt shuffles sequence in place and doesn’t return anything, i.e., It returns None. This function changes the position of items in a mutable sequence.\n\nNote: As you can see in the output, the positions of list items are changed.\n\nAs you know, the works in place and returns None, i.e., it changes the order of items in the original list randomly. But most of the time, we need the original list or sequence.\n\nWe can keep the original list intact using the following two ways. These options don’t modify the original list but return a new shuffled list.\n\nMake a copy of the original list before shuffling (Ideal and preferred)\n\nOption 2: Shuffle list not in Place using\n\nUse the function to shuffle list not in place to get the new shuffled list in return instead of changing the original list\n\nThe random.sample() function returns the random list with the sample size you passed to it. For example, will return a list of 3 random items from a list.\n\nIf we pass the sample size the same as the original list’s size, it will return us the new shuffled list.\n\nLet’s see the example. In this example, I am shuffling the list of Employee objects.\n\nWaring: As per the official Python documentation, for small , the total number of permutations of can quickly grow more extensive than the period of most random number generators. This implies that most permutations of a long sequence can never be generated. For example, a sequence of length 2080 is the largest that can fit within the Mersenne Twister random number generator period. So I advise you to use the use first approach.\n\nShuffle Two Lists At Once With Same Order\n\nLet’s assume if you want to Shuffle two lists and maintain the same shuffle order. For example, One list contains employee names, and the other includes a salary. Let’s see how to randomize multiple lists by maintaining their order.\n\nNumPy module has a package to generate random data. In this example, I am using Python’s Numpy module to create a 2d array. Also, Using function, we can shuffle the multidimensional array.\n\nShuffle a List to Get the Same Result Every time\n\nLet’s how to seed the random generator in such a way that shuffling produces the same result every time. Using the and together, we can generate the same shuffled list every time.\n\nDo you know how PRNG works in Python?\n\nPython’s random module is not truly random. It is pseudo-random (PRNG), i.e., deterministic. The random module uses the seed value as a base to generate a random number. By default, current system time is used as a seed value. If we change the seed value, we can change the output.\n\nNote: We are getting the same list because we use the same seed value before calling the shuffle function. This is just a simple example. To make it work with any list, we need to find the exact seed root number for that list, which will produce the output we desire.\n\nIn this section, we will see how to shuffle String in Python. But it is not as simple as shuffling a list. You will get an error if you try to shuffle a string using the method.\n\nBecause a string is an immutable type, and You can’t modify the immutable objects in Python. The doesn’t’ work with String. I.e., It can’t accept string argument. Let’s understand this with the help of the following example.\n\nWe have a solution to this. We can shuffle a string using various approaches. Let see each one by one.\n\nShuffle a String by Converting it to a List\n\nConvert String to list and Shuffle the list randomly, again convert the shuffled list into String\n\nApproach Two: Shuffling a String, not in place\n\nUsing this approach, we can keep the original string unchanged and get the new shuffled string in return. Also, we don’t need to convert the string to a list to get the shuffled string.\n\nThe sample() function returns a sample from a sequence as per the sample size you passed to it. For example, will return a list of 3 random characters from a list.\n\nIf we pass the sample size the same as the string size, it will return us the new shuffled string of characters.\n\nThe doesn’t return the list, so when you try to run , you will get an error. To shuffle numbers in the , first convert the range to a .\n\nShuffling a dictionary is not possible in Python. However, we can rearrange the order of keys of a dictionary.\n• Fetch all keys from a dictionary as a list.\n• Shuffle that list and access dictionary values using shuffled keys.\n\nThe needs to know the sequence’s size to shuffle the sequence uniformly. If you try to shuffle a generator object using it, you will get a TypeError: the object of type 'generator' has no len() .\n\nAs the generator cannot provide us the size we need to convert it into a list to shuffle it.\n\nI want to hear from you. What do you think of this article on ? Or maybe I missed one of the usages of . Either way, let me know by leaving a comment below.\n\nAlso, try to solve the following exercise and quiz to have a better understanding of working with random data in Python."
    },
    {
        "link": "https://stackoverflow.com/questions/976882/shuffling-a-list-of-objects",
        "document": "How do I shuffle a list of objects? I tried random.shuffle :\n\nThis question already has answers here :\n\nshould work. Here's an example, where the objects are lists: from random import shuffle x = [[i] for i in range(10)] shuffle(x) print(x) # print(x) gives [[9], [2], [7], [0], [4], [5], [3], [1], [8], [6]] Note that works in place, and returns . More generally in Python, mutable objects can be passed into functions, and when a function mutates those objects, the standard is to return (rather than, say, the mutated object).\n\nIf you have multiple lists, you might want to define the permutation (the way you shuffle the list / rearrange the items in the list) first and then apply it to all lists: import random perm = list(range(len(list_one))) random.shuffle(perm) list_one = [list_one[index] for index in perm] list_two = [list_two[index] for index in perm] If your lists are numpy arrays, it is simpler: I've created the small utility package which has the function: import mpu # Necessary if you want consistent results import random random.seed(8) # Define example lists list_one = [1,2,3] list_two = ['a', 'b', 'c'] # Call the function list_one, list_two = mpu.consistent_shuffle(list_one, list_two) Note that takes an arbitrary number of arguments. So you can also shuffle three or more lists with it.\n\n'print func(foo)' will print the return value of 'func' when called with 'foo'. 'shuffle' however has None as its return type, as the list will be modified in place, hence it prints nothing. Workaround: # shuffle the list in place random.shuffle(b) # print it print(b) If you're more into functional programming style you might want to make the following wrapper function:\n\nFor anyone interested in using the Index Sequential Method (Ouarda et.al., 1997) to reorder a list: This will work for a single value list... @Shantanu Sharma provides some great methods for breaking a list of values into a sequence of nested lists of size n. valList = [1,2,3,4,5,6,7,8,9,10,11,12] # Yield successive n-sized lists from l def SequenceList(l, n): # looping till length l for i in range(0, len(l), n): yield l[i:i + n] nestedList = list(SequenceList(valList, 3))\n\nPlan: Write out the shuffle without relying on a library to do the heavy lifting. Example: Go through the list from the beginning starting with element 0; find a new random position for it, say 6, put 0’s value in 6 and 6’s value in 0. Move on to element 1 and repeat this process, and so on through the rest of the list import random iteration = random.randint(2, 100) temp_var = 0 while iteration > 0: for i in range(1, len(my_list)): # have to use range with len() for j in range(1, len(my_list) - i): # Using temp_var as my place holder so I don't lose values temp_var = my_list[i] my_list[i] = my_list[j] my_list[j] = temp_var iteration -= 1"
    },
    {
        "link": "https://reddit.com/r/gamedev/comments/jup9cj/what_would_you_recommend_doing_when_structuring",
        "document": "I'm currently in the process of making a card game. Before I mess with the code further I should decide how I should structure the cards.\n\nThere are a few ways I think I could do.\n• Use a Datatable system to retrieve all relevant card data. (Abilities, Health, Text, Attack, effects, etc.)\n• \n• The constant pulling of card data from a data table may impact the system\n• Individual cards with specialized effects are impossible to achieve\n• Abilities are not flexible as they depend on the original card class' variables\n• Use a Datatable system for card previews and stats and for the deck builder but have separate child classes for each individual card. The child classes only hold relevant abilities and effects.\n• \n• A little softer on the system as it doesn't need to constantly pull data from a data table when a card in spawned in\n• Individual cards can have specialized effects and abilities are easier to implement as it is possible to make variables unique to the class\n\nEdit: If you have another idea, I'm open to anything. Cheers!"
    },
    {
        "link": "https://stackoverflow.com/questions/41970795/what-is-the-best-way-to-create-a-deck-of-cards",
        "document": "I was thinking about making a deck of cards for a card game. I could make a list of all of the cards (I don't really care about the suits), but I was wondering if there was a much easier way to do this. I'm positive you could make a loop to create 4 cards of the same value and add it to a list, but I was wondering if that was the best solution. I am not advanced enough to know about or create a which I have seen to be offered as other solutions, but I am open to explanations. I have already made a dictionary defining the card values."
    },
    {
        "link": "https://stackoverflow.com/questions/60289405/a-good-way-to-make-classes-for-more-complex-playing-card-types-than-those-found",
        "document": "I am extremely new to object-oriented programming, and am trying to begin learning in python by making a simple card game (as seems to be traditional!). I have done the following example which works fine, and teaches me about making multiple instances of the class to create an instance of the class:\n\nI want to make something now with more complex cards, not just a standard 52 deck (which has nicely incrementing values). The deck I have in mind is the [Monopoly card game][1]:\n\nThere are 3 fundamental types of cards - ACTION cards, PROPERTY cards, and MONEY cards. The action cards perform different actions, the property cards belong to different colour sets, and the money cards can have different values. Additionally, the property cards can be \"wildcards\", and can be used as part of one of two sets. Finally, every card also has an equivalent money value (indicated in the top corner of each card). In the rent action cards, the card can only apply to the colour property indicated on the card.\n\nMy question is just generally how to handle a situation like this, and what would be a nice way to include these different cards in a class-based python program? Should I keep my single class, and just have many inputs, such as . Or would it be better to create seperate classes such as , , etc ? Or is there a better way? As I say, I am at the beginning of my learning here, and how to organise these types of situations in terms of the higher level design."
    },
    {
        "link": "https://quora.com/How-do-you-create-a-card-game-in-Python",
        "document": "Something went wrong. Wait a moment and try again."
    },
    {
        "link": "https://reddit.com/r/tabletopgamedesign/comments/qtc6u2/iterating_card_game_design_with_python_an_example",
        "document": "I share here how I technically iterated my card game design with Python programming language, including card rendering, printing, using Tabletop simulator, and The Gamecrafter. I wanted to see how tough it's to use Python to design a card game, and if non-programmer designers could use the same approach. It was much more work than I thought, but now the repository https://github.com/jukujala/pycards has components you can reuse in game design. The repository has a full example of my prototype game without the rules, but I'll later share experiences & ask feedback on the game design itself.\n\nLets go through how to iterate game design with pycards. The example here renders a battle victory card as shown below from this CSV data:\n\nThe steps in code to render card images are:\n• You store and modify game data in Google sheets or CSV. Read CSV and convert each card to a separate Python dictionary (example). List of card dictionaries is a deck.\n• Add rendering information to each card, for example asset images. The assets are a folder in the repository (example) which is read to a global dictionary (example), and the assets are added to each card (example). The loop to process each card is here.\n• Render each card to a Pillow image in a for loop. Functions render different parts of the card, like title text and an image of a victory point. For example function calls utility function which renders text in to relative coordinates of the card. Coordinates is middle of the card, and would be the top-left -corner of the card. The text can contain asset images, for example: , where is a reference to an image in the assets dictionary.\n\nWith above you get a single PNG image for each card. To play test you then do one of:\n• Combine images to PDF pages and print and play, or\n• Use a service like The Gamecrafter to print the cards.\n\nI hope the above had useful information, but I admit that the tech design has a lot to digest and explaining it in detail would take much longer. If someone is curious I could write more documentation. I think the advantage of using a Python is that its very flexible, especially if you know programming. Also, you gain advantage of the best practices in programming, for example using version control (git) to manage history of your design project."
    }
]