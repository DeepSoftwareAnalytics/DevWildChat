[
    {
        "link": "https://stackoverflow.com/questions/63869119/moving-a-string-without-using-string-instuctions-in-assemply-language-programmin",
        "document": "I believe the problem is the instruction.\n\nWithout a segment prefix, it will assume that the address in DI is in the segment referenced by DS and you want to use the segment referenced by ES.\n\nIf I remember correctly, the syntax is"
    },
    {
        "link": "https://tutorialspoint.com/assembly_programming/assembly_strings.htm",
        "document": "We have already used variable length strings in our previous examples. The variable length strings can have as many characters as required. Generally, we specify the length of the string by either of the two ways −\n\nWe can store the string length explicitly by using the $ location counter symbol that represents the current value of the location counter. In the following example −\n\n$ points to the byte after the last character of the string variable msg. Therefore, $-msg gives the length of the string. We can also write\n\nAlternatively, you can store strings with a trailing sentinel character to delimit a string instead of storing the string length explicitly. The sentinel character should be a special character that does not appear within a string.\n\nEach string instruction may require a source operand, a destination operand or both. For 32-bit segments, string instructions use ESI and EDI registers to point to the source and destination operands, respectively.\n\nFor 16-bit segments, however, the SI and the DI registers are used to point to the source and destination, respectively.\n\nThere are five basic instructions for processing strings. They are −\n• None MOVS − This instruction moves 1 Byte, Word or Doubleword of data from memory location to another.\n• None LODS − This instruction loads from memory. If the operand is of one byte, it is loaded into the AL register, if the operand is one word, it is loaded into the AX register and a doubleword is loaded into the EAX register.\n• None STOS − This instruction stores data from register (AL, AX, or EAX) to memory.\n• None CMPS − This instruction compares two data items in memory. Data could be of a byte size, word or doubleword.\n• None SCAS − This instruction compares the contents of a register (AL, AX or EAX) with the contents of an item in memory.\n\nEach of the above instruction has a byte, word, and doubleword version, and string instructions can be repeated by using a repetition prefix.\n\nThese instructions use the ES:DI and DS:SI pair of registers, where DI and SI registers contain valid offset addresses that refers to bytes stored in memory. SI is normally associated with DS (data segment) and DI is always associated with ES (extra segment).\n\nThe DS:SI (or ESI) and ES:DI (or EDI) registers point to the source and destination operands, respectively. The source operand is assumed to be at DS:SI (or ESI) and the destination operand at ES:DI (or EDI) in memory.\n\nFor 16-bit addresses, the SI and DI registers are used, and for 32-bit addresses, the ESI and EDI registers are used.\n\nThe following table provides various versions of string instructions and the assumed space of the operands.\n\nThe REP prefix, when set before a string instruction, for example - REP MOVSB, causes repetition of the instruction based on a counter placed at the CX register. REP executes the instruction, decreases CX by 1, and checks whether CX is zero. It repeats the instruction processing until CX is zero.\n\nThe Direction Flag (DF) determines the direction of the operation.\n• Use CLD (Clear Direction Flag, DF = 0) to make the operation left to right.\n• Use STD (Set Direction Flag, DF = 1) to make the operation right to left.\n\nThe REP prefix also has the following variations:\n• None REP: It is the unconditional repeat. It repeats the operation until CX is zero.\n• None REPE or REPZ: It is conditional repeat. It repeats the operation while the zero flag indicates equal/zero. It stops when the ZF indicates not equal/zero or when CX is zero.\n• None REPNE or REPNZ: It is also conditional repeat. It repeats the operation while the zero flag indicates not equal/zero. It stops when the ZF indicates equal/zero or when CX is decremented to zero."
    },
    {
        "link": "https://stackoverflow.com/questions/26498929/manipulate-string-in-assembly-x86-mov-and-print-to-screen",
        "document": "I'm working on a larger project but I'm stuck with string manipulation. My assembly file includes math coprocessor operations (it starts the coprocessor with \"FINIT\") but I don't think it should be interfering at all. Basically, I have some strings that are 50 bytes long each:\n\nI need to assign the value stored in variable \"_cte_14\" to variable \"$s\" I attempted to use a register to temporarily store the value, like this:\n\nbut I get the \"operand types do not match\" error.\n\nSince I know the AX, BX, CX, DX registers only hold 16 bits, I thought maybe I need to work with the memory address of the first string character, so I tried:\n\nbut the same error shows up.\n\nI'm using TASM to compile for an x86 processor. What would be the right way to accomplish this?"
    },
    {
        "link": "https://reddit.com/r/asm/comments/1ah95zv/how_do_string_variables_work_in_assembly",
        "document": "in case of integer variables , something like int a = 7 would be translated into something like :\n\nin the same way , what does something like string text = \"hello\" translate to ?"
    },
    {
        "link": "https://quora.com/How-can-I-perform-string-operations-in-assembly-language",
        "document": "Something went wrong. Wait a moment and try again."
    },
    {
        "link": "https://stackoverflow.com/questions/47513958/finding-the-substring-in-an-input-string",
        "document": "This does nothing useful. The length that it calculate can not help you in any way!\n\nHere (as Jester told you) the instruction is wrong. You need to set to the start of the string. You will also need to add to set to the start of the word. Do this and the valid part of your program will work correctly.\n\nConsider the case where the string has 7 characters and the word that you're looking for has 6 characters. You can find the word in at most 2 ways.\n\nConsider the case where the string has 8 characters and the word that you're looking for has 6 characters. You can find the word in at most 3 ways.\n\nConsider the case where the string has 9 characters and the word that you're looking for has 6 characters. You can find the word in at most 4 ways.\n\nNotice the regularity? The number of possible finds is equal to the difference in length plus 1.\n\nThis sets to the number of tries in your matching routine.\n\nThe check part will use to test for a match, but in the event that the match is not found, you must be able to return to the matching code at the continue label. You have to preserve the registers."
    },
    {
        "link": "https://stackoverflow.com/questions/4364692/finding-substring-in-assembly",
        "document": "I'm wondering if there is a more efficient method to finding a substring in assembly then what I am currently planning to do.\n\nI know the string instruction \"scansb/scasw/scads\" can compare a value in EAX to a value addressed by EDI. However, as far as I understand, I can only search for one character at a time using this methodology.\n\nSo, if I want to find the location of \"help\" in string \"pleasehelpme\", I could use scansb to find the offset of the h, then jump to another function where I compare the remainder. If the remainder isn't correct, I jump back to scansb and try searching again, this time after the previous offset mark.\n\nHowever, I would hate to do this and then discover there is a more efficient method. Any advice? Thanks in advance"
    },
    {
        "link": "https://medium.com/wix-engineering/beating-textbook-algorithms-in-string-search-5d24b2f1bbd0",
        "document": "This is a well known string search algorithm that dates back to 1970. Since it is well described in the literature, I will not try to explain its details here. KMP is based on Finite State Automaton — during precomputing phase, an array of jump indexes is built based on the . During the search, this automaton accepts characters of the one after another, and updates it’s internal state (which is just an index within this jump table).\n\nWell, I had to come up with some name for it because I don’t remember seeing this algorithm anywhere in the literature. If you have seen a similar algorithm described somewhere — kindly please share a link in the comments below.\n\nUpdate: I have learned that this algorithm (and its variations) was known since 1964, under various names, such as Bitap, Shift-or, Shift-and, Baeza-Yates–Gonnet. I thank my readers for pointing this out.\n\nThis algorithm is based on a very simple idea, and performs great because it is effectively jump-free and is based on just a few primitive binary operations. Because of that, it has a limitation on the length of the we are searching for — it cannot be more than 64 bytes long (based on the number of bits of a on JVM). This limit is generous enough for many use cases.\n\nBecause this is a home made algorithm, I will try to explain it in detail. The first part is precomputing the search context for the given :\n\nWe precompute a (64 bit for every possible byte value (256 in total). For some byte value , its contains ones in every position where is present in the , for example:\n\nAlso, we need to precompute a which will help us know when we have a full match. It is simply a value with bit in the position :\n\nAnd the last part is performing the actual search. The only mutable state that we need to track is (a ). For every byte of , we shift to the left by 1 bit, set its lowest bit to 1, and perform a bitwise operation of the resulting value with the precomputed for the current byte value of the being processed (this resets all the bits in positions of that do not match the currently processed byte value).\n\nThis way, after each byte processed, only the bits that are in matching positions “survive”. And, with each byte processed, all the bits are shifted to the left by one position. If a bit “survives” the process for the number of iterations that is equal to the length of the , we have a match (we use to check for this):\n\nNote: the method above returns in case of a match, which might seem somewhat counterintuitive. This is needed because returning has the meaning of continuing the search process, and stops it indicating a match (as I mentioned before, this API was designed to plug into Netty framework). See this code for a better understanding of how the search process is being executed.\n\nSo, the whole logics boils down to just a few simple CPU instructions. And, sadly, a completely redundant bounds check on array access that Java JIT compiler is unable to eliminate (yes, I have checked the assembly generated by multiple JDKs).\n\nA link to the full implementation in Scala.\n\nAnother well known algorithm, dating back to 1975. Its distinct (and in some cases very useful) feature is the possibility to search for multiple simultaneously, while still processing every character of the only once (which I think is brilliant!). The idea behind it is an extension to Knuth Morris Pratt — a Finite State Automaton supported by a trie (built based on the set of ) of jump references (versus one-dimensional array of jump indexes of KMP). Based on those references, the internal state of the automaton jumps around the nodes of the trie upon every character processed, and some of the nodes indicate a match on some specific . It’s precomputing phase is quite complicated, but the actual search phase is surprisingly simple."
    },
    {
        "link": "https://cs.jhu.edu/~misha/ReadingSeminar/Papers/Knuth77.pdf",
        "document": ""
    },
    {
        "link": "https://quora.com/How-do-you-write-a-program-in-assembly-language-to-take-an-input-string-and-display-it-word-by-word",
        "document": "Something went wrong. Wait a moment and try again."
    }
]