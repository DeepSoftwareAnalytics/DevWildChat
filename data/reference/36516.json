[
    {
        "link": "https://unrealengine.com/en-US/tech-blog/dealing-with-memory-leaks-in-ue4",
        "document": "Memory leaks are an elusive category of bugs that often take quite a while to manifest. These bugs occur when we allocate memory for something and then lose track of it without ever freeing up the memory it’s using. Memory leaks contribute to overall instability, causing an application to get bogged down and eventually crash as it slowly consumes all of the available RAM.\n\nWhile it’s hard to patch up every leaky allocation, there are a few techniques we can use to find the largest offenders and make sure they stop hogging memory that they don’t need. Recently, the Paragon team did just that in response to some memory leaks that would crash the game after a few hours. While Paragon matches rarely last long enough to eat up all of the system's memory, it’s difficult to predict how the match may play out. After all, nothing would be more frustrating than having your client crash right as your team engages in that pivotal team fight!\n\nFollowing along with their experiences, here are some tips and tricks on how to track down the source of your memory leaks.\n\nThe first step to tracking down memory leaks is determining whether or not a leak is occurring. A simple way to do this is to take a snapshot of the current memory allocations at two different points in time, and comparing them to see what has changed. If no actions are taken in the game, we can expect similar memory usage regardless of the amount of time passed. However, if there is a steady rise in the amount of memory used as time passes, it may be time to start looking for a leak.\n\nAs an example, I created an Actor that allocated 1,000 integers per Tick, throwing away the reference immediately. I dropped my Actor in an empty scene and allowed it to run for ten minutes, and took a MemReport at the beginning and end of my session. A comparison of the two reports shows a noticeable increase in memory usage, despite the fact that the object count hasn’t changed at all.\n\nMore information about MemReport can be found in a previous blog post, Debugging and Optimizing Memory.\n\nMemReport can help distinguish memory leaks from other types of leaks, such as object leaks. An object leak may be occurring if the number of objects present in the scene is consistently increasing. This typically indicates that spawned objects aren’t being cleaned up properly. For example, what if we create a projectile class that is destroyed when colliding with another object? Projectiles fired into the air will just travel skyward forever, holding on to valuable memory. The MemReport will show how many instances of each object exist in the world at that time, giving a clue as to which object is leaking so that we can investigate the spawning and despawning logic to see if there’s a problem.\n\nOnce we suspect some of our memory allocations are never being freed, we need to track down who is responsible for those allocations. To accomplish this, the Paragon team built a tool that can monitor any open memory allocations that haven’t yet been freed. The tool is still experimental and disabled by default, so you’ll need to make a quick change to MallocLeakDetection.h and recompile:\n\nOnce you’ve done that, make sure you have Visual Studio running and attached to your game instance. You can begin logging by typing “MallocLeak Start” in the console and stop by typing “MallocLeak Stop”. The tool will then dump all open allocations that were made during the logging period into Visual Studio’s output window. Optionally, you can type “MallocLeak Dump N” while the logger is running, where N is a size in bytes. This will immediately dump open allocations filtered to allocations of at least N bytes. It’s helpful to begin logging after the game has initialized, as many allocations may be made at initialization and not freed until the game is closed.\n\nI modified my leaky Actor to make a large allocation 10 seconds after the game starts. I then ensured MallocLeak was running during the allocation, and used “MallocLeak Dump 1000000” to dump all open allocations larger than 1 megabyte. As expected, I found something suspicious in the results. Quite a bit of memory has been allocated by an Actor’s Tick function!\n\nAs with most profiling techniques, it’s important to look at the results critically. Keep in mind that allocations made before you begin logging won’t show up in the result. Similarly, allocations freed after you stop logging will show up, even if they aren’t indicative of a leak. However, the MallocLeak tool is great for investigating where your memory is going and give some hints as to where to look for the offending code. Happy Hunting!"
    },
    {
        "link": "https://reddit.com/r/unrealengine/comments/14pru6t/memory_leaks_whats_the_best_way_to_diagnose_and",
        "document": "Im working on a project, and when i open it fresh, the memory is at like 2k mb. But if i let it sit for like a half hour with the window in focus, it climbs up to 6k mb and beyond. The memory is literally climbing at a rate of 10mb or so per second."
    },
    {
        "link": "https://forums.unrealengine.com/t/continous-memory-leak-problems/96311",
        "document": "Memory leaks are an elusive category of bugs and often take quite a while to manifest. These bugs occur when we allocate memory for something then lose track of it without freeing up the memory it’s using. While it’s hard to patch up every leaky..."
    },
    {
        "link": "https://medium.com/@igor.karatayev/the-easiest-way-to-memory-leak-in-unreal-engine-9e2aeaa7b104",
        "document": "That is so far the easiest way to make a memory leak in Unreal Engine. You will ask, how is it possible to leak something in Unreal Engine if everything is garbage collected? That is a type of memory leak specific for garbage collected languages, we are not loosing reference to that object forever, but we introduce a much longer then we expect reference to an object.\n\nWhat is leaking? Return Value of Construct node. We can expect that we are not storing Return Value in any property or variable so it is free to go on next garbage collection cycle, but actually it will never be freed until we destroy object with that event.\n\nConstruct node is not principal here.\n\nSo what is happening and why are those references leaking. Local Variables are here to blame. Local Variable can be created in Functions and quite handy to store some temporary values. They are freed when we go out of function. But here we work not in function scope, but in Uber Graph scope.\n\nUber Graph scope is the top level scope of all blueprints. That is the space where we can create Custom Events. Custom Events are actually not so different from functions. They have entry node, they also have Return Node (but it is not visible, and we can not return values with it). But they don’t have their own scope, they all share one Uber Graph scope. So that is the main difference. In normal functions scope is created whenever you enter function and is destroyed when you exit it. In Uber Graph scope is created when first event is called and is persistent until the end of objects lifetime.\n\nWe can not create local variables in Uber Graph scope explicitly. There is no Local Variable tab in blueprint editor. But they can be created by macros.\n\nAnd if you call that macro in Uber Graph you will create that local variable, and it will stay on that scope “forever”.\n\nThere is another way to implicitly create local variables in Uber Graph — by calling BlueprintCallable functions. Whenever you call a non Pure function blueprint virtual machine needs to save its return value and for that it creates implicit local variable.\n\nWhenever you call NewFunction_1 virtual machine creates Local Variable to store it’s result. And because Uber Graphs are persistent — they store local values across event calls, thus making all their function call code equivalent to storing all result in Variables.\n\nAnd that is why everything start to unintentionally reference each other and leak. All objects which was passed to some event in any way became secretly referenced by that object and their lifetime became extended to the objects lifetime. Objects start to clot into big self-referencing chunks of memory on basically any operation with them. I was not expecting such a behavior. As a programmer I think that is kind of surprising and should not happen. And that is not documented anywhere.\n\nBut I understand why that behavior was thought to be a good idea at some point. Blueprints are for designers, that is a visual language, which even I as a programmer find appealing and easy to use, with some interesting features like\n\nCallbacks are backbone of visual scripting. The most popular usage of them I think is in timers.\n\nAnd that code would not simply work without persistent Uber Graphs. And as I know that is the only way to pass some parameter to timer callback.\n\nCan that be fixed?\n\nIn vanilla Unreal Engine you can actually clear that local variables by hand )\n\nIn our project I added a patch to clear local variables when leaving Events, I think that should be the default behavior, but that will completely kill that feature with passing values to timer events. Currently I don’t see that a big problem, you will need to explicitly store such values in instance Variables and clean them by hand when they are not needed. But even that is so far a better approach then loosing them in hidden references.\n\nIs it that serious?\n\nLooks like a serious problem from first glance, but you may wonder how UE games still work? Actually it is not a very big problem. And here is why. Every time you some event happens it rewrites its Local Variables. In games every tick usually something happens, every event is usually get called several times per second, so object are stuck not forever, but until next event. And that mostly mitigates the problem. But still, sometimes it can backfire on you. In some rare situations in rare called events some objects can be frozen for considerable amount of time, slowly eating your memory. On one project we experienced that problem on RPC calls, and only feasible at that time was to rewrite all RPC functions from BP to C++. On another project there was Dead Actor references stored in Uber Graph leading to Engine Crash. So there are a lot of possible “good luck to fix them” bugs because of that Uber Graph feature. So you better know about it."
    },
    {
        "link": "https://forums.unrealengine.com/t/memory-leak-or-performance-issue/376750",
        "document": "Not really sure what is going on. Since upgrading to 4.14 the editor has been crashing a lot, crashing when steamvr is also having problems (missing files and such for some reason). Now today I was doing some testing in blueprints, and when I was exiting the PIE, it started taking a long time to exit. a little longer each time. Then I tried to import a model and it almost locked up my whole system for about 30 seconds, at which point I started loading up the windows task manager. The editor was using 13.7GB of ram on a relatively small scene (not sure what ram usage is when not having problems…) It was also using a fair bit of cpu, tho vrserver.exe and vrcompositor.exe were both using a little more, at 4%. I closed the editor, and it took about 4minutes before it was gone from the task manager. After closing the editor, vrserver and vrcompositor, it was about 5-10 minutes before my system stopped lagging horribly. The editor didnt crash today, and I’m not sure if this issue was an editor problem, or something else. I’ve included a whole bunch of logs if they’re of any help.\n\nI can reproduce this memory leak and behavior with ue4.14.0 built from source very easily.\n• press play then stop (play adds about +100mb usage, stop adds an another +300mb) The editor can quit fast (about a few seconds) if i don’t hit the memory limits of my system, but after filling up all the 16GB ram the system gets unstable and exiting the editor might take up to a minute or so to shut the process down. Editor is running from an SSD, but the system pagefile is placed on a HDD. Image is taken from win7 task manager, the px/sec chart showing the memory consuption of starting the editor and load the template project, press play and stop about ~15 times (raise) then quit the editor application (fall). edit: Additional observation, that pressing the posess/eject button will raise the memory as well, however new editor window PIE does not seem consume additional memory (at all, which is odd but helps me to avoid this leak issue for now).\n\nThe Launcher version of 4.14.0 also have this issue, the memory continously filled up by 400-500 mb every time the play/stop is pressed. Launcher and source built 4.13.2 have no such issues. Both are tested with the corresponding template FPS project version provided by the launcher.\n\nI’m running the launcher version. It was suggested in IRC for me to use the console command “memreport - full” Before and after playing in editor. It seemed to give a bunch of errors, So I’ve included the new project log.\n\n link text With this log I had been running UE4 for several hours without doing any PIE, just importing/exporting models. After doing the memreports and PIE, I closed the application. Shortly after I got a windows error saying the application had crashed. Here is the description it gave:\n\nI’ve been done the “memreport -full” before and after PIE, and then compared the resulting two .memreport log files with winmerge which pointed out the only difference between the shots was the Platform Memory Stats, but that’s only a summary report. Process Physical Memory: 5211.16 MB used, 5211.16 MB peak Process Virtual Memory: 5836.79 MB used, 5898.93 MB peak Physical Memory: 10518.35 MB used, 5808.52 MB free, 16326.87 MB total Virtual Memory: 6566.20 MB used, 5808.52 MB free, 8388608.00 MB total Process Physical Memory: 5648.56 MB used, 5648.56 MB peak Process Virtual Memory: 6285.20 MB used, 6347.35 MB peak Physical Memory: 10957.73 MB used, 5369.14 MB free, 16326.87 MB total Virtual Memory: 7008.45 MB used, 5369.14 MB free, 8388608.00 MB total The rest of the logs are identical, which means this logging method will unable to help. Edit: also measured “obj list -alphasort” in similar fashion but that is showing identical result as well.\n\nWhile your suggestion is very good for measuring project level issues, it unfortunately won’t help to investigate the error we are described here. The memory leak can even be reproduced with the launcher version of templates (eg no user changes are requried), as it is a general Editor error. I’m sure there must be a lot repro available here, but you can easily reproduce it when play/stop the project or pressing the possess/eject buttons. UE 4.14.0-preview 1 (built from source) have no issues at all, whereas the release version of 4.14.0 is producing memory leaks in both events. Here is the most simple repro i have found so far.\n• create a new Blank BP project in 4.14.0 release version (both source and launcher version are affected)\n• press start PIE then stop, you will measure an additional 400+ mbyte of memory usage\n• repeat step 2 until your system become unresponsive Alternatively you can use the Possess/Eject buttons, where both button press will adds 400-400 mbytes ram usage that never gets released.\n\nEvery memory leak I investigate sounds simple. However it never happens consistently across different machines. I am not able to reproduce this. I have the OP’s dxdiag, but can I get yours as well? Also please check here to see if you have any software on our known conflicts list. Some do cause memory leaks.\n\n“never happens consistently across different machines”, but at least should be consistent between engine versions which is not. Like i have been trying to explain this issue i have indeed tested between different engine versions on the same pc machine, and they show different results. 4.14.0 is bogus on our end, although i’m a little surprised that you were unable to reproduce this issue with the current release version on your setup. A related issue from an another user will support that something is not right with the 4.14 build. SC list is checked and fine. Attached my dxdiag anyways."
    },
    {
        "link": "https://developer.chrome.com/docs/devtools/memory",
        "document": "Save and categorize content based on your preferences.\n\nStay organized with collections Save and categorize content based on your preferences.\n\nThe Memory panel provides diagnostic tools that let you see the memory distribution of JavaScript objects, discover and isolate memory leaks, get a breakdown of memory allocation by function, and more.\n\nThe Memory panel lets you capture four profile types. These profile types show you snapshots from different perspectives and provide varying utility:\n• Heap snapshot: Shows memory distribution among your page's Javascript objects and related DOM nodes.\n• Allocation instrumentation on timeline: Shows instrumented JavaScript memory allocations over time. Once a profile is recorded you can select a time interval to see objects that were allocated within it and still live by the end of the recording. Use this profile type to isolate memory leaks.\n• Allocation sampling: Records memory allocations using the sampling method. This profile type has minimal performance overhead and can be used for long running operations. It provides good approximations of allocations broken down by JavaScript execution stack.\n• Detached elements: Shows objects that are retained by a JavaScript reference.\n\nYou can select a JavaScript VM instance to run each of these profiles on.\n\nTo learn more, see:\n• Start typing , select Show Memory, and press . DevTools displays the Memory panel at the top of your DevTools window.\n\nAlternatively, you can open the Memory panel in the following ways:\n• In the action bar at the top, click More panels and select Memory from the drop-down list.\n• In the top right corner, select More options > More tools > Memory."
    },
    {
        "link": "https://developer.chrome.com/docs/devtools/memory-problems/heap-snapshots",
        "document": "Stay organized with collections Save and categorize content based on your preferences.\n\nLearn how to record heap snapshots with Memory > Profiles > Heap snapshot and find memory leaks.\n\nThe heap profiler shows memory distribution by your page's JavaScript objects and related DOM nodes. Use it to take JS heap snapshots, analyze memory graphs, compare snapshots, and find memory leaks. For more information, see Objects retaining tree.\n• On a page you want to profile, open DevTools and navigate to the Memory panel.\n• Select the Heap snapshot profiling type, then select a JavaScript VM instance, and click Take snapshot.\n\nWhen the Memory panel loads and parses the snapshot, it shows the total size of reachable JavaScript objects below the snapshot title in the HEAP SNAPSHOTS section.\n\nSnapshots show only the objects from the memory graph that are reachable from the global object. Taking a snapshot always starts with garbage collection.\n\nTo remove all snapshots, click block Clear all profiles:\n\nTo inspect snapshots from different perspectives for different purposes, select one of the views from the drop-down menu at the top:\n\nInitially, a heap snapshot opens in the Summary view that lists Constructors in a column. Constructors are named after the JavaScript function that created the object, plain objects names are based on the proper they contain, and some names are special entries. All objects are grouped by their names first, then by the line in the source file they come from, for example, .\n\nYou can expand grouped constructors to see the objects they instantiated.\n\nTo filter out irrelevant constructors, type a name that you want to inspect in the Class filter at the top of the Summary view.\n\nThe numbers next to constructor names indicate the total number of objects created with the constructor. The Summary view also shows the following columns:\n• Distance shows the distance to the root using the shortest simple path of nodes.\n• Shallow size shows the sum of shallow sizes of all objects created by a certain constructor. The shallow size is the size of memory held by an object itself. Generally, arrays and strings have larger shallow sizes. See also Object sizes.\n• Retained size shows the maximum retained size among the same set of objects. Retained size is the size of memory that you can free by deleting an object and making its dependents no longer reachable. See also Object sizes.\n\nWhen you expand a constructor, the Summary view shows you all of its instances. Each instance gets a breakdown of its shallow and retained sizes in the corresponding columns. The number after the character is the object's unique ID. It lets you compare heap snapshots on per-object basis.\n\nSummary view lets you filter constructors based on common cases of inefficient memory usage.\n\nTo use these filters, select one of the following options from the rightmost drop-down menu in the action bar:\n• All objects: all objects captured by the current snapshot. Set by default.\n• Objects allocated before snapshot 1: objects that were created and remained in memory before the first snapshot was taken.\n• Objects allocated between Snapshots 1 and Snapshots 2: view the difference in objects between the most recent snapshot and the previous snapshot. Each new snapshot adds an increment of this filter to the drop-down list.\n• Duplicated strings: string values that have been stored multiple times in memory.\n• Objects retained by detached nodes: objects that are kept alive because a detached DOM node references them.\n• Objects retained by the DevTools console: objects kept in memory because they were evaluated or interacted with through the DevTools console.\n\nIn addition to grouping by constructors, the Summary view also groups objects by:\n• Built-in functions such as or .\n• HTML elements grouped by their tags, for example, , , , and others.\n• Functions you defined in your code.\n\nThis category includes various internal array-like objects that don't directly correspond to objects visible in JavaScript.\n\nFor example, the contents of JavaScript objects are stored in a secondary internal object named , to allow easier resizing. Similarly, the named properties in JavaScript objects are often stored in secondary internal objects named that are also listed in the category.\n\nThis category includes internal data that V8 needs so that it can run functions defined by JavaScript or WebAssembly. Each function can be represented in a variety of ways, from small and slow to large and fast.\n\nV8 automatically manages memory usage in this category. If a function runs many times, V8 uses more memory for that function so that it can run faster. If a function hasn't run in a while, V8 may clear the internal data for that function.\n\nWhen V8 concatenates two strings, such as with the JavaScript operator, it may choose to represent the result internally as a \"concatenated string\" also known as the Rope data structure.\n\nRather than copying all of the characters of the two source strings into a new string, V8 allocates a small object with internal fields called and , which point to the two source strings. This lets V8 save time and memory. From the perspective of JavaScript code, these are just normal strings, and they behave like any other string.\n\nThis category represents objects allocated outside V8, such as C++ objects defined by Blink.\n\nTo see C++ class names, use Chrome for Testing and do the following:\n• Open DevTools and turn on Settings > Experiments > Show option to expose internals in heap snapshots.\n• Open the Memory panel, select Heap snapshot, and turn on Expose internals (includes additional implementation-specific details).\n• Reproduce the issue that caused the to retain a lot of memory.\n• Take a heap snapshot. In this snapshot, objects have C++ class names instead of .\n\nAs described in Fast Properties in V8, V8 tracks hidden classes (or shapes) so that multiple objects with the same properties in the same order can be represented efficiently. This category contains those hidden classes, called (unrelated to JavaScript ), and related data.\n\nWhen V8 needs to take a substring, such as when JavaScript code calls , V8 may choose to allocate a sliced string object rather than copying all of the relevant characters from the original string. This new object contains a pointer to the original string and describes which range of characters from the original string to use.\n\nFrom the perspective of JavaScript code, these are just normal strings, and they behave like any other string. If a sliced string is retaining a lot of memory, then the program may have triggered Issue 2869 and might benefit from taking deliberate steps to \"flatten\" the sliced string.\n\nInternal objects of type contain local variables from a closure—a JavaScript scope that a nested function can access.\n\nEvery function instance contains an internal pointer to the in which it executes, so that it can access those variables. Even though objects aren't directly visible from JavaScript, you do have direct control over them.\n\nThis category contains various internal objects that haven't (yet) been categorized in any more meaningful way.\n\nThe Comparison view lets you find leaked objects by comparing multiple snapshots to each other. For example, doing an action and reversing it, like opening a document and closing it, shouldn't leave extra objects behind.\n\nTo verify that a certain operation doesn't create leaks:\n• Take a heap snapshot before performing an operation.\n• Perform an operation. That is, interact with a page in some way that you think might be causing a leak.\n• Perform a reverse operation. That is, do the opposite interaction and repeat it a few times.\n• Take a second heap snapshot and change its view to Comparison, comparing it to Snapshot 1.\n\nThe Comparison view shows the difference between two snapshots. When expanding a total entry, added and deleted object instances are shown:\n\nThe Containment view is a \"bird's eye view\" of your application's objects structure. It lets you peek inside function closures, observe VM internal objects that together make up your JavaScript objects, and to understand how much memory your application uses at a very low level.\n\nThe view provides several entry points:\n• GC roots. GC roots used by the VM's garbage collector. GC roots can consist of built-in object maps, symbol tables, VM thread stacks, compilation caches, handle scopes, and global handles.\n• Native objects. Browser objects \"pushed\" inside the JavaScript virtual machine to allow automation, for example, DOM nodes and CSS rules.\n\nThe Retainers section at the bottom of the Memory panel shows objects that point to the object selected in the view. The Memory panel updates the Retainers section when you select a different objects in any of the views except Statistics.\n\nIn this example, the selected string is retained by the property of an instance.\n\nYou can hide retainers to find out of any other objects retain the selected one. With this option, you don't have to first remove this retainer from the code and then retake the heap snapshot.\n\nTo hide a retainer, right-click and select Ignore this retainer. Ignored retainers are marked as in the Distance column. To stop ignoring all retainers, click playlist_remove Restore ignored retainers in the action bar at the top.\n\nTo find an object in the collected heap you can search using and enter the object ID.\n\nIt helps a lot to name the functions so you can distinguish between closures in the snapshot.\n\nFor example, the following code doesn't use named functions:\n\nWhilst this example does:\n\nThe heap profiler has the ability to reflect bidirectional dependencies between browser-native objects (DOM nodes and CSS rules) and JavaScript objects. This helps discover otherwise invisible leaks happening due to forgotten detached DOM subtrees floating around.\n\nDOM leaks can be bigger than you think. Consider the following example. When is the garbage collected?\n\nmaintains a reference to its parent ( ) and recursively up to , so only when is nullified is the whole tree under a candidate for GC."
    },
    {
        "link": "https://medium.com/performance-engineering-for-the-ordinary-barbie/intro-to-memory-profiling-chrome-devtools-memory-tab-explained-5a99d3ba85d2",
        "document": "Now, back onto memory profiles and the different profile types.\n\nBefore we look at the Memory tab, let’s first look at the Performance tab. When you go to the Performance tab, you have an option to check the “memory” checkbox when collecting profiles.\n\nIf you check that “memory” box and run the profiler, it will give you some graphs that look like this:\n\nThis graph shows the size of JS heap over time as I was interacting with the page.\n\nAs you interact with a page, memory can grow for many reasons. React for instance, maintains a virtual DOM representation of the actual DOM, and this virtual DOM lives within the heap memory. Thus, as you add more and more elements into the application (e.g. via infinite scroll), you will increase the size of this virtual DOM, and thus your JS heap. When you create Redux stores, they also live in the heap.\n\nLooking at which user interactions are associated with JS heap growth is a good starting point to investigating memory leaks.\n\nThe “JS heap” graph here tells you the size of Javascript heap memory currently in use over time. However, it doesn’t tell you what objects in memory have grown over time.\n\nFor this, you need the Heap snapshot from the Memory tab.\n\nThe Heap snapshot gives you a detailed view of your JS heap.\n\nBelow, I took a Heap snapshot of Medium.com after the page load. And I took one again after scrolling down its infinite scroll for a bit.\n\nThis gives you a rough idea of what kind of objects has increased from one snapshot to the other. As you can see, the shallow size of has increased by 26MB. The objects themselves have increased from 200,936 to 1,145,575. Shallow size means the size of the object itself. Retained size means the size of the object itself and all the objects it alone references. In other words, it is the size that would be freed once this object is deleted from the heap.\n\nI will write a detailed step-by-step with examples of how to investigate memory leaks in a future article. Stay tuned!\n\nThe information from Heap Snapshot is analogous to the “heap live objects” and “heap live size” profile types from the Datadog UI for Go runtime.\n\nHowever, the Heap snapshot from Chrome doesn’t tell you what functions created these objects. In other words, you can’t build a Flame Graph with this information.\n\nIf you want to look into how functions are contributing to the JS heap as you interact with the page (e.g. infinite scrolling on the Medium homepage), you need to select “allocation sampling.”\n\nSelect Allocation sampling, and record a profile as you interact with the page. Then stop it. This produces an “Allocated Memory” profile type.\n\nAllocated memory profile type shows you the amount of heap memory allocated by each function over the duration of the profile, including allocations which were subsequently freed. That’s a big difference between this profile type and heap live size, which tells you the live size at the time the heap snapshot was taken.\n\nLook at the first line, the function has allocated 3.4 MB. Self size is analogous to the shallow size used in Heap snapshot, and is the size of the allocated objects themselves. Total size is analogous to retained size mentioned earlier.\n\nBecause the Javascript is minimized, we can’t actually tell what functions etc. are referring to. You’ll need a source map or an non-minimized development version.\n\nNotice at the top a Select field with ? This refers to how the functions are displayed.\n\nThis way of visualizing data is called a Call Tree.\n\nBottom up indicates the direction of the Call Tree, which refers to the direction of the stack trace.\n\nLet’s say you have function calling and , both of which call :\n\nBottom up tree view will look like:\n\nTop down will look like:\n\nA (top down) Flame Graph, on the other hand, will look like:\n\nCall Trees are not as user-friendly as a Flame Graphs, are they?\n\nThis goes to show having the right visualization is critical for making profiling accessible to non-experts. Want to learn more about how to visualize profiling data, read my blog here.\n\nIn our real life example with ,\n\nis a leaf node, and are called from several places, amongst which are , , , and some “anonymous” functions like callbacks. Any Javascript function without a name are going show up as “anonymous.” E.g:\n\nAbove, there are two anonymous functions. One for the closure passed into setTimeout, and the other for the callback. And yes, anonymous functions make debugging difficult."
    },
    {
        "link": "https://github.com/GoogleChrome/devtools-docs/blob/master/docs/javascript-memory-profiling.md",
        "document": "The DevTools docs have moved! Read the latest version of this article and head over to the new home of Chrome DevTools for the latest tutorials, docs and updates.\n\nA memory leak is a gradual loss of available computer memory. It occurs when a program repeatedly fails to return memory it has obtained for temporary use. JavaScript web apps can often suffer from similar memory related issues that native applications do, such as leaks and bloat but they also have to deal with garbage collection pauses.\n\nAlthough JavaScript uses garbage collection for automatic memory management, effective memory management is still important. In this guide we will walk through profiling memory issues in JavaScript web apps. Be sure to try the supporting demos when learning about features to improve your awareness of how the tools work in practice.\n\nRead the Memory 101 page to become familiar with the terms used in this document.\n\nNote: Some of these features we will be using are currently only available in Chrome Canary. We recommend using this version to get the best memory profiling tooling for your applications.\n\nIn general, there are three questions you will want to answer when you think you have a memory leak:\n• Is my page using too much memory? - the Timeline memory view and Chrome task manager can help you identify if you’re using too much memory. Memory view can track the number of live DOM nodes, documents and JS event listeners in the inspected render process. As a rule of thumb: avoid holding references to DOM elements you no longer need to use, unbind unneeded event listeners and take care when storing large chunks of data you aren't going to use.\n• Is my page free of memory leaks? - the Object allocation tracker can help you narrow down leaks by looking at JS object allocation in real-time. You can also use the heap profiler to take JS heap snapshots, analyze memory graphs and compare snapshots to discover what objects are not being cleaned up by garbage collection.\n• How frequently is my page forcing garbage collection? - if you are GCing frequently, you may be allocating too frequently. The Timeline memory view can help you identify pauses of interest.\n\nThis section describes common terms used in memory analysis, and is applicable to a variety of memory profiling tools for different languages. The terms and notions described here are used in the Heap Profiler UI and the corresponding documentation.\n\nIt helps to become familiar with these to use the tool effectively. If you have ever worked with either the Java, .NET, or some other memory profiler then this may be a refresher.\n\nThink of memory as a graph with primitive types (like numbers and strings) and objects (associative arrays). It might visually be represented as a graph with a number of interconnected points as follows:\n\nAn object can hold memory in two ways:\n• Directly by the object itself\n• Implicitly by holding references to other objects, and therefore preventing those objects from being automatically disposed by a garbage collector (GC for short).\n\nWhen working with the Heap Profiler in DevTools (a tool for investigating memory issues found under \"Profiles\"), you will likely find yourself looking at a few different columns of information. Two that stand out are Shallow Size and Retained Size, but what do these represent?\n\nThis is the size of memory that is held by the object itself.\n\nTypical JavaScript objects have some memory reserved for their description and for storing immediate values. Usually, only arrays and strings can have a significant shallow size. However, strings and external arrays often have their main storage in renderer memory, exposing only a small wrapper object on the JavaScript heap.\n\nRenderer memory is all memory of the process where an inspected page is rendered: native memory + JS heap memory of the page + JS heap memory of all dedicated workers started by the page. Nevertheless, even a small object can hold a large amount of memory indirectly, by preventing other objects from being disposed of by the automatic garbage collection process.\n\nThis is the size of memory that is freed once the object itself is deleted along with its dependent objects that were made unreachable from GC roots.\n\nGC roots are made up of handles that are created (either local or global) when making a reference from native code to a JavaScript object outside of V8. All such handles can be found within a heap snapshot under GC roots > Handle scope and GC roots > Global handles. Describing the handles in this documentation without diving into details of the browser implementation may be confusing. Both GC roots and the handles are not something you need to worry about.\n\nThere are lots of internal GC roots most of which are not interesting for the users. From the applications standpoint there are following kinds of roots:\n• Window global object (in each iframe). There is a distance field in the heap snapshots which is the number of property references on the shortest retaining path from the window.\n• Document DOM tree consisting of all native DOM nodes reachable by traversing the document. Not all of them may have JS wrappers but if they have the wrappers will be alive while the document is alive.\n• Sometimes objects may be retained by debugger context and DevTools console (e.g. after console evaluation).\n\nNote: We recommend users to do heap snapshots with clear console and no active breakpoints in the debugger.\n\nThe memory graph starts with a root, which may be the object of the browser or the object of a Node.js module. You don't control how this root object is GC'd.\n\nWhatever is not reachable from the root gets GC.\n\nNote: Both the Shallow and Retained size columns represent data in bytes.\n\nAs we introduced earlier, the heap is a network of interconnected objects. In the mathematical world, this structure is called a graph or memory graph. A graph is constructed from nodes connected by means of edges, both of which are given labels.\n• Nodes (or objects) are labelled using the name of the *constructor *function that was used to build them\n• Edges are labelled using the names of properties.\n\nLater in this guide you will learn how to record a profile using the Heap Profiler. Some of the eye-catching things we can see in the Heap Profiler recording below include distance: the distance from the GC root. If almost all the objects of the same type are at the same distance, and a few are at a bigger distance, that's something worth investigating.\n\nDominator objects are comprised of a tree structure because each object has exactly one dominator. A dominator of an object may lack direct references to an object it dominates, that is, the dominators tree is not a spanning tree of the graph.\n\nIn the diagram above:\n\nIn the example below, node is the dominator of , but also exists in every simple path from GC to . Therefore, an object B is a dominator of an object A if B exists in every simple path from the root to the object A.\n\nIn this section we describe some memory-related topics that correspond specifically to the **V8 JavaScript virtual machine **(V8 VM or VM). When profiling memory, it is helpful to understand why heap snapshots look this way.\n\nThere are three primitive types:\n\nThey cannot reference other values and are always leafs or terminating nodes.\n\nNumbers can be stored as either:\n• an immediate 31-bit integer values called small integers (SMIs), or\n• heap objects, referred to as heap numbers. Heap numbers are used for storing values that do not fit into the SMI form, such as doubles, or when a value needs to be boxed, such as setting properties on it.\n\nStrings can be stored in either:\n• externally in the renderer’s memory. A wrapper object is created and used for accessing external storage where, for example, script sources and other content that is received from the Web is stored, rather than copied onto the VM heap.\n\nMemory for new JavaScript objects is allocated from a dedicated JavaScript heap (or VM heap). These objects are managed by V8's garbage collector and therefore, will stay alive as long as there is at least one strong reference to them.\n\n**Native objects **are everything else which is not in the JavaScript heap. Native object, in contrast to heap object, is not managed by the V8 garbage collector throughout it’s lifetime, and can only be accessed from JavaScript using its JavaScript wrapper object.\n\n**Cons string **is an object that consists of pairs of strings stored then joined, and is a result of concatenation. The joining of the cons string contents occurs only as needed. An example would be when a substring of a joined string needs to be constructed.\n\nFor example, if you concatenate a and b, you get a string (a, b) which represents the result of concatenation. If you later concatenated d with that result, you get another cons string ((a, b), d).\n\nArrays - An Array is an Object with numeric keys. They are used extensively in the V8 VM for storing large amounts of data. Sets of key-value pairs used like dictionaries are backed up by arrays.\n\nA typical JavaScript object can be one of two array types used for storing:\n\nIn cases where there is a very small number of properties, they can be stored internally in the JavaScript object itself.\n\nMap - an object that describes the kind of object and its layout. For example, maps are used to describe implicit object hierarchies for fast property access.\n\nEach native objects group is made up from objects that hold mutual references to each other. Consider for example a DOM subtree, where every node has a link to its parent and links to the next child and next sibling, thus forming a connected graph. Note that native objects are not represented in the JavaScript heap — that's why they have zero size. Instead, wrapper objects are created.\n\nEach wrapper object holds a reference to the corresponding native object, for redirecting commands to it. In its own turn, an object group holds wrapper objects. However, this doesn't create an uncollectable cycle, as GC is smart enough to release object groups whose wrappers are no longer referenced. But forgetting to release a single wrapper will hold the whole group and associated wrappers.\n\nNote: When profiling memory issues in Chrome, it is a good idea to setup a clean-room testing environment.\n\nUsing the Chrome Task Manager you can quickly see if a page is consuming a lot of memory by monitoring the memory columns while performing actions that may be causing this to happen. The Task Manager is accessed from the Chrome menu > Tools or by pressing Shift + Esc.\n\nOnce open, right-click on the heading area of the columns and enable the JavaScript memory column.\n\nThe first step in solving any performance problem is having the ability to show proof that the problem exists. This means being able to create a reproducible test that can be used to take a baseline measurement of the problem. Without a reproducible program, you cannot reliably measure the problem. Further, without a baseline measurement, there is no way of knowing that any changes made are improving performance.\n\nThe Timeline panel is helpful for determining when a problem exists. It gives a complete overview of where time is spent when loading and interacting with your web app or page. All events, from loading resources to parsing JavaScript, calculating styles, garbage collection pauses, and repainting are plotted on a timeline.\n\nWhen investigating memory issues, the Timeline panel’s Memory view can be used for tracking:\n\nTo read more about how to isolate problems that might be causing leaks during your memory profiling sessions, see Memory profiling with the Chrome DevTools by Zack Grossbart.\n\nThe first thing to do is identify a sequence of actions you suspect is leaking memory. This could be anything from navigating around a site, hovering, clicking, or otherwise somehow interacting with page in a way that seems to negatively impact performance more over time.\n\nOn the Timeline panel start recording (Ctrl + E or Cmd + E) and perform the sequence of actions you want to test. To force a full garbage collection click the trash icon ( ) at the bottom.\n\nBelow we see a memory leak pattern, where some nodes are not being collected:\n\nIf after a few iterations you see a sawtooth shaped graph (in the memory pane at the top), you are allocating lots of shortly lived objects. But if the sequence of actions is not expected to result in any retained memory, and the DOM node count does not drop down back to the baseline where you began, you have good reason to suspect there is a leak.\n\nOnce you’ve confirmed that the problem exists, you can get help identifying the source of the problem using the **heap profiler **on the Profiles panel.\n\nExample: Try out this example of memory growth where you can practice how to effectively use Timeline memory mode.\n\nA garbage collector (such as the one in V8) needs to be able to locate objects in your application which are live, as well as, those which are considered dead (garbage*)* and are unreachable.\n\nIf garbage collection (GC) misses any dead objects due to logical errors in your JavaScript then the memory consumed by these objects cannot be reclaimed. Situations like this can end up slowing down your application over time.\n\nThis often happens when you’ve written your code in such a way that variables and event listeners you don’t require are still referenced by some code. While these references are maintained, the objects cannot be correctly cleaned up by GC.\n\nRemember to check and nullify variables that contain references to DOM elements which may be getting updated/destroyed during the lifecycle of your app. Check object properties which may reference other objects (or other DOM elements). Be sure to keep an eye on variable caches which may accumulate over time.\n\nOn the Profiles panel, choose ** Take Heap Snapshot **, then click Start or press Cmd + E or Ctrl + E:\n\n** **Snapshots are initially stored in the renderer process memory. They are transferred to the DevTools on demand, when you click on the snapshot icon to view it. After the snapshot has been loaded into DevTools and has been parsed, the number below the snapshot title appears and shows the total size of the reachable JavaScript objects:\n\nExample: Try out this example of garbage collection in action and monitor memory usage in the Timeline.\n\nSnapshots can be removed (both from DevTools and renderers memory) by pressing the Clear all profiles icon ( ):\n\nNote: Closing the DevTools window will not delete ed profiles from the renderers memory. When reopening DevTools, all previously taken snapshots will reappear in the list of snapshots.\n\nRemember that we mentioned earlier you can force GC from the DevTools as part of your snapshot workflow. When taking a Heap Snapshot, it is automatically forced. In Timeline it can be very convenient to force a GC by clicking on the trash can ( Garbage) button ( ).\n\nExample: Try out this example of scattered objects and profile it using the Heap Profiler. You should see a number of (object) item allocations.\n\nA snapshot can be viewed from different perspectives for different tasks. To switch between views, use the selector at the bottom of the view:\n\nThere are three default views:\n• **Summary — **shows objects grouped by the constructor name;\n\nThe **Dominators **view, which can be enabled via the Settings panel **— **shows the dominators tree. and can be useful to find accumulation points.\n\nProperties and property values of objects have different types and are colored accordingly. ** **Each property has one of four types:\n• **a: property — **a regular property with a name, accessed via the . (dot) operator, or via [ ] (brackets) notation, e.g. [\"foo bar\"];\n• a:** context var — **a variable in a function context, accessible by its name from inside a function closure;\n• a:** system prop — **property added by the JavaScript VM, not accessible from JavaScript code.\n\nObjects designated as do not have a corresponding JavaScript type. They are part of JavaScript VM's object system implementation. V8 allocates most of its internal objects in the same heap as the user's JS objects. So these are just v8 internals.\n\nTo find an object in the collected heap you can search using and giving the object ID.\n\nInitially, a snapshot opens in the Summary view, displaying object totals, which can be expanded to show instances:\n• the **Constructor represents **all objects created using this constructor\n• the number of object instances is displayed in the # column\n• the Shallow size column displays the sum of shallow sizes of all objects created by a certain constructor function\n• the Retained size column displays the maximum retained size among the same set of objects\n• the **Distance **displays the distance to the root using the shortest simple path of nodes.\n\nAfter expanding a total line in the upper view, all of its instances are displayed. For each instance, its shallow and retained sizes are displayed in the corresponding columns. The number after the @ character is the objects’ unique ID, allowing you to compare heap snapshots on per-object basis.\n\nExample: Try this demo page (opens in a new tab) to understand how the Summary view can be used.\n\nRemember that yellow objects have JavaScript references on them and red objects are detached nodes which are referenced from one with a yellow background.\n\nThis view is used to compare multiple snapshots to each other so that you can see what the difference between them are in order to find leaked objects. To verify that a certain application operation doesn't create leaks (e.g. usually a pair of direct and reverse operations, like opening a document, and then closing it, should not leave any garbage), you may follow the scenario below:\n• Take a heap snapshot before performing an operation;\n• Perform an operation (interact with a page in some way that you believe to be causing a leak);\n• Perform a reverse operation (do the opposite interaction and repeat it a few times);\n• Take a second heap snapshot and change the view of this one to Comparison, comparing it to snapshot 1.\n\nIn the Comparison view, the difference between two snapshots is displayed. When expanding a total entry, added and deleted object instances are shown:\n\nExample: Try this demo page (opens in a new tab) to get an idea how to use snapshot comparison for detecting leaks.\n\nThe Containment view is essentially a \"bird's eye view\" of your application's objects structure. It allows you to peek inside function closures, to observe VM internal objects that together make up your JavaScript objects, and to understand how much memory your application uses at a very low level.\n\nThe view provides several entry points:\n• DOMWindow** objects** — these are objects considered as \"global\" objects for JavaScript code;\n• GC roots — actual GC roots used by VM's garbage or;\n• Native objects — browser objects that are \"pushed\" inside the JavaScript virtual machine to allow automation, e.g. DOM nodes, CSS rules (see the next section for more details.)\n\nBelow is the example of a populated Containment view:\n\nExample: Try this demo page (opens in a new tab) for finding out how to explore closures and event handlers using the view.\n\nIt helps a lot to name the functions so you can easily distinguish between closures in the snapshot. For example, this example does not use named functions:\n\nWhilst this example does:\n\nExamples: Try out this example of why eval is evil to analyze the impact of closures on memory. You may also be interested in following it up with this example that takes you through recording heap allocations.\n\nA unique ability of the tool is to reflect bidirectional dependencies between browser native objects (DOM nodes, CSS rules) and JavaScript objects. This helps to discover otherwise invisible leaks happening due to forgotten detached DOM subtrees floating around.\n\nDOM leaks can be bigger than you think. Consider the following sample - when is the #tree GC?\n\nmaintains a reference to it's parent (parentNode) and recursively up to , so only when leafRef is nullified is the WHOLE tree under a candidate for GC.\n\nExamples: Try out this example of leaking DOM nodes to understand where DOM nodes can leak and how to detect them. You can follow it up by also looking at this example of DOM leaks being bigger than expected.\n\nTo read more about DOM leaks and memory analysis fundamentals checkout Finding and debugging memory leaks with the Chrome DevTools by Gonzalo Ruiz de Villa.\n\nNative objects are most easily accessible from Summary and Containment views — there are dedicated entry nodes for them:\n\nExample: Try this demo (opens in a new tab) to play with detached DOM trees.\n\nThe Dominators view shows the dominators tree for the heap graph. The Dominators view looks similar to the Containment view, but lacks property names. This is because a dominator of an object may lack direct references to it, that is, the dominators tree is not a spanning tree of the graph. But this only serves for good, as helps us to identify memory accumulation points quickly.\n\nNote: In Chrome Canary, Dominators view can be enabled by going to Settings > Show advanced heap snapshot properties and restarting the DevTools.\n\nExamples: Try this demo (opens in a new tab) to train yourself in finding accumulation points. Follow it up with this example of running into retaining paths and dominators.\n\nThe object tracker combines the detailed snapshot information of the heap profiler with the incremental updating and tracking of the Timeline panel. Similar to these tools, tracking objects’ heap allocation involves starting a recording, performing a sequence of actions, then stop the recording for analysis.\n\nThe object tracker takes heap snapshots periodically throughout the recording (as frequently as every 50 ms!) and one final snapshot at the end of the recording. The heap allocation profile shows where objects are being created and identifies the retaining path.\n\nEnabling and using the Object Tracker\n\nTo begin using the Object Tracker:\n• Make sure you have the latest Chrome Canary.\n• Open the Developer Tools and click on the gear icon in the lower right.\n• Now, open the Profiler panel, you should see a profile called \"Record Heap Allocations\"\n\nThe bars at the top indicate when new objects are found in the heap. The height of each bar corresponds to the size of the recently allocated objects, and the color of the bars indicate whether or not those objects are still live in the final heap snapshot: blue bars indicate objects that are still live at the end of the timeline, gray bars indicate objects that were allocated during the timeline, but have since been garbage collected.\n\nIn the example above, an action was performed 10 times. The sample program caches five objects, so the last five blue bars are expected. But the leftmost blue bar indicates a potential problem. You can then use the sliders in the timeline above to zoom in on that particular snapshot and see the objects that were recently allocated at that point.\n\nClicking on a specific object in the heap will show its retaining tree in the bottom portion of the heap snapshot. Examining the retaining path to the object should give you enough information to understand why the object was not collected, and you can make the necessary code changes to remove the unnecessary reference.\n\nQ: I don't see all the properties of objects, I don't see non-string values for them! Why?\n\nNot all properties are actually stored on the JavaScript heap. Some of them are implemented using getters that execute native code. Such properties are not captured in heap snapshots in order to avoid the cost of calling getters and to avoid possible program state changes if getters are not \"pure\" functions. Also, non-string values such as numbers are not captured in an attempt to reduce snapshot size.\n\nQ: What does the number after the @ char mean — is this an address or an ID? Is the ID value really unique?\n\nThis is an object ID. Displaying an object's address makes no sense, as objects are moved during garbage collections. Those object IDs are real IDs — that means, they persist among multiple snapshots taken and are unique. This allows precise comparison between heap states. Maintaining those IDs adds an overhead to GC cycles, but it is only initiated after the first heap snapshot was taken — no overhead if heap profiles aren't used.\n\nNo. Only reachable objects are included in snapshots. Also, taking a snapshot always starts with doing a GC.\n\nNote:At the time of writing, we are planning on avoiding this GC to reduce the drop in used heap size when taking heap snapshots. This has yet to be implemented but garbage would still be out of the snapshot.\n\nQ: I’ve been told to use the Heap Profiler and Timeline Memory view for detecting memory leaks. What tool should be used first?\n\nThe Timeline. Use it to diagnose excessive memory usage when you first notice your page has slowed down after extended use. Slowdown was once a classic symptom of a memory leak but it could also be something else – maybe you have a paint or network bottleneck in your page, so make sure to fix the real issue in your page.\n\nTo diagnose whether memory is the issue, go to the Timeline panel and Memory view. Hit the record button and interact with your application, repeating any steps you feel may be causing a leak. Stop the recording. The graph you see will display the memory allocated to your application. If it happens to be consuming an increasing amount of this over time (without ever dropping), it’s an indication you may have a memory leak.\n\nThe profile for a healthy application should look more like a sawtooth curve as memory is allocated then freed when the garbage collector comes in. There’s nothing to worry about here – there’s always going to be a cost of doing business in JavaScript and even an empty will cause this type of sawtooth, you can’t avoid it. Just ensure it’s not sharp as that’s an indication a lot of allocations are being made, which can equate to a lot of garbage on the other side.\n\nIt's the rate of increase in the steepness of this curve that you need to keep an eye on.There is also a DOM node counter, Document counter and Event listener count in the Memory view which can be useful during diagnosis. DOM nodes use native memory and do not directly affect the JavaScript memory graph.\n\nOnce you suspect you have a memory leak, the Heap profiler can be used to discover the source of the leak.\n\n**Q: I noticed a number of DOM nodes in the heap snapshot where some are highlighted in red and indicated as a \"Detached DOM tree\" whilst others are yellow. What does this mean? **\n\nYou'll notice nodes of a few different colors. Red nodes (which have a darker background) do not have direct references from JavaScript to them, but are alive because they’re part of a detached DOM tree. There may be a node in the tree referenced from JavaScript (maybe as a closure or variable) but is coincidentally preventing the entire DOM tree from being garbage collected.\n\nYellow nodes (with a yellow background) however do have direct references from JavaScript. Look for yellow nodes in the same detached DOM tree to locate references from your JavaScript. There should be a chain of properties leading from the DOM window to the element (e.g ).\n\nAn animation of where detached nodes fit into the overall picture can be seen below:\n\nExample: Try out this example of detached nodes where you can watch node evolution in the Timeline then take heap snapshots to find detached nodes.\n\nQ: What do the Shallow and Retained Size columns represent and what are the differences between them?\n\nSo, objects can be kept in memory (be alive) in two different ways – either directly by another alive object (window and document are always alive objects) or implicitly by holding references from native part of the renderer (like DOM objects). The latter is what ends up preventing these objects from being disposed by GC automatically, causing leaks. The size of memory held by an object itself is known as the shallow size (generally, arrays and strings have larger shallow sizes).\n\nAn object of any size can hold a ton of memory if it prevents other objects from being disposed. The size of memory that can be freed once an object is deleted (and this its dependents made no longer reachable) is called the retained size.\n\nQ: There's a lot of data in the constructor and retained views. Where should I start digging into to discover if I have a leak?\n\nIt's generally a good idea to begin investigation from the first object retained in your tree as retainers are sorted by distance (well, distance to the window).\n\nThe object retained with the shortest distance is usually your first candidate for causing a memory leak.\n\nQ: What's the difference between the different Summary, Comparison, Dominators and Containment views?\n\nYou may get some mileage by switching between the different data views available at the bottom of the screen.\n• Summary view helps you hunt down objects (and their memory use) based on type grouped by constructor name. This view is particularly helpful for tracking down DOM leaks.\n• Comparison view helps you track down memory leaks, by displaying which objects have been correctly cleaned up by the garbage collector. Generally used to record and compare two (or more) memory snapshots of before and after an operation. The idea is that inspecting the delta in freed memory and reference count lets you confirm the presence and cause of a memory leak.\n• Containment view provides a better view of object structure, helping us analyse objects referenced in the global namespace (i.e. window) to find out what is keeping them around. It lets you analyse closures and dive into your objects at a low level.\n• Dominators view helps confirm that no unexpected references to objects are still hanging around (i.e that they are well contained) and that deletion/garbage collection is actually working.\n\nQ: What do the various constructor (group) entries in the Heap profiler correspond to?** **\n• (global property) – intermediate objects between a global object (like 'window') and an object referenced by it. If an object is created using a constructor Person and is held by a global object, the retaining path would look like [global] > (global property) > Person. This contrasts with the norm, where objects directly reference each other. We have intermediate objects for performance reasons. Globals are modified regularly and property access optimisations do a good job for non-global objects aren't applicable for globals.\n• (roots) – The root entries in the retaining tree view are the entities that have references to the selected object. These can also be references created by the engine for its own purposes. The engine has caches which reference objects, but all such references are weak and won't prevent an object from being collected given that there are no truly strong references.\n• (closure) – a count of references to a group of objects through function closures\n• (array, string, number, regexp) – a list of object types with properties which reference an Array, String, Number or regular expression\n• (compiled code) – simply, everything related to compiled code. Script is similar to a function but corresponds to a <script> body. SharedFunctionInfos (SFI) are objects standing between functions and compiled code. Functions are usually have a context, while SFIs do not.\n• HTMLDivElement, HTMLAnchorElement, DocumentFragment etc – references to elements or document objects of a particular type referenced by your code.\n\nMany of the other objects you may see were likely generated during the lifecycle of your code and can include event listeners as well as custom objects, like the controllers below:\n\nQ: Is there anything I should be turning off in Chrome that might be influencing my figures?\n\nWhen performing any type of profiling using the Chrome DevTools, it is recommended that you either run in incognito mode with all extensions disabled or start Chrome with a custom user data directory ( ).\n\nApps, extensions and even console logging can have an implicit impact on your figures and you want to keep them as reliable as possible.\n\nThe JavaScript engines of today are highly capable of automatically cleaning garbage generated by our code in a number of situations. That said, they can only go so far and our applications are still prone to memory leaks caused by logical errors. Use the tools available to find out your bottlenecks and remember, don't guess it - test it.\n\nAlthough we've mentioned them throughout this guide, a good set of end-to-end examples for testing various memory issues, ranging from growing memory leaking DOM nodes can be found summarized below. You may wish to experiment with them before attempting to use the tooling on your own more complex page or application.\n• Example 7: Eval is evil (almost always)\n\nAdditional demos are available for:\n\nMemory Management Masterclass with Addy Osmani gives you a crash-course in debugging memory issues. The slides for the presentation are available as well as the example code.\n\nThere are a number of excellent resources written by the community on finding and fixing memory issues in web apps using the Chrome DevTools. Below are a selection of some you may find useful:\n• Finding and debugging memory leaks with the Chrome DevTools\n• Rendering and memory profiling with the DevTools"
    },
    {
        "link": "https://stackoverflow.com/questions/56311832/how-to-find-a-particular-object-in-devtools-memory-snapshot-if-the-type-of-the-o",
        "document": "It would be very hard to distinct the plain \"Objects\" returned by from all of the plain Objects in the heap snapshot\n\nHere's what I've done to \"tag\" the objects so I can distinct them easily:\n• Create a class that can be easily found in dev tools\n• Create a wrapper function to be called in place of\n• the key is the original return value\n• the value is a\n• when the original value is no longer retained anywhere - it's automatically garbage collected from the\n\nThe is referencing the original data directly, but since nothing is referencing the - we never expose it - it does not prevent the from garbage collecting the original data and the that captured it\n\nHere is a sample of how that works in Chrome Dev Tools:\n• Search for the object class name (TaggedItem)\n• It's retained by the property of another object, that uses the original data\n\nA simpler approach is to append a key to the original object\n\nThis way you can still filter by in dev tools and see what's retaining the and in turn the parent object\n\nThe first approach gives a better estimate of total retained memory, while the simple approach would just allow you to trace what's retaining the original"
    }
]