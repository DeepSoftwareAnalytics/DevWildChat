[
    {
        "link": "https://stackoverflow.com/questions/70132031/understanding-hack-assembly-language-code",
        "document": "There are at least 3 levels upon which to understand such code:\n• None What does each individual instruction do (each line of assembly)? These are explained in the tutorial texts, but most instructions simply move some data from one register, or memory location, or an instruction immediate to another register (or memory location). Some of them compute instead of/beyond just moving data, such as adding two things together. These accomplish tiny changes in the state of the processor, and require sequences of instructions to accomplish anything of significance. Still, we need to understand these most primitive operations in order to follow the program.\n• None How are the most basic operations (that we would see in high level languages) performed. All assembly languages use some form of if-goto-label for control structures like loops and if-then-else. The if-goto-label form is some way of saying \"if this is true (or false) then change the instruction stream to this other sequence at this other location, but if it is false (or true) then keep doing the current, sequential instruction stream\". Conditional branches usually involve a construct such as \"if a > b then goto Label;\" so all processors can do this but there are a lot of operands involved in such a conditional, so many processors split these into a couple of instructions. (a, b are operands, > is another as there are many different relational operators, and then Label is yet another operand; that's 4 operands, which usually more than can be done in one instruction, so instruction sets split these operations into two or more instructions, so each has only 2 operands or so.)\n• None And yet at a higher level, how do we accomplish control structures like while-loops, if-then-else, for-loops, and computational expressions using these primitives.\n\nIn nand2tetris, there are two broad categories of instructions. The ones tagged with @ in assembly language load the A register with an address. How that is used depends then on subsequent instructions. The @ form takes a label as an operand, but that label can be a code label or a data label, and it is up to the program to do something sensible therewith. The ones that don't start with @ are computational, and can either move data between register, add or subtract, and move data from memory to registers or the other way around.\n\nAt the most primitive level, a conditional branch is done by loading the label target into the A register, then performing some computational test & branch, that will conditionally transfer control of the instruction stream, by loading the program counter, either with the value in the A register or not!\n\nSo, that first two-instruction sequence says: load the A register with the address of R1, then the next instruction says, load D with the value from memory at A. There, D=M means the D register gets the value of M, Memory, where that implicitly means memory at A or memory[A].\n\nAnother two instruction sequence: @END... D;JLE says, load the address of label END into A, and then conditionally branch to that instruction sequence, if D is <= 0. So, the processor will conditionally do PC=A (or not).\n\nAnd the last two-instruction sequence says always jump to label END, which is presumably right there, so the program ends itself with an infinite loop that does nothing, which is a common way to end programs on simple processors.\n\nThe usages @x are references to a data cell/location labeled x. M=D means write to memory and D=M means read from memory. So, there is a variable called x, which is sometimes updated and sometimes consulted.\n\nAs for the while loop, it is doing something like\n\nIn order to accomplish this conditional test & branch, first the address of data label x is loaded into A, then memory is accessed/read there and loaded into D (D=M); next the address of code label END is loaded into A. So, when the executes, D holds a copy of the value in x, which is tested via the JLE, and also A holds the address of END, which is transferred to the PC (PC=A) when the condition holds (that D <= 0).\n\nThat kind of conditional branch is possibly part of a while loop as follows:\n\nwould translate into if-goto-label form as follows:\n\nYou can see the the conditions are opposite for the C and the assembly if-goto because their sense/meaning is inverted: in C the loop condition of the while says when to stay in the loop, whereas in assembly we tell the processor when to exit the loop so the opposite condition is tested.\n\nWe don't see the rest of the program so this is just informed speculation."
    },
    {
        "link": "https://cs.huji.ac.il/course/2002/nand2tet/oldsite/docs/ch_5_assembler.pdf",
        "document": ""
    },
    {
        "link": "https://github.com/aalhour/Assembler.hack",
        "document": "Assembler.hack is a 16-bit machine language assembler for the 16-bit Hack Assembly Language. This was done as part of building a complete 16-bit computer from the grounds up through the book, and MOOC, Elementes of Computing Systems, which is informally known as nand2tetris. Hack is also the name of the computer.\n\nAssembler.hack takes a program source code file written in the Hack Assembly Language (see: intro section below), which is a .asm text file, and then assembles it into binary machine code (Hack Machine Language). The assembled machine code program is then written to a new .hack text file with the same name.\n\nThe Assembling process is implemented in two passes. The first pass scans the whole program, registering the labels only in the Symbol Table. The second pass scans the whole program again, registering all variables in the Symbol Table, substituting the symbols with their respective memory and/or instruction addresses from the Symbol Table, generating binary machine code and then writing the assembled machine code to the new .hack text file.\n\nSource code is organized into several components, the decisions for their names, interfaces and APIs were already specified in the book as sort of a specification-implementation contract. All components of the Assembler reside in the /Assembler directory, as follows:\n• Assembler.py: Main module. Implements the two passes and glues the other components together.\n• Parser.py: Simple Parser. Parses the instructions by looking ahead 1 or 2 characters to determine their types and structures.\n• Lex.py: A simple Lexer which is used by the Parser to break an instruction to smaller parts and sturcture it in a way that makes it easy to convert it to machine code.\n• Code.py: Generates binary machine code for instructions. For C-Instructions, it generates machine code for its constituting parts and then merges them back altogether.\n• SymbolTable.py: Implements a lookup table which is used to register symbols (labels and variables) and look up their memory addresses.\n\nNote: You might need to read the Intro to Hack Assembly section below to understand the instructions in Max.asm source code.\n\nThe Hack Assembly Language is minimal, it mainly consists of 3 types of instructions. It ignores whitespace and allows programs to declare symbols with a single symbol declaration instruction. Symbols can either be labels or variables. It also allows the programmer to write comments in the source code, for example: .\n\nIf you cannot contain your excitement then head over to the tests directory and check out the testing programs, .asm files contain programs written in the Hack Assembly Language, and .hack files contain their equivalent binary machine code programs (Hack Machine Language).\n• M: Refers to the register in Main Memory whose address is currently stored in A.\n• R0-R15: Addresses of 16 RAM Registers, mapped from 0 to 15.\n• SCREEN: Base address of the Screen Map in Main Memory, which is equal to 16384.\n• KBD: Keyboard Register address in Main Memory, which is equal to 24576.\n\n, where value is either a decimal non-negative number or a Symbol.\n\n, where is a bit, either 0 or 1. A-Instructions always have their MSB set to 0.\n\nSets the contents of the A register to the specified value. The value is either a non-negative number (i.e. 21) or a Symbol. If the value is a Symbol, then the contents of the A register is set to the value that the Symbol refers to but not the actual data in that Register or Memory Location.\n\nSymbols can be either variables or lables. Variables are symbolic names for memory addresses to make remembering these addresses easier. Labels are instructions addresses that allow multiple jumps in the program easier to handle. Symbols declaration is not a machine instruction because machine code doesn't operate on the level of abstraction of that of labels and variables, and hence it is considered a pseudo-instruction.\n\nThe instruction declares a variable \"i\", and the instruction sets the memory location of \"i\" in Main Memory to 0, the address \"i\" was automatically generated and stored in A Register by the instruction.\n\nTo declare a label we need to use the command , where \"LABEL_NAME\" can be any name we desire to have for the label, as long as it's wraped between parentheses. For example:\n\nThe instruction declares a new label called \"LOOP\", the assembler will resolve this label to the address of the next instruction (A or C instruction) on the following line.\n\nThe instruction is a straight-forward A-Instruction that sets the contents of A Register to the instruction address the label refers to, whereas the instruction causes an unconditional jump to the address in A Register causing the program to execute the set of instructions between and infinitely.\n• dest: Destination register in which the result of computation will be stored.\n• bit: Chooses to load the contents of either A register or M (Main Memory register addressed by A) into the ALU for computation.\n• Bits through : Control bits expected by the ALU to perform arithmetic or bit-wise logic operations.\n• Bits through : Specify which memory location to store the result of ALU computation into: A, D or M.\n• Bits through : Specify which JUMP directive to execute (either conditional or uncoditional).\n\nPerforms a computation on the CPU (arithmetic or bit-wise logic) and stores it into a destination register or memory location, and then (optionally) JUMPS to an instruction memory location that is usually addressed by a value or a Symbol (label).\n\nThe following reference images are taken from the nand2tetris Coursera MOOC.\n\nThis project is licensed under the MIT License."
    },
    {
        "link": "https://github.com/aalhour/Assembler.hack/blob/master/README.md",
        "document": "Assembler.hack is a 16-bit machine language assembler for the 16-bit Hack Assembly Language. This was done as part of building a complete 16-bit computer from the grounds up through the book, and MOOC, Elementes of Computing Systems, which is informally known as nand2tetris. Hack is also the name of the computer.\n\nAssembler.hack takes a program source code file written in the Hack Assembly Language (see: intro section below), which is a .asm text file, and then assembles it into binary machine code (Hack Machine Language). The assembled machine code program is then written to a new .hack text file with the same name.\n\nThe Assembling process is implemented in two passes. The first pass scans the whole program, registering the labels only in the Symbol Table. The second pass scans the whole program again, registering all variables in the Symbol Table, substituting the symbols with their respective memory and/or instruction addresses from the Symbol Table, generating binary machine code and then writing the assembled machine code to the new .hack text file.\n\nSource code is organized into several components, the decisions for their names, interfaces and APIs were already specified in the book as sort of a specification-implementation contract. All components of the Assembler reside in the /Assembler directory, as follows:\n• Assembler.py: Main module. Implements the two passes and glues the other components together.\n• Parser.py: Simple Parser. Parses the instructions by looking ahead 1 or 2 characters to determine their types and structures.\n• Lex.py: A simple Lexer which is used by the Parser to break an instruction to smaller parts and sturcture it in a way that makes it easy to convert it to machine code.\n• Code.py: Generates binary machine code for instructions. For C-Instructions, it generates machine code for its constituting parts and then merges them back altogether.\n• SymbolTable.py: Implements a lookup table which is used to register symbols (labels and variables) and look up their memory addresses.\n\nNote: You might need to read the Intro to Hack Assembly section below to understand the instructions in Max.asm source code.\n\nThe Hack Assembly Language is minimal, it mainly consists of 3 types of instructions. It ignores whitespace and allows programs to declare symbols with a single symbol declaration instruction. Symbols can either be labels or variables. It also allows the programmer to write comments in the source code, for example: .\n\nIf you cannot contain your excitement then head over to the tests directory and check out the testing programs, .asm files contain programs written in the Hack Assembly Language, and .hack files contain their equivalent binary machine code programs (Hack Machine Language).\n• M: Refers to the register in Main Memory whose address is currently stored in A.\n• R0-R15: Addresses of 16 RAM Registers, mapped from 0 to 15.\n• SCREEN: Base address of the Screen Map in Main Memory, which is equal to 16384.\n• KBD: Keyboard Register address in Main Memory, which is equal to 24576.\n\n, where value is either a decimal non-negative number or a Symbol.\n\n, where is a bit, either 0 or 1. A-Instructions always have their MSB set to 0.\n\nSets the contents of the A register to the specified value. The value is either a non-negative number (i.e. 21) or a Symbol. If the value is a Symbol, then the contents of the A register is set to the value that the Symbol refers to but not the actual data in that Register or Memory Location.\n\nSymbols can be either variables or lables. Variables are symbolic names for memory addresses to make remembering these addresses easier. Labels are instructions addresses that allow multiple jumps in the program easier to handle. Symbols declaration is not a machine instruction because machine code doesn't operate on the level of abstraction of that of labels and variables, and hence it is considered a pseudo-instruction.\n\nThe instruction declares a variable \"i\", and the instruction sets the memory location of \"i\" in Main Memory to 0, the address \"i\" was automatically generated and stored in A Register by the instruction.\n\nTo declare a label we need to use the command , where \"LABEL_NAME\" can be any name we desire to have for the label, as long as it's wraped between parentheses. For example:\n\nThe instruction declares a new label called \"LOOP\", the assembler will resolve this label to the address of the next instruction (A or C instruction) on the following line.\n\nThe instruction is a straight-forward A-Instruction that sets the contents of A Register to the instruction address the label refers to, whereas the instruction causes an unconditional jump to the address in A Register causing the program to execute the set of instructions between and infinitely.\n• dest: Destination register in which the result of computation will be stored.\n• bit: Chooses to load the contents of either A register or M (Main Memory register addressed by A) into the ALU for computation.\n• Bits through : Control bits expected by the ALU to perform arithmetic or bit-wise logic operations.\n• Bits through : Specify which memory location to store the result of ALU computation into: A, D or M.\n• Bits through : Specify which JUMP directive to execute (either conditional or uncoditional).\n\nPerforms a computation on the CPU (arithmetic or bit-wise logic) and stores it into a destination register or memory location, and then (optionally) JUMPS to an instruction memory location that is usually addressed by a value or a Symbol (label).\n\nThe following reference images are taken from the nand2tetris Coursera MOOC.\n\nThis project is licensed under the MIT License."
    },
    {
        "link": "https://courses.cs.washington.edu/courses/cse390b/22wi/lectures/CSE390B-L08-hack-assembly_22wi.pdf",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/70132031/understanding-hack-assembly-language-code",
        "document": "There are at least 3 levels upon which to understand such code:\n• None What does each individual instruction do (each line of assembly)? These are explained in the tutorial texts, but most instructions simply move some data from one register, or memory location, or an instruction immediate to another register (or memory location). Some of them compute instead of/beyond just moving data, such as adding two things together. These accomplish tiny changes in the state of the processor, and require sequences of instructions to accomplish anything of significance. Still, we need to understand these most primitive operations in order to follow the program.\n• None How are the most basic operations (that we would see in high level languages) performed. All assembly languages use some form of if-goto-label for control structures like loops and if-then-else. The if-goto-label form is some way of saying \"if this is true (or false) then change the instruction stream to this other sequence at this other location, but if it is false (or true) then keep doing the current, sequential instruction stream\". Conditional branches usually involve a construct such as \"if a > b then goto Label;\" so all processors can do this but there are a lot of operands involved in such a conditional, so many processors split these into a couple of instructions. (a, b are operands, > is another as there are many different relational operators, and then Label is yet another operand; that's 4 operands, which usually more than can be done in one instruction, so instruction sets split these operations into two or more instructions, so each has only 2 operands or so.)\n• None And yet at a higher level, how do we accomplish control structures like while-loops, if-then-else, for-loops, and computational expressions using these primitives.\n\nIn nand2tetris, there are two broad categories of instructions. The ones tagged with @ in assembly language load the A register with an address. How that is used depends then on subsequent instructions. The @ form takes a label as an operand, but that label can be a code label or a data label, and it is up to the program to do something sensible therewith. The ones that don't start with @ are computational, and can either move data between register, add or subtract, and move data from memory to registers or the other way around.\n\nAt the most primitive level, a conditional branch is done by loading the label target into the A register, then performing some computational test & branch, that will conditionally transfer control of the instruction stream, by loading the program counter, either with the value in the A register or not!\n\nSo, that first two-instruction sequence says: load the A register with the address of R1, then the next instruction says, load D with the value from memory at A. There, D=M means the D register gets the value of M, Memory, where that implicitly means memory at A or memory[A].\n\nAnother two instruction sequence: @END... D;JLE says, load the address of label END into A, and then conditionally branch to that instruction sequence, if D is <= 0. So, the processor will conditionally do PC=A (or not).\n\nAnd the last two-instruction sequence says always jump to label END, which is presumably right there, so the program ends itself with an infinite loop that does nothing, which is a common way to end programs on simple processors.\n\nThe usages @x are references to a data cell/location labeled x. M=D means write to memory and D=M means read from memory. So, there is a variable called x, which is sometimes updated and sometimes consulted.\n\nAs for the while loop, it is doing something like\n\nIn order to accomplish this conditional test & branch, first the address of data label x is loaded into A, then memory is accessed/read there and loaded into D (D=M); next the address of code label END is loaded into A. So, when the executes, D holds a copy of the value in x, which is tested via the JLE, and also A holds the address of END, which is transferred to the PC (PC=A) when the condition holds (that D <= 0).\n\nThat kind of conditional branch is possibly part of a while loop as follows:\n\nwould translate into if-goto-label form as follows:\n\nYou can see the the conditions are opposite for the C and the assembly if-goto because their sense/meaning is inverted: in C the loop condition of the while says when to stay in the loop, whereas in assembly we tell the processor when to exit the loop so the opposite condition is tested.\n\nWe don't see the rest of the program so this is just informed speculation."
    },
    {
        "link": "https://courses.cs.washington.edu/courses/cse390b/22wi/lectures/CSE390B-L08-hack-assembly_22wi.pdf",
        "document": ""
    },
    {
        "link": "https://infosecinstitute.com/resources/secure-coding/loops",
        "document": "We help IT and security professionals advance their careers with skills development and certifications while empowering all employees with security awareness and phishing training to stay cyber safe at work and home."
    },
    {
        "link": "https://medium.com/@MadOverlord/optimizing-nand2tetris-assembly-code-f378700d0096",
        "document": "One of the joys of writing assembly language code on any processor is that since you are so close to the bare metal, you can indulge in clever optimizations to make your programs smaller and faster. These days, high-level language compilers are very good at finding optimizations, but in the bad old days, there was no substitute for getting your hands dirty and spending hours cutting a cycle or two out of that inner loop.\n\nThe NAND2Tetris Hack machine, because it is such a simple architecture, presents many opportunities for finding these optimizations. Some of these are very machine-specific, but others are applicable in other circumstances. Here are a few that I’ve encountered over the years.\n\nMessing with the space/time complexity of the 16-bit multiply\n\nThe 16-bit multiply routine is one of the homework exercises for NAND2Tetris, and it can be performed in a number of simple ways; for example, here is a relatively straightforward version.\n\nIt runs in about 260+4n instructions, where n is the number of 1 bits in the multiplier. Fairly constant time, but clearly we can do better speed-wise (space-wise, it’s about the best you can do). The key to improving overall speed of the code is reducing the number of times we have to loop. The simple algorithm does one loop per bit of the multiplier (15 times since we don’t care about the top bit). However, if we know the position of the topmost 1 bit, then we can quit at that point since there will never be any more additions and the job is complete.\n\nThe straightforward way of doing this requires a slightly more expensive loop (20 invariant instructions vs. 16 for the simple loop). Since the simple loop runs 15 times, that’s 240 instructions. This means that the more complex algorithm is a win whenever the multiplier has 12 or fewer bits we need to check. In addition, because A*B == B*A, we can compare the multiplier and multiplicand and swap them so the multiplier is the smaller number. This means that the simple algorithm only wins when *both* the multiplier and multiplicand have 12 or more significant bits — and since the result is a 15 bit number, you’re not going to get a usable result in that case anyway! So the more complex loop is a *win*\n\nThe trick therefore is finding a simple way to determine if we have any more bits we need to check in the Multiplier. The way we do this is use a negative mask to strip bits out of it one at a time; if it ever becomes 0, then we know we are done, and if the bit-stripping changes it, we know the bit in question is a 1. This also means we don’t need a loop counter, but we do need a copy of the Multiplier.\n\n// Multiplies R0 and R1 and stores the result in R2.\n\n// (R0, R1, R2 refer to RAM[0], RAM[1], and RAM[2], respectively.)\n\n\n\n// IMPORTANT: DOES NOT TRASH R0,R1 (even though the test allows it,\n\n// it's terrible form)\n\n\n\n(INIT)\n\n @R2 // Initialize product (R2) to 0\n\n M = 0\n\n\n\n @MASK // Initialize MASK to 1111...1110\n\n M = -1 // which is -2\n\n M = M - 1\n\n\n\n @R0 // Check if R0 is negative\n\n D = M // If so, R1 is Multiplier\n\n @R0GER1\n\n D ; JLT\n\n @R1 // Same if R0 >= R1\n\n D = D - M // This minimizes the number of times\n\n @R0GER1 // through the main loop.\n\n D ; JGE\n\n\n\n @R1 // Initialize Multiplicand to copy of R1\n\n D = M\n\n @MULC\n\n M = D\n\n\n\n @R0 // Initialize Multiplier to copy of R0\n\n D = M\n\n @MULP\n\n M = D\n\n\n\n @LOOP // Jump to top of loop\n\n 0 ; JMP\n\n\n\n(R0GER1) // R0 >= R1 or R0 < 0, so R1 is MULP\n\n\n\n @R0 // Initialize Multiplicand to copy of R0\n\n D = M\n\n @MULC\n\n M = D\n\n\n\n @R1 // Initialize Multiplier to copy of R1\n\n D = M\n\n @MULP\n\n M = D\n\n\n\n// Efficiency note: We could place a check here to see if MULP is 0 and\n\n// exit immediately. This costs 2 instructions on every multiply. Omitting\n\n// this check means that if MULP is 0, we'll go through the loop once (20\n\n// instructions), so this is only a win if we expect MULP to be 0 more\n\n// than 10% of the time.\n\n\n\n(LOOP) // D = MULP and non-zero at this point (unless it starts as zero).\n\n\n\n @OMULP // Save a copy of MULP as it currently is\n\n M = D\n\n\n\n @MASK // MULP = MULP & MASK. Because MASK is a negative mask, only the\n\n D = D & M // bit we currently care about is set to 0 if it is 1. We save\n\n @MULP // the *changed* version back into MULP\n\n M = D\n\n\n\n @OMULP // if MULP == OMULP, nothing to do on this round\n\n D = D - M\n\n @NEXT\n\n D ; JEQ\n\n\n\n @MULC // R2 = R2 + MULC\n\n D = M\n\n @R2\n\n M = M + D\n\n\n\n(NEXT)\n\n\n\n @MULC // MULC = MULC * 2 (Shift Left 1 bit)\n\n D = M\n\n M = M + D\n\n\n\n @MASK // MASK = MASK * 2 (Shift left 1 bit)\n\n D = M\n\n M = M + D\n\n\n\n @MULP // Load up MULP again\n\n D = M\n\n @LOOP // and loop if non-zero\n\n D ; JNE\n\n\n\n @END\n\n(END)\n\n 0 ; JMP\n\nOK, so what else could we do? Well, if we are not worried about space, and want to go for pure speed, we can consider unrolling the loop. Apart from getting rid of the loop overhead, we don’t have to recompute the mask, since we’ll know what it should be at any particular point. The starting point for this is the unrolled version of the original simple multiplication code.\n\nThis is a pretty good improvement; the invariant part goes from 16 instructions per bit down to 9. However, we’re executing the entire string of code regardless of what the numbers are. We could do the same swap MULC and MULP and test to see if we have more work to do, but there is a catch — each test that we do slows us down. As it turns out, each test takes 6 cycles, so if we put one on each element in the unrolled loop, we’d have an invariant part of 15 instructions (as opposed to 20 cycles in our negative mask example). This is still an improvement, but note that we don’t have to put the check on each element; if we have statistics on what numbers typically get multiplied, we can place the checks to minimize the average number of cycles.\n\nIn my test, I decided to put the checks after bit 3 and bit 7, like this:\n\nI worked through a couple of other techniques that might shave instruction cycles but the 6 cycle/test limit is hard to beat. For example, if you can set a variable to 0 or an address, then you can do an indirect jump in 3 instructions:\n\nThe problem is that you need to set/clear the address variable based on some prior test, and doing this test in < 3 cycles per test is not possible, so there’s no gain in this instance.\n\nThe other major possibility is to borrow from our second example and use a variable to hold a mask. This adds 3 instructions to update the mask, a total of 45 instructions:\n\nHowever, it means that if we can compute the position of the top bit in less than 45 instructions, we can then jump directly into the middle of the unrolled loop at the correct position so that only the right number of sections get executed (ie: if there are 3 bits in the multiplier, only the last 3 sections run). We can definitely do this by using a 4-level binary tree search, and each node would look like this:\n\nHalf the time, we’d fall through and wouldn’t have to reload the multiplier, so it’s an average of 5 cycles per node = 20 cycles plus a jump (2 cycles) = 22 cycles. So we can do this with an overhead of ~22 + 3 cycles per bit in the multiplier. This is probably better than just checking after bit 3 and 7, but only profiling will tell you for sure.\n\nReplacing a whole calculation with a simple lookup in a pre-computed table is always a big win. For example, here’s the code from my Life implementation that computes the address of a cell given the X and Y coordinates:\n\nThe problem is that the Hack machine doesn’t have any easy way to preload tables, since the instruction memory isn’t directly readable by the machine. So in order to use tables, you have to write code to initialize them and run it when your program starts.\n\nIn my first implementation of Life, I just wrote a Python script to generate the code, but when I decided to really optimize the code and expand to a 128x64 grid size, I ended up writing an improved assembler that lets you predefine tables; it then generates some simple code to initialize the tables and injects it into the program.\n\nSo you get to write code like this:\n\nBasically, every time I ran into a limitation of the stock assembler, I added a feature to address it; stuff like simple expression arithmetic, variable initialization, symbol tables, memory allocation, bitmap import and so on. If you decide to do some heavy-duty programming in Hack, you may find it useful.\n\nOne of the fun things about assembly code is that you can break the rules anytime you want — just be sure to clearly document your crimes against good coding practice so that the next poor soul who has to read your code won’t want to hunt you down and murder you (note that this person is often future-you…).\n• If the last thing a called function does is call another function, you can just jump to it instead, and have it return to the original caller.\n• If you have a big switch statement where everything ends with calling a function (for example, decoding a keypress and deciding what to do), just set up the stack first, then decide what function to call. But remember to clean up the stack if you end up not calling anything.\n• You can often eliminate a loop variable if you have a way of detecting an “end of array” state. For example, if you have an array that always contains non-negative values, you can append a -1 value to the array, and if you ever load a negative value (which is a simple thing to check) you know you’re done.\n• Loop unrolling is a big win, and the smaller the loop body, the bigger the win is.\n• Since the Hack machine has only two registers, rearranging your code to avoid having to reload a register is a win — and since loading a value into the D register requires two instructions, it’s worth paying an instruction to avoid this.\n• Since you can only directly load 15-bit numbers into A, if you want to set A or D to a 16-bit unsigned quantity (one with the high-bit set), load A with the inverse of the desired number (which will be 15-bit) and then NOT it (which will always set the high-bit).\n\nIf you read through the Life.asm code in the github repo, I’ve documented most of the hacks I used to squeeze out cycles in the critical code paths. Enjoy!"
    },
    {
        "link": "https://stackoverflow.com/questions/72131833/hack-assembly-language-finding-the-maximum-number-in-ram",
        "document": "The following loop exit test won't work because there is no instruction that does\n\nInstead of that, source 20 to the A register, then do D-A, as follows:\n\nYou can simplify as:\n\nLet's note that this part is happening too soon. You want to do the after the other parts of the loop body, otherwise you'll skip .\n\nThis operation does not\n\nis indexing by a variable (aka pointer dereference) so if is in memory, then this will require two reads to memory, the first to read then the second to read where the value of refers.\n\nLet's also note that this operation is also premature: you only want to capture RAM[0]=RAM[i] under the condition that it is the current max, but you're doing it always, unconditionally. So, this operation should be the then-part of an if statement.\n\nHopefully, you can see now how variable indexing works: , where is in memory requires two reads: two operations. Since is a pointer to location 10 (at first, then 11 later), you need to get into the A register so you can read where that points.\n\nAlso, the order of the various operations does not follow a working algorithm. Try writing out the loop in pseudo code. Trying to work out an algorithm in assembly when you don't know it is hard, and, debugging a broken algorithm in assembly is even harder.\n\nHere's an example doing max:\n\nLet's simplify, by translating this into a while loop:\n\nCan you see that the needs to be at the end of the loop body, so that the main portion of the loop body operates with the original ?\n\nYou also need to implement the if-statement so that you capture only when it is actually larger than the current .\n\nAnd also complete the loop so that it iterates."
    }
]