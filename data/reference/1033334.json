[
    {
        "link": "https://element-plus.org/en-US/component/form",
        "document": "Form consists of , , , and so on. With form, you can collect, verify and submit data.\n\nIt includes all kinds of input items, such as , , and .\n\nWhen the vertical space is limited and the form is relatively simple, you can put it in one line.\n\nDepending on your design, there are several different ways to align your label element.\n\nYou can set of separately 2.7.7. If the value is empty, the of is used.\n\nForm component allows you to verify your data, helping you find and correct errors.\n\nThis example shows how to customize your own validation rules to finish a two-factor password verification.\n\nAll components in a Form inherit their attribute from that Form. Similarly, FormItem also has a attribute.\n\nWhen only a single input (or related control such as select or checkbox) is inside of a , the form item's label will automatically be attached to that input. However, if multiple inputs are inside of the , the form item will be assigned the WAI-ARIA role of group instead. In this case, it is your responsibility to assign assistive labels to the individual inputs."
    },
    {
        "link": "https://github.com/element-plus/element-plus/blob/dev/docs/examples/form/custom-validation.vue",
        "document": "To see all available qualifiers, see our documentation .\n\nSaved searches Use saved searches to filter your results more quickly\n\nWe read every piece of feedback, and take your input very seriously.\n\nYou signed in with another tab or window. Reload to refresh your session.\n\nYou signed out in another tab or window. Reload to refresh your session.\n\nYou switched accounts on another tab or window. Reload to refresh your session."
    },
    {
        "link": "https://elementplus.fenxianglu.cn/en-US/component/form",
        "document": "Made with ❤️ by Element Plus"
    },
    {
        "link": "https://stackoverflow.com/questions/75411283/how-to-use-async-validator-on-submit-with-element-plus-in-vue-3",
        "document": "I have a Vue 3 project and using element plus, I created a form with async validation. The code of validation function (Laravel precognition):\n\nand I define the rules like this:\n\nThe getSubmitShape() funtion return Object with all form-item keys, that should be validated. So you can imagine it like:\n\nThis works like a charm, when I write to inputs and switch between them. The errors would appear and dissappear correctly.\n\nWhen the form is submitted, I am calling function, which should validate all the inputs. It works, BUT:\n\nfor every rule item, one HTTP request is sent to server, because the validation method is called for each rule separately.\n\nI tried to implement debounce method, which would save the params from each previous function call and include that in next call, so in a last call, I would have all the inputs, rules and callbacks available. This works, when I try it while writing inputs to elements and switching them fast (triggering validation).\n\nWhen on submit, it waits the debounce time for each rule. So the requests again go one by one with the delay of debounce time.\n\nAny ideas, how I could make this in one request?"
    },
    {
        "link": "https://vuejs.org/v2/cookbook/form-validation.html",
        "document": "Form validation is natively supported by the browser, but sometimes different browsers will handle things in a manner which makes relying on it a bit tricky. Even when validation is supported perfectly, there may be times when custom validations are needed and a more manual, Vue-based solution may be more appropriate. Let’s begin with a simple example.\n\nGiven a form of three fields, make two required. Let’s look at the HTML first:\n\nLet’s cover it from the top. The tag has an ID that we’ll be using for the Vue component. There’s a submit handler that you’ll see in a bit, and the is a temporary URL that would point to something real on a server someplace (where you have backup server-side validation of course).\n\nBeneath that there is a paragraph that shows or hides itself based on an error state. This will render a simple list of errors on top of the form. Also note we fire the validation on submit rather than as every field is modified.\n\nThe final thing to note is that each of the three fields has a corresponding to connect them to values we will work with in the JavaScript. Now let’s look at that.\n\nFairly short and simple. We define an array to hold errors and set values for the three form fields. The logic (which is run on submit remember) checks for name and age only as movie is optional. If they are empty we check each and set a specific error for each. And that’s really it. You can run the demo below. Don’t forget that on a successful submission it’s going to POST to a temporary URL.\n\nSee the Pen form validation 1 by Raymond Camden (@cfjedimaster) on CodePen.\n\nFor the second example, the second text field (age) was switched to email which will be validated with a bit of custom logic. The code is taken from the StackOverflow question, How to validate email address in JavaScript?. This is an awesome question because it makes your most intense Facebook political/religious argument look like a slight disagreement over who makes the best beer. Seriously - it’s insane. Here is the HTML, even though it’s really close to the first example.\n\nWhile the change here is small, note the on top. This is important because the browser will attempt to validate the email address in the field when . Frankly it may make more sense to trust the browser in this case, but as we wanted an example with custom validation, we’re disabling it. Here’s the updated JavaScript.\n\nAs you can see, we’ve added as a new method and it is simply called from . You can play with this example here:\n\nSee the Pen form validation 2 by Raymond Camden (@cfjedimaster) on CodePen.\n\nAnother Example of Custom Validation\n\nFor the third example, we’ve built something you’ve probably seen in survey apps. The user is asked to spend a “budget” for a set of features for a new Star Destroyer model. The total must equal 100. First, the HTML.\n\nNote the set of inputs covering the five different features. Note the addition of to the attribute. This tells Vue to cast the value to a number when you use it. However, there is a bug with this feature such that when the value is blank, it turns back into a string. You’ll see the workaround below. To make it a bit easier for the user, we also added a current total right below so they can see, in real time, what their total is. Now let’s look at the JavaScript.\n\nWe set up the total value as a computed value, and outside of that bug I ran into, it was simple enough to setup. My checkForm method now just needs to see if the total is 100 and that’s it. You can play with this here:\n\nSee the Pen form validation 3 by Raymond Camden (@cfjedimaster) on CodePen.\n\nIn my final example, we built something that makes use of Ajax to validate at the server. The form will ask you to name a new product and will then check to ensure that the name is unique. We wrote a quick Netlify serverless action to do the validation. While it isn’t terribly important, here is the logic:\n\nBasically any name but “vista”, “empire”, and “mbp” are acceptable. Ok, so let’s look at the form.\n\nThere isn’t anything special here. So let’s go on to the JavaScript.\n\nWe start off with a variable representing the URL of the API that is running on OpenWhisk. Now look at . In this version, we always prevent the form from submitting (which, by the way, could be done in the HTML with Vue as well). You can see a basic check on being empty, and then we hit the API. If it’s bad, we add an error as before. If it’s good, right now we do nothing (just an alert), but you could navigate the user to a new page with the product name in the URL, or do other actions as well. You can run this demo below:\n\nSee the Pen form validation 4 by Raymond Camden (@cfjedimaster) on CodePen.\n\nWhile this cookbook entry focused on doing form validation “by hand”, there are, of course, some great Vue libraries that will handle a lot of this for you. Switching to a prepackage library may impact the final size of your application, but the benefits could be tremendous. You have code that is (most likely) heavily tested and also updated on a regular basis. Some examples of form validation libraries for Vue include:"
    },
    {
        "link": "https://vuejs.org/api/composition-api-lifecycle",
        "document": "Registers a callback to be called after the component has been mounted.\n• None\n• None All of its synchronous child components have been mounted (does not include async components or components inside trees).\n• None Its own DOM tree has been created and inserted into the parent container. Note it only guarantees that the component's DOM tree is in-document if the application's root container is also in-document. This hook is typically used for performing side effects that need access to the component's rendered DOM, or for limiting DOM-related code to the client in a server-rendered application. This hook is not called during server-side rendering.\n\nRegisters a callback to be called after the component has updated its DOM tree due to a reactive state change.\n• None A parent component's updated hook is called after that of its child components. This hook is called after any DOM update of the component, which can be caused by different state changes, because multiple state changes can be batched into a single render cycle for performance reasons. If you need to access the updated DOM after a specific state change, use nextTick() instead. This hook is not called during server-side rendering. Do not mutate component state in the updated hook - this will likely lead to an infinite update loop!\n• None // text content should be the same as current `count.value`\n\nRegisters a callback to be called after the component has been unmounted.\n• None\n• None All of its child components have been unmounted.\n• None All of its associated reactive effects (render effect and computed / watchers created during ) have been stopped. Use this hook to clean up manually created side effects such as timers, DOM event listeners or server connections. This hook is not called during server-side rendering.\n\nRegisters a hook to be called right before the component is to be mounted.\n• None When this hook is called, the component has finished setting up its reactive state, but no DOM nodes have been created yet. It is about to execute its DOM render effect for the first time. This hook is not called during server-side rendering.\n\nRegisters a hook to be called right before the component is about to update its DOM tree due to a reactive state change.\n• None This hook can be used to access the DOM state before Vue updates the DOM. It is also safe to modify component state inside this hook. This hook is not called during server-side rendering.\n\nRegisters a hook to be called right before a component instance is to be unmounted.\n• None When this hook is called, the component instance is still fully functional. This hook is not called during server-side rendering.\n\nRegisters a hook to be called when an error propagating from a descendant component has been captured.\n• None Errors can be captured from the following sources: The hook receives three arguments: the error, the component instance that triggered the error, and an information string specifying the error source type. In production, the 3rd argument ( ) will be a shortened code instead of the full information string. You can find the code to string mapping in the Production Error Code Reference. You can modify component state in to display an error state to the user. However, it is important that the error state should not render the original content that caused the error; otherwise the component will be thrown into an infinite render loop. The hook can return to stop the error from propagating further. See error propagation details below.\n• None By default, all errors are still sent to the application-level if it is defined, so that these errors can still be reported to an analytics service in a single place.\n• None If multiple hooks exist on a component's inheritance chain or parent chain, all of them will be invoked on the same error, in the order of bottom to top. This is similar to the bubbling mechanism of native DOM events.\n• None If the hook itself throws an error, both this error and the original captured error are sent to .\n• None An hook can return to prevent the error from propagating further. This is essentially saying \"this error has been handled and should be ignored.\" It will prevent any additional hooks or from being invoked for this error.\n\nRegisters a debug hook to be called when a reactive dependency has been tracked by the component's render effect.\n\nThis hook is development-mode-only and not called during server-side rendering.\n• None See also Reactivity in Depth\n\nRegisters a debug hook to be called when a reactive dependency triggers the component's render effect to be re-run.\n\nThis hook is development-mode-only and not called during server-side rendering.\n• None See also Reactivity in Depth\n\nRegisters a callback to be called after the component instance is inserted into the DOM as part of a tree cached by .\n\nThis hook is not called during server-side rendering.\n• None See also Guide - Lifecycle of Cached Instance\n\nRegisters a callback to be called after the component instance is removed from the DOM as part of a tree cached by .\n\nThis hook is not called during server-side rendering.\n• None See also Guide - Lifecycle of Cached Instance\n\nRegisters an async function to be resolved before the component instance is to be rendered on the server.\n• None If the callback returns a Promise, the server renderer will wait until the Promise is resolved before rendering the component. This hook is only called during server-side rendering can be used to perform server-only data fetching.\n• None // component is rendered as part of the initial request // pre-fetch data on server as it is faster than on the client // if data is null on mount, it means the component // is dynamically rendered on the client. Perform a"
    },
    {
        "link": "https://stackoverflow.com/questions/68754161/vue3-the-value-of-the-ref-to-component-in-setup-puzzle-me",
        "document": "My project is based on Vue3 and I use the component called 'el-tree' provided by 'element-plus'. For accessing I define a variable called 'tree' which value is ref(null) in setup() method. Then I wrote an attribute ref called 'tree' in 'el-tree' in my template code.\n\nI think that the ref value of 'tree' in the whole setup() method is null. But why it has value when I log it in the callback function of promise."
    },
    {
        "link": "https://github.com/element-plus/element-plus/issues/15145",
        "document": "\n• This bug is caused by vue lifecycle hooks is executed in the wrong order vuejs#8898\n• In some special cases(v-if=\"dynamicRefValue\") lifecycle it will be executed in the following order:\n• This will cause the el-form to be incorrect, executes before , unmounted form-item prop error exists in in fields:\n• When the final validate, the unmounted form-item prop verify will be triggered.\n• Temp solution: replace with and waiting for vue fix it."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Frameworks_libraries/Vue_refs_focus_management",
        "document": "We are nearly done with Vue. The last bit of functionality to look at is focus management, or put another way, how we can improve our app's keyboard accessibility. We'll look at using Vue refs to handle this — an advanced feature that allows you to have direct access to the underlying DOM nodes below the virtual DOM, or direct access from one component to the internal DOM structure of a child component. Familiarity with the core HTML, CSS, and JavaScript languages, knowledge of the terminal/command line. Vue components are written as a combination of JavaScript objects that manage the app's data and an HTML-based template syntax that maps to the underlying DOM structure. For installation, and to use some of the more advanced features of Vue (like Single File Components or render functions), you'll need a terminal with node + npm installed. To learn how to handle focus management using Vue refs.\n\nWhile we do have working edit functionality, we aren't providing a great experience for non-mouse users. Specifically, when a user activates the \"Edit\" button, we remove the \"Edit\" button from the DOM, but we don't move the user's focus anywhere, so in effect it just disappears. This can be disorienting for keyboard and non-visual users.\n• Reload your page, then press . You should see a focus outline on the input for adding new to-do items.\n• Press again. The focus should move to the \"Add\" button.\n• Hit it again, and it'll be on the first checkbox. One more time, and focus should be on the first \"Edit\" button.\n• Activate the \"Edit\" button by pressing . The checkbox will be replaced with our edit component, but the focus outline will be gone. This behavior can be jarring. In addition, what happens when you press again varies depending on the browser you're using. Similarly, if you save or cancel your edit, focus will disappear again as you move back to the non-edit view. To give users a better experience, we'll add code to control the focus so that it gets set to the edit field when the edit form is shown. We'll also want to put focus back on the \"Edit\" button when a user cancels or saves their edit. In order to set focus, we need to understand a little bit more about how Vue works internally.\n\nVue, like some other frameworks, uses a virtual DOM (VDOM) to manage elements. This means that Vue keeps a representation of all of the nodes in our app in memory. Any updates are first performed on the in-memory nodes, and then all the changes that need to be made to the actual nodes on the page are synced in a batch. Since reading and writing actual DOM nodes is often more expensive than virtual nodes, this can result in better performance. However, it also means you often should not edit your HTML elements directly through native browser APIs (like ) when using frameworks, because it results in the VDOM and real DOM going out of sync. Instead, if you need to access the underlying DOM nodes (like when setting focus), you can use Vue refs. For custom Vue components, you can also use refs to directly access the internal structure of a child component, however this should be done with caution as it can make code harder to reason about and understand. To use a ref in a component, you add a attribute to the element that you want to access, with a string identifier for the value of the attribute. It's important to note that a ref needs to be unique within a component. No two elements rendered at the same time should have the same ref.\n\nWe want to set focus on the \"Edit\" button when a user saves or cancels their edit. To do that, we need to handle focus in the component's and methods. For convenience, create a new method which takes no arguments called . Inside it, assign your to a variable, and then call the method on the ref. Next, add a call to at the end of the and methods: Try editing and then saving/cancelling a to-do item via your keyboard. You'll notice that focus isn't being set, so we still have a problem to solve. If you open your console, you'll see an error raised along the lines of \"can't access property \"focus\", editButtonRef is undefined\". This seems weird. Your button ref was defined when you activated the \"Edit\" button, but now it's not. What is going on? Well, remember that when we change to , we no longer render the section of the component featuring the \"Edit\" button. This means there's no element to bind the ref to, so it becomes . You might now be thinking \"hey, don't we set before we try to access the , so therefore shouldn't the now be displaying the button?\" This is where the virtual DOM comes into play. Because Vue is trying to optimize and batch changes, it won't immediately update the DOM when we set to . So when we call , the \"Edit\" button has not been rendered yet. Instead, we need to wait until after Vue undergoes the next DOM update cycle. To do that, Vue components have a special method called . This method accepts a callback function, which then executes after the DOM updates. Since the method needs to be invoked after the DOM has updated, we can wrap the existing function body inside a call. Now when you activate the \"Edit\" button and then cancel or save your changes via the keyboard, focus should be returned to the \"Edit\" button. Success!\n\nNext, we need to move focus to the edit form's element when the \"Edit\" button is clicked. However, because our edit form is in a different component to our \"Edit\" button, we can't just set focus inside the \"Edit\" button's click event handler. Instead, we can use the fact that we remove and re-mount our component whenever the \"Edit\" button is clicked to handle this. So how does this work? Well, Vue components undergo a series of events, known as a lifecycle. This lifecycle spans from all the way before elements are created and added to the VDOM (mounted), until they are removed from the VDOM (destroyed). Vue lets you run methods at various stages of this lifecycle using lifecycle methods. This can be useful for things like data fetching, where you may need to get your data before your component renders, or after a property changes. The list of lifecycle methods are below, in the order that they fire.\n• — Runs before the instance of your component is created. Data and events are not yet available.\n• — Runs after your component is initialized but before the component is added to the VDOM. This is often where data fetching occurs.\n• — Runs after your template is compiled, but before your component is rendered to the actual DOM.\n• — Runs after your component is mounted to the DOM. Can access here.\n• — Runs whenever data in your component changes, but before the changes are rendered to the DOM.\n• — Runs whenever data in your component has changed and after the changes are rendered to the DOM.\n• — Runs before a component is removed from the DOM.\n• — Runs after a component has been removed from the DOM.\n• — Only used in components wrapped in a special tag. Runs after the component is activated.\n• — Only used in components wrapped in a special tag. Runs after the component is deactivated. Note: The Vue Docs provide a nice diagram for visualizing when these hooks happen. This article from the DigitalOcean Community Blog dives into the lifecycle methods more deeply. Now that we've gone over the lifecycle methods, let's use one to trigger focus when our component is mounted. In , attach to the element, like so: Next, add a property just inside your component object — note that this should not be put inside the property, but rather at the same hierarchy level as , , and . Lifecycle methods are special methods that sit on their own, not alongside the user-defined methods. This should take no inputs. Note that you cannot use an arrow function here since we need access to to access our ref. Inside your method, assign your ref to a variable, and then call the function of the ref. You don't have to use here because the component has already been added to the DOM when is called. Now when you activate the \"Edit\" button with your keyboard, focus should immediately be moved to the edit .\n\nThere's one more place we need to consider focus management: when a user deletes a to-do. When clicking the \"Edit\" button, it makes sense to move focus to the edit name text box, and back to the \"Edit\" button when canceling or saving from the edit screen. However, unlike with the edit form, we don't have a clear location for focus to move to when an element is deleted. We also need a way to provide assistive technology users with information that confirms that an element was deleted. We're already tracking the number of elements in our list heading — the in — and it's associated with our list of to-do items. This makes it a reasonable place to move focus to when we delete a node. First, we need to add a ref to our list heading. We also need to add a to it — this makes the element programmatically focusable (i.e. it can be focused via JavaScript), when by default it is not. Inside , update your as follows: Note: is a really powerful tool for handling certain accessibility problems. However, it should be used with caution. Over-using can cause problems for all sorts of users, so only use it exactly where you need to. You should also almost never use > = , as it can cause problems for users since it can make the DOM flow and the tab-order mismatch, and/or add non-interactive elements to the tab order. This can be confusing to users, especially those using screen readers and other assistive technology. Now that we have a and have let browsers know that we can programmatically focus the , we need to set focus on it. At the end of , use the ref to set focus on the . Since the is always rendered in the app, you do not need to worry about using or lifecycle methods to handle focusing it. Now, when you delete an item from your list, focus should be moved up to the list heading. This should provide a reasonable focus experience for all of our users."
    },
    {
        "link": "https://stackoverflow.com/questions/67033933/cant-use-template-ref-on-component-in-vue-3-composition-api",
        "document": "I want to get the dimensions of a vue.js component from the parent (I'm working with the experimental script setup).\n\nWhen I use the ref inside a component, it works as expected. I get the dimensions:\n\nBut I want to get the dimension inside the parent component. Is this possible?\n\nI have tried this:\n\nthe console logs this error message: Uncaught (in promise) TypeError: x.value.getBoundingClientRect is not a function\n\nIn the documentation I can only find the way to use inside the child component\n\ndoes this approach not work because the refs are \"closed by default\" as the rfcs description says?"
    }
]