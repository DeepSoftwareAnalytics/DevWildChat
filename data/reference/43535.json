[
    {
        "link": "https://marketplace.visualstudio.com/items?itemName=RichardKaiser.cppclrwinf",
        "document": "Windows Forms Apps in C++ with Visual Studio 2022 Extend Visual Studio 2022 by Windows Forms projects written in C++. Applications created by such projects have a graphical user interface. They are based on .NET Framework. You can use all common Windows controls like Buttons, Menues, TextBoxes etc. Click here for a tutorial for Windows Forms Projects in English.\n\n Klicken Sie hier für eine Anleitung für Windows Forms Projekte in Deutsch. Use Standard C++ (including most of C++11, C++14, C++17) for your business logic. To access GUI controls use C++/CLI (an easy to use C++ dialect). The main difference between a traditional C++ program is, that instead of using the console for user interaction you can use Windows controls, e.g. a TextBox C++ Windows forms projects are an easy way to create programs with a graphical user interface in C++.\n• Use Windows Forms Projects to enhance your C++ programs with a graphical user interface. You can write serious C++ applications with Windows Forms projects.\n• Windows Forms Projects are great for learning C++. I used them in my introductory C++ lectures for years. Since the programs are not restricted to the console for user interaction, they are more attractive, more flexible and much easier to use for the students. Based on this extension I created another extension that is a very simple Windows Forms Project with a graphical user interace (GUI) written in C++. The form contains a button and textboxes for input and output, but you can easily extend it by adding more controls and functions. My textbook (in German) teaches C++ from the scratch, using C++ Windows forms. It focuses on standard C++ at the C++17 level, not C++/CLI."
    },
    {
        "link": "https://learn.microsoft.com/en-us/answers/questions/1421117/visual-studio-2022-forms-using-c",
        "document": ">Please explain the difference between “document” and “dialog” in this option box.\n\n\"MFC makes it easy to work with both single-document interface (SDI) and multiple-document interface (MDI) applications.\""
    },
    {
        "link": "https://learn.microsoft.com/en-us/visualstudio/windows?view=vs-2022",
        "document": "Share your apps and code by using Web Deploy, InstallShield, NuGet, Continuous Integration, and more."
    },
    {
        "link": "https://reddit.com/r/learnprogramming/comments/ulpkp3/is_visual_c_clr_windows_forms_still_widely_being",
        "document": "I use Visual C++ CLR (.NET/.NET Framework) Windows Forms to make small GUI programs that are being given as college assignments.\n\nBut, It feels a bit cringe to learn this technology. Visual C++ CLR Windows Forms is probably the only way to make GUI C++ apps in Visual Studio and the Microsoft itself recommends using C# instead of Visual C++ to make these things.\n• Programs made in this environment aren't compatible outside Windows\n• Lack of learning resources. What I primary found are the official Microsoft documentation and a couple of random questions on StackOverflow.\n• On Youtube there's only one guy called Sciber, who've managed to make a consistent, modern and in depth tutorial on Visual C++ Windows Forms\n\nFrom my quick research, I didn't find many job stating the technology as a requirement.\n\nFor example, typing into Indeed search bar: \"Visual C++ CLR\" gives out only 5 results across the United States. For \"C++ CLR\" it is 14 jobs. Typing \"C++ Windows forms\" gives the results of jobs similar, but not related to the technology.\n\nWhat do you think? Is it still used today? What about the C# in this context?\n\nIs it better to learn and use QT C++ in terms of development convenience and job demand?\n\nMay be Visual Studio C++ used more widely in other ways?"
    },
    {
        "link": "https://stackoverflow.com/questions/65851671/windows-forms-c-clr-net-framework-how-to-use-button-events",
        "document": "I am building an application that uses Computer Vision to detect objects with a webcam.\n• To implement the idea, I use the OpenCV library and C++.\n• To build the windows form I am using C++/CLR (.NET Framework) with Visual Studio 2019.\n\nI have already got the program to work but I want to improve my code.\n\nIntroduction to my question: \n\n I want to make less and more efficient code in the \"button events\" which you can see in \"CODE 1\". The reason for it, is because I am almost using the same code for all of the three buttons (it takes a lot of space and is ugly).\n\nMy idea is to build a class around the code which you can see in the button events and make instances of the class in each button event. The problem is, I also need to be able to press the exit button and control the member variables I have in CODE 1.\n\nThe three private member variables in CODE 1 are as follows:\n\nI use them to turn the while loops on and off in each button event so the webcam window will be turned off when a new event is pressed.\n\n(the webcam window is provided by the OpenCV library when you press one of the three buttons).\n• What is the best and most efficient way to implement this.\n• Is it good as it is?\n• I am using already trained Haar Cascade files from the OpenCV library to detect the objects. My program is very slow and the webcam lags a lot. How can get rid of this lag? (I think I need to use YOLO or some other implementation of the Artificial Intelligence (AI) part but i'm not sure)\n• Is it good as it is? Do I need to turn one event off by my self when another button event is pressed or does that happen automatically inside of the C++/CLR library?\n\nCODE 1 and CODE 2 are found below.\n\nCODE 1: Here is my \"windows Form code\" called MyForm.h\n\nCODE 2: Here is my \"Source code\" called Source.cpp\n\nThank you for reading the question!"
    },
    {
        "link": "https://stackoverflow.com/questions/2501700/event-handling-for-button-click-in-visual-c",
        "document": "\n• None Add a new project of type \"Visual C++/CLR/Windows Forms Application\" to your solution.\n• None Add a button and textbox to the designer.\n• None Double-click the button on the designer. This should take you to the form code, where an event handler will have been created and registered for you.\n• None In the body of that event handler, you may access the text field using its name from the design (the name is viewed/modified by right-clicking the item in the form designer and selecting \"Properties\")."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/desktop/winforms/controls/how-to-respond-to-windows-forms-button-clicks?view=netframeworkdesktop-4.8",
        "document": "How to: Respond to Windows Forms Button Clicks\n\nThe most basic use of a Windows Forms Button control is to run some code when the button is clicked.\n\nClicking a Button control also generates a number of other events, such as the MouseEnter, MouseDown, and MouseUp events. If you intend to attach event handlers for these related events, be sure that their actions do not conflict. For example, if clicking the button clears information that the user has typed in a text box, pausing the mouse pointer over the button should not display a tool tip with that now-nonexistent information.\n\nIf the user attempts to double-click the Button control, each click will be processed separately; that is, the control does not support the double-click event.\n• None In the button's EventHandler write the code to run. must be bound to the control. For more information, see How to: Create Event Handlers at Run Time for Windows Forms. Private Sub Button1_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles Button1.Click MessageBox.Show(\"Button1 was clicked\") End Sub"
    },
    {
        "link": "https://stackoverflow.com/questions/65851671/windows-forms-c-clr-net-framework-how-to-use-button-events",
        "document": "I am building an application that uses Computer Vision to detect objects with a webcam.\n• To implement the idea, I use the OpenCV library and C++.\n• To build the windows form I am using C++/CLR (.NET Framework) with Visual Studio 2019.\n\nI have already got the program to work but I want to improve my code.\n\nIntroduction to my question: \n\n I want to make less and more efficient code in the \"button events\" which you can see in \"CODE 1\". The reason for it, is because I am almost using the same code for all of the three buttons (it takes a lot of space and is ugly).\n\nMy idea is to build a class around the code which you can see in the button events and make instances of the class in each button event. The problem is, I also need to be able to press the exit button and control the member variables I have in CODE 1.\n\nThe three private member variables in CODE 1 are as follows:\n\nI use them to turn the while loops on and off in each button event so the webcam window will be turned off when a new event is pressed.\n\n(the webcam window is provided by the OpenCV library when you press one of the three buttons).\n• What is the best and most efficient way to implement this.\n• Is it good as it is?\n• I am using already trained Haar Cascade files from the OpenCV library to detect the objects. My program is very slow and the webcam lags a lot. How can get rid of this lag? (I think I need to use YOLO or some other implementation of the Artificial Intelligence (AI) part but i'm not sure)\n• Is it good as it is? Do I need to turn one event off by my self when another button event is pressed or does that happen automatically inside of the C++/CLR library?\n\nCODE 1 and CODE 2 are found below.\n\nCODE 1: Here is my \"windows Form code\" called MyForm.h\n\nCODE 2: Here is my \"Source code\" called Source.cpp\n\nThank you for reading the question!"
    },
    {
        "link": "https://learn.microsoft.com/en-us/archive/msdn-magazine/2006/may/integrate-windows-forms-and-mfc-applications-through-c-interop",
        "document": "Integrate Windows Forms Into Your MFC Applications Through C++ Interop\n\nC++ Interop Is Your Friend\n\n When to Use C++ Interop\n\n Windows Forms Controls in MFC Apps\n\n Handling Control Events\n\n Controls as Dialog Boxes\n\n Windows Forms Views\n\n Bridges to Avalon\n\n Conclusion\n\nAlthough the Microsoft .NET Framework was first made public almost five years ago, and version 2.0 has just recently been released, many C++ applications are still pure unmanaged code. But interest in the .NET Framework is growing rapidly among C++ developers. And for good reason: many future Windows® APIs will be based on the .NET Framework. This is certainly true for the WinFX® components Windows Presentation Foundation, Windows Communication Foundation, and Windows Workflow Foundation.\n\nStill, many C++ developers want to use native APIs instead of wrappers around existing APIs. Wrappers are often assumed to be buggy, slow, and less flexible. Apart from that, it would be really difficult to map huge APIs like WinFX so that they can be used from native code.\n\nIn most cases, extending C++ applications with features from the .NET Framework is easier than most developers believe. Visual C++® includes a feature called C++ interop, sometimes referred to as IJW, or \"It Just Works.\" You can use this feature to seamlessly integrate .NET-based code into your existing C++ source code.\n\nC++ interop is based on two major features. First, you can compile your existing C++ code to Microsoft® intermediate language (MSIL) by using the /clr switch of the C++ compiler. Your code can then use .NET features like garbage collection, sandboxed security, and types from the huge .NET Framework base class library.\n\nThe other feature is called mixed-mode, and it is equally important. It refers to the combination of both managed and unmanaged code. When compiling C++ code to MSIL, the compiler creates managed object files containing MSIL code instead of the normal, unmanaged object files containing native assembly code. The linker is able to take both managed and unmanaged object files as input. When the linker detects at least one managed input, it creates a .NET assembly, which can contain both managed code and unmanaged code. That\"s why it is called mixed-mode (see Figure 1). This feature is extremely important for performance optimizations because it allows you to drastically reduce the number of transitions between the managed and unmanaged spaces.\n\nC++ Interop Is Your Friend\n\nMy experience has shown that C++ interop is very reliable, and while it has some limitations, it\"s a worthwhile addition to your developer toolbox. To understand how this feature is possible, you should be aware that C++ interop was a design feature of the .NET Framework. The Common Language Infrastructure (CLI), which is the base specification of the .NET Framework, has been designed to support this feature. In fact, there are many aspects of the CLI that were defined simply because C++ interop required them.\n\nFor example, managed metadata supports global functions. Yet C# and most other .NET-targeted languages require all methods to exist within the scope of a class. This feature exists because C++ code that should be mapped to .NET-based code can have global functions, and to map this C++ code to managed code, metadata needs an equivalent concept.\n\nThe MSIL instruction set has also been designed with C++ interop in mind. To map C++ code to MSIL code, MSIL must support all common data manipulation operations like the typical Boolean, arithmetic, and floating point operations. MSIL also supports pointer-based access to virtual memory. This feature is key to using native types in managed code. If your C++ code accesses a field of a native object, the C++/CLI compiler can emit MSIL code that pushes the address of the native object on the stack, adds the field\"s offset to it, and uses the resulting address to access the field. All of this is possible because the MSIL instruction set has operations that can access virtual memory through addresses.\n\nAnother C++-specific feature of the IL language is the CALLI instruction. It can be used to call to native functions through function pointers. This feature is used to call virtual functions of native types. It is important because COM interfaces are native types with virtual functions. This method of COM interoperability has many advantages over the alternative COM interoperability techniques used by other languages.\n\nFinally it\"s worth mentioning the design impact that is most obvious to all developers who use .NET: the file format for components. While Java has defined its own file format (the .class file), the .NET Framework uses the standard PE file format. Therefore, .NET-based components have the comfortable file extensions DLL and EXE. The fact that PE files are still used is essential to supporting mixed-mode assemblies.\n\nWhen to Use C++ Interop\n\nTo evaluate whether C++ interop is the way to go for your projects, you should also know about the impact that this feature has on the way you build your projects—compiler settings, for starters—as well as the impact on the output of this build process.\n\nIf you compile with the /clr option, your code implicitly depends on the multithreaded DLL version of the C runtime libraries (CRT). This means that all files in your project—even those compiled without /clr—must use the multithreaded DLL version of the CRT. This is also important for MFC projects. The static MFC library depends on the static CRT library, which is incompatible with /clr compilation. Therefore you have to make sure that your MFC projects link the DLL version of MFC.\n\nThere can also be issues regarding execution time. Initializing the CLR takes a certain amount of time, and JIT compilation has some overhead, too. Therefore you may experience a somewhat longer startup time. However, for most projects this should not be a big issue.\n\nMethod calls with managed-to-unmanaged transitions will take longer than normal method calls. As I have mentioned already, you can significantly reduce the number of transitions between managed and unmanaged code by deciding which specific parts of your app should be compiled to managed code. The calling convention __clrcall is another important optimization feature that can significantly reduce the number of transitions, but this feature is beyond the scope of this article.\n\nIn most cases, the just-in-time (JIT)-compiled code itself is not the cause of significant performance penalties. In fact, there are some optimizations that a JIT compiler can do that are not possible for the C++ compiler and the linker. For example, a JIT compiler can optimize code for the processor architecture on the target machine. In contrast to the C++ compiler, a JIT compiler can also provide cross-component inlining. This can be a very effective optimization, because code compiled with cross-component inlining can then be exposed to further optimizations.\n\nApart from the issues I\"ve mentioned here, there are some other areas that will be impacted that I will not cover in detail here. Most of these can be easily resolved by modifying compiler and linker settings in the right way. The optimal compiler settings are not always straightforward. Some of these settings turn on features that are mandatory for C++ interop compilation, while some other settings may turn off features that are incompatible with /clr compilation or that are solved for Microsoft intermediate language in a different manner.\n\nAll source files that are compiled with the /clr option can use types from the .NET Framework base class library. You can use most parts of the base class library as you have always used them. Some cases require special attention. Integrating Windows Forms controls in MFC applications is such an example.\n\nYou cannot pass System::Windows::Forms::Control^ when a CWnd* is expected. However, the Windows Forms API and MFC share a common heritage: good old User32.dll. Both APIs provide some backdoors to the HWNDs. While the MFC CWnd class provides a conversion operator to HWND, the Windows Forms control class implements the interface IWin32Window from the namespace System::Windows::Forms to expose the window handle:\n\nHowever, getting a window handle from a window object is often not enough. MFC provides some classes with support for dealing with Windows Forms controls in different scenarios. These classes are declared in afxwinforms.h.\n\nThe most important of these classes is CWinFormsControl, which is defined in the namespace Microsoft::VisualC::MFC. This class allows you to host a Windows Forms control in an MFC Dialog or CDialog-derived class. It is a templated class with one template argument, used to pass the type of the Windows Forms control you want to host. The type can be either the concrete type you want to instantiate later or a base class of the concrete type. The CWinFormsControl template is quite simple. It has only two interesting features: it inherits CWnd and it provides several overloads of a self-explaining method, CreateManagedControl.\n\nIf you want to host a Windows Forms control in an MFC Dialog or CDialog-derived class, define a member variable of type CWinFormsControl<TWinFormsCtrl> in your class and pick one of the overloads of CreateManagedControl. If you implement a CDialog-derived class, a good candidate for creating the managed control is OnInitDialog. For most other cases, OnCreate (the message handler for WM_CREATE) is the best option. One of the overloads is especially interesting for dialog classes. This overload expects you to add a static placeholder control to a dialog resource. Place the static control so that it has the position and size that the Windows Forms control should have and give it a unique ID, as shown in Figure 4. To instantiate the hosted control, call CreateManagedControl as shown in Figure 2. As an alternative, you can even use a special variant of Dialog Data Exchange (DDX) like in Figure 3.\n\nNotice that this way of hosting Windows Forms controls in MFC applications uses yet another common heritage of Windows Forms and MFC: ActiveX® controls. As you can see in the list in Figure 5, System::Windows::Forms::Control implements many interfaces that should be familiar to OLE and ActiveX control veterans. Inside of CreateManagedControl, the Windows Forms control is instantiated via the gcnew operator and in-place activated just like a normal ActiveX control.\n\nAlso notice that CWinFormsControl overloads the -> operator so that the hosted control is returned. This allows you to initialize the button\"s Text property through simple assignement:\n\nThis handling is not as clean as modifying a control\"s properties in the properties window, but if you can live with the limited designer support that currently exists, the world of Windows Forms controls is open to your trusty old MFC dialog boxes.\n\nThere is another aspect that should be discussed here. So far the button\"s click event is not handled. Since you have a Windows Forms control that is hosted like an ActiveX control, there are two options for event handling: connection points provided by the ActiveX control and event members of the Windows Forms control. The connection point alternative would only be successful if the Windows Forms control was prepared to support COM-based events. For most Windows Forms controls this is not the case, so handling events the .NET way is the only option here. Events of managed classes are a special kind of type member that allows the registration and deregistration of event handler delegates. The following line shows how to register the button\"s click event:\n\nTo provide such a delegate, a function with the following syntax is required:\n\nUnfortunately, it is not enough to implement such a method in the CDialog-derived class. Delegate target functions must be member functions of managed classes, and the CDialog derived class is a native one. Visual C++ provides a header file, \\Msclr\\Event.h, that gives you a generic solution to this problem. The definitions in this header can be used whenever you want to handle a .NET event with a method of a native C++ class. As I will discuss later, you can also use this header when integrating the Visuals features of Windows Presentation Foundation. Since this header is helpful in so many different scenarios, it makes sense to discuss the solution it provides in depth.\n\nTo handle the events of the Windows Forms control, you could implement a managed class containing the message handler. C++ interop allows you to do this in an elegant way because this managed class can be nested into the CDialog-derived class:\n\nThe most convenient way to handle the button\"s click event is to forward this method call to a member function of the CDialog-derived class. The method that finally handles the click event can easily access other members of the derived class, just in the way you expect event handlers to work. The managed class containing the delegate target ends up being a simple proxy type. Although such a proxy type and its proxy event handlers can be created with macros defined in Event.h, let\"s first have a look at a manual definition (see Figure 6).\n\nAs you can see, the delegate proxy has a constructor that takes a CMyDialog* argument. Such a constructor is necessary to forward method calls to the CDialog-derived class. This delegate proxy type could be used for all event handlers for all Windows Forms controls of the dialog class. It is not possible to add a member variable of the delegate_proxy_type to the derived class, since native classes cannot have handles to garbage-collected objects as fields. Using the gcroot template, you can bypass this restriction here. Therefore, a member variable of type gcroot<delegate_proxy_type> is necessary. However, there is still a remaining question: how could the gcrooted reference to the delegate proxy type be initialized properly? This can be handled by a separate method that is called whenever a handle to delegate_proxy_type is needed.\n\nWith the code from Figure 6, a delegate can easily be registered as in the following sample:\n\nWriting all this code would be a huge amount of work for just handling events of a Windows Forms control in a CDialog-derived class. Event.h contains macros and templates to achieve the same and even more with many fewer lines, as shown in Figure 7.\n\nEvery new version of MFC brings at least one new map. As you can see, the current version introduces the delegate map. The macro BEGIN_DELEGATE_MAP defines the delegate_proxy_type that contains the delegate targets. Every EVENT_DELEGATE_ENTRY line adds such a target method to the managed class. END_DELEGATE_MAP just finishes the managed class. Finally, MAKE_DELEGATE instantiates a delegate referring to the target method of delegate_proxy_type. In fact, the macros do even more than what I have just discussed. They are even prepared for scenarios where the managed class fires events to be sent to a native object that no longer exists.\n\nAnother simple yet effective helper is the template CWinFormsDialog. You can use it to show a Windows Forms control as a modal or modeless dialog box. This class is fairly simple. It extends CDialog to provide the standard behavior of MFC dialog boxes. Apart from that, it uses a CWinFormsControl member variable to host the Windows Forms control, initializes the dialog box\"s caption to the value of the hosted control\"s Text property, sets the dialog\"s initial size so that the control perfectly fits into it, and ensures that the size of the hosted control is adjusted whenever the size of the parent window changes.\n\nThis one-liner instantiates a temporary dialog box object hosting YourWinFormsDlgControl and shows it as a modal dialog box:\n\nYou should avoid this, however, since there\"s no way to get the dialog\"s return value using DoModal. For more realistic scenarios, consider deriving your own class from CWinFormsDialog<YourWinFormsDlgControl>. This allows you to override OnInitDialog to set properties of the nested Windows Forms control or to handle events of the hosted control. The macros from Event.h that I described earlier can be useful in this case, too. For more information, see msdn2.microsoft.com/ahdd1h97.aspx.\n\nLast, but not least, you can host Windows Forms controls as views. CWinFormsView is the little helper you need for this scenario. Unlike CWinFormsDialog, it is not a template class. Nevertheless, there are significant similarities. Both leave the actual hosting of the control up to the CWinFormsControl template and both handle the resizing of the hosted control.\n\nTo host a Windows Forms control as an MFC dialog box, you have to inherit your view class from CWinFormsView. The following code shows the declaration of a simple view class that is based on CWinFormsView:\n\nIf your view class was generated by a wizard, you should make sure to switch to CWinFormsView not only in the base class list of your view\"s class declaration, but also in its implementation. This may cause you to change parameters of macros like IMPLEMENT_DYNAMIC and BEGIN_MESSAGE_MAP. To instantiate the hosted Windows Forms control, the constructor of CWinFormsView (your view\"s base class) gets a handle to the System::Type object of the Windows Forms control. The implementation of the view class just shown can be very simple, too:\n\nAt the first view, this code looks much too simplistic for a real-life scenario, but in many cases this is really all you need. The view class acts as a simple proxy for the real implementation that resides in the view\"s control.\n\nMany view implementations override virtual functions of the MFC CView base class. To keep the native view class acting as a simple proxy, you could override these methods in the native view class and forward the calls to equivalent methods in the view\"s Windows Forms control. For the three most important overrides of CView, such forwarding has already been implemented in the base class CWinFormsView. These three methods are OnInitialUpdate, OnUpdate, and OnActivateView. The forwarding is based on a managed interface named Microsoft::VisualC::MFC::IView that is defined in the assembly Mfcmifc80.dll. To override these methods, implement this interface in the view\"s Windows Forms control class as shown in Figure 8.\n\nIn addition to overriding virtual functions, views can also implement command handlers. Again, it would be possible to implement such a command handler in the native view class and forward to the Windows Forms control, but since this is a common scenario, MFC provides a more convenient solution. The Mfcmifc80.dll assembly contains some more managed helper types for this scenario. To receive command messages from MFC\"s command-routing infrastructure, Windows Forms controls must implement the interface Microsoft::VisualC::MFC::ICommandTarget:\n\nWhen a view that implements ICommandTarget is created, ICommandTarget::Initialize is called on that view and a handle to a new command source object is passed as an argument. This argument is of the type ICommandSource^. The object that the argument refers to is a container for handlers. These handlers should sound familiar to MFC developers: they are command handlers that are called when a command is issued and command UI handlers that can control whether a control\"s UI is enabled, checked, or adorned with a radio button, and what text is displayed in the command\"s UI.\n\nTo register a handler, methods like AddCommandHandler and AddCommandUIHandler can be called on the command source. These methods expect two arguments: an unsigned integer for the command ID, and a delegate that is used to pass the control\"s handler function. Since command handlers and command UI handlers have different signatures, two different delegate types are defined in the namespace Microsoft::VisualC::MFC:\n\nFigure 9 shows how to register a command handler for the ID_EDIT_PASTE command.\n\nWhen a view is supposed to handle a command, the delegate is used to call a member function of the view. The command\"s ID is passed as an argument. If every command has its own private handler function, this argument is not important, but a single method can also be used as a handler for more than one command. AddCommand[UI]RangeHandler allows you to register one delegate for multiple commands.\n\nThe delegate for command UI handlers has an additional argument of type ICommandUI^. The handle that is passed using this parameter is a wrapper for the MFC CCmdUI class that allows you to control the appearance and usability of interface elements like menu items and toolbar buttons.\n\nIn addition to adding command handlers in ICommandSource::Initialize, it can also be useful to store the ICommandTarget handle in a member variable of the Windows Forms control. This gives you the option to add or remove further command handlers later, and you can even fire command events either synchronously or asynchronously through ICommandTarget::SendMessage or ICommandTarget::PostMessage.\n\nSince Windows Presentation Foundation has not yet been released in final form, the current version of MFC does not have helper classes and templates for integrating its Visuals in CWnds and CDialogs. However, this does not mean that integrating Visuals in MFC applications is not possible. In fact, even without these little helper classes, it only takes a few lines of code to host a Visual in a CWnd or a CDialog.\n\nThe key feature for this integration comes from Windows Presentation Foundation itself. The assembly Windows.PresentationCore.dll provides a namespace System::Windows::Interop with very powerful class named HwndSource. This class provides the bridge between an HWND and a Visual. To the hosting USER32 window object, it looks like a child window with a normal HWND. Using its RootVisual property, you can switch into the new world of Windows Presentation Foundation. (Note that the information here is based on a prerelease version of Windows Presentation Foundation and may change with the final release.)\n\nThe HwndSource constructor expects a HwndSourceParameters value type as an argument. As you can see in Figure 10, this value type contains similar information that you would pass as arguments in a call to the Win32 function CreateWindowEx. Figure 11 shows how to use HwndSource in an OnInitDialog implementation.\n\nUsing C++ interop, managed code can be seamlessly integrated into existing C++ sources. The MFC support for Windows Forms can be seen as strong evidence that this integration is an intended and supported feature of Visual C++. To simplify this integration, several helper classes and templates exist. This integration layer is neither complex nor difficult to use.\n\nOne thing that is missing is a seamless integration of these features into the wizards of Visual Studio. In most scenarios, this is not a big problem since much of the implementation will be left to the hosted Windows Forms control, which has great designer support in Visual Studio. When Windows Presentation Foundation ships, there\"s a high probability that equivalent support for integrating Visuals into MFC applications will be provided. Even without such support, though, it is easy to host Visuals in MFC apps.\n\nMarcus Heege works as a course author and trainer for DevelopMentor and provides consulting for different IT companies. He regularly posts his thoughts about C++/CLI and .NET in his blog at www.heege.net."
    },
    {
        "link": "https://rkaiser.de/c-winforms-tutorial",
        "document": "In Visual Studio up to version 2010, Templates for Windows Forms projects are pre-installed, but not as of Visual Studio 2012. For these newer versions of Visual Studio you have to install an extension.\n\nThis tutorial is for Visual Studio 2022, but applies essentially the same to other versions of Visual Studio (2019, 2017, 2015 and earlier).\n\nInstalling the extension for Windows Forms projects with C++\n\nAfter the next start of Visual Studio under File|New|Project you will find the CppCLR_WinformsProject template:\n\nWith this template you can create Windows Forms projects written in C++. Such a project creates a Windows application with a graphical user interface (buttons, menus, etc.), for example:\n\nStandard C++ (including almost all extensions of C++11, C++14, C++17) is used as programming language for the business logic. Only for accessing Windows controls C++/CLI is necessary. This is a simple C++ dialect for the .NET Framework.\n\nThe book „C++ mit Visual Studio 2019 und Windows Forms-Anwendungen“\n\nIn order to create Windows Forms projects in Visual Studio, particular components must be installed during the installation of Visual Studio. If this was forgotten during the installation, start the Visual Studio Installer either under Windows|Start\n\nor in Visual Studio under File|New|Project|Create new project (at the end of the project list)\n\nIn the installer, check .NET desktop development, desktop development with C++ and C++/CLI support:\n\nClick the Next button. Then you will be prompted to enter the name of the project and a directory:\n\nIf you now click on Form1.h in the Solution Explorer, the form is displayed:\n\nTo prevent the toolbox from covering the form, drag the toolbox to the frame with the Solution Explorer (press the left mouse button on the title bar of the toolbox, then move to the title bar of the Solution Explorer with the mouse button pressed and release the mouse button).\n\nThe form (here Form1) is the starting point for all Windows Forms applications. It corresponds to the window that is displayed when the program is started:\n\nControls from the Toolbox can be placed on a form. The Toolbox contains essentially all the controls commonly used in Windows. They are located in various groups (e.g. General Controls, Containers, etc.), which can be expanded and collapsed. Most of these controls (such as a button) are displayed on the form while the program is running. If you stop with the mouse pointer briefly on a line of the toolbox, a small hint appears with a short description:\n\nTo place an element from the toolbox on the form, simply drag it from the toolbox onto the form. Or click on it in the toolbox first and then click on the position in the form where you want the upper left corner to be.\n\nExample: After placing a Label (line seven in Common Controls, with the capital A), a TextBox (fourth line from the bottom, labelled ab) and a Button (second line labelled ab) on the form, it looks something like this:\n\nDo not forget to close your program before you continue editing it. As long as the program is still running, you cannot restart the compiler or modify the form.\n\nThis way of programming is called visual programming. While conventional programming means developing a program solely by writing instructions (text) in a programming language, visual programming means composing it wholly or in part from out-of-the-box graphical controls.\n\nWith Visual Studio, the user interface of a Windows Forms program can be designed visually. This allows you to see how the program will look later at runtime as soon as you design it. The instructions that are to take place as a response to user input (mouse clicks, etc.), on the other hand, are written conventionally in a programming language (e.g. C++).\n\nThe control that was clicked last on a form (or in the pull-down menu of the Properties window) is called the currently selected control. You can identify it by the small squares on its edges, the so-called drag handles. You can drag them with the mouse to change to resize the control. A form becomes the currently selected control by clicking on a free position in the form.\n\nExample: In the last example, button1 is the currently selected control.\n\nIn the Properties window (context menu of the control on the form, or View|Properties window – do not confuse with View|Property pages).\n\nthe properties of the currently selected control are displayed. The left column contains the names and the right column contains the values of the properties. With F1 you get a description of the property.\n\nThe value of a property can be changed via the right column. For some properties, you can type the new value using the keyboard. For others, after clicking on the right column, a small triangle is displayed for a pull-down menu, through which a value can be selected. Or an icon with three dots „…“ is displayed, which can be used to enter values.\n• For the Text property, you can enter a text with the keyboard. For a button this text is the inscription on the button (e.g. „OK“), and for a form the title line (e.g. „My first C++ program“).\n• For the BackColor property (e.g. from a button) you can select the background color via a pull-down menu.\n• If you click the right column of the Font property and then the „…“ icon, you can select the font of the Text property.\n\nA control on the form is not only adjusted to its properties in the Properties panel, but also vice versa: if you resize it by dragging the drag handles on the form, the values of the corresponding properties (Location and Size in the Layout section) in the Properties panel are automatically updated.\n\nNext, the program from Section 1.5 is to be extended so that instructions are executed in response to user input (e.g., a button click).\n\nWindows programs can receive user input in the form of mouse clicks or keyboard input. All inputs are received centrally by Windows and passed on to the program. This triggers a so-called event in the program.\n\nSuch an event can be assigned a function that is called when the event occurs. This function is also called an event handler.\n\nFor the time being, our program should only react to the clicking of a button. The easiest way to get the function called for this event is to double-click on the button in the form. The cursor is then placed at the beginning of the function. This causes Visual Studio to generate the following function and display it in the editor:\n\nBetween the curly brackets „{“ and „}“ you then write the statements to be executed when the Click event occurs.\n\nEssentially all instructions of C++ are possible here. In the context of this simple tutorial, only some elementary instructions are to be introduced, which is necessary for the basic understanding of Visual Studio. If terms like „variables“ etc. are new to you, read on anyway – from the context you will surely get an intuitive idea which is sufficient for the time being.\n\nA frequently used instruction in programming is the assignment (with the operator „=“), which is used to assign a value to a variable. Initially, only those properties of controls that are also displayed in the properties window are to be used as variables. These variables can then be assigned the values that are also offered in the properties window in the right column of the properties.\n\nFor the BackColor property, the allowed values are offered after the pull-down menu is expanded:\n\nThese values can be used in the program by specifying them after Color::. If you now write the statement\n\nthe BackColor property of textBox1 gets the value Color::Yellow, which stands for the color yellow, when button1 is clicked during the execution of the program. If you now start the program with F5 and then click button1, the TextBox actually gets the background color yellow.\n\nEven if this program is not yet much more useful than the first one, you have seen how Visual Studio is used to develop applications for Windows. This development process always consists of the following activities:\n• You design the user interface by placing controls from the Toolbox on the form (drag and drop) and adjusting their properties in the Properties window or the layout with the mouse (visual programming).\n• You write in C++ the instructions that should be done in response to user input (non-visual programming).\n\nThe period of program development (activities 1. and 2.) is called design time. In contrast, the time during which a program runs is called the runtime of a program.\n\nThe main purpose of this project is to show how the application logic is separated from the user interface:\n• The functions, classes, etc. of the application logic are written in standard C++ and are contained in a header file that is added to the project.\n• The instructions for the user interface, on the other hand, are written primarily in C++/CLI and are often included in the form class in Form1..\n• The functions of the header file are called when clicking a button.\n\nThe following is a simplified version of chapter 2.11 from my book „C++ mit Visual Studio 2019 und Windows Forms-Anwendungen“. There I recommend such a project for the solutions of the exercises. In the header file of such a project you can include the solutions of several exercises or distribute them to different header files. For each subtask you can put a button (or menu options) on the form. This way you don’t have to create a new project for each subtask.\n\nOf course, outsourcing your own instructions to an extra file (as in 3.) and accessing the controls via function parameters is somewhat cumbersome: however, it leads to clearer programs than if all instructions are located in the form file within the Form1 class. This saves many programming errors that lead to obscure error messages, and makes it easier to search for errors.\n\nThe form is then designed to contain all the controls needed to input and output information and start actions. This is done by dragging appropriate controls from the toolbox onto the form.\n\nFor many projects (e.g. the exercises from my book) the following controls are sufficient:\n\nA TextBox becomes multiline TextBox by the value true of the MultiLine property. The TextBox for output is to be named out_textBox:\n\nThe TextBox for entering data will be named in_textBox:\n\nSince the function plus_1 is called when the button is clicked, it is given the caption „plus 1“ and the name button_plus1:\n\nThe functions, declarations, classes etc. of the so-called application logic are placed in a separate header file, which is added to the project with Project|Add new element|Visual C++|Code as header file(.h) with the name Header1.h. In practice, however, you should group functions and classes that belong together conceptually in a header file, and then give the header file a more meaningful name than Header.h.\n\nThe application logic is then included in the header file. These are mostly functions, classes, etc. written in C++. In our first example, this should be a function with the name plus_1, which returns the value of the argument increased by 1:\n\nIn a C++ Windows Forms project, the application logic consists primarily of functions, classes, etc. written in C++, without C++/CLI language elements. In our first example, this should be a function named plus_1, which returns the value of the argument incremented by 1:\n\nDiese Datei wird dann vor dem namespace des Projekts mit einer #include-Anweisung in die Formulardatei (z.B. Form1.h) aufgenommen:\n\nThis file is then included in the form file (e.g. Form1.h) before the namespace of the project with an #include statement:\n\nBy double-clicking the button on the form, Visual Studio creates the function (the event handler) that will be called when the button is clicked when the program is running:\n\nIn this event handler you then call the corresponding function. In this simple tutorial this is the function plus_1 from the file Header.h.\n• If this function uses user input, you read it in via a TextBox. In this simple tutorial, it will be a number that is read from the in_TextBox.\n• If a parameter of the called function does not have type String (the type of the property in_textBox->Text), the string must be converted to the type of the parameter. This is possible with one of the Convert:: functions.\n• The results are to be displayed in the out_textBox. This can be done with the function out_textBox->AppendText. The string that AppendText expects can be created with String::Format. In the first argument (a string) you specify {0} for the first value after the string, {1} for the second and so on.\n\nIf you enter a number in the input field after starting this program with F5 and then click on the button, the value incremented by 1 is displayed in the output text box:\n\nFor each further function whose result is to be displayed, a button is placed on the form and given a suitable name (Name property) and a suitable label (Text property). This function is then called in the associated event handler.\n\nWith this all relevant parts of the ??? CppCLR_Winforms_GUI are presented. You can enhance it as you like with additional controls (buttons, menus, etc.). See chapter 2 of my book for more information.\n\nIn the version created under 1. to 4. the application logic is strictly separated from the user interface: The access to the user interface with C++/CLI is exclusively done in Form1.h. In Header1.h, however, only standard C++ is used. This has in particular the advantage that one can use this header also in other platforms (e.g. console applications, Qt, Mac).\n\nHowever, in the early stages of a project, when there is still a lot of experimenting going on, it can be a bit cumbersome if you have to change the calls in another file every time you change a parameter list. And for applications that are not intended to be used for other platforms at all, this strict separation doesn’t help much. This often applies to exercise tasks as well.\n\nThis jumping back and forth between different files can be avoided by relaxing the strict separation between the application logic and the user interface by including access to the controls in the header file as well.\n\ninto the header file at the beginning. Then you can also use the types of the controls in the header file (e.g. as parameters) and include the statements that were in the buttonClick function in Form1.h under 4.\n\nHere you pass a parameter for the control to the function. Please note that you must specify a ^ after the name of a .NET type (e.g. TextBox, Button). In the function you then address the control under the name of the parameter.\n\nComparing of this Windows Forms project with a corresponding console application shows the analogy of the two types of projects. This analogy shows how to convert a console application into a forms application: If you have a console program like\n\nyou can port it to a form application with relatively little effort. You just need to replace the I/O statements and call the functions in response to a ButtonClick, etc:\n\nExcerpt from the preface to my book „C++ mit Visual Studio 2019 und Windows Forms-Anwendungen“\n\nThe starting point for this book was the desire for a C++ textbook in which programs for a graphical user interface (Windows) are developed from the beginning, and not console applications as is usually the case. Programs in which inputs and outputs are done via a console are like stone-aged DOS programs for many beginners and discourage them from wanting to deal with C++ at all.\n\nWindows Forms applications are an ideal framework for C++ programs with an attractive user interface: access to Windows controls (Buttons, TextBoxes etc.) is easy. The difference to a standard C++ program is mostly only that inputs and outputs are done via a Windows control (mostly a TextBox)\n\nwhile in standard C++ the console is used with cout:\n\nBut not only students can benefit from C++ with a graphical user interface. With Windows Forms projects, existing C or C++ programs can be enhanced with a graphical user interface without much effort. And those who know C or C++ and do not want to learn a new language for a GUI can make their existing programs more beautiful and easier to use with simple means.\n\nC++ has developed rapidly in recent years: The innovations of C++11, C++14, C++17 and C++20 have brought many improvements and new possibilities. Much of what was good and recommended in 2010 can be made better and safer today.\n\nAs a book author and trainer who has accompanied this whole evolution, you notice this particularly clearly: many things that have been written in the past should be done differently today. True, it would still be compiled. But it is no longer modern C++, which corresponds to the current state of the art and uses all the advantages.\n\nThis book introduces C++ at the Visual Studio 2019 level in May 2020. This is the scope of C++17."
    }
]