[
    {
        "link": "https://developer.android.com/develop/ui/views/layout/declaring-layout",
        "document": "Save and categorize content based on your preferences.\n\nA layout defines the structure for a user interface in your app, such as in an activity. All elements in the layout are built using a hierarchy of and objects. A usually draws something the user can see and interact with. A is an invisible container that defines the layout structure for and other objects, as shown in figure 1.\n\nobjects are often called widgets and can be one of many subclasses, such as or . The objects are usually called layouts and can be one of many types that provide a different layout structure, such as or .\n\nYou can declare a layout in two ways:\n• Declare UI elements in XML. Android provides a straightforward XML vocabulary that corresponds to the classes and subclasses, such as those for widgets and layouts. You can also use Android Studio's Layout Editor to build your XML layout using a drag-and-drop interface.\n• Instantiate layout elements at runtime. Your app can create and objects and manipulate their properties programmatically.\n\nDeclaring your UI in XML lets you separate the presentation of your app from the code that controls its behavior. Using XML files also makes it easier to provide different layouts for different screen sizes and orientations. This is discussed further in Support different screen sizes.\n\nThe Android framework gives you the flexibility to use either or both of these methods to build your app's UI. For example, you can declare your app's default layouts in XML, and then modify the layout at runtime.\n\nUsing Android's XML vocabulary, you can quickly design UI layouts and the screen elements they contain, in the same way that you create web pages in HTML with a series of nested elements.\n\nEach layout file must contain exactly one root element, which must be a or object. After you define the root element, you can add additional layout objects or widgets as child elements to gradually build a hierarchy that defines your layout. For example, here's an XML layout that uses a vertical to hold a and a :\n\nAfter you declare your layout in XML, save the file with the extension in your Android project's directory so it properly compiles.\n\nFor more information about the syntax for a layout XML file, see Layout resource.\n\nWhen you compile your app, each XML layout file is compiled into a resource. Load the layout resource in your app's callback implementation. Do so by calling , passing it the reference to your layout resource in the form: . For example, if your XML layout is saved as , load it for your as follows:\n\nThe Android framework calls the callback method in your when the launches. For more information about activity lifecycles, see Introduction to activities.\n\nEvery and object supports its own variety of XML attributes. Some attributes are specific to a object. For example, supports the attribute. However, these attributes are also inherited by any objects that extend this class. Some are common to all objects, because they are inherited from the root class, like the attribute. Other attributes are considered layout parameters, which are attributes that describe certain layout orientations of the object, as defined by that object's parent object.\n\nAny object can have an integer ID associated with it to uniquely identify the within the tree. When the app is compiled, this ID is referenced as an integer, but the ID is typically assigned in the layout XML file as a string in the attribute. This is an XML attribute common to all objects, and it is defined by the class. You use it very often. The syntax for an ID inside an XML tag is the following:\n\nThe at symbol (@) at the beginning of the string indicates that the XML parser parses and expands the rest of the ID string and identifies it as an ID resource. The plus symbol (+) means this is a new resource name that must be created and added to your resources in the file.\n\nThe Android framework offers many other ID resources. When referencing an Android resource ID, you don't need the plus symbol, but you must add the package namespace as follows:\n\nThe package namespace indicates that you're referencing an ID from the resources class, rather than the local resources class.\n\nTo create views and reference them from your app, you can use a common pattern as follows:\n• Define a view in the layout file and assign it a unique ID, as in the following example:\n• Create an instance of the view object and capture it from the layout, typically in the method, as shown in the following example:\n\nDefining IDs for view objects is important when creating a . In a relative layout, sibling views can define their layout relative to another sibling view, which is referenced by the unique ID.\n\nAn ID doesn't need to be unique throughout the entire tree, but it must be unique within the part of the tree you search. It might often be the entire tree, so it's best to make it unique when possible.\n\nXML layout attributes named define layout parameters for the that are appropriate for the it resides in.\n\nEvery class implements a nested class that extends . This subclass contains property types that define the size and position of each child view, as appropriate for the view group. As shown in figure 2, the parent view group defines layout parameters for each child view, including the child view group.\n\nEvery subclass has its own syntax for setting values. Each child element must define a that is appropriate for its parent, though it might also define a different for its own children.\n\nAll view groups include a width and height, using and , and each view is required to define them. Many include optional margins and borders.\n\nYou can specify width and height with exact measurements, but you might not want to do this often. More often, you use one of these constants to set the width or height:\n• : tells your view to size itself to the dimensions required by its content.\n• : tells your view to become as big as its parent view group allows.\n\nIn general, we don't recommend specifying a layout width and height using absolute units such as pixels. A better approach is using relative measurements, such as density-independent pixel units (dp), , or , because it helps your app display properly across a variety of device screen sizes. The accepted measurement types are defined in Layout resource.\n\nA view has rectangular geometry. It has a location, expressed as a pair of left and top coordinates, and two dimensions, expressed as a width and height. The unit for location and dimensions is the pixel.\n\nYou can retrieve the location of a view by invoking the methods and . The former returns the left (x) coordinate of the rectangle representing the view. The latter returns the top (y) coordinate of the rectangle representing the view. These methods return the location of the view relative to its parent. For example, when returns 20, this means the view is located 20 pixels to the right of the left edge of its direct parent.\n\nIn addition, there are convenience methods to avoid unnecessary computations: namely and . These methods return the coordinates of the right and bottom edges of the rectangle representing the view. For example, calling is similar to the following computation: .\n\nThe size of a view is expressed with a width and height. A view has two pairs of width and height values.\n\nThe first pair is known as measured width and measured height. These dimensions define how big a view wants to be within its parent. You can obtain the measured dimensions by calling and .\n\nThe second pair is known as width and height, or sometimes drawing width and drawing height. These dimensions define the actual size of the view on screen, at drawing time and after layout. These values might, but don't have to, differ from the measured width and height. You can obtain the width and height by calling and .\n\nTo measure its dimensions, a view takes into account its padding. The padding is expressed in pixels for the left, top, right and bottom parts of the view. You can use padding to offset the content of the view by a specific number of pixels. For instance, a left padding of two pushes the view's content two pixels to the right of the left edge. You can set padding using the method and query it by calling , , , and .\n\nAlthough a view can define a padding, it doesn't support margins. However, view groups do support margins. See and for more information.\n\nFor more information about dimensions, see Dimension.\n\nBesides setting margins and padding programmatically, you can also set them in your XML layouts, as shown in the following example:\n\nThe preceding example shows margin and padding being applied. The has uniform margins and padding applied all around, and the shows how you can apply them independently to different edges.\n\nEach subclass of the class provides a unique way to display the views you nest within it. The most flexible layout type, and the one that provides the best tools for keeping your layout hierarchy shallow, is .\n\nThe following are some of the common layout types built into the Android platform.\n\nWhen the content for your layout is dynamic or not pre-determined, you can use or a subclass of . is generally the better option, because it uses memory more efficiently than .\n\nCommon layouts possible with and include the following:\n\noffers more possibilities and the option to create a custom layout manager.\n\nYou can populate an such as or by binding the instance to an , which retrieves data from an external source and creates a that represents each data entry.\n\nAndroid provides several subclasses of that are useful for retrieving different kinds of data and building views for an . The two most common adapters are:\n\nIf during the course of your app's life you change the underlying data that is read by your adapter, call . This notifies the attached view that the data has been changed and it refreshes itself.\n\nYou can respond to click events on each item in an by implementing the interface. For example:\n\nSee how layouts are used in the Sunflower demo app on GitHub."
    },
    {
        "link": "https://stackoverflow.com/questions/7916527/android-using-layouts-as-a-template-for-creating-multiple-layout-instances",
        "document": "OK, So I understand how to use the include tag but I've run into a problem.\n\nBasically I want to have a layout defined in xml which has a couple of s and an in it. I then want to iterate across an array and populate fields within the xml layout depending on whats in an array(which is populated on runtime). Thus making multiple copies of the xml layout and populating the fields with unique data. Now i've got no idea how you can re-use this in this way as the s and s within it have a constant id and I need to make multiple copies of this layout.\n\nIs there any way to inflate a resource and then make a copy of it, that would work... So\n\n^ There is no constructor like that unfortunately.\n\nThe only other way is to do it all programatically but I would of preferred to have the properties of the views and the in xml rather than in the code. It's like I want the to be a template which you can make copies of I guess... Really not sure if that's possible."
    },
    {
        "link": "https://stackoverflow.com/questions/7407254/creating-xml-template-for-feed-list-items-in-android",
        "document": "Yes, every list item can be a custom layout. In fact you always have to define a layout for the list entries. You can either choose a prebuilt one from or you can use your own from . You can specify it when you create the list adapter in code.\n\nHave a look at one of the constructors for example:\n\nThe constructor takes a layout that will be used for the childs. Works similar with other adapters.\n\nWhat you usually do is inflating the layout inside of the adapter though. When you did that, fill all the data you need into the views of the layout, and return the view. Note that you get an argument called . This is one of the older layouts you already inflated before. In most cases the user just scrolled down and that entry is not visible anymore. If this convertView is not null, you can fill your data in there instead of inflating the whole layout again (thats expensive).\n\nYou can find a working example inside the\n\n file. Also take a look at the other list examples in that folder."
    },
    {
        "link": "https://developer.android.com/develop/ui/views/layout/improving-layouts/reusing-layouts",
        "document": "Although Android offers a variety of widgets to provide small, reusable, interactive elements, you might also need to reuse larger components that require a special layout. To efficiently reuse complete layouts, use the and tags to embed one layout inside another.\n\nThis lets you create complex layouts—such as a yes or no button panel or a custom progress bar with description text. And it means that you can extract any elements of your application that are common across multiple layouts, manage them separately, and include them in each layout. While you can create individual UI components by writing a custom , you can do it more easily by reusing a layout file.\n\nStart by creating a new XML file and defining the layout you want to be able to reuse. For example, here's a layout that defines a title bar to include in each activity ( ):\n\nThe root must be exactly how you want it to appear in each layout where you plan to add this layout.\n\nInside the layout where you want to add the reusable component, add the tag. For example, here's a layout that includes the title bar from the preceding example:\n\nYou can also override all the layout parameters—any attributes—of the included layout's root view by specifying them in the tag. This is shown in the following example:\n\nHowever, if you want to override layout attributes using the tag, also override and to make the other layout attributes take effect.\n\nThe tag helps eliminate redundant view groups in your view hierarchy when including one layout within another. One use case of is when you implement a custom view by extending a .\n\nFor example, if your main layout is a vertical in which two consecutive views can be reused in multiple layouts, then the reusable layout where you place the two views requires its own root view. However, using another as the root for the reusable layout results in a vertical inside a vertical . The nested serves no real purpose and slows down your UI performance.\n\nInstead, you can extend a to create a custom view and use a layout XML to describe its child views. The top tag in the XML is , rather than , as shown in the following example:\n\nWhen you include this layout in another layout—using the tag—the system ignores the element and places the two buttons directly in the layout, in place of the tag.\n\nFor more information about , see Layout resource."
    },
    {
        "link": "https://kotlinlang.org/docs/coding-conventions.html",
        "document": "Commonly known and easy-to-follow coding conventions are vital for any programming language. Here we provide guidelines on the code style and code organization for projects that use Kotlin.\n\nIn pure Kotlin projects, the recommended directory structure follows the package structure with the common root package omitted. For example, if all the code in the project is in the package and its subpackages, files with the package should be placed directly under the source root, and files in should be in the subdirectory of the source root. On JVM: In projects where Kotlin is used together with Java, Kotlin source files should reside in the same source root as the Java source files, and follow the same directory structure: each file should be stored in the directory corresponding to each package statement. If a Kotlin file contains a single class or interface (potentially with related top-level declarations), its name should be the same as the name of the class, with the extension appended. It applies to all types of classes and interfaces. If a file contains multiple classes, or only top-level declarations, choose a name describing what the file contains, and name the file accordingly. Use upper camel case, where the first letter of each word is capitalized. For example, . The name of the file should describe what the code in the file does. Therefore, you should avoid using meaningless words such as in file names. In multiplatform projects, files with top-level declarations in platform-specific source sets should have a suffix associated with the name of the source set. For example: As for the common source set, files with top-level declarations should not have a suffix. For example, . We recommend following this file naming scheme in multiplatform projects due to JVM limitations: it doesn't allow top-level members (functions, properties). To work around this, the Kotlin JVM compiler creates wrapper classes (so-called \"file facades\") that contain top-level member declarations. File facades have an internal name derived from the file name. In turn, JVM doesn't allow several classes with the same fully qualified name (FQN). This might lead to situations when a Kotlin project cannot be compiled to JVM: Here both files are in the same package, so the Kotlin JVM compiler produces two file facades, both of which have FQN . This produces the \"Duplicate JVM classes\" error. The simplest way to avoid that is renaming one of the files according to the guideline above. This naming scheme helps avoid clashes while retaining code readability. There are two scenarios where these recommendations may seem redundant, but we still advise to follow them:\n• None Non-JVM platforms don't have issues with duplicating file facades. However, this naming scheme can help you keep file naming consistent.\n• None On JVM, if source files don't have top-level declarations, the file facades aren't generated, and you won't face naming clashes. However, this naming scheme can help you avoid situations when a simple refactoring or an addition could include a top-level function and result in the same \"Duplicate JVM classes\" error. Placing multiple declarations (classes, top-level functions or properties) in the same Kotlin source file is encouraged as long as these declarations are closely related to each other semantically, and the file size remains reasonable (not exceeding a few hundred lines). In particular, when defining extension functions for a class which are relevant for all clients of this class, put them in the same file with the class itself. When defining extension functions that make sense only for a specific client, put them next to the code of that client. Avoid creating files just to hold all extensions of some class. The contents of a class should go in the following order: Do not sort the method declarations alphabetically or by visibility, and do not separate regular methods from extension methods. Instead, put related stuff together, so that someone reading the class from top to bottom can follow the logic of what's happening. Choose an order (either higher-level stuff first, or vice versa) and stick to it. Put nested classes next to the code that uses those classes. If the classes are intended to be used externally and aren't referenced inside the class, put them in the end, after the companion object. When implementing an interface, keep the implementing members in the same order as members of the interface (if necessary, interspersed with additional private methods used for the implementation). Always put overloads next to each other in a class.\n\nPackage and class naming rules in Kotlin are quite simple:\n• None Names of packages are always lowercase and do not use underscores ( ). Using multi-word names is generally discouraged, but if you do need to use multiple words, you can either just concatenate them together or use camel case ( ).\n• None Names of classes and objects use upper camel case: Names of functions, properties and local variables start with a lowercase letter and use camel case with no underscores: Exception: factory functions used to create instances of classes can have the same name as the abstract return type: In tests (and only in tests), you can use method names with spaces enclosed in backticks. Note that such method names are only supported by Android runtime from API level 30. Underscores in method names are also allowed in test code. Names of constants (properties marked with , or top-level or object properties with no custom function that hold deeply immutable data) should use all uppercase, underscore-separated names following the (screaming snake case) convention: Names of top-level or object properties which hold objects with behavior or mutable data should use camel case names: Names of properties holding references to singleton objects can use the same naming style as declarations: For enum constants, it's OK to use either all uppercase, underscore-separated (screaming snake case) names ( ) or upper camel case names, depending on the usage. If a class has two properties which are conceptually the same but one is part of a public API and another is an implementation detail, use an underscore as the prefix for the name of the private property: The name of a class is usually a noun or a noun phrase explaining what the class is: , . The name of a method is usually a verb or a verb phrase saying what the method does: , . The name should also suggest if the method is mutating the object or returning a new one. For instance is sorting a collection in place, while is returning a sorted copy of the collection. The names should make it clear what the purpose of the entity is, so it's best to avoid using meaningless words ( , ) in names. When using an acronym as part of a declaration name, follow these rules:\n• None For two-letter acronyms, use uppercase for both letters. For example, .\n• None For acronyms longer than two letters, capitalize only the first letter. For example, or .\n\nUse four spaces for indentation. Do not use tabs. For curly braces, put the opening brace at the end of the line where the construct begins, and the closing brace on a separate line aligned horizontally with the opening construct. if (elements != null) { for (element in elements) { // ... } } In Kotlin, semicolons are optional, and therefore line breaks are significant. The language design assumes Java-style braces, and you may encounter surprising behavior if you try to use a different formatting style.\n• None Put spaces around binary operators ( ). Exception: don't put spaces around the \"range to\" operator ( ).\n• None Do not put spaces around unary operators ( ).\n• None Put spaces between control flow keywords ( , , , and ) and the corresponding opening parenthesis.\n• None Do not put a space before an opening parenthesis in a primary constructor declaration, method declaration or method call.\n• None Never put a space after , , or before , .\n• None Never put a space around or : , .\n• None Do not put spaces around angle brackets used to specify type parameters: .\n• None Do not put spaces around : , .\n• None Do not put a space before used to mark a nullable type: . As a general rule, avoid horizontal alignment of any kind. Renaming an identifier to a name with a different length should not affect the formatting of either the declaration or any of the usages. Put a space before in the following scenarios:\n• None When it's used to separate a type and a supertype.\n• None When delegating to a superclass constructor or a different constructor of the same class. Don't put a space before when it separates a declaration and its type. Classes with a few primary constructor parameters can be written in a single line: Classes with longer headers should be formatted so that each primary constructor parameter is in a separate line with indentation. Also, the closing parenthesis should be on a new line. If you use inheritance, the superclass constructor call, or the list of implemented interfaces should be located on the same line as the parenthesis: For multiple interfaces, the superclass constructor call should be located first and then each interface should be located in a different line: For classes with a long supertype list, put a line break after the colon and align all supertype names horizontally: To clearly separate the class header and body when the class header is long, either put a blank line following the class header (as in the example above), or put the opening curly brace on a separate line: Use regular indent (four spaces) for constructor parameters. This ensures that properties declared in the primary constructor have the same indentation as properties declared in the body of a class. If a declaration has multiple modifiers, always put them in the following order: public / protected / private / internal expect / actual final / open / abstract / sealed / const external override lateinit tailrec vararg suspend inner enum / annotation / fun // as a modifier in `fun interface` companion inline / value infix operator data Unless you're working on a library, omit redundant modifiers (for example, ). Place annotations on separate lines before the declaration to which they are attached, and with the same indentation: Annotations without arguments may be placed on the same line: A single annotation without arguments may be placed on the same line as the corresponding declaration: File annotations are placed after the file comment (if any), before the statement, and are separated from with a blank line (to emphasize the fact that they target the file and not the package). If the function signature doesn't fit on a single line, use the following syntax: Use regular indent (four spaces) for function parameters. It helps ensure consistency with constructor parameters. Prefer using an expression body for functions with the body consisting of a single expression. If the function has an expression body whose first line doesn't fit on the same line as the declaration, put the sign on the first line and indent the expression body by four spaces. For very simple read-only properties, consider one-line formatting: For more complex properties, always put and keywords on separate lines: For properties with an initializer, if the initializer is long, add a line break after the sign and indent the initializer by four spaces: If the condition of an or statement is multiline, always use curly braces around the body of the statement. Indent each subsequent line of the condition by four spaces relative to the statement start. Put the closing parentheses of the condition together with the opening curly brace on a separate line: This helps align the condition and statement bodies. Put the , , keywords, as well as the keyword of a loop, on the same line as the preceding curly brace: if (condition) { // body } else { // else part } try { // body } finally { // cleanup } In a statement, if a branch is more than a single line, consider separating it from adjacent case blocks with a blank line: Put short branches on the same line as the condition, without braces. In long argument lists, put a line break after the opening parenthesis. Indent arguments by four spaces. Group multiple closely related arguments on the same line. Put spaces around the sign separating the argument name and value. When wrapping chained calls, put the character or the operator on the next line, with a single indent: val anchor = owner ?.firstChild!! .siblings(forward = true) .dropWhile { it is PsiComment || it is PsiWhiteSpace } The first call in the chain should usually have a line break before it, but it's OK to omit it if the code makes more sense that way. In lambda expressions, spaces should be used around the curly braces, as well as around the arrow which separates the parameters from the body. If a call takes a single lambda, pass it outside parentheses whenever possible. If assigning a label for a lambda, do not put a space between the label and the opening curly brace: When declaring parameter names in a multiline lambda, put the names on the first line, followed by the arrow and the newline: If the parameter list is too long to fit on a line, put the arrow on a separate line: A trailing comma is a comma symbol after the last item in a series of elements: Using trailing commas has several benefits:\n• None It makes version-control diffs cleaner – as all the focus is on the changed value.\n• None It makes it easy to add and reorder elements – there is no need to add or delete the comma if you manipulate elements.\n• None It simplifies code generation, for example, for object initializers. The last element can also have a comma. Trailing commas are entirely optional – your code will still work without them. The Kotlin style guide encourages the use of trailing commas at the declaration site and leaves it at your discretion for the call site. To enable trailing commas in the IntelliJ IDEA formatter, go to Settings/Preferences | Editor | Code Style | Kotlin, open the Other tab and select the Use trailing comma option.\n\nFor longer documentation comments, place the opening on a separate line and begin each subsequent line with an asterisk: /** * This is a documentation comment * on multiple lines. */ Short comments can be placed on a single line: Generally, avoid using and tags. Instead, incorporate the description of parameters and return values directly into the documentation comment, and add links to parameters wherever they are mentioned. Use and only when a lengthy description is required which doesn't fit into the flow of the main text. // Avoid doing this: /** * Returns the absolute value of the given number. * @param number The number to return the absolute value for. * @return The absolute value. */ fun abs(number: Int): Int { /*...*/ } // Do this instead: /** * Returns the absolute value of the given [number]. */ fun abs(number: Int): Int { /*...*/ }\n\nPrefer using immutable data to mutable. Always declare local variables and properties as rather than if they are not modified after initialization. Always use immutable collection interfaces ( , , , ) to declare collections which are not mutated. When using factory functions to create collection instances, always use functions that return immutable collection types when possible: // Bad: use of a mutable collection type for value which will not be mutated fun validateValue(actualValue: String, allowedValues: HashSet<String>) { ... } // Good: immutable collection type used instead fun validateValue(actualValue: String, allowedValues: Set<String>) { ... } // Bad: arrayListOf() returns ArrayList<T>, which is a mutable collection type val allowedValues = arrayListOf(\"a\", \"b\", \"c\") // Good: listOf() returns List<T> val allowedValues = listOf(\"a\", \"b\", \"c\") If you have a functional type or a type with type parameters which is used multiple times in a codebase, prefer defining a type alias for it: If you use a private or internal type alias for avoiding name collision, prefer the mentioned in Packages and Imports. In lambdas which are short and not nested, it's recommended to use the convention instead of declaring the parameter explicitly. In nested lambdas with parameters, always declare parameters explicitly. Avoid using multiple labeled returns in a lambda. Consider restructuring the lambda so that it will have a single exit point. If that's not possible or not clear enough, consider converting the lambda into an anonymous function. Do not use a labeled return for the last statement in a lambda. Use the named argument syntax when a method takes multiple parameters of the same primitive type, or for parameters of type, unless the meaning of all parameters is absolutely clear from context. Prefer using the expression form of , , and . The above is preferable to: Prefer using for binary conditions instead of . For example, use this syntax with : Instead of this one with : Prefer using if there are three or more options. Use parentheses when combining multiple boolean expressions in expressions or statements with guard conditions: when (status) { is Status.Ok if (status.info.isEmpty() || status.info.id == null) -> \"no information\" } when (status) { is Status.Ok if status.info.isEmpty() || status.info.id == null -> \"no information\" } If you need to use a nullable in a conditional statement, use or checks. Prefer using higher-order functions ( , etc.) to loops. Exception: (prefer using a regular loop instead, unless the receiver of is nullable or is used as part of a longer call chain). When making a choice between a complex expression using multiple higher-order functions and a loop, understand the cost of the operations being performed in each case and keep performance considerations in mind. Use the operator to loop over an open-ended range: for (i in 0..n - 1) { /*...*/ } // bad for (i in 0..<n) { /*...*/ } // good To maintain indentation in multiline strings, use when the resulting string does not require any internal indentation, or when internal indentation is required: Learn the difference between Java and Kotlin multiline strings. In some scenarios, functions with no arguments might be interchangeable with read-only properties. Although the semantics are similar, there are some stylistic conventions on when to prefer one to another. Prefer a property over a function when the underlying algorithm:\n• None Is cheap to calculate (or cached on the first run).\n• None Returns the same result over invocations if the object state hasn't changed. Use extension functions liberally. Every time you have a function that works primarily on an object, consider making it an extension function accepting that object as a receiver. To minimize API pollution, restrict the visibility of extension functions as much as it makes sense. As necessary, use local extension functions, member extension functions, or top-level extension functions with private visibility. Declare a function as only when it works on two objects which play a similar role. Good examples: , , . Bad example: . Do not declare a method as if it mutates the receiver object. If you declare a factory function for a class, avoid giving it the same name as the class itself. Prefer using a distinct name, making it clear why the behavior of the factory function is special. Only if there is really no special semantics, you can use the same name as the class. If you have an object with multiple overloaded constructors that don't call different superclass constructors and can't be reduced to a single constructor with default argument values, prefer to replace the overloaded constructors with factory functions. A public function/method returning an expression of a platform type must declare its Kotlin type explicitly: Any property (package-level or class-level) initialized with an expression of a platform type must declare its Kotlin type explicitly: A local value initialized with an expression of a platform type may or may not have a type declaration: Kotlin provides a set of functions to execute a block of code in the context of a given object: , , , , and . For the guidance on choosing the right scope function for your case, refer to Scope Functions."
    },
    {
        "link": "https://developer.android.com/develop/ui/views/layout/relative",
        "document": "is a view group that displays child views in relative positions. The position of each view can be specified as relative to sibling elements (such as to the left-of or below another view) or in positions relative to the parent area (such as aligned to the bottom, left or center).\n\nNote: For better performance and tooling support, you should instead build your layout with ConstraintLayout.\n\nA is a very powerful utility for designing a user interface because it can eliminate nested view groups and keep your layout hierarchy flat, which improves performance. If you find yourself using several nested groups, you may be able to replace them with a single .\n\nlets child views specify their position relative to the parent view or to each other (specified by ID). So you can align two elements by right border, or make one below another, centered in the screen, centered left, and so on. By default, all child views are drawn at the top-left of the layout, so you must define the position of each view using the various layout properties available from .\n\nSome of the many layout properties available to views in a include:\n\nThese are just a few examples. All layout attributes are documented at .\n\nThe value for each layout property is either a boolean to enable a layout position relative to the parent or an ID that references another view in the layout against which the view should be positioned.\n\nIn your XML layout, dependencies against other views in the layout can be declared in any order. For example, you can declare that \"view1\" be positioned below \"view2\" even if \"view2\" is the last view declared in the hierarchy. The example below demonstrates such a scenario.\n\nEach of the attributes that control the relative position of each view are emphasized.\n\nFor details about all the layout attributes available to each child view of a , see ."
    },
    {
        "link": "https://developer.android.com/reference/android/widget/RelativeLayout",
        "document": ""
    },
    {
        "link": "https://geeksforgeeks.org/android-relativelayout-in-kotlin",
        "document": "RelativeLayout in Android is a ViewGroup subclass, that allows users to position child views relative to each other (e.g., view A to the right of view B) or relative to the parent (e.g., aligned to the top of the parent). Instead of using LinearLayout, we have to use RelativeLayout to design the user interface and keep our hierarchy flat because it improves the performance of the application. Unlike LinearLayout, which stacks the views in a particular direction, RelativeLayout allows more flexibility and dynamic UIs while maintaining a flat view hierarchy. This improves performance of the app.\n\nImportant Attributes for Positioning Views in the RelativeLayout\n\nAs we know, we need to define the position of child views or ViewGroups relative to each other element or relative to the parent. By default position is top-left, if someone forgets to specify the position of child views.\n\nSet “true” to match the left edge of view to the left edge of parent. Set “true” to match the right edge of view to the right edge of the parent. Set to “true” to match the top edge of the view to the top edge of the parent. Set to “true” to match the bottom edge of the view to the bottom edge of the parent. It accepts another sibling view ID and Align the view to the left of the specified view ID. It accepts another sibling view ID and Align the view to the right of the specified view ID. It accepts another sibling view ID and Align the view to the start of the specified view ID. It accepts another sibling view ID and Align the view to the end of the specified view ID. When it is set to “true”, the view will be aligned to the center of parent. When it is set to “true”, the view will be horizontally centre-aligned within its parent. When it is set to “true”, the view will be vertically centre-aligned within its parent. It accepts another sibling view ID and places the view left of the specified view ID. It accepts another sibling view ID and places the view right of the specified view ID. It accepts another sibling view ID and places the view to start of the specified view ID. It accepts another sibling view ID and places the view to end of the specified view ID. It accepts another sibling view ID and places the view above the specified view ID. It accepts another sibling view ID and places the view below the specified view ID.\n\nHow to Declare RelativeLayout in XML file?\n\nHere’s an example of how to declare a RelativeLayout in an XML file:\n\nExample of Application using Relative Layout\n\nLet’s create a application accepting first and last name of a person. Before moving to MainActivity.kt , we will first create a layout of application using Relative Layout.\n\nFollowing is a sample code for RelativeLayout in xml file which includes two TextView(s), two EditText(s) and a Button.\n\nHere’s a view of the design and blueprint in the design layout:\n\nWhen the layout is created, you can access the UI elements from the activity_main.xml file by using the findViewById() method in the onCreate() call back function in the MainActivity.kt file.\n\nAfter running the application, this is the expected result from the above code:\n\nClick Here to Learn More about Android Kotlin Application"
    },
    {
        "link": "https://github.com/MicrosoftDocs/xamarin-docs/blob/live/docs/android/user-interface/layouts/relative-layout.md",
        "document": "is a that displays child elements in relative positions. The position of a can be specified as relative to sibling elements (such as to the left-of or below a given element) or in positions relative to the area (such as aligned to the bottom, left of center).\n\nA is a very powerful utility for designing a user interface because it can eliminate nested s. If you find yourself using several nested groups, you may be able to replace them with a single .\n\nOpen the Resources/Layout/Main.axml file and insert the following:\n\nNotice each of the attributes, such as , , and . When using a , you can use these attributes to describe how you want to position each . Each one of these attributes define a different kind of relative position. Some attributes use the resource ID of a sibling to define its own relative position. For example, the last is defined to lie to the left-of and aligned-with-the-top-of the identified by the ID (which is the previous ).\n\nAll of the available layout attributes are defined in .\n\nMake sure you load this layout in the method:\n\nThe method loads the layout file for the , specified by the resource ID — refers to the Resources/Layout/Main.axml layout file.\n\nRun the application. You should see the following layout:\n\nPortions of this page are modifications based on work created and shared by the Android Open Source Project and used according to terms described in the Creative Commons 2.5 Attribution License."
    },
    {
        "link": "https://developer.android.com/studio/write/tool-attributes",
        "document": "Stay organized with collections Save and categorize content based on your preferences.\n\nAndroid Studio supports a variety of XML attributes in the namespace that enable design-time features, such as which layout to show in a fragment, or compile-time behaviors, such as which shrinking mode to apply to your XML resources. When you build your app, the build tools remove these attributes so that there is no effect on your APK size or runtime behavior.\n\nTo use these attributes, add the namespace to the root element of each XML file where you'd like to use them, as shown here:\n\nThe following attributes help suppress lint warning messages:\n\nThis attribute accepts a comma-separated list of lint issue IDs that you'd like the tools to ignore on this element or any of its descendants.\n\nFor example, you can tell the tools to ignore the error:\n\nThis attribute works the same as the annotation in Java code. It lets you specify the API level (either as an integer or as a code name) that supports this element.\n\nThis tells the tools that you believe this element and any children are used only on the specified API level or higher. This stops lint from warning you if that element or its attributes are not available on the API level you specify as your .\n\nFor example, you might use this attribute because is only available on API level 14 and higher, but you know this layout is not used in your code for any lower versions:\n\nThis tells the tools what the default language or locale is for the resources in the given element to avoid warnings from the spellchecker. The tool otherwise assumes the language is English.\n\nThe value must be a valid locale qualifier.\n\nFor example, you can add this to your default file to indicate that the language used for the default strings is Spanish rather than English:\n\nThe following attributes define layout characteristics that are visible only in the Android Studio layout preview.\n\nYou can insert sample data in your layout preview by using the prefix instead of with any attribute from the Android framework. This is useful when the attribute's value isn't populated until runtime and you want to see the effect in the layout preview.\n\nFor example, if the attribute value is set at runtime, or you want to see the layout with a value different than the default, you can add to specify some text for the layout preview only.\n\nYou can add both the namespace attribute, which is used at runtime, and the matching attribute, which overrides the runtime attribute in the layout preview only.\n\nYou can also use a attribute to undo an attribute setting for the layout preview only. For example, if you have a with two children but you want to see only one child in the layout preview, you can set one of them to be invisible in the layout preview, as shown here:\n\nWhen using the Layout Editor in design view, the Properties window lets you edit some design-time view attributes. Each design-time attribute is indicated with a wrench icon next to the attribute name to distinguish it from the real attribute of the same name.\n\nThis attribute declares which activity this layout is associated with by default. This enables features in the editor or layout preview that require knowledge of the activity, such as what the layout theme is in the preview and where to insert handlers generated from a quickfix, as shown in figure 2.\n\nYou can specify the activity class name using the same dot prefix as in the manifest file (excluding the full package name).\n\nFor a given , this attribute specifies the number of items the Layout Editor should render in the Preview window.\n\nThis attribute declares which layout you want the layout preview to draw inside the fragment because the layout preview can't execute the activity code that normally applies the layout.\n\nIntended for: (and subclasses like )\n\nThese attributes specify which layout to show in the layout preview for a list's items, header, and footer. Any data fields in the layout are filled with numeric contents, such as \"Item 1,\" so that the list items are not repetitive.\n\nIntended for: Any root in a layout that's referred to by an\n\nThis attribute lets you point to a layout that uses this layout using , so you can preview and edit this file as it appears while embedded in its parent layout.\n\nNow the layout preview shows this layout as it appears inside the layout.\n\nThis attribute specifies which menu the layout preview shows in the app bar. The value is one or more menu IDs, separated by commas, without or any such ID prefix and without the extension.\n\nThese attributes set minimum and maximum values for a view.\n\nThis attribute lets you open a in the preview.\n\nYou can also modify how the Layout Editor renders the layout by passing one of the following values:\n\nTable 1. Values to modify how the Layout Editor renders a\n\nIntended for: Any view that supports UI text or images\n\nThis attribute lets you inject placeholder data or images into your view. For example, to test how your layout behaves with text before you have finalized UI text for your app, you can use placeholder text as follows:\n\nThe following table describes the types of placeholder data you can inject into your layouts:\n\nThe following attributes let you enable strict reference checks and declare whether to keep or discard certain resources when using resource shrinking.\n\nTo enable resource shrinking, set the property to in your file, alongside for code shrinking.\n\nUsed by: Build tools with resource shrinking\n\nThis attribute lets you specify whether the build tools should use the following:\n• Safe mode: Keep all resources that are explicitly cited and that might be referenced dynamically with a call to .\n• Strict mode: Keep only the resources that are explicitly cited in code or in other resources.\n\nThe default is to use safe mode ( ). To instead use strict mode, add to the tag as shown here:\n\nWhen you enable strict mode, you might need to use to keep resources that were removed but that you actually want, and use to explicitly remove even more resources.\n\nFor more information, see Shrink your resources.\n\nUsed by: Build tools with resource shrinking\n\nWhen using resource shrinking to remove unused resources, this attribute lets you specify resources to keep, typically because they are referenced in an indirect way at runtime, such as by passing a dynamically generated resource name to .\n\nTo use, create an XML file in your resources directory (for example, ) with a tag and specify each resource to keep in the attribute as a comma-separated list. You can use the asterisk character as a wild card.\n\nFor more information, see Shrink your resources.\n\nUsed by: Build tools with resource shrinking\n\nWhen using resource shrinking to remove unused resources, this attribute lets you specify resources you want to manually discard, typically because the resource is referenced but in a way that does not affect your app or because the Gradle plugin has incorrectly deduced that the resource is referenced.\n\nTo use, create an XML file in your resources directory (for example, ) with a tag and specify each resource to discard in the attribute as a comma-separated list. You can use the asterisk character as a wild card.\n\nFor more information, see Shrink your resources."
    }
]