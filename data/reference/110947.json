[
    {
        "link": "https://docs.python-telegram-bot.org",
        "document": "We have made you a wrapper you can’t refuse\n\nWe have a vibrant community of developers helping each other in our Telegram group. Join us!\n\nStay tuned for library updates and new releases on our Telegram Channel.\n\nYou can install or upgrade via To install a pre-release, use the flag in addition. You can also install from source, though this is usually not necessary. To enable you to verify that a release file that you downloaded was indeed provided by the team, we have taken the following measures. Starting with v21.4, all releases are signed via sigstore. The corresponding signature files are uploaded to the GitHub releases page. To verify the signature, please install the sigstore Python client and follow the instructions for verifying signatures from GitHub Actions. As input for the parameter, please use the value . Earlier releases are signed with a GPG key. The signatures are uploaded to both the GitHub releases page and the PyPI project and end with a suffix . Please find the public keys here. The keys are named in the format . In addition, the GitHub release page also contains the sha1 hashes of the release files in the files with the suffix . tries to use as few 3rd party dependencies as possible. However, for some features using a 3rd party library is more sane than implementing the functionality again. As these features are optional, the corresponding 3rd party dependencies are not installed by default. Instead, they are listed as optional dependencies. This allows to avoid unnecessary dependency conflicts for users who don’t need the optional features. The only required dependency is httpx ~= 0.27 for , the default networking backend. is most useful when used along with additional libraries. To minimize dependency conflicts, we try to be liberal in terms of version requirements on the (optional) dependencies. On the other hand, we have to ensure stability of , which is why we do apply version bounds. If you encounter dependency conflicts due to these bounds, feel free to reach out. PTB can be installed with optional dependencies:\n• None installs the cryptography>=39.0.1 library. Use this, if you want to use Telegram Passport related functionality.\n• None installs httpx[socks]. Use this, if you want to work behind a Socks5 server.\n• None installs httpx[http2]. Use this, if you want to use HTTP/2.\n• None installs aiolimiter~=1.1,<1.3. Use this, if you want to use .\n• None installs the tornado~=6.4 library. Use this, if you want to use / .\n• None installs the cachetools>=5.3.3,<5.6.0 library. Use this, if you want to use arbitrary callback_data.\n• None installs the APScheduler>=3.10.4,<3.12.0 library. Use this, if you want to use the . To install multiple optional dependencies, separate them by commas, e.g. .\n• None installs all optional dependencies that are related to , i.e. .\n\nOnce you have installed the library, you can begin working with it - so let’s get started! Our Wiki contains an Introduction to the API explaining how the pure Bot API can be accessed via . Moreover, the Tutorial: Your first Bot gives an introduction on how chatbots can be easily programmed with the help of the module.\n• None The package documentation is the technical reference for . It contains descriptions of all available classes, modules, methods and arguments as well as the changelog.\n• None The wiki is home to number of more elaborate introductions of the different features of and other useful resources that go beyond the technical documentation.\n• None Our examples section contains several examples that showcase the different features of both the Bot API and . Even if it is not your approach for learning, please take a look at . It is the de facto base for most of the bots out there. The code for these examples is released to the public domain, so you can start by grabbing the code and building on top of it.\n• None The official Telegram Bot API documentation is of course always worth a read. If the resources mentioned above don’t answer your questions or simply overwhelm you, there are several ways of getting help.\n• None We have a vibrant community of developers helping each other in our Telegram group. Join us! Asking a question here is often the quickest way to get a pointer in the right direction.\n• None You can even ask for help on Stack Overflow using the python-telegram-bot tag. Since v20.0, is built on top of Pythons module. Because is in general single-threaded, does currently not aim to be thread-safe. Noteworthy parts of API that are likely to cause issues (e.g. race conditions) when used in a multi-threaded setting include:\n• None all classes in the module that allow to add/remove allowed users/chats at runtime\n\nOccasionally we are asked if we accept donations to support the development. While we appreciate the thought, maintaining PTB is our hobby, and we have almost no running costs for it. We therefore have nothing set up to accept donations. If you still want to donate, we kindly ask you to donate to another open source project/initiative of your choice instead.\n\nYou may copy, distribute and modify the software provided that modifications are described and licensed for free under LGPL-3. Derivative works (including modifications or anything statically linked to the library) can only be redistributed under LGPL-3, but applications that use the library don’t have to be."
    },
    {
        "link": "https://python-telegram-bot.readthedocs.io/en/v20.0a0/index.html",
        "document": ""
    },
    {
        "link": "https://pypi.org/project/python-telegram-bot",
        "document": "A required part of this site couldn’t load. This may be due to a browser extension, network issues, or browser settings. Please check your connection, disable any ad blockers, or try using a different browser."
    },
    {
        "link": "https://github.com/python-telegram-bot/python-telegram-bot",
        "document": "We have made you a wrapper you can't refuse\n\nWe have a vibrant community of developers helping each other in our Telegram group. Join us!\n\nStay tuned for library updates and new releases on our Telegram Channel.\n\nThis library provides a pure Python, asynchronous interface for the Telegram Bot API. It's compatible with Python versions 3.9+.\n\nIn addition to the pure API implementation, this library features several convenience methods and shortcuts as well as a number of high-level classes to make the development of bots easy and straightforward. These classes are contained in the submodule.\n\nAfter installing the library, be sure to check out the section on working with PTB.\n\nAll types and methods of the Telegram Bot API 8.3 are natively supported by this library. In addition, Bot API functionality not yet natively included can still be used as described in our wiki.\n\nYou can install or upgrade via\n\nTo install a pre-release, use the flag in addition.\n\nYou can also install from source, though this is usually not necessary.\n\nTo enable you to verify that a release file that you downloaded was indeed provided by the team, we have taken the following measures.\n\nStarting with v21.4, all releases are signed via sigstore. The corresponding signature files are uploaded to the GitHub releases page. To verify the signature, please install the sigstore Python client and follow the instructions for verifying signatures from GitHub Actions. As input for the parameter, please use the value .\n\nEarlier releases are signed with a GPG key. The signatures are uploaded to both the GitHub releases page and the PyPI project and end with a suffix . Please find the public keys here. The keys are named in the format .\n\nIn addition, the GitHub release page also contains the sha1 hashes of the release files in the files with the suffix .\n\ntries to use as few 3rd party dependencies as possible. However, for some features using a 3rd party library is more sane than implementing the functionality again. As these features are optional, the corresponding 3rd party dependencies are not installed by default. Instead, they are listed as optional dependencies. This allows to avoid unnecessary dependency conflicts for users who don't need the optional features.\n\nThe only required dependency is httpx ~= 0.27 for , the default networking backend.\n\nis most useful when used along with additional libraries. To minimize dependency conflicts, we try to be liberal in terms of version requirements on the (optional) dependencies. On the other hand, we have to ensure stability of , which is why we do apply version bounds. If you encounter dependency conflicts due to these bounds, feel free to reach out.\n\nPTB can be installed with optional dependencies:\n• installs the cryptography>=39.0.1 library. Use this, if you want to use Telegram Passport related functionality.\n• installs httpx[socks]. Use this, if you want to work behind a Socks5 server.\n• installs httpx[http2]. Use this, if you want to use HTTP/2.\n• installs aiolimiter~=1.1,<1.3. Use this, if you want to use .\n• installs the tornado~=6.4 library. Use this, if you want to use / .\n• installs the cachetools>=5.3.3,<5.6.0 library. Use this, if you want to use arbitrary callback_data.\n• installs the APScheduler>=3.10.4,<3.12.0 library. Use this, if you want to use the .\n\nTo install multiple optional dependencies, separate them by commas, e.g. .\n• installs all optional dependencies that are related to , i.e. .\n\nOnce you have installed the library, you can begin working with it - so let's get started!\n\nOur Wiki contains an Introduction to the API explaining how the pure Bot API can be accessed via . Moreover, the Tutorial: Your first Bot gives an introduction on how chatbots can be easily programmed with the help of the module.\n• The package documentation is the technical reference for . It contains descriptions of all available classes, modules, methods and arguments as well as the changelog.\n• The wiki is home to number of more elaborate introductions of the different features of and other useful resources that go beyond the technical documentation.\n• Our examples section contains several examples that showcase the different features of both the Bot API and . Even if it is not your approach for learning, please take a look at . It is the de facto base for most of the bots out there. The code for these examples is released to the public domain, so you can start by grabbing the code and building on top of it.\n• The official Telegram Bot API documentation is of course always worth a read.\n\nIf the resources mentioned above don't answer your questions or simply overwhelm you, there are several ways of getting help.\n• We have a vibrant community of developers helping each other in our Telegram group. Join us! Asking a question here is often the quickest way to get a pointer in the right direction.\n• You can even ask for help on Stack Overflow using the python-telegram-bot tag.\n\nSince v20.0, is built on top of Pythons module. Because is in general single-threaded, does currently not aim to be thread-safe. Noteworthy parts of API that are likely to cause issues (e.g. race conditions) when used in a multi-threaded setting include:\n• all classes in the module that allow to add/remove allowed users/chats at runtime\n\nContributions of all sizes are welcome. Please review our contribution guidelines to get started. You can also help by reporting bugs or feature requests.\n\nOccasionally we are asked if we accept donations to support the development. While we appreciate the thought, maintaining PTB is our hobby, and we have almost no running costs for it. We therefore have nothing set up to accept donations. If you still want to donate, we kindly ask you to donate to another open source project/initiative of your choice instead.\n\nYou may copy, distribute and modify the software provided that modifications are described and licensed for free under LGPL-3. Derivative works (including modifications or anything statically linked to the library) can only be redistributed under LGPL-3, but applications that use the library don't have to be."
    },
    {
        "link": "https://docs.python-telegram-bot.org/en/v12.0.0",
        "document": "If you’re just starting out with the library, we recommend following our “Your first Bot” tutorial that you can find on our wiki. On our wiki you will also find guides like how to use handlers, webhooks, emoji, proxies and much more.\n\nA great way to learn is by looking at examples. Ours can be found at our github in the examples folder."
    },
    {
        "link": "https://docs.python.org/3/library/sqlite3.html",
        "document": "SQLite is a C library that provides a lightweight disk-based database that doesn’t require a separate server process and allows accessing the database using a nonstandard variant of the SQL query language. Some applications can use SQLite for internal data storage. It’s also possible to prototype an application using SQLite and then port the code to a larger database such as PostgreSQL or Oracle.\n\nThe module was written by Gerhard Häring. It provides an SQL interface compliant with the DB-API 2.0 specification described by PEP 249, and requires SQLite 3.15.2 or newer.\n• None Tutorial teaches how to use the module.\n• None Reference describes the classes and functions this module defines.\n\nHow to use placeholders to bind values in SQL queries¶ SQL operations usually need to use values from Python variables. However, beware of using Python’s string operations to assemble queries, as they are vulnerable to SQL injection attacks. For example, an attacker can simply close the single quote and inject to select all rows: # Never do this -- insecure! SELECT * FROM stocks WHERE symbol = '' OR TRUE; --' Instead, use the DB-API’s parameter substitution. To insert a variable into a query string, use a placeholder in the string, and substitute the actual values into the query by providing them as a of values to the second argument of the cursor’s method. An SQL statement may use one of two kinds of placeholders: question marks (qmark style) or named placeholders (named style). For the qmark style, parameters must be a sequence whose length must match the number of placeholders, or a is raised. For the named style, parameters must be an instance of a (or a subclass), which must contain keys for all named parameters; any extra items are ignored. Here’s an example of both styles: # This is the named style used with executemany(): # This is the qmark style used in a SELECT query: PEP 249 numeric placeholders are not supported. If used, they will be interpreted as named placeholders. How to adapt custom Python types to SQLite values¶ SQLite supports only a limited set of data types natively. To store custom Python types in SQLite databases, adapt them to one of the Python types SQLite natively understands. There are two ways to adapt Python objects to SQLite types: letting your object adapt itself, or using an adapter callable. The latter will take precedence above the former. For a library that exports a custom type, it may make sense to enable that type to adapt itself. As an application developer, it may make more sense to take direct control by registering custom adapter functions. Suppose we have a class that represents a pair of coordinates, and , in a Cartesian coordinate system. The coordinate pair will be stored as a text string in the database, using a semicolon to separate the coordinates. This can be implemented by adding a method which returns the adapted value. The object passed to protocol will be of type . The other possibility is to create a function that converts the Python object to an SQLite-compatible type. This function can then be registered using . How to convert SQLite values to custom Python types¶ Writing an adapter lets you convert from custom Python types to SQLite values. To be able to convert from SQLite values to custom Python types, we use converters. Let’s go back to the class. We stored the x and y coordinates separated via semicolons as strings in SQLite. First, we’ll define a converter function that accepts the string as a parameter and constructs a object from it. Converter functions are always passed a object, no matter the underlying SQLite data type. We now need to tell when it should convert a given SQLite value. This is done when connecting to a database, using the detect_types parameter of . There are three options:\n• None Both: set detect_types to . Column names take precedence over declared types. The following example illustrates the implicit and explicit approaches: This section shows recipes for common adapters and converters. How to use connection shortcut methods¶ Using the , , and methods of the class, your code can be written more concisely because you don’t have to create the (often superfluous) objects explicitly. Instead, the objects are created implicitly and these shortcut methods return the cursor objects. This way, you can execute a statement and iterate over it directly using only a single call on the object. # close() is not a shortcut method and it's not called automatically; # the connection object should be closed manually How to use the connection context manager¶ A object can be used as a context manager that automatically commits or rolls back open transactions when leaving the body of the context manager. If the body of the statement finishes without exceptions, the transaction is committed. If this commit fails, or if the body of the statement raises an uncaught exception, the transaction is rolled back. If is , a new transaction is implicitly opened after committing or rolling back. If there is no open transaction upon leaving the body of the statement, or if is , the context manager does nothing. The context manager neither implicitly opens a new transaction nor closes the connection. If you need a closing context manager, consider using . # con.rollback() is called after the with block finishes with an exception, # the exception is still raised and must be caught # Connection object used as context manager only commits or rollbacks transactions, # so the connection object should be closed manually How to work with SQLite URIs¶\n• None Do not implicitly create a new database file if it does not already exist; will raise if unable to create a new file: More information about this feature, including a list of parameters, can be found in the SQLite URI documentation. How to create and use row factories¶ By default, represents each row as a . If a does not suit your needs, you can use the class or a custom . While exists as an attribute both on the and the , it is recommended to set , so all cursors created from the connection will use the same row factory. provides indexed and case-insensitive named access to columns, with minimal memory overhead and performance impact over a . To use as a row factory, assign it to the attribute: \"SELECT 'Earth' AS name, 6378 AS radius\" The clause can be omitted in the statement, as in the above example. In such cases, SQLite returns a single row with columns defined by expressions, e.g. literals, with the given aliases . You can create a custom that returns each row as a , with column names mapped to values: Using it, queries now return a instead of a : can be used as follows: With some adjustments, the above recipe can be adapted to use a , or any other custom class, instead of a . By default, uses to adapt SQLite values with the data type. This works well for UTF-8 encoded text, but it might fail for other encodings and invalid UTF-8. You can use a custom to handle such cases. Because of SQLite’s flexible typing, it is not uncommon to encounter table columns with the data type containing non-UTF-8 encodings, or even arbitrary data. To demonstrate, let’s assume we have a database with ISO-8859-2 (Latin-2) encoded text, for example a table of Czech-English dictionary entries. Assuming we now have a instance connected to this database, we can decode the Latin-2 encoded text using this : For invalid UTF-8 or arbitrary data in stored in table columns, you can use the following technique, borrowed from the Unicode HOWTO: The module API does not support strings containing surrogates."
    },
    {
        "link": "https://kdnuggets.com/a-guide-to-working-with-sqlite-databases-in-python",
        "document": "By, KDnuggets Contributing Editor & Technical Content Specialist on May 21, 2024 in Python\n\nGet started with SQLite databases in Python using the built-in sqlite3 module.\n\nSQLite is a lightweight, serverless relational database management system (RDBMS) that is widely used due to its simplicity and ease of embedding within applications.\n\nSo whether you're building a small application, managing data locally, or prototyping a project, SQLite provides a convenient solution for storing and querying structured data. In this tutorial, you’ll learn how to work with SQLite databases from Python using the built-in sqlite3 module.\n\nParticularly, you’ll learn how to connect to an SQLite database from Python and perform basic CRUD operations. Let’s get started.\n\nAs a first step create a dedicated virtual environment for your project (in the project directory) and activate it. You can do it using the built-in venv module like so:\n\nIn this tutorial, we’ll use Faker to generate synthetic records. So install it using pip:\n\nThe sqlite3 module is built into the Python standard library, so you don't have to install it. So if you’ve installed Faker and are using a recent version of Python, you’re good to go!\n\nIn the project directory, create a Python script and get started. As a first step to interact with the database, we should establish a connection with the database.\n\nTo connect to a sample database example.db, you can use the function from the sqlite3 module like so:\n\nIf the database already exists, then it connects to it. Else it creates the database in the working directory.\n\nAfter connecting to the database, we’ll create a database cursor that will help us run queries. The cursor object has methods to execute queries and fetch the results of the query. It works very similarly to a file handler.\n\nIt’s often helpful to use the connection as a context manager in a with statement like so:\n\nThis way you don’t have to worry about closing the connection object. The connection is automatically closed when the execution exits the with block. We’ll explicitly close the cursor objects in this tutorial, though.\n\nNow let’s create a table with the required fields in the database. To do so, we first create a cursor object. We then run a CREATE TABLE statement, and pass in the query string to the method called on the cursor object:\n\nWhen you run the script, you should see the following output:\n\nLet’s perform some basic CRUD operations on the database table. If you’d like you may create separate scripts for each operation.\n\n\n\nNow we’ll insert some records into the table. We’ll use Faker to generate synthetic records. To keep the outputs readable, I’ve inserted only 10 records. But you may insert as many records as you’d like.\n\nNotice how we use parameterized queries: instead of hardcoding the values into the INSERT statement, we use ? placeholders and pass in a tuple of values.\n\n\n\nNow that we’ve inserted records into the table, let’s run a query to read in all the records. Notice how we use the method to run queries and the method on the cursor to retrieve the results of the query.\n\nBecause we’ve stored the results of the previous query in `all_customers`, let’s also run an UPDATE query to update the corresponding to the id 1. Here’s the code snippet:\n\nThis outputs both the records and the message after the update query:\n\nTo delete a customer with a specific customer ID, let’s run a DELETE statement as shown:\n\nFiltering Records Using the WHERE Clause\n\nLet’s say we want to fetch records of customers who’ve made fewer than 10 orders, say to run targeted campaigns and the like. For this, we run a SELECT query with the WHERE clause specifying the condition for filtering (in this case the number of orders). Here's how you can achieve this:\n\nAnd that’s a wrap! This was a guide to getting started with SQLite with Python. I hope you found it helpful. You can find all the code on GitHub. In the next part, we’ll look at running joins and subqueries, managing transactions in SQLite, and more. Until then, happy coding!\n\nIf you’re interested in learning how database indexes work, read How To Speed Up SQL Queries Using Indexes [Python Edition].\n\nBala Priya C is a developer and technical writer from India. She likes working at the intersection of math, programming, data science, and content creation. Her areas of interest and expertise include DevOps, data science, and natural language processing. She enjoys reading, writing, coding, and coffee! Currently, she's working on learning and sharing her knowledge with the developer community by authoring tutorials, how-to guides, opinion pieces, and more. Bala also creates engaging resource overviews and coding tutorials."
    },
    {
        "link": "https://freecodecamp.org/news/work-with-sqlite-in-python-handbook",
        "document": "SQLite is one of the most popular relational database management systems (RDBMS). It’s lightweight, meaning that it doesn’t take up much space on your system. One of its best features is that it’s serverless, so you don’t need to install or manage a separate server to use it.\n\nInstead, it stores everything in a simple file on your computer. It also requires zero configuration, so there’s no complicated setup process, making it perfect for beginners and small projects.\n\nSQLite is a great choice for small to medium applications because it’s easy to use, fast, and can handle most tasks that bigger databases can do, but without the hassle of managing extra software. Whether you're building a personal project or prototyping a new app, SQLite is a solid option to get things up and running quickly.\n\nIn this tutorial, you'll learn how to work with SQLite using Python. Here’s what we’re going to cover in this tutorial:\n• None How to Set Up Your Python Environment\n• None How to Create an SQLite Database\n• None How to Insert Data into a Table\n• None How to Update and Delete Data\n• None How to Use Transactions\n• None How to Optimize SQLite Query Performance with Indexing\n• None How to Handle Errors and Exceptions\n• None How to Export and Import Data [Bonus Section]\n\nThis tutorial is perfect for anyone who wants to get started with databases without diving into complex setups.\n\nHow to Set Up Your Python Environment\n\nBefore working with SQLite, let’s ensure your Python environment is ready. Here’s how to set everything up.\n\nIf you don’t have Python installed on your system yet, you can download it from the official Python website. Follow the installation instructions for your operating system (Windows, macOS, or Linux).\n\nTo check if Python is installed, open your terminal (or command prompt) and type:\n\nThis should show the current version of Python installed. If it’s not installed, follow the instructions on the Python website.\n\nThe good news is that SQLite3 comes built-in with Python! You don’t need to install it separately because it’s included in the standard Python library. This means you can start using it right away without any additional setup.\n\nHow to Create a Virtual Environment (Optional but Recommended)\n\nIt’s a good idea to create a virtual environment for each project to keep your dependencies organized. A virtual environment is like a clean slate where you can install packages without affecting your global Python installation.\n• None First, open your terminal or command prompt and navigate to the directory where you want to create your project.\n• None Run the following command to create a virtual environment:\n\nHere, is the name of the virtual environment. You can name it anything you like.\n\nAfter activating the virtual environment, you’ll notice that your terminal prompt changes, showing the name of the virtual environment. This means you’re now working inside it.\n\nWe’ll need a few additional libraries for this project. Specifically, we’ll use:\n• None : This is an optional library for handling and displaying data in tabular format, useful for advanced use cases.\n• None : This library will help us generate fake data, like random names and addresses, which we can insert into our database for testing.\n\nTo install and , simply run the following commands:\n\nThis installs both and into your virtual environment. With this, your environment is set up, and you’re ready to start creating and managing your SQLite database in Python!\n\nHow to Create an SQLite Database\n\nA database is a structured way to store and manage data so that it can be easily accessed, updated, and organized. It’s like a digital filing system that allows you to efficiently store large amounts of data, whether it’s for a simple app or a more complex system. Databases use tables to organize data, with rows and columns representing individual records and their attributes.\n\nUnlike most other database systems, SQLite is a serverless database. This means that it doesn’t require setting up or managing a server, making it lightweight and easy to use. All the data is stored in a single file on your computer, which you can easily move, share, or back up. Despite its simplicity, SQLite is powerful enough to handle many common database tasks and is widely used in mobile apps, embedded systems, and small to medium-sized projects.\n\nHow to Create a New SQLite Database\n\nLet’s create a new SQLite database and learn how to interact with it using Python’s library.\n\nSince is pre-installed, you just need to import it in your Python script. To create a new database or connect to an existing one, we use the method. This method takes the name of the database file as an argument. If the file doesn’t exist, SQLite will automatically create it.\n\nIn this example, a file named is created in the same directory as your script. If the file already exists, SQLite will just open the connection to it.\n\nOnce you have a connection, the next step is to create a cursor object. The cursor is responsible for executing SQL commands and queries on the database.\n\nAfter you’ve finished working with the database, it’s important to close the connection to free up any resources. You can close the connection with the following command:\n\nHowever, you should only close the connection once you’re done with all your operations.\n\nWhen you run your Python script, a file named will be created in your current working directory. You’ve now successfully created your first SQLite database!\n\nHow to Use Context Manager to Open and Close Connections\n\nPython provides a more efficient and cleaner way to handle database connections using the statement, also known as a context manager. The statement automatically opens and closes the connection, ensuring that the connection is properly closed even if an error occurs during the database operations. This eliminates the need to manually call .\n\nHere’s how you can use the statement to handle database connections:\n\nFrom now on, we’ll use the statement in our upcoming code examples to manage database connections efficiently. This will make the code more concise and easier to maintain.\n\nNow that we’ve created an SQLite database and connected to it, the next step is to create tables inside the database. A table is where we’ll store our data, organized in rows (records) and columns (attributes). For this example, we’ll create a table called to store information about students, which we’ll reuse in upcoming sections.\n\nTo create a table, we use SQL's statement. This command defines the table structure, including the column names and the data types for each column.\n\nHere’s a simple SQL command to create a table with the following fields:\n• None : A unique identifier for each student (an integer).\n• None name: The student's name (text).\n\nThe SQL command to create this table would look like this:\n\nWe can execute this SQL command in Python using the library. Let’s see how to do that.\n• None : This ensures that the table is only created if it doesn’t already exist, preventing errors if the table has been created before.\n• None : This saves (commits) the changes to the database.\n\nWhen you run the Python code above, it will create the table in the database file. You’ll also see a message in the terminal confirming that the table has been created successfully.\n\nIf you’re using Visual Studio Code, you can install the SQLite Viewer extension to view SQLite databases.\n\nData Types in SQLite and Their Mapping to Python\n\nSQLite supports several data types, which we need to understand when defining our tables. Here’s a quick overview of common SQLite data types and how they map to Python types:\n• None is of type , which maps to Python’s .\n• None and are of type , which map to Python’s .\n• None is also of type , mapping to Python’s .\n\nHow to Insert Data into a Table\n\nNow that we have our table created, it’s time to start inserting data into the database. In this section, we’ll cover how to insert both single and multiple records using Python and SQLite, and how to avoid common security issues like SQL injection by using parameterized queries.\n\nTo insert data into the database, we use the SQL command. Let’s start by inserting a single record into our table.\n\nHowever, instead of writing SQL directly in our Python script with hardcoded values, we’ll use parameterized queries to make our code more secure and flexible. Parameterized queries help prevent SQL injection, a common attack where malicious users can manipulate the SQL query by passing harmful input.\n\nHere’s how we can insert a single record into the table using a parameterized query:\n\nThe placeholders represent the values to be inserted into the table. The actual values are passed as a tuple ( ) in the method.\n\nIf you want to insert multiple records at once, you can use the method in Python. This method takes a list of tuples, where each tuple represents one record.\n\nTo make our example more dynamic, we can use the library to generate random student data. This is useful for testing and simulating real-world scenarios.\n• None generates random names, ages, and emails for students. Passing the locale( ) is optional.\n• None : This method allows us to insert multiple records at once, making the code more efficient.\n• None : A list of tuples where each tuple represents one student’s data.\n\nSQL injection is a security vulnerability where attackers can insert or manipulate SQL queries by providing harmful input. For example, an attacker might try to inject code like to delete the table.\n\nBy using parameterized queries (as demonstrated above), we avoid this issue. The placeholders in parameterized queries ensure that input values are treated as data, not as part of the SQL command. This makes it impossible for malicious code to be executed.\n\nNow that we’ve inserted some data into our table, let’s learn how to retrieve the data from the table. We'll explore different methods for fetching data in Python, including , , and .\n\nTo query data from a table, we use the statement. Here’s a simple SQL command to select all columns from the table:\n\nThis command retrieves all records and columns from the table. We can execute this query in Python and fetch the results.\n\nHow to Fetch All Records\n\nHere’s how we can fetch all records from the table:\n\nIn this example, the method retrieves all rows returned by the query as a list of tuples.\n\nIf you want to retrieve only one record, you can use the method:\n\nTo fetch a specific number of records, you can use :\n\nHow to Use for Better Data Presentation\n\nFor better data presentation, we can use the library to create a from our query results. This makes it easier to manipulate and visualize the data.\n\nHere’s how to fetch all records and display them as a pandas DataFrame:\n\nThe function executes the SQL query and directly returns the results as a pandas DataFrame.\n\nIn this section, we’ll learn how to update existing records and delete records from our table using SQL commands in Python. This is essential for managing and maintaining your data effectively.\n\nTo modify existing records in a database, we use the SQL command. This command allows us to change the values of specific columns in one or more rows based on a specified condition.\n\nFor example, if we want to update a student's age, the SQL command would look like this:\n\nNow, let’s write Python code to update a specific student's age in our table.\n\nIn this example, we used parameterized queries to prevent SQL injection.\n\nHow to Delete Records from the Table\n\nTo remove records from a database, we use the SQL command. This command allows us to delete one or more rows based on a specified condition.\n\nFor example, if we want to delete a student named 'Jane Doe', the SQL command would look like this:\n\nLet’s write Python code to delete a specific student from our table using the statement.\n• None Conditions: Always use the clause when updating or deleting records to avoid modifying or removing all rows in the table. Without a clause, the command affects every row in the table.\n• None Backup: It’s good practice to back up your database before performing updates or deletions, especially in production environments.\n\nHow to Use Transactions\n\nA transaction is a sequence of one or more SQL operations that are treated as a single unit of work. In the context of a database, a transaction allows you to perform multiple operations that either all succeed or none at all. This ensures that your database remains in a consistent state, even in the face of errors or unexpected issues.\n\nFor example, if you are transferring money between two bank accounts, you would want both the debit from one account and the credit to the other to succeed or fail together. If one operation fails, the other should not be executed to maintain consistency.\n• None Atomicity: Transactions ensure that a series of operations are treated as a single unit. If one operation fails, none of the operations will be applied to the database.\n• None Consistency: Transactions help maintain the integrity of the database by ensuring that all rules and constraints are followed.\n• None Isolation: Each transaction operates independently of others, preventing unintended interference.\n• None Durability: Once a transaction is committed, the changes are permanent, even in the event of a system failure.\n\nWhen to Use Transactions?\n\nYou should use transactions when:\n• None Performing multiple related operations that must succeed or fail together.\n• None Working with operations that can potentially fail, such as financial transactions or data migrations.\n\nHow to Manage Transactions in Python\n\nIn SQLite, transactions are managed using the , , and commands. However, when using the module in Python, you typically manage transactions through the connection object.\n\nA transaction begins implicitly when you execute any SQL statement. To start a transaction explicitly, you can use the command:\n\nHowever, it’s usually unnecessary to start a transaction manually, as SQLite starts a transaction automatically when you execute an SQL statement.\n\nTo save all changes made during a transaction, you use the method. This makes all modifications permanent in the database.\n\nWe have already used the method in the above provided examples.\n\nIf something goes wrong and you want to revert the changes made during a transaction, you can use the method. This will undo all changes made since the transaction started.\n\nExample of Using Transactions in Python\n\nTo illustrate the use of transactions in a real-world scenario, we’ll create a new table called to manage customer accounts. In this example, we’ll assume each customer has a . We will add two customers to this table and perform a funds transfer operation between them.\n\nFirst, let's create the table and insert two customers:\n\nNow, let’s perform the funds transfer operation between Ashutosh and Krishna:\n\nIn this example, we first created a table and inserted two customers, Ashutosh with a balance of ₹100, and Krishna with a balance of ₹50. We then performed a funds transfer of ₹80 from Ashutosh to Krishna. By using transactions, we ensure that both the debit from Ashutosh's account and the credit to Krishna's account are executed as a single atomic operation, maintaining data integrity in the event of any errors. If the transfer fails (for example, due to insufficient funds), the transaction will roll back, leaving both accounts unchanged.\n\nHow to Optimize SQLite Query Performance with Indexing\n\nIndexing is a powerful technique used in databases to improve query performance. An index is essentially a data structure that stores the location of rows based on specific column values, much like an index at the back of a book helps you quickly locate a topic.\n\nWithout an index, SQLite has to scan the entire table row by row to find the relevant data, which becomes inefficient as the dataset grows. By using an index, SQLite can jump directly to the rows you need, significantly speeding up query execution.\n\nHow to Populate the Database with Fake Data\n\nTo effectively test the impact of indexing, we need a sizable dataset. Instead of manually adding records, we can use the library to quickly generate fake data. In this section, we’ll generate 10,000 fake records and insert them into our table. This will simulate a real-world scenario where databases grow large, and query performance becomes important.\n\nWe will use the method to insert the records as below:\n\nBy running this script, 10,000 fake student records will be added to the table. In the next section, we'll query the database and compare the performance of queries with and without indexing.\n\nHow to Query Without Indexes\n\nIn this section, we’ll query the table without any indexes to observe how SQLite performs when there are no optimizations in place. This will serve as a baseline to compare the performance when we add indexes later.\n\nWithout indexes, SQLite performs a full table scan, which means that it must check every row in the table to find matching results. For small datasets, this is manageable, but as the number of records grows, the time taken to search increases dramatically. Let’s see this in action by running a basic query to search for a specific student by name and measure how long it takes.\n\nFirst, we’ll query the table by looking for a student with a specific name. We’ll log the time taken to execute the query using Python’s module to measure the performance.\n\nBy running the above script, you'll see how long it takes to search the table without any indexes. For example, if there are 10,000 records in the table, the query might take 1000-2000 microseconds depending on the size of the table and your hardware. This may not seem too slow for a small dataset, but the performance will degrade as more records are added.\n\nWe use to measure the time taken for the query execution in nanoseconds. This method is highly accurate for benchmarking small time intervals. We convert the time to microseconds( ) for easier readability.\n\nWhen working with databases, understanding how queries are executed can help you identify performance bottlenecks and optimize your code. SQLite provides a helpful tool for this called , which allows you to analyze the steps SQLite takes to retrieve data.\n\nIn this section, we’ll introduce how to use to visualize and understand the inner workings of a query—specifically, how SQLite performs a full table scan when no index is present.\n\nLet’s use to see how SQLite retrieves data from the table without any indexes. We’ll search for a student by name, and the query plan will reveal the steps SQLite takes to find the matching rows.\n\nWhen you run this code, SQLite will return a breakdown of how it plans to execute the query. Here’s an example of what the output might look like:\n\nThis indicates that SQLite is scanning the entire table (a full table scan) to find the rows where the column matches the provided value ( ). Since there is no index on the column, SQLite must examine each row in the table.\n\nHow to Create an Index\n\nCreating an index on a column allows SQLite to find rows more quickly during query operations. Instead of scanning the entire table, SQLite can use the index to jump directly to the relevant rows, significantly speeding up queries—especially those involving large datasets.\n\nTo create an index, use the following SQL command:\n\nIn this example, we will create an index on the column of the table. Here’s how you can do it using Python:\n\nEven though creating the index takes this long (102768.6 microseconds), it's a one-time operation. You will still get substantial speed-up when running multiple queries. In the following sections, we will query the database again to observe the performance improvements made possible by this index.\n\nHow to Query with Indexes\n\nIn this section, we will perform the same query we executed earlier, but this time we will take advantage of the index we created on the column of the table. We'll measure and log the execution time to observe the performance improvements provided by the index.\n\nHere’s what we get in the output:\n\nWe can observe a significant reduction in execution time compared to when the query was performed without an index.\n\nLet’s analyze the query execution plan for the query with the index on the column of the table. If you execute the same script again to explain the query, you’ll get the below output:\n\nThe plan now shows that the query uses the index , significantly reducing the number of rows that need to be scanned, which leads to faster query execution.\n\nNow, let's summarize the performance results we obtained when querying with and without indexes.\n• None The query with the index is approximately 4.04 times faster than the query without the index.\n• None The execution time improved by about 75.24% after adding the index.\n\nBest Practices for Using Indexes\n\nIndexes can significantly enhance the performance of your SQLite database, but they should be used judiciously. Here are some best practices to consider when working with indexes:\n\nWhen and Why to Use Indexes\n• None Frequent Query Columns: Use indexes on columns that are frequently used in queries, especially those used in , , and clauses. This is because indexing these columns can drastically reduce query execution time.\n• None Uniqueness Constraints: When you have columns that must hold unique values (like usernames or email addresses), creating an index can enforce this constraint efficiently.\n• None Large Datasets: For tables with a large number of records, indexes become increasingly beneficial. They enable quick lookups, which is essential for maintaining performance as your data grows.\n• None Composite Indexes: Consider creating composite indexes for queries that filter or sort by multiple columns. For example, if you often search for students by both and , an index on both columns can optimize such queries.\n\nWhile indexes provide significant advantages, there are some potential downsides:\n• None Slower Insert/Update Operations: When you insert or update records in a table with indexes, SQLite must also update the index, which can slow down these operations. This is because each insert or update requires additional overhead to maintain the index structure.\n• None Increased Storage Requirements: Indexes consume additional disk space. For large tables, the storage cost can be substantial. Consider this when designing your database schema, especially for systems with limited storage resources.\n• None Complex Index Management: Having too many indexes can complicate database management. It may lead to situations where you have redundant indexes, which can degrade performance rather than enhance it. Regularly reviewing and optimizing your indexes is a good practice.\n\nIndexes are powerful tools for optimizing database queries, but they require careful consideration. Striking a balance between improved read performance and the potential overhead on write operations is key. Here are some strategies for achieving this balance:\n• None Monitor Query Performance: Use SQLite’s to analyze how your queries perform with and without indexes. This can help identify which indexes are beneficial and which may be unnecessary.\n• None Regular Maintenance: Periodically review your indexes and assess whether they are still needed. Remove redundant or rarely used indexes to streamline your database operations.\n• None Test and Evaluate: Before implementing indexes in a production environment, conduct thorough testing to understand their impact on both read and write operations.\n\nBy following these best practices, you can leverage the benefits of indexing while minimizing potential drawbacks, ultimately enhancing the performance and efficiency of your SQLite database.\n\nHow to Handle Errors and Exceptions\n\nIn this section, we’ll discuss how to handle errors and exceptions when working with SQLite in Python. Proper error handling is crucial for maintaining the integrity of your database and ensuring that your application behaves predictably.\n\nWhen interacting with an SQLite database, several common errors may arise:\n• None Constraint Violations: This occurs when you try to insert or update data that violates a database constraint, such as primary key uniqueness or foreign key constraints. For example, trying to insert a duplicate primary key will trigger an error.\n• None Data Type Mismatches: Attempting to insert data of the wrong type (for example, inserting a string where a number is expected) can lead to an error.\n• None Database Locked Errors: If a database is being written to by another process or connection, trying to access it can result in a \"database is locked\" error.\n• None Syntax Errors: Mistakes in your SQL syntax will result in errors when you try to execute your commands.\n\nHow to Use Python's Exception Handling\n\nPython’s built-in exception handling mechanisms ( and ) are essential for managing errors in SQLite operations. By using these constructs, you can catch exceptions and respond appropriately without crashing your program.\n\nHere’s a basic example of how to handle errors when inserting data into the database:\n\nIn this example:\n• None We catch , which is raised for violations like unique constraints.\n• None We catch for general database-related issues (like database locked errors).\n• None We also have a generic block to handle any unexpected exceptions.\n• None Use Transactions: Always use transactions (as discussed in the previous section) when performing multiple related operations. This helps ensure that either all operations succeed or none do, maintaining consistency.\n• None Validate Input Data: Before executing SQL commands, validate the input data to ensure it meets the expected criteria (for example, correct types, within allowable ranges).\n• None Catch Specific Exceptions: Always catch specific exceptions to handle different types of errors appropriately. This allows for clearer error handling and debugging.\n• None Log Errors: Instead of just printing errors to the console, consider logging them to a file or monitoring system. This will help you track issues in production.\n• None Graceful Degradation: Design your application to handle errors gracefully. If an operation fails, provide meaningful feedback to the user rather than crashing the application.\n• None Regularly Backup Data: Regularly back up your database to prevent data loss in case of critical failures or corruption.\n• None Use Prepared Statements: Prepared statements help prevent SQL injection attacks and can also provide better performance for repeated queries.\n\nHow to Export and Import Data [Bonus Section]\n\nIn this section, we will learn how to export data from an SQLite database to common formats like CSV and JSON, as well as how to import data into SQLite from these formats using Python. This is useful for data sharing, backup, and integration with other applications.\n\nExporting data to a CSV (Comma-Separated Values) file is straightforward with Python’s built-in libraries. CSV files are widely used for data storage and exchange, making them a convenient format for exporting data.\n\nHere’s how to export data from an SQLite table to a CSV file:\n\nHow to Export Data to JSON\n\nSimilarly, you can export data to a JSON (JavaScript Object Notation) file, which is a popular format for data interchange, especially in web applications.\n\nHere’s an example of how to export data to JSON:\n\nHow to Import Data into SQLite from CSV\n\nYou can also import data from a CSV file into an SQLite database. This is useful for populating your database with existing datasets.\n\nHere's how to import data from a CSV file:\n\nHow to Import Data into SQLite from JSON\n\nSimilarly, importing data from a JSON file is simple. You can read the JSON file and insert the data into your SQLite table.\n\nHere's how to do it:\n\nAnd that’s a wrap! This guide has introduced you to the fundamentals of working with SQLite in Python, covering everything from setting up your environment to querying and manipulating data, as well as exporting and importing information. I hope you found it helpful and that it has sparked your interest in using SQLite for your projects.\n\nNow it's time to put your newfound knowledge into practice! I encourage you to create your project using SQLite and Python. Whether it’s a simple application for managing your library, a budgeting tool, or something unique, the possibilities are endless.\n\nOnce you’ve completed your project, share it on Twitter and tag me! I’d love to see what you’ve created and celebrate your accomplishments.\n\nYou can find all the code from this tutorial on GitHub. Thank you for following along, and happy coding!"
    },
    {
        "link": "https://sqlite.org/docs.html",
        "document": ""
    },
    {
        "link": "https://medium.com/@miguel.jesus.cor/working-with-sqlite-databases-in-python-bdfffbb95a84",
        "document": "SQLite is a lightweight, file-based database engine that is very easy to use from Python. In this post, we’ll walk through how to create SQLite databases, insert and query data, and analyze results using the Python module.\n\nWe’ll use examples based on some publicly available datasets from the city of Chicago to demonstrate these concepts.\n\nTo follow along, you’ll need:\n\nWe’ll also use the following public Chicago datasets:\n• Socioeconomic Indicators. This dataset contains a selection of six socioeconomic indicators of public health significance and a “hardship index,” for each Chicago community area, for the years 2008–2012.\n• Chicago Public Schools. This dataset shows all school-level performance data used to create CPS School Report Cards for the 2011–2012 school year. This dataset is provided by the city of Chicago’s Data Portal.\n• Chicago Crime Data. This dataset reflects reported incidents of crime (with the exception of murders where data exists for each victim) that occurred in the City of Chicago from 2001 to the present, minus the most recent seven days.\n\nNOTE: The versions to download in this article are subsets of the original datasets and have some of the column names modified to be more database-friendly which will make it easier to complete this assignment.\n\nTo begin, we need to import the module and connect it to a new database. This will create the database if it doesn't already exist:\n\nBy default, this will create the database file in the current directory. You can also specify a full path.\n\nIt’s important to highlight that we will write SQL commands using SQLMagic. SQLMagic is an extension that allows you to seamlessly query and access SQLite databases directly within a Jupyter Notebook. So, If you are planning to run the code locally through an IDE, you will have to necessarily use the ‘cursor’ object to execute the SQL commands.\n\nIn this case, the data to be inserted into the Chicago database are available as CSV (Comma Separated Values) on the internet. We will first read the CSV files from the given URL into pandas dataframes. Next, we will be using the df.to_sql() function to convert each CSV file to a table in SQLite with the CSV data loaded in it.\n\nYou can verify that the table creation was successful by retrieving the list of all tables in your schema. In SQLite, you do that by referring to the sqlite_master table from the database system catalogue.\n\nYou can also retrieve column metadata from the database system catalogue like column names, datatypes and length. All you need to do is write a SELECT statement, specifying the desired table name with the PRAGMA_TABLE_INFO function.\n\nHaving made sure that everything is in order, we can now write and execute SQL queries to solve problems, such as those shown below.\n\nPROBLEM 1. List the number and name of community areas with a per capita income below 12000. Sort results descending by per capita income.\n\nPROBLEM 2. What kinds of crimes were recorded at schools? Add the description of the crimes and a count of the same.\n\nPROBLEM 3. Retrieve the list of 5 Schools with the lowest Average Student Attendance sorted in ascending order based on attendance.\n\nPROBLEM 4. Determine the 5 community areas with the most number of crimes.\n\nBy following the previous steps, we’ve created a SQLite database from scratch and loaded in real data from the city of Chicago. The data is now persisted locally and can be analyzed by combining the SQL statements with several analytical modules. In this case, we will store the result of a query in a variable to then use it in a plot.\n\nFinally, we should free all resources by closing the database connection. Remember that it is always important to close connections so that we can avoid unused connections taking up resources."
    }
]