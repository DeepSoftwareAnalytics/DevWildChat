[
    {
        "link": "https://w3schools.com/HOWTO/howto_css_smooth_scroll.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://w3schools.com/howto/howto_css_smooth_scroll.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://forum.squarespace.com/topic/196122-how-do-i-create-a-smooth-scrolling-website-that-jumps-to-sections",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/70552182/scroll-to-section-in-html-css",
        "document": "if I have the following JS code:\n\nThis basically is for the Back-top-button animation where if the user clicks the button, then it brings the user back to the homepage with smooth scrolling. I would like the opposite. Is there a way to modify the above JS code so that when the user clicks the button, it brings the user to whichever page they desire? Right now, this scrolls all the way to the top and brings the user to only the homepage of the website, but how can I make it so it would bring the user to whichever page on the website?\n\nThis is what I have in HTML file:\n\nBasically, I would like the user to go in the about section of the page instead of the homepage. Any suggestions on how to achieve this task?"
    },
    {
        "link": "https://css-tricks.com/snippets/jquery/smooth-scrolling",
        "document": "Hey! Before you go too far down the rabbit hole of JavaScript-based smooth scrolling, know that there is a native CSS feature for this: .\n\nAnd before you reach for a library like jQuery to help, there is also a native JavaScript version of smooth scrolling, like this:\n\nDustan Kasten has a polyfill for this. And you’d probably only reach for this if you were doing something with scrolling the page that couldn’t be done with #target jump links and CSS.\n\nWhatever technology you use for smooth scrolling, accessibility is a concern. For example, if you click a link, the native behavior is for the browser to change focus to the element matching that ID. The page may scroll, but the scrolling is a side effect of the focus changing.\n\nIf you override the default focus-changing behavior (which you have to, to prevent instant scrolling and enable smooth scrolling), you need to handle the focus-changing yourself.\n\nHeather Migliorisi wrote about this, with code solutions, in Smooth Scrolling and Accessibility.\n\njQuery can also do this. Here’s the code to perform a smooth page scroll to an anchor on the same page. It has some logic built in to identify those jump links, and not target other links.\n\nIf you’ve used this code and you’re all like HEY WHAT’S WITH THE BLUE OUTLINES?!, read the stuff about accessibility above.\n\nJames Quick has a nice step-by-step tutorial on how to implement smooth scrolling in React using the plugin:"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect",
        "document": "The returned value is a object which is the smallest rectangle which contains the entire element, including its padding and border-width. The , , , , , , , and properties describe the position and size of the overall rectangle in pixels. Properties other than and are relative to the top-left of the viewport.\n\nThe and properties of the object returned by the method include the and , not only the content width/height. In the standard box model, this would be equal to the or property of the element + + . But if is set for the element this would be directly equal to its or .\n\nThe returned value can be thought of as the union of the rectangles returned by for the element, i.e., the CSS border-boxes associated with the element.\n\nEmpty border-boxes are completely ignored. If all the element's border-boxes are empty, then a rectangle is returned with a and of zero and where the and are the top-left of the border-box for the first CSS box (in content order) for the element.\n\nThe amount of scrolling that has been done of the viewport area (or any other scrollable element) is taken into account when computing the bounding rectangle. This means that the rectangle's boundary edges ( , , , ) change their values every time the scrolling position changes (because their values are relative to the viewport and not absolute).\n\nIf you need the bounding rectangle relative to the top-left corner of the document, just add the current scrolling position to the and properties (these can be obtained using and ) to get a bounding rectangle which is independent from the current scrolling position."
    },
    {
        "link": "https://stackoverflow.com/questions/25630035/javascript-getboundingclientrect-changes-while-scrolling",
        "document": "I want to have the exact distance between the Y-coordinate of an element an the Y-value=0, which I consider as the top of the document.\n\nBut the value of seems to change while scrolling. How can I get the real distance between myElement and the Y-coordinate=0 (top of document)?"
    },
    {
        "link": "https://stackoverflow.com/questions/487073/how-to-check-if-element-is-visible-after-scrolling",
        "document": "I'm loading elements via AJAX. Some of them are only visible if you scroll down the page. Is there any way I can know if an element is now in the visible part of the page?\n\nIt's easy & efficient to determine if an element is visible in the viewport, or in any scrollable container, by using an observer. The need to attach a event and manually checking on the event callback is eliminated, which is more efficient: // define an observer instance var observer = new IntersectionObserver(onIntersection, { root: null, // default is the viewport threshold: .5 // percentage of target's visible area. Triggers \"onIntersection\" }) // callback is called on intersection change function onIntersection(entries, opts){ entries.forEach(entry => entry.target.classList.toggle('visible', entry.isIntersecting) ) } // Use the observer to observe an element observer.observe( document.querySelector('.box') ) // To stop observing: // observer.unobserve(entry.target) Supported by modern browsers, including mobile browsers. Not supported in IE - View browsers support table\n\nMost answers here don't take into account that an element can also be hidden because it is scrolled out of view of a div, not only of the whole page. To cover that possibility, you basically have to check if the element is positioned inside the bounds of each of its parents. This solution does exactly that: function(element, percentX, percentY){ var tolerance = 0.01; //needed because the rects returned by getBoundingClientRect provide the position up to 10 decimals if(percentX == null){ percentX = 100; } if(percentY == null){ percentY = 100; } var elementRect = element.getBoundingClientRect(); var parentRects = []; while(element.parentElement != null){ parentRects.push(element.parentElement.getBoundingClientRect()); element = element.parentElement; } var visibleInAllParents = parentRects.every(function(parentRect){ var visiblePixelX = Math.min(elementRect.right, parentRect.right) - Math.max(elementRect.left, parentRect.left); var visiblePixelY = Math.min(elementRect.bottom, parentRect.bottom) - Math.max(elementRect.top, parentRect.top); var visiblePercentageX = visiblePixelX / elementRect.width * 100; var visiblePercentageY = visiblePixelY / elementRect.height * 100; return visiblePercentageX + tolerance > percentX && visiblePercentageY + tolerance > percentY; }); return visibleInAllParents; }; It also lets you specify to what percentage it has to be visible in each direction.\n\n It doesn't cover the possibility that it may be hidden due to other factors, like . This should work in all major browsers, since it only uses . I personally tested it in Chrome and Internet Explorer 11.\n\nThere are over 30 answers to this question, and none of them use the amazingly simple, pure JS solution that I have been using. There is no need to load jQuery just to solve this, as many others are pushing. In order to tell if the element is within the viewport, we must first determine the elements position within the body. We do not need to do this recursively as I once thought. Instead, we can use . This value is the Y difference between the top of the object and the top of the body. We then must tell if the element is within view. Most implementations ask if the full element is within the viewport, so this is what we shall cover. First of all, the top position of the window is: . We can get the bottom position of the window by adding the window's height to its top position: Lets create a simple function for getting the element's top position: This function will return the element's top position within the window or it will return if you pass it something other than an element with the method. This method has been around for a long time, so you shouldn't have to worry about your browser not supporting it. Now, our element's top position is: And or element's bottom position is: Now we can determine if the element is within the viewport by checking if the element's bottom position is lower than the viewport's top position and by checking if the element's top position is higher than the viewport's bottom position: if(element_bottom_position >= window.scrollY && element_top_position <= window_bottom_position){ //element is in view else //element is not in view From there, you can perform the logic to add or remove an class on your element, which you can then handle later with transition effects in your CSS. I am absolutely amazed that I did not find this solution anywhere else, but I do believe that this is the cleanest and most effective solution, and it doesn't require you to load jQuery!"
    },
    {
        "link": "https://dev.to/fpaghar/how-to-check-if-an-element-is-visible-in-the-viewport-using-javascript-and-react-hook-4648",
        "document": "In web development, it's common to determine if an element is currently visible within the viewport, especially when implementing features like lazy loading, animations triggered by scrolling, or analytics tracking. Fortunately, JavaScript provides methods to accomplish it efficiently. Below, we'll explore two approaches to achieve this.\n\nThe size of an element and its position relative to the viewport are returned by the method. We can leverage this to check if an element is within the viewport.\n\nThe below code demonstrates how to implement a simple element visibility checker in a React component using .\n\n\n\nInside the function, we use to obtain the position and dimensions of the element relative to the viewport. Based on these dimensions, we determine whether the element is currently visible in the viewport or not. We update the state variable isVisible accordingly.\n\nInitial Check: We call initially when the component mounts to check the visibility status of the element.\n\nCleanup: We remove the event listener when the component unmounts to prevent memory leaks.\n\nRendering: We render a element with a ref pointing to elementRef. The background color of this div changes based on the isVisible state, allowing us to visually observe the visibility changes. We also provide a message indicating whether the element is visible or not.\n\nThe Intersection Observer API provides a more performant way to observe changes in the intersection of a target element with an ancestor element or with a top-level document's viewport. This component demonstrates how to implement a simple element checker using the Intersection Observer API in a React component.\n\n\n\nObserver Configuration: We configure the Intersection Observer with options such as root, rootMargin, and threshold. In this example, we set root to null (viewport), rootMargin to 0px (no margin), and threshold to 0.5 (50% of the target visible).\n\nObserver Callback: The callback function receives an array of entries, each representing a target element's visibility. We update the isVisible state based on .\n\nObserver Registration: We use the observation method to start observing the target element's visibility. We pass the current value of targetRef.current as the target element.\n\nCleanup: We use the unobserved method to stop observing the target element's visibility when the component unmounts.\n\nRendering: We render a element with a ref pointing to targetRef.The background color of this div changes based on the state, allowing us to visually observe the visibility changes. We also provide a message indicating whether the element is visible or not.\n\nSummary\n\n The article explores techniques to monitor element visibility in React. It discusses using for basic checks and highlights the advantages of the Intersection Observer API for efficient and flexible visibility tracking. The Intersection Observer API is recommended for its superior performance and customization options, making it ideal for complex scenarios in React applications.\n• None React hook check if the element is in viewport"
    },
    {
        "link": "https://w3schools.com/jsref/met_element_getboundingclientrect.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    }
]