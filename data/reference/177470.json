[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Structuring_content/Structuring_documents",
        "document": "In addition to defining individual parts of your page (such as \"a paragraph\" or \"an image\"), HTML also boasts a number of block level elements used to define areas of your website (such as \"the header\", \"the navigation menu\", \"the main content column\"). This article looks into how to plan a basic website structure, and write the HTML to represent this structure. Basic HTML familiarity, as covered in Basic HTML Syntax. Text-level semantics such as headings and paragraphs and lists.\n• The common HTML semantic structural elements, for example , , , , , and , and how to use them correctly.\n• The need to use semantic elements in appropriate places, rather than just using elements wherever a block-level container is required, and the benefits of this (such as improved accessibility).\n\nWebpages can and will look pretty different from one another, but they all tend to share similar standard components, unless the page is displaying a fullscreen video or game, is part of some kind of art project, or is just badly structured: Usually a big strip across the top with a big heading, logo, and perhaps a tagline. This usually stays the same from one page of a website to another. Links to the site's main sections; usually represented by menu buttons, links, or tabs. Like the header, this content usually remains consistent from one webpage to another — having inconsistent navigation on your website will just lead to confused, frustrated users. Many web designers consider the navigation bar to be part of the header rather than an individual component, but that's not a requirement; in fact, some also argue that having the two separate is better for accessibility, as screen readers can read the two features better if they are separate. A big area in the center that contains most of the unique content of a given webpage, for example, the video you want to watch, or the main story you're reading, or the map you want to view, or the news headlines, etc. This is the one part of the website that definitely will vary from page to page! Some peripheral info, links, quotes, ads, etc. Usually, this is contextual to what is contained in the main content (for example on a news article page, the sidebar might contain the author's bio, or links to related articles) but there are also cases where you'll find some recurring elements like a secondary navigation system. A strip across the bottom of the page that generally contains fine print, copyright notices, or contact info. It's a place to put common information (like the header) but usually, that information is not critical or secondary to the website itself. The footer is also sometimes used for SEO purposes, by providing links for quick access to popular content. A \"typical website\" could be structured something like this: Note: The image above illustrates the main sections of a document, which you can define with HTML. However, the appearance of the page shown here — including the layout, colors, and fonts — is achieved by applying CSS to the HTML.\n\nActive learning: exploring the code for our example Our example seen above is represented by the following code (you can also find the example in our GitHub repository). We'd like you to look at the example above, and then look over the listing below to see what parts make up what section of the visual. <!doctype html> <html lang=\"en-US\"> <head> <meta charset=\"utf-8\" /> <meta name=\"viewport\" content=\"width=device-width\" /> <title>My page title</title> <link href=\"https://fonts.googleapis.com/css?family=Open+Sans+Condensed:300|Sonsie+One\" rel=\"stylesheet\" /> <link rel=\"stylesheet\" href=\"style.css\" /> </head> <body> <!-- The main header used across all the pages of our website --> <header> <h1>Header</h1> </header> <nav> <ul> <li><a href=\"#\">Home</a></li> <li><a href=\"#\">Our team</a></li> <li><a href=\"#\">Projects</a></li> <li><a href=\"#\">Contact</a></li> </ul> <!-- A Search form: another common non-linear way to navigate through a site. --> <form> <input type=\"search\" name=\"q\" placeholder=\"Search query\" /> <input type=\"submit\" value=\"Go!\" /> </form> </nav> <!-- Our page's main content --> <main> <!-- An article --> <article> <h2>Article heading</h2> <p> Lorem ipsum dolor sit amet, consectetur adipisicing elit. Donec a diam lectus. Set sit amet ipsum mauris. Maecenas congue ligula as quam viverra nec consectetur ant hendrerit. Donec et mollis dolor. Praesent et diam eget libero egestas mattis sit amet vitae augue. Nam tincidunt congue enim, ut porta lorem lacinia consectetur. </p> <section> <h3>Subsection</h3> <p> Donec ut librero sed accu vehicula ultricies a non tortor. Lorem ipsum dolor sit amet, consectetur adipisicing elit. Aenean ut gravida lorem. Ut turpis felis, pulvinar a semper sed, adipiscing id dolor. </p> <p> Pelientesque auctor nisi id magna consequat sagittis. Curabitur dapibus, enim sit amet elit pharetra tincidunt feugiat nist imperdiet. Ut convallis libero in urna ultrices accumsan. Donec sed odio eros. </p> </section> <section> <h3>Another subsection</h3> <p> Donec viverra mi quis quam pulvinar at malesuada arcu rhoncus. Cum soclis natoque penatibus et manis dis parturient montes, nascetur ridiculus mus. In rutrum accumsan ultricies. Mauris vitae nisi at sem facilisis semper ac in est. </p> <p> Vivamus fermentum semper porta. Nunc diam velit, adipscing ut tristique vitae sagittis vel odio. Maecenas convallis ullamcorper ultricied. Curabitur ornare, ligula semper consectetur sagittis, nisi diam iaculis velit, is fringille sem nunc vet mi. </p> </section> </article> <!-- the aside content can also be nested within the main content --> <aside> <h2>Related</h2> <ul> <li><a href=\"#\">Oh I do like to be beside the seaside</a></li> <li><a href=\"#\">Oh I do like to be beside the sea</a></li> <li><a href=\"#\">Although in the North of England</a></li> <li><a href=\"#\">It never stops raining</a></li> <li><a href=\"#\">Oh well…</a></li> </ul> </aside> </main> <!-- The footer that is used across all the pages of our website --> <footer> <p>©Copyright 2050 by nobody. All rights reversed.</p> </footer> </body> </html> Take some time to look over the code and understand it — the comments inside the code should also help you to understand it. We aren't asking you to do much else in this article, because the key to understanding document layout is writing a sound HTML structure, and then laying it out with CSS. We'll wait for this until you start to study CSS layout as part of the CSS topic.\n\nSometimes you'll come across a situation where you can't find an ideal semantic element to group some items together or wrap some content. Sometimes you might want to just group a set of elements together to affect them all as a single entity with some CSS or JavaScript. For cases like these, HTML provides the and elements. You should use these preferably with a suitable attribute, to provide some kind of label for them so they can be easily targeted. is an inline non-semantic element, which you should only use if you can't think of a better semantic text element to wrap your content, or don't want to add any specific meaning. For example: <p> The King walked drunkenly back to his room at 01:00, the beer doing nothing to aid him as he staggered through the door. <span class=\"editor-note\"> [Editor's note: At this point in the play, the lights should be down low]. </span> </p> In this case, the editor's note is supposed to merely provide extra direction for the director of the play; it is not supposed to have extra semantic meaning. For sighted users, CSS would perhaps be used to distance the note slightly from the main text. is a block level non-semantic element, which you should only use if you can't think of a better semantic block element to use, or don't want to add any specific meaning. For example, imagine a shopping cart widget that you could choose to pull up at any point during your time on an e-commerce site: This isn't really an , as it doesn't necessarily relate to the main content of the page (you want it viewable from anywhere). It doesn't even particularly warrant using a , as it isn't part of the main content of the page. So a is fine in this case. We've included a heading as a signpost to aid screen reader users in finding it. Warning: Divs are so convenient to use that it's easy to use them too much. As they carry no semantic value, they just clutter your HTML code. Take care to use them only when there is no better semantic solution and try to reduce their usage to the minimum otherwise you'll have a hard time updating and maintaining your documents.\n\nTwo elements that you'll use occasionally and will want to know about are and . creates a line break in a paragraph; it is the only way to force a rigid structure in a situation where you want a series of fixed short lines, such as in a postal address or a poem. For example: <p> There once was a man named O'Dell<br /> Who loved to write HTML<br /> But his structure was bad, his semantics were sad<br /> and his markup didn't read very well. </p> Without the elements, the paragraph would just be rendered in one long line (as we said earlier in the course, HTML ignores most whitespace); with elements in the code, the markup renders like this: elements create a horizontal rule in the document that denotes a thematic change in the text (such as a change in topic or scene). Visually it just looks like a horizontal line. As an example: <p> Ron was backed into a corner by the marauding netherbeasts. Scared, but determined to protect his friends, he raised his wand and prepared to do battle, hoping that his distress call had made it through. </p> <hr /> <p> Meanwhile, Harry was sitting at home, staring at his royalty statement and pondering when the next spin off series would come out, when an enchanted distress letter flew through his window and landed in his lap. He read it hazily and sighed; \"better get back to work then\", he mused. </p>"
    },
    {
        "link": "https://w3schools.com/html/html5_syntax.asp",
        "document": "Consistent, clean, and tidy HTML code makes it easier for others to read and understand your code.\n\nHere are some guidelines and tips for creating good HTML code.\n\nAlways declare the document type as the first line in your document.\n\nThe correct document type for HTML is:\n\nHTML allows mixing uppercase and lowercase letters in element names.\n\nHowever, we recommend using lowercase element names, because:\n\nIn HTML, you do not have to close all elements (for example the element).\n\nHowever, we strongly recommend closing all HTML elements, like this:\n\nHTML allows mixing uppercase and lowercase letters in attribute names.\n\nHowever, we recommend using lowercase attribute names, because:\n\nHowever, we recommend quoting attribute values, because:\n• You MUST use quotes if the value contains spaces\n\nAlways Specify alt, width, and height for Images\n\nAlways specify the attribute for images. This attribute is important if the image for some reason cannot be displayed.\n\nAlso, always define the and of images. This reduces flickering, because the browser can reserve space for the image before loading.\n\nHTML allows spaces around equal signs. But space-less is easier to read and groups entities better together.\n\nWhen using an HTML editor, it is NOT convenient to scroll right and left to read the HTML code.\n\nTry to avoid too long code lines.\n\nDo not add blank lines, spaces, or indentations without a reason.\n\nFor readability, add blank lines to separate large or logical code blocks.\n\nFor readability, add two spaces of indentation. Do not use the tab key.\n\nThe element is required in HTML.\n\nThe contents of a page title is very important for search engine optimization (SEO)! The page title is used by search engine algorithms to decide the order when listing pages in search results.\n• provides a title for the page when it is added to favorites\n• displays a title for the page in search-engine results\n\nSo, try to make the title as accurate and meaningful as possible:\n\nAn HTML page will validate without the and tags:\n\nHowever, we strongly recommend to always add the and tags!\n\nOmitting and can also crash DOM and XML software.\n\nThe HTML <head> tag can also be omitted.\n\nBrowsers will add all elements before , to a default element.\n\nHowever, we recommend using the tag.\n\nIn HTML, it is optional to close empty elements.\n\nIf you expect XML/XHTML software to access your page, keep the closing slash (/), because it is required in XML and XHTML.\n\nYou should always include the attribute inside the tag, to declare the language of the Web page. This is meant to assist search engines and browsers.\n\nTo ensure proper interpretation and correct search engine indexing, both the language and the character encoding should be defined as early as possible in an HTML document:\n\nThe viewport is the user's visible area of a web page. It varies with the device - it will be smaller on a mobile phone than on a computer screen.\n\nYou should include the following element in all your web pages:\n\nThis gives the browser instructions on how to control the page's dimensions and scaling.\n\nThe part sets the width of the page to follow the screen-width of the device (which will vary depending on the device).\n\nThe part sets the initial zoom level when the page is first loaded by the browser.\n\nHere is an example of a web page without the viewport meta tag, and the same web page with the viewport meta tag:\n\nShort comments should be written on one line, like this:\n\nComments that spans more than one line, should be written like this:\n\nLong comments are easier to observe if they are indented with two spaces.\n\nUse simple syntax for linking to style sheets (the attribute is not necessary):\n\nShort CSS rules can be written compressed, like this:\n\nLong CSS rules should be written over multiple lines:\n• Place the opening bracket on the same line as the selector\n• Use one space before the opening bracket\n• Use two spaces of indentation\n• Use semicolon after each property-value pair, including the last\n• Only use quotes around values if the value contains spaces\n• Place the closing bracket on a new line, without leading spaces\n\nUse simple syntax for loading external scripts (the attribute is not necessary):\n\nUsing \"untidy\" HTML code can result in JavaScript errors.\n\nThese two JavaScript statements will produce different results:\n\nSome web servers (Apache, Unix) are case sensitive about file names: \"london.jpg\" cannot be accessed as \"London.jpg\".\n\nOther web servers (Microsoft, IIS) are not case sensitive: \"london.jpg\" can be accessed as \"London.jpg\".\n\nIf you use a mix of uppercase and lowercase, you have to be aware of this.\n\nIf you move from a case-insensitive to a case-sensitive server, even small errors will break your web!\n\nTo avoid these problems, always use lowercase file names!\n\nHTML files should have a .html extension (.htm is allowed).\n\nThere is no difference between the .htm and .html file extensions!\n\nBoth will be treated as HTML by any web browser and web server.\n\nWhen a URL does not specify a filename at the end (like \"https://www.w3schools.com/\"), the server just adds a default filename, such as \"index.html\", \"index.htm\", \"default.html\", or \"default.htm\".\n\nIf your server is configured only with \"index.html\" as the default filename, your file must be named \"index.html\", and not \"default.html\".\n\nHowever, servers can be configured with more than one default filename; usually you can set up as many default filenames as you want."
    },
    {
        "link": "https://almabetter.com/bytes/tutorials/html/html5-structure",
        "document": "The basic structure of an HTML (Hypertext Markup Language) document refers to the overall organization and syntax of an HTML file. It consists of several elements that provide information about the web page's content, structure, and formatting.\n\nThe basic structure of an HTML document includes the following components:\n\n1.<!DOCTYPE html>: This declaration specifies the version of HTML that the document is written in. It is usually the first line of an HTML file.\n\n2.<html> element: This is the root element of the document and encloses all other elements.\n\n3.<head> element: This element contains metadata about the document, such as the title, author, and character set. It does not contain any visible content on the page.\n\n4.<title> element: This element is nested within the head element and specifies the title of the web page, which appears in the browser's title bar.\n\n5.<body> element: This element contains all visible content on the page, such as text, images, links, and other HTML elements.\n\n6.Other HTML elements: These are additional elements used to structure and format the content within the body element, such as headings, paragraphs, lists, tables, and more.\n\nBy following this basic structure, web developers can create consistent and well-organized HTML documents that are easy to understand and maintain.\n\nEvery HTML document begins with a document type declaration, which tells the browser what type of HTML the document is written in. The <!DOCTYPE html> declaration is an instruction that tells the web browser which version of HTML is being used in the document.\n\nThe DOCTYPE declaration is required in HTML documents to ensure that the browser renders the page in standards mode. Standards mode ensures that the web page is displayed consistently across different browsers and platforms.\n\nThe <!DOCTYPE html> declaration is used in HTML5 to indicate that the document is written in the latest version of HTML. It is usually placed at the beginning of an HTML document, before the <html> tag.\n\nThe <html>element is the root element of an HTML document and represents the top-level container for all other HTML elements in the document. It tells the browser that the document is an HTML document and encloses the entire HTML document, including the <head> and <body> elements. The HTML tag is opened at the beginning of the document and closed at the end of the document.\n\nThe <html> element also specifies the language of the document using the lang attribute. For example, to specify that the document is written in English, you would add the following attribute to the <html> tag:\n\nThe <head> element is a container for metadata about an HTML document, such as the title of the page, links to stylesheets and scripts, and other information that is not directly visible on the page.\n\nHere's an example of how the <head> element is used in an HTML document:\n\nIn this example, the <head> element contains several elements that provide metadata about the document:\n• <title>: This element specifies the title of the web page, which appears in the browser's title bar and is used by search engines to index the page.\n• <meta>: This element provides information about the character set used in the document. In this example, the charset attribute specifies that the document is encoded using UTF-8.\n• <link>: This element specifies the location of an external stylesheet that is used to define the visual style of the web page.\n• <script>: This element specifies the location of an external JavaScript file that is used to add interactivity to the web page.\n\nOverall, the <head> element is an important part of an HTML document as it provides information about the document that is used by the browser and other software to render the page correctly.\n\nIn HTML, the <body> element represents the content of an HTML document that is visible in a web browser. It is the main container for all the content that is displayed on a webpage, such as text, images, videos, and other HTML elements.\n\nThe <body> element typically comes after the <head> element in an HTML document, which contains information about the document that is not displayed in the browser, such as metadata and scripts. The content of the <body> element is what is rendered in the browser window, and it can include other HTML elements such as headings, paragraphs, lists, links, images, forms, and more.\n\nHere is an example of a basic HTML document structure that includes a <body> element:\n\nIn this example, the <body> element contains a heading (<h1>), a paragraph (<p>), and an image (<img>). When this HTML document is loaded in a web browser, these elements will be displayed in the main content area of the webpage.\n\nThe Opening and the Closing Tags\n\nIn HTML, elements are usually written as opening tags, content, and closing tags. The opening tag is denoted by the angle bracket \"<\", followed by the name of the element, and then another angle bracket \">\". The closing tag has the same name as the opening tag, but with a forward slash \"/\" before the name, and then another angle bracket \">\".\n\nFor example, consider the following HTML code:\n\nIn this code, <p> is the opening tag, and </p> is the closing tag. The content of the paragraph, \"This is a paragraph.\", is located between the opening and closing tags.\n\nIt is important to include both the opening and closing tags in your HTML code to ensure that the web browser can properly interpret the content and render it correctly on the webpage. If a closing tag is omitted, the web browser may not be able to properly interpret the HTML code, leading to display issues on the webpage.\n\nIn conclusion, the basic structure of an HTML document includes several elements that provide information about the web page's content, structure, and formatting. The HTML document begins with the <!DOCTYPE html> declaration, which specifies the version of HTML that the document is written in. The root element of the document is the <html> element, which encloses all other elements. The <head> element contains metadata about the document, such as the title, author, and character set, while the <body> element contains all visible content on the page. By following this basic structure, web developers can create consistent and well-organized HTML documents that are easy to understand and maintain."
    },
    {
        "link": "https://kinsta.com/blog/html-best-practices",
        "document": "HTML best practices help developers offer innovative and highly interactive websites and web apps. These best practices help you develop the most feature-rich and business-centric applications. Plus, organizations can harness these best practices to provide a seamless user experience.\n\nToday, when we talk about HTML, we typically discuss HTML5 (and not its immediate predecessors). HTML5 is a powerful markup language that allows web developers to create a web document. It’s easy to use and understand, and almost all browsers support it. Also, it’s the foundation of almost all Content Management Systems (CMS)\n\nAs a web developer with minimal experience, questions such as “How can I write better HTML?” often arise. This article aims to help you get started on the right foot.\n\nYou probably already have a grasp of this markup language, but here are some HTML5 best practices that will let you code better.\n\nWhen creating an HTML document, the declaration is required for informing the browser what standards you’re using. Its purpose is to render your markup correctly.\n\nThe declaration should be in the first line of your HTML document. Here is a comparison between its right and wrong implementation:\n\nAlternatively, you can use the doctype corresponding to the HTML/XHTML version you want to use. Learn about the recommended list of doctype declarations to help you choose the right one.\n\nDevelopers know that the purpose of tags is to help web browsers distinguish between HTML content and ordinary content. HTML tags contain an opening tag, content, and closing tag. However, they’re often confused about the proper placement of tags, the elements that require closing tags, or when to omit tags.\n\nFor instance, where’s the best place to put tags?\n\nScript tags are typically placed inside the element. But a modern HTML best practice is to place them at the bottom of the document instead, before closing the tag, to delay their download. The webpage will load the Document Object Model (DOM) first, show it to the user, and then request the scripts afterward, reducing time to first byte (TTFB).\n\nThe browser interprets your HTML document line by line from top to bottom. So, when it reads the head and comes across a script tag, it starts a request to the server to get the file. There’s nothing inherently wrong with this process, but if the page is loading a huge file, it will take a long time and greatly affect the user experience.\n\nUnder the root element is the , or language, attribute. This attribute helps in translating an HTML document into the proper language. The best practice is to keep this attribute’s value as short as possible.\n\nFor example, the Japanese language is mostly used in Japan. Therefore, the country code is not necessary when targeting the Japanese language.\n\nOne of the most common HTML best practices is to check on the do’s and don’ts. Here are some known don’ts in HTML coding:\n\nLike any coding practice, the “keep it simple” principle is very applicable to HTML and HTML5. Generally, HTML5 is compatible with older HTML versions and XHTML. For that reason, we recommend avoiding the use of XML declarations or attributes.\n\nYou don’t need to declare code as such unless you want to write an XHTML document. Similarly, you don’t need XML attributes, such as:\n\nDevelopers should code with SEO in mind. Web contents that are not found are also not indexed. For that reason, here are some best SEO best practices to consider:\n\nThe tag is a handy tag, but misusing it may result in some non-intuitive behaviors. Thus, if you declare a base tag, then every link in the document will be relative unless explicitly specified:\n\nThis syntax changes the default behavior of some links. For example, linking to an external webpage with only the page name and extension:\n\nOr the browser will interpret it as:\n\nThis interpretation becomes chaotic, so it’s safer to always use absolute paths for your links.\n\nOn the other hand, writing metatag descriptions is not strictly a part of HTML best practices, but it’s still equally important. The attribute is what search engine crawlers reference when they index your page, so it’s vital to your SEO health.\n\nThe tag makes a web page search engine-friendly. For one thing, the text inside the tag appears in Google’s Search Engine Result Pages (SERP) and the user’s web browser bar and tabs.\n\nTake, for example, when you search the keyword “HTML5.” The title in this search result indicates the specific title attribute and the author. This is very important in SEO and site traffic generation.\n\nImages Must Have an Alt Attribute\n\nUsing a meaningful alt attribute with elements is a must for writing valid and semantic code.\n\nIn the table below, the bad practice column shows an element without an alt attribute. Although the second example in the same column has an alt attribute, its value is meaningless.\n\nThe meta description is an HTML element that describes and summarizes the contents of a webpage. Its purpose is for the users to find the context of the page. Although metadata doesn’t help anymore with SEO rankings, the meta description still plays a significant role in on-page SEO.\n\nHere is a sample code that includes the keywords, description, author’s name, and character set. The character set is used to support almost all the characters and symbols from different languages. On the other hand, you can set cookies, add a revision date, and allow the page to refresh.\n\nIn the anchor elements, the best practice is to use title attributes to improve accessibility. The title attribute increases the meaning of the anchor tag. The tag (or anchor element) paired with its attribute, creates a hyperlink to web pages, email addresses, and files. It is used to link locations within the same page or external addresses.\n\nCheck the example under the bad practice column — it’s there for being redundant. This type of practice is evident if a user uses a screen reader to read the anchor tag and read the same text twice to the listener. A screen reader is an assistive technology provided to the visually impaired or those with a learning disability. As a good practice, if you’re just repeating the anchor’s text, then it’s better not to use a title at all.\n\nWebsite development isn’t simply a matter of creating a block of text and headers, link pages, and you’re done. There are some best practices in HTML to consider to make the best of your website.\n\nThe HTML documents will still work without the primary elements: , , and . However, pages may not render correctly if these elements are missing. To that end, it’s important to use proper document structure consistently.\n\nFor a thematic grouping of content, use the section element. According to the W3C specification, a should contain a heading (H1, H2, etc.). Some developers skip the use of the heading element entirely, but we recommend including it to reach those better using screen readers:\n\nThe tag serves as a container for an external resource. This includes web pages, pictures, videos, or plug-ins. However, you must consider that most browsers no longer support Java Applets and plug-ins. What’s more, ActiveX controls are no longer supported in any browser, and the support for Shockwave Flash has also been turned off in modern browsers.\n\nWe recommend the following:\n• For a picture, use the tag.\n• For HTML pulled in from another site, use the tag.\n• For videos or audios, use the and tags.\n\nThe alt attribute in the element provides an image description useful to search engines and screen readers. It can come in especially handy to users when the images can’t be processed:\n\nLeave the alt attribute empty if there’s supplemental text to explain the image. This is to avoid redundancy:\n\nLeave elements empty if there are some restrictions in its content. An empty iframe element is always safe:\n\nDevelopers should provide fallback content, or backup links, for any or elements, just as with images. Fallback content is needed, especially for newly introduced elements in HTML:\n\nHTML documents become complicated, especially for web pages with a lot of content. It’s best to reduce the number of elements on a page to as few as you can manage. Learn how to use the heading elements wisely and follow how to elements denote HTML’s content hierarchy. This makes your content more meaningful for your readers, screen-reading software, and search engines.\n\nFor WordPress developers and content creators, use the element for the blog post’s title instead of the site’s name. This helps in search engine crawling, and this approach is SEO-friendly.\n\nIn addition, use the right HTML element to convey the information it contains to achieve a semantic and meaningful content structure. For example, use for emphasis and for heavy emphasis instead of their predecessors or , which are now deprecated.\n\nJust as importantly, use for paragraphs, and avoid using to add a new line between paragraphs. Instead, make use of CSS margin and/or padding properties to position your content better. Sometimes, you might find yourself tempted to use the tag for indentation purposes. Avoid this pitfall — use it exclusively when quoting text.\n\nOne of the best HTML best practices is to use semantically appropriate elements in your page layout. Several elements will help you organize your layout in sections.\n\nWith the wide breadth of topics under HTML layout, it’s best to highlight the do’s and don’ts in layout quickly. For instance, HTML gives more semantic meaning to the header and footer elements, so don’t neglect the use of the tag as it’s used in any given section or article. Aside from controlling the and tags and other stylistic elements of the document, it’s used in headings, publish dates, and other introductory content of your page or section. Similarly, you can do away with the notion that footers belong to the copyright section only — now, you can use it just about everywhere.\n\nFor the element, you should use it for site-wide navigation. There is no need to declare a role as the usage is already implied in the tag.\n\nAs for the element, it is already part of the latest HTML5 versions, which denote the main content of the document body. So, there is no longer any need to use when we have a more specific tag for our main content.\n\nThe is used for a content block. It is a stand-alone and makes sense without the need to give further explanation, while the tag is used to divide a page into different subject areas or to section an individual article. Unfortunately, many developers still use the two interchangeably.\n\nConsider that the tag is a more generic tag than the tag. This means that the former denotes content related to the topic at hand, but not necessarily self-contained. The latter, conversely, is a stand-alone property.\n\nBut when there’s no appropriate markup tag for your purposes, what should you use? The answer is to use when no other element works or when it’s a specifically stylistic element. For our purposes, using is also a bad practice.\n\nLet’s go back to the tag, which is a semantic markup tag. It is not a stylistic one, and it is important to emphasize it. In effect, a good coding practice should include a heading tag.\n\nNow, the don’ts with follows that you shouldn’t use it to tag a wrapper, a container, or any other purely stylistic block. Below is an example of bad coding practice with the tag:\n\nHere is a better approach, but it overuses the tag:\n\nHence, a much better coding practice is:\n\nA popular part of many layouts are figures for data representation, and the element is mostly used with pictures. However, it has a wider range of possible uses, as anything related to the document could be positioned anywhere and wrapped in a element. Some examples include illustrations, tables, or diagrams in a book.\n\nAn interesting characteristic of is that it does not contribute to the document’s outline. Therefore, you can use it to group elements with a common theme — for instance, several images with one common , or even a block of code.\n\nIn grouping elements with , use . The caption should go either directly after the opening tag, or directly before the closing tag :\n\nHTML is one of the core technologies in web development. It has awesome power and features that made it popular with developers and business owners. Frontend development keeps on innovating, and to keep up with it, developers should know the best practices in HTML scripting.\n\nInline styles will make your code cluttered and unreadable. To that end, always link to and use external stylesheets. Also, avoid using import statements in your CSS files as they produce an extra server request.\n\nThe same goes for inline CSS and JavaScript. Apart from readability issues, this will make your document heavier and more difficult to maintain so that you can avoid inlining code.\n\nUsing lowercase characters in code is an industry-standard practice. Although using uppercase or other text cases will still render your page, the problem is not standardization but code readability.\n\nCode readability is an important aspect of coding as it helps make applications maintainable and secure. Not only that, web development mostly comprises a team. Making your code readable makes your work and the work of your team less complicated.\n\nWhile there are many don’ts in coding HTML, we’ll share two basics don’ts in scripting:\n• Write well-indented and consistently formatted codes: Clean and well-written code promotes better readability on your site, which is a huge help to your developer and other people who might work with the site. It also shows great professionalism and attention to detail, reflecting well on your attitude as a developer.\n• Refrain from including excessive comments: Comments are essential and make your code easier to understand. However, HTML syntax is very self-explanatory, so commenting is not necessary unless you have to clarify semantics and naming conventions.\n\nValidating and minifying codes are used to identify errors early on. Don’t wait until you finish your HTML document — make it a habit to validate and identify errors frequently. You can do validation either manually or use any known validator tool such as W3C Markup Validator.\n\nAt the same time, practice minification by removing anything that is not essential such as comments or whitespace. Ensure that you write clean and concise codes to reduce the size of your HTML file. You can use tools such as HTML Minifier and others.\n\nMany HTML5 best practices resources for 2021 are available online to assist you. However, remember the general rule in coding: consistency. This article has provided basic insights and helped you kick-start that frontend development journey. Using this guide, you’ll be an expert in semantically correct HTML5 in no time.\n\nWhen you’re ready, look beyond what HTML can offer and explore some open source HTML frameworks too for building modern, single-page web apps. They offer excellent synchronization between the data and UI and work seamlessly with CSS and JavaScript.\n\nDid we miss any HTML best practices that you use in your own coding? Let us know in the comments section!"
    },
    {
        "link": "https://web.dev/learn/html/document-structure",
        "document": "HTML documents include a document type declaration and the root element. Nested in the element are the document head and document body. While the head of the document isn't visible to the sighted visitor, it is vital to make your site function. It contains all the meta information, including information for search engines and social media results, icons for the browser tab and mobile home screen shortcut, and the behavior and presentation of your content. In this section, you'll discover the components that, while not visible, are present on almost every web page.\n\nTo create the MachineLearningWorkshop.com (MLW) site, start by including the components that should be considered essential for every web page: the type of document, the content's human language, the character set, and, of course, the title or name of the site or application.\n\nThere are several features that should be considered essential for any and every web page. Browsers will still render content if these elements are missing, but include them. Always.\n\nThe first thing in any HTML document is the preamble. For HTML, all you need is . This may look like an HTML element, but it isn't. It's a special kind of node called \"doctype\". The doctype tells the browser to use standards mode. If omitted, browsers will use a different rendering mode known as quirks mode. Including the doctype helps prevent quirks mode.\n\nThe element is the root element for an HTML document. It is the parent of the and , containing everything in the HTML document other than the doctype. If omitted it will be implied, but it is important to include it, as this is the element on which the language of the content of the document is declared.\n\nThe language attribute added to the tag defines the main language of the document. The value of the attribute is a two- or three-letter ISO language code followed by the region. The region is optional, but recommended, as a language can vary greatly between regions. For example, French is very different in Canada ( ) versus Burkina Faso ( ). This language declaration enables screen readers, search engines, and translation services to know the document language.\n\nThe attribute is not limited to the tag. If there is text within the page that is in a language different from the main document language, the attribute should be used to identify exceptions to the main language within the document. Just like when it is included in the head, the attribute in the body has no visual effect. It only adds semantics, enabling assistive technologies and automated services to know the language of the impacted content.\n\nIn addition to setting the language for the document and exceptions to that base language, the attribute can be used in CSS selectors. can be targeted with the attribute and language selectors and .\n\nNested between the opening and closing tags, we find the two children: and :\n\nThe , or document metadata header, contains all the metadata for a site or application. The body contains the visible content. The rest of this section focuses on the components found nested inside the opening and closing\n\nThe document metadata, including the document title, character set, viewport settings, description, base URL, stylesheet links, and icons, are found in the element. While you may not need all these features, always include character set, title, and viewport settings.\n\nThe very first element in the should be the character encoding declaration. It comes before the title to ensure the browser can render the characters in that title and all the characters in the rest of the document.\n\nThe default encoding in most browsers is , depending on the locale. However, you should use , as it enables the one- to four-byte encoding of all characters, even ones you didn't even know existed. Also, it's the encoding type required by HTML5.\n\nTo set the character encoding to UTF-8, include:\n\nBy declaring (case-insensitive), you can even include emojis in your title (but please don't).\n\nThe character encoding is inherited into everything in the document, even and . This little declaration means you can include emojis in class names and the selectorAPI (again, please don't). If you do use emojis, make sure to use them in a way that enhances usability without harming accessibility.\n\nYour home page and all additional pages should each have a unique title. The contents for the document title, the text between the opening and closing tags, are displayed in the browser tab, the list of open windows, the history, search results, and, unless redefined with tags, in social media cards.\n\nThe other meta tag that should be considered essential is the viewport meta tag, which helps site responsiveness, enabling content to render well by default, no matter the viewport width. While the viewport meta tag has been around since June 2007, when the first iPhone came out, it's only recently been documented in a specification. As it enables controlling a viewport's size and scale, and prevents the site's content from being sized down to fit a 960px site onto a 320px screen, it is definitely recommended.\n\nThe preceding code means \"make the site responsive, starting by making the width of the content the width of the screen\". In addition to , you can set zoom and scalability, but they both default to accessible values. If you want to be explicit, include:\n\nViewport is part of the Lighthouse accessibility audit; your site will pass if it is scalable and has no maximum size set.\n\nSo far, the outline for our HTML file is:\n\nThere's a lot more that goes into the . All the metadata, in fact. Most of the elements you'll find in the are covered here, while saving a plethora of the options for the next chapter.\n\nYou've seen the meta character set and the document title, but there is a lot more metadata outside of tags that should be included.\n\nThe is where you include styles for your HTML. There is a learning path dedicated to CSS if you want to learn about styles, but you do need to know how to include them in your HTML documents.\n\nThere are three ways to include CSS: , , and the attribute.\n\nThe main two ways to include styles in your HTML file are by including an external resource using a element with the attribute set to , or including CSS directly in the head of your document within opening and closing tags.\n\nThe tag is the preferred method of including stylesheets. Linking a single or a few external style sheets is good for both developer experience and site performance: you get to maintain CSS in one spot instead of it being sprinkled everywhere, and browsers can cache the external file, meaning it doesn't have to be downloaded again with every page navigation.\n\nThe syntax is , where styles.css is the URL of your stylesheet. You'll often see . Not necessary! If you are including styles written in something other than CSS, the is needed, but since there isn't any other type, this attribute isn't needed. The attribute defines the relationship: in this case . If you omit this, your CSS will not be linked.\n\nYou'll discover a few other values shortly, but let's first discuss other ways of including CSS.\n\nIf you want your external style sheet styles to be within a cascade layer but you don't have access to edit the CSS file to put the layer information in it, you'll want to include the CSS with inside a :\n\nWhen using to import style sheets into your document, optionally into cascade layers, the statements must be the first statements in your or linked stylesheet, outside of the character set declaration.\n\nWhile cascade layers are still fairly new and you might not spot the in a head , you will often see custom properties declared in a head style block:\n\nStyles, either via or , or both, should go in the head. They will work if included in the document's body, but you want your styles in the head for performance reasons. That may seem counterintuitive, as you may think you want your content to load first, but you actually want the browser to know how to render the content when it is loaded. Adding styles first prevents the unnecessary repainting that occurs if an element is styled after it is first rendered.\n\nThen there's the one way of including styles you'll never use in the of your document: inline styles. You'll probably never use inline styles in the head because the user agents' style sheets hide the head by default. But if you want to make a CSS editor without JavaScript, for example, so you can test your page's custom elements, you can make the head visible with , and then hide everything in the head, and then with an inline attribute, make a content-editable style block visible.\n\nWhile you can add inline styles on the , it's way more fun to style your in your . I digress.\n\nOther uses of the element\n\nThe element is used to create relationships between the HTML document and external resources. Some of these resources may be downloaded, others are informational. The type of relationship is defined by the value of the attribute. There are currently 25 available values for the attribute that can be used with , and , or , with a few that can be used with all. It's preferable to include those related to meta information in the head and those related to performance in the .\n\nYou'll include three other types in your header now: , , and . (You'll include a fourth type, , in the next module).\n\nUse the tag, with the attribute/value pair to identify the favicon to be used for your document. A favicon is a very small icon that appears on the browser tab, generally to the left of the document title. When you have an unwieldy number of tabs open, the tabs will shrink and the title may disappear altogether, but the icon always remains visible. Most favicons are company or application logos.\n\nIf you don't declare a favicon, the browser will look for a file named in the top-level directory (the website's root folder). With , you can use a different file name and location:\n\nThe preceding code says \"use the as the icon for scenarios where a 16px, 32px, or 48px makes sense.\" The sizes attribute accepts the value of for scalable icons or a space-separated list of square values; where the width and height values are 16, 32, 48, or greater in that geometric sequence, the pixel unit is omitted, and the X is case-insensitive.\n\nThere are two special non-standard kind of icons for Safari browser: for iOS devices and for pinned tabs on macOS. is applied only when the user adds a site to home screen: you can specify multiple icons with different for different devices. will only be used if the user pins the tab in desktop Safari: the icon itself should be a monochrome SVG, and the attribute fills the icon with needed color.\n\nWhile you can use to define a completely different image on each page or even each page load, don't. For consistency and a good user experience, use a single image! Twitter uses the blue bird: when you see the blue bird in your browser tab, you know that tab is open to a Twitter page without clicking on the tab. Google uses different favicons for each of its different applications: there's a mail icon, a calendar icon, for example. But all the Google icons use the same color scheme. Again, you know exactly what the content of an open tab is simply from the icon.\n\nWe use the value of the attribute to identify translations, or alternate representations, of the site.\n\nLet's pretend we have versions of the site translated into French and Brazilian Portuguese:\n\nWhen using for a translation, the attribute must be set.\n\nThe alternate value is for more than just translations. For example, the attribute can define the alternate URI for an RSS feed when the attribute is set to or . Let's link to a pretend PDF version of the site.\n\nIf the value is , it defines an alternate stylesheet and the attribute must be set giving that alternate style a name.\n\nIf you create several translations or versions of Machine Learning Workshop, search engines may get confused as to which version is the authoritative source. For this, use to identify the preferred URL for the site or application.\n\nInclude the canonical URL on all of your translated pages, and on the home page, indicating our preferred URL:\n\nThe canonical link is most often used for cross-posting with publications and blogging platforms to credit the original source; when a site syndicates content, it should include the canonical link to the original source.\n\nThe tag is used to include, well, scripts. The default type is JavaScript. If you include any other scripting language, include the attribute with the mime type, or if it's a JavaScript module. Only JavaScript and JavaScript modules get parsed and executed.\n\nThe tags can be used to encapsulate your code or to download an external file. In MLW, there is no external script file because contrary to popular belief, you don't need JavaScript for a functional website, and, well, this is an HTML learning path, not a JavaScript one.\n\nYou will be including a tiny bit of JavaScript to create an Easter egg later on:\n\nThis snippet creates an event handler for an element with the id of . With JavaScript, you don't want to reference an element before it exists. It doesn't exist yet, so we won't include it yet. When we do add the light switch element, we'll add the at the bottom of the rather than in the . Why? Two reasons. We want to ensure elements exist before the script referencing them is encountered as we're not basing this script on a DOMContentLoaded event. And, mainly, JavaScript is not only render-blocking, but the browser stops downloading all assets when scripts are downloaded and doesn't resume downloading other assets until the JavaScript has finished execution. For this reason, you will often find JavaScript requests at the end of the document rather than in the head.\n\nThere are two attributes that can reduce the blocking nature of JavaScript download and execution: and . With , HTML rendering is not blocked during the download, and the JavaScript only executes after the document has otherwise finished rendering. With , rendering isn't blocked during the download either, but once the script has finished downloading, the rendering is paused while the JavaScript is executed.\n\nTo include MLW's JavaScript in an external file, you could write:\n\nAdding the attribute defers the execution of the script until after everything is rendered, preventing the script from harming performance. The and attributes are only valid on external scripts.\n\nThere is another element that is only found in the Not used very often, the element allows setting a default link URL and target. The attribute defines the base URL for all relative links.\n\nThe attribute, valid on as well as on links and forms, sets where those links should open. The default of opens linked files in the same context as the current document. Other options include , which opens every link in a new window, the of the current content, which may be the same as self if the opener is not an iframe, or , which is in the same browser tab, but popped out of any context to take up the entire tab.\n\nMost developers add the attribute to the few, if any, links they want to open in a new window on the links or form themselves, rather than using .\n\nIf our website found itself nested within an iframe on a site like Yummly, including the element would mean when a user clicks on any links within our document, the link will load popped out of the iframe, taking up the whole browser window.\n\nOne of the drawbacks of this element is that anchor links are resolved with . The effectively converts the link to , triggering an HTTP request to the base URL with the fragment attached.\n\nA few other things to note about : there can be only one element in a document, and it should come before any relative URLs are used, including possible script or stylesheet references.\n\nThe code now looks like this:\n\nNote that the script is wrapped between some angle brackets, dashes, and a bang. This is how you comment out HTML. We'll leave the script commented out until we have the actual content on the page. Anything between and will not be visible or parsed. HTML comments can be put anywhere on the page, including the head or body, with the exception of scripts or style blocks, where you should use JavaScript and CSS comments, respectively.\n\nYou have covered the basics of what goes in the , but you want to learn more than the basics. In the next sections, we will learn about meta tags, and how to control what gets displayed when your website is linked to on social media."
    },
    {
        "link": "http://web.simmons.edu/~grabiner/comm244/weekfour/css-concepts.html",
        "document": "Now that you're starting to get used to using some basic CSS rules, it's time to start learning the \"big concepts\" of CSS. Inheritance, the Cascade, and Specificity are the big three. Understanding these concepts will allow you to write very powerful stylesheets and also save time by writing fewer CSS rules.\n\nIn CSS, some styles are inherited down the HTML document tree while others are not.\n\nWhile this can be confusing, the principle behind it is actually designed to allow to write fewer CSS rules.\n\nStyles that are inherited are generally related to the styling of the document text.\n\nThe font property is inherited. This is why we generally use the <body> element to attach our font styles.\n\nThe element in our HTML is the parent of all of our other HTML elements (excluding the section). Setting the font property on the element allows the rest of the document to inherit the font rule.\n\nUsing the rule above, all text (unless we specify otherwise) will be 14px with an 18px line height and be Helvetica or Verdana.\n\nStyles That Are Not Inherited\n\nStyles that are not inherited are usually related to the appearance of elements.\n\nFor example, the border property is not inherited, because it would not make sense. Remember what happens when we used the universal selector to set the border property?\n\nIn general, you can just use common sense to figure out if a property is inherited or not. Think to yourself, \"Would it make sense for this property to be inherited?\"\n\nIf simple reasoning fails, the following CSS reference page lists many CSS properties. The right column indicates whether or not the property is inherited.\n\nCSS rules often conflict with one another. In fact, this is what we want. The trick is understanding how conflicting rules will apply.\n\nSpecificity is one of the ways that conflicting rules are applied.\n\nSelectors have different values of importance (or specificity). Here is the short list (listed in order of importance):\n\nIf multiple CSS rules conflict with one another, the most important or specific selector is the one that will apply.\n\nUsually, we combine different types of selectors in our CSS to make the rules. We can use a relatively simple technique to rate the specificity level of each rule.\n\nAssume we have the following HTML snippet:\n\nNow assume we have the following CSS rules (line numbers added for clarity):\n\nThere is a simple scoring system for each style that you plug into a three-value layout like this:\n• Add one to A for each ID in the selector\n• Add one to B for each class or pseudo class in the selector\n• Add one to C for each element name\n\nSo, The CSS rules 1-3 in the above code all apply to the same tag. Which one wins?\n\nAs we can see, the selector wins, because it is the most specific. The text color in the will be blue.\n\nFor those of you that are not so mathematically inclined, there's always this graphical method.\n\nWe've already talked about how there can be many different sources of CSS styles. How do we know which one will be used?\n\nIn CSS, styles sheets cascade by order of importance. If rules in different style sheets conflict with one another, the rule from the most important style sheet wins.\n\nBelow is a list of possible sources of a CSS rule. They are listed by order of importance. As the creator of the style sheet, you're the author.\n\nWe've already seen the cascade in action. All browsers have a default style sheet, which is designated as the least important.\n\nWhat happens when conflicts occur?\n\nThere may be times when two or more declarations are applied to the same element. It is also possible that there may be a conflict between them. When conflicts like this occur, the declaration with the most weight is used. So, how is weight determined?\n• Find all declarations whose selectors match a particular element.\n• Sort these declarations by weight and origin\n\nFor a complete description of these rules, see What happens when conflicts occur?\n\nIn CSS, the order in which we specify our rules matters.\n\nIf a rule from the same style sheet, with the same level of specificity exists, the rule that is declared last in the CSS document will be the one that is applied.\n\nAn example will illustrate this best.\n\nIn the code above, we have created rules for paragraphs to be three different colors. Clearly, these rules conflict with one another.\n\nRule #3 is the most specific because it specifies all paragraphs that also have the class attribute value of .\n\nRule #4 is declared last in the CSS document and therefore, overrides the previously declared Rule #1."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_cascade/Specificity",
        "document": "Specificity is an algorithm that calculates the weight that is applied to a given CSS declaration. The weight is determined by the number of selectors of each weight category in the selector matching the element (or pseudo-element). If there are two or more declarations providing different property values for the same element, the declaration value in the style block having the matching selector with the greatest algorithmic weight gets applied. The specificity algorithm is basically a three-column value of three categories or weights - ID, CLASS, and TYPE - corresponding to the three types of selectors. The value represents the count of selector components in each weight category and is written as ID - CLASS - TYPE. The three columns are created by counting the number of selector components for each selector weight category in the selectors that match the element.\n\nThe selector weight categories are listed here in the order of decreasing specificity: Includes only ID selectors, such as . For each ID in a matching selector, add 1-0-0 to the weight value. Includes class selectors, such as , attribute selectors like and , and pseudo-classes, such as , , and . For each class, attribute selector, or pseudo-class in a matching selector, add 0-1-0 to the weight value. Includes type selectors, such as , , and , and pseudo-elements like , , and all other selectors with double-colon notation. For each type or pseudo-element in a matching selector, add 0-0-1 to the weight value. The universal selector ( ) and the pseudo-class and its parameters aren't counted when calculating the weight so their value is 0-0-0, but they do match elements. These selectors do not impact the specificity weight value. Combinators, such as , , , \" \", and , may make a selector more specific in what is selected but they don't add any value to the specificity weight. The nesting combinator doesn't add specificity weight, but nested rules do. In terms of specificity, and functionality, nesting is very similar to the pseudo-class. Like nesting, the , , and negation ( ) pseudo-classes themselves add no weight. The parameters in these selectors, however, do. The specificity weight of each comes from the selector parameter in the list of selectors with the highest specificity. Similarly, with nested selectors, the specificity weight added by the nested selector component is the selector in the comma-separated list of nested selectors with the highest specificity. The , , and CSS nesting exceptions are discussed below. The specificity weight comes from the matching selector. Take this CSS selector with three comma-separated selectors as an example: The selector in the above selector list, with a specificity weight of , applies the declaration to all password input types. All inputs, no matter the type, when receiving focus, match the second selector in the list, , with a specificity weight of ; this weight is made up of the pseudo-class (0-1-0) and the type (0-0-1). If the password input has focus, it will match , and the specificity weight for the style declaration will be . When that password doesn't have focus, the specificity weight remains at . The specificity for a required input nested in an element with attribute is , based on one ID, two pseudo-classes, and one element type. If the password input type with is nested in an element with set, the specificity weight will be , based on one ID, two pseudo-classes, and one element type, whether or not it has focus. Why is the specificity weight rather than or in this case? Because the specificity weight comes from the matching selector with the greatest specificity weight. The weight is determined by comparing the values in the three columns, from left to right.\n\nOnce the specificity values of the relevant selectors are determined, the number of selector components in each column are compared, from left to right. The first column is the value of the ID component, which is the number of IDs in each selector. The numbers in the ID columns of competing selectors are compared. The selector with the greater value in the ID column wins no matter what the values are in the other columns. In the above example, even though the yellow selector has more components in total, only the value of the first column matters. If the number in the ID columns of competing selectors is the same, then the next column, CLASS, is compared, as shown below. The CLASS column is the count of class names, attribute selectors, and pseudo-classes in the selector. When the ID column value is the same, the selector with the greater value in the CLASS column wins, no matter the value in the TYPE column. This is shown in the example below. If the numbers in the CLASS and ID columns in competing selectors are the same, the TYPE column becomes relevant. The TYPE column is the number of element types and pseudo-elements in the selector. When the first two columns have the same value, the selector with the greater number in the TYPE column wins. If the competing selectors have the same values in all the three columns, the proximity rule comes into play, wherein the last declared style gets precedence. input.myClass { color: yellow; /* 0-1-1 */ } :root input { color: green; /* 0-1-1 WINS because it comes later */ }\n\nThe matches-any pseudo-class , the relational pseudo-class , and the negation pseudo-class are not considered as pseudo-classes in the specificity weight calculation. They themselves don't add any weight to the specificity equation. However, the selector parameters passed into the pseudo-class parenthesis are part of the specificity algorithm; the weight of the matches-any and negation pseudo-class in the specificity value calculation is the weight of the parameter's weight. Note that in the above CSS pairing, the specificity weight provided by the , and pseudo-classes is the value of the selector parameter, not of the pseudo-class. All three of these pseudo-classes accept complex selector lists, a list of comma-separated selectors, as a parameter. This feature can be used to increase a selector's specificity: In the above CSS code block, we have included in the selectors. This adds to the specificity weight of each paragraph. When creating complex selector lists with CSS nesting this behaves in exactly the same way as the pseudo-class. In the above code block the complex selector the specificity is taken from and also the , so this create a specificity of for both and . This is the equivalent specificity as the selector. Generally, you want to keep specificity down to a minimum, but if you need to increase an element's specificity for a particular reason, these three pseudo-classes can help. In this example, all links will be blue, unless overridden by a link declaration with 3 or more IDs, a color value matching an includes the flag, or if the link has an inline style color declaration. If you use such a technique, add a comment to explain why the hack was needed.\n\nCSS declarations marked as important override any other declarations within the same cascade layer and origin. Although technically, has nothing to do with specificity, it interacts directly with specificity and the cascade. It reverses the cascade order of stylesheets. If declarations from the same origin and cascade layer conflict and one property value has the flag set, the important declaration is applied no matter the specificity. When conflicting declarations from the same origin and cascade layer with the flag are applied to the same element, the declaration with a greater specificity is applied. Using to override specificity is considered a bad practice and should be avoided for this purpose. Understanding and effectively using specificity and the cascade can remove any need for the flag. Instead of using to override foreign CSS (from external libraries, like Bootstrap or normalize.css), import the third-party scripts directly into cascade layers. If you must use in your CSS, comment your usage so future code maintainers know why the declaration was marked important and know not to override it. But definitely, don't use when writing plugins or frameworks that other developers will need to incorporate without being able to control.\n\nIn the following CSS, we have three selectors targeting elements to set a color. For a given input, the specificity weight of the color declaration having precedence is the matching selector with the greatest weight: If the above selectors all target the same input, the input will be red, as the first declaration has the highest value in the ID column. The last selector has four TYPE components. While it has the highest integer value, no matter how many elements and pseudo-elements are included, even if there were 150, TYPE components never have precedence over CLASS components. The column values are compared starting from left to right when column values are equal. Had we converted the id selector in the example code above to an attribute selector, the first two selectors would have the same specificity, as shown below: When multiple declarations have equal specificity, the last declaration found in the CSS is applied to the element. If both selectors match the same , the color will be blue."
    },
    {
        "link": "https://stackoverflow.com/questions/4284499/use-multiple-css-stylesheets-in-the-same-html-page",
        "document": "Yes, you can include multiple style sheets, but you need to label them as alternate style sheets and give the user some way to activate them using JavaScript - perhaps by clicking a link.\n\nNext create a method in your Javascript file that will: 1. Load all the style sheets in an array 2. Example:\n\nThen go through the array using some type of if/else loop that disables the style sheets you don't want and enables the style sheet you want. (You can write a separate method or insert the loop into the method above. I like to use the onload command to load the CSS array with the page, then call the printView method.)\n\nLastly, create code in your HTML document that the user will activate the JavaScript method such as:"
    },
    {
        "link": "https://digitalocean.com/community/tutorials/how-to-apply-css-styles-to-html-with-cascade-and-specificity",
        "document": "The author selected the Diversity in Tech Fund to receive a donation as part of the Write for DOnations program.\n\nCascading Style Sheets, better known as CSS, is the language for visual style and design on the web. CSS has a long history on the web dating back to 1994 with the initial idea. In the time since, CSS has become a feature-rich language capable of laying out a webpage, creating complex animations, and much more.\n\nSince CSS is the web’s styling language, understanding how it works and how to use it is fundamental to web development. It is especially valuable to understand in order to work with Hypertext Markup Language (HTML) and JavaScript effectively. This tutorial will focus on applying CSS to HTML, cascade, and specificity, which are foundational aspects of CSS and will prepare you for using CSS effectively in your web projects.\n\nCSS is not a conventional programming language. While it does have some features found in other programming languages, such as variables and math, CSS is wholly dependent on HTML to work. CSS’s purpose is to provide visual modifications to HTML. The CSS language is more like a to-do list for the browser: You are saying to the browser, here is a list of things I want you to find. Once the browser finds those things, the CSS instructs the browser to go through the subset list and make changes to those things.\n\nThe browser follows this list of instructions from top to bottom unquestionably, and CSS needs to be written with that in mind. The cascade part of Cascading Stylesheets speaks to how browsers read the list. Since the browser is impartial, it makes the style changes as it encounters them. If the CSS says to make some HTML elements red, then later down in the CSS it says to make those elements blue, the result is blue.\n\nApplying styles to an element gets a little complicated, as there are many ways to tell the browser to find an element in the HTML. Each element in HTML has a set of attributes which can be used to find a specific element. Because of the cascade where the browser reads the instructions from top to bottom with impartiality, the instructions provided must be specific. This is known as specificity, where the developer must write precise criteria for the browser to find the exact element they wish to apply the styles to.\n\nIn this tutorial you will work through multiple hands-on examples to understand the different ways styles can be applied to HTML elements and how cascade and specificity affect how styles are written.\n• An HTML file saved on your local machine as that you can access from your text editor and web browser of choice. To get started, check out our How To Set Up Your HTML Project tutorial, and follow How To Use and Understand HTML Elements for instructions on how to view your HTML in your browser. If you’re new to HTML, try out the whole How To Build a Website in HTML series.\n\nIn this first step, you will apply styles to an HTML element directly with the attribute. This method, also known as inline styling, uses an HTML element attribute to accept a CSS property as a value, and then applies it directly to the element.\n\nTo familiarize yourself with some concepts of CSS, start by opening the file in your text editor. In that file, set up the base HTML structure of the , , and tags. Inside the tags add a with a short sentence of text:\n\nNext, open in your browser. You will see your text in the in the top left portion of the browser window. Visually, the text should appear similar to the following image with black text on a white background using serif font, such as Times New Roman:\n\nTo begin styling, add an attribute with an empty value to the opening tag:\n\nThe attribute is a special attribute for HTML that contains CSS properties and values. The browser will apply those styles to that element.\n\nIn this case, change the color of your sentence to using the property. The format for CSS property and values begins with the property name, followed by the colon symbol , then the property value, and finally a semicolon symbol after the value to tell the browser that’s all for the value:\n\nSave , return to your browser, and refresh. The text has changed from the browser default color of black to navy, as seen in the following image:\n\nThere are many CSS properties you can try in the attribute, such as or . Typically, a browser’s default font is a serif font, such as Times New Roman. To change the font to a sans serif font, such as Arial or Helvetica, add a space after the semicolon for the property then type the property, followed by a colon, with as the value:\n\nSave your file and refresh your browser to see how the font for your sentence has changed. The font will now be the browser’s sans-serif font, such as Helvetica or Arial, instead of the default font. The following image shows how the property builds on the color change to navy.\n\nNow that you have written a couple of CSS properties, wrap a word in your sentence with the element and return to your browser:\n\nIn your browser, the word inside the tag will appear bolder than the other words in the sentence, as shown in the following image.\n\nThe word with the element retains the and properties of the HTML element it is inside, also known as its parent. This is an example of inheritance, where a child element, an HTML element inside another element, inherits styles that are placed on the parent element. The element also adds a browser default style of , making the text bold. Additionally, the element can have a attribute as well to give that element a custom look:\n\nSave the file and refresh you browser to see the difference, as the word in the element is now blue, in contrast to the navy of the rest of the sentence. This change is shown in the following image:\n\nIn this section you used HTML attributes to apply styles to a and a element. In the next section you’ll take the styles you wrote for those specific elements and apply them to all and elements on the page.\n\nUsing the Tag to Write CSS\n\nNext you will take what was written in the previous section and apply the styles to all similar elements on the page. You will move from using the attribute to using the HTML element. is a special element that allows you to write CSS within it and have those styles applied to the whole page.\n\nUsing the attribute on an HTML element can be very handy, but it is limited to only that element or its descendants. To see how this works add another element with a new sentence:\n\nGo to your browser and reload the page. As you may notice in the browser or the following image, the first sentence gets all the styles you wrote earlier, but the new sentence uses the browser default styles instead:\n\nYou could apply the same attribute on each individual element, but that becomes very cumbersome if you have many sentences that you want to look the same. What you need is a way to target many of the same kinds of elements simultaneously. This can be done with the HTML element.\n\nThe element is most often placed in the tag of an HTML document. This way the browser reads the styles before reading the HTML, causing the page to load already styled. The inverse can cause a flash as the browser loads the content with browser default styles and then loads the custom styles. However, keep in mind that the tag is not limited to use in the and can be placed anywhere within the , which can be advantageous in some scenarios.\n\nAdd tags to the of your file:\n\nInside the element, you can define what kind of element you want to target with selectors, which identify which HTML elements to apply styles to. Once the selector is in place, you can then group the styles you wish to apply to that element in what is called a selector block.\n\nTo begin setting that up, look at the example from earlier. Here there is a with two properties, and .\n\nTo target all elements on the page, add what is called a type selector within the attribute, followed by an opening and closing curly brace, which define the selector block. This tells the browser to find all the elements on the page and apply the styles found within the selector block:\n\nNext, take the properties from the attribute and put them inside the curly braces of the selector block. To make it easier to read, it helps to put each property on an individual line:\n\nOnce you have saved the file, return to the browser and refresh. Now both sentences have the same styles applied, all from a single selector in the element:\n\nAdd a new selector after your selector block to apply the styles for the element in the same manner. Also, add a element around a word in your second sentence to see your new CSS on multiple elements:\n\nSave the file and refresh your browser, or look at the following image, to find that now both words using the element are the color blue:\n\nIn this section, you wrote CSS selectors within a element, which applied the styles to all matching elements on the page. In the next section you will move these styles so that they can be applied on many pages of a website.\n\nIn this section you will start working with a CSS file that is loaded on multiple HTML pages. You will move the styles from the previous section to the CSS file and create a new HTML page to see how one CSS file can style multiple pages.\n\nJust as the attribute is limited to styling the single element, the CSS found in a element are limited to styling a single page. Websites are most often a collection of many web pages that share the same styles. If you had multiple pages that all needed to look the same and you used the element to hold your CSS, making changes to the styles would require a lot of repeat work on each page. This is where the CSS file comes in.\n\nCreate a new file in your editor called . In that file, copy the contents of the element from and add them to your file. Be sure to exclude the tags.\n\nNow that you have an independent CSS file, it’s time to load that file on to the page so the browser can apply the styles. Start by removing the tags from the . Then inside the tag, write a self-closing element with two attributes, and . The value contains the path to the file so the browser can reference the CSS. The attribute should have a value of as it defines the type of relationship between the page and the document being referenced:\n\nNow go to your browser and refresh . In this case, you will not find anything changed since all you have done is change where the styles live.\n\nTo demonstrate how useful a CSS file is, create a new HTML file called . Copy and paste the HTML from and then make changes to the sentences, or create new sentences:\n\nNext, open in a new browser window so you can view and compare both HTML files simultaneously. This results in having the same styles for both and elements, as shown in the following image.\n\nReturn to your text editor and open and change the selector’s property value to :\n\nIn your browser, refresh both and to see how changing the styles in the CSS file affects both HTML files. As the following image shows, the text changed from navy to green in both and :\n\nEach page has the same styles applied with the green text and blue elements, all from one central CSS file.\n\nIn this section you created a CSS file and loaded that CSS file on multiple HTML pages. You moved your CSS from the element into the CSS file, which applied the same styles to and the new page. Next you will start working with CSS cascade and specificity.\n\nWorking With the Cascade and Specificity\n\nThis section will get into the depths of the CSS features of cascade and specificity mentioned in the introduction. You will write CSS that exemplifies these concepts, starting with cascade and then specificity. Understanding cascade and specificity can help troubleshoot problems you may find in your code.\n\nWith what you have accomplished so far, the cascade is short. As your CSS file grows in size, it is more and more necessary to be aware of the order of your CSS selectors and properties. One way to think about the cascade is to think of a water cascade and traversing rapids. It’s advisable to go with the current, as trying to go upstream will require extensive effort to make little progress. The same is true with CSS: if your code is not working as expected, it may be going against the flow of the cascade.\n\nTo see this in practice, open up the files from earlier. Open in your text editor and in your browser. The elements in the browser will currently be , with the bold text in . After the property in the selector, add another property with a value of :\n\nThe browser traverses the cascade and hits the green style, turning the green. Then the browser hits the orange style, and changes the color from green to orange. Refresh in your browser to see the green text is now orange, as shown in the following image:\n\nIn this scenario the browser has been given two properties, and due to the nature of the cascade, the browser applies the last property to the element. When a property further down the cascade negates a previous property, this results in a situation called an override. As a CSS file grows in size and scope, overrides can be the source of bugs as well as the solution to problems.\n\nWhile the cascade deals with how the browser reads and applies styles to elements, specificity deals with what elements are found and styled.\n\nOpen in your browser. Right now both sentences have the same style. Next, you will change the color of the element in the second sentence to , but keep the first color set to . To accomplish this change requires a higher specificity selector. Right now the selectors are what is called low specificity as they are targeting all elements on the page, regardless of their parent.\n\nHigher specificity can be achieved several different ways, but the most common and effective way is a class selector. On the second element, add a new attribute called and give that attribute a property value of :\n\nNext, open in you text editor to create a class selector. First, remove the from the you added earlier.\n\nIn CSS, element selectors are written out without an identifier, but with class selectors a period ( ) precedes the value found in the attribute. In this case, use the selector to apply a property with a value of :\n\nSave the changes to both and and refresh in your browser. You will find that the second element is now , as seen in the following image:\n\nTo understand the robustness of specificity in regards to the cascade, swap the and selector blocks. Different kinds of selectors have higher specificity. In this case the class selector has a higher specificity than the element selector:\n\nSave and refresh in your browser and you’ll notice no change. The following image shows that there is no visual change despite the reordering of the CSS.\n\nThis is due to the low specificity of element selectors and the high specificity of a class selector. While the browser is reading the list from top to bottom without regard, you can tell the browser to pay more attention when applying a style by using higher specificity selectors.\n\nIn this section you worked with the CSS features of cascade and specificity. You applied the same property twice to an element, which showed how the cascade works by using the last property in the list. You also created styles using a higher specificity selector called a class selector. Next you’ll learn about a special CSS rule that overrides both cascade and specificity.\n\nIn this last section you will learn about the CSS rule and write an example of how to use it. This example uses a fictional scenario where you would not have control over the HTML and therefore must fix the problem only using CSS.\n\nAlthough CSS will often work with the cascade and have good specificity, there are times when a style needs to be forced. This is done by adding an flag at the end of a property value, before the semicolon. This is not a rule to be used lightly, and when used it is a good practice to include a code comment explaining the reason for using .\n\nTo see how this works, open up in your editor and add a attribute with a set to :\n\nLoad in your browser and you will find that the attribute overrides the blue color with red, since a attribute has higher specificity than the CSS selector. What is in the browser will look similar to the following image:\n\nWhen working with websites it is common to have Javascript loaded that may apply inline styles like this. Elements with attributes are at the bottom of the cascade, meaning that even with styles that turn all tags , this one will be . In a scenario where Javascript creates the attribute, it cannot be removed from the HTML.\n\nTo force a style override, open up in your editor and after the property value in your selector, add :\n\nNow return to your browser and refresh . You will see the blue color again, as in the following image:\n\nDespite the attribute defining the color as it is now , thanks to the rule telling the browser that this is the more important style to use. It is helpful to add a CSS code comment explaining the reason for the so future developers or future you understand why you are using it.\n\nIn this section you learned about the rule and used it in a real-world scenario. You also learned that that the rule is a dangerous tool that should be used intentionally because of how drastic it overrides cascade and specificity. Additionally, you wrote a CSS comment, which is used to inform future developers looking at your code as well as a reminder to you when you return to your code later.\n\nCSS is a versatile language made for manipulating and styling HTML. In this tutorial you styled HTML elements through various methods of applying styles. You now have the foundation to begin writing your own styles. If you want to dive further into understanding CSS and how it works, the World Wide Web Consortium (W3C), the governing body for CSS, provides all kinds of information about the language.\n\nIf you would like to see more tutorials on CSS, check out our CSS topic page."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Styling_basics/Handling_conflicts",
        "document": "The aim of this lesson is to develop your understanding of some of the most fundamental concepts of CSS — the cascade, specificity, and inheritance — which control how CSS is applied to HTML and how conflicts between style declarations are resolved. While working through this lesson may seem less relevant immediately and a little more academic than some other parts of the course, an understanding of these concepts will save you from a lot of pain later on! We encourage you to work through this section carefully and check that you understand the concepts before moving on.\n• Understand how rules can conflict in CSS.\n• The main concepts that govern the outcome of conflicts — specificity, source order, and importance.\n\nCSS stands for Cascading Style Sheets, and that first word cascading is incredibly important to understand — the way that the cascade behaves is key to understanding CSS. At some point, you will be working on a project and you will find that the CSS you thought should be applied to an element is not working. Often, the problem is that you create two rules that apply different values of the same property to the same element. Cascade and the closely-related concept of specificity are mechanisms that control which rule applies when there is such a conflict. The rule that's styling your element may not be the one you expect, so you need to understand how these mechanisms work. Also significant here is the concept of inheritance, which means that some CSS properties by default inherit values set on the current element's parent element and some don't. This can also cause some behavior that you might not expect. Let's start by taking a quick look at the key things we are dealing with, then we'll look at each in turn and see how they interact with each other and your CSS. These can seem like a tricky set of concepts to understand. As you get more practice writing CSS, the way it works will become more obvious to you.\n\nWe'll start with inheritance. In the example below, we have a element with two levels of unordered lists nested inside it. We have given the outer a border, padding, and font color. The property is an inherited property. So, the property value is applied to the direct children and also to the indirect children — the immediate child s and those inside the first nested list. We have then added the class to the second nested list and applied a different color to it. This then inherits down through its children. Properties like (as mentioned earlier), , , and are not inherited properties. If a border were to be inherited by the children in this list example, every single list and list item would gain a border — probably not an effect we would ever want! Though every CSS property page lists whether or not the property is inherited, you can often guess the same intuitively if you know what aspect the property value will style.\n\nYou will often run into a situation where you know that a rule comes later in the stylesheet, but an earlier, conflicting rule is applied. This happens because the earlier rule has a higher specificity — it is more specific, and therefore, is being chosen by the browser as the one that should style the element. As we saw earlier in this lesson, a class selector has more weight than an element selector, so the properties defined in the class style block will override those defined in the element style block. Something to note here is that although we are thinking about selectors and the rules that are applied to the text or component they select, it isn't the entire rule that is overwritten, only the properties that are declared in multiple places. This behavior helps avoid repetition in your CSS. A common practice is to define generic styles for the basic elements, and then create classes for those that are different. For example, in the stylesheet below, we have defined generic styles for level 2 headings, and then created some classes that change only some of the properties and values. The values defined initially are applied to all headings, then the more specific values are applied to the headings with the classes. <h2>Heading with no class</h2> <h2 class=\"small\">Heading with class of small</h2> <h2 class=\"bright\">Heading with class of bright</h2> Let's now have a look at how the browser will calculate specificity. We already know that an element selector has low specificity and can be overwritten by a class. Essentially a value in points is awarded to different types of selectors, and adding these up gives you the weight of that particular selector, which can then be assessed against other potential matches. The amount of specificity a selector has is measured using three different values (or components), which can be thought of as ID, CLASS, and ELEMENT columns in the hundreds, tens, and ones place:\n• Identifiers: Score one in this column for each ID selector contained inside the overall selector.\n• Classes: Score one in this column for each class selector, attribute selector, or pseudo-class contained inside the overall selector.\n• Elements: Score one in this column for each element selector or pseudo-element contained inside the overall selector. Note: The universal selector ( ), combinators ( , , , ' '), and specificity adjustment selector ( ) along with its parameters, have no effect on specificity. The negation ( ), relational selector ( ), the matches-any ( ) pseudo-classes, and CSS nesting themselves don't add to specificity, but their parameters or nested rules do. The specificity weight that each contributes to the specificity algorithm is the specificity weight of the selector in the parameter or nested rule with the greatest weight. The following table shows a few isolated examples to get you in the mood. Try going through these, and make sure you understand why they have the specificity that we have given them. We've not covered selectors in detail yet, but you can find details of each selector on the MDN selectors reference. Before we move on, let's look at an example in action. /* 1. specificity: 1-0-1 */ #outer a { background-color: red; } /* 2. specificity: 2-0-1 */ #outer #inner a { background-color: blue; } /* 3. specificity: 1-0-4 */ #outer div ul li a { color: yellow; } /* 4. specificity: 1-1-3 */ #outer div ul .nav a { color: white; } /* 5. specificity: 0-2-4 */ div div li:nth-child(2) a:hover { border: 10px solid black; } /* 6. specificity: 0-2-3 */ div li:nth-child(2) a:hover { border: 10px dashed black; } /* 7. specificity: 0-3-3 */ div div .nav:nth-child(2) a:hover { border: 10px double black; } a { display: inline-block; line-height: 40px; font-size: 20px; text-decoration: none; text-align: center; width: 200px; margin-bottom: 10px; } ul { padding: 0; } li { list-style-type: none; } So what's going on here? First of all, we are only interested in the first seven rules of this example, and as you'll notice, we have included their specificity values in a comment before each one.\n• The first two selectors are competing over the styling of the link's background color. The second one wins and makes the background color blue because it has an extra ID selector in the chain: its specificity is 2-0-1 vs. 1-0-1.\n• Selectors 3 and 4 are competing over the styling of the link's text color. The second one wins and makes the text white because although it has one less element selector, the missing selector is swapped out for a class selector, which has more weight than infinity element selectors. The winning specificity is 1-1-3 vs. 1-0-4.\n• Selectors 5–7 are competing over the styling of the link's border when hovered. Selector 6 clearly loses to selector 5 with a specificity of 0-2-3 vs. 0-2-4; it has one fewer element selectors in the chain. Selector 7, however, beats both selectors 5 and 6 because it has the same number of sub-selectors in the chain as selector 5, but an element has been swapped out for a class selector. So the winning specificity is 0-3-3 vs. 0-2-3 and 0-2-4. Note: Each selector type has its own level of specificity that cannot be overwritten by selectors with a lower specificity level. For example, a million class selectors combined would not be able to overwrite the specificity of one id selector. The best way to evaluate specificity is to score the specificity levels individually starting from the highest and moving on to the lowest when necessary. Only when there is a tie between selector scores within a specificity column do you need to evaluate the next column down; otherwise, you can disregard the lower specificity selectors since they can never overwrite the higher specificity selectors. ID selectors have high specificity. This means styles applied based on matching an ID selector will overrule styles applied based on other selectors, including class and type selectors. Because an ID can only occur once on a page and because of the high specificity of ID selectors, it is preferable to add a class to an element instead of an ID. If using the ID is the only way to target the element — perhaps because you do not have access to the markup and cannot edit it — consider using the ID within an attribute selector, such as .\n\nThere is a special piece of CSS that you can use to overrule all of the above calculations, even inline styles - the flag. However, you should be very careful while using it. This flag is used to make an individual property and value pair the most specific rule, thereby overriding the normal rules of the cascade, including normal inline styles. Note: It is useful to know that the flag exists so that you know what it is when you come across it in other people's code. However, we strongly recommend that you never use it unless you absolutely have to. The flag changes the way the cascade normally works, so it can make debugging CSS problems really hard to work out, especially in a large stylesheet. Take a look at this example where we have two paragraphs, one of which has an ID. <p class=\"better\">This is a paragraph.</p> <p class=\"better\" id=\"winning\">One selector to rule them all!</p> Let's walk through this to see what's happening — try removing some of the properties to see what happens if you are finding it hard to understand:\n• You'll see that the third rule's and values have been applied, but the hasn't. Why? Really, all three should surely apply because rules later in the source order generally override earlier rules.\n• However, the rules above it win because class selectors have higher specificity than element selectors.\n• Both elements have a of , but the 2nd one has an of too. Since IDs have an even higher specificity than classes (you can only have one element with each unique ID on a page, but many elements with the same class — ID selectors are very specific in what they target), the red background color and the 1px black border should both be applied to the 2nd element, with the first element getting the gray background color, and no border, as specified by the class.\n• The 2nd element does get the red background color, but no border. Why? Because of the flag in the second rule. Adding the flag after means that this declaration will win over the value in the previous rule, even though the ID selector has higher specificity. Note: The only way to override an important declaration is to include another important declaration with the same specificity later in the source order, or one with higher specificity. One situation in which you may have to use the flag is when you are working on a CMS where you can't edit the core CSS modules, and you really want to override an inline style or an important declaration that can't be overridden in any other way. But really, don't use it if you can avoid it."
    }
]