[
    {
        "link": "https://stackoverflow.com/questions/461203/when-to-use-virtual-destructors",
        "document": "When are you meant to make them virtual and why?\n\nI thought that the destructor always gets called no matter what and for every object in the chain.\n\nI have a solid understanding of most OOP theory but the one thing that confuses me a lot is virtual destructors.\n\nVirtual destructors are useful when you might potentially delete an instance of a derived class through a pointer to base class: class Base { // some virtual methods }; class Derived : public Base { ~Derived() { // Do some important cleanup } }; Here, you'll notice that I didn't declare Base's destructor to be . Now, let's have a look at the following snippet: Base *b = new Derived(); // use b delete b; // Here's the problem! Since Base's destructor is not and is a pointing to a object, has undefined behaviour: [In ], if the static type of the object to be deleted is different from its dynamic type, the static type shall be a base class of the dynamic type of the object to be deleted and the static type shall have a virtual destructor or the behavior is undefined. In most implementations, the call to the destructor will be resolved like any non-virtual code, meaning that the destructor of the base class will be called but not the one of the derived class, resulting in a resources leak. To sum up, always make base classes' destructors when they're meant to be manipulated polymorphically. If you want to prevent the deletion of an instance through a base class pointer, you can make the base class destructor protected and nonvirtual; by doing so, the compiler won't let you call on a base class pointer. You can learn more about virtuality and virtual base class destructor in this article from Herb Sutter.\n\nA virtual constructor is not possible but virtual destructor is possible. Let us experiment....... The above code output the following: The construction of derived object follow the construction rule but when we delete the \"b\" pointer(base pointer) we have found that only the base destructor is called. But this must not happen. To do the appropriate thing, we have to make the base destructor virtual. Now let see what happens in the following: The output changed as following: So the destruction of the base pointer (which takes an allocation on derived object!) follows the destruction rule, i.e first the Derived, then the Base. On the other hand, there is nothing like a virtual constructor.\n\nVirtual destructor call is no different from any other virtual function call. For , the call will be dispatched to , and it's the same for - its overriding function - the will be called. Same happens when destructor is being called indirectly, e.g. . The statement will call which will be dispatched to . If you are not going to delete object through a pointer to its base class - then there is no need to have a virtual destructor. Just make it so that it won't be called accidentally: // library.hpp struct Base { virtual void f() = 0; protected: ~Base() = default; }; void CallsF(Base& base); // CallsF is not going to own \"base\" (i.e. call \"delete &base;\"). // It will only call Base::f() so it doesn't need to access Base::~Base. //------------------- // application.cpp struct Derived : Base { void f() override { ... } }; int main() { Derived derived; CallsF(derived); // No need for virtual destructor here as well. }\n\nI propose the following: If a class or struct is not declared as final, it should have a virtual destructor. Although it might seem unnecessarily cautious to adopt this as a rule of thumb, it's the only way to ensure that subclasses derived from your class will not cause undefined behavior (UB) when deleted via a base pointer. Scott Meyers, in Effective C++, provides a useful guideline: if a class has any virtual function, it should have a virtual destructor, and that classes not designed to be base classes or not designed to be used polymorphically should not declare virtual destructors. Defining a virtual function in a class somewhat signals the intention that the class is suitable for use as a base class in a polymorphic context. In contrast, the absence of virtual functions does not clearly convey this intent, and the compiler will not issue an error if the class is used polymorphically. While it's not possible to enforce polymorphic suitability through compiler checks when virtual functions are absent, you can clearly communicate that a class is not designed to be a base class by marking it with the final keyword. Consider the scenario below where the base class B does not include any virtual functions. According to Meyers' recommendation, a virtual destructor might seem unnecessary. But omitting it will cause undefined behavior. #include <iostream> struct A { ~A() { std::cout << \"A::~A()\" << std::endl; } }; struct B { }; struct C : public B { A a; }; int main(int argc, char *argv[]) { B *b = new C; delete b; // UB, and won't print \"A::~A()\" return 0; }\n\nWhat is a virtual destructor or how to use virtual destructor A class destructor is a function with same name of the class preceding with ~ that will reallocate the memory that is allocated by the class. Why we need a virtual destructor See the following sample with some virtual functions The sample also tell how you can convert a letter to upper or lower #include \"stdafx.h\" #include<iostream> using namespace std; // program to convert the lower to upper orlower class convertch { public: //void convertch(){}; virtual char* convertChar() = 0; ~convertch(){}; }; class MakeLower :public convertch { public: MakeLower(char *passLetter) { tolower = true; Letter = new char[30]; strcpy(Letter, passLetter); } virtual ~MakeLower() { cout<< \"called ~MakeLower()\"<<\"\n\n\"; delete[] Letter; } char* convertChar() { size_t len = strlen(Letter); for(int i= 0;i<len;i++) Letter[i] = Letter[i] + 32; return Letter; } private: char *Letter; bool tolower; }; class MakeUpper : public convertch { public: MakeUpper(char *passLetter) { Letter = new char[30]; toupper = true; strcpy(Letter, passLetter); } char* convertChar() { size_t len = strlen(Letter); for(int i= 0;i<len;i++) Letter[i] = Letter[i] - 32; return Letter; } virtual ~MakeUpper() { cout<< \"called ~MakeUpper()\"<<\"\n\n\"; delete Letter; } private: char *Letter; bool toupper; }; int _tmain(int argc, _TCHAR* argv[]) { convertch *makeupper = new MakeUpper(\"hai\"); cout<< \"Eneterd : hai = \" <<makeupper->convertChar()<<\" \"; delete makeupper; convertch *makelower = new MakeLower(\"HAI\");; cout<<\"Eneterd : HAI = \" <<makelower->convertChar()<<\" \"; delete makelower; return 0; } From the above sample you can see that the destructor for both MakeUpper and MakeLower class is not called. See the next sample with the virtual destructor #include \"stdafx.h\" #include<iostream> using namespace std; // program to convert the lower to upper orlower class convertch { public: //void convertch(){}; virtual char* convertChar() = 0; virtual ~convertch(){}; // defined the virtual destructor }; class MakeLower :public convertch { public: MakeLower(char *passLetter) { tolower = true; Letter = new char[30]; strcpy(Letter, passLetter); } virtual ~MakeLower() { cout<< \"called ~MakeLower()\"<<\"\n\n\"; delete[] Letter; } char* convertChar() { size_t len = strlen(Letter); for(int i= 0;i<len;i++) { Letter[i] = Letter[i] + 32; } return Letter; } private: char *Letter; bool tolower; }; class MakeUpper : public convertch { public: MakeUpper(char *passLetter) { Letter = new char[30]; toupper = true; strcpy(Letter, passLetter); } char* convertChar() { size_t len = strlen(Letter); for(int i= 0;i<len;i++) { Letter[i] = Letter[i] - 32; } return Letter; } virtual ~MakeUpper() { cout<< \"called ~MakeUpper()\"<<\"\n\n\"; delete Letter; } private: char *Letter; bool toupper; }; int _tmain(int argc, _TCHAR* argv[]) { convertch *makeupper = new MakeUpper(\"hai\"); cout<< \"Eneterd : hai = \" <<makeupper->convertChar()<<\" \n\n\"; delete makeupper; convertch *makelower = new MakeLower(\"HAI\");; cout<<\"Eneterd : HAI = \" <<makelower->convertChar()<<\"\n\n \"; delete makelower; return 0; } The virtual destructor will call explicitly the most derived run time destructor of class so that it will be able to clear the object in a proper way.\n\nI thought it would be beneficial to discuss the \"undefined\" behavior, or at least the \"crash\" undefined behavior that may occur when deleting through a base class(/struct) without a virtual destructor, or more precisely no vtable. The code below list a few simple structs (the same would be true for classes). #include <iostream> using namespace std; struct a { ~a() {} unsigned long long i; }; struct b : a { ~b() {} unsigned long long j; }; struct c : b { ~c() {} virtual void m3() {} unsigned long long k; }; struct d : c { ~d() {} virtual void m4() {} unsigned long long l; }; int main() { cout << \"sizeof(a): \" << sizeof(a) << endl; cout << \"sizeof(b): \" << sizeof(b) << endl; cout << \"sizeof(c): \" << sizeof(c) << endl; cout << \"sizeof(d): \" << sizeof(d) << endl; // No issue. a* a1 = new a(); cout << \"a1: \" << a1 << endl; delete a1; // No issue. b* b1 = new b(); cout << \"b1: \" << b1 << endl; cout << \"(a*) b1: \" << (a*) b1 << endl; delete b1; // No issue. c* c1 = new c(); cout << \"c1: \" << c1 << endl; cout << \"(b*) c1: \" << (b*) c1 << endl; cout << \"(a*) c1: \" << (a*) c1 << endl; delete c1; // No issue. d* d1 = new d(); cout << \"d1: \" << d1 << endl; cout << \"(c*) d1: \" << (c*) d1 << endl; cout << \"(b*) d1: \" << (b*) d1 << endl; cout << \"(a*) d1: \" << (a*) d1 << endl; delete d1; // Doesn't crash, but may not produce the results you want. c1 = (c*) new d(); delete c1; // Crashes due to passing an invalid address to the method which // frees the memory. d1 = new d(); b1 = (b*) d1; cout << \"d1: \" << d1 << endl; cout << \"b1: \" << b1 << endl; delete b1; /* // This is similar to what's happening above in the \"crash\" case. char* buf = new char[32]; cout << \"buf: \" << (void*) buf << endl; buf += 8; cout << \"buf after adding 8: \" << (void*) buf << endl; delete buf; */ } I'm not suggesting whether you need virtual destructors or not, though I think in general it's a good practice to have them. I'm just pointing out the reason you may end up with a crash if your base class(/struct) does not have a vtable and your derived class(/struct) does and you delete an object via a base class(/struct) pointer. In this case, the address you pass to the heap's free routine is invalid and thus the reason for the crash. If you run the above code you'll see clearly when the issue occurs. When the this pointer of the base class(/struct) is different from the this pointer of the derived class(/struct) you're going to run into this problem. In the sample above, struct a and b don't have vtables. structs c and d do have vtables. Thus an a or b pointer to a c or d object instance will be fixed up to account for the vtable. If you pass this a or b pointer to delete it will crash due to the address being invalid to the heap's free routine. If you plan to delete derived instances which have vtables from base class pointers, you need to ensure the base class has a vtable. One way to do that is to add a virtual destructor, which you might want anyway to properly clean up resources.\n\nMake all destructors virtual unless you have good reason not to. Otherwise evil like this happens: Suppose you have an array of Fruit pointers with both Apple and Orange objects. When you delete from the collection of Fruit objects, ~Apple() and ~Orange() fail to be called unless ~Fruit() is virtual. #include <iostream> using namespace std; struct Fruit { // good virtual ~Fruit() { cout << \"peel or core should have been tossed\" << endl; } }; struct Apple: Fruit { virtual ~Apple() {cout << \"toss core\" << endl; } }; struct Orange: Fruit { virtual ~Orange() {cout << \"toss peel\" << endl; } }; int main() { Fruit *basket[]={ new Apple(), new Orange() }; for (auto fruit: basket) delete fruit; }; toss core peel or core should have been tossed toss peel peel or core should have been tossed #include <iostream> using namespace std; struct Fruit { // bad ~Fruit() { cout << \"peel or core should have been tossed\" << endl; } }; struct Apple: Fruit { virtual ~Apple() {cout << \"toss core\" << endl; } }; struct Orange: Fruit { virtual ~Orange() {cout << \"toss peel\" << endl; } }; int main() { Fruit *basket[]={ new Apple(), new Orange() }; for (auto fruit: basket) delete fruit; }; peel or core should have been tossed peel or core should have been tossed"
    },
    {
        "link": "https://bulldogjob.com/readme/virtual-destructors-in-c-necessity-good-practice-bad-practice",
        "document": "One common misuse of C++ features is declaring virtual destructors for all classes, including those that do not utilize runtime polymorphism (e.g. data wrapper, container, concurrency control classes, etc.). For a C++ developer working on a common codebase, it is likely a class declaration like the following has been encountered:\n\nBecause of the frequency of this misuse, it is even possible to encounter author comments next to non-virtual destructor declarations explaining why these destructors are declared as non-virtual, warning others who may modify the code that this was intentional.\n\nFrequently, the subject of virtual destructors has been discussed online addressing the common questions: “Should every class/Does every class have to have a virtual destructor?” and “When (not) to use virtual destructors?” Depending on whether the question seeks advice or clarification regarding the necessity of virtual destructors, many answers detail when its use is recommended, not recommended, required, or prohibited. The outcomes of declaring destructors virtual, organized into 3 categories and based on their utilization of runtime polymorphism, after closer examination, provides proof that declaring all destructors virtual is an improper practice.\n\nThese types of classes exhibit the true use case of virtual destructors. Consider the following pseudo-code:\n\nDeclaring the base class destructor as virtual ensures the call of the derived class destructor, when an object of the derived class type is destroyed via a pointer or a reference of the base class type. If is non-virtual, executing the delete expression would invoke , but not , which would result in a leak of resources allocated by other than those inherited from .\n\nWell, there is not much more to say... In such a situation, using virtual destructors is a necessity for the utilization of runtime polymorphism and, in fact, this is exactly what they are used for.\n\nWhat if runtime polymorphism is already in use (i.e. the base class has at least one virtual function that is not its destructor), but polymorphic destruction is not intended in the class design? In the following example, the method of destruction from the previous example has been changed to justify such a scenario:\n\nBecause runtime polymorphism is not used in the destruction of derived class instances, allowing the base class destructor to be non-virtual does not prevent the derived class destructor from being called. There is no concern for resource leaks due to missed destructor calls.\n\nSince virtual destructors are not necessary for this case, what are the implications of its use? What is the runtime cost of such virtual function calls?\n\nRuntime cost of a virtual function call: Although the implementation method of virtual functions is not defined by the language specification, compilers generally use a data structure called a virtual function table (vtable), an instance of which is created for each class type that declares or inherits at least one virtual function. For each virtual function of the class, there exists a row in the vtable that contains a pointer to that function. Each instance of a class with a vtable holds a pointer to this vtable as a hidden data member. It is through this pointer to the vtable, that virtual function calls through pointers and references of base class types are directed to the function of the actual object’s type. That is why a call to a virtual function effectively resembles something like the following statement:\n\nAlso worth mentioning: it is less likely for virtual functions to be inlined, than non-virtual functions.\n\nIt is obvious, that the cost of using a virtual function mechanism is not always negligible. On the other hand, for classes in a hierarchy that already utilize this mechanism (e.g. and in the code example), the toll for a class level virtual function table and a pointer to this table in each class instance has already been paid. The extra cost of declaring a base class destructor can be expected as an additional row in the class vtables, as well as access to the appropriate vtable and row during the destructor call.\n\nFor most cases, these additional costs are considered relatively low. Therefore, when implementing a design with runtime polymorphism, but without polymorphic destruction of derived class objects, declaring destructors virtual is a good practice as a safety mechanism for unintended polymorphic destruction through client mistake. (Please note, destructors of base classes can be declared in the protected class scope in order to prevent compilation of such client code, if public scope is not required by design.)\n\nStill remaining, are all the other classes that do not use runtime polymorphism. In other words, those which do not need any virtual functions. Some classes are not designed to be base classes at all, as exhibited in from the first code snippet. Furthermore, a base class may not use runtime polymorphism, as shown in the following example:\n\nDeclaring virtual destructors for these classes can incur costs for the virtual function mechanism, although they will not be utilized. The runtime costs of virtual destructors have already been discussed for Type 2 classes. However, these costs are not the same for classes without any other virtual functions.\n\nBelow is a list of the potential disadvantages of declaring the destructor virtual in a class not utilizing runtime polymorphism, the importance of each depending on the particular use case:\n• Assuming the virtual function mechanism is implemented by virtual function tables (vtable), separate vtables are allocated in the memory for the class and for each class that inherits it. More importantly, the size of each instance of the class are increased by the size of a hidden pointer to a vtable. This can cause significant memory overhead for small sized classes where the size of the pointer is comparable to the total size of an object, especially if many instances exist at a given moment. It would be quite reasonable to assume that other implementations for virtual function tables would also add hidden members to class objects.\n• A class that has at least one virtual function is prevented from many low-level operations on a class object. (One can assume that this is due to the hidden pointer in the vtable implementation.) If the class is otherwise a plain old data (POD) structure, having a virtual function renders the class a non-POD type, violating one of the conditions of POD types. For example, this prevents the use of bytewise operating functions such as and with an object of this class type. Additionally, because memory layout of such objects is no longer simple, extra measures are needed when passing the class type to another language for developing cross-language software\n• During program execution, virtual function calls are slower than non-virtual function calls, because of additional instructions for accessing the target functions that must be called (typically through function pointers in vtables). The compiler/linker pairs can optimize virtual destructor calls that are invoked on the true class type and replace them with ordinary calls, only if the optimization level is high enough, they themselves are “smart” enough and aware of the true class type in the call. However, if optimization is not in place for any reason, virtual destructors that do not have to be virtual suffer from the overhead. Furthermore, destructors that would otherwise be chosen by the compiler as suitable to be inlined, may not qualify for this benefit, because compilers are less likely to inline virtual functions.\n• Examining the code, a keyword next to the name of a destructor function in a non-runtime polymorphic class declaration implies runtime polymorphism, as this is the sole purpose of virtual functions. (When encountering a virtual destructor, a reader may look for other virtual function declarations as the next thing to do, because the use of runtime polymorphism is a fundamental class trait.) This is always a valid concern, even if all other drawbacks are negligible for a given class.\n\n\n\nContrarily, the only advantage of declaring destructors of such classes as virtual is to prevent against possible client misuse by destructing derived class objects through pointers or references of base class types. As aforementioned, the toll can be too costly for this type of advantage, especially to make it a habit.\n\nIn fact, virtual destructors are still reasonable for non-runtime polymorphic base classes for which performance and size are not important concerns and all costs are acceptable. This is true particularly when the destructor must be public, keeping in mind that protected base class destructors prevent this misuse as well. It is also worth reminding that base classes that do not have any virtual functions are not very common in object-oriented design.\n\nHowever, virtual destructors do not make much sense for classes that are not designed to be base classes (a trait that can be enforced with the final identifier since C++11). In general, blindly declaring every destructor as virtual is a bad practice and can potentially lead to a significant waste of resources.\n\nBad practices such as this, are typically a result of misguidance for novice C++ programmers. However, in the case of experienced programmers, this can better be explained with a tendency of overlooking the rationale and costs of using specific language features, which leads to an incorrect level of abstraction in the coding process, resulting in bad code. On the other hand, doing this deliberately may well point to a zealous belief in defensive programming to the point of significant performance loss, as well as making the code less coherent.\n\nUpon examining the advantages and disadvantages of using virtual destructors, the best practice can be summarized by Scott Meyers, from his book Effective C++:\n• “Effective C++, Third Edition: 55 Specific Ways to Improve Your Programs and Designs” Scott Meyers"
    },
    {
        "link": "https://stackoverflow.com/questions/12092933/calling-virtual-function-from-destructor",
        "document": "I am going to go against the flow here... but first, I must assume that your destructor is virtual, as otherwise the destructor will never be called.\n\nIt is usually not a good idea to call a virtual function from a constructor/destructor\n\nThe reason for this is that dynamic dispatch is strange during these two operations. The actual type of the object changes during construction and it changes again during destruction. When a destructor is being executed, the object is of exactly that type, and never a type derived from it. Dynamic dispatch is in effect at all time, but the final overrider of the virtual function will change depending where in the hierarchy you are.\n\nThat is, you should never expect a call to a virtual function in a constructor/destructor to be executed in any type that derived from the type of the constructor/destructor being executed.\n\nIn your particular case, the final overrider (at least for this part of the hierarchy) is above your level. Moreover, you are not using dynamic dispatch at all. The call is statically resolved, and effectively equivalent to a call to any non-virtual function. The fact that the function is virtual or not does not affect this call.\n\nSo yes it is fine doing as you are doing, although you will be forced to explain this in code reviews as most people learn the mantra of the rule rather than the reason for it."
    },
    {
        "link": "https://geeksforgeeks.org/when-to-use-virtual-destructors-in-cpp",
        "document": "When to Use Virtual Destructors in C++?\n\nIn C++, destructors are special members of a class that frees memory occupied by an object when it goes out of scope. A virtual destructor is a special form of destructor that is declared as virtual in a base class.\n\nIn this article, we will discuss the cases when the need for a virtual destructor arises.\n\nWhen to Use Virtual Destructors?\n\nVirtual destructors in C++ are needed in scenarios in which polymorphism and inheritance are involved, and instances of derived classes are managed pointers to base classes.\n\nIf your class has one or more virtual functions that are derived by their child classes and you are using pointers to base class to manage the objects, then you need to implement a virtual destructor so that the relevant version of the destructor is called when the object is deleted.\n\nIn the below code, we won't use the virtual constructor and see how the objects are destroyed.\n\nHere, only the Base class destructor is called for the Derived class object that is being referred to by the Base class pointer. Due to this, the resources allocated inside the base class are not released leading to memory leaks. In this case, we can make the destructor virtual so that the most derived implementation of it is called.\n\nC++ Program to Show the Use of Virtual Destructor\n\nIf you have the case of multilevel inheritance, the destructor will be called in the order of derivation."
    },
    {
        "link": "https://softwareengineering.stackexchange.com/questions/284561/when-not-to-use-virtual-destructors",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://stackoverflow.com/questions/2321511/what-is-meant-by-resource-acquisition-is-initialization-raii",
        "document": "It's a really terrible name for an incredibly powerful concept, and perhaps one of the number 1 things that C++ developers miss when they switch to other languages. There has been a bit of a movement to try to rename this concept as Scope-Bound Resource Management, though it doesn't seem to have caught on just yet. When we say 'Resource' we don't just mean memory - it could be file handles, network sockets, database handles, GDI objects... In short, things that we have a finite supply of and so we need to be able to control their usage. The 'Scope-bound' aspect means that the lifetime of the object is bound to the scope of a variable, so when the variable goes out of scope then the destructor will release the resource. A very useful property of this is that it makes for greater exception-safety. For instance, compare this: RawResourceHandle* handle=createNewResource(); handle->performInvalidOperation(); // Oops, throws exception ... deleteResource(handle); // oh dear, never gets called so the resource leaks In this latter case, when the exception is thrown and the stack is unwound, the local variables are destroyed which ensures that our resource is cleaned up and doesn't leak.\n\nThis is a programming idiom which briefly means that you\n• encapsulate a resource into a class (whose constructor usually - but not necessarily** - acquires the resource, and its destructor always releases it)\n• use the resource via a local instance of the class*\n• the resource is automatically freed when the object gets out of scope This guarantees that whatever happens while the resource is in use, it will eventually get freed (whether due to normal return, destruction of the containing object, or an exception thrown). It is a widely used good practice in C++, because apart from being a safe way to deal with resources, it also makes your code much cleaner as you don't need to mix error handling code with the main functionality. Update: \"local\" may mean a local variable, or a nonstatic member variable of a class. In the latter case the member variable is initialized and destroyed with its owner object. Update2: as @sbi pointed out, the resource - although often is allocated inside the constructor - may also be allocated outside and passed in as a parameter.\n\n\"RAII\" stands for \"Resource Acquisition is Initialization\" and is actually quite a misnomer, since it isn't resource acquisition (and the initialization of an object) it is concerned with, but releasing the resource (by means of destruction of an object).\n\n But RAII is the name we got and it sticks. At its very heart, the idiom features encapsulating resources (chunks of memory, open files, unlocked mutexes, you-name-it) in local, automatic objects, and having the destructor of that object releasing the resource when the object is destroyed at the end of the scope it belongs to: Of course, objects aren't always local, automatic objects. They could be members of a class, too: class something { private: raii obj_; // will live and die with instances of the class // ... }; If such objects manage memory, they are often called \"smart pointers\". There are many variations of this. For example, in the first code snippets the question arises what would happen if someone wanted to copy . The easiest way out would be to simply disallow copying. , a smart pointer to be part of the standard library as featured by the next C++ standard, does this.\n\n Another such smart pointer, features \"shared ownership\" of the resource (a dynamically allocated object) it holds. That is, it can freely be copied and all copies refer to the same object. The smart pointer keeps track of how many copies refer to the same object and will delete it when the last one is being destroyed.\n\n A third variant is featured by which implements a kind of move-semantics: An object is owned by only one pointer, and attempting to copy an object will result (through syntax hackery) in transferring ownership of the object to the target of the copy operation.\n\nAn object's lifetime is determined by its scope. However, sometimes we need, or it is useful, to create an object that lives independently of the scope where it was created. In C++, the operator is used to create such an object. And to destroy the object, the operator can be used. Objects created by the operator are dynamically allocated, i.e. allocated in dynamic memory (also called heap or free store). So, an object that was created by will continue to exist until it's explicitly destroyed using . Some mistakes that can occur when using and are:\n• Leaked object (or memory): using to allocate an object and forget to the object.\n• Premature delete (or dangling reference): holding another pointer to an object, the object, and then use the other pointer.\n• Double delete: trying to an object twice. Generally, scoped variables are preferred. However, RAII can be used as an alternative to and to make an object live independently of its scope. Such a technique consists of taking the pointer to the object that was allocated on the heap and placing it in a handle/manager object. The latter has a destructor that will take care of destroying the object. This will guarantee that the object is available to any function that wants access to it, and that the object is destroyed when the lifetime of the handle object ends, without the need for explicit cleanup. Examples from the C++ standard library that use RAII are and . Consider this piece of code: void fn(const std::string& str) { std::vector<char> vec; for (auto c : str) vec.push_back(c); // do something } when you create a vector and you push elements to it, you don't care about allocating and deallocating such elements. The vector uses to allocate space for its elements on the heap, and to free that space. You as a user of vector you don't care about the implementation details and will trust vector not to leak. In this case, the vector is the handle object of its elements. Other examples from the standard library that use RAII are , , and . Another name for this technique is SBRM, short for Scope-Bound Resource Management.\n\nMany argue that RAII is a misnomer, but actually it is a right name for this idiom, just it is not explained well. Wikipedia explained behavior in detail: Resource acquisition is initialization (RAII) is a programming idiom used in several object-oriented, statically-typed programming languages to describe a particular language behavior. In RAII, holding a resource is a class invariant, and is tied to object lifetime: resource allocation (or acquisition) is done during object creation (specifically initialization), by the constructor, while resource deallocation (release) is done during object destruction (specifically finalization), by the destructor. In other words, resource acquisition must succeed for initialization to succeed. Thus the resource is guaranteed to be held between when initialization finishes and finalization starts (holding the resources is a class invariant), and to be held only when the object is alive. Thus if there are no object leaks, there are no resource leaks. And now for the name, it simply means the action of \"resource acquisition\" is an action of initialization and should be part of the initialization/constructor of the resource class object. In other word, using this idiom, working with a resource means making a resource class to hold the resource and initialize resource at time of constructing the class object. Implicitly, it suggests the deallocation of the resource should happen symmetrically in the resource class destructor. How is this useful? You can of course choose not to use this idiom, but if you wonder what you would get with this idiom, consider RAII It is quite common for even larger C++ projects to not contain a single call to new or delete (or malloc/free) outside of a constructor/destructor pair. Or at all, in fact. or use a RAII lock so you never forget to unlock."
    },
    {
        "link": "https://geeksforgeeks.org/resource-acquisition-is-initialization",
        "document": "RAII stands for “Resource Acquisition Is Initialization”. Suppose there is a “resource” in terms of Files, Memory, Sockets, etc. RAII means that an object’s creation and destruction are tied to a resource being acquired and released.\n\nLet’s assume we have to write events to a log file. A non-object-oriented way to do this would be:\n\nWe forgot to close log_fd. It’s imperative that every Linux process closes its file descriptors during its lifetime; otherwise, it may run out of file descriptors and misbehave/fail. Additionally, leaving file descriptors open will cause the kernel to keep extra bookkeeping and state around for unused yet open file descriptors and their backing file objects, resulting in increased memory consumption and unnecessary work.\n\nConsider a Logger class that writes events to a log file. In order to write to the file, it will need to open a file descriptor to it. Let’s take a look at how a primitive version of this class might look:\n\nNow let’s see how we will use this API:\n\nThe good thing is that upon destruction, the `Logger` closes the underlying file descriptor, making it responsible for its own resources.\n\nHowever, the `logger` object is in limbo between the `Constructor` and the `Initialize` call, as it has no file to write to internally. Relying on “good and responsible” users to use our API judiciously is always a bad code smell.\n\nLet’s see if we can do better:\n\nPutting RAII into practice, let’s acquire the file in the `Logger` constructor itself. Here’s how it would look:\n\nThis version improves our previous API by acquiring the file in the constructor. It still has one flaw but let’s see how we use this API:\n\nIf we fail to open the log file, then all logging events will fail. We could have `Log` return an error, but the client may keep retrying. To the client, the object creation succeeded, implying that the `Logger` is ready to log events. Any `Log` errors may be transient and worth retrying.\n\nHowever, this is not the case. All `Log` calls will fail. We should have returned an error where it happened – in the constructor. Constructors, unfortunately, cannot return errors. Let’s see an elegant way to get around this.\n\nLet’s return a `std::unique_ptr` from a static constructor. Internally, this will create a `Logger` object on the heap, wrap it in a `unique_ptr`, and return it to the client. If we fail to open the log file, we will return a `nullptr` instead. This way, we will inform the client that we failed when we actually failed.\n\nLet’s see how we can use this API:\n\nNow that the client knows when a `Logger` creation fails, it can take necessary steps without being confused by `Log` API failures. When `logger` goes out of scope, its destructor is called, and the log file is closed.\n\nOther Scenarios where RAII can be used\n\nWhen we create a thread in C++, we have to either join() or detach() the thread. In case some exception occurs in the function, and we are not able to join() or detach() the thread, the thread will become a zombie thread. To avoid this, we can use RAII:\n\nIn this program, we are calling func1() inside a try-catch block in main(). If func1() throws an exception, we’ll catch the exception in main().\n\nNow, func1() is called, and it creates a thread t1. Then it does some processing and expects to join t1 after the processing is done. But unfortunately, some exception occurs during this process, and func1 rethrows the exception in the catch block, without joining t1. He hopes to catch the exception in main(), but the program will throw an error because t1 has not been joined.\n\nIn a deeper calling stack, we can get trapped in this error quite easily. One way to solve this is to create a Wrapper that will join the thread automatically when the thread goes out of scope.\n\nHere we are creating an object of Wrapper i.e. w. In the constructor, we are passing the pointer to thread t1. The constructor assigns its pointer member variable std::thread *t with the pointer of thread t1. When the exception is thrown and func1() ends, the destructor of the Wrapper Class is invoked and it joins t1 automatically.\n\nScoped pointers are pointers that point to a heap-allocated memory and are deleted when the scope in which they are defined ends. Memory leak occurs when we forget to delete pointers that point to heap-allocated memory. This can exhaust our heap. So, it is very important to delete and free the heap memory we are not going to use.\n\nThe question is that if we want to delete the memory when the scope ends, why not use the stack memory? Obviously, we should always use stack memory whenever we can because it is faster to initialize and easier to manage. We only use heap memory when we need the memory to be shared between different scopes. So, what is the use case of scoped pointers?\n\nWhen you need to allocate a large amount of memory, The stack might not be helpful because stack size is limited. If allocate more memory in the stack, stack overflow will occur. So to allocate large amounts of memory, we use heap allocation.\n\nIn this program, we are creating a class Scoped_ptr and passing a void pointer to it, so that we can support all types. Since we need to know the kind of pointer when we delete it, we also pass a parameter ‘type’ and cast our pointer to that type. When the scope ends, the heap-allocated object gets deleted automatically.\n\nThis implementation is just an example of how Scoped Pointers can be implemented. The real implementation of Scoped Pointer is based on templates. You can learn templates and implement Scoped pointers using them as an exercise.\n\nIn supported languages, RAII is a powerful tool to abstract resources without manually managing them. It prevents leaks and nasty bugs. Developers should use it to make their life easier."
    },
    {
        "link": "https://stackoverflow.com/questions/712639/understanding-the-meaning-of-the-term-and-the-concept-raii-resource-acquisiti",
        "document": "There are excellent answers out there, so I just add some things forgotten.\n\nRAII is about both:\n• acquiring a resource (no matter what resource) in the constructor, and un-acquiring it in the destructor.\n• having the constructor executed when the variable is declared, and the destructor automatically executed when the variable goes out of scope.\n\nOthers already answered about that, so I won't elaborate.\n\n1. When coding in Java or C#, you already use RAII...\n\nAs Monsieur Jourdain did with prose, C# and even Java people already use RAII, but in hidden ways. For example, the following Java code (which is written the same way in C# by replacing with ):\n\n... is already using RAII: The mutex acquisition is done in the keyword ( or ), and the un-acquisition will be done when exiting the scope.\n\nIt's so natural in its notation it requires almost no explanation even for people who never heard about RAII.\n\nThe advantage C++ has over Java and C# here is that anything can be made using RAII. For example, there are no direct build-in equivalent of nor in C++, but we can still have them.\n\nIn C++, it would be written:\n\nwhich can be easily written as it would be in Java/C# (using C++ macros):\n\nYou know when the constructor will be called (at the object declaration), and you know when its corresponding destructor will be called (at the exit of the scope), so you can write almost magical code with but a line. Welcome to the C++ wonderland (at least, from a C++ developer's viewpoint).\n\nFor example, you can write a counter object (I let that as an exercise) and use it just by declaring its variable, like the lock object above was used:\n\nwhich of course, can be written, again, the Java/C# way using a macro:\n\n3. Why does C++ lack ?\n\nThe clause is used in C#/Java to handle resource disposal in case of scope exit (either through a or a thrown exception).\n\nAstute specification readers will have noticed C++ has no finally clause. And this is not an error, because C++ does not need it, as RAII already handle resource disposal. (And believe me, writing a C++ destructor is magnitudes easier than writing the right Java finally clause, or even a C#'s correct Dispose method).\n\nStill, sometimes, a clause would be cool. Can we do it in C++? Yes, we can! And again with an alternate use of RAII.\n\nConclusion: RAII is a more than philosophy in C++: It's C++\n\nWhen you reach some level of experience in C++, you start thinking in terms of RAII, in terms of construtors and destructors automated execution.\n\nYou start thinking in terms of scopes, and the and characters become ones of the most important in your code.\n\nAnd almost everything fits right in terms of RAII: exception safety, mutexes, database connections, database requests, server connection, clocks, OS handles, etc., and last, but not least, memory.\n\nThe database part is not negligible, as, if you accept to pay the price, you can even write in a \"transactional programming\" style, executing lines and lines of code until deciding, in the end, if you want to commit all the changes, or, if not possible, having all the changes reverted back (as long as each line satisfy at least the Strong Exception Guarantee). (see the second part of this Herb's Sutter article for the transactional programming).\n\nAnd like a puzzle, everything fits.\n\nRAII is so much part of C++, C++ could not be C++ without it.\n\nThis explains why experienced C++ developers are so enamored with RAII, and why RAII is the first thing they search when trying another language.\n\nAnd it explains why the Garbage Collector, while a magnificient piece of technology in itself, is not so impressive from a C++ developer's viewpoint:\n• RAII already handles most of the cases handled by a GC\n• A GC deals better than RAII with circular references on pure managed objects (mitigated by smart uses of weak pointers)\n• Still A GC is limited to memory, while RAII can handle any kind of resource.\n• As described above, RAII can do much, much more..."
    },
    {
        "link": "https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization",
        "document": "Approach to managing resources by tying them to object lifetime\n\nResource acquisition is initialization (RAII)[1] is a programming idiom[2] used in several object-oriented, statically typed programming languages to describe a particular language behavior. In RAII, holding a resource is a class invariant, and is tied to object lifetime. Resource allocation (or acquisition) is done during object creation (specifically initialization), by the constructor, while resource deallocation (release) is done during object destruction (specifically finalization), by the destructor. In other words, resource acquisition must succeed for initialization to succeed. Thus, the resource is guaranteed to be held between when initialization finishes and finalization starts (holding the resources is a class invariant), and to be held only when the object is alive. Thus, if there are no object leaks, there are no resource leaks.\n\nRAII is associated most prominently with C++, where it originated, but also Ada,[3] Vala,[4] and Rust.[5] The technique was developed for exception-safe resource management in C++ during 1984–1989, primarily by Bjarne Stroustrup and Andrew Koenig, and the term itself was coined by Stroustrup.\n\nOther names for this idiom include Constructor Acquires, Destructor Releases (CADRe)[9] and one particular style of use is called Scope-based Resource Management (SBRM).[10] This latter term is for the special case of automatic variables. RAII ties resources to object lifetime, which may not coincide with entry and exit of a scope. (Notably variables allocated on the free store have lifetimes unrelated to any given scope.) However, using RAII for automatic variables (SBRM) is the most common use case.\n\nThe following C++11 example demonstrates usage of RAII for file access and mutex locking:\n\nThis code is exception-safe because C++ guarantees that all objects with automatic storage duration (local variables) are destroyed at the end of the enclosing scope in the reverse order of their construction.[11] The destructors of both the lock and file objects are therefore guaranteed to be called when returning from the function, whether an exception has been thrown or not.[12]\n\nLocal variables allow easy management of multiple resources within a single function: they are destroyed in the reverse order of their construction, and an object is destroyed only if fully constructed—that is, if no exception propagates from its constructor.[13]\n\nUsing RAII greatly simplifies resource management, reduces overall code size and helps ensure program correctness. RAII is therefore recommended by industry-standard guidelines,[14] and most of the C++ standard library follows the idiom.[15]\n\nThe advantages of RAII as a resource management technique are that it provides encapsulation, exception safety (for stack resources), and locality (it allows acquisition and release logic to be written next to each other).\n\nEncapsulation is provided because resource management logic is defined once in the class, not at each call site. Exception safety is provided for stack resources (resources that are released in the same scope as they are acquired) by tying the resource to the lifetime of a stack variable (a local variable declared in a given scope): if an exception is thrown, and proper exception handling is in place, the only code that will be executed when exiting the current scope are the destructors of objects declared in that scope. Finally, locality of definition is provided by writing the constructor and destructor definitions next to each other in the class definition.\n\nResource management therefore needs to be tied to the lifespan of suitable objects in order to gain automatic allocation and reclamation. Resources are acquired during initialization, when there is no chance of them being used before they are available, and released with the destruction of the same objects, which is guaranteed to take place even in case of errors.\n\nComparing RAII with the construct used in Java, Stroustrup wrote that “In realistic systems, there are far more resource acquisitions than kinds of resources, so the 'resource acquisition is initialization' technique leads to less code than use of a 'finally' construct.”[1]\n\nThe RAII design is often used for controlling mutex locks in multi-threaded applications. In that use, the object releases the lock when destroyed. Without RAII in this scenario the potential for deadlock would be high and the logic to lock the mutex would be far from the logic to unlock it. With RAII, the code that locks the mutex essentially includes the logic that the lock will be released when execution leaves the scope of the RAII object.\n\nAnother typical example is interacting with files: We could have an object that represents a file that is open for writing, wherein the file is opened in the constructor and closed when execution leaves the object's scope. In both cases, RAII ensures only that the resource in question is released appropriately; care must still be taken to maintain exception safety. If the code modifying the data structure or file is not exception-safe, the mutex could be unlocked or the file closed with the data structure or file corrupted.\n\nOwnership of dynamically allocated objects (memory allocated with in C++) can also be controlled with RAII, such that the object is released when the RAII (stack-based) object is destroyed. For this purpose, the C++11 standard library defines the smart pointer classes for single-owned objects and for objects with shared ownership. Similar classes are also available through in C++98, and in the Boost libraries.\n\nAlso, messages can be sent to network resources using RAII. In this case, the RAII object would send a message to a socket at the end of the constructor, when its initialization is completed. It would also send a message at the beginning of the destructor, when the object is about to be destroyed. Such a construct might be used in a client object to establish a connection with a server running in another process.\n\nBoth Clang and the GNU Compiler Collection implement a non-standard extension to the C language to support RAII: the \"cleanup\" variable attribute.[16] The following annotates a variable with a given destructor function that it will call when the variable goes out of scope:\n\nIn this example, the compiler arranges for the fclosep function to be called on logfile before example_usage returns.\n\nRAII only works for resources acquired and released (directly or indirectly) by stack-allocated objects, where there is a well-defined static object lifetime. Heap-allocated objects which themselves acquire and release resources are common in many languages, including C++. RAII depends on heap-based objects to be implicitly or explicitly deleted along all possible execution paths, in order to trigger its resource-releasing destructor (or equivalent).[17]: 8:27 This can be achieved by using smart pointers to manage all heap objects, with weak pointers for cyclically referenced objects.\n\nIn C++, stack unwinding is only guaranteed to occur if the exception is caught somewhere. This is because \"If no matching handler is found in a program, the function terminate() is called; whether or not the stack is unwound before this call to terminate() is implementation-defined (15.5.1).\" (C++03 standard, §15.3/9).[18] This behavior is usually acceptable, since the operating system releases remaining resources like memory, files, sockets, etc. at program termination.[citation needed]\n\nAt the 2018 Gamelab conference, Jonathan Blow claimed that use of RAII can cause memory fragmentation which in turn can cause cache misses and a 100 times or worse hit on performance.[19]\n\nPerl, Python (in the CPython implementation),[20] and PHP[21] manage object lifetime by reference counting, which makes it possible to use RAII. Objects that are no longer referenced are immediately destroyed or finalized and released, so a destructor or finalizer can release the resource at that time. However, it is not always idiomatic in such languages, and is specifically discouraged in Python (in favor of context managers and finalizers from the weakref package).[citation needed]\n\nHowever, object lifetimes are not necessarily bound to any scope, and objects may be destroyed non-deterministically or not at all. This makes it possible to accidentally leak resources that should have been released at the end of some scope. Objects stored in a static variable (notably a global variable) may not be finalized when the program terminates, so their resources are not released; CPython makes no guarantee of finalizing such objects, for instance. Further, objects with circular references will not be collected by a simple reference counter, and will live indeterminately long; even if collected (by more sophisticated garbage collection), destruction time and destruction order will be non-deterministic. In CPython there is a cycle detector which detects cycles and finalizes the objects in the cycle, though prior to CPython 3.4, cycles are not collected if any object in the cycle has a finalizer.[22]\n• None Stroustrup, Bjarne (1994). The Design and Evolution of C++. Addison-Wesley. Bibcode:1994dec..book.....S. ISBN .\n• Sample Chapter: \"Gotcha #67: Failure to Employ Resource Acquisition Is Initialization\" by Stephen C. Dewhurst\n• Article: \"The Law of The Big Two\" by Bjorn Karlsson and Matthew Wilson\n• Article: \"Implementing the 'Resource Acquisition is Initialization' Idiom\" by Danny Kalev\n• Article: \"RAII, Dynamic Objects, and Factories in C++\" by Roland Pibinger\n• RAII in Delphi: \"One-liner RAII in Delphi\" by Barry Kelly\n• Guide: RAII in C++ by W3computing"
    },
    {
        "link": "https://reddit.com/r/cpp_questions/comments/d78wg4/what_is_raii",
        "document": "So, I saw a post about someone transitioning from C# to C++. And a lot of people said something about RAII. What is that, and where can I find something to explain it? Thanks in advance!!!"
    }
]