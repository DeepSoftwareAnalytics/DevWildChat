[
    {
        "link": "https://vuejs.org/guide/essentials/forms",
        "document": "When dealing with forms on the frontend, we often need to sync the state of form input elements with corresponding state in JavaScript. It can be cumbersome to manually wire up value bindings and change event listeners:\n\nThe directive helps us simplify the above to:\n\nIn addition, can be used on inputs of different types, , and elements. It automatically expands to different DOM property and event pairs based on the element it is used on:\n• with text types and elements use property and event;\n• and use property and event;\n• uses as a prop and as an event.\n\nNote that interpolation inside won't work. Use instead.\n\nWe can also bind multiple checkboxes to the same array or Set value:\n\nIn this case, the array will always contain the values from the currently checked boxes.\n\nIf the initial value of your expression does not match any of the options, the element will render in an \"unselected\" state. On iOS this will cause the user not being able to select the first item because iOS does not fire a change event in this case. It is therefore recommended to provide a disabled option with an empty value, as demonstrated in the example above.\n\nSelect options can be dynamically rendered with :\n\nFor radio, checkbox and select options, the binding values are usually static strings (or booleans for checkbox):\n\nBut sometimes we may want to bind the value to a dynamic property on the current active instance. We can use to achieve that. In addition, using allows us to bind the input value to non-string values.\n\nand are Vue-specific attributes that only work with . Here the property's value will be set to when the box is checked, and set to when unchecked. You can also bind them to dynamic values using :\n\nwill be set to the value of when the first radio input is checked, and set to the value of when the second one is checked.\n\nsupports value bindings of non-string values as well! In the above example, when the option is selected, will be set to the object literal value of .\n\nBy default, syncs the input with the data after each event (with the exception of IME composition as stated above). You can add the modifier to instead sync after events:\n\nIf you want user input to be automatically typecast as a number, you can add the modifier to your managed inputs:\n\nIf the value cannot be parsed with , then the original (string) value is used instead. In particular, if the input is empty (for instance after the user clearing the input field), an empty string is returned. This behavior differs from the DOM property .\n\nThe modifier is applied automatically if the input has .\n\nIf you want whitespace from user input to be trimmed automatically, you can add the modifier to your -managed inputs:\n\nHTML's built-in input types won't always meet your needs. Fortunately, Vue components allow you to build reusable inputs with completely customized behavior. These inputs even work with ! To learn more, read about Usage with in the Components guide."
    },
    {
        "link": "https://stackoverflow.com/questions/41001192/setting-a-checkbox-as-checked-with-vue-js",
        "document": "I have been googling and playing with every combination I know but I cannot get my checkboxes to be initialised as checked.\n\nAn example of the modules data:\n\nWhat can I do to initially set the checked status of the checkboxes?"
    },
    {
        "link": "https://v2.vuejs.org/v2/guide/forms",
        "document": "You can use the directive to create two-way data bindings on form input, textarea, and select elements. It automatically picks the correct way to update the element based on the input type. Although a bit magical, is essentially syntax sugar for updating data on user input events, plus special care for some edge cases.\n\nwill ignore the initial , , or attributes found on any form elements. It will always treat the Vue instance data as the source of truth. You should declare the initial value on the JavaScript side, inside the option of your component.\n\ninternally uses different properties and emits different events for different input elements:\n• text and textarea elements use property and event;\n• checkboxes and radiobuttons use property and event;\n• select fields use as a prop and as an event.\n\nFor languages that require an IME (Chinese, Japanese, Korean, etc.), you’ll notice that doesn’t get updated during IME composition. If you want to cater to these updates as well, use the event instead.\n\nInterpolation on textareas ( ) won't work. Use instead.\n\nMultiple checkboxes, bound to the same Array:\n\nIf the initial value of your expression does not match any of the options, the element will render in an “unselected” state. On iOS, this will prevent the user from being able to select the first item, because iOS does not fire a event in this case. It is therefore recommended to provide a option with an empty value, as demonstrated in the example above.\n\nFor radio, checkbox and select options, the binding values are usually static strings (or booleans for checkboxes):\n\nBut sometimes, we may want to bind the value to a dynamic property on the Vue instance. We can use to achieve that. In addition, using allows us to bind the input value to non-string values.\n\nThe and attributes don’t affect the input’s attribute, because browsers don’t include unchecked boxes in form submissions. To guarantee that one of two values is submitted in a form (i.e. “yes” or “no”), use radio inputs instead.\n\nBy default, syncs the input with the data after each event (with the exception of IME composition, as stated above). You can add the modifier to instead sync after events:\n\nIf you want user input to be automatically typecast as a Number, you can add the modifier to your managed inputs:\n\nThis is often useful, because even with , the value of HTML input elements always returns a string. If the value cannot be parsed with , then the original value is returned.\n\nIf you want whitespace from user input to be trimmed automatically, you can add the modifier to your -managed inputs:\n\nHTML’s built-in input types won’t always meet your needs. Fortunately, Vue components allow you to build reusable inputs with completely customized behavior. These inputs even work with !\n\nTo learn more, read about custom inputs in the Components guide."
    },
    {
        "link": "https://stackoverflow.com/questions/50506235/vuejs-click-event-from-checkbox",
        "document": "If you'd like the function to be called after the value has been changed, you can wrap your handler functionality inside of . You can read about , but the gist is\n\nDefer the callback to be executed after the next DOM update cycle. Use it immediately after you’ve changed some data to wait for the DOM update.\n\nSo your handler will get called after the DOM gets updated, aka after your state has changed and the effects have been reflected in the DOM."
    },
    {
        "link": "https://bootstrap-vue.org/docs/components/form-checkbox",
        "document": ""
    },
    {
        "link": "https://vuejs.org/guide/essentials/event-handling",
        "document": "We can use the directive, which we typically shorten to the symbol, to listen to DOM events and run some JavaScript when they're triggered. The usage would be or with the shortcut, .\n\nThe handler value can be one of the following:\n• None Inline handlers: Inline JavaScript to be executed when the event is triggered (similar to the native attribute).\n• None Method handlers: A property name or path that points to a method defined on the component.\n\nInline handlers are typically used in simple cases, for example:\n\nThe logic for many event handlers will be more complex though, and likely isn't feasible with inline handlers. That's why can also accept the name or path of a component method you'd like to call.\n\nA method handler automatically receives the native DOM Event object that triggers it - in the example above, we are able to access the element dispatching the event via .\n\nThe template compiler detects method handlers by checking whether the value string is a valid JavaScript identifier or property access path. For example, , and are treated as method handlers, while and are treated as inline handlers.\n\nInstead of binding directly to a method name, we can also call methods in an inline handler. This allows us to pass the method custom arguments instead of the native event:\n\nSometimes we also need to access the original DOM event in an inline handler. You can pass it into a method using the special variable, or use an inline arrow function:\n\nIt is a very common need to call or inside event handlers. Although we can do this easily inside methods, it would be better if the methods can be purely about data logic rather than having to deal with DOM event details.\n\nTo address this problem, Vue provides event modifiers for . Recall that modifiers are directive postfixes denoted by a dot.\n\nThe , , and modifiers mirror the options of the native method:\n\nThe modifier is typically used with touch event listeners for improving performance on mobile devices.\n\nWhen listening for keyboard events, we often need to check for specific keys. Vue allows adding key modifiers for or when listening for key events:\n\nYou can directly use any valid key names exposed via as modifiers by converting them to kebab-case.\n\nIn the above example, the handler will only be called if is equal to .\n\nVue provides aliases for the most commonly used keys:\n\nYou can use the following modifiers to trigger mouse or keyboard event listeners only when the corresponding modifier key is pressed:\n\nThe modifier allows control of the exact combination of system modifiers needed to trigger an event.\n\nThese modifiers restrict the handler to events triggered by a specific mouse button.\n\nNote, however, that , , and modifier names are based on the typical right-handed mouse layout, but in fact represent \"main\", \"secondary\", and \"auxiliary\" pointing device event triggers, respectively, and not the actual physical buttons. So that for a left-handed mouse layout the \"main\" button might physically be the right one but would trigger the modifier handler. Or a trackpad might trigger the handler with a one-finger tap, the handler with a two-finger tap, and the handler with a three-finger tap. Similarly, other devices and event sources generating \"mouse\" events might have trigger modes that are not related to \"left\" and \"right\" whatsoever."
    },
    {
        "link": "https://v2.vuejs.org/v2/guide/forms",
        "document": "You can use the directive to create two-way data bindings on form input, textarea, and select elements. It automatically picks the correct way to update the element based on the input type. Although a bit magical, is essentially syntax sugar for updating data on user input events, plus special care for some edge cases.\n\nwill ignore the initial , , or attributes found on any form elements. It will always treat the Vue instance data as the source of truth. You should declare the initial value on the JavaScript side, inside the option of your component.\n\ninternally uses different properties and emits different events for different input elements:\n• text and textarea elements use property and event;\n• checkboxes and radiobuttons use property and event;\n• select fields use as a prop and as an event.\n\nFor languages that require an IME (Chinese, Japanese, Korean, etc.), you’ll notice that doesn’t get updated during IME composition. If you want to cater to these updates as well, use the event instead.\n\nInterpolation on textareas ( ) won't work. Use instead.\n\nMultiple checkboxes, bound to the same Array:\n\nIf the initial value of your expression does not match any of the options, the element will render in an “unselected” state. On iOS, this will prevent the user from being able to select the first item, because iOS does not fire a event in this case. It is therefore recommended to provide a option with an empty value, as demonstrated in the example above.\n\nFor radio, checkbox and select options, the binding values are usually static strings (or booleans for checkboxes):\n\nBut sometimes, we may want to bind the value to a dynamic property on the Vue instance. We can use to achieve that. In addition, using allows us to bind the input value to non-string values.\n\nThe and attributes don’t affect the input’s attribute, because browsers don’t include unchecked boxes in form submissions. To guarantee that one of two values is submitted in a form (i.e. “yes” or “no”), use radio inputs instead.\n\nBy default, syncs the input with the data after each event (with the exception of IME composition, as stated above). You can add the modifier to instead sync after events:\n\nIf you want user input to be automatically typecast as a Number, you can add the modifier to your managed inputs:\n\nThis is often useful, because even with , the value of HTML input elements always returns a string. If the value cannot be parsed with , then the original value is returned.\n\nIf you want whitespace from user input to be trimmed automatically, you can add the modifier to your -managed inputs:\n\nHTML’s built-in input types won’t always meet your needs. Fortunately, Vue components allow you to build reusable inputs with completely customized behavior. These inputs even work with !\n\nTo learn more, read about custom inputs in the Components guide."
    },
    {
        "link": "https://stackoverflow.com/questions/43612473/vuejs-2-how-to-update-v-model-by-component",
        "document": "I would like to create a component for i-check but I cannot get the v-model data during form submission.\n\nI can do it via normal input element.\n\nBelow is an example. Thanks"
    },
    {
        "link": "https://v2.vuejs.org/v2/guide/components-custom-events",
        "document": "Unlike components and props, event names don’t provide any automatic case transformation. Instead, the name of an emitted event must exactly match the name used to listen to that event. For example, if emitting a camelCased event name:\n\nListening to the kebab-cased version will have no effect:\n\nUnlike components and props, event names will never be used as variable or property names in JavaScript, so there’s no reason to use camelCase or PascalCase. Additionally, event listeners inside DOM templates will be automatically transformed to lowercase (due to HTML’s case-insensitivity), so would become – making impossible to listen to.\n\nFor these reasons, we recommend you always use kebab-case for event names.\n\nBy default, on a component uses as the prop and as the event, but some input types such as checkboxes and radio buttons may want to use the attribute for a different purpose. Using the option can avoid a conflict in such cases:\n\nNow when using on this component:\n\nthe value of will be passed to the prop. The property will then be updated when emits a event with a new value.\n\nNote that you still have to declare the prop in the component’s option.\n\nThere may be times when you want to listen directly to a native event on the root element of a component. In these cases, you can use the modifier for :\n\nThis can be useful sometimes, but it’s not a good idea when you’re trying to listen on a very specific element, like an . For example, the component above might refactor so that the root element is actually a element:\n\nIn that case, the listener in the parent would silently break. There would be no errors, but the handler wouldn’t be called when we expected it to.\n\nTo solve this problem, Vue provides a property containing an object of listeners being used on the component. For example:\n\nUsing the property, you can forward all event listeners on the component to a specific child element with . For elements like , that you also want to work with , it’s often useful to create a new computed property for listeners, like below:\n\nNow the component is a fully transparent wrapper, meaning it can be used exactly like a normal element: all the same attributes and listeners will work, without the modifier.\n\nIn some cases, we may need “two-way binding” for a prop. Unfortunately, true two-way binding can create maintenance issues, because child components can mutate the parent without the source of that mutation being obvious in both the parent and the child.\n\nThat’s why instead, we recommend emitting events in the pattern of . For example, in a hypothetical component with a prop, we could communicate the intent of assigning a new value with:\n\nThen the parent can listen to that event and update a local data property, if it wants to. For example:\n\nFor convenience, we offer a shorthand for this pattern with the modifier:\n\nNote that with the modifier does not work with expressions (e.g. is invalid). Instead, you must only provide the name of the property you want to bind, similar to .\n\nThe modifier can also be used with when using an object to set multiple props at once:\n\nThis passes each property in the object (e.g. ) as an individual prop, then adds update listeners for each one.\n\nUsing with a literal object, such as in , will not work, because there are too many edge cases to consider in parsing a complex expression like this."
    },
    {
        "link": "https://stackoverflow.com/questions/56953243/vue-component-v-model-with-input-handler",
        "document": "I'm trying to make a wrapper component for an element in Vue.js.\n\nThis seems to work just fine. The model gets updated via the input event handler by emitting the target element value.\n\nHowever, now I'm trying to use this component with some existing code:\n\nThis is where I'm having trouble with the event. I'm getting the following error:\n\nSo, my is emitting the value and now the existing event handler can't reference the properly.\n\nIf I change my component's method to emit the instead of , the new code seems to work, but then model gets updated to the InputEvent instead of the actual value.\n\nI'm not sure what I need to do."
    }
]