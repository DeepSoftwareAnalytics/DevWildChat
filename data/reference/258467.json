[
    {
        "link": "https://docs.opencv.org/4.x/d6/d00/tutorial_py_root.html",
        "document": "\n• Learn how to setup OpenCV-Python on your computer!\n• Here you will learn how to display and save images and videos, control mouse events and create trackbar.\n• In this section you will learn basic operations on image like pixel editing, geometric transformations, code optimization, some mathematical tools etc.\n• In this section you will learn different image processing functions inside OpenCV.\n• In this section you will learn about feature detectors and descriptors\n• In this section you will learn different techniques to work with videos like object tracking etc.\n• In this section we will learn about camera calibration, stereo imaging etc.\n• In this section you will learn different image processing functions inside OpenCV.\n• In this section you will learn different computational photography techniques like image denoising etc.\n• In this section you will learn object detection techniques like face detection etc.\n• In this section, we will see how OpenCV-Python bindings are generated"
    },
    {
        "link": "https://geeksforgeeks.org/image-enhancement-techniques-using-opencv-python",
        "document": "Image enhancement is the process of improving the quality and appearance of an image. It can be used to correct flaws or defects in an image, or to simply make an image more visually appealing. Image enhancement techniques can be applied to a wide range of images, including photographs, scans, and digital images. Some common goals of image enhancement include increasing contrast, sharpness, and colorfulness; reducing noise and blur; and correcting distortion and other defects. Image enhancement techniques can be applied manually using image editing software, or automatically using algorithms and computer programs such as OpenCV. \n\nIn this article, we will explore a variety of image enhancement techniques that can be performed using OpenCV and Python. OpenCV is a powerful, open-source computer vision library that provides a wide range of image processing and computer vision algorithms. By combining the capabilities of OpenCV with the versatility of Python, we can easily implement a variety of image enhancement techniques to improve the quality and appearance of our images. \n\nIn the following sections, we will discuss the different image enhancement techniques and how to implement them using OpenCV and Python. There are several image enhancement techniques that you can use with OpenCV and Python to improve the quality and clarity of images. Here are a few examples:\n\nAdjusting the brightness and contrast of an image can significantly affect its visual appeal and effectiveness. It can also help to correct defects or flaws in the image and make it easier to see details. Finding the right balance of brightness and contrast is important for creating an attractive and effective image.\n\nThere are several ways to adjust the brightness and contrast of an image using OpenCV and Python. One common method is to use the cv2.addWeighted() function, which allows you to adjust the brightness by adding a scalar value to each pixel in the image, and the contrast by scaling the pixel values.\n\nHere is an example of how to adjust the brightness and contrast of an image using the cv2.addWeighted() function:\n\nIn this example, the brightness of the image is adjusted by adding 10 to each pixel value, and the contrast is adjusted by scaling the pixel values by 2.3. You can adjust the values of brightness and contrast to achieve the desired level of brightness and contrast.\n\nAnother method for adjusting the brightness and contrast of an image is to use the cv2.convertScaleAbs() function, which allows you to adjust the brightness and contrast using a combination of scaling and shifting the pixel values.\n\nIn this example, the brightness and contrast are adjusted using a combination of scaling and shifting the pixel values. You can adjust the values of alpha and beta to achieve the desired level of brightness and contrast.\n\nSharpening is the process of enhancing the edges and fine details in an image to make it appear sharper and more defined. It is important because it can help to bring out the details and features in an image, making it more visually appealing and easier to understand. Sharpening can be used to correct blur or softness in an image and can be applied using a variety of techniques.\n\nOne common method for sharpening images using OpenCV and Python is to use the cv2.filter2D() function, which convolves the image with a kernel. The kernel can be designed to enhance the edges in the image, resulting in a sharper image.\n\nHere is an example of how to sharpen an image using the cv2.filter2D() function:\n\nIn this example, a 3×3 sharpening kernel is used to enhance the edges in the image. You can experiment with different kernels to achieve the desired level of sharpening. Numpy is used to create the sharpening kernel is created as a NumPy array using the np.array() function. This array is then passed as an argument to the cv2.filter2D() function, which convolves the image with the kernel to sharpen it.\n\nAnother method for sharpening images is to use the cv2.Laplacian() function, which calculates the Laplacian of an image and returns the result as a sharpened image.\n\nIn this example, the Laplacian operator calculates the sharpened image. You can adjust the depth of the output image using the cv2.CV_64F parameter.\n\nNoise reduction is the process of removing or reducing unwanted noise or artifacts from an image. It is important because it can improve the visual quality and clarity of the image and make it easier to analyze or process using computer algorithms. Noise can be introduced into an image due to a variety of factors and can degrade its quality. There are several techniques for reducing noise, including using filters such as the median filter or the Gaussian filter. It is important to apply noise reduction judiciously to avoid blur or loss of detail in the image.\n\nOne common method for removing noise from images using OpenCV and Python is to use a median filter. The median filter works by replacing each pixel in the image with the median value of a set of neighboring pixels. This can help to smooth out noise and reduce artifacts in the image.\n\nHere is an example of how to remove noise from an image using the cv2.medianBlur() function in OpenCV:\n\nIn this example, the cv2.medianBlur() function is used to apply a median filter to the image. The 5 parameter specifies the size of the kernel to use for the filter. You can adjust the kernel size to achieve the desired level of noise reduction.\n\nAnother method for removing noise from images is to use a Gaussian filter, which uses a weighted average of neighboring pixels to smooth out noise and reduce artifacts. You can use the cv2.GaussianBlur() function to apply a Gaussian filter to an image in OpenCV.\n\nIn this example, the cv2.GaussianBlur() function is used to apply a Gaussian filter to the image. The (5, 5) parameter specifies the size of the kernel to use for the filter, and the 0 parameter specifies the standard deviation of the Gaussian function. You can adjust these parameters to achieve the desired level of noise reduction.\n\nColor enhancement is adjusting the colors in an image to make them more vibrant, balanced, or natural. It can be used to correct color defects or problems in an image or to simply make an image more appealing and aesthetically pleasing. Color enhancement is important because it can significantly affect the visual impact and effectiveness of an image. It can also be useful for correcting color errors or problems in an image and can make it easier to see details and features in the image. There are several techniques for enhancing the colors in an image, including adjusting the color balance, adjusting the saturation, and adjusting the hue.\n\nThere are several ways to enhance the colors in an image using OpenCV and Python. One common method is to use the cv2.cvtColor() function, which allows you to convert the image from one color space to another. This can be useful for adjusting the color balance or saturation of the image.\n\nHere is an example of how to enhance the colors in an image using the cv2.cvtColor() function:\n\nThis code first converts the image from the BGR color space to the HSV color space using the cv2.cvtColor() function. It then adjusts the hue, saturation, and value (brightness) of the image by multiplying the corresponding channels by a scalar value. Finally, it converts the image back to the BGR color space and saves the modified image. You can adjust the scalar values to achieve the desired level of color enhancement.\n\nImage resizing and scaling involve adjusting the dimensions and size of an image. Both are important for meeting specific requirements or context, such as fitting a specific size or aspect ratio or reducing the file size. There are several techniques, including interpolation methods like the nearest neighbor, bilinear, and bicubic interpolation. It is important to choose a method that preserves image quality and clarity.\n\nYou can use the cv2.resize() function in OpenCV to resize and scale images. The cv2.resize() function takes the following arguments:\n• dsize: The size of the output image, specified as a tuple (width, height).\n• fx: The scaling factor along the x-axis.\n• fy: The scaling factor along the y-axis.\n• interpolation: The interpolation method to use.\n\nHere is an example of how to use the cv2.resize() function to resize an image:\n\nIn this example, the image is resized to a width of 400 pixels and a height of 300 pixels.\n\nYou can also use the fx and fy parameters to specify the scaling factors along the x-axis and y-axis, respectively. For example:\n\nIn this example, the image is scaled by a factor of 2 along both axes, resulting in an image that is twice the size of the original. The interpolation parameter allows you to specify the interpolation method to use when resizing or scaling the image. The available options include cv2.INTER_NEAREST, cv2.INTER_LINEAR, cv2.INTER_CUBIC, and others.\n\nThis is just a basic example of how to resize and scale images using OpenCV and Python. You can adjust the size and scaling factors to achieve the desired results, and you can also specify the interpolation method to use when resizing or scaling the image.\n\nWe can also inverse the color by simply subtracting each value from 255\n\nHistogram equalization is a technique used to adjust the contrast of an image by spreading out the intensity values of the pixels in the image. It is important because it can improve the contrast and clarity of an image, making it easier to see details and features that might be difficult to see in an image with low contrast. There are several different methods for performing histogram equalization, including global histogram equalization and local histogram equalization. Global histogram equalization adjusts the contrast of the entire image, while local histogram equalization adjusts the contrast in small, localized areas of the image.\n\nYou can use the cv2.equalizeHist() function in OpenCV to equalize the histogram of an image. This function takes the image data as an argument and returns the equalized image data. Here is an example of how to use the cv2.equalizeHist() function to equalize the histogram of an image:\n\nIn this example, the image is first loaded from a file using the cv2.imread() function. It is then converted to grayscale using the cv2.cvtColor() function. The cv2.equalizeHist() function is then called and passed the grayscale image data as an argument. The equalized image data is stored in the equalized_image variable. Finally, the modified image is saved to a file using the cv2.imwrite() function.\n\nNote that the cv2.equalizeHist() function only works on grayscale images. If you want to equalize the histogram of a color image, you will need to convert the image to a color space that separates the intensity values (such as the YCrCb color space) and apply histogram equalization to the intensity channel. You can then convert the image back to the original color space if desired.\n\nImage enhancement is a wide field that involves adjusting images to improve their visual quality or to make them more suitable for further analysis. There are many techniques for enhancing images, such as:\n• Morphological transformations: These are operations based on the image shape. They are typically applied to binary images, but can also be used with grayscale images. Examples include dilation, erosion, opening, closing, etc. Operations can be used to enhance or modify the shape or structure of objects in an image. To apply morphological operations with OpenCV and Python, you can use functions such as erode, dilate, and morphologyEx.\n• Edge detection: OpenCV provides several functions for performing edge detection, such as Canny(), Sobel(), and Laplacian(). These functions can be used to identify edges in an image by looking for sharp changes in pixel intensity.\n• Color correction: OpenCV provides several functions for adjusting the colors in an image, such as cvtColor() and inRange(). These functions can be used to perform tasks such as color balance, color grading, and white balancing.\n• Image gradients: OpenCV provides several functions for computing image gradients, such as Scharr(), Sobel(), and Laplacian(). These functions can be used to highlight changes in pixel intensity in an image and can be useful for tasks such as edge detection and image segmentation.\n• Image cropping: Cropping techniques can be used to remove unwanted areas from an image. To crop an image, you can use the copyMakeBorder function to create a new image with the desired dimensions, and then copy the relevant portion of the original image into the new image.\n• Image rotation: Rotation techniques can be used to change the orientation of an image. To rotate an image with OpenCV, you can use the warpAffine function with a rotation matrix.\n• Image blending: Blending techniques can be used to combine two or more images together. To blend images with OpenCV and Python, you can use the addWeighted function to combine the images using a weighted average.\n• Image thresholding: Thresholding techniques can be used to convert an image to black and white by setting a threshold value for pixel intensity. To apply thresholding, you can use the threshold function.\n• Image deblurring: Deblurring techniques can be used to remove blur from an image caused by camera shake, out-of-focus subjects, or other factors. To deblur an image, you can use the wiener function, which applies a Wiener filter to the image.\n\n\n\nOpenCV is a powerful library for image processing and computer vision tasks and it provides many advanced image enhancement techniques that can be used for a variety of applications. Some of these techniques are:\n• Super-resolution: OpenCV provides the pyrUp() and pyrDown() functions for upsampling and downsampling images, respectively. These functions can be used as part of a super-resolution algorithm to increase the resolution of an image.\n• Image restoration: OpenCV provides several functions for image restoration, such as fastNlMeansDenoising() and fastNlMeansDenoisingColored(). These functions can be used to remove noise and improve the visual quality of an image.\n• Image fusion: OpenCV provides the addWeighted() function for combining two images using a weighted sum. This function can be used to fuse multiple images of the same scene to create a single image that contains more information or is of higher quality.\n• Image segmentation: OpenCV provides several functions for image segmentation, including threshold(), adaptiveThreshold(), and findContours(). These functions can be used to partition an image into regions or segments that correspond to different objects or regions of interest.\n• Image recognition: OpenCV provides several functions for image recognition, including HOGDescriptor() and SIFT(). These functions can be used to extract features from an image and train a machine-learning model to recognize objects or scenes.\n• Object detection: OpenCV provides several functions for object detection, including HOGDescriptor() and SIFT(). These functions can be used to detect and locate objects in an image or video in real time.\n• Image registration: OpenCV provides the registerTranslation() function for aligning or registering two or more images of the same scene. This function can be used to align images from different sensors or from different viewpoints.\n• Image stitching: Image stitching techniques can be used to combine multiple images into a single panoramic or mosaic image. To apply image stitching with OpenCV and Python, you can use techniques such as feature matching, which matches the features in the source images to create a common reference frame, and image warping, which warps the images to align them with the reference frame.\n\n\n\nTo effectively use image enhancement techniques using OpenCV and Python, it is important to choose the right technique for your images and desired outcomes, experiment with different parameters, use caution when increasing image contrast, use color appropriately, and consider using other image processing techniques as needed. For further reading and resources on image enhancement using OpenCV and Python, consider exploring the OpenCV documentation and tutorials, as well as online resources such as the PyImageSearch blog and tutorials, and the Python Machine Learning with OpenCV course. \n\nIn conclusion, image enhancement is a crucial technique used to improve the visual quality of images in various fields such as medicine, robotics, security, photography, remote sensing, and manufacturing. OpenCV is a powerful open-source library that provides a wide range of image enhancement techniques for use in Python. By using OpenCV, developers can easily implement image enhancement techniques in their applications to improve the visual quality of images and extract valuable information from them. Whether you are a researcher, a developer, or a professional working in a field that relies on images, OpenCV and Python offers a flexible and powerful toolkit for enhancing the quality of your images."
    },
    {
        "link": "https://docs.opencv.org/4.x/d2/d96/tutorial_py_table_of_contents_imgproc.html",
        "document": "\n• Learn to change images between different color spaces. Plus learn to track a colored object in a video.\n• Learn to apply different geometric transformations to images like rotation, translation etc.\n• Learn to convert images to binary images using global thresholding, Adaptive thresholding, Otsu's binarization etc\n• Learn to blur the images, filter the images with custom kernels etc.\n• Learn about morphological transformations like Erosion, Dilation, Opening, Closing etc\n• Learn about image pyramids and how to use them for image blending\n• All about Contours in OpenCV\n• All about histograms in OpenCV\n• Meet different Image Transforms in OpenCV like Fourier Transform, Cosine Transform etc.\n• Learn to search for an object in an image using Template Matching\n• Learn to detect lines in an image\n• Learn to detect circles in an image"
    },
    {
        "link": "https://bhavikjikadara.medium.com/image-processing-using-opencv-a-step-by-step-guide-e589b0acbbf3",
        "document": "Image processing is a crucial part of modern fields like AI, computer vision, and robotics. OpenCV, a powerful open-source library, allows developers to handle complex image tasks with ease. This blog will guide you through essential image processing techniques using Python, covering everything from reading and displaying images, converting color spaces, and resizing images, to more advanced tasks like edge detection, contour detection, and thresholding. With hands-on examples, you’ll learn to manipulate and enhance images effortlessly.\n\nOpenCV is a widely used open-source computer vision library that allows developers to manipulate images and video streams with minimal effort. It’s the go-to solution for many tasks such as image recognition, filtering, edge detection, and more. OpenCV is also cross-platform, making it a perfect choice for large-scale AI and machine-learning applications.\n\nBefore we start, let’s make sure OpenCV is installed. You can easily install it using :"
    },
    {
        "link": "https://stackoverflow.com/questions/56304657/how-to-see-python-docs-for-opencv",
        "document": "I am using python and try to do some denoising using opencv as in this tutorial:\n\nHowever, when I want to check the parameters to the function and click on for example \"cv2.fastNlMeansDenoising\" I come to the documentation for the C++-implementation. How can I find the python documentation?!"
    },
    {
        "link": "https://geeksforgeeks.org/histograms-equalization-opencv",
        "document": ""
    },
    {
        "link": "https://pyimagesearch.com/2021/02/01/opencv-histogram-equalization-and-adaptive-histogram-equalization-clahe",
        "document": "In this tutorial, you will learn to perform both histogram equalization and adaptive histogram equalization with OpenCV.\n\nHistogram equalization is a basic image processing technique that adjusts the global contrast of an image by updating the image histogram’s pixel intensity distribution. Doing so enables areas of low contrast to obtain higher contrast in the output image.\n• Evenly spreading out and distributing the most frequent pixel values (i.e., the ones with the largest counts in the histogram)\n\nThe result of applying histogram equalization is an image with higher global contrast.\n\nWe can further improve histogram equalization by applying an algorithm called Contrast Limited Adaptive Histogram Equalization (CLAHE), resulting in higher quality output images.\n\nOther than photographers using histogram equalization to correct under/over-exposed images, the most widely used histogram equalization application can be found in the medical field.\n\nYou’ll typically see histogram equalization applied to X-ray scans and CT scans to improve the radiograph’s contrast. Doing so helps doctors and radiologists better interpret the scans and make an accurate diagnosis.\n\nBy the end of this tutorial, you will be able to successfully apply both basic histogram equalization and adaptive histogram equalization to images with OpenCV.\n\nTo learn to use histogram equalization and adaptive histogram equalization with OpenCV, just keep reading.\n\nIn the first part of this tutorial, we’ll discuss what histogram equalization is and how we can apply histogram equalization with OpenCV.\n\nFrom there, we’ll configure our development environment and then review the project directory structure for this guide.\n\nWe’ll wrap up this guide with a discussion of our results.\n\nHistogram equalization is a basic image processing technique that can improve an image’s overall contrast.\n\nApplying histogram equalization starts by computing the histogram of pixel intensities in an input grayscale/single-channel image:\n\nNotice how our histogram has numerous peaks, indicating there are a good number of pixels binned to those respective buckets. With histogram equalization, our goal is to spread these pixels to buckets that don’t have as many pixels binned to them.\n\nMathematically, what this means is that we’re attempting to apply a linear trend to our cumulative distribution function (CDF):\n\nThe before and after histogram equalization application can be seen in Figure 3:\n\nNotice how the input image’s contrast has improved significantly but at the expense of also boosting the contrast of the noise in the input image.\n\nThe answer is “Yes,” you just need to apply adaptive histogram equalization.\n\nWith adaptive histogram equalization, we divide an input image into an M x N grid. We then apply equalization to each cell in the grid, resulting in a higher quality output image:\n\nThe downside is that adaptive histogram equalization is by definition more computationally complex (but given modern hardware, both implementations are still quite speedy).\n\nHow can we use OpenCV for histogram equalization?\n\nOpenCV includes implementations of both basic histogram equalization and adaptive histogram equalization through the following two functions:\n\nApplying the function is as simple as converting an image to grayscale and then calling on it:\n• Convert the input image to grayscale/extract a single channel from it\n• Call the method on the CLAHE object to apply histogram equalization\n\nIt’s a lot easier than it sounds, requiring only a few lines of code:\n\nNotice that we supply two parameters to :\n• : This is the threshold for contrast limiting\n• : Divides the input image into M x N tiles and then applies histogram equalization to each local tile\n\nYou will get practice using both and in the remainder of this guide.\n\nTo learn how to apply histogram equalization with OpenCV, you need to have the OpenCV library installed.\n\nIf you need help configuring your development environment for OpenCV, I highly recommend that you read my pip install OpenCV guide — it will have you up and running in a matter of minutes.\n\nAll that said, are you:\n• Wanting to skip the hassle of fighting with the command line, package managers, and virtual environments?\n• Ready to run the code right now on your Windows, macOS, or Linux system?\n\nGain access to Jupyter Notebooks for this tutorial and other PyImageSearch guides that are pre-configured to run on Google Colab’s ecosystem right in your web browser! No installation required.\n\nAnd best of all, these Jupyter Notebooks will run on Windows, macOS, and Linux!\n\nBefore we implement histogram equalization with OpenCV, let’s start by reviewing our project directory structure.\n\nBe sure to access the “Downloads” section of this tutorial to retrieve the source code and example images.\n\nFrom there, inspect the project directory structure:\n\nWe have two Python scripts that we’ll be reviewing today:\n• : Uses the CLAHE algorithm to perform adaptive histogram equalization.\n\nOur directory contains example images to which we will apply histogram equalization.\n\nWith our project directory structure reviewed, let’s move on to implementing basic histogram equalization with OpenCV.\n\nOpen the file in your project folder, and let’s get to work:\n\nLines 2 and 3 import our required Python packages while Lines 6-9 parse our command line arguments.\n\nWe only need a single argument here, , which is the path to our input image on disk, where we wish to apply the histogram equalization.\n\nWith the command line arguments parsed, we can move on to the next step:\n\nLine 13 loads our from disk, while Line 14 converts our image from RGB to grayscale.\n\nLine 18 performs basic histogram equalization using the function. The only required argument we must pass in is the grayscale/single-channel image.\n\nNote: When performing histogram equalization with OpenCV, we must supply a grayscale/single-channel image. If we try to pass in a multi-channel image, OpenCV will throw an error. To perform histogram equalization on a multi-channel image, you would need to (1) split the image into its respective channels, (2) equalize each channel, and (3) merge the channels back together.\n\nThe final step is to show our output images:\n\nHere, we are displaying our input image along with the histogram equalized image.\n\nWe are now ready to apply basic histogram equalization with OpenCV!\n\nBe sure to access the “Downloads” section of this tutorial to retrieve the source code and example images.\n\nFrom there, open a terminal and execute the following command:\n\nOn the top, we have the original input image of the moon. The bottom shows the output after applying histogram equalization. Notice that we have boosted the image’s global contrast.\n\nLet’s try a different image, this one of an under-exposed photograph:\n\nThe dog (left) appears washed out due to underexposure. By applying histogram equalization (right), we correct this effect and improve the dog’s contrast.\n\nThe following image highlights one of the limitations of global contrast adjustment via histogram equalization:\n\nThe image on the left shows my wife and me in Boston over the Christmas holiday a few years ago. Due to the auto-adjustment on the camera, our faces are quite dark, and it’s hard to see us.\n\nBy applying histogram equalization (right), we can see that not only are our faces visible, but we can see another couple sitting behind us! Without histogram equalization, you may have missed the other couple.\n\nHowever, our output is not entirely desirable. To start, the fire in the fireplace is totally washed out. And if you study our faces, particularly mine, you’ll see that portions of my forehead are now totally washed out.\n\nTo improve our results, we need to apply adaptive histogram equalization.\n\nAt this point, we’ve seen some of the limitations of basic histogram equalization.\n\nWhile a bit more computationally expensive, adaptive histogram equalization can yield better results than simple histogram equalization. But don’t take my word for it — you should see the results for yourself.\n\nOpen the file in your project directory structure and insert the following code:\n\nWe only need two imports here, for command line arguments and for our OpenCV bindings.\n\nWe then have three command line arguments, one of which is required, the second two optional (but useful to tune and play with when experimenting with CLAHE):\n• : The path to our input image on disk, where we wish to apply histogram equalization.\n• : The threshold for contrast limiting. You’ll typically want to leave this value in the range of . If you set the value too large, then effectively, what you’re doing is maximizing local contrast, which will, in turn, maximize noise (which is the opposite of what you want). Instead, try to keep this value as low as possible.\n• : The tile grid size for CLAHE. Conceptually, what we are doing here is dividing our input image into cells and then applying histogram equalization to each cell (with the additional bells and whistles that CLAHE provides).\n\nLines 17 and 18 load our input image from disk and convert it to grayscale, just like we did for basic histogram equalization.\n\nLines 22 and 23 initialize our object via the function. Here, we supply the and our , which we provided via our command line arguments.\n\nA call to the method applies adaptive histogram equalization to the image.\n\nThe final step is to display the output images to our screen:\n\nHere, we are displaying our input image along with the output image from the CLAHE algorithm.\n\nAccess the “Downloads” section of this tutorial to retrieve the source code and example images.\n\nFrom there, open a shell and execute the following command:\n\nOn the left, we have our original input image. We then apply adaptive histogram equalization on the right — compare these results to that of Figure 4, where we applied basic histogram equalization.\n\nNotice how adaptive histogram equalization has improved the contrast of the input image. My wife and I are more visible. The once near-invisible couple in the background can be seen. There are fewer artifacts on my forehead, etc.\n\nWhen building your own image processing pipelines and finding that histogram equalization should be applied, I suggest starting with simple histogram equalization using . But if you find that the results are poor and instead boost the input image’s noise, you should then try using adaptive histogram equalization through .\n\nI thank Aruther Cotse (University of Utah) for the fantastic report on using histograms for image processing. Cotse’s work inspired some of the example figures in this post.\n\nAdditionally, I acknowledge the contributors to Wikipedia’s page on histogram equalization. If you’re interested in more mathematical details behind histogram equalization, be sure to refer to that page.\n\nThe example image was obtained from this article on EarthSky, while the image came from this page.\n\nCourse information:\n\n 86+ total classes\n• 115+ hours hours of on-demand code walkthrough videos\n• Last updated: March 2025\n\n 4.84 (128 Ratings)\n• 16,000+ Students Enrolled I strongly believe that if you had the right teacher you could master computer vision and deep learning. Do you think learning computer vision and deep learning has to be time-consuming, overwhelming, and complicated? Or has to involve complex mathematics and equations? Or requires a degree in computer science? All you need to master computer vision and deep learning is for someone to explain things to you in simple, intuitive terms. And that’s exactly what I do. My mission is to change education and how complex Artificial Intelligence topics are taught. If you're serious about learning computer vision, your next stop should be PyImageSearch University, the most comprehensive computer vision, deep learning, and OpenCV course online today. Here you’ll learn how to successfully and confidently apply computer vision to your work, research, and projects. Join me in computer vision mastery.\n• ✓ Brand new courses released regularly, ensuring you can keep up with state-of-the-art techniques\n• ✓ Run all code examples in your web browser — works on Windows, macOS, and Linux (no dev environment configuration required!)\n• ✓ Access to centralized code repos for all 540+ tutorials on PyImageSearch\n\nIn this tutorial, you learned how to perform both basic histogram equalization and adaptive histogram equalization with OpenCV.\n\nBasic histogram equalization aims to improve the global contrast of an image by “spreading out” pixel intensities often used in the image.\n\nBut while simple histogram equalization is easy to apply and computationally efficient, the problem is that it can increase noise. What would be basic noise that could be easily filtered out is now further contaminating the signal (i.e., the components of the image we want to process).\n\nIf and when that happens, we can apply adaptive histogram equalization to obtain better results.\n\nAdaptive histogram equalization works by dividing an image into an M x N grid and then applying histogram equalization locally to each grid. The result is an output image that overall has higher contrast with (ideally) the noise still suppressed.\n\nTo download the source code to this post (and be notified when future tutorials are published here on PyImageSearch), simply enter your email address in the form below!"
    },
    {
        "link": "https://geeksforgeeks.org/python-thresholding-techniques-using-opencv-set-2-adaptive-thresholding",
        "document": ""
    },
    {
        "link": "https://docs.opencv.org/4.x/d5/daf/tutorial_py_histogram_equalization.html",
        "document": "\n• We will learn the concepts of histogram equalization and use it to improve the contrast of our images.\n\nConsider an image whose pixel values are confined to some specific range of values only. For eg, brighter image will have all pixels confined to high values. But a good image will have pixels from all regions of the image. So you need to stretch this histogram to either ends (as given in below image, from wikipedia) and that is what Histogram Equalization does (in simple words). This normally improves the contrast of the image.\n\nI would recommend you to read the wikipedia page on Histogram Equalization for more details about it. It has a very good explanation with worked out examples, so that you would understand almost everything after reading that. Instead, here we will see its Numpy implementation. After that, we will see OpenCV function.\n\nYou can see histogram lies in brighter region. We need the full spectrum. For that, we need a transformation function which maps the input pixels in brighter region to output pixels in full region. That is what histogram equalization does.\n\nNow we find the minimum histogram value (excluding 0) and apply the histogram equalization equation as given in wiki page. But I have used here, the masked array concept array from Numpy. For masked array, all operations are performed on non-masked elements. You can read more about it from Numpy docs on masked arrays.\n\nNow we have the look-up table that gives us the information on what is the output pixel value for every input pixel value. So we just apply the transform.\n\nNow we calculate its histogram and cdf as before ( you do it) and result looks like below :\n\nAnother important feature is that, even if the image was a darker image (instead of a brighter one we used), after equalization we will get almost the same image as we got. As a result, this is used as a \"reference tool\" to make all images with same lighting conditions. This is useful in many cases. For example, in face recognition, before training the face data, the images of faces are histogram equalized to make them all with same lighting conditions.\n\nOpenCV has a function to do this, cv.equalizeHist(). Its input is just grayscale image and output is our histogram equalized image.\n\nBelow is a simple code snippet showing its usage for same image we used :\n\nSo now you can take different images with different light conditions, equalize it and check the results.\n\nHistogram equalization is good when histogram of the image is confined to a particular region. It won't work good in places where there is large intensity variations where histogram covers a large region, ie both bright and dark pixels are present. Please check the SOF links in Additional Resources.\n\nThe first histogram equalization we just saw, considers the global contrast of the image. In many cases, it is not a good idea. For example, below image shows an input image and its result after global histogram equalization.\n\nIt is true that the background contrast has improved after histogram equalization. But compare the face of statue in both images. We lost most of the information there due to over-brightness. It is because its histogram is not confined to a particular region as we saw in previous cases (Try to plot histogram of input image, you will get more intuition).\n\nSo to solve this problem, adaptive histogram equalization is used. In this, image is divided into small blocks called \"tiles\" (tileSize is 8x8 by default in OpenCV). Then each of these blocks are histogram equalized as usual. So in a small area, histogram would confine to a small region (unless there is noise). If noise is there, it will be amplified. To avoid this, contrast limiting is applied. If any histogram bin is above the specified contrast limit (by default 40 in OpenCV), those pixels are clipped and distributed uniformly to other bins before applying histogram equalization. After equalization, to remove artifacts in tile borders, bilinear interpolation is applied.\n\nBelow code snippet shows how to apply CLAHE in OpenCV:\n\nSee the result below and compare it with results above, especially the statue region:\n\nAlso check these SOF questions regarding contrast adjustment:\n• How can I adjust contrast in OpenCV in C?\n• How do I equalize contrast & brightness of images using opencv?"
    },
    {
        "link": "https://stackoverflow.com/questions/15561863/fast-image-thresholding",
        "document": "What is a fast and reliable way to threshold images with possible blurring and non-uniform brightness?\n\nBecause the image is not guaranteed to have uniform brightness, it's not feasible to use a fixed threshold. An adaptive threshold works alright, but because of the blurriness it creates breaks and distortions in the features (here, the important features are the Sudoku digits):\n\nI've also tried using Histogram Equalization (using OpenCV's function). It increases contrast without reducing differences in brightness.\n\nThe best solution I've found is to divide the image by its morphological closing (credit to this post) to make the brightness uniform, then renormalize, then use a fixed threshold (using Otsu's algorithm to pick the optimal threshold level):\n\nHere is code for this in OpenCV for Android:\n\nThis works great but the closing operation is very slow. Reducing the size of the structuring element increases speed but reduces accuracy.\n\nEdit: based on DCS's suggestion I tried using a high-pass filter. I chose the Laplacian filter, but I would expect similar results with Sobel and Scharr filters. The filter picks up high-frequency noise in the areas which do not contain features, and suffers from similar distortion to the adaptive threshold due to blurring. it also takes about as long as the closing operation. Here is an example with a 15x15 filter:\n\nEdit 2: Based on AruniRC's answer, I used Canny edge detection on the image with the suggested parameters:\n\nI'm not sure how to reliably automatically fine-tune the parameters to get connected digits."
    }
]