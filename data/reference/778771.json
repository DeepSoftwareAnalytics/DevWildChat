[
    {
        "link": "https://airsdk.dev/reference/actionscript/3.0/flash/system/LoaderContext.html",
        "document": "When loading images (JPEG, GIF, or PNG) instead of SWF files, there is no need to specify a SecurityDomain or an application domain, because those concepts are meaningful only for SWF files. Instead, you have only one decision to make: do you need programmatic access to the pixels of the loaded image? If so, see the checkPolicyFile property. If you want to apply deblocking when loading an image, use the JPEGLoaderContext class instead of the LoaderContext class.\n\nWhen loading a SWF file with the Loader.loadBytes() method, you have the same application domain choice to make as for Loader.load() , but it's not necessary to specify a security domain, because Loader.loadBytes() always places its loaded SWF file into the security domain of the loading SWF file.\n\nWhen loading SWF files with the Loader.load() method, you have two decisions to make: into which security domain the loaded SWF file should be placed, and into which application domain within that security domain? For more details on these choices, see the applicationDomain and securityDomain properties.\n\nThe LoaderContext class provides options for loading SWF files and other media by using the Loader class. The LoaderContext class is used as theparameter in theandmethods of the Loader class.\n\nAn Object containing the parameters to pass to the LoaderInfo object of the content.\n\nSpecifies whether to decode bitmap image data when it is used or when it is loaded.\n\nSpecifies whether the application should attempt to download a URL policy file from the loaded object's server before beginning to load the object itself.\n\nSpecifies whether you can use a Loader object to import content with executable code, such as a SWF file, into the caller's security sandbox.\n\nIndicates whether an instance of the Object class is in the prototype chain of the object specified as the parameter.\n\nSpecifies whether you can use a object to import content with executable code, such as a SWF file, into the caller's security sandbox. There are two affected importing operations: the method, and the method with . (The latter operation is not supported in the AIR application sandbox.) With the property set to , these importing operations are restricted to safe operations, such as loading images. Normal, non-importing SWF file loading with the method is not affected by the value of this property. This property is useful when you want to import image content into your sandbox - for example, when you want to replicate or process an image from a different domain - but you don't want to take the security risk of receiving a SWF file when you expected only an image file. Since SWF files may contain ActionScript code, importing a SWF file is a much riskier operation than importing an image file. In AIR content in the application sandbox, the default value is . In non-application content (which includes all content in Flash Player), the default value is . The property was added in Flash Player 10.1 and AIR 2.0. However, this property is made available to SWF files and AIR applications of all versions when the Flash Runtime supports it.\n\n[read-write] Legacy property, replaced by , but still supported for compatibility. Previously, the only operation affected by was the method, but as of Flash Player 10.1 and AIR 2.0, the import-loading operation of with is affected as well. (The latter operation is not supported in the AIR application sandbox.) This dual effect made the property name overly specific, so now is the preferred property name. Setting either of or will affect the value of both. Specifies whether you can use a object to import content with executable code, such as a SWF file, into the caller's security sandbox. With this property set to , these importing operations are restricted to safe operations, such as loading images. In AIR content in the application sandbox, the default value is . In non-application content, the default value is . \n\n \n\n \n\n\n\nSpecifies the application domain to use for the or method. Use this property only when loading a SWF file written in ActionScript 3.0 (not an image or a SWF file written in ActionScript 1.0 or ActionScript 2.0). Every security domain is divided into one or more application domains, represented by ApplicationDomain objects. Application domains are not for security purposes; they are for managing cooperating units of ActionScript code. If you are loading a SWF file from another domain, and allowing it to be placed in a separate security domain, then you cannot control the choice of application domain into which the loaded SWF file is placed; and if you have specified a choice of application domain, it will be ignored. However, if you are loading a SWF file into your own security domain — either because the SWF file comes from your own domain, or because you are importing it into your security domain — then you can control the choice of application domain for the loaded SWF file. You can pass an application domain only from your own security domain in . Attempting to pass an application domain from any other security domain results in a exception. You have four choices for what kind of property to use:\n• Child of loader's ApplicationDomain. The default. You can explicitly represent this choice with the syntax . This allows the loaded SWF file to use the parent's classes directly, for example by writing . The parent, however, cannot use this syntax; if the parent wishes to use the child's classes, it must call to retrieve them. The advantage of this choice is that, if the child defines a class with the same name as a class already defined by the parent, no error results; the child simply inherits the parent's definition of that class, and the child's conflicting definition goes unused unless either child or parent calls the method to retrieve it.\n• Loader's own ApplicationDomain. You use this application domain when using . When the load is complete, parent and child can use each other's classes directly. If the child attempts to define a class with the same name as a class already defined by the parent, the parent class is used and the child class is ignored.\n• Child of the system ApplicationDomain. You use this application domain when using . This separates loader and loadee entirely, allowing them to define separate versions of classes with the same name without conflict or overshadowing. The only way either side sees the other's classes is by calling the method.\n• Child of some other ApplicationDomain. Occasionally you may have a more complex ApplicationDomain hierarchy. You can load a SWF file into any ApplicationDomain from your own SecurityDomain. For example, loads a SWF file into a new child of the current domain's parent's parent. When a load is complete, either side (loading or loaded) may need to find its own ApplicationDomain, or the other side's ApplicationDomain, for the purpose of calling . Either side can retrieve a reference to its own application domain by using . The loading SWF file can retrieve a reference to the loaded SWF file's ApplicationDomain via . If the loaded SWF file knows how it was loaded, it can find its way to the loading SWF file's ApplicationDomain object. For example, if the child was loaded in the default way, it can find the loading SWF file's application domain by using . For more information, see the \"ApplicationDomain class\" section of the \"Client System Environment\" chapter of the ActionScript 3.0 Developer's Guide.\n\nSpecifies whether the application should attempt to download a URL policy file from the loaded object's server before beginning to load the object itself. This flag is applicable to the method, but not to the method. Set this flag to when you are loading an image (JPEG, GIF, or PNG) from outside the calling SWF file's own domain, and you expect to need access to the content of that image from ActionScript. Examples of accessing image content include referencing the property to obtain a Bitmap object, and calling the method to obtain a copy of the loaded image's pixels. If you attempt one of these operations without having specified at loading time, you may get a exception because the needed policy file has not been downloaded yet. When you call the method with set to , the application does not begin downloading the specified object in until it has either successfully downloaded a relevant URL policy file or discovered that no such policy file exists. Flash Player or AIR first considers policy files that have already been downloaded, then attempts to download any pending policy files specified in calls to the method, then attempts to download a policy file from the default location that corresponds to , which is on the same server as . In all cases, the given policy file is required to exist at by virtue of the policy file's location, and the file must permit access by virtue of one or more tags. If you set to , the main download that specified in the method does not load until the policy file has been completely processed. Therefore, as long as the policy file that you need exists, as soon as you have received any or events from the property of your Loader object, the policy file download is complete, and you can safely begin performing operations that require the policy file. If you set to , and no relevant policy file is found, you will not receive any error indication until you attempt an operation that throws a exception. However, once the LoaderInfo object dispatches a or event, you can test whether a relevant policy file was found by checking the value of the property. If you will not need pixel-level access to the image that you are loading, you should not set the property to . Checking for a policy file in this case is wasteful, because it may delay the start of your download, and it may consume network bandwidth unnecessarily. Also try to avoid setting to if you are using the method to download a SWF file. This is because SWF-to-SWF permissions are not controlled by policy files, but rather by the method, and thus has no effect when you load a SWF file. Checking for a policy file in this case is wasteful, because it may delay the download of the SWF file, and it may consume network bandwidth unnecessarily. (Flash Player or AIR cannot tell whether your main download will be a SWF file or an image, because the policy file download occurs before the main download.) Be careful with if you are downloading an object from a URL that may use server-side HTTP redirects. Policy files are always retrieved from the corresponding initial URL that you specify in . If the final object comes from a different URL because of HTTP redirects, then the initially downloaded policy files might not be applicable to the object's final URL, which is the URL that matters in security decisions. If you find yourself in this situation, you can examine the value of after you have received a or event, which tells you the object's final URL. Then call the method with a policy file URL based on the object's final URL. Then poll the value of until it becomes . You do not need to set this property for AIR content running in the application sandbox. Content in the AIR application sandbox can call the method using any loaded image content as the source.\n\nSpecifies whether to decode bitmap image data when it is used or when it is loaded. Under the default policy, , the runtime decodes the image data when the data is needed (for display or some other purpose). This policy maintains the decoding behavior used by previous versions of the runtime. Under the policy, the runtime decodes the image immediately after it is loaded and before dispatching the event. Decoding images on load rather than on demand can improve animation and user interface performance. You can see improvements when several loaded images are displayed in quick succession. Some examples of a rapid display of images are scrolling lists, or cover flow control. On the other hand, using the policy indiscriminately can increase the peak memory usage of your application. More decoded image data could be in memory at one time than would be the case under the policy. Under both policies, the runtime uses the same cache and flush behavior after the image is decoded. The runtime can flush the decoded data at any time and decode the image again the next time it is required. To set the image decoding policy (for example, to ):\n\nAn Object containing the parameters to pass to the LoaderInfo object of the content. Normally, the value of the property is obtained by parsing the requesting URL. If the var is set, the gets its value from the LoaderContext object, instead of from the requesting URL. The var accepts only objects containing name-value string pairs, similar to URL parameters. If the object does not contain name-value string pairs, an is thrown. The intent of this API is to enable the loading SWF file to forward its parameters to a loaded SWF file. This functionality is especially helpful when you use the method, since does not provide a means of passing parameters through the URL. Parameters can be forwarded successfully only to another AS3 SWF file; an AS1 or AS2 SWF file cannot receive the parameters in an accessible form, although the AVM1Movie's AS3 loaderInfo.parameters object will be the forwarded object. For example, consider the following URL: The following code uses the LoaderContext.parameters property to replicate a parameter passed to this URL: To verify that the parameter passed properly, use the following trace statement after you run this code: If the content loaded successfully, this trace prints \"bar\".\n\nThe parent to which the Loader will attempt to add the loaded content. When content is completely loaded, the Loader object normally becomes the parent of the content. If is set, the object that it specifies becomes the parent, unless a runtime error prevents the assignment. This reparenting can also be done after the event without use of this property. However, specifying the parent with eliminates extra events. sets the desired parent before frame one scripts in the loaded content execute, but after the constructor has run. If is null (the default), the Loader object becomes the content's parent. If the loaded content is an AVM1Movie object, or if an error is thrown when is called on the object, then the following actions occur:\n• The Loader object becomes the parent of the loaded content. If the requested parent and the loaded content are in different security sandboxes, and if the requested parent does not have access to the loaded content, then the following actions occur:\n• The Loader becomes the parent of the loaded content. The following code uses to place the loaded content into a Sprite object: import flash.system.LoaderContext; import flash.display.Loader; import flash.display.Sprite; var lc:LoaderContext = new LoaderContext(); var l:Loader = new Loader(); var s:Sprite = new Sprite(); lc.requestedContentParent = s; addChild(s); l.load(new URLRequest(\"child.swf\"), lc); When this code runs, the child SWF file appears on stage. This fact confirms that the Sprite object you added to the stage is the parent of the loaded child.swf file.\n\nSpecifies the security domain to use for a operation. Use this property only when loading a SWF file (not an image). The choice of security domain is meaningful only if you are loading a SWF file that might come from a different domain (a different server) than the loading SWF file. When you load a SWF file from your own domain, it is always placed into your security domain. But when you load a SWF file from a different domain, you have two options. You can allow the loaded SWF file to be placed in its \"natural\" security domain, which is different from that of the loading SWF file; this is the default. The other option is to specify that you want to place the loaded SWF file placed into the same security domain as the loading SWF file, by setting to be equal to . This is called import loading, and it is equivalent, for security purposes, to copying the loaded SWF file to your own server and loading it from there. In order for import loading to succeed, the loaded SWF file's server must have a policy file trusting the domain of the loading SWF file. You can pass your own security domain only in . Attempting to pass any other security domain results in a exception. Content in the AIR application security sandbox cannot load content from other sandboxes into its SecurityDomain. For more information, see the \"Security\" chapter in the ActionScript 3.0 Developer's Guide."
    },
    {
        "link": "https://cs.vu.nl/~eliens/assets/flex3/langref/flash/system/LoaderContext.html",
        "document": "When loading images (JPEG, GIF, or PNG) instead of SWF files, there is no need to specify a SecurityDomain or an application domain, because those concepts are meaningful only for SWF files. Instead, you have only one decision to make: do you need programmatic access to the pixels of the loaded image? If so, see the checkPolicyFile property.\n\nWhen loading a SWF file with the Loader.loadBytes() method, you have the same application domain choice to make as for Loader.load() , but it's not necessary to specify a security domain, because Loader.loadBytes() always places its loaded SWF file into the security domain of the loading SWF file.\n\nWhen loading SWF files with the Loader.load() method, you have two decisions to make: into which security domain the loaded SWF file should be placed, and into which application domain within that security domain? For more details on these choices, see the applicationDomain and securityDomain properties.\n\nThe LoaderContext class provides options for loading SWF files and other media by using the Loader class. The LoaderContext class is used as theparameter in theandmethods of the Loader class.\n\nSpecifies whether a cross-domain policy file should be loaded from the loaded object's server before beginning to load the object itself.\n\nSpecifies whether you can use the loadBytes() method of a Loader object to load content with executable code, such as a SWF file.\n\nIndicates whether an instance of the Object class is in the prototype chain of the object specified as the parameter.\n\nSpecifies whether you can use the method of a Loader object to load content with executable code, such as a SWF file. With his property set to (the default), the method is restricted to safe operations, such as loading images. In AIR content in the application sandbox, the default value is . In non-application content, the default value is . Note: This API is likely to be replaced in a future release of AIR. When that occurs, you will need to be adjust code to use the new API and recompile before destributing an application for the new version of AIR.\n\nSpecifies the application domain to use for the or method. Use this property only when loading a SWF file written in ActionScript 3.0 (not an image or a SWF file written in ActionScript 1.0 or ActionScript 2.0). Every security domain is divided into one or more application domains, represented by ApplicationDomain objects. Application domains are not for security purposes; they are for managing cooperating units of ActionScript code. If you are loading a SWF file from another domain, and allowing it to be placed in a separate security domain, then you cannot control the choice of application domain into which the loaded SWF file is placed; and if you have specified a choice of application domain, it will be ignored. However, if you are loading a SWF file into your own security domain — either because the SWF file comes from your own domain, or because you are importing it into your security domain — then you can control the choice of application domain for the loaded SWF file. You can pass an application domain only from your own security domain in . Attempting to pass an application domain from any other security domain results in a exception. You have four choices for what kind of property to use:\n• Child of loader's ApplicationDomain. The default. You can explicitly represent this choice with the syntax . This allows the loaded SWF file to use the parent's classes directly, for example by writing . The parent, however, cannot use this syntax; if the parent wishes to use the child's classes, it must call to retrieve them. The advantage of this choice is that, if the child defines a class with the same name as a class already defined by the parent, no error results; the child simply inherits the parent's definition of that class, and the child's conflicting definition goes unused unless either child or parent calls the method to retrieve it.\n• Loader's own ApplicationDomain. You use this application domain when using . When the load is complete, parent and child can use each other's classes directly. If the child attempts to define a class with the same name as a class already defined by the parent, the parent class is used and the child class is ignored.\n• Child of the system ApplicationDomain. You use this application domain when using . This separates loader and loadee entirely, allowing them to define separate versions of classes with the same name without conflict or overshadowing. The only way either side sees the other's classes is by calling the method.\n• Child of some other ApplicationDomain. Occasionally you may have a more complex ApplicationDomain hierarchy. You can load a SWF file into any ApplicationDomain from your own SecurityDomain. For example, loads a SWF file into a new child of the current domain's parent's parent. When a load is complete, either side (loading or loaded) may need to find its own ApplicationDomain, or the other side's ApplicationDomain, for the purpose of calling . Either side can retrieve a reference to its own application domain by using . The loading SWF file can retrieve a reference to the loaded SWF file's ApplicationDomain via . If the loaded SWF file knows how it was loaded, it can find its way to the loading SWF file's ApplicationDomain object. For example, if the child was loaded in the default way, it can find the loading SWF file's application domain by using . For more information, see the \"ApplicationDomain class\" section of the \"Client System Environment\" chapter of Programming ActionScript 3.0.\n\nSpecifies whether a cross-domain policy file should be loaded from the loaded object's server before beginning to load the object itself. This flag is applicable to the method, but not to the method. Set this flag to when you are loading an image (JPEG, GIF, or PNG) from outside the calling SWF file's own domain, and you expect to need access to the content of that image from ActionScript. Examples of accessing image content include referencing the property to obtain a Bitmap object, and calling the method to obtain a copy of the loaded image's pixels. If you attempt one of these operations without having specified at loading time, you may get a exception because the needed policy file has not been downloaded yet. When you call the method with set to , the specified object in does not begin downloading until it has either successfully downloaded a relevant cross-domain policy file or discovered that no such policy file exists. Policy files that have already been downloaded are considered first, then an attempt is made to download any pending policy files specified in calls to the method, then attempts to download a policy file from the default location that corresponds to , which is on the same server as . In all cases, the given policy file is required to exist at by virtue of the policy file's location, and the file must permit access by virtue of one or more tags. If you set to , the main download that specified in the method does not load until the policy file has been completely processed. Therefore, as long as the policy file that you need exists, as soon as you have received any or events from the property of your Loader object, the policy file download is complete, and you can safely begin performing operations that require the policy file. If you set to , and no relevant policy file is found, you will not receive any error indication until you attempt an operation that throws a exception. However, once the LoaderInfo object dispatches a or event, you can test whether a relevant policy file was found by checking the value of the property. If you will not need pixel-level access to the image that you are loading, you should not set the property to . Checking for a policy file in this case is wasteful, because it may delay the start of your download, and it may consume network bandwidth unnecessarily. Also try to avoid setting to if you are using the method to download a SWF file. This is because SWF-to-SWF permissions are not controlled by policy files, but rather by the method, and thus has no effect when you load a SWF file. Checking for a policy file in this case is wasteful, because it may delay the download of the SWF file, and it may consume network bandwidth unnecessarily. (Flash Player or Adobe AIR cannot tell whether your main download will be a SWF file or an image, because the policy file download occurs before the main download.) Be careful with if you are downloading an object from a URL that may use server-side HTTP redirects. Policy files are always retrieved from the corresponding initial URL that you specify in . If the final object comes from a different URL because of HTTP redirects, then the initially downloaded policy files might not be applicable to the object's final URL, which is the URL that matters in security decisions. If you find yourself in this situation, you can examine the value of after you have received a or event, which tells you the object's final URL. Then call the method with a policy file URL based on the object's final URL. Then poll the value of until it becomes .\n\nSpecifies the security domain to use for a operation. Use this property only when loading a SWF file (not an image). The choice of security domain is meaningful only if you are loading a SWF file that might come from a different domain (a different server) than the loading SWF file. When you load a SWF file from your own domain, it is always placed into your security domain. But when you load a SWF file from a different domain, you have two options. You can allow the loaded SWF file to be placed in its \"natural\" security domain, which is different from that of the loading SWF file; this is the default. The other option is to specify that you want to place the loaded SWF file placed into the same security domain as the loading SWF file, by setting to be equal to . This is called import loading, and it is equivalent, for security purposes, to copying the loaded SWF file to your own server and loading it from there. In order for import loading to succeed, the loaded SWF file's server must have a policy file trusting the domain of the loading SWF file. You can pass your own security domain only in . Attempting to pass any other security domain results in a exception. Content in the air application security sandbox cannot load content from other sandboxes into its SecurityDomain. For more information, see the \"Security\" chapter in Programming ActionScript 3.0."
    },
    {
        "link": "https://airsdk.dev/docs/development/core-actionscript-classes/working-with-application-domains",
        "document": "The purpose of the ApplicationDomain class is to store a table of ActionScript 3.0 definitions. All code in a SWF file is defined to exist in an application domain. You use application domains to partition classes that are in the same security domain. This allows multiple definitions of the same class to exist and also lets children reuse parent definitions.\n\nYou can use application domains when loading an external SWF file written in ActionScript 3.0 using the Loader class API. (Note that you cannot use application domains when loading an image or SWF file written in ActionScript 1.0 or ActionScript 2.0.) All ActionScript 3.0 definitions contained in the loaded class are stored in the application domain. When loading the SWF file, you can specify that the file be included in the same application domain as that of the Loader object, by setting the parameter of the LoaderContext object to . By putting the loaded SWF file in the same application domain, you can access its classes directly. This can be useful if you are loading a SWF file that contains embedded media, which you can access via their associated class names, or if you want to access the loaded SWF file's methods.\n\nThe following example assumes it has access to a separate Greeter.swf file that defines a public method named welcome():\n\nAlso see the ApplicationDomain class example in the ActionScript 3.0 Reference for the Adobe Flash Platform.\n\nOther things to keep in mind when you work with application domains include the following:\n• None All code in a SWF file is defined to exist in an application domain. The current domain is where your main application runs. The system domain contains all application domains, including the current domain, which means that it contains all Flash Player classes.\n• None All application domains, except the system domain, have an associated parent domain. The parent domain for your main application's application domain is the system domain. Loaded classes are defined only when their parent doesn't already define them. You cannot override a loaded class definition with a newer definition.\n\nThe following diagram shows an application that loads content from various SWF files within a single domain, domain1.com. Depending on the content you load, different application domains can be used. The text that follows describes the logic used to set the appropriate application domain for each SWF file in the application.\n\nThe main application file is application1.swf. It contains Loader objects that load content from other SWF files. In this scenario, the current domain is Application domain 1. Usage A, usage B, and usage C illustrate different techniques for setting the appropriate application domain for each SWF file in an application.\n\nPartition the child SWF file by creating a child of the system domain. In the diagram, Application domain 2 is created as a child of the system domain.The application2.swf file is loaded in Application domain 2, and its class definitions are thus partitioned from the classes defined in application1.swf.\n\nOne use of this technique is to have an old application dynamically loading a newer version of the same application without conflict. There is no conflict because although the same class names are used, they are partitioned into different application domains.\n\nThe following code creates an application domain that is a child of the system domain, and starts loading a SWF using that application domain:\n\nAdd new class definitions to current class definitions. The application domain of module1.swf is set to the current domain (Application domain 1). This lets you add to the application's current set of class definitions with new class definitions. This could be used for a run-time shared library of the main application. The loaded SWF is treated as a remote shared library (RSL). Use this technique to load RSLs by a preloader before the application starts.\n\nThe following code loads a SWF, setting its application domain to the current domain:\n\nUse the parent's class definitions by creating a new child domain of the current domain. The application domain of module3.swf is a child of the current domain, and the child uses the parent's versions of all classes. One use of this technique might be a module of a multiple-screen rich Internet application (RIA), loaded as a child of the main application, that uses the main application's types. If you can ensure that all classes are always updated to be backward compatible, and that the loading application is always newer than the things it loads, the children will use the parent versions. Having a new application domain also allows you to unload all the class definitions for garbage collection, if you can ensure that you do not continue to have references to the child SWF.\n\nThis technique lets loaded modules share the loader's singleton objects and static class members.\n\nThe following code creates a new child domain of the current domain, and starts loading a SWF using that application domain:"
    },
    {
        "link": "https://stackoverflow.com/questions/7502100/as3-scripting-a-cross-domain-loaded-swf",
        "document": "I'm having some strange inter-domain loading behaviour. I need to give my loading swf access to my loaded swf's classes and methods across domains, but despite all my applicationDomain settings and cross domain settings, I'm not being able to cast it to a usable type across domains, but it works perfectly same domain.\n\nApplication on domain A loads a skin from domain B (actually all part of a massive domain structure (test.domain.co.uk, assets.domain.co.uk, etc), but for Flash's purposes they are different). Currently some of the files are on a testing environment and will move through several environments before it goes live, so I'm keeping all security calls relatively loose. There are crossdomain.xml files all over the place.\n\nSo it works when the skin is on the same domain as the shell application, but not when they are separate. As you may tell from the code above the skin implements ISkin and extends and abstract class ASkin; to deal with security I have the following as the constructor of the skin class (which is the base class of the fla).\n• When the skin is on the same domain if I test I get true, when on separate domains, I get false\n• There are no security events\n• I have tried setting the loader context to new ApplicationDomain as well."
    },
    {
        "link": "https://stackoverflow.com/questions/13752053/applicationdomain-clarifiation-needed",
        "document": "I need some clarification on this subject as I just ran into an issue with loading swfs into a reused loader object.\n\n\n\nSo lets say I have 3 SWFs.\n\n Main.swf\n\n childA.swf\n\n childB.swf\n\n\n\nMain.swf has a loader object in it that gets reused (myloader.load(\"childA.swf\")) and childA or childB swf will be loaded via user interaction.\n\n Both child swfs have a com package with a class in that package called config.\n\n The config files are different files for both classes just named the same.\n\n both child swf also dispatch an event that the Main listens for\n\nNow the problem I had was if childA was loaded first then after childB was loaded it would still show as childA. Basically, whichever one got loaded into that loader first would be the winner.\n\n This drove me nuts as nothing I did would cause the swf to unload. Not until I found the following code.\n\n\n\nI stumbled over this code on a post somewhere talking about how to truly unload a swf. Apparently, This also applies to how to truly load a swf.\n\n As you can see a new appDomain is created and assigned to the context when loaded.\n\n This works like a dream I can now load and unload all day long.\n\n\n\nMy confusion is the event that the child dispatches still works, when I don't think the Main swf should pick it up due to it not being in the same appDomain.\n\n I mean shouldn't the event be blocked?"
    },
    {
        "link": "https://stackoverflow.com/questions/8260196/flash-as3-loading-best-practices",
        "document": "I am creating an interactive flash application where I need to use many sound files and images. I am currently loading resources (both images and sound files) as I need them. When I run it on my computer everything works fine and I see no delay. Running it on an offsite computer shows pauses and delays. I know this is due to the time it takes to load the resources.\n\nI want to know what the best practice for loading resources is. Should I preload everything in the beginning (which will create a considerable pause)? Is it better to have a short pause multiple times throughout when a new resource is needed? Or is there a better solution (I hope this is the case)?\n\nI have been programming in AS3 for about 3 months so I am relatively new. I'm sorry if this question is really noob, but I do need to figure out what to do about the delays."
    },
    {
        "link": "https://airsdk.dev/reference/actionscript/3.0/flash/display/NativeWindow.html",
        "document": "NativeWindow objects will not be garbage collected after the window constructor has been called and before close() has been called. It is the responsibility of the application to close its own windows.\n\nIf the NativeApplication.autoExit property is true , which is the default, the application will close when its last window is closed (and all close event handlers have returned). If autoExit is false , then NativeApplication.nativeApplication.exit() must be called to terminate the application.\n\nThe following operations on NativeWindow objects are asynchronous: close() , maximize() , minimize() , restore() , and bounds changes. An application can detect when these operations have completed by listening for the appropriate events.\n\nYou cannot not add Flex components directly to the display list of a NativeWindow instance. Instead, use the Flex mx:WindowedApplication and mx:Window components to create your windows and add the other Flex components as children of those objects. You can add Flex-based SWF content directly to a NativeWindow window as long as the SWF file is loaded into its own application domain and is application content.\n\nContent can be added to a window using the DisplayObjectContainer methods of the Stage object such as addChild() .\n\nThe properties of a NativeWindow instance can only be accessed by application content. If non-application content attempts to access the NativeWindow object, a security error will be thrown.\n\nOn mobile operating systems, the window object cannot be modified, but can be used to listen for resize events (for example, on screen orientation changes) and for focus (activate/deactive) events. These can be separate from the NativeApplication events that describe the foreground/background mode of the application itself, and can be used to determine when other elements are hiding part of the window's display.\n\nOn desktop operating systems, a reference to a new NativeWindow instance is returned by the window constructor. On mobile operating systems, attempting to create a new NativeWindow instance will throw an error - the only NativeWindow that exists is the initial application window with properties set via the application descriptor file, and accessed from the stage. The reference to the initial NativeWindow instance for an application can be accessed using the stage.nativeWindow property of any display object on that window's stage:\n\nAIR profile support: This feature is supported fully on desktop operating systems, has some limited (single-window) support on mobile devices, and is not supported on AIR for TV devices. You can test for support at run time on desktop devices using the NativeWindow.isSupported property. See AIR Profile Support for more information regarding API support across multiple profiles.\n\nThe NativeWindow class provides an interface for creating and controlling native desktop windows.\n\nThe vertical axis coordinate of this window's top left corner relative to the upper left corner of the operating system's desktop.\n\nThe horizontal axis coordinate of this window's top left corner relative to the origin of the operating system desktop.\n\nThe width of this window in pixels.\n\n[read-only] Reports the window type setting used to create this window.\n\n[read-only] Reports the transparency setting used to create this window.\n\n[read-only] Reports the system chrome setting used to create this window.\n\n[static][read-only] Indicates whether AIR supports window notification cueing on the current computer system.\n\n[static][read-only] Indicates whether AIR supports native window menus on the current computer system.\n\n[read-only] Reports the resizable setting used to create this window.\n\n[read-only] Reports the window renderMode setting used to create this window.\n\n[static] A reference to the prototype object of a class or function object.\n\n[read-only] Reports the minimizable setting used to create this window.\n\n[read-only] Reports the maximizable setting used to create this window.\n\n[static][read-only] Indicates whether native windows are supported on the client system.\n\nThe height of this window in pixels.\n\nA reference to the class object or constructor function for a given object instance.\n\n[read-only] Indicates whether this window has been closed.\n\nThe size and location of this window.\n\nSpecifies whether this window will always be in front of other windows (including those of other applications).\n\n[read-only] Indicates whether this window is the active application window.\n\nChecks whether an event listener is registered with this EventDispatcher object or any of its ancestors for the specified event type.\n\nReturns the primitive value of the specified object.\n\nReturns the string representation of the specified object.\n\nReturns the string representation of this object, formatted according to locale-specific conventions.\n\nRestores this window from either a minimized or a maximized state.\n\nMove and resize this window to match the full size of the target Screen.\n\nIndicates whether the specified property exists and is enumerable.\n\nBrings this window in front of any other visible windows.\n\nSends this window behind any other visible windows.\n\nBrings this window directly in front of the specified window.\n\nSends this window directly behind the specified window.\n\nTriggers a visual cue through the operating system that an event of interest has occurred.\n\nReturns a list of the NativeWindow objects that are owned by this window.\n\nIndicates whether an instance of the Object class is in the prototype chain of the object specified as the parameter.\n\nIndicates whether an object has a specified property defined.\n\nChecks whether the EventDispatcher object has any listeners registered for a specific type of event.\n\nConverts a point in pixel coordinates relative to the origin of the window stage (a global point in terms of the display list), to a point on the virtual desktop.\n\nRegisters an event listener object with an EventDispatcher object so that the listener receives notification of an event.\n\n[read-write] The size and location of this window. The dimensions of a window include any system chrome. The dimensions of a window's stage are equal to the dimensions of the window, minus the size of any system chrome. Changing the width and height of the window will change the stage's and . The reverse also applies; changing the stage dimensions will change the window size. In a root HTML window, the and properties are equivalent to the window and properties. The and properties equal the and properties minus the thickness of any automatic scrollbars displayed by the window. A event is dispatched whenever the width or height of this window changes. Likewise, a event is dispatched whenever the origin (x,y) of this window changes. On Mac OS and Windows, setting the property directly will not dispatch a or event. However, on Linux the NativeWindow does dispatch a and events when you set the property. Setting the property of a window is equivalent to setting its , , , and properties. Likewise, setting any of the individual dimensions is equivalent to setting the property. When you set all the dimensions at the same time by using the property, fewer events are dispatched. The order in which the individual dimensions are set is not guaranteed. On Linux window managers that do not allow windows to extend off the desktop area, a change to an individual property may be blocked even though the net affect of applying all the property changes would have resulted in a legal window. If the width or height specified is less than the minimum or greater than the maximum allowed width or height, then the window width or height is set to the closest legal size. The factors that determine the minimum and maximum width and height are the following:\n• The and properties of the NativeWindow object\n• The minimum and maximum operating system limits, which are the values of and .\n• The maximum width and height of a window in Adobe AIR, which are each 4095 pixels. (In AIR 1.5 and earlier, the maximum width and height of a window is 2880 pixels each.)\n• The minimum width and height required by any displayed system chrome. Pixel values are rounded to the nearest integer when the position or dimensions of a window are changed. \n\n \n\n \n\n \n\n \n\n — If the rectangle is null or contains invalid values. — If the bounds property is accessed after this window has been closed. \n\n \n\nThe following examples set the bounds of a window with a reference to a NativeWindow object: The following examples set the bounds of a window with a reference to a NativeWindow object: With a reference to a display object on the window stage: With a reference to a display object on the window stage: From a JavaScript routine running in an HTMLLoader object in the window (or a root HTML window): From a JavaScript routine running in an HTMLLoader object in the window (or a root HTML window):"
    },
    {
        "link": "https://cs.vu.nl/~eliens/assets/flex3/langref/flash/display/NativeWindow.html",
        "document": "NativeWindow objects will not be garbage collected after the window constructor has been called and before close() has been called. It is the responsibility of the application to close its own windows.\n\nIf the NativeApplication.autoExit property is true , which is the default, the application will close when its last window is closed (and all close event handlers have returned). If autoExit is false , then NativeApplication.nativeApplication.exit() must be called to terminate the application.\n\nThe following operations on NativeWindow objects are asynchronous: close() , maximize() , minimize() , restore() , and bounds changes. An application can detect when these operations have completed by listening for the appropriate events.\n\nTo create a root HTML window for displaying HTML content it is typically easier to create the window with HTMLLoader.createRootContent() . Windows created in this way will have an HTMLLoader object added automatically. (From JavaScript code, you can also use the JavaScript window.open() function. However, this method gives you less control over the window appearance and behavior.)\n\nYou cannot not add Flex components directly to the display list of a NativeWindow instance. Instead, use the Flex mx:WindowedApplication and mx:Window components to create your windows and add the other Flex components as children of those objects. You can add Flex-based SWF content directly to a NativeWindow window as long as the SWF file is loaded into its own application domain and is application content.\n\nContent can be added to a window using the DisplayObjectContainer methods of the Stage object such as addChild() .\n\nThe properties of a NativeWindow instance can only be accessed by application content. If non-application content attempts to access the NativeWindow object, a security error will be thrown.\n\nA reference to the NativeWindow instance is returned by the window constructor. A reference to a NativeWindow instance can also be accessed using the stage.nativeWindow property of any display object on that window's stage:\n\nThe NativeWindow class provides an interface for creating and controlling native desktop windows.\n\nThe vertical axis coordinate of this window's top left corner relative to the upper left corner of the operating system's desktop.\n\nThe horizontal axis coordinate of this window's top left corner relative to the origin of the operating system desktop.\n\nThe width of this window in pixels.\n\nSpecifies whether this window is visible.\n\n[read-only] Reports the window type setting used to create this window.\n\n[read-only] Reports the transparency setting used to create this window.\n\n[static] [read-only] The smallest window size allowed by the operating system.\n\n[static] [read-only] The largest window size allowed by the operating system.\n\n[read-only] Reports the system chrome setting used to create this window.\n\n[static] [read-only] Indicates whether AIR supports window notification cueing on the current computer system.\n\n[static] [read-only] Indicates whether AIR supports native window menus on the current computer system.\n\n[read-only] The Stage object for this window.\n\n[read-only] Reports the resizable setting used to create this window.\n\n[static] A reference to the prototype object of a class or function object.\n\nThe minimum size for this window.\n\n[read-only] Reports the minimizable setting used to create this window.\n\nThe native menu for this window.\n\nThe maximum size for this window.\n\n[read-only] Reports the maximizable setting used to create this window.\n\nThe height of this window in pixels.\n\n[read-only] The display state of this window.\n\nA reference to the class object or constructor function for a given object instance.\n\n[read-only] Indicates whether this window has been closed.\n\nThe size and location of this window.\n\nSpecifies whether this window will always be in front of other windows (including those of other applications).\n\n[read-only] Indicates whether this window is the active application window.\n\nChecks whether an event listener is registered with this EventDispatcher object or any of its ancestors for the specified event type.\n\nReturns the primitive value of the specified object.\n\nReturns the string representation of the specified object.\n\nSets the availability of a dynamic property for loop operations.\n\nRestores this window from either a minimized or a maximized state.\n\nIndicates whether the specified property exists and is enumerable.\n\nBrings this window in front of any other visible windows.\n\nSends this window behind any other visible windows.\n\nBrings this window directly in front of the specified window.\n\nSends this window directly behind the specified window.\n\nTriggers a visual cue through the operating system that an event of interest has occurred.\n\nIndicates whether an instance of the Object class is in the prototype chain of the object specified as the parameter.\n\nIndicates whether an object has a specified property defined.\n\nChecks whether the EventDispatcher object has any listeners registered for a specific type of event.\n\nConverts a point in pixel coordinates relative to the origin of the window stage (a global point in terms of the display list), to a point on the virtual desktop.\n\nDispatches an event into the event flow.\n\nRegisters an event listener object with an EventDispatcher object so that the listener receives notification of an event.\n\nCreates a new NativeWindow instance and a corresponding operating system window.\n\n[read-write] Specifies whether this window will always be in front of other windows (including those of other applications). There are two groups of windows in the system depth order. Windows in the group are always displayed in front of all other windows. Depth ordering between windows within the same group is determined normally. In other words, activating a window will bring it in front of other windows in its group. Changing from to will bring the window to the top of all other windows. Changing the property from to will send the window to the back of \"alwaysInFront\" windows, but still in front of other windows. Setting the property to its current value will not change the window depth order. The property should rarely be set to since windows with this setting will appear in front of the windows of other applications even when the other application is active. Note: On Mac® OS X, setting to will have no effect when the property of the window stage is or . \n\n \n\n \n\n \n\n \n\n \n\n \n\n The following examples force a window to be displayed in front of all other windows (that are not similarly forced to the front): \n\n With a reference to a display object on the window stage: \n\n From a JavaScript routine running in an HTMLLoader object in the window (or a root HTML window):\n\n[read-write] The size and location of this window. The dimensions of a window include any system chrome. The dimensions of a window's stage are equal to the dimensions of the window, minus the size of any system chrome. Changing the width and height of the window will change the stage's and . The reverse also applies; changing the stage dimensions will change the window size. In a root HTML window, the and properties are equivalent to the window and properties. The and properties equal the and properties minus the thickness of any automatic scrollbars displayed by the window. A event is dispatched whenever the width or height of this window changes. Likewise, a event is dispatched whenever the origin (x,y) of this window changes. Setting the property directly will not dispatch a or event. To allow other components to prepare for or cancel an impending move or resize operation, your bounds-changing logic can dispatch and events with the NativeWindow method and then check whether the event was canceled by a registered listener. Setting the property of a window is equivalent to setting its , , , and properties. Likewise, setting any of the individual dimensions is equivalent to setting the property. When you set all the dimensions at the same time by using the property, fewer events are displatched. If the width and the height specified are less than the minimum or greater than the maximum allowed size, because of the and properties of the window or the minimum and maximum operating system limits, then the window dimensions are set to the closest legal size. The minimum width and height of any displayed system chrome may also result in a window that is larger than the specified size. \n\n \n\n \n\n \n\n \n\n \n\n — If the rectangle is null or contains invalid values. — If the bounds property is accessed after this window has been closed. \n\n \n\n \n\n The following examples set the bounds of a window with a reference to a NativeWindow object: \n\n With a reference to a display object on the window stage: \n\n From a JavaScript routine running in an HTMLLoader object in the window (or a root HTML window):"
    },
    {
        "link": "https://stackoverflow.com/questions/26838170/stage-nativewindow-activate-in-as3-doesnt-bring-minimized-apps-to-front",
        "document": "I have an app (App1) that gets displayed in front of any other apps when a button in another app (App2) is clicked (the two apps are connected via sockets).\n\nIt works fine if App1 was maximized or restored down to start with, but if it was minimized, it will be brought forward, but still kept behind App2.\n\nI can half get around it by first of all maximizing the App1, then bringing it forward, but that's not ideal, as the user may have had App1 restored down before minimizing it, but now after bringing it forward, it's maximized instead of restored down.\n\nAnyone know how to get this to work?\n\nI've tried a bunch of permutations of\n\nThanks for your time and help."
    },
    {
        "link": "https://airsdk.dev/reference/actionscript/3.0/flash/display/Loader.html",
        "document": "The Loader class is used to load SWF files or image (JPG, PNG, or GIF) files. Use the method to initiate loading. The loaded display object is added as a child of the Loader object. The Loader class is used to load SWF files or image (JPG, PNG, or GIF) files. Use themethod to initiate loading. The loaded display object is added as a child of the Loader object. Use the URLLoader class to load text or binary data. The Loader class overrides the following methods that it inherits, because a Loader object can only have one child display object—the display object that it loads. Calling the following methods throws an exception: , , , , and . To remove a loaded display object, you must remove the Loader object from its parent DisplayObjectContainer child array. In AIR applications on iOS, you can only load a SWF file containing ActionScript from the application package. This restriction includes any ActionScript, such as assets with class names exported for ActionScript. For loading any SWF file, you must load the SWF using the same application domain as the parent SWF, as shown in the following example: var loader:Loader = new Loader(); var url:URLRequest = new URLRequest(\"swfs/SecondarySwf.swf\"); var loaderContext:LoaderContext = new LoaderContext(false, ApplicationDomain.currentDomain, null); loader.load(url, loaderContext); In addition, on iOS you can't load a SWF file that contains any ActionScript ByteCode (ABC) then unload it and reload it. If you attempt to do this, the runtime throws error 3764. Prior to AIR 3.6, only SWF files that do not contain ActionScript bytecode can be loaded, regardless of whether they're loaded from the application package or over a network. As an alternative to using an external SWF file with ActionScript, create a SWC library and link it in to your main SWF. AIR 3.7 and higher supports loading of externally hosted secondary SWFs. The detailed description about this feature can be found here. These iOS restrictions restrictions do not apply when an application is running in the iOS Simulator (ipa-test-interpreter-simulator or ipa-debug-interpreter-simulator) or interpreter mode (ipa-test-interpreter or ipa-debug-interpreter.) When you use the Loader class, consider the Flash Player and Adobe AIR security model:\n• You can load content from any accessible source.\n• Loading is not allowed if the calling SWF file is in a network sandbox and the file to be loaded is local.\n• If the loaded content is a SWF file written with ActionScript 3.0, it cannot be cross-scripted by a SWF file in another security sandbox unless that cross-scripting arrangement was approved through a call to the or the method in the loaded content file.\n• If the loaded content is an AVM1 SWF file (written using ActionScript 1.0 or 2.0), it cannot be cross-scripted by an AVM2 SWF file (written using ActionScript 3.0). However, you can communicate between the two SWF files by using the LocalConnection class.\n• If the loaded content is an image, its data cannot be accessed by a SWF file outside of the security sandbox, unless the domain of that SWF file was included in a URL policy file at the origin domain of the image.\n• Movie clips in the local-with-file-system sandbox cannot script movie clips in the local-with-networking sandbox, and the reverse is also prevented.\n• You cannot connect to commonly reserved ports. For a complete list of blocked ports, see \"Restricting Networking APIs\" in the ActionScript 3.0 Developer's Guide. However, in AIR, content in the security sandbox (content installed with the AIR application) are not restricted by these security limitations. For more information related to security, see the Flash Player Developer Center Topic: Security. When loading a SWF file from an untrusted source (such as a domain other than that of the Loader object's root SWF file), you may want to define a mask for the Loader object, to prevent the loaded content (which is a child of the Loader object) from drawing to portions of the Stage outside of that mask, as shown in the following code: import flash.display.*; import flash.net.URLRequest; var rect:Shape = new Shape(); rect.graphics.beginFill(0xFFFFFF); rect.graphics.drawRect(0, 0, 100, 100); rect.graphics.endFill(); addChild(rect); var ldr:Loader = new Loader(); ldr.mask = rect; var url:String = \"http://www.unknown.example.com/content.swf\"; var urlReq:URLRequest = new URLRequest(url); ldr.load(urlReq); addChild(ldr); Note: App Transport Security is being introduced from Apple in iOS9, which doesnt allow unsecure connections between App and Web services. Due to this change all the connections which are made to Unsecure web sites via Loader, URLLoader will discontinue and not work due to App Transport Security. Please specify exceptions to the default behaviour by adding keys to Info.plist in your app. To turn off the feature completely you can add following in your Info.plist and it will work as before. Please specify exceptions to the default behavior by adding keys to InfoAdditions tag of application descriptor of your app. <iPhone> <InfoAdditions> <![CDATA[ <key>NSAppTransportSecurity</key> <dict> <key>NSExceptionDomains</key> <dict> <key>www.example.com</key> <dict> <!--Include to allow subdomains--> <key>NSIncludesSubdomains</key> <true/> <!--Include to allow HTTP requests--> <key>NSTemporaryExceptionAllowsInsecureHTTPLoads</key> <true/> <!--Include to specify minimum TLS version--> <key>NSTemporaryExceptionMinimumTLSVersion</key> <string>TLSv1.1</string> </dict> </dict> </dict> ]]> </InfoAdditions> </iPhone> \n\n\n\n[read-only] Contains the root display object of the SWF file or image (JPG, PNG, or GIF) file that was loaded by using the or methods. \n\n \n\n \n\n \n\n — The loaded SWF file or image file belongs to a security sandbox to which you do not have access. For a loaded SWF file, you can avoid this situation by having the file call the method or by having the loading file specify a parameter with its property set to when you call the or method. [read-only] Returns a LoaderInfo object corresponding to the object being loaded. LoaderInfo objects are shared between the Loader object and the loaded content object. The LoaderInfo object supplies loading progress information and statistics about the loaded file. Events related to the load are dispatched by the LoaderInfo object referenced by the property of the Loader object. The property is set to a valid LoaderInfo object, even before the content is loaded, so that you can add event listeners to the object prior to the load. To detect uncaught errors that happen in a loaded SWF, use the property, not the property. \n\n \n\n \n\n \n\nThe following example shows how you can load and position an image in ActionScript 3.0 using the Loader class and the complete event on the Loader object's contentLoaderInfo property. Example provided by var url:String = \"http://www.helpexamples.com/flash/images/image2.jpg\"; var urlRequest:URLRequest = new URLRequest(url); var loader:Loader = new Loader(); loader.contentLoaderInfo.addEventListener(Event.COMPLETE, loader_complete); loader.load(urlRequest); addChild(loader); function loader_complete(evt:Event):void { var target_mc:Loader = evt.currentTarget.loader as Loader; target_mc.x = (stage.stageWidth - target_mc.width) / 2; target_mc.y = (stage.stageHeight - target_mc.height) / 2; } The following example shows how you can load and position an image in ActionScript 3.0 using the Loader class and the complete event on the Loader object's contentLoaderInfo property. Example provided by ActionScriptExamples.com [read-only] An object that dispatches an event when an unhandled error occurs in the SWF that's loaded by this Loader object. An uncaught error happens when an error is thrown outside of any blocks or when an ErrorEvent object is dispatched with no registered listeners. Note that a Loader object's property dispatches events that bubble through it, not events that it dispatches directly. It never dispatches an in the target phase. It only dispatches the event in the capture and bubbling phases. To detect an uncaught error in the current SWF (the SWF in which the Loader object is defined) use the property instead. If the content loaded by the Loader object is an AVM1 (ActionScript 2) SWF file, uncaught errors in the AVM1 SWF file do not result in an event. \n\n \n\n \n\n \n\nThe following example demonstrates the use of an uncaught error event handler to detect uncaught errors in a loaded SWF. The example defines an event handler to detect uncaught errors. The following example demonstrates the use of an uncaught error event handler to detect uncaught errors in a loaded SWF. The example defines anevent handler to detect uncaught errors. In the constructor, the code creates a Loader object and registers a listener for the event dispatched by the Loader object's property. In the method, the code checks the data type of the property and responds accordingly. package { import flash.display.Loader; import flash.display.Sprite; import flash.events.ErrorEvent; import flash.events.UncaughtErrorEvent; import flash.net.URLRequest; public class LoaderUncaughtErrorEventExample extends Sprite { private var ldr:Loader; public function LoaderUncaughtErrorEventExample() { ldr = new Loader(); ldr.load(new URLRequest(\"child.swf\")); ldr.uncaughtErrorEvents.addEventListener(UncaughtErrorEvent.UNCAUGHT_ERROR, uncaughtErrorHandler); } private function uncaughtErrorHandler(event:UncaughtErrorEvent):void { if (event.error is Error) { var error:Error = event.error as Error; // do something with the error } else if (event.error is ErrorEvent) { var errorEvent:ErrorEvent = event.error as ErrorEvent; // do something with the error } else { // a non-Error, non-ErrorEvent type was thrown and uncaught } } } } Creates a Loader object that you can use to load files, such as SWF, JPEG, GIF, or PNG files. Call the method to load the asset as a child of the Loader instance. You can then add the Loader object to the display list (for instance, by using the method of a DisplayObjectContainer instance). The asset appears on the Stage as it loads. You can also use a Loader instance \"offlist,\" that is without adding it to a display object container on the display list. In this mode, the Loader instance might be used to load a SWF file that contains additional modules of an application. To detect when the SWF file is finished loading, you can use the events of the LoaderInfo object associated with the property of the Loader object. At that point, the code in the module SWF file can be executed to initialize and start the module. In the offlist mode, a Loader instance might also be used to load a SWF file that contains components or media assets. Again, you can use the LoaderInfo object event notifications to detect when the components are finished loading. At that point, the application can start using the components and media assets in the library of the SWF file by instantiating the ActionScript 3.0 classes that represent those components and assets. To determine the status of a Loader object, monitor the following events that the LoaderInfo object associated with the property of the Loader object:\n• The event is dispatched when loading begins.\n• The , or event is dispatched if the file cannot be loaded or if an error occured during the load process.\n• The event fires continuously while the file is being loaded.\n• The event is dispatched when a file completes downloading, but before the loaded movie clip's methods and properties are available.\n• The event is dispatched after the properties and methods of the loaded SWF file are accessible, so you can begin manipulating the loaded SWF file. This event is dispatched before the handler. In streaming SWF files, the event can occur significantly earlier than the event. For most purposes, use the handler. Notes (iOS only): In AIR applications on iOS, you can only load a SWF file containing ActionScript from the application package. This restriction includes any ActionScript, such as assets with class names exported for ActionScript. For loading any SWF file, you must load the SWF using the same application domain as the parent SWF. Prior to AIR 3.6, only SWF files that do not contain ActionScript bytecode can be loaded, regardless of whether they're loaded from the application package or over a network. As an alternative to using an external SWF file with ActionScript, create a SWC library and link it in to your main SWF. These restrictions do not apply when an application is running in the iOS Simulator (ipa-test-interpreter-simulator or ipa-debug-interpreter-simulator) or interpreter mode (ipa-test-interpreter or ipa-debug-interpreter.) Cancels a method operation that is currently in progress for the Loader instance. Loads a SWF, JPEG, progressive JPEG, unanimated GIF, or PNG file into an object that is a child of this Loader object. If you load an animated GIF file, only the first frame is displayed. As the Loader object can contain only a single child, issuing a subsequent request terminates the previous request, if still pending, and commences a new load. Note: In AIR 1.5 and Flash Player 10, the maximum size for a loaded image is 8,191 pixels in width or height, and the total number of pixels cannot exceed 16,777,215 pixels. (So, if an loaded image is 8,191 pixels wide, it can only be 2,048 pixels high.) In Flash Player 9 and earlier and AIR 1.1 and earlier, the limitation is 2,880 pixels in height and 2,880 pixels in width. A SWF file or image loaded into a Loader object inherits the position, rotation, and scale properties of the parent display objects of the Loader object. Use the method to remove movies or images loaded with this method, or to cancel a load operation that is in progress. You can prevent a SWF file from using this method by setting the parameter of the the and tags in the HTML page that contains the SWF content. In AIR applications on iOS, you can only load a SWF file containing ActionScript from the application package. This restriction includes any ActionScript, such as assets with class names exported for ActionScript. For loading any SWF file, you must load the SWF using the same application domain as the parent SWF, as shown in the following example: var loader:Loader = new Loader(); var url:URLRequest = new URLRequest(\"swfs/SecondarySwf.swf\"); var loaderContext:LoaderContext = new LoaderContext(false, ApplicationDomain.currentDomain, null); loader.load(url, loaderContext); In addition, on iOS you can't load a SWF file that contains any ActionScript ByteCode (ABC) then unload it and reload it. If you attempt to do this, the runtime throws error 3764. Prior to AIR 3.6, only SWF files that do not contain ActionScript bytecode can be loaded, regardless of whether they're loaded from the application package or over a network. As an alternative to using an external SWF file with ActionScript, create a SWC library and link it in to your main SWF. These restrictions do not apply when an application is running in the iOS Simulator (ipa-test-interpreter-simulator or ipa-debug-interpreter-simulator) or interpreter mode (ipa-test-interpreter or ipa-debug-interpreter.) When you use this method, consider the Flash Player security model, which is described in the Loader class description. In Flash Player 10 and later, if you use a multipart Content-Type (for example \"multipart/form-data\") that contains an upload (indicated by a \"filename\" parameter in a \"content-disposition\" header within the POST body), the POST operation is subject to the security rules applied to uploads:\n• The POST operation must be performed in response to a user-initiated action, such as a mouse click or key press.\n• If the POST operation is cross-domain (the POST target is not on the same server as the SWF file that is sending the POST request), the target server must provide a URL policy file that permits cross-domain access. Also, for any multipart Content-Type, the syntax must be valid (according to the RFC2046 standard). If the syntax appears to be invalid, the POST operation is subject to the security rules applied to uploads. For more information related to security, see the Flash Player Developer Center Topic: Security. — The absolute or relative URL of the SWF, JPEG, GIF, or PNG file to be loaded. A relative path must be relative to the main SWF file. Absolute URLs must include the protocol reference, such as http:// or file:///. Filenames cannot include disk drive specifications. (default = ) — A LoaderContext object, which has properties that define the following:\n• Whether or not to check for the existence of a policy file upon loading the object\n• The ApplicationDomain for the loaded object\n• The SecurityDomain for the loaded object\n• The ImageDecodingPolicy for the loaded image object If the parameter is not specified or refers to a null object, the loaded content remains in its own security domain. iOS only: When calling the method in AIR for iOS, the LoaderContext instance must specify the main application domain ( ). For complete details, see the description of the properties in the LoaderContext class. \n\n — Dispatched by the object if the property has been specified and it is not possible to add the loaded content as a child to the specified DisplayObjectContainer. This could happen if the loaded content is a or if the call to the requestedContentParent throws an error. — Dispatched by the object when the file has completed loading. The event is always dispatched after the event. — Dispatched by the object when a network request is made over HTTP and Flash Player can detect the HTTP status code. — Dispatched by the object when the properties and methods of the loaded SWF file are accessible. The event always precedes the event. — Dispatched by the object when an input or output error occurs that causes a load operation to fail. — Dispatched by the object when the loading operation starts. — Dispatched by the object as data is received while load operation progresses. — Dispatched by the object if a SWF file in the local-with-filesystem sandbox attempts to load content in the local-with-networking sandbox, or vice versa. — Dispatched by the object if a load request is made to a secure server that has an invalid (e.g. self-signed) certificate. Listening for this event will override any default OS-specific behaviour and cause the connection to be rejected, unless the method is called on the event. — Dispatched by the object if the property has been specified and the security sandbox of the does not have access to the loaded SWF. — Dispatched by the object when a loaded object is removed. \n\n — The property of the object is not . You should only set the property of a URLRequest object when calling the method when loading a SWZ file (an Adobe platform component). — The value of must be either or . This reflects the fact that you can only place the loaded media in its natural security sandbox or your own (the latter requires a policy file). — Local SWF files may not set to anything other than . It is not permitted to import non-local media into a local sandbox, or to place other local media in anything other than its natural sandbox. — You cannot connect to commonly reserved ports. For a complete list of blocked ports, see \"Restricting Networking APIs\" in the ActionScript 3.0 Developer's Guide. — If the or properties of the parameter are from a disallowed domain. — If a local SWF file is attempting to use the property of the parameter. — If the property of the parameter is a . — If the parameter is set to non-null and has some values which are not Strings. — On iOS, if the application attempts to load a SWF file in an application domain other than the main application domain. — On iOS, if the application attempts to reload a SWF that has been loaded and unloaded and the SWF contains ABC code. — On iOS, if the application attempts to load a SWF file from outside the application package that contains ActionScript code. This error can't be caught. It appears as a dialog box on the app screen with the title \"Uncompiled ActionScript.\" Prior to AIR 3.6, this error occurs when you attempt to load any SWF file containing ActionScript, whether it is external or included in the application package. The method is asynchronous. You must wait for the \"init\" event before accessing the properties of a loaded object. When you use this method, consider the Flash Player security model, which is described in the Loader class description. Note (iOS only): In AIR applications on iOS, you can only load a SWF file containing ActionScript from the application package. This restriction includes any ActionScript, such as assets with class names exported for ActionScript. For loading any SWF file, you must load the SWF using the same application domain as the parent SWF. Prior to AIR 3.6, calling this method has no effect on iOS. — A ByteArray object. The contents of the ByteArray can be any of the file formats supported by the Loader class: SWF, GIF, JPEG, or PNG. (default = ) — A LoaderContext object. Only the property of the LoaderContext object applies; the and properties of the LoaderContext object do not apply. If the parameter is not specified or refers to a null object, the content is loaded into the current security domain— a process referred to as \"import loading\" in Flash Player security documentation. Specifically, if the loading SWF file trusts the remote SWF by incorporating the remote SWF into its code, then the loading SWF can import it directly into its own security domain. For more information related to security, see the Flash Player Developer Center Topic: Security. \n\n — Dispatched by the object if the property has been specified and it is not possible to add the loaded content as a child to the specified DisplayObjectContainer. This could happen if the loaded content is a or if the call to the requestedContentParent throws an error. — Dispatched by the object when the operation is complete. The event is always dispatched after the event. — Dispatched by the object when the properties and methods of the loaded data are accessible. The event always precedes the event. — Dispatched by the object when the runtime cannot parse the data in the byte array. — Dispatched by the object when the operation starts. — Dispatched by the object as data is transfered in memory. — Dispatched by the object if the property has been specified and the security sandbox of the does not have access to the loaded SWF. — Dispatched by the object when a loaded object is removed. \n\n — If the property of the ByteArray object is not greater than 0. — If the or property of the parameter are non-null. — If the property of the parameter is a . — If the parameter is set to non-null and has some values which are not Strings. — On iOS, if the application attempts to load a SWF file in an application domain other than the main application domain. — On iOS, if the application attempts to reload a SWF that has been loaded and unloaded and that contains ABC code. — On iOS, if the application attempts to load a SWF file from outside the application package that contains ActionScript code. This error can't be caught. It appears as a dialog box on the app screen with the message \"Uncompiled ActionScript.\" Prior to AIR 3.6, this error occurs when you attempt to load any SWF file containing ActionScript, whether it is external or included in the application package. — If the provided property of the property is from a disallowed domain. — You cannot connect to commonly reserved ports. For a complete list of blocked ports, see \"Restricting Networking APIs\" in the ActionScript 3.0 Developer's Guide. The method takes an object and loads the binary data. If the data is a progressive stream, such as a video wait for the \"init\" or progress events before accessing the properties of the loaded object. Otherwise, wait for the complete event to make sure that the data is fully loaded. When you use this method, consider the Flash Player security model, which is described in the Loader class description. — An IFilePromise object. The data source of the object can be any of the file formats supported by the Loader class: SWF, GIF, JPEG, or PNG. (default = ) — A LoaderContext object. Only the property of the LoaderContext object applies; the and properties of the LoaderContext object do not apply. If the parameter is not specified or refers to a null object, the content is loaded into the current security domain— a process referred to as \"import loading\" in Flash Player security documentation. Specifically, if the loading SWF file trusts the remote SWF by incorporating the remote SWF into its code, then the loading SWF can import it directly into its own security domain. For more information related to security, see the Flash Player Developer Center Topic: Security. \n\n — Dispatched by the object if the property has been specified and it is not possible to add the loaded content as a child to the specified DisplayObjectContainer. This could happen if the loaded content is a or if the call to the requestedContentParent throws an error. — Dispatched by the object when the operation is complete. The event is always dispatched after the event. — Dispatched by the object when the properties and methods of the loaded data are accessible. The event always precedes the event. — Dispatched by the object when the runtime cannot parse the data in the data source or if the data source stream is not readable. — Dispatched by the object when the operation starts. — Dispatched by the object as data is transfered in memory. — Dispatched by the object if the property has been specified and the security sandbox of the does not have access to the loaded SWF. — Dispatched by the object when a loaded object is removed. \n\n — If the property of the parameter is a . — If the parameter is set to non-null and has some values which are not Strings. — If the object passed as parameter is null Removes a child of this Loader object that was loaded by using the method. The of the associated LoaderInfo object is reset to . The child is not necessarily destroyed because other objects might have references to it; however, it is no longer a child of the Loader object. When you call the method, the Loader object's property is set to . Any visual assets that were loaded with the SWF are unloaded and removed from memory. ActionScript class definitions in the loaded SWF remain in memory, and code in the same application domain as the loaded SWF can access instances of those classes and create new instances. Note (iOS only): Prior to AIR 3.6, this method has no effect on iOS. As a best practice, before you unload a child SWF file, you should explicitly close any streams in the child SWF file's objects, such as LocalConnection, NetConnection, NetStream, and Sound objects. Otherwise, audio in the child SWF file might continue to play, even though the child SWF file was unloaded. To close streams in the child SWF file, add an event listener to the child that listens for the event. When the parent calls , the event is dispatched to the child. The following code shows how you might do this: Attempts to unload child SWF file contents and stops the execution of commands from loaded SWF files. This method attempts to unload SWF files that were loaded using or by removing references to EventDispatcher, NetConnection, Timer, Sound, or Video objects of the child SWF file. As a result, the following occurs for the child SWF file and the child SWF file's display list:\n• Event listeners for , , , and are removed. When you call the method, the Loader object's property is set to . Any visual assets that were loaded with the SWF are unloaded and removed from memory. ActionScript class definitions in the loaded SWF remain in memory, and code in the same application domain as the loaded SWF can access instances of those classes and create new instances. Note (iOS only): Prior to AIR 3.6, this method has no effect on iOS. (default = ) — Provides a hint to the garbage collector to run on the child SWF objects ( ) or not ( ). If you are unloading many objects asynchronously, setting the paramter to might improve application performance. However, if the parameter is set to , media and display objects of the child SWF file might persist in memory after running the command.\n• A property is created, which is the location and name of the image file\n• In the constructor, a new Loader object named is created, which is then passed to the method, described in step 3.\n• The constructor creates a new instance of a URLRequest object, , with passed so that the file name and location are known.\n• The object is passed to the object's method, which loads the image onto the display list.\n• A event listener is registered for the event on the loader. After a mouse click, the loaded image is unloaded.\n• The method adds seven event listeners by using the following methods:\n• The method executes when the image finishes loading.\n• The method executes if the image is not loaded locally and only if the network request is made available and the Flash Player can detect it.\n• The method executes before the method and after the method. Generally, the event is more useful when loading SWF files.\n• The method executes if the image file is not available or not accessible.\n• The method executes when the image file is first opened.\n• The method executes when the image file starts to load and again when the image is finished loading.\n• The method executes when the image is unloaded by using the method when the user clicks the image. The following example uses the LoaderExample class to illustrate how various event listeners are used. This task is accomplished by performing the following steps: Keep in mind the following requirements:\n• This example requires that you place a file named Image.gif in the same directory as the compiled SWF file. Use an image that has an area that fits within the dimensions of the main SWF file.\n• Although this example makes use of all events available to the LoaderInfo object, most situations require only a subset. In particular, when loading only an image file, the event (and perhaps the event) are sufficient when loading a local image."
    }
]