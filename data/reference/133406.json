[
    {
        "link": "https://doc.qt.io/qtforpython-5/PySide2/QtGui/QPainter.html",
        "document": "The QPainter class performs low-level painting on widgets and other paint devices. More …\n\nprovides highly optimized functions to do most of the drawing GUI programs require. It can draw everything from simple lines to complex shapes like pies and chords. It can also draw aligned text and pixmaps. Normally, it draws in a “natural” coordinate system, but it can also do view and world transformation. can operate on any object that inherits the class. The common use of is inside a widget’s paint event: Construct and customize (e.g. set the pen or the brush) the painter. Then draw. Remember to destroy the object after drawing. For example: The core functionality of is drawing, but the class also provide several functions that allows you to customize ‘s settings and its rendering quality, and others that enable clipping. In addition you can control how different shapes are merged together by specifying the painter’s composition mode. The function indicates whether the painter is active. A painter is activated by the function and the constructor that takes a argument. The function, and the destructor, deactivates it. Together with the and classes, form the basis for Qt’s paint system. is the class used to perform drawing operations. represents a device that can be painted on using a . provides the interface that the painter uses to draw onto different types of devices. If the painter is active, returns the paint device on which the painter paints, and returns the paint engine that the painter is currently operating on. For more information, see the Paint System . Sometimes it is desirable to make someone else paint on an unusual . supports a static function to do this, . When the paintdevice is a widget, can only be used inside a paintEvent() function or in a function called by paintEvent()."
    },
    {
        "link": "https://stackoverflow.com/questions/62866047/pyqt-drawing-a-qpixmap-along-qpainterpath",
        "document": "Long story short, there is no easy way to achieve this, especially if the requirement is to use a QPixmap.\n\nThis doesn't mean that it is completely impossible, but doing it using the common Qt capabilities is quite hard.\n\nWhat you want to achieve is fundamentally a \"texture mapping\". Even if it's done on a two-dimensional surface (which can be easily done by using simple transformations), doing it for curved paths requires much more complex computations. While simple curves (like circles and ellipses) may be easily achieved with relatively simple matrix transforms, those curves are actually simplifications of extremely complex math problems that will eventually rise in case of quadratic or cubic curves.\n\nSee the related question How can I project a rectangular texture into a region of curved shape?, in which the OP explains that this can be achieved by using thin-plate spline transformations. Qt doesn't provide means to do this, so you'd need to rely on external libraries: it seems that the scikit-image module may introduce such feature (see issue 2429, but this is still done from Python, which could result in a very slow processing for complex paths, since each pattern of each curve needs to be properly mapped.\n\nStill, there is a possibility, as long as the pattern is simple as the one in the question, all that can be simplified into a mono-dimensional structure (a linear sequence of colors with specified widths): the given pattern can be then interpreted as a dashed line that alternates two colors, each one being 15 pixels wide.\n\nIn this case, the trick is to properly use QPen capabilities to show \"dash patterns\", which makes the whole approach much easier, even if not completely foolproof. Just remember that dash patterns are based on the pen width, so their actual extent needs to be divided by it.\n\nThe concept is based on a main QGraphicsPathItem that uses a dash pattern to draw its main segments (the \"first color\" of the pattern) and overrides its method in order to draw the remaining ones by setting their relative dash pattern and an offset based on the previously drawn dashes.\n\nNote that this approach is far from perfect, since drawing is done in layers and complex paths may create graphical artifacts since the overimposed \"dash lines\" are always drawn one above the other.\n\nYet, it can provide acceptable results for simple cases, and some level of partial improvement is still possible.\n\nThe following example class takes a few possible arguments: other than the default ones QGraphicsPathItem requires, it also accepts an iterable for the \"pattern\" and a \"pen width\", which is fundamental to keep drawing consistent.\n\nThe \"pattern\" is made of pairs of colors and extents, indicating the \"size\" of each color within the drawing result.\n\nThen, whenever more than a color/size pair is set, it draws further \"dashed paths\" above the main one.\n\nHere is a simple example that randomly creates paths and patterns in order to show the result:\n\nHere is a possible result:\n\nAs you can see, there are some issues near the bottom right corner, caused by the superimposed drawing explained above. This is clearer for a more complex path:\n\nThe above image clearly shows the issues related to \"layered\" painting.\n\nStill, if the paths you're drawing are not that complex, the solution is quite acceptable considering its speed and results.\n\nIt may be possible to partially improve the result by splitting the overall path in smaller ones, but you need to consider partial dash offsets and potential issues with alpha channels or pen styles/caps.\n\nAbout the last point, as you can see, I always used the mode, which is required for proper \"multi-line\" approaches like this. This obviously means that using or styles will also create drawing issues, so these aspects must be taken into account."
    },
    {
        "link": "https://forum.qt.io/topic/119330/qpainter-qimage-vs-qpixmap",
        "document": "Hi, I am making software that has a line plot. I have made the algorithms to make the plots, axis values, etc. by directly painting on , but now, since the algorithms are all fully developed I want to move from drawing directly on to something more consistent such as or . Since the painting is done using I assume everything will work the same on or because these both use the same paint engine as . However, I am slightly confused regarding which to use: or . The Qt documentation is confusing, so I am trying to ask here if you have any knowledge about these topics then please share.\n\nbut it also says:\n\nThis confuses me, the above two statements are for two different types: Devices and Platforms. So, a is better if I want to draw on a which is a screen because will only accepts a while is better if I want to have support for different (such as Mac OS and Windows) but is inferior to when it comes to drawing on screen. If I want to have both, i.e. platform-independent fast on-screen drawing (which I am guessing is the most used/practical scenario), which one should I go with?\n\nP.S. I have tried to search on Stack Exchange as well as here on the Qt forum, but usually the answers to the questions regarding which one to use, people just quote documentation from Qt docs. What I am looking for is a real answer that acts as a bridge between the above two statements from Qt Docs."
    },
    {
        "link": "https://stackoverflow.com/questions/29395336/qt-draw-pixmap-png-file-with-qpainter-from-resources",
        "document": "I have some problems with drawing image on QWidget with QPainter from resources. I'm sure I'm missing something but I really dont know what. If I use absolute path, it works fine.\n\nSo my question is: what should I do if I want to draw .png file from resources with QPainter? (What am I missing?)\n\nHere is my simple test code:"
    },
    {
        "link": "https://pythonguis.com/tutorials/bitmap-graphics",
        "document": "The first step towards creating custom widgets in PyQt5 is understanding bitmap (pixel-based) graphic operations. All standard widgets draw themselves as bitmaps on a rectangular \"canvas\" that forms the shape of the widget. Once you understand how this works you can draw any widget you like!\n\nA bitmap is a rectangular grids of pixels, where each pixel is stored individually as a number of bits. Contrast with vector graphics, where the image is stored as a series of drawing instructions which are repeated to form the image.\n\nIn this tutorial we'll take a look at — Qt's API for performing bitmap graphic operations and the basis for drawing your own widgets. We'll go through some basic drawing operations and finally put it all together to create our own little Paint app.\n\nBitmap drawing operations in Qt are handled through the class. This is a generic interface which can be used to draw on various surfaces including, for example, . To make this easy to demonstrate we'll be using the following stub application which handles creating our container (a ), creating a pixmap canvas, displaying that in the container and adding the container to the main window.\n\nWhy do we use to draw on? The widget can also be used to show images, and it's the simplest widget available for displaying a .\n\nSave this to a file and run it and you should see the following — a single black line inside the window frame —\n\nAll the drawing occurs within the method — we create a instance, passing in the canvas ( ) and then issue a command to draw a line. Finally we call to close the painter and apply the changes.\n\nYou would usually also need to call to trigger a refresh of the widget, but as we're drawing before the application window is shown a refresh is already going to occur.\n\nprovides a huge number of methods for drawing shapes and lines on a bitmap surface (in 5.12 there are 192 specific non-event methods). The good news is that most of these are overloaded methods which are simply different ways of calling the same base methods.\n\nFor example, there are 5 different methods, all of which draw the same line, but differ in how the coordinates of what to draw are defined.\n\nIf you're wondering what the difference is between a and a , the latter has its coordinates specified as . This is convenient if you have float positions as the result of other calculations, but otherwise not so much.\n\nIgnoring the F-variants, we have 3 unique ways to draw a line — with a line object, with two sets of coordinates or with two objects. When you discover that a itself is defined as or you see that they are all in fact, exactly the same thing. The different call signatures are simply there for convenience.\n\nGiven the x1, y1, x2, y2 coordinates, the two objects would be defined as and .\n\nLeaving out the duplicates we have the following draw operations — , , , , , , , , , , , and . To avoid get overwhelmed we'll focus first on the primitive shapes and lines first and return to the more complicated operations once we have the basics down.\n\nFor each example, replace the method in your stub application and re-run it to see the output.\n\nThis draws a point, or pixel at a given point on the canvas. Each call to draws one pixel. Replace your code with the following.\n\nIf you re-run the file you will see a window, but this time there is a single dot, in black in the middle of it. You'll probably need to move the window around to spot it.\n\nThat really isn't much to look at. To make things more interesting we can change the colour and size of the point we're drawing. In PyQt the colour and thickness of lines is defined using the active pen on the QPainter. You can set this by creating a instance and applying it.\n\nThis will give the following mildly more interesting result..\n\nYou are free to perform multiple draw operations with your until the painter is ended. Drawing onto the canvas is very quick — here we're drawing 10k dots at random.\n\nThe dots are 3 pixel-width and black (the default pen).\n\nYou will often want to update the current pen while drawing — e.g. to draw multiple points in different colours while keeping other characteristics (width) the same. To do this without recreating a new instance each time you can get the current active pen from the using . You can also re-apply an existing pen multiple times, changing it each time.\n\nWill produce the following output —\n\nThere can only ever be one active on a — the current pen.\n\nThat's about as much excitement as you can have drawing dots onto a screen, so we'll move on to look at some other drawing operations.\n\nWe already drew a line on the canvas at the beginning to test things are working. But what we didn't try was setting the pen to control the line appearance.\n\nIn this example we're also using to define the two points to connect with a line, rather than passing individual parameters — remember that both methods are functionally identical.\n\nThese functions all draw rectangles, defined by , coordinates and a and of the rectangle, or by or instances which provide the equivalent information.\n\nA square is just a rectangle with the same width and height.\n\nYou can also replace the multiple calls to with a single call to passing in multiple objects. This will produce exactly the same result.\n\nDrawn shapes can be filled in PyQt by setting the current active painter brush, passing in a instance to . The following example fills all rectangles with a patterned yellow colour.\n\nAs for the pen, there is only ever one brush active on a given painter, but you can switch between them or change them while drawing. There are a number of brush style patterns available. You'll probably use more than any others though.\n\nYou must set a style to see any fill at all as the default is\n\nThe methods draw a rectangle, but with rounded edges, and so take two extra parameters for the x & y radius of the corners.\n\nThere is an optional final parameter to toggle between the x & y ellipse radii of the corners being defined in absolute pixel terms (the default) or relative to the size of the rectangle (passed as a value 0…100). Pass to enable this.\n\nThe final primitive draw method we'll look at now is which can be used to draw an ellipse or a circle.\n\nA circle is just an ellipse with an equal width and height.\n\nIn this example is taking 4 parameters, with the first two being the x & y position of the top left of the rectangle in which the ellipse will be drawn, while the last two parameters are the width and height of that rectangle respectively.\n\nDrawing an ellipse with x, y, width, height or QRect.\n\nYou can achieve the same by passing in a\n\nThere is another call signature which takes the centre of the ellipse as the first parameter, provided as or object, and then a x and y radius. The example below shows it in action.\n\nYou can fill ellipses by setting just as for filling rectangles, the same features for style and colour are available.\n\nFinally, we'll take a brief tour through the text drawing methods. To control the current font on a you use passing in a instance. With this you can control the family, weight and size (among other things) of the text you write. However, the colour of the text is still defined using the current pen.\n\nYou can also specify location with or .\n\nThe width of the pen has no effect on the appearance of the text.\n\nThere are also methods for drawing text within a specified area. Here the parameters define the x & y position and the width & height of the bounding box. Text outside this box is clipped (hidden). The 5th parameter flags can be used to control alignment of the text within the box among other things.\n\nYou have complete control over the display of text by setting the active font on the painter via a object. Check out the QFont documentation for more information.\n\nThat got a bit heavy, so let's take a breather and make something fun. So far we've been programmatically defining draw operations to perform. But we can just as easily draw in response to user input — for example allowing a user to scribble all over the canvas. In this part we'll take what we've learned so far and use it to build a rudimentary Paint app.\n\nWe can start with the same simple application outline, adding a handler to the class in place of our draw method. Here we'll take the current position of the user's mouse and plot a point on the canvas.\n\nWhy no click event? Widgets by default only receive mouse move events when a mouse button is pressed, unless mouse tracking is enabled. This can be configured using the method — setting this to (it is by default) will track the mouse continuously.\n\nIf you save this and run it you should be able to move your mouse over the screen and click to draw individual points. It should look something like this —\n\nThe issue here is that when you move the mouse around quickly it actually jumps between locations on the screen, rather than moving smoothly from one place to the next. The is fired for each location the mouse is in, but that's not enough to draw a continuous line, unless you move very slowly.\n\nThe solution to this is to draw lines instead of points. On each event we simply draw a line from where we were (previous and ) to where we are now (current and ). We can do this by tracking and ourselves.\n\nWe also need to forget the last position when releasing the mouse, or we'll start drawing from that location again after moving the mouse across the page — i.e. we won't be able to break the line.\n\nIf you run this you should be able to scribble on the screen as you would expect.\n\nDrawing with the mouse, using a continuous line.\n\nIt's still a bit dull, so let's add a simple palette to allow us to change the pen colour.\n\nThis requires a bit of re-architecting. So far we've using the on the . When we only have a single widget in the window this is fine — as long as you don't resize the window larger than the widget (did you try that?), the coordinates of the container and the single nested widget line up. However, if we add other widgets to the layout this won't hold — the coordinates of the will be offset from the window, and we'll be drawing in the wrong location.\n\nThis is easily fixed by moving the mouse handling onto the itself— it's event coordinates are always relative to itself. This we wrap up as an custom object, which handles the creation of the pixmap surface, sets up the x & y locations and the holds the current pen colour (set to black by default).\n\nThis self-contained is a drop-in drawable surface you could use in your own apps.\n\nFor the colour selection we're going to build a custom widget, based off . This widget accepts a parameter which can be a instance, or a colour name ('red', 'black') or hex value. This colour is set on the background of the widget to make it identifiable. We can use the standard signal to hook it up to any actions.\n\nWith those two new parts defined, we simply need to iterate over our list of colours, create a passing in the colour, connect its pressed signal to the handler on the canvas (indirectly through a to pass the additional colour data) and add it to the palette layout.\n\nThis should give you a fully-functioning multicolour paint application, where you can draw lines on the canvas and select colours from the palette.\n\nUnfortunately, it doesn't make you a good artist.\n\nFor a final bit of fun you can switch out the with the following to draw with a \"spray can\" effect instead of a line. This is simulated using to generate a series of normally distributed dots around the current mouse position which we plot with .\n\nDefine the and variables at the top of your file and import the standard library module. The image below shows the spray behaviour when using the following settings:\n\nFor the spray can we don't need to track the previous position, as we always spray around the current point.\n\nIf you want a challenge, you could try adding an additional button to toggle between draw and spray mode, or an input to define the brush/spray diameter.\n\nFor a fully-functional drawing program written with PyQt5 check out my 15 Minute App \"Piecasso\".\n\nThis introduction should have given you a good idea of what you can do with . As described, this system is the basis of all widget drawing. If you want to look further, check out the widget method, which receives a instance, to allow the widget to draw on itself. The same methods you've learned here can be used in to draw some basic custom widgets. We'll expand on this in the next tutorial."
    },
    {
        "link": "https://stackoverflow.com/questions/59866185/how-to-draw-with-qpainter-on-top-of-already-placed-qlabel-or-qpixmap",
        "document": "In general, the painting of a QWidget (QLabel, QPushButton, etc.) should only be done in the paintEvent method as the OP seems to know. And that painting depends on the information that the widget has, for example QLabel uses a text and draws the text, OR uses a QPixmap and draws based on that pixmap. So in this case you must create a QPixmap where the line is painted, and pass that QPixmap to the QLabel to paint it.\n\nI can't have text and drawn line on the label?\n\nAs I already pointed out in the initial part of my answer: Either you paint a text or you paint a QPixmap, you can't do both in a QLabel.\n\nCan I draw line then text on it using ?\n\nYes, you can use all the methods to paint the text in the QPixmap: be creative :-). For example:"
    },
    {
        "link": "https://stackoverflow.com/questions/62866047/pyqt-drawing-a-qpixmap-along-qpainterpath",
        "document": "Long story short, there is no easy way to achieve this, especially if the requirement is to use a QPixmap.\n\nThis doesn't mean that it is completely impossible, but doing it using the common Qt capabilities is quite hard.\n\nWhat you want to achieve is fundamentally a \"texture mapping\". Even if it's done on a two-dimensional surface (which can be easily done by using simple transformations), doing it for curved paths requires much more complex computations. While simple curves (like circles and ellipses) may be easily achieved with relatively simple matrix transforms, those curves are actually simplifications of extremely complex math problems that will eventually rise in case of quadratic or cubic curves.\n\nSee the related question How can I project a rectangular texture into a region of curved shape?, in which the OP explains that this can be achieved by using thin-plate spline transformations. Qt doesn't provide means to do this, so you'd need to rely on external libraries: it seems that the scikit-image module may introduce such feature (see issue 2429, but this is still done from Python, which could result in a very slow processing for complex paths, since each pattern of each curve needs to be properly mapped.\n\nStill, there is a possibility, as long as the pattern is simple as the one in the question, all that can be simplified into a mono-dimensional structure (a linear sequence of colors with specified widths): the given pattern can be then interpreted as a dashed line that alternates two colors, each one being 15 pixels wide.\n\nIn this case, the trick is to properly use QPen capabilities to show \"dash patterns\", which makes the whole approach much easier, even if not completely foolproof. Just remember that dash patterns are based on the pen width, so their actual extent needs to be divided by it.\n\nThe concept is based on a main QGraphicsPathItem that uses a dash pattern to draw its main segments (the \"first color\" of the pattern) and overrides its method in order to draw the remaining ones by setting their relative dash pattern and an offset based on the previously drawn dashes.\n\nNote that this approach is far from perfect, since drawing is done in layers and complex paths may create graphical artifacts since the overimposed \"dash lines\" are always drawn one above the other.\n\nYet, it can provide acceptable results for simple cases, and some level of partial improvement is still possible.\n\nThe following example class takes a few possible arguments: other than the default ones QGraphicsPathItem requires, it also accepts an iterable for the \"pattern\" and a \"pen width\", which is fundamental to keep drawing consistent.\n\nThe \"pattern\" is made of pairs of colors and extents, indicating the \"size\" of each color within the drawing result.\n\nThen, whenever more than a color/size pair is set, it draws further \"dashed paths\" above the main one.\n\nHere is a simple example that randomly creates paths and patterns in order to show the result:\n\nHere is a possible result:\n\nAs you can see, there are some issues near the bottom right corner, caused by the superimposed drawing explained above. This is clearer for a more complex path:\n\nThe above image clearly shows the issues related to \"layered\" painting.\n\nStill, if the paths you're drawing are not that complex, the solution is quite acceptable considering its speed and results.\n\nIt may be possible to partially improve the result by splitting the overall path in smaller ones, but you need to consider partial dash offsets and potential issues with alpha channels or pen styles/caps.\n\nAbout the last point, as you can see, I always used the mode, which is required for proper \"multi-line\" approaches like this. This obviously means that using or styles will also create drawing issues, so these aspects must be taken into account."
    },
    {
        "link": "https://pythonguis.com/tutorials/bitmap-graphics",
        "document": "The first step towards creating custom widgets in PyQt5 is understanding bitmap (pixel-based) graphic operations. All standard widgets draw themselves as bitmaps on a rectangular \"canvas\" that forms the shape of the widget. Once you understand how this works you can draw any widget you like!\n\nA bitmap is a rectangular grids of pixels, where each pixel is stored individually as a number of bits. Contrast with vector graphics, where the image is stored as a series of drawing instructions which are repeated to form the image.\n\nIn this tutorial we'll take a look at — Qt's API for performing bitmap graphic operations and the basis for drawing your own widgets. We'll go through some basic drawing operations and finally put it all together to create our own little Paint app.\n\nBitmap drawing operations in Qt are handled through the class. This is a generic interface which can be used to draw on various surfaces including, for example, . To make this easy to demonstrate we'll be using the following stub application which handles creating our container (a ), creating a pixmap canvas, displaying that in the container and adding the container to the main window.\n\nWhy do we use to draw on? The widget can also be used to show images, and it's the simplest widget available for displaying a .\n\nSave this to a file and run it and you should see the following — a single black line inside the window frame —\n\nAll the drawing occurs within the method — we create a instance, passing in the canvas ( ) and then issue a command to draw a line. Finally we call to close the painter and apply the changes.\n\nYou would usually also need to call to trigger a refresh of the widget, but as we're drawing before the application window is shown a refresh is already going to occur.\n\nprovides a huge number of methods for drawing shapes and lines on a bitmap surface (in 5.12 there are 192 specific non-event methods). The good news is that most of these are overloaded methods which are simply different ways of calling the same base methods.\n\nFor example, there are 5 different methods, all of which draw the same line, but differ in how the coordinates of what to draw are defined.\n\nIf you're wondering what the difference is between a and a , the latter has its coordinates specified as . This is convenient if you have float positions as the result of other calculations, but otherwise not so much.\n\nIgnoring the F-variants, we have 3 unique ways to draw a line — with a line object, with two sets of coordinates or with two objects. When you discover that a itself is defined as or you see that they are all in fact, exactly the same thing. The different call signatures are simply there for convenience.\n\nGiven the x1, y1, x2, y2 coordinates, the two objects would be defined as and .\n\nLeaving out the duplicates we have the following draw operations — , , , , , , , , , , , and . To avoid get overwhelmed we'll focus first on the primitive shapes and lines first and return to the more complicated operations once we have the basics down.\n\nFor each example, replace the method in your stub application and re-run it to see the output.\n\nThis draws a point, or pixel at a given point on the canvas. Each call to draws one pixel. Replace your code with the following.\n\nIf you re-run the file you will see a window, but this time there is a single dot, in black in the middle of it. You'll probably need to move the window around to spot it.\n\nThat really isn't much to look at. To make things more interesting we can change the colour and size of the point we're drawing. In PyQt the colour and thickness of lines is defined using the active pen on the QPainter. You can set this by creating a instance and applying it.\n\nThis will give the following mildly more interesting result..\n\nYou are free to perform multiple draw operations with your until the painter is ended. Drawing onto the canvas is very quick — here we're drawing 10k dots at random.\n\nThe dots are 3 pixel-width and black (the default pen).\n\nYou will often want to update the current pen while drawing — e.g. to draw multiple points in different colours while keeping other characteristics (width) the same. To do this without recreating a new instance each time you can get the current active pen from the using . You can also re-apply an existing pen multiple times, changing it each time.\n\nWill produce the following output —\n\nThere can only ever be one active on a — the current pen.\n\nThat's about as much excitement as you can have drawing dots onto a screen, so we'll move on to look at some other drawing operations.\n\nWe already drew a line on the canvas at the beginning to test things are working. But what we didn't try was setting the pen to control the line appearance.\n\nIn this example we're also using to define the two points to connect with a line, rather than passing individual parameters — remember that both methods are functionally identical.\n\nThese functions all draw rectangles, defined by , coordinates and a and of the rectangle, or by or instances which provide the equivalent information.\n\nA square is just a rectangle with the same width and height.\n\nYou can also replace the multiple calls to with a single call to passing in multiple objects. This will produce exactly the same result.\n\nDrawn shapes can be filled in PyQt by setting the current active painter brush, passing in a instance to . The following example fills all rectangles with a patterned yellow colour.\n\nAs for the pen, there is only ever one brush active on a given painter, but you can switch between them or change them while drawing. There are a number of brush style patterns available. You'll probably use more than any others though.\n\nYou must set a style to see any fill at all as the default is\n\nThe methods draw a rectangle, but with rounded edges, and so take two extra parameters for the x & y radius of the corners.\n\nThere is an optional final parameter to toggle between the x & y ellipse radii of the corners being defined in absolute pixel terms (the default) or relative to the size of the rectangle (passed as a value 0…100). Pass to enable this.\n\nThe final primitive draw method we'll look at now is which can be used to draw an ellipse or a circle.\n\nA circle is just an ellipse with an equal width and height.\n\nIn this example is taking 4 parameters, with the first two being the x & y position of the top left of the rectangle in which the ellipse will be drawn, while the last two parameters are the width and height of that rectangle respectively.\n\nDrawing an ellipse with x, y, width, height or QRect.\n\nYou can achieve the same by passing in a\n\nThere is another call signature which takes the centre of the ellipse as the first parameter, provided as or object, and then a x and y radius. The example below shows it in action.\n\nYou can fill ellipses by setting just as for filling rectangles, the same features for style and colour are available.\n\nFinally, we'll take a brief tour through the text drawing methods. To control the current font on a you use passing in a instance. With this you can control the family, weight and size (among other things) of the text you write. However, the colour of the text is still defined using the current pen.\n\nYou can also specify location with or .\n\nThe width of the pen has no effect on the appearance of the text.\n\nThere are also methods for drawing text within a specified area. Here the parameters define the x & y position and the width & height of the bounding box. Text outside this box is clipped (hidden). The 5th parameter flags can be used to control alignment of the text within the box among other things.\n\nYou have complete control over the display of text by setting the active font on the painter via a object. Check out the QFont documentation for more information.\n\nThat got a bit heavy, so let's take a breather and make something fun. So far we've been programmatically defining draw operations to perform. But we can just as easily draw in response to user input — for example allowing a user to scribble all over the canvas. In this part we'll take what we've learned so far and use it to build a rudimentary Paint app.\n\nWe can start with the same simple application outline, adding a handler to the class in place of our draw method. Here we'll take the current position of the user's mouse and plot a point on the canvas.\n\nWhy no click event? Widgets by default only receive mouse move events when a mouse button is pressed, unless mouse tracking is enabled. This can be configured using the method — setting this to (it is by default) will track the mouse continuously.\n\nIf you save this and run it you should be able to move your mouse over the screen and click to draw individual points. It should look something like this —\n\nThe issue here is that when you move the mouse around quickly it actually jumps between locations on the screen, rather than moving smoothly from one place to the next. The is fired for each location the mouse is in, but that's not enough to draw a continuous line, unless you move very slowly.\n\nThe solution to this is to draw lines instead of points. On each event we simply draw a line from where we were (previous and ) to where we are now (current and ). We can do this by tracking and ourselves.\n\nWe also need to forget the last position when releasing the mouse, or we'll start drawing from that location again after moving the mouse across the page — i.e. we won't be able to break the line.\n\nIf you run this you should be able to scribble on the screen as you would expect.\n\nDrawing with the mouse, using a continuous line.\n\nIt's still a bit dull, so let's add a simple palette to allow us to change the pen colour.\n\nThis requires a bit of re-architecting. So far we've using the on the . When we only have a single widget in the window this is fine — as long as you don't resize the window larger than the widget (did you try that?), the coordinates of the container and the single nested widget line up. However, if we add other widgets to the layout this won't hold — the coordinates of the will be offset from the window, and we'll be drawing in the wrong location.\n\nThis is easily fixed by moving the mouse handling onto the itself— it's event coordinates are always relative to itself. This we wrap up as an custom object, which handles the creation of the pixmap surface, sets up the x & y locations and the holds the current pen colour (set to black by default).\n\nThis self-contained is a drop-in drawable surface you could use in your own apps.\n\nFor the colour selection we're going to build a custom widget, based off . This widget accepts a parameter which can be a instance, or a colour name ('red', 'black') or hex value. This colour is set on the background of the widget to make it identifiable. We can use the standard signal to hook it up to any actions.\n\nWith those two new parts defined, we simply need to iterate over our list of colours, create a passing in the colour, connect its pressed signal to the handler on the canvas (indirectly through a to pass the additional colour data) and add it to the palette layout.\n\nThis should give you a fully-functioning multicolour paint application, where you can draw lines on the canvas and select colours from the palette.\n\nUnfortunately, it doesn't make you a good artist.\n\nFor a final bit of fun you can switch out the with the following to draw with a \"spray can\" effect instead of a line. This is simulated using to generate a series of normally distributed dots around the current mouse position which we plot with .\n\nDefine the and variables at the top of your file and import the standard library module. The image below shows the spray behaviour when using the following settings:\n\nFor the spray can we don't need to track the previous position, as we always spray around the current point.\n\nIf you want a challenge, you could try adding an additional button to toggle between draw and spray mode, or an input to define the brush/spray diameter.\n\nFor a fully-functional drawing program written with PyQt5 check out my 15 Minute App \"Piecasso\".\n\nThis introduction should have given you a good idea of what you can do with . As described, this system is the basis of all widget drawing. If you want to look further, check out the widget method, which receives a instance, to allow the widget to draw on itself. The same methods you've learned here can be used in to draw some basic custom widgets. We'll expand on this in the next tutorial."
    },
    {
        "link": "https://forum.qt.io/topic/150358/using-qpainter-to-draw-on-a-qpixmap-and-save-it",
        "document": "Your browser does not seem to support JavaScript. As a result, your viewing experience will be diminished, and you have been placed in read-only mode.\n\nPlease download a browser that supports JavaScript, or enable it if it's disabled (i.e. NoScript)."
    },
    {
        "link": "https://doc.qt.io/qtforpython-5/PySide2/QtGui/QPainter.html",
        "document": "The QPainter class performs low-level painting on widgets and other paint devices. More …\n\nprovides highly optimized functions to do most of the drawing GUI programs require. It can draw everything from simple lines to complex shapes like pies and chords. It can also draw aligned text and pixmaps. Normally, it draws in a “natural” coordinate system, but it can also do view and world transformation. can operate on any object that inherits the class. The common use of is inside a widget’s paint event: Construct and customize (e.g. set the pen or the brush) the painter. Then draw. Remember to destroy the object after drawing. For example: The core functionality of is drawing, but the class also provide several functions that allows you to customize ‘s settings and its rendering quality, and others that enable clipping. In addition you can control how different shapes are merged together by specifying the painter’s composition mode. The function indicates whether the painter is active. A painter is activated by the function and the constructor that takes a argument. The function, and the destructor, deactivates it. Together with the and classes, form the basis for Qt’s paint system. is the class used to perform drawing operations. represents a device that can be painted on using a . provides the interface that the painter uses to draw onto different types of devices. If the painter is active, returns the paint device on which the painter paints, and returns the paint engine that the painter is currently operating on. For more information, see the Paint System . Sometimes it is desirable to make someone else paint on an unusual . supports a static function to do this, . When the paintdevice is a widget, can only be used inside a paintEvent() function or in a function called by paintEvent()."
    }
]