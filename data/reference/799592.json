[
    {
        "link": "https://docs.python.org/3/library/json.html",
        "document": "JSON (JavaScript Object Notation), specified by RFC 7159 (which obsoletes RFC 4627) and by ECMA-404, is a lightweight data interchange format inspired by JavaScript object literal syntax (although it is not a strict subset of JavaScript ).\n\nexposes an API familiar to users of the standard library and modules.\n\nUsing from the shell to validate and pretty-print:\n\nSerialize obj as a JSON formatted stream to fp (a -supporting file-like object) using this Python-to-JSON conversion table. Unlike and , JSON is not a framed protocol, so trying to serialize multiple objects with repeated calls to using the same fp will result in an invalid JSON file.\n• None obj (object) – The Python object to be serialized.\n• None fp (file-like object) – The file-like object obj will be serialized to. The module always produces objects, not objects, therefore must support input.\n• None skipkeys (bool) – If , keys that are not of a basic type ( , , , , ) will be skipped instead of raising a . Default .\n• None ensure_ascii (bool) – If (the default), the output is guaranteed to have all incoming non-ASCII characters escaped. If , these characters will be outputted as-is.\n• None check_circular (bool) – If , the circular reference check for container types is skipped and a circular reference will result in a (or worse). Default .\n• None allow_nan (bool) – If , serialization of out-of-range values ( , , ) will result in a , in strict compliance with the JSON specification. If (the default), their JavaScript equivalents ( , , ) are used.\n• None cls (a subclass) – If set, a custom JSON encoder with the method overridden, for serializing into custom datatypes. If (the default), is used.\n• None indent (int | str | None) – If a positive integer or string, JSON array elements and object members will be pretty-printed with that indent level. A positive integer indents that many spaces per level; a string (such as ) is used to indent each level. If zero, negative, or (the empty string), only newlines are inserted. If (the default), the most compact representation is used.\n• None separators (tuple | None) – A two-tuple: . If (the default), separators defaults to if indent is , and otherwise. For the most compact JSON, specify to eliminate whitespace.\n• None default (callable | None) – A function that is called for objects that can’t otherwise be serialized. It should return a JSON encodable version of the object or raise a . If (the default), is raised.\n• None sort_keys (bool) – If , dictionaries will be outputted sorted by key. Default . Changed in version 3.2: Allow strings for indent in addition to integers. Changed in version 3.4: Use as default if indent is not . Changed in version 3.6: All optional parameters are now keyword-only. Serialize obj to a JSON formatted using this conversion table. The arguments have the same meaning as in . Keys in key/value pairs of JSON are always of the type . When a dictionary is converted into JSON, all the keys of the dictionary are coerced to strings. As a result of this, if a dictionary is converted into JSON and then back into a dictionary, the dictionary may not equal the original one. That is, if x has non-string keys. Deserialize fp to a Python object using the JSON-to-Python conversion table.\n• None fp (file-like object) – A -supporting text file or binary file containing the JSON document to be deserialized.\n• None cls (a subclass) – If set, a custom JSON decoder. Additional keyword arguments to will be passed to the constructor of cls. If (the default), is used.\n• None object_hook (callable | None) – If set, a function that is called with the result of any object literal decoded (a ). The return value of this function will be used instead of the . This feature can be used to implement custom decoders, for example JSON-RPC class hinting. Default .\n• None object_pairs_hook (callable | None) – If set, a function that is called with the result of any object literal decoded with an ordered list of pairs. The return value of this function will be used instead of the . This feature can be used to implement custom decoders. If object_hook is also set, object_pairs_hook takes priority. Default .\n• None parse_float (callable | None) – If set, a function that is called with the string of every JSON float to be decoded. If (the default), it is equivalent to . This can be used to parse JSON floats into custom datatypes, for example .\n• None parse_int (callable | None) – If set, a function that is called with the string of every JSON int to be decoded. If (the default), it is equivalent to . This can be used to parse JSON integers into custom datatypes, for example .\n• None parse_constant (callable | None) – If set, a function that is called with one of the following strings: , , or . This can be used to raise an exception if invalid JSON numbers are encountered. Default .\n• None JSONDecodeError – When the data being deserialized is not a valid JSON document.\n• None UnicodeDecodeError – When the data being deserialized does not contain UTF-8, UTF-16 or UTF-32 encoded data.\n• None All optional parameters are now keyword-only.\n• None fp can now be a binary file. The input encoding should be UTF-8, UTF-16 or UTF-32. Changed in version 3.11: The default parse_int of now limits the maximum length of the integer string via the interpreter’s integer string conversion length limitation to help avoid denial of service attacks. Identical to , but instead of a file-like object, deserialize s (a , or instance containing a JSON document) to a Python object using this conversion table. Changed in version 3.6: s can now be of type or . The input encoding should be UTF-8, UTF-16 or UTF-32. Changed in version 3.9: The keyword argument encoding has been removed.\n\nPerforms the following translations in decoding by default: It also understands , , and as their corresponding values, which is outside the JSON spec. object_hook is an optional function that will be called with the result of every JSON object decoded and its return value will be used in place of the given . This can be used to provide custom deserializations (e.g. to support JSON-RPC class hinting). object_pairs_hook is an optional function that will be called with the result of every JSON object decoded with an ordered list of pairs. The return value of object_pairs_hook will be used instead of the . This feature can be used to implement custom decoders. If object_hook is also defined, the object_pairs_hook takes priority. parse_float is an optional function that will be called with the string of every JSON float to be decoded. By default, this is equivalent to . This can be used to use another datatype or parser for JSON floats (e.g. ). parse_int is an optional function that will be called with the string of every JSON int to be decoded. By default, this is equivalent to . This can be used to use another datatype or parser for JSON integers (e.g. ). parse_constant is an optional function that will be called with one of the following strings: , , . This can be used to raise an exception if invalid JSON numbers are encountered. If strict is false ( is the default), then control characters will be allowed inside strings. Control characters in this context are those with character codes in the 0–31 range, including (tab), , and . If the data being deserialized is not a valid JSON document, a will be raised. Changed in version 3.6: All parameters are now keyword-only. Return the Python representation of s (a instance containing a JSON document). will be raised if the given JSON document is not valid. Decode a JSON document from s (a beginning with a JSON document) and return a 2-tuple of the Python representation and the index in s where the document ended. This can be used to decode a JSON document from a string that may have extraneous data at the end. Supports the following objects and types by default: Changed in version 3.4: Added support for int- and float-derived Enum classes. To extend this to recognize other objects, subclass and implement a method with another method that returns a serializable object for if possible, otherwise it should call the superclass implementation (to raise ). If skipkeys is false (the default), a will be raised when trying to encode keys that are not , , or . If skipkeys is true, such items are simply skipped. If ensure_ascii is true (the default), the output is guaranteed to have all incoming non-ASCII characters escaped. If ensure_ascii is false, these characters will be output as-is. If check_circular is true (the default), then lists, dicts, and custom encoded objects will be checked for circular references during encoding to prevent an infinite recursion (which would cause a ). Otherwise, no such check takes place. If allow_nan is true (the default), then , , and will be encoded as such. This behavior is not JSON specification compliant, but is consistent with most JavaScript based encoders and decoders. Otherwise, it will be a to encode such floats. If sort_keys is true (default: ), then the output of dictionaries will be sorted by key; this is useful for regression tests to ensure that JSON serializations can be compared on a day-to-day basis. If indent is a non-negative integer or string, then JSON array elements and object members will be pretty-printed with that indent level. An indent level of 0, negative, or will only insert newlines. (the default) selects the most compact representation. Using a positive integer indent indents that many spaces per level. If indent is a string (such as ), that string is used to indent each level. Changed in version 3.2: Allow strings for indent in addition to integers. If specified, separators should be an tuple. The default is if indent is and otherwise. To get the most compact JSON representation, you should specify to eliminate whitespace. Changed in version 3.4: Use as default if indent is not . If specified, default should be a function that gets called for objects that can’t otherwise be serialized. It should return a JSON encodable version of the object or raise a . If not specified, is raised. Changed in version 3.6: All parameters are now keyword-only. Implement this method in a subclass such that it returns a serializable object for o, or calls the base implementation (to raise a ). For example, to support arbitrary iterators, you could implement like this: # Let the base class default method raise the TypeError Return a JSON string representation of a Python data structure, o. For example: Encode the given object, o, and yield each string representation as available. For example:\n\nThe JSON format is specified by RFC 7159 and by ECMA-404. This section details this module’s level of compliance with the RFC. For simplicity, and subclasses, and parameters other than those explicitly mentioned, are not considered. This module does not comply with the RFC in a strict fashion, implementing some extensions that are valid JavaScript but not valid JSON. In particular:\n• None Infinite and NaN number values are accepted and output;\n• None Repeated names within an object are accepted, and only the value of the last name-value pair is used. Since the RFC permits RFC-compliant parsers to accept input texts that are not RFC-compliant, this module’s deserializer is technically RFC-compliant under default settings. The RFC requires that JSON be represented using either UTF-8, UTF-16, or UTF-32, with UTF-8 being the recommended default for maximum interoperability. As permitted, though not required, by the RFC, this module’s serializer sets ensure_ascii=True by default, thus escaping the output so that the resulting strings only contain ASCII characters. Other than the ensure_ascii parameter, this module is defined strictly in terms of conversion between Python objects and , and thus does not otherwise directly address the issue of character encodings. The RFC prohibits adding a byte order mark (BOM) to the start of a JSON text, and this module’s serializer does not add a BOM to its output. The RFC permits, but does not require, JSON deserializers to ignore an initial BOM in their input. This module’s deserializer raises a when an initial BOM is present. The RFC does not explicitly forbid JSON strings which contain byte sequences that don’t correspond to valid Unicode characters (e.g. unpaired UTF-16 surrogates), but it does note that they may cause interoperability problems. By default, this module accepts and outputs (when present in the original ) code points for such sequences. The RFC does not permit the representation of infinite or NaN number values. Despite that, by default, this module accepts and outputs , , and as if they were valid JSON number literal values: # Neither of these calls raises an exception, but the results are not valid JSON In the serializer, the allow_nan parameter can be used to alter this behavior. In the deserializer, the parse_constant parameter can be used to alter this behavior. The RFC specifies that the names within a JSON object should be unique, but does not mandate how repeated names in JSON objects should be handled. By default, this module does not raise an exception; instead, it ignores all but the last name-value pair for a given name: The object_pairs_hook parameter can be used to alter this behavior. The old version of JSON specified by the obsolete RFC 4627 required that the top-level value of a JSON text must be either a JSON object or array (Python or ), and could not be a JSON null, boolean, number, or string value. RFC 7159 removed that restriction, and this module does not and has never implemented that restriction in either its serializer or its deserializer. Regardless, for maximum interoperability, you may wish to voluntarily adhere to the restriction yourself. Some JSON deserializer implementations may set limits on:\n• None the maximum level of nesting of JSON objects and arrays\n• None the range and precision of JSON numbers\n• None the content and maximum length of JSON strings This module does not impose any such limits beyond those of the relevant Python datatypes themselves or the Python interpreter itself. When serializing to JSON, beware any such limitations in applications that may consume your JSON. In particular, it is common for JSON numbers to be deserialized into IEEE 754 double precision numbers and thus subject to that representation’s range and precision limitations. This is especially relevant when serializing Python values of extremely large magnitude, or when serializing instances of “exotic” numerical types such as .\n\nThe module provides a simple command line interface to validate and pretty-print JSON objects. If the optional and arguments are not specified, and will be used respectively: Changed in version 3.5: The output is now in the same order as the input. Use the option to sort the output of dictionaries alphabetically by key. The JSON file to be validated or pretty-printed: python -m json.tool mp_films.json \"title\": \"And Now for Something Completely Different\", If infile is not specified, read from . Write the output of the infile to the given outfile. Otherwise, write it to . Sort the output of dictionaries alphabetically by key. Disable escaping of non-ascii characters, see for more information."
    },
    {
        "link": "https://docs.python.org/3/whatsnew/3.10.html",
        "document": "This article explains the new features in Python 3.10, compared to 3.9. Python 3.10 was released on October 4, 2021. For full details, see the changelog.\n\nUsing enclosing parentheses for continuation across multiple lines in context managers is now supported. This allows formatting a long collection of context managers in multiple lines in a similar way as it was previously possible with import statements. For instance, all these examples are now valid: it is also possible to use a trailing comma at the end of the enclosed group: This new syntax uses the non LL(1) capacities of the new parser. Check PEP 617 for more details. When parsing code that contains unclosed parentheses or brackets the interpreter now includes the location of the unclosed bracket of parentheses instead of displaying SyntaxError: unexpected EOF while parsing or pointing to some incorrect location. For instance, consider the following code (notice the unclosed ‘{‘): Previous versions of the interpreter reported confusing places as the location of the syntax error: but in Python 3.10 a more informative error is emitted: In a similar way, errors involving unclosed string literals (single and triple quoted) now point to the start of the string instead of reporting EOF/EOL. These improvements are inspired by previous work in the PyPy interpreter. exceptions raised by the interpreter will now highlight the full error range of the expression that constitutes the syntax error itself, instead of just where the problem is detected. In this way, instead of displaying (before Python 3.10): now Python 3.10 will display the exception as: This improvement was contributed by Pablo Galindo in bpo-43914. A considerable amount of new specialized messages for exceptions have been incorporated. Some of the most notable ones are as follows:\n• File , line : did you forget parentheses around the comprehension target?\n• None Missing commas in collection literals and between expressions:\n• None Usage of instead of in comparisons: File , line : cannot assign to attribute here. Maybe you meant '==' instead of '='?\n• File , line : f-string: cannot use starred expression here Many exceptions now have more context regarding what kind of block was expecting an indentation, including the location of the statement: File , line : expected an indented block after 'if' statement in line 2 When printing , will offer suggestions of similar attribute names in the object that the exception was raised from: File , line , in : module 'collections' has no attribute 'namedtoplo'. Did you mean: namedtuple? Notice this won’t work if is not called to display the error which can happen if some other custom error display function is used. This is a common scenario in some REPLs like IPython. When printing raised by the interpreter, will offer suggestions of similar variable names in the function that the exception was raised from: File , line , in : name 'schwarschild_black_hole' is not defined. Did you mean: schwarzschild_black_hole? Notice this won’t work if is not called to display the error, which can happen if some other custom error display function is used. This is a common scenario in some REPLs like IPython. Structural pattern matching has been added in the form of a match statement and case statements of patterns with associated actions. Patterns consist of sequences, mappings, primitive data types as well as class instances. Pattern matching enables programs to extract information from complex data types, branch on the structure of data, and apply specific actions based on different forms of data. The generic syntax of pattern matching is: A match statement takes an expression and compares its value to successive patterns given as one or more case blocks. Specifically, pattern matching operates by:\n• None using data with type and shape (the )\n• None evaluating the in the statement\n• None comparing the subject with each pattern in a statement from top to bottom until a match is confirmed.\n• None executing the action associated with the pattern of the confirmed match\n• None If an exact match is not confirmed, the last case, a wildcard , if provided, will be used as the matching case. If an exact match is not confirmed and a wildcard case does not exist, the entire match block is a no-op. Readers may be aware of pattern matching through the simple example of matching a subject (data object) to a literal (pattern) with the switch statement found in C, Java or JavaScript (and many other languages). Often the switch statement is used for comparison of an object/expression with case statements containing literals. More powerful examples of pattern matching can be found in languages such as Scala and Elixir. With structural pattern matching, the approach is “declarative” and explicitly states the conditions (the patterns) for data to match. While an “imperative” series of instructions using nested “if” statements could be used to accomplish something similar to structural pattern matching, it is less clear than the “declarative” approach. Instead the “declarative” approach states the conditions to meet for a match and is more readable through its explicit patterns. While structural pattern matching can be used in its simplest form comparing a variable to a literal in a case statement, its true value for Python lies in its handling of the subject’s type and shape. Let’s look at this example as pattern matching in its simplest form: a value, the subject, being matched to several literals, the patterns. In the example below, is the subject of the match statement. The patterns are each of the case statements, where literals represent request status codes. The associated action to the case is executed after a match: If the above function is passed a of 418, “I’m a teapot” is returned. If the above function is passed a of 500, the case statement with will match as a wildcard, and “Something’s wrong with the internet” is returned. Note the last block: the variable name, , acts as a wildcard and insures the subject will always match. The use of is optional. You can combine several literals in a single pattern using (“or”): If we modify the above example by removing the last case block, the example becomes: Without the use of in a case statement, a match may not exist. If no match exists, the behavior is a no-op. For example, if of 500 is passed, a no-op occurs. Patterns can look like unpacking assignments, and a pattern may be used to bind variables. In this example, a data point can be unpacked to its x-coordinate and y-coordinate: The first pattern has two literals, , and may be thought of as an extension of the literal pattern shown above. The next two patterns combine a literal and a variable, and the variable binds a value from the subject ( ). The fourth pattern captures two values, which makes it conceptually similar to the unpacking assignment . If you are using classes to structure your data, you can use as a pattern the class name followed by an argument list resembling a constructor. This pattern has the ability to capture class attributes into variables: and the point is on the y-axis.\" and the point is on the x-axis.\" \"The point is located somewhere else on the plane.\" You can use positional parameters with some builtin classes that provide an ordering for their attributes (e.g. dataclasses). You can also define a specific position for attributes in patterns by setting the special attribute in your classes. If it’s set to (“x”, “y”), the following patterns are all equivalent (and all bind the attribute to the variable): Patterns can be arbitrarily nested. For example, if our data is a short list of points, it could be matched like this: \"The origin is the only point in the list.\" \"Two points on the Y axis at \"Something else is found in the list.\" To this point, the examples have used alone in the last case statement. A wildcard can be used in more complex patterns, such as . For example: In the above case, will match for (‘error’, code, 100) and (‘error’, code, 800). We can add an clause to a pattern, known as a “guard”. If the guard is false, goes on to try the next case block. Note that value capture happens before the guard is evaluated: \"The point is located on the diagonal Y=X at \"Point is not on the diagonal.\"\n• None Like unpacking assignments, tuple and list patterns have exactly the same meaning and actually match arbitrary sequences. Technically, the subject must be a sequence. Therefore, an important exception is that patterns don’t match iterators. Also, to prevent a common mistake, sequence patterns don’t match strings.\n• None Sequence patterns support wildcards: and work similar to wildcards in unpacking assignments. The name after may also be , so matches a sequence of at least two items without binding the remaining items.\n• None Mapping patterns: captures the and values from a dict. Unlike sequence patterns, extra keys are ignored. A wildcard is also supported. (But would be redundant, so is not allowed.)\n• None Subpatterns may be captured using the keyword: This binds x1, y1, x2, y2 like you would expect without the clause, and p2 to the entire second item of the subject.\n• None Most literals are compared by equality. However, the singletons , and are compared by identity.\n• None Named constants may be used in patterns. These named constants must be dotted names to prevent the constant from being interpreted as a capture variable: For the full specification see PEP 634. Motivation and rationale are in PEP 635, and a longer tutorial is in PEP 636. The default encoding of and is platform and locale dependent. Since UTF-8 is used on most Unix platforms, omitting option when opening UTF-8 files (e.g. JSON, YAML, TOML, Markdown) is a very common bug. For example: # BUG: \"rb\" mode or encoding=\"utf-8\" should be used. To find this type of bug, an optional is added. It is emitted when is true and locale-specific default encoding is used. option and are added to enable the warning. See Text Encoding for more information.\n• None Currently Python accepts numeric literals immediately followed by keywords, for example , , . It allows confusing and ambiguous expressions like (which can be interpreted as or ). Starting in this release, a deprecation warning is raised if the numeric literal is immediately followed by one of keywords , , , , , and . In future releases it will be changed to syntax warning, and finally to syntax error. (Contributed by Serhiy Storchaka in bpo-43833.)\n• None Starting in this release, there will be a concerted effort to begin cleaning up old import semantics that were kept for Python 2.7 compatibility. Specifically, / (superseded by ), (superseded by ), (which the import system takes care of for you), the attribute (superseded by ), the attribute (superseded by ), and the attribute (superseded by ) will slowly be removed (as well as other classes and methods in ). and/or will be raised as appropriate to help identify code which needs updating during this transition.\n• None The entire namespace is deprecated, to be removed in Python 3.12. Refer to the module changes section for more information.\n• None Non-integer arguments to are deprecated. The is deprecated in favor of a . (Contributed by Serhiy Storchaka and Raymond Hettinger in bpo-37319.)\n• None The various methods of have been documented as deprecated since Python 3.6, but will now also trigger a . Use instead. (Contributed by Brett Cannon in bpo-26131.)\n• None has been deprecated in preference for . (Contributed by Brett Cannon in bpo-26131.)\n• None The use of by the import system now triggers an as is preferred. (Contributed by Brett Cannon in bpo-26131.)\n• None The use of and by the import system now trigger an as and are preferred, respectively. You can use to help in porting. (Contributed by Brett Cannon in bpo-42134.)\n• None The use of by the import system now triggers an as is preferred. You can use to help in porting. (Contributed by Brett Cannon in bpo-43672.)\n• None The various implementations of ( , , , , ), ( ), and ( ) now raise and are slated for removal in Python 3.12 (previously they were documented as deprecated in Python 3.4). (Contributed by Brett Cannon in bpo-42135.)\n• None is deprecated (including its sole method, ). Both and no longer inherit from the class. Users should inherit from one of these two classes as appropriate instead. (Contributed by Brett Cannon in bpo-42135.)\n• None The deprecations of , , , , , , and have all been updated to list Python 3.12 as the slated version of removal (they began raising in previous versions of Python). (Contributed by Brett Cannon in bpo-43720.)\n• None The import system now uses the attribute on modules before falling back on for a module’s method. Removal of the use of is scheduled for Python 3.12. (Contributed by Brett Cannon in bpo-42137.)\n• None , , and are deprecated and slated for removal in Python 3.12. (Contributed by Brett Cannon in bpo-42136.)\n• None has been undocumented and obsolete since Python 3.3, when it was made an alias to . It is now deprecated, scheduled for removal in Python 3.12. (Contributed by Erlend E. Aasland in bpo-42264.)\n• None The undocumented built-in function is now deprecated, scheduled for removal in Python 3.12. Its use is strongly discouraged by the SQLite3 documentation. See the SQLite3 docs for more details. If a shared cache must be used, open the database in URI mode using the query parameter. (Contributed by Erlend E. Aasland in bpo-24464.)\n• None The following methods are now deprecated:\n• None is deprecated and slated for removal in Python 3.12. Use instead. (Contributed by Barney Gale in bpo-39950.)\n• None is deprecated and slated for removal in Python 3.12. (Contributed by Inada Naoki in bpo-41139.)\n• None The following features have been deprecated since Python 3.6, Python 3.7, or OpenSSL 1.1.0 and will be removed in 3.11:\n• None , , , , , and are replaced by and .\n• None , , , , , , and are deprecated in favor of and\n• None NPN features like and are replaced by ALPN.\n• None The threading debug ( environment variable) is deprecated in Python 3.10 and will be removed in Python 3.12. This feature requires a debug build of Python. (Contributed by Victor Stinner in bpo-44584.)\n• None Importing from the and submodules will now emit . These submodules will be removed in a future version of Python. Anything belonging to these submodules should be imported directly from instead. (Contributed by Sebastian Rittau in bpo-38291.)"
    },
    {
        "link": "https://geeksforgeeks.org/reading-and-writing-json-to-a-file-in-python",
        "document": "The full form of JSON is Javascript Object Notation. It means that a script (executable) file which is made of text in a programming language, is used to store and transfer the data. Python supports JSON through a built-in package called JSON. To use this feature, we import the JSON package in Python script. The text in JSON is done through quoted-string which contains the value in key-value mapping within { }. It is similar to the dictionary in Python.\n\nSerializing JSON refers to the transformation of data into a series of bytes (hence serial) to be stored or transmitted across a network. To handle the data flow in a file, the JSON library in Python uses dump() or dumps() function to convert the Python objects into their respective JSON object, so it makes it easy to write data to files. See the following table given below.\n\nMethod 1: Writing JSON to a file in Python using json.dumps()\n\nThe JSON package in Python has a function called json.dumps() that helps in converting a dictionary to a JSON object. It takes two parameters:\n• dictionary – the name of a dictionary which should be converted to a JSON object.\n• indent – defines the number of units for indentation\n\nAfter converting the dictionary to a JSON object, simply write it to a file using the “write” function.\n\nMethod 2: Writing JSON to a file in Python using json.dump()\n\nAnother way of writing JSON to a file is by using json.dump() method The JSON package has the “dump” function which directly writes the dictionary to a file in the form of JSON, without needing to convert it into an actual JSON object. It takes 2 parameters:\n• dictionary – the name of a dictionary which should be converted to a JSON object.\n• file pointer – pointer of the file opened in write or append mode.\n\nDeserialization is the opposite of Serialization, i.e. conversion of JSON objects into their respective Python objects. The load() method is used for it. If you have used JSON data from another program or obtained it as a string format of JSON, then it can easily be deserialized with load(), which is usually used to load from a string, otherwise, the root object is in a list or Dict.\n\nThe JSON package has json.load() function that loads the JSON content from a JSON file into a dictionary. It takes one parameter:"
    },
    {
        "link": "https://stackoverflow.com/questions/72693000/reading-in-json-file-in-python",
        "document": "Keep having issue reading in JSON file. I've tried everything from changing cwd to specifying absolute path... but nothing seems to work. Here is the current code:\n\nAnd this is the output I keep getting:"
    },
    {
        "link": "https://scrapingbee.com/blog/how-to-read-and-parse-json-data-with-python",
        "document": "JSON, or JavaScript Object Notation, is a popular data interchange format that has become a staple in modern web development. If you're a programmer, chances are you've come across JSON in one form or another. It's widely used in REST APIs, single-page applications, and other modern web technologies to transmit data between a server and a client, or between different parts of a client-side application. JSON is lightweight, easy to read, and simple to use, making it an ideal choice for developers looking to transmit data quickly and efficiently.\n\nIn this article, you will learn how to work with JSON in Python:\n• How to convert a JSON string to a Python object\n• How to convert a JSON file to a Python object\n• How to convert a Python object to a JSON string\n• How to convert a Python object to a JSON file\n• How to convert custom Python objects to JSON objects\n\nFor those who are new to JSON, it's a text-based format that uses key-value pairs to represent data. Keys are strings, and values can be strings, numbers, arrays, or other JSON objects. This structure makes it simple to transmit complex data structures in a human-readable format, and it's easy for machines to parse and generate as well. With its popularity, many programming languages, including Python, Java, and JavaScript, have built-in support for reading and writing JSON data.\n\nHere is what typical JSON data might look like:\n\nJSON is a completely language-independent format but uses conventions that are familiar to programmers of the C family of languages, including C, C++, C#, Java, JavaScript, Perl, Python, and many others. This makes it really easy to parse JSON data into corresponding data structures in the target language.\n\nFor instance, here is how the same data as above will be represented in Python:\n\nAnd likewise, here is how it will be represented in JavaScript:\n\nJSON has become the defacto standard on the web for API responses and various other avenues due to a bunch of reasons including:\n• Lightweight: JSON data is relatively small and lightweight compared to other data interchange formats, making it quick to transmit and parse.\n• Human-readable: JSON data is represented as key-value pairs, making it easy for humans to read and understand. This is particularly useful when debugging and troubleshooting.\n• Language-independent: JSON is based on a text format, which makes it language-independent. This means that JSON data can be transmitted between different programming languages and platforms without any loss of information.\n• Easy to use: Many programming languages, such as Python, Java, and JavaScript, have built-in support for reading and writing JSON data, making it easy for developers to integrate into their applications.\n• Wide adoption: JSON has been widely adopted in modern web development, particularly in REST APIs and single-page applications, which has led to a large ecosystem of libraries and tools that support it.\n• Flexibility: JSON can be used to represent a wide range of data structures, including simple key-value pairs, arrays, and complex nested objects. This flexibility makes it an ideal choice for representing complex data structures in a simple and intuitive format.\n\nNow that you know what JSON is, what it looks like, and why it is popular, let's take a look at how to work with JSON in Python.\n\nPython has extensive built-in support for JSON via its package. This has long been a part of Python and can help you in converting JSON to Python and vice-versa. As you saw earlier, JSON objects and Python dictionaries look very similar and if you do not pay attention, you might even confuse one for the other.\n\nFirst, go ahead and create a new directory named . This will contain all the code you will write in this tutorial. Then create a new file in this directory. This file will store all of the Python code.\n\nTo make use of the package, you need to import it into your Python projects. Go to the very top of the file and add this import:\n\nNow you are ready to use any of the different modules and methods that are exposed by the package.\n\nHow to convert a JSON string to a Python object\n\nYou can use the method to easily convert this JSON string to a Python object:\n\nNow you can access any key/value the same way as you would in a Python dictionary. This is the conversion table used by Python while decoding JSON to a Python object:\n\nYou can read more about the method in the official docs.\n\nHow to convert a JSON file to a Python object\n\nWhat if the same JSON string is stored in a file? Python makes it super easy to parse that into a Python object as well. Suppose you have a JSON file named in the folder and it contains the same JSON that you saw earlier:\n\nYou can use the method to parse this into a Python object. Notice that this time it is instead of . This slight distinction has a big impact on how either of these methods is used. , as you used previously, works on a , or instance that contains a JSON string and converts it into a Python object. Whereas works on a text or binary file-like object containing JSON that has the method defined.\n\nThis is how you can use to parse the file:\n\nNow let's take a look at how you can do it the other way around and encode a Python object to JSON.\n\nJust like how the package provides and , it provides similar methods to \"dump\" a Python object to a string or a file. In this section, you will learn what these methods are and how to use them.\n\nHow to convert a Python object to a JSON string\n\nThe package contains the method to convert a Python object to a JSON string. This is how it works:\n\nThe default conversion table used by looks like this:\n\nOne thing to keep in mind is that when you dump and load a JSON string, the resulting object might use different types from the one you dumped. For instance, take a look at this example:\n\nThis makes sense when you look at the conversion tables for both operations. Python converts both lists and tuples to a JSON array during encoding and then converts a JSON array into a Python list while decoding. So the data is the same but the data types are different. This is an important caveat to keep in mind while working with JSON in Python.\n\nHow to write a Python object to a JSON file\n\nWriting a Python object to a JSON file is as simple as calling . This method expects a file-like object that has a method defined. You can use it to write a Python object to a JSON file or a object (as that also provides a file-like interface with a method!). This is how it works:\n\nIf you open up in a text editor, you will see the profile dictionary dumped as a JSON string.\n\nHow to convert custom Python objects to JSON objects\n\nThis is all well and good but what happens if you want to encode a custom Python data structure/class and dump it as JSON into a file? The conversion tables that you have seen so far don't list such a conversion. Let's still try it out and see what happens:\n\nWhen you run this code, Python will scream at you. It is not happy and throws an error similar to this:\n\nPython has no idea how to serialize our custom Python object. Luckily, it provides us with a way to instruct it on how to do so.\n\nBy default, the module uses the class to perform the serialization. And as you saw, this class is aware of only a limited number of mappings between JSON and Python. However, you can subclass it and inform it about additional mappings and methods of performing serialization. Let's create a subclass and tell it how to serialize the object:\n\nThis time it works without a hitch! This is because the method knows how to encode the profile thanks to the subclass. The subclass simply checks whether the object being encoded is of type and if it is it returns the attributes of the class as a . You will need to add additional logic to this encoder if the CustomProfile contains attributes of additional custom types. It works for now because you are only using default types in .\n\nThis custom encoding magic works for too!\n\nIn this article, you learned how to encode and decode a JSON string to a Python object and vice versa. Moreover, you saw how a custom encoder can be used to encode custom types to JSON. The package is very versatile and provides a ton of additional features that are worth exploring. If you are working with JSON in Python then there is a pretty good chance that you will have to use this library. You can read more about it in the official Python documentation.\n\nPython also provides the and modules to serialize data. They follow a similar API to the package and will be even easier for you to learn now that you know about . Do explore them as well in case they suit your needs better. Best of luck!"
    },
    {
        "link": "https://geeksforgeeks.org/create-first-gui-application-using-python-tkinter",
        "document": "We are now stepping into making applications with graphical elements, we will learn how to make cool apps and focus more on its GUI(Graphical User Interface) using Tkinter.\n\nTkinter is a Python Package for creating GUI applications. Python has a lot of GUI frameworks, but Tkinter is the only framework that’s built into the Python standard library.\n\nTkinter has several strengths; it’s cross-platform, so the same code works on Windows, macOS, and Linux.\n\nTkinter is lightweight and relatively painless to use compared to other frameworks. This makes it a compelling choice for building GUI applications in Python, especially for applications where a modern shine is unnecessary, and the top priority is to build something functional and cross-platform quickly.\n\n1. Creating windows and dialog boxes: Tkinter can be used to create windows and dialog boxes that allow users to interact with your program. These can be used to display information, gather input, or present options to the user.\n\nTo create a window or dialog box, you can use the Tk() function to create a root window, and then use functions like Label, Button, and Entry to add widgets to the window.\n\n2. Building a GUI for a desktop application: Tkinter can be used to create the interface for a desktop application, including buttons, menus, and other interactive elements.\n\nTo build a GUI for a desktop application, you can use functions like Menu, Checkbutton, and RadioButton to create menus and interactive elements and use layout managers like pack and grid to arrange the widgets on the window.\n\n3. Adding a GUI to a command-line program: Tkinter can be used to add a GUI to a command-line program, making it easier for users to interact with the program and input arguments.\n\nTo add a GUI to a command-line program, you can use functions like Entry and Button to create input fields and buttons, and use event handlers like command and bind to handle user input.\n\n4. Creating custom widgets: Tkinter includes a variety of built-in widgets, such as buttons, labels, and text boxes, but it also allows you to create your own custom widgets.\n\nTo create a custom widget, you can define a class that inherits from the Widget class and overrides its methods to define the behavior and appearance of the widget.\n\n5. Prototyping a GUI: Tkinter can be used to quickly prototype a GUI, allowing you to test and iterate on different design ideas before committing to a final implementation.\n\nTo prototype a GUI with Tkinter, you can use the Tk() function to create a root window, and then use functions like Label, Button, and Entry to add widgets to the window and test different layouts and design ideas.\n\nThere are several libraries that are similar to Tkinter and can be used for creating graphical user interfaces (GUIs) in Python. Some examples include:\n• PyQt : PyQt is a GUI library that allows you to create GUI applications using the Qt framework. It is a comprehensive library with a large number of widgets and features.\n• wxPython : wxPython is a library that allows you to create GUI applications using the wxWidgets framework. It includes a wide range of widgets in it’s GUI toolkit and is cross-platform, meaning it can run on multiple operating systems.\n• PyGTK : PyGTK is a GUI library that allows you to create GUI applications using the GTK+ framework. It is a cross-platform library with a wide range of widgets and features.\n• Kivy : Kivy is a library that allows you to create GUI applications using a modern, responsive design. It is particularly well-suited for building mobile apps and games.\n• PyForms : PyForms is a library that allows you to create GUI applications using a simple, declarative syntax. It is designed to be easy to use and has a small footprint.\n• Pygame : PyForms is a library that is popular because you can develop video games using it. It is a free, open source, and cross-platform wrapper for the Simple DirectMedia Library (SDL). You can check if you are interested in video game development.\n\nIn summary, there are several libraries available for creating GUI applications in Python, each with its own set of features and capabilities. Tkinter is a popular choice, but you may want to consider other options depending on your specific needs and requirements.\n\nTo understand Tkinter better, we will create a simple GUI.\n\n1. Import tkinter package and all of its modules.\n\n2. Create a root window. Give the root window a title(using title()) and dimension(using geometry()). All other widgets will be inside the root window. \n\n3. Use mainloop() to call the endless loop of the window. If you forget to call this nothing will appear to the user. The window will wait for any user interaction till we close it.\n\n4. We’ll add a label using the Label Class and change its text configuration as desired. The grid() function is a geometry manager which keeps the label in the desired location inside the window. If no parameters are mentioned by default it will place it in the empty cell; that is 0,0 as that is the first location.\n\n5. Now add a button to the root window. Changing the button configurations gives us a lot of options. In this example we will make the button display a text once it is clicked and also change the color of the text inside the button.\n\n6. Using the Entry() class we will create a text box for user input. To display the user input text, we’ll make changes to the function clicked(). We can get the user entered text using the get() function. When the Button after entering of the text, a default text concatenated with the user text. Also change button grid location to column 2 as Entry() will be column 1.\n\n7. To add a menu bar, you can use Menu class. First, we create a menu, then we add our first label, and finally, we assign the menu to our window. We can add menu items under any menu by using add_cascade().\n\nOutput\n\nThis simple GUI covers the basics of Tkinter package. Similarly, you can add more widgets and change their configurations as desired.\n\nTkinter is the GUI library of Python, it provides various controls, such as buttons, labels and text boxes used in a GUI application. These controls are commonly called Widgets. The list of commonly used Widgets are mentioned below –\n\nThe Label widget is used to provide a single-line caption for other widgets. It can also contain images. The Button widget is used to display buttons in your application. The Entry widget is used to display a single-line text field for accepting values from a user. The Menu widget is used to provide various commands to a user. These commands are contained inside Menubutton. The Canvas widget is used to draw shapes, such as lines, ovals, polygons and rectangles, in your application. The Checkbutton widget is used to display a number of options as checkboxes. The user can select multiple options at a time. The Frame widget is used as a container widget to organize other widgets. The Listbox widget is used to provide a list of options to a user. The Menubutton widget is used to display menus in your application. The Message widget is used to display multiline text fields for accepting values from a user. The Radiobutton widget is used to display a number of options as radio buttons. The user can select only one option at a time. The Scale widget is used to provide a slider widget. The Scrollbar widget is used to add scrolling capability to various widgets, such as list boxes. The Text widget is used to display text in multiple lines. The Toplevel widget is used to provide a separate window container. A labelframe is a simple container widget. Its primary purpose is to act as a spacer or container for complex window layouts. This module is used to display message boxes in your applications. The Spinbox widget is a variant of the standard Tkinter Entry widget, which can be used to select from a fixed number of values. A PanedWindow is a container widget that may contain any number of panes, arranged horizontally or vertically.\n\nAll Tkinter widgets have access to specific geometry management methods, which have the purpose of organizing widgets throughout the parent widget area. Tkinter exposes the following geometry manager classes: pack, grid, and place. Their description is mentioned below –\n\nIn this article, we have learned about GUI programming in Python and how to make GUI in Python. GUI is a very demanded skill so you must know how to develop GUI using Python. Hope this article helped you in creating GUI using Python.\n\nHow to Make a GUI in Python Tkinter?\n\nHow Do I Create My First Application in Python?\n\nHow to Create an App Using Tkinter?\n\nWhich GUI is Best for Python?\n\nWhat is the Simplest Python GUI?"
    },
    {
        "link": "https://geeksforgeeks.org/image-viewer-app-in-python-using-tkinter",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/47732254/setting-up-gui-with-tkinter-for-image-and-text-inputs",
        "document": "Im using python 2.7 to build a satellite tracker for a cubesat project at my university. Now I've got the whole thing running as I want it to. I produce 4 images and a load of text based on the ISS's orbit parameters as our cubesat is not yet flying.\n\n1) Satellite's current position on a globe based on its TLE straight from celestrak.\n\n3) Its current lat/lon position translated to a google earth view to physically interpret where it is.\n\n4) Its current lat/lon position based on current weather maps, for whether or not there are clouds in the region, obscuring the satellites remote sensing imaging capabilities. (Reason why the picture looks ugly and purple, is because this region had no current weather data at the time of retrieving data)\n\nThen I need to implement a text box with information on altitude, velocity, spatial resolution etc.\n\nIt's all nice and dandy. But I cant for the love of god figure out how to get this Tkinter GUI to play nice! I'm a geoscientist, not a computer scientist and python programming is very new to me :D\n\nAnyway I did a quick layout in photoshop as of how I want the finished data to be produced in a Tkinter GUI. See the primitive image below:\n\nNow here is my shameful code below:\n\nMy issues are clearly:\n\n1) Images are not aligned in any way I want. Normally in HTML I'd set up table rows, align and fit it with spacers as I want. But I don't know how to define that here and I've spend hours being frustrated of this by now.\n\n2) I need to add a text box. Every time I've tried to add various versions of text boxes. I get weird pyimage'xx' errors and no text box seems to materialize.\n\n3) For the future: A button under the images that will show the full size uncropped picture. But that's not imperative right now!\n\nSo I'm hoping one of you have a nice way to do this, or can point me in a direction.. or perhaps even have done something like it where I can see your code and just tweak the numbers of a bit for aligning the pixels.\n\nThank you in advance."
    },
    {
        "link": "https://stackoverflow.com/questions/17504570/creating-simply-image-gallery-in-python-tkinter-pil",
        "document": "So, I'm on simple project for a online course to make an image gallery using python. The thing is to create 3 buttons one Next, Previous and Quit. So far the quit button works and the next loads a new image but in a different window, I'm quite new to python and GUI-programming with Tkinter so this is a big part of the begineers course.\n\nSo far my code looks like this and everything works. But I need help in HOW to make a previous and a next button, I've used the NEW statement so far but it opens in a different window. I simply want to display 1 image then click next image with some simple text."
    },
    {
        "link": "https://activestate.com/resources/quick-reads/how-to-add-images-in-tkinter",
        "document": "This Python tutorial is a part of our series of Python Package tutorials . You can find other Tkinter related topics too!\n\nTkinter relies on the Python Pillow (aka PIL) package for image processing capabilities. Using Pillow, a Tkinter function that displays a text-based message can instead display an image-based message.\n\nNote that depending on the purpose of an image in a Tkinter application, different coding may be required. The reason for this is because images in applications can vary from background wallpaper, to positioned images that represent processes in underlying code, to clickable images or icons that perform an action when clicked.\n\nHow to Display Images with Tkinter’s Label Widget\n\nTkinter’s label widget can be used to display either images or text. To display an image requires the use of Image and ImageTk imported from the Python Pillow (aka PIL) package.\n\nA label widget can display either PhotoImage or BitmapImage objects:\n• The PhotoImage class is used to display grayscale or true color icons, as well as images in labels. Note that only GIF and PGM/PPM image formats are supported. For information on how you can work with more image formats, see the Pillow section below.\n• The BitmapImage class is used to display only monochrome (two-color) images in labels.\n\nTkinter has three built-in Layout Managers that can be used to position labels containing images in a frame: pack, grid, and place. For example, a label can be placed in a frame using the place layout manager at x,y coordinates, as shown in the following example:\n\nHow to Use Pillow with Tkinter\n\nTkinter relies on Pillow for working with images. Pillow is a fork of the Python Imaging Library, and can be imported in a Python console as PIL. Pillow has the following characteristics:\n• Support for a wide range of image file formats, including PNG, JPEG and GIF.\n• Width and height options that can be used to set the Label size for an image. If a size is not specified, the Label will be just large enough to display its contents.\n\nTo check if Pillow is already installed, enter the following command in a Python console:\n\nIf Pillow is not installed, you can install it with:\n\nHow to Manipulate Images with PIL and ImageTk\n\nTo import ImageTk and Image in a Python console, enter:\n\nAn image can be opened with the following code snippet:\n\nThe resize() option can be used to set an image’s height and width. In the following example, an image’s dimensions are set to 50 pixels high and wide:\n\nIf an image size is not specified, the Label will be just large enough to display its contents.\n\nHow to Display a Background Image with Tkinter\n\nThe following example displays a background image in a frame:\n\nHow to Display an Image on a Tkinter Button\n\nThe following example displays an image positioned on a button"
    }
]