[
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.io.file.readalllines?view=net-9.0",
        "document": "A string array containing all lines of the file.\n\nThe following code example demonstrates the use of the ReadAllLines method to display the contents of a file. In this example a file is created, if it doesn't already exist, and text is added to it.\n\nThis method opens a file, reads each line of the file, and then adds each line as an element of a string array. It then closes the file. A line is defined as a sequence of characters followed by a carriage return ('\\r'), a line feed ('\n\n'), or a carriage return immediately followed by a line feed. The resulting string does not contain the terminating carriage return and/or line feed.\n\nThis method attempts to automatically detect the encoding of a file based on the presence of byte order marks. Encoding formats UTF-8 and UTF-32 (both big-endian and little-endian) can be detected.\n• How to: Write Text to a File\n• How to: Read and Write to a Newly Created Data File"
    },
    {
        "link": "https://stackoverflow.com/questions/23989677/file-readalllines-or-stream-reader",
        "document": "We can read file either by using or by using .\n\nFor example I want to load each line into a or for further manipulation on each line.\n\nApplication come across different size of text file. Which could grow from few to occasionally.\n\nMy question is that which one is preferred way and why one should be preferred over other?"
    },
    {
        "link": "https://geeksforgeeks.org/file-readalllinesstring-method-in-c-sharp-with-examples",
        "document": "File.ReadAllLines(String) is an inbuilt File class method that is used to open a text file then reads all lines of the file into a string array and then closes the file.\n\nSyntax: \n\n\n\nParameter: This function accepts a parameter which is illustrated below:\n• ArgumentException: The path is a zero-length string, contains only white space, or one or more invalid characters as defined by InvalidPathChars.\n• PathTooLongException: The specified path, file name, or both exceed the system-defined maximum length.\n• DirectoryNotFoundException: The specified path is invalid.\n• IOException: An I/O error occurred while opening the file.\n• UnauthorizedAccessException: The path specified a file that is read-only. OR this operation is not supported on the current platform. OR the path specified a directory. OR the caller does not have the required permission.\n• FileNotFoundException: The file specified in the path was not found.\n• NotSupportedException: The path is in an invalid format.\n• SecurityException: The caller does not have the required permission.\n\nReturn Value: Returns a string array containing all lines of the file.\n\nBelow are the programs to illustrate the File.ReadAllLines(String) method.\n\nProgram 1: Initially, a file file.txt is created with some contents shown below-\n\n\n\nProgram 2: Initially, no file was created. Below code itself create a file file.txt with some specified contents."
    },
    {
        "link": "https://geeksforgeeks.org/how-to-read-and-write-a-text-file-in-c-sharp",
        "document": "How to Read and Write a Text File in C#?\n\nTermination of a program leads to the deletion of all data related to it. Therefore, we need to store the data somewhere. Files are used for permanently storing and sharing data. C# can be used to retrieve and manipulate data stored in text files.\n\nReading a Text file: The file class in C# defines two static methods to read a text file namely File.ReadAllText() and File.ReadAllLines().\n• The File.ReadAllText() reads the entire file at once and returns a string. We need to store this string in a variable and use it to display the contents onto the screen.\n• The File.ReadAllLines() reads a file one line at a time and returns that line in string format. We need an array of strings to store each line. We display the contents of the file using the same string array.\n\nThere is another way to read a file and that is by using a StreamReader object. The StreamReader also reads one line at a time and returns a string. All of the above-mentioned ways to read a file are illustrated in the example code given below.\n\nTo run this program, save the file with .cs extension and then can execute using csc filename.cs command on cmd. Or you can use the Visual Studio. Here, we have a text file named as Textfile.txt which have the content shown in the output.\n\nWriting a Text File: The File class in C# defines two static methods to write a text file namely File.WriteAllText() and File.WriteAllLines().\n• The File.WriteAllText() writes the entire file at once. It takes two arguments, the path of the file and the text that has to be written.\n• The File.WriteAllLines() writes a file one line at a time. It takes two arguments, the path of the file and the text that has to be written, which is a string array.\n\nThere is another way to write to a file and that is by using a StreamWriter object. The StreamWriter also writes one line at a time. All of the three writing methods create a new file if the file doesn’t exist, but if the file is already present in that specified location then it is overwritten. All of the above-mentioned ways to write to a text file are illustrated in the example code given below.\n\nTo run this program, save the file with .cs extension and then can execute using csc filename.cs command on cmd. Or you can use the Visual Studio.\n\nIn case you want to add more text to an existing file without overwriting the data already stored in it, you can use the append methods provided by the File class of System.IO."
    },
    {
        "link": "https://stackoverflow.com/questions/7387085/how-to-read-an-entire-file-to-a-string-using-c",
        "document": "@Cris sorry .This is quote\n\nIn this experiment, two classes will be compared. The and the class will be directed to read two files of 10K and 200K in their entirety from the application directory.\n\nis obviously faster in this test. It takes an additional 50% more time for to read the small file. For the large file, it took an additional 27% of the time.\n\nis specifically looking for line breaks while does not. This will account for some of the extra time.\n\nDepending on what the application needs to do with a section of data, there may be additional parsing that will require additional processing time. Consider a scenario where a file has columns of data and the rows are delimited. The would work down the line of text looking for the , and then the application would do additional parsing looking for a specific location of data. (Did you think String. SubString comes without a price?)\n\nOn the other hand, the reads the data in chunks and a proactive developer could write a little more logic to use the stream to his benefit. If the needed data is in specific positions in the file, this is certainly the way to go as it keeps the memory usage down.\n\nis the better mechanism for speed but will take more logic."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.io.directory.createdirectory?view=net-9.0",
        "document": "An object that represents the directory at the specified path. This object is returned regardless of whether a directory at the specified path already exists.\n\n.NET Framework and .NET Core versions older than 2.1: is a zero-length string, contains only white space, or contains one or more invalid characters. You can query for invalid characters by using the GetInvalidPathChars() method. is prefixed with, or contains, only a colon character (:).\n\nThe following example creates and deletes the specified directory:\n\nTo create the directory C:\\Users\\User1\\Public\\Html when the current directory is C:\\Users\\User1, use any of the following calls to ensure that the backslash is interpreted properly:\n\nAny and all directories specified in are created, unless they already exist or unless some part of is invalid. If the directory already exists, this method does not create a new directory, but it returns a DirectoryInfo object for the existing directory.\n\nTrailing spaces are removed from the end of the parameter before creating the directory.\n\nYou can create a directory on a remote computer, on a share that you have write access to. UNC paths are supported; for example, you can specify the following for : in Visual Basic, and in C#.\n\nCreating a directory with only the colon character (:) is not supported, and will cause a to be thrown.\n\nOn Unix systems, use a forward slash (/) as path separator.\n• How to: Read Text from a File\n• How to: Write Text to a File"
    },
    {
        "link": "https://stackoverflow.com/questions/3201598/how-do-i-create-a-file-and-any-folders-if-the-folders-dont-exist",
        "document": "Imagine I wish to create (or overwrite) the following file :-\n\nUsing the File.Create(..) method, this can do it.\n\nBUT, if I don't have either one of the following folders (from that example path, above)\n\nthen I get an DirectoryNotFoundException thrown.\n\nSo .. given a path, how can we recursively create all the folders necessary to create the file .. for that path? If Temp or Bar folders exists, but Foo doesn't... then that is created also.\n\nFor simplicity, lets assume there's no Security concerns -- all permissions are fine, etc."
    },
    {
        "link": "https://stackoverflow.com/questions/50297100/directory-createdirectory-results-in-system-io-error-files-write-too-fast",
        "document": "I have a problem that I am unable to reproduce in the lab / dev environment.\n\nA beta user is reporting the following error during a file copy.\n\nThe line of code in question is:\n\nNow I'm speculating what is going on here is this. Directory.CreateDirectory hands the operation off to the OS. On my test and dev machines there are plenty of resources and the OS creates the directory instantly.\n\nOn the beta users machine it is more resource challenged and it doesn't create the directory for a few milliseconds...perhaps even a full second.\n\nIn the meantime my application has moved on and is expecting the folder to be there. file.CopyTo(path, true);\n\nMy first question is if I am connecting the dots properly.\n\nSecond question is if so how should I handle?\n• None sleep the app and monitor OS events for the folder created flag and then proceed. This seems to be a complex solution.\n• None Sleep the app. Spin up a new thread that probes for the folder. When it exists kill thread then proceed. Perhaps not a new thread but same idea on main thread?"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.io.directory?view=net-9.0",
        "document": "The following example shows how to retrieve all the text files from a directory and move them to a new directory. After the files are moved, they no longer exist in the original directory.\n\nThe following example demonstrates how to use the EnumerateFiles method to retrieve a collection of text files from a directory, and then use that collection in a query to find all the lines that contain \"Example\".\n\nThe following example demonstrates how to move a directory and all its files to a new directory. The original directory no longer exists after it has been moved.\n\nUse the Directory class for typical operations such as copying, moving, renaming, creating, and deleting directories.\n• None To create a directory, use one of the CreateDirectory methods.\n• None To delete a directory, use one of the Delete methods.\n• None To get or set the current directory for an app, use the GetCurrentDirectory or SetCurrentDirectory method.\n• None To manipulate DateTime information related to the creation, access, and writing of a directory, use methods such as SetLastAccessTime and SetCreationTime.\n\nThe static methods of the Directory class perform security checks on all methods. If you are going to reuse an object several times, consider using the corresponding instance method of DirectoryInfo instead, because the security check will not always be necessary.\n\nIf you are performing only one directory-related action, it might be more efficient to use a static Directory method rather than a corresponding DirectoryInfo instance method. Most Directory methods require the path to the directory that you are manipulating.\n\nIn members that accept a path, the path can refer to a file or a directory. You can use a full path, a relative path, or a Universal Naming Convention (UNC) path for a server and share name. For example, all the following are acceptable paths:\n• None \"c:\\\\MyDir\" in C#, or \"c:\\MyDir\" in Visual Basic.\n• None \"MyDir\\\\MySubdir\" in C#, or \"MyDir\\MySubDir\" in Visual Basic.\n• None \"\\\\\\\\MyServer\\\\MyShare\" in C#, or \"\\\\MyServer\\MyShare\" in Visual Basic.\n\nBy default, full read/write access to new directories is granted to all users. However, the app must have the correct security to access existing directories.\n\nTo demand permissions for a directory and all its subdirectories, end the path string with the directory separator character. (For example, \"C:\\Temp\\\" grants access to C:\\Temp\\ and all its subdirectories.) To demand permissions only for a specific directory, end the path string with a period. (For example, \"C:\\Temp\\.\" grants access only to C:\\Temp\\, not to its subdirectories.)\n\nIn members that accept a parameter, the search string can be any combination of literal characters and two wildcard characters; * and ?. This parameter does not recognize regular expressions. For more information, see the EnumerateDirectories(String, String) method or any other method that uses the parameter.\n\nFor a list of common I/O tasks, see Common I/O Tasks.\n\nDirectory and DirectoryInfo are not supported for use in Windows Store apps. For information about how to access files and folders in Windows Store apps, see Accessing data and files (Windows Store apps).\n• How to: Read Text from a File\n• How to: Write Text to a File\n• How to: Read and Write to a Newly Created Data File"
    },
    {
        "link": "https://geeksforgeeks.org/c-sharp-program-to-create-a-directory",
        "document": "A directory is a file system that stores file. Now our task is to create a directory in C#. We can create a directory by using the CreateDirectory() method of the Directory class. This method is used to create directories and subdirectories in a specified path. If the specified directory exists or the given path is invalid then this method will not create a directory. To use CreateDirectory() method we have to import the system.IO namespace in the program.\n\nReturn: This will return the object of the specified created directory.\n\nException: It will throw the following exception:\n• IOException: This exception occurs when the directory specified by path is a file.\n• UnauthorizedAccessException: This exception occurs when the caller does not have the required permission.\n• ArgumentException: This exception occurs when the path is prefixed with, or contains, only a colon character (:).\n• ArgumentNullException: This exception occurs when the path is null.\n• PathTooLongException: This exception occurs when the specified path, file name, or both exceed the system-defined maximum length.\n• DirectoryNotFoundException: This exception occurs when the specified path is invalid\n• NotSupportedException: This exception occurs when the path contains a colon character(:) that is not part of a drive label (“D:\\”)."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.guid.newguid?view=net-9.0",
        "document": "Some information relates to prerelease product that may be substantially modified before it’s released. Microsoft makes no warranties, express or implied, with respect to the information provided here.\n\nThe following code example creates and displays the values of two Guid objects.\n\nThis is a convenient method that you can call to get a new Guid. The method creates a Version 4 Universally Unique Identifier (UUID) as described in RFC 4122, Sec. 4.4. The returned Guid is guaranteed to not equal Guid.Empty.\n\nOn Windows, this function wraps a call to the CoCreateGuid function. The generated GUID contains 122 bits of strong entropy.\n\nOn non-Windows platforms, starting with .NET 6, this function calls the OS's underlying cryptographically secure pseudo-random number generator (CSPRNG) to generate 122 bits of strong entropy. In previous versions of .NET, the entropy is not guaranteed to be generated by a CSPRNG.\n\nIt is recommended that applications not use the NewGuid method for cryptographic purposes. First, since a Version 4 UUID has a partially predictable bit pattern, the NewGuid function cannot serve as a proper cryptographic pseudo-random function (PRF). If the output of NewGuid is given to a cryptographic component which requires its input to be generated by a proper PRF, the cryptographic component may not be able to maintain its security properties. Second, NewGuid utilizes at most 122 bits of entropy, regardless of platform. Some cryptographic components set a minimum entropy level on their inputs as a matter of policy. Such policies often set the minimum entropy level at 128 bits or higher. Passing the output of NewGuid to such a routine may violate its policy.\n\nIf an application requires random data for cryptographic purposes, consider using a static method on the RandomNumberGenerator class. That class provides a random number generator suitable for cryptographic use."
    },
    {
        "link": "https://ironpdf.com/blog/net-help/csharp-new-guid",
        "document": "Test in production without watermarks.\n\nWorks wherever you need it to."
    },
    {
        "link": "https://stackoverflow.com/questions/11313205/generate-a-unique-id",
        "document": "Why can't we make a unique id as below.\n\nWe can use DateTime.Now.Ticks and Guid.NewGuid().ToString() to combine together and make a unique id.\n\nAs the DateTime.Now.Ticks is added, we can find out the Date and Time in seconds at which the unique id is created.\n\nPlease see the code.\n\nWe can even take the part of ticks in unique id and check for the date and time later for future reference."
    },
    {
        "link": "https://stackoverflow.com/questions/11938151/guid-newguid-vs-new-guid",
        "document": "creates a new UUID using an algorithm that is designed to make collisions very, very unlikely.\n\nGenerally you would prefer the former, because that's the point of a UUID (unless you're receiving it from somewhere else of course).\n\nThere are cases where you do indeed want an all-zero UUID, but in this case or is clearer about your intent, and there's less chance of someone reading it expecting a unique value had been created.\n\nIn all, isn't that useful due to this lack of clarity, but it's not possible to have a value-type that doesn't have a parameterless constructor that returns an all-zeros-and-nulls value.\n\nEdit: Actually, it is possible to have a parameterless constructor on a value type that doesn't set everything to zero and null, but you can't do it in C#, and the rules about when it will be called and when there will just be an all-zero struct created are confusing, so it's not a good idea anyway."
    },
    {
        "link": "https://reddit.com/r/csharp/comments/ytx7q3/how_do_you_add_a_unique_identifier_when",
        "document": "I'd like to generate a GUID that will be used as the primary key in my database.\n• Check if exist in the database, if not then insert it.\n• Repeat the task until nothing exists in the database.\n\nThe problem is I have two different databases, one is the local database and the other one is in the main server. Multiple clients will have their own local database and will upload into the main server making migration of each local database.\n\nWith this, I'm afraid that the generated GUID might already exist from another client. To solve this, I'd liked to add a unique string as an identifier to each client during the generation of the GUID.\n\nI'm not sure if this is the best way to do it but I currently have the following;\n\nWhat do you think?"
    }
]