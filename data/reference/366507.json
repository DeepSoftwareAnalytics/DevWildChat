[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest_API/Sending_and_Receiving_Binary_Data",
        "document": "The property of the XMLHttpRequest object can be set to change the expected response type from the server. Possible values are the empty string (default), , , , , and . The property will contain the entity body according to , as an , , , , or string. This is if the request is not complete or was not successful.\n\nThis example reads an image as a binary file and creates an 8-bit unsigned integer array from the raw bytes. Note that this will not decode the image and read the pixels. This can be done with the interface.\n\nYou can also read a binary file as a by setting the string to the property."
    },
    {
        "link": "https://stackoverflow.com/questions/4376657/is-there-any-way-to-send-binary-data-with-xmlhttprequest-object",
        "document": "I'am trying to send binary chunk with XMLHttpRequest\n\nBut this approach not works. I've tried to provide Content-type: application/octet-stream, Content-encoding headers for xhr and they don't work either. I am suspect that there is no way to compose request of such kind.\n\nI would appreciate any help."
    },
    {
        "link": "https://stackoverflow.com/questions/1095102/how-do-i-load-binary-image-data-using-javascript-and-xmlhttprequest",
        "document": "Here's how I did it.\n\nThis technique is provided in an answer to another SO question, but it's also relevant here.\n\nI didn't want to base64 encode anything. I wanted to download and parse binary files in the browser via Javascript, without modifying the server to encode them specially. I found that in Firefox, by coercing the mimetype of the response via , I could use . On IE, it's different because:\n• None on IE truncates at the first zero. For binary streams this is a big problem.\n• None there is no , to force IE to treat binary streams as text.\n• None while there is a (IE only!) that is specifically designed to be used with binary data streams, maddeningly that property is not usable from Javascript.\n\nTherefore, the need is to convert IE's property into a thing that looks like from FireFox, with the mime-type coercion. This is possible using injected VBScript.\n\nTo make it cross-browser, you need to just pack up the browser-specific logic in a conditional. This is what I used:\n\n...then call to get the byte at the ith position in the binary file.\n\nCredit to Miskun for the VBScript conversion logic."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest_API/Using_XMLHttpRequest",
        "document": "This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015 . * Some parts of this feature may have varying levels of support.\n\nIn this guide, we'll take a look at how to use to issue HTTP requests in order to exchange data between the website and a server. Examples of both common and more obscure use cases for are included. After the transaction completes, the object will contain useful information such as the response body and the HTTP status of the result.\n\nA request made via can fetch the data in one of two ways, asynchronously or synchronously. The type of request is dictated by the optional argument (the third argument) that is set on the method. If this argument is or not specified, the is processed asynchronously, otherwise the process is handled synchronously. A detailed discussion and demonstrations of these two types of requests can be found on the synchronous and asynchronous requests page. You can't use synchronous requests outside web workers as it freezes the main interface. Note: The constructor isn't limited to only XML documents. It starts with \"XML\" because when it was created the main format that was originally used for asynchronous data exchange was XML.\n\nAlthough is most commonly used to send and receive textual data, it can be used to send and receive binary content. There are several well tested methods for coercing the response of an into sending binary data. These involve utilizing the method on the object and is a workable solution. However, more modern techniques are available, since the attribute now supports a number of additional content types, which makes sending and receiving binary data much easier. For example, consider this snippet, which uses the of to fetch the remote content into a object, which stores the raw binary data. For more examples check out the Sending and Receiving Binary Data page.\n\nprovides the ability to listen to various events that can occur while the request is being processed. This includes periodic progress notifications, error notifications, and so forth. Support for DOM event monitoring of transfers follows the specification for progress events: these events implement the interface. The actual events you can monitor to determine the state of an ongoing transfer are: The amount of data that has been retrieved has changed. The transfer is complete; all data is now in the const req = new XMLHttpRequest(); req.addEventListener(\"progress\", updateProgress); req.addEventListener(\"load\", transferComplete); req.addEventListener(\"error\", transferFailed); req.addEventListener(\"abort\", transferCanceled); req.open(); // … // progress on transfers from the server to the client (downloads) function updateProgress(event) { if (event.lengthComputable) { const percentComplete = (event.loaded / event.total) * 100; // … } else { // Unable to compute progress information since the total size is unknown } } function transferComplete(evt) { console.log(\"The transfer is complete.\"); } function transferFailed(evt) { console.log(\"An error occurred while transferring the file.\"); } function transferCanceled(evt) { console.log(\"The transfer has been canceled by the user.\"); } We add event listeners for the various events that are sent while performing a data transfer using . Note: You need to add the event listeners before calling on the request. Otherwise the events will not fire. The progress event handler, specified by the function in this example, receives the total number of bytes to transfer as well as the number of bytes transferred so far in the event's and fields. However, if the field is false, the total length is not known and will be zero. Progress events exist for both download and upload transfers. The download events are fired on the object itself, as shown in the above sample. The upload events are fired on the object, as shown below: Note: Progress events are not available for the protocol. Progress events come in for every chunk of data received, including the last chunk in cases in which the last packet is received and the connection closed before the progress event is fired. In this case, the progress event is automatically fired when the load event occurs for that packet. This lets you now reliably monitor progress by only watching the \"progress\" event. One can also detect all three load-ending conditions ( , , or ) using the event: req.addEventListener(\"loadend\", loadEnd); function loadEnd(e) { console.log( \"The transfer finished (although we don't know if it succeeded or not).\", ); } Note there is no way to be certain, from the information received by the event, as to which condition caused the operation to terminate; however, you can use this to handle tasks that need to be performed in all end-of-transfer scenarios.\n\nIf you conclude with an XMLHttpRequest receiving and , this means the request was not allowed to be performed. It was . A likely cause for this is when the origin (at the creation of the XMLHttpRequest) has changed when the XMLHttpRequest is subsequently . This case can happen, for example, when one has an XMLHttpRequest that gets fired on an onunload event for a window, the expected XMLHttpRequest is created when the window to be closed is still there, and finally sending the request (in other words, ) when this window has lost its focus and another window gains focus. The most effective way to avoid this problem is to set a listener on the new window's event which is set once the terminated window has its event triggered."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseType",
        "document": "Note: This feature is available in Web Workers, except for Service Workers. The property is an enumerated string value specifying the type of data contained in the response. It also lets the author change the response type. If an empty string is set as the value of , the default value of is used.\n\nA string which specifies what type of data the response contains. It can take the following values: An empty string is the same as , the default type. The is a JavaScript containing binary data. The is a object containing the binary data. The is an HTML or XML , as appropriate based on the MIME type of the received data. See HTML in XMLHttpRequest to learn more about using XHR to fetch HTML content. The is a JavaScript object created by parsing the contents of received data as JSON. The is a text in a string. Note: When setting to a particular value, the author should make sure that the server is actually sending a response compatible with that format. If the server returns data that is not compatible with the that was set, the value of will be .\n\nYou cannot change the value of in a synchronous except when the request belongs to a . This restriction is designed in part to help ensure that synchronous operations aren't used for large transactions that block the browser's main thread, thereby bogging down the user experience. XHR requests are asynchronous by default; they are only placed in synchronous mode by passing as the value of the optional parameter when calling ."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL_static",
        "document": "Note: This feature is available in Web Workers, except for Service Workers. The static method of the interface creates a string containing a URL representing the object given in the parameter. The URL lifetime is tied to the in the window on which it was created. The new object URL represents the specified object or object. Note: This feature is not available in Service Workers due to its potential to create memory leaks.\n\nEach time you call , a new object URL is created, even if you've already created one for the same object. Each of these must be released by calling when you no longer need them. Browsers will release object URLs automatically when the document is unloaded; however, for optimal performance and memory usage, if there are safe times when you can explicitly unload them, you should do so.\n\nIn older versions of the Media Source specification, attaching a stream to a element required creating an object URL for the . This is no longer necessary, and browsers are removing support for doing this. Warning: If you still have code that relies on to attach streams to media elements, you need to update your code to set to the directly."
    },
    {
        "link": "https://stackoverflow.com/questions/51019467/convert-blob-to-image-url-and-use-in-image-src-to-display-image",
        "document": "When trying to load an image as a blob from a server response I ran into the issue that Angular2 (7) is considering the provided url as unsafe. When searching for a solution the widely suggested solution is to use to bypass the security.\n\nSee example from @Amirreza here, but also in other StackOverflow posts the same solution is suggested.\n\nOn the angular documentation page for they write the following:\n\nSeems to me that it is not safe to do so, unless you are really really sure that the image source can be trusted! \n\n You should consider that even if the source comes from your own server, it might have been uploaded by a user and it would be possible to exploit such a solution by uploading a malicious image.\n\nIt is better and more secure to convert the blob (image) into a data-url (a base64 string) and set that as the for your image element.\n\nThis solution is also suggested in the blog post here and even in the other answer from @Powkachu, but in that answer the mistake is that the base64 protocol identifier is added double (the already returns this in the result) and unnecessarily passed to the from the sanitizer.\n\nThe correct, secure and more simple solution would look like this:\n\nWhere blob is a and is a dataUrl (base64 string) that now can be set as image src immediately:\n\nHere a fiddle in plain Javascript to demonstrate the workings of this solution without Angular."
    },
    {
        "link": "https://stackoverflow.com/questions/11876175/how-to-get-a-file-or-blob-from-an-object-url",
        "document": "The problem with fetching the blob URL again is that this will create a full copy of the Blob's data, and so instead of having it only once in memory, you'll have it twice. With big Blobs this can blow your memory usage quite quickly.\n\nIt's rather unfortunate that the File API doesn't give us access to the currently linked Blobs, certainly they thought web-authors should store that Blob themselves at creation time anyway, which is true:\n\nThe best here is to store the object you used when creating the blob:// URL.\n\nIf you are afraid this would prevent the Blob from being Garbage Collected, you're right, but so does the blob:// URL in the first place, until you revoke it. So holding yourself a pointer to that Blob won't change a thing.\n\nBut for those who aren't responsible for the creation of the blob:// URI (e.g because a library made it), we can still fill that API hole ourselves by overriding the default URL.createObjectURL and URL.revokeObjectURL methods so that they do store references to the object passed.\n\nBe sure to call this function before the code that does generate the blob:// URI is called.\n\nAnd an other advantage is that it can even retrieve MediaSource objects, while the fetching solutions would just err in that case."
    },
    {
        "link": "https://reddit.com/r/learnjavascript/comments/d1ocm5/how_to_use_urlcreateobjecturl_for_blob_images",
        "document": "This subreddit is for anyone who wants to learn JavaScript or help others do so. Questions and posts about frontend development in general are welcome, as are all posts pertaining to JavaScript on the backend."
    },
    {
        "link": "https://id.javascript.info/blob",
        "document": "and views are a part of ECMA standard, a part of JavaScript.\n\nconsists of an optional string (a MIME-type usually), plus – a sequence of other objects, strings and .\n• – the of the new blob, by default the same as the source.\n\nWe can’t change data directly in a , but we can slice parts of a , create new objects from them, mix them into a new and so on. This behavior is similar to JavaScript strings: we can’t change a character in a string, but we can make a new corrected string.\n\nA Blob can be easily used as a URL for , or other tags, to show its contents.\n\nLet’s start with a simple example. By clicking on a link you download a dynamically-generated with contents as a file:\n\nWe can also create a link dynamically in JavaScript and simulate a click by , then download starts automatically.\n\nHere’s the similar code that causes user to download the dynamically created , without any HTML:\n\ntakes a and creates a unique URL for it, in the form .\n\nFor each URL generated by the browser stores a URL → mapping internally. So such URLs are short, but allow to access the .\n\nA generated URL (and hence the link with it) is only valid within the current document, while it’s open. And it allows to reference the in , , basically any other object that expects a URL.\n\nThere’s a side-effect though. While there’s a mapping for a , the itself resides in the memory. The browser can’t free it.\n\nremoves the reference from the internal mapping, thus allowing the to be deleted (if there are no other references), and the memory to be freed.\n\nIn the previous example with the clickable HTML-link, we don’t call , because that would make the url invalid. After the revocation, as the mapping is removed, the URL doesn’t work any more.\n\nThat encoding represents binary data as a string of ultra-safe “readable” characters with ASCII-codes from 0 to 64. And what’s more important – we can use this encoding in “data-urls”.\n\nA data url has the form . We can use such urls everywhere, on par with “regular” urls.\n\nThe browser will decode the string and show the image:\n\nTo transform a into base64, we’ll use the built-in object. It can read data from Blobs in multiple formats. In the next chapter we’ll cover it more in-depth.\n\nHere’s the demo of downloading a blob, now via base-64:\n\nBoth ways of making a URL of a are usable. But usually is simpler and faster.\n\nWe can create a of an image, an image part, or even make a page screenshot. That’s handy to upload it somewhere.\n\nFor screenshotting a page, we can use a library such as https://github.com/niklasvh/html2canvas. What it does is just walks the page and draws it on . Then we can get a of it the same way as above.\n\nWhile , and other are “binary data”, a Blob represents “binary data with type”.\n\nMethods that perform web-requests, such as XMLHttpRequest, fetch and so on, can work with natively, as well as with other binary types.\n• We can get back from a Blob using , and then create a view over it for low-level binary processing."
    }
]