[
    {
        "link": "https://airsdk.dev/reference/actionscript/3.0/flash/utils/Timer.html",
        "document": "The Timer class is the interface to timers, which let you run code on a specified time sequence. Use the method to start a timer. Add an event listener for the event to set up code to be run on the timer interval. The Timer class is the interface to timers, which let you run code on a specified time sequence. Use themethod to start a timer. Add an event listener for theevent to set up code to be run on the timer interval. You can create Timer objects to run once or repeat at specified intervals to execute code on a schedule. Depending on the SWF file's framerate or the runtime environment (available memory and other factors), the runtime may dispatch events at slightly offset intervals. For example, if a SWF file is set to play at 10 frames per second (fps), which is 100 millisecond intervals, but your timer is set to fire an event at 80 milliseconds, the event will be dispatched close to the 100 millisecond interval. Applications may dispatch events at slightly offset intervals based on the internal frame rate of the application. Memory-intensive scripts may also offset the events. \n\n\n\n[read-only] The total number of times the timer has fired since it started at zero. If the timer has been reset, only the fires since the reset are counted. \n\n \n\n [read-write] The delay, in milliseconds, between timer events. If you set the delay interval while the timer is running, the timer will restart at the same iteration. Note: A lower than 20 milliseconds is not recommended. Timer frequency is limited to 60 frames per second, meaning a delay lower than 16.6 milliseconds causes runtime problems. \n\n \n\n \n\n \n\n \n\n — Throws an exception if the delay specified is negative or not a finite number. [read-write] The total number of times the timer is set to run. If the repeat count is set to 0, the timer continues indefinitely, up to a maximum of 24.86 days, or until the method is invoked or the program stops. If the repeat count is nonzero, the timer runs the specified number of times. If is set to a total that is the same or less then the timer stops and will not fire again. \n\n \n\n \n\n [read-only] The timer's current state; if the timer is running, otherwise . \n\n \n\n Constructs a new Timer object with the specified and states. The timer does not start automatically; you must call the method to start it. — The delay between timer events, in milliseconds. A lower than 20 milliseconds is not recommended. Timer frequency is limited to 60 frames per second, meaning a delay lower than 16.6 milliseconds causes runtime problems. (default = ) — Specifies the number of repetitions. If zero, the timer repeats indefinitely, up to a maximum of 24.86 days (int.MAX_VALUE + 1). If nonzero, the timer runs the specified number of times and then stops. \n\n — if the delay specified is negative or not a finite number \n\n \n\nIn the following example, the user is given 90 seconds to enter a response in an input text field. Also, every 30 seconds, a status message lets the user know how many seconds are left. In the following example, the user is given 90 seconds to enter a response in an input text field. Also, every 30 seconds, a status message lets the user know how many seconds are left. A Timer object is created that starts in 30 seconds (delay is set to 30000 milliseconds) and repeats three times, for a total of 90 seconds. (The timer stops after the third time.) Two event listeners are added for the timer. The first is triggered by the event, which occurs every time the timer is started. The method changes the text for the text field to reflect the seconds remaining. Note: The Timer class keeps track of the number of times it has to start ( ) by increasing the number in the property.) After the timer is called for the last time, the event is dispatched and the method is called. The method changes the type of the text field from to , which means the user can no longer enter or change text. package { import flash.display.Sprite; import flash.text.TextField; import flash.text.TextFieldType; import flash.text.TextFieldAutoSize; import flash.utils.Timer; import flash.events.TimerEvent; import flash.events.Event; public class Timer_constructorExample extends Sprite { private var statusTextField:TextField = new TextField(); private var inputTextField:TextField = new TextField(); private var delay:uint = 30000; private var repeat:uint = 3; private var myTimer:Timer = new Timer(delay, repeat); public function Timer_constructorExample() { inputTextField.x = 10; inputTextField.y = 10; inputTextField.border = true; inputTextField.background = true; inputTextField.height = 200; inputTextField.width = 200; inputTextField.multiline = true; inputTextField.wordWrap = true; inputTextField.type = TextFieldType.INPUT; statusTextField.x = 10; statusTextField.y = 220; statusTextField.background = true; statusTextField.autoSize = TextFieldAutoSize.LEFT; myTimer.start(); statusTextField.text = \"You have \" + ((delay * repeat) / 1000) + \" seconds to enter your response.\"; myTimer.addEventListener(TimerEvent.TIMER, timerHandler); myTimer.addEventListener(TimerEvent.TIMER_COMPLETE, completeHandler); addChild(inputTextField); addChild(statusTextField); } private function timerHandler(e:TimerEvent):void{ repeat--; statusTextField.text = ((delay * repeat) / 1000) + \" seconds left.\"; } private function completeHandler(e:TimerEvent):void { statusTextField.text = \"Times Up.\"; inputTextField.type = TextFieldType.DYNAMIC; } } } Stops the timer, if it is running, and sets the property back to 0, like the reset button of a stopwatch. Then, when is called, the timer instance runs for the specified number of repetitions, as set by the value. Starts the timer, if it is not already running. Stops the timer. When is called after , the timer instance runs for the remaining number of repetitions, as set by the property. \n\n \n\n Dispatched whenever a Timer object reaches an interval specified according to the property. Defines the value of the property of a event object. This event has the following properties: ; there is no default behavior to cancel. The object that is actively processing the Event object with an event listener. The Timer object that has reached its interval. \n\n \n\n Dispatched whenever it has completed the number of requests set by . Defines the value of the property of a event object. This event has the following properties: ; there is no default behavior to cancel. The object that is actively processing the Event object with an event listener. The Timer object that has completed its requests. to show how a listener method can be set to listen for a new TimerEvent to be dispatched. The timer is started when is called, and after that point, the timer events are dispatched. The following example uses the classto show how a listener methodcan be set to listen for a new TimerEvent to be dispatched. The timer is started whenis called, and after that point, the timer events are dispatched."
    },
    {
        "link": "https://stackoverflow.com/questions/5955044/how-to-make-a-timer-accurate-flash-actionscript-3-0",
        "document": "I'm using the following method to dispatch a sound in X times/minute (X is determined through bpm, which is a NumericStepper object)\n\nAccording to this http://www.metronomeonline.com/ the sound is not sitting well. Is there something I can do to fix this problem I'm stuck in?\n\nPath to the output file I'm getting: http://conatur.net/metroBig.swf"
    },
    {
        "link": "https://airsdk.dev/reference/actionscript/3.0",
        "document": "This document is designed to be viewed using the frames feature. If you see this message, you are using a non-frame-capable web client. \n\n Link to Non-frame version."
    },
    {
        "link": "https://stackoverflow.com/questions/15666700/setting-up-a-timer-in-flash-as3",
        "document": "So you want a timer that ticks every 15 seconds for 60 seconds. That means it will have to tick 4 times ( ). Let's call it ; You have to instantiate it something like that:\n\nThen you need to add two different event listeners. One that will be called every time your timer ticks, and one that will be called when it stops.\n\nIn the first event handler you increment the value of . For that to be possible you need to change it from a constant to a variable.\n\nIn the second handler, you put your code to go to another page.\n\nThere is several points that ought to be mentioned:\n\nWhen you declare a variable, you should specify a scope (i.e. private, public, etc.) the same way you do for your functions:\n\nWhen you declare a function, you should specify a return value, except for the constructor of your class. If the function returns nothing, you can use void:\n\nNaming is important, especially to understand your code when you'll read it later. If you use a it is better to name it something like rather than .\n\nThis is the same for function names: creates a new and starts it, so I would name it .\n\nWhen you create a new timer like this:\n\nYou specify a repeat count of 1. That means that your timer will stop after the delay is met. Because you want it to run over and over again, your should instead specify a repeatCount of (infinite). To keep the functionnality that your timer tick at random interval, you'll then need to set a new delai value in your event handler\n\nand are never modified, so you should extract them in constants:\n\nWith all these changes, it should now be easier to understand what your code is doing. Here is the updated code:\n\nIf there is still some part that you do not understand, please feel free to mention them in comment"
    },
    {
        "link": "https://emanueleferonato.com/2008/11/18/understanding-as3-timer-class",
        "document": "A lot of time ago I wrote about AS2 time management in Flash simple timer/countdown. Now it’s time to see how to manage time with AS3.\n\nAS3 has its own class to manage time, the class. You can read some documentation about this class in the official AS3 page, but in this test drive I am going to create two different timers… one using time intervals and one checking for elapsed time at every frame.\n\nYou will find some differences.\n\nLine 5: I need class to use function. returns the number of milliseconds since the movie started.\n\nLines 9-10: and are two dynamic text fields that will contain the number of seconds elapsed with both methods. Since I am using dynamic text fields, I had to include the TextField class at line 7.\n\nLine 15: This is the core of the time based method. When I use , I dispatch an event every milliseconds for times. If is omitted, I dispatch an event every milliseconds forever. In this case, I am dispatching the event every second, forever.\n\nLine 16: This is the listener for the timer event that points to the function.\n\nLine 17: This is a simple listener for a new frame pointing on function\n\nLine 21: Updating the dynamic text field with , that stores the number of times the target has been triggered (in this case the number of seconds).\n\nLine 25: In this case I simply get the time passed with and display it on screen.\n\nHere it is:\n\nAt a first glance both methods work, but if you let them run for a while, you will notice they will differ more and more.\n\nLook at this picture:\n\nIf you let timers run a lot, the difference is quite big.\n\nWhat kind of timer would you use?"
    },
    {
        "link": "https://airsdk.dev/reference/actionscript/3.0/flash/display/BitmapData.html",
        "document": "Calls to any method or property of a BitmapData object throw an ArgumentError error if the BitmapData object is invalid (for example, if it has height == 0 and width == 0 ) or it has been disposed of via dispose().\n\nStarting with AIR 3 and Flash player 11, the size limits for a BitmapData object have been removed. The maximum size of a bitmap is now dependent on the operating system.\n\nIn AIR 1.5 and Flash Player 10, the maximum size for a BitmapData object is 8,191 pixels in width or height, and the total number of pixels cannot exceed 16,777,215 pixels. (So, if a BitmapData object is 8,191 pixels wide, it can only be 2,048 pixels high.) In Flash Player 9 and earlier and AIR 1.1 and earlier, the limitation is 2,880 pixels in height and 2,880 in width.\n\nIn the AIR runtime, the DockIcon, Icon, InteractiveIcon, and SystemTrayIcon classes each include a bitmaps property that is an array of BitmapData objects that define the bitmap images for an icon.\n\nYou can use a BitmapData object to fill a Graphics object by using the Graphics.beginBitmapFill() method.\n\nYou can attach BitmapData objects to a Bitmap object by using the bitmapData property of the Bitmap object.\n\nThe four channels (alpha, red, green, and blue) are represented as numbers when you use them with the BitmapData.copyChannel() method or the DisplacementMapFilter.componentX and DisplacementMapFilter.componentY properties, and these numbers are represented by the following constants in the BitmapDataChannel class:\n\nEach 32-bit integer is a combination of four 8-bit channel values (from 0 to 255) that describe the alpha transparency and the red, green, and blue (ARGB) values of the pixel. (For ARGB values, the most significant byte represents the alpha channel value, followed by red, green, and blue.)\n\nA BitmapData object contains an array of pixel data. This data can represent either a fully opaque bitmap or a transparent bitmap that contains alpha channel data. Either type of BitmapData object is stored as a buffer of 32-bit integers. Each 32-bit integer determines the properties of a single pixel in the bitmap.\n\nThe methods of the BitmapData class support effects that are not available through the filters available to non-bitmap display objects.\n\nThis class lets you separate bitmap rendering operations from the internal display updating routines of Flash Player. By manipulating a BitmapData object directly, you can create complex images without incurring the per-frame overhead of constantly redrawing the content from vector data.\n\nThe BitmapData class lets you work with the data (pixels) of a. You can use the methods of the BitmapData class to create arbitrarily sized transparent or opaque bitmap images and manipulate them in various ways at runtime.\n\nYou can also access the BitmapData for a bitmap image that you load with the flash.display.Loader class.\n\n[read-only] The rectangle that defines the size and location of the bitmap image.\n\nUnlocks an image so that any objects that reference the BitmapData object, such as Bitmap objects, are updated when this BitmapData object changes.\n\nTests pixel values in an image against a specified threshold and sets pixels that pass the test to new color values.\n\nIndicates whether the specified property exists and is enumerable.\n\nPerforms a pixel dissolve either from a source image to a destination image or by using the same image.\n\nRemaps the color channel values in an image that has up to four arrays of color palette data, one for each channel.\n\nLocks an image so that any objects that reference the BitmapData object, such as Bitmap objects, are not updated when this BitmapData object changes.\n\nIndicates whether an instance of the Object class is in the prototype chain of the object specified as the parameter.\n\nReturns an integer that represents an RGB pixel value from a BitmapData object at a specific point (x, y).\n\nDetermines a rectangular region that either fully encloses all pixels of a specified color within the bitmap image (if the findColor parameter is set to true ) or fully encloses all pixels that do not include the specified color (if the findColor parameter is set to false ).\n\nPerforms a flood fill operation on an image starting at an (x, y) coordinate and filling with a certain color.\n\nProvides a fast routine to perform pixel manipulation between images with no stretching, rotation, or color effects.\n\nTransfers data from one channel of another BitmapData object or the current BitmapData object into a channel of the current BitmapData object.\n\nAdjusts the color values in a specified area of a bitmap image by using a ColorTransform object.\n\nReturns a new BitmapData object that is a clone of the original instance with an exact copy of the contained bitmap.\n\nDraws the display object onto the bitmap image, using the Flash runtime vector renderer. You can specify , , , and a destination parameter to control how the rendering performs. Optionally, you can specify whether the bitmap should be smoothed when scaled (this works only if the source object is a BitmapData object). Note: The method works exactly like the method, but instead of using the property to determine the quality of vector rendering, you specify the parameter to the method. This method directly corresponds to how objects are drawn with the standard vector renderer for objects in the authoring tool interface. The source display object does not use any of its applied transformations for this call. It is treated as it exists in the library or file, with no matrix transform, no color transform, and no blend mode. To draw a display object (such as a movie clip) by using its own transform properties, you can copy its property object to the property of the Bitmap object that uses the BitmapData object. This method is supported over RTMP in Flash Player 9.0.115.0 and later and in Adobe AIR. You can control access to streams on Flash Media Server in a server-side script. For more information, see the and properties in Server-Side ActionScript Language Reference for Adobe Flash Media Server. If the source object and (in the case of a Sprite or MovieClip object) all of its child objects do not come from the same domain as the caller, or are not in a content that is accessible to the caller by having called the method, a call to the throws a SecurityError exception. This restriction does not apply to AIR content in the application security sandbox. There are also restrictions on using a loaded bitmap image as the . A call to the method is successful if the loaded image comes from the same domain as the caller. Also, a cross-domain policy file on the image's server can grant permission to the domain of the SWF content calling the method. In this case, you must set the property of a LoaderContext object, and use this object as the parameter when calling the method of the Loader object used to load the image. These restrictions do not apply to AIR content in the application security sandbox. On Windows, the method cannot capture SWF content embedded in an HTML page in an HTMLLoader object in Adobe AIR. The method cannot capture PDF content in Adobe AIR. Nor can it capture or SWF content embedded in HTML in which the attribute is set to in Adobe AIR. — The display object or BitmapData object to draw to the BitmapData object. (The DisplayObject and BitmapData classes implement the IBitmapDrawable interface.) (default = ) — A Matrix object used to scale, rotate, or translate the coordinates of the bitmap. If you do not want to apply a matrix transformation to the image, set this parameter to an identity matrix, created with the default constructor, or pass a value. (default = ) — A ColorTransform object that you use to adjust the color values of the bitmap. If no object is supplied, the bitmap image's colors are not transformed. If you must pass this parameter but you do not want to transform the image, set this parameter to a ColorTransform object created with the default constructor. (default = ) — A string value, from the flash.display.BlendMode class, specifying the blend mode to be applied to the resulting bitmap. (default = ) — A Rectangle object that defines the area of the source object to draw. If you do not supply this value, no clipping occurs and the entire source object is drawn. (default = ) — A Boolean value that determines whether a BitmapData object is smoothed when scaled or rotated, due to a scaling or rotation in the parameter. The parameter only applies if the parameter is a BitmapData object. With set to , the rotated or scaled BitmapData image can appear pixelated or jagged. For example, the following two images use the same BitmapData object for the parameter, but the parameter is set to on the left and on the right: Drawing a bitmap with set to takes longer than doing so with set to . \n\n — The parameter is not a BitmapData or DisplayObject object. — The object and (in the case of a Sprite or MovieClip object) all of its child objects do not come from the same domain as the caller, or are not in a content that is accessible to the caller by having called the method. This restriction does not apply to AIR content in the application security sandbox. — The source is null or not a valid IBitmapDrawable object. \n\n \n\nThe following example shows how to draw a TextField object to a BitmapData object: import flash.display.Bitmap; import flash.display.BitmapData; import flash.text.TextField; var tf:TextField = new TextField(); tf.text = \"bitmap text\"; var myBitmapData:BitmapData = new BitmapData(80, 20); myBitmapData.draw(tf); var bmp:Bitmap = new Bitmap(myBitmapData); this.addChild(bmp); The following example shows how to draw a TextField object to a BitmapData object:\n\nDraws the display object onto the bitmap image, using the Flash runtime vector renderer. You can specify , , , and a destination parameter to control how the rendering performs. Optionally, you can specify whether the bitmap should be smoothed when scaled (this works only if the source object is a BitmapData object). Note: The method works exactly like the method, but instead of using the property to determine the quality of vector rendering, you specify the parameter to the method. This method directly corresponds to how objects are drawn with the standard vector renderer for objects in the authoring tool interface. The source display object does not use any of its applied transformations for this call. It is treated as it exists in the library or file, with no matrix transform, no color transform, and no blend mode. To draw a display object (such as a movie clip) by using its own transform properties, you can copy its property object to the property of the Bitmap object that uses the BitmapData object. This method is supported over RTMP in Flash Player 9.0.115.0 and later and in Adobe AIR. You can control access to streams on Flash Media Server in a server-side script. For more information, see the and properties in Server-Side ActionScript Language Reference for Adobe Flash Media Server. If the source object and (in the case of a Sprite or MovieClip object) all of its child objects do not come from the same domain as the caller, or are not in a content that is accessible to the caller by having called the method, a call to the throws a SecurityError exception. This restriction does not apply to AIR content in the application security sandbox. There are also restrictions on using a loaded bitmap image as the . A call to the method is successful if the loaded image comes from the same domain as the caller. Also, a cross-domain policy file on the image's server can grant permission to the domain of the SWF content calling the method. In this case, you must set the property of a LoaderContext object, and use this object as the parameter when calling the method of the Loader object used to load the image. These restrictions do not apply to AIR content in the application security sandbox. On Windows, the method cannot capture SWF content embedded in an HTML page in an HTMLLoader object in Adobe AIR. The method cannot capture PDF content in Adobe AIR. Nor can it capture or SWF content embedded in HTML in which the attribute is set to in Adobe AIR. — The display object or BitmapData object to draw to the BitmapData object. (The DisplayObject and BitmapData classes implement the IBitmapDrawable interface.) (default = ) — A Matrix object used to scale, rotate, or translate the coordinates of the bitmap. If you do not want to apply a matrix transformation to the image, set this parameter to an identity matrix, created with the default constructor, or pass a value. (default = ) — A ColorTransform object that you use to adjust the color values of the bitmap. If no object is supplied, the bitmap image's colors are not transformed. If you must pass this parameter but you do not want to transform the image, set this parameter to a ColorTransform object created with the default constructor. (default = ) — A string value, from the flash.display.BlendMode class, specifying the blend mode to be applied to the resulting bitmap. (default = ) — A Rectangle object that defines the area of the source object to draw. If you do not supply this value, no clipping occurs and the entire source object is drawn. (default = ) — A Boolean value that determines whether a BitmapData object is smoothed when scaled or rotated, due to a scaling or rotation in the parameter. The parameter only applies if the parameter is a BitmapData object. With set to , the rotated or scaled BitmapData image can appear pixelated or jagged. For example, the following two images use the same BitmapData object for the parameter, but the parameter is set to on the left and on the right: Drawing a bitmap with set to takes longer than doing so with set to . (default = ) — Any of one of the StageQuality values. Selects the antialiasing quality to be used when drawing vectors graphics. \n\n — The parameter is not a BitmapData or DisplayObject object. — The object and (in the case of a Sprite or MovieClip object) all of its child objects do not come from the same domain as the caller, or are not in a content that is accessible to the caller by having called the method. This restriction does not apply to AIR content in the application security sandbox. — The source is null or not a valid IBitmapDrawable object. \n\n \n\nThe following example shows how to draw a TextField object to a BitmapData object: import flash.display.Bitmap; import flash.display.BitmapData; import flash.text.TextField; var tf:TextField = new TextField(); tf.text = \"bitmap text\"; var myBitmapData:BitmapData = new BitmapData(80, 20); myBitmapData.drawWithQuality(tf, , , , , , StageQuality.LOW); var bmp:Bitmap = new Bitmap(myBitmapData); this.addChild(bmp); The following example shows how to draw a TextField object to a BitmapData object:"
    },
    {
        "link": "https://dougmccune.com/blog/2008/09/13/using-bitmapdata-for-array-manipulation-in-as3",
        "document": "Recently I was thinking about how to do some complex Array manipulation, and how to do it fast. I needed to take a large source Array and filter it two different ways, producing two new filtered arrays, each of which is made up of a subset of the values in the source array. Then I wanted to know which values of the first filtered array were unique to that array (did not appear in filtered array #2) and vice versa. I came up with a technique that uses the bitmap manipulation of the Flash player to accomplish these goals.\n\nAn example of the problem:\n\n Let’s say I have a source array that looks like this:\n\nThen I filter that array to produce a new array, Filtered Array #1, that contains some but not all of the items. I do the same thing again, except this time using a different filter that produces Filtered Array #2. Now my data looks like this:\n\nI want to know the unique values in Filtered Array #1 that do not appear in #2 (Item 5) and the unique values in Filtered Array #2 that do not appear in #1 (Item 1, Item 4). An added bonus would be some extra stuff like being able to know the union of both arrays (items that appear in either array 1 or 2) or the intersection (items that only appear in both filtered arrays).\n\nThe slow-ass way\n\n So the first thing that comes to mind when trying to solve this is that you can simply do a for loop over the source array and check if each item appears in Filtered Array #1 and Filtered Array #2. This means you have one full loop over every item in the data set, and then you need to do a check for whether the item exists in each of the filtered arrays. The most basic way would be something like this:\n\nSo that's the easiest way and it certainly works. I'm sure there are countless ways to do this in a more optimized way, like not looping over the source array but instead looping over the first filtered array, somehow marking all the items in the second filtered array if they were found in the first filtered array, then looping over the remaining items in the second filtered array. I'm sure someone will tell me that I should use a binary tree search since I know the source index, or that I should use a hashtable to lookup the existence of items faster. I bet all those different approaches would beat this simple example speed-wise, but I was still worried no matter how optimized an approach like this can get, it would still suck. (Side note: If you have an alternative approach that will handle many items with really fast performance, especially if you have an AS3 implementation, I'd love to hear about it.) So anyway, I decided I wanted to try something different.\n\nUsing bitmaps\n\n Check this out. Say you have a source array of 10,000 items. Then you filter that down to a filtered array that might have a subset of about 4,000 of those items. The relationship of the items in the filtered array to the source array can be drawn using a bitmap like this:\n\n\n\nThis image is a 100 pixel by 100 pixel square, and each pixel within that square represents whether or not the item in the source array appears in the filtered array. So if the pixel at 0,0 is black that means that the first item in the source array is also in the filtered array. If a pixel is red, that means that that item does not appear in the filtered array.\n\nWhy did I choose to make a square image? I originally just did a single line 1px high. But Flash has a bitmap limitation of a max width or height of 2,880 pixels. So a single line means that you would be limited to arrays with only 2,880 items, and that's not the kind of problem I was trying to solve. The performance need arose from having to do this with a shitload of items. So if we use a square instead (easy to calculate the dimensions, just take the square root of the # of items), then we have a theoretical maximum number of items of 2,880 x 2,880 = about 8.3 million. I'm not going to try to filter more than 8 million items client-side, so I'm ok with that limitation.\n\nOK, cool. Now we do the same thing for the second filtered array. Below is the generated image of both filtered arrays side by side. The red image represents Filtered Array #1 and the green represents Filtered Array #2:\n\n\n\nBut how do you create these images in an optimized way? Since the arrays are already being filtered, that means I'm using Array.filter() with a callback function to decide whether or not the item passes the filter test. This filter function is going to be run on every item in the array. So I use that function to also do my bitmap drawing. And check this out, the callback for a filterFunction tells you the index of the item in the array! So that gives you all the information you need to draw these images. You know that the function will get called one time for each item, and it tells you the index. So just do a simple BitmapData.setPixelAt() and once your filtering is complete your image has been generated. Dope.\n\nSo now we start with the real bitmap magic. We're going to use the compare() method of the BitmapData class to generate a third image that represents a pixel by pixel comparison of these two images. To use the compare() method you call it on one BitmapData and pass in a second BitmapData. The function will return a new BitmapData object that contains pixel comparisons. If the pixel in bitmap 1 is the same as the pixel in bitmap 2 then the new comparison bitmap will have a transparent pixel (0x00000000). If they are not the same, then it will return the \"difference pixel\", which contains the difference between each channel (RGB). So what happens when we run compare() on these two images? We get a new image something like this:\n\n\n\nThere are only a few possible pixel values now, and each unique pixel value tells us something special. So by looping over the pixels we can know whether the item occurs in both arrays, one array or the other, or neither array. And just like that, we got our answer.\n\nTry out the demo application I created here. And you can view the full source here. Be forgiving, the source code is dirty as hell... no comments, no nothin'... I basically just cranked this out and decided to put it out there without taking the time to clean it up because a) I think it's a pretty cool approach and b) it's dinner time and I'm hungry.\n\nPerformance\n\n So what about some benchmarks? I've put together a little demo app that you can play with to try out this method. It lets you run two algorithms, one that is a very simple for loop that loops over each item and calls array1.indexOf(item) and array2.indexOf(item) to see if the item is present in both filtered arrays. Then you can also run the bitmap test that I've described. Here are the results that I had on my machine when running both techniques on various numbers of items:\n\nThese aren't meant to be scientific results. There are some pretty big factors that might influence speed. For the tests I have a filter function that just chooses at random (with 50% probability) which items to include in the two filtered arrays. If you change the number of items in either array the speeds will fluctuate. But the basic idea is that doing a for loop and checking for an item using indexOf fails miserably when you start getting over the tens of thousands of items. The bitmap method works even on a million records, albeit slowly at 3-4 seconds, but at least it works without timing out or crashing the browser.\n\nAnd like I said before, I'm sure there are other algorithms that would be faster than looping over every item in the full array and checking using indexOf. If you have some implementations that solve the same problem but with better performance, please let me know in the comments.\n\nSo what?\n\n I don't really know if I'm going to actually use this technique anywhere, but I might. I'm also thinking about performing other calculations on large datasets using similar methods. Essentially if you have two or more datasets, you can use this graphical technique to perform all kinda of other calculations. I'm only using the compare() function to test for a few very distinct possibilities, but you could imagine doing something much more detailed, like performing calculations based on the aggregate color difference of multiple array images. The bitmap manipulation in Flash is so damn fast, that it opens a whole new door if you try to think about using those methods for number crunching and not just pretty graphics.\n\nP.S. I know it's been a long time since I did a blog post with code. I think this one geeks out to a pretty extreme level, so for anyone reading who was getting fed up with my non-technical ramblings, I hope this makes up for it."
    },
    {
        "link": "https://stackoverflow.com/questions/24667070/as3-drawing-using-bitmapdata",
        "document": "I am extremely new to actionscript (or any code for that matter) and am having some trouble undertsanding why my code wont work. I am trying to create a small drawing application using BitmapData - there are no errors when I run the code but it doesn't do anything at all.\n\nHopefully this isn't too silly of a question - but if someone can guide me through why this wouldn't work or give me a working example (would be even better) I would be very grateful"
    },
    {
        "link": "https://airsdk.dev/reference/actionscript/3.0/flash/display/Bitmap.html",
        "document": "The Bitmap class represents display objects that represent bitmap images. These can be images that you load with the flash.display.Loader class, or they can be images that you create with the constructor. The Bitmap class represents display objects that represent bitmap images. These can be images that you load with the flash.display.Loader class, or they can be images that you create with theconstructor. The constructor allows you to create a Bitmap object that contains a reference to a BitmapData object. After you create a Bitmap object, use the or method of the parent DisplayObjectContainer instance to place the bitmap on the display list. A Bitmap object can share its BitmapData reference among several Bitmap objects, independent of translation or rotation properties. Because you can create multiple Bitmap objects that reference the same BitmapData object, multiple display objects can use the same complex BitmapData object without incurring the memory overhead of a BitmapData object for each display object instance. A BitmapData object can be drawn to the screen by a Bitmap object in one of two ways: by using the vector renderer as a fill-bitmap shape, or by using a faster pixel-copying routine. The pixel-copying routine is substantially faster than the vector renderer, but the Bitmap object must meet certain conditions to use it:\n• No stretching, rotation, or skewing can be applied to the Bitmap object.\n• No color transform can be applied to the Bitmap object.\n• No blend mode can be applied to the Bitmap object.\n• No clipping can be done through mask layers or methods.\n• The image itself cannot be a mask.\n• The destination coordinates must be on a whole pixel boundary. If you load a Bitmap object from a domain other than that of the Loader object used to load the image, and there is no URL policy file that permits access to the domain of the Loader object, then a script in that domain cannot access the Bitmap object or its properties and methods. For more information, see the Flash Player Developer Center Topic: Security. Note: The Bitmap class is not a subclass of the InteractiveObject class, so it cannot dispatch mouse events. However, you can use the method of the display object container that contains the Bitmap object. \n\n\n\n[read-write] Controls whether or not the Bitmap object is snapped to the nearest pixel. The PixelSnapping class includes possible values:\n• —The image is always snapped to the nearest pixel, independent of transformation.\n• —The image is snapped to the nearest pixel if it is drawn with no rotation or skew and it is drawn at a scale factor of 99.9% to 100.1%. If these conditions are satisfied, the bitmap image is drawn at 100% scale, snapped to the nearest pixel. Internally, this value allows the image to be drawn as fast as possible using the vector renderer. \n\n \n\n \n\n [read-write] Controls whether or not the bitmap is smoothed when scaled. If , the bitmap is smoothed when scaled. If , the bitmap is not smoothed when scaled. \n\n \n\n \n\n Initializes a Bitmap object to refer to the specified BitmapData object. (default = \" \") — Whether or not the Bitmap object is snapped to the nearest pixel. (default = ) — Whether or not the bitmap is smoothed when scaled. For example, the following examples show the same bitmap scaled by a factor of 3, with set to (left) and (right): \n\n \n\nThe following example shows how you can dynamically load an image at runtime using the ActionScript 3.0 Loader class and then copy the image's pixels into four separate Bitmap object instances on the display list by using the Loader instance's content property and bitmapData properties. Example provided by const IMAGE_URL:String = \"http://www.helpexamples.com/flash/images/logo.png\"; var ldr:Loader = new Loader(); ldr.contentLoaderInfo.addEventListener(Event.COMPLETE, ldr_complete); ldr.load(new URLRequest(IMAGE_URL)); var bitmap1:Bitmap; var bitmap2:Bitmap; var bitmap3:Bitmap; var bitmap4:Bitmap; function ldr_complete(evt:Event):void { var bmp:Bitmap = ldr.content as Bitmap; bitmap1 = new Bitmap(bmp.bitmapData); bitmap1.x = 100; bitmap1.y = 100; bitmap1.rotation = 0; addChild(bitmap1); bitmap2 = new Bitmap(bmp.bitmapData); bitmap2.x = 200; bitmap2.y = 100; bitmap2.rotation = 90; addChild(bitmap2); bitmap3 = new Bitmap(bmp.bitmapData); bitmap3.x = 300; bitmap3.y = 100; bitmap3.rotation = 180; addChild(bitmap3); bitmap4 = new Bitmap(bmp.bitmapData); bitmap4.x = 400; bitmap4.y = 100; bitmap4.rotation = 270; addChild(bitmap4); } The following example shows how you can dynamically load an image at runtime using the ActionScript 3.0 Loader class and then copy the image's pixels into four separate Bitmap object instances on the display list by using the Loader instance's content property and bitmapData properties. Example provided by ActionScriptExamples.com method. This task is accomplished using the following steps:\n• A property is created, which is the location and name of the image file\n• The class constructor calls the method, which, in turn, calls the method.\n• creates a Loader object, which then instantiates an event listener, which is dispatched when completes the image manipulation.\n• Next, the method creates a new instance of a URLRequest object, , with passed so the file name and location are known.\n• The object is passed to the method, which loads the image into memory via a display object.\n• The image is then placed on the display list, which promptly displays the image on screen at coordinates x = 0, y = 0.\n• The method then performs the following tasks:\n• Creates a second Loader object, along with a Bitmap object, which is initialized with the Loader object.\n• Creates a second Bitmap object, , which in turn calls the method, which creates a duplicate of the original image.\n• Creates a BitmapData object, which is assigned to the object's BitmapData object.\n• Creates a new Rectangle object initialized with the same coordinates, width, and height as the original image.\n• Creates a new Point object, which defaults to x = 0, y = 0.\n• Creates the following variables:\n• : applies the new color when the threshold value is >= the original.\n• : the value against which each pixel is compared is set to light gray with an alpha of 0xCC.\n• : the color that the pixels will be set to that pass the threshold test, which is solid yellow in this case.\n• : set to the exact opposite of color, (transparent blue).\n• : set to false, indicating that the pixel values are not copied in the event the threshold value does not pass. This value has no meaning because the image is duplicated and only pixels that pass the threshold test are changed.\n• Calls the method by using the preceding variables. The resulting threshold equation is as follows: if (current pixel Value & 0x000000FF) >= (0xCCCCCCCC & 0x000000FF) then set pixel to 0xFFFFFF00 . The following example uses the BitmapExample class to load the \"Image.gif\" image into a DisplayObject in the default location (x = 0, y = 0). A copy of Image.gif is then placed to the right of the original, which has new colors applied to pixels that pass a test using themethod. This task is accomplished using the following steps:\n• You will need to compile the SWF file with \"Local playback security\" set to \"Access local files only\".\n• This example requires that a file named Image.gif be placed in the same directory as your SWF file.\n• It is recommended that you use an image up to 80 pixels wide. package { import flash.display.Bitmap; import flash.display.BitmapData; import flash.display.Loader; import flash.display.Sprite; import flash.events.*; import flash.geom.Point; import flash.geom.Rectangle; import flash.net.URLRequest; public class BitmapExample extends Sprite { private var url:String = \"Image.gif\"; private var size:uint = 80; public function BitmapExample() { configureAssets(); } private function configureAssets():void { var loader:Loader = new Loader(); loader.contentLoaderInfo.addEventListener(Event.COMPLETE, completeHandler); loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler); var request:URLRequest = new URLRequest(url); loader.x = size * numChildren; loader.load(request); addChild(loader); } private function duplicateImage(original:Bitmap):Bitmap { var image:Bitmap = new Bitmap(original.bitmapData.clone()); image.x = size * numChildren; addChild(image); return image; } private function completeHandler(event:Event):void { var loader:Loader = Loader(event.target.loader); var image:Bitmap = Bitmap(loader.content); var duplicate:Bitmap = duplicateImage(image); var bitmapData:BitmapData = duplicate.bitmapData; var sourceRect:Rectangle = new Rectangle(0, 0, bitmapData.width, bitmapData.height); var destPoint:Point = new Point(); var operation:String = \">=\"; var threshold:uint = 0xCCCCCCCC; var color:uint = 0xFFFFFF00; var mask:uint = 0x000000FF; var copySource:Boolean = true; bitmapData.threshold(bitmapData, sourceRect, destPoint, operation, threshold, color, mask, copySource); } private function ioErrorHandler(event:IOErrorEvent):void { trace(\"Unable to load image: \" + url); } } }"
    },
    {
        "link": "https://peachpit.com/articles/article.aspx?p=100577&seqNum=337",
        "document": "The Flash bitmapData class is a tool you can use to construct dynamic bitmap images at processor runtime. What does this mean? You can create complex vector images that can be treated in the same way as bitmap images. To help you with your development, Macromedia has included a broad swath of methods that can be applied to a bitmapData object.\n\nThe bitmapData class is constructed of methods and properties you can control. The following is a complete list of all the methods:\n\nThe following is a list of properties:\n\nAs you can see, the bitmapData class is very broad. In this section of the guide, you'll learn how to create a bitmapData object together with a selection of some of the methods used to manipulate the object.\n\nLet's get started. The following ActionScript allows you to build a simple bitmapData drawing. Note that you need to import the flash.display.BitmapData class. The class provides ActionScript with extra definition that allows you to construct the image.\n\nFollowing the import statement is the new bitmapData object. The new object defines a region's width, height, transparency, and color.\n\nFor this example, a dynamic movie clip is created that's bound to the new bitmapData object.\n\nThe final result is a simple, red square. The region of the square is created from the myBitmapData object. The constructor defines the width, height, transparency, and color.\n\nThe following ActionScript demonstrates how different filter effects can be applied to a bitmapData object. In this example, you can swap out different filter effects for either bevel, drop shadow, or blur.\n\nWhen you use the ApplyFilter method, you must import the filters you want to use. Here, I have imported three filters:\n\nThe following script creates the bitmapData object and an empty movie clip to which you can apply the bitmapData object:\n\nNow, you need to create instances for each filter together with the settings for each filter. The following script sets up a bevel, blur, and drop shadow filter.\n\nThe method you need to focus on is the ApplyFilter method. Here, you can bind a filter by variable name. In this instance, the variable \"filter\" can be applied to add a bevel effect. You can swap this out with \"filter2\" and \"filter3\" to apply a blur and drop shadow effect.\n\nTry swapping the bold variable \"filter\" above for filter2 and filter3 to see the differences.\n\nThe PaletteMap method gives you control over adding color to regions of your bitmap. As with the other exercises, you'll need to import the correct classes and create the bitmapData object as well as the empty movie clips.\n\nNow, you'll want to apply the fillRect method to create a red, rectangle object.\n\nThe PaletteMap is constructed of red, green, blue, and alpha. Here, the red and green values are being applied.\n\nTry modifying the blue and alpha levels to tweak the PaletteMap method.\n\nTo visually apply pixel-based distortion to an object, you need to use the Noise method. In this example, two rectangles will be created to demonstrate both the grayscale and color scale parameters in the Noise method.\n\nThe following function controls the Noise method values for objects bitMapData_1 and bitMapData_2.\n\nNoise is a logical distortion of pixels. For larger shapes, you need to use the PerlinNoise method.\n\nPerlinNoise is similar to Noise. The difference is that you can create shapes to act as the noise instead of just a pixel. The following example is very similar to the Noise method example above. The differences are highlighted below in bold.\n\nWhen you run this example, you'll see that the shapes are created dynamically.\n\nWhen To Use BitMap Data Class\n\nAs you can see, the bitMapData class can be very useful. For example, you can use the PerlinNoise method to create a simple animation that is less processor-intensive than a traditional vector animation."
    }
]