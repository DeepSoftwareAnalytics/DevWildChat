[
    {
        "link": "https://docs.python.org/3/library/functions.html",
        "document": "The Python interpreter has a number of functions and types built into it that are always available. They are listed here in alphabetical order.\n\nOpen file and return a corresponding file object. If the file cannot be opened, an is raised. See Reading and Writing Files for more examples of how to use this function. file is a path-like object giving the pathname (absolute or relative to the current working directory) of the file to be opened or an integer file descriptor of the file to be wrapped. (If a file descriptor is given, it is closed when the returned I/O object is closed unless closefd is set to .) mode is an optional string that specifies the mode in which the file is opened. It defaults to which means open for reading in text mode. Other common values are for writing (truncating the file if it already exists), for exclusive creation, and for appending (which on some Unix systems, means that all writes append to the end of the file regardless of the current seek position). In text mode, if encoding is not specified the encoding used is platform-dependent: is called to get the current locale encoding. (For reading and writing raw bytes use binary mode and leave encoding unspecified.) The available modes are: open for writing, truncating the file first open for exclusive creation, failing if the file already exists open for writing, appending to the end of file if it exists The default mode is (open for reading text, a synonym of ). Modes and open and truncate the file. Modes and open the file with no truncation. As mentioned in the Overview, Python distinguishes between binary and text I/O. Files opened in binary mode (including in the mode argument) return contents as objects without any decoding. In text mode (the default, or when is included in the mode argument), the contents of the file are returned as , the bytes having been first decoded using a platform-dependent encoding or using the specified encoding if given. Python doesn’t depend on the underlying operating system’s notion of text files; all the processing is done by Python itself, and is therefore platform-independent. buffering is an optional integer used to set the buffering policy. Pass 0 to switch buffering off (only allowed in binary mode), 1 to select line buffering (only usable when writing in text mode), and an integer > 1 to indicate the size in bytes of a fixed-size chunk buffer. Note that specifying a buffer size this way applies for binary buffered I/O, but (i.e., files opened with ) would have another buffering. To disable buffering in , consider using the flag for . When no buffering argument is given, the default buffering policy works as follows:\n• None Binary files are buffered in fixed-size chunks; the size of the buffer is chosen using a heuristic trying to determine the underlying device’s “block size” and falling back on . On many systems, the buffer will typically be 4096 or 8192 bytes long.\n• None “Interactive” text files (files for which returns ) use line buffering. Other text files use the policy described above for binary files. encoding is the name of the encoding used to decode or encode the file. This should only be used in text mode. The default encoding is platform dependent (whatever returns), but any text encoding supported by Python can be used. See the module for the list of supported encodings. errors is an optional string that specifies how encoding and decoding errors are to be handled—this cannot be used in binary mode. A variety of standard error handlers are available (listed under Error Handlers), though any error handling name that has been registered with is also valid. The standard names include:\n• None to raise a exception if there is an encoding error. The default value of has the same effect.\n• None ignores errors. Note that ignoring encoding errors can lead to data loss.\n• None causes a replacement marker (such as ) to be inserted where there is malformed data.\n• None will represent any incorrect bytes as low surrogate code units ranging from U+DC80 to U+DCFF. These surrogate code units will then be turned back into the same bytes when the error handler is used when writing data. This is useful for processing files in an unknown encoding.\n• None is only supported when writing to a file. Characters not supported by the encoding are replaced with the appropriate XML character reference .\n• None (also only supported when writing) replaces unsupported characters with escape sequences. newline determines how to parse newline characters from the stream. It can be , , , , and . It works as follows:\n• None When reading input from the stream, if newline is , universal newlines mode is enabled. Lines in the input can end in , , or , and these are translated into before being returned to the caller. If it is , universal newlines mode is enabled, but line endings are returned to the caller untranslated. If it has any of the other legal values, input lines are only terminated by the given string, and the line ending is returned to the caller untranslated.\n• None When writing output to the stream, if newline is , any characters written are translated to the system default line separator, . If newline is or , no translation takes place. If newline is any of the other legal values, any characters written are translated to the given string. If closefd is and a file descriptor rather than a filename was given, the underlying file descriptor will be kept open when the file is closed. If a filename is given closefd must be (the default); otherwise, an error will be raised. A custom opener can be used by passing a callable as opener. The underlying file descriptor for the file object is then obtained by calling opener with (file, flags). opener must return an open file descriptor (passing as opener results in functionality similar to passing ). The following example uses the dir_fd parameter of the function to open a file relative to a given directory: 'This will be written to somedir/spamspam.txt' The type of file object returned by the function depends on the mode. When is used to open a file in a text mode ( , , , , etc.), it returns a subclass of (specifically ). When used to open a file in a binary mode with buffering, the returned class is a subclass of . The exact class varies: in read binary mode, it returns an ; in write binary and append binary modes, it returns an , and in read/write mode, it returns an . When buffering is disabled, the raw stream, a subclass of , , is returned. See also the file handling modules, such as , (where is declared), , , , and . The and arguments may have been modified or inferred from the original call.\n• None used to be raised, it is now an alias of .\n• None is now raised if the file opened in exclusive creation mode ( ) already exists.\n• None The file is now non-inheritable.\n• None If the system call is interrupted and the signal handler does not raise an exception, the function now retries the system call instead of raising an exception (see PEP 475 for the rationale).\n• None On Windows, opening a console buffer may return a subclass of other than . Changed in version 3.11: The mode has been removed.\n\nReturn a proxy object that delegates method calls to a parent or sibling class of type. This is useful for accessing inherited methods that have been overridden in a class. The object_or_type determines the method resolution order to be searched. The search starts from the class right after the type. For example, if of object_or_type is and the value of type is , then searches . The attribute of the class corresponding to object_or_type lists the method resolution search order used by both and . The attribute is dynamic and can change whenever the inheritance hierarchy is updated. If the second argument is omitted, the super object returned is unbound. If the second argument is an object, must be true. If the second argument is a type, must be true (this is useful for classmethods). When called directly within an ordinary method of a class, both arguments may be omitted (“zero-argument ”). In this case, type will be the enclosing class, and obj will be the first argument of the immediately enclosing function (typically ). (This means that zero-argument will not work as expected within nested functions, including generator expressions, which implicitly create nested functions.) There are two typical use cases for super. In a class hierarchy with single inheritance, super can be used to refer to parent classes without naming them explicitly, thus making the code more maintainable. This use closely parallels the use of super in other programming languages. The second use case is to support cooperative multiple inheritance in a dynamic execution environment. This use case is unique to Python and is not found in statically compiled languages or languages that only support single inheritance. This makes it possible to implement “diamond diagrams” where multiple base classes implement the same method. Good design dictates that such implementations have the same calling signature in every case (because the order of calls is determined at runtime, because that order adapts to changes in the class hierarchy, and because that order can include sibling classes that are unknown prior to runtime). For both use cases, a typical superclass call looks like this: # This does the same thing as: In addition to method lookups, also works for attribute lookups. One possible use case for this is calling descriptors in a parent or sibling class. Note that is implemented as part of the binding process for explicit dotted attribute lookups such as . It does so by implementing its own method for searching classes in a predictable order that supports cooperative multiple inheritance. Accordingly, is undefined for implicit lookups using statements or operators such as . Also note that, aside from the zero argument form, is not limited to use inside methods. The two argument form specifies the arguments exactly and makes the appropriate references. The zero argument form only works inside a class definition, as the compiler fills in the necessary details to correctly retrieve the class being defined, as well as accessing the current instance for ordinary methods. For practical suggestions on how to design cooperative classes using , see guide to using super()."
    },
    {
        "link": "https://docs.python.org/3/library/stdtypes.html",
        "document": "The following sections describe the standard types that are built into the interpreter.\n\nThe principal built-in types are numerics, sequences, mappings, classes, instances and exceptions.\n\nSome collection classes are mutable. The methods that add, subtract, or rearrange their members in place, and don’t return a specific item, never return the collection instance itself but .\n\nSome operations are supported by several object types; in particular, practically all objects can be compared for equality, tested for truth value, and converted to a string (with the function or the slightly different function). The latter function is implicitly used when an object is written by the function.\n\nThere are three distinct numeric types: integers, floating-point numbers, and complex numbers. In addition, Booleans are a subtype of integers. Integers have unlimited precision. Floating-point numbers are usually implemented using double in C; information about the precision and internal representation of floating-point numbers for the machine on which your program is running is available in . Complex numbers have a real and imaginary part, which are each a floating-point number. To extract these parts from a complex number z, use and . (The standard library includes the additional numeric types , for rationals, and , for floating-point numbers with user-definable precision.) Numbers are created by numeric literals or as the result of built-in functions and operators. Unadorned integer literals (including hex, octal and binary numbers) yield integers. Numeric literals containing a decimal point or an exponent sign yield floating-point numbers. Appending or to a numeric literal yields an imaginary number (a complex number with a zero real part) which you can add to an integer or float to get a complex number with real and imaginary parts. Python fully supports mixed arithmetic: when a binary arithmetic operator has operands of different numeric types, the operand with the “narrower” type is widened to that of the other, where integer is narrower than floating point, which is narrower than complex. A comparison between numbers of different types behaves as though the exact values of those numbers were being compared. The constructors , , and can be used to produce numbers of a specific type. All numeric types (except complex) support the following operations (for priorities of the operations, see Operator precedence): absolute value or magnitude of x a complex number with real part re, imaginary part im. im defaults to zero. conjugate of the complex number c\n• None Also referred to as integer division. For operands of type , the result has type . For operands of type , the result has type . In general, the result is a whole integer, though the result’s type is not necessarily . The result is always rounded towards minus infinity: is , is , is , and is .\n• None Not for complex numbers. Instead convert to floats using if appropriate.\n• None Conversion from to truncates, discarding the fractional part. See functions and for alternative conversions.\n• None float also accepts the strings “nan” and “inf” with an optional prefix “+” or “-” for Not a Number (NaN) and positive or negative infinity.\n• None Python defines and to be , as is common for programming languages.\n• None The numeric literals accepted include the digits to or any Unicode equivalent (code points with the property). See the Unicode Standard for a complete list of code points with the property. All types ( and ) also include the following operations: x rounded to n digits, rounding half to even. If n is omitted, it defaults to 0. For additional numeric operations see the and modules. Bitwise operations only make sense for integers. The result of bitwise operations is calculated as though carried out in two’s complement with an infinite number of sign bits. The priorities of the binary bitwise operations are all lower than the numeric operations and higher than the comparisons; the unary operation has the same priority as the other unary numeric operations ( and ). This table lists the bitwise operations sorted in ascending priority: bitwise exclusive or of x and y\n• None Negative shift counts are illegal and cause a to be raised.\n• None A left shift by n bits is equivalent to multiplication by .\n• None A right shift by n bits is equivalent to floor division by .\n• None Performing these calculations with at least one extra sign extension bit in a finite two’s complement representation (a working bit-width of or more) is sufficient to get the same result as if there were an infinite number of sign bits. The int type implements the abstract base class. In addition, it provides a few more methods: Return the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros: More precisely, if is nonzero, then is the unique positive integer such that . Equivalently, when is small enough to have a correctly rounded logarithm, then . If is zero, then returns . Return the number of ones in the binary representation of the absolute value of the integer. This is also known as the population count. Example: Return an array of bytes representing an integer. The integer is represented using length bytes, and defaults to 1. An is raised if the integer is not representable with the given number of bytes. The byteorder argument determines the byte order used to represent the integer, and defaults to . If byteorder is , the most significant byte is at the beginning of the byte array. If byteorder is , the most significant byte is at the end of the byte array. The signed argument determines whether two’s complement is used to represent the integer. If signed is and a negative integer is given, an is raised. The default value for signed is . The default values can be used to conveniently turn an integer into a single byte object: However, when using the default arguments, don’t try to convert a value greater than 255 or you’ll get an . \"byteorder must be either 'little' or 'big'\" Changed in version 3.11: Added default argument values for and . Return the integer represented by the given array of bytes. The argument bytes must either be a bytes-like object or an iterable producing bytes. The byteorder argument determines the byte order used to represent the integer, and defaults to . If byteorder is , the most significant byte is at the beginning of the byte array. If byteorder is , the most significant byte is at the end of the byte array. To request the native byte order of the host system, use as the byte order value. The signed argument indicates whether two’s complement is used to represent the integer. \"byteorder must be either 'little' or 'big'\" Changed in version 3.11: Added default argument value for . Return a pair of integers whose ratio is equal to the original integer and has a positive denominator. The integer ratio of integers (whole numbers) is always the integer as the numerator and as the denominator. The float type implements the abstract base class. float also has the following additional methods. Return a pair of integers whose ratio is exactly equal to the original float. The ratio is in lowest terms and has a positive denominator. Raises on infinities and a on NaNs. Return if the float instance is finite with integral value, and otherwise: Two methods support conversion to and from hexadecimal strings. Since Python’s floats are stored internally as binary numbers, converting a float to or from a decimal string usually involves a small rounding error. In contrast, hexadecimal strings allow exact representation and specification of floating-point numbers. This can be useful when debugging, and in numerical work. Return a representation of a floating-point number as a hexadecimal string. For finite floating-point numbers, this representation will always include a leading and a trailing and exponent. Class method to return the float represented by a hexadecimal string s. The string s may have leading and trailing whitespace. Note that is an instance method, while is a class method. where the optional may by either or , and are strings of hexadecimal digits, and is a decimal integer with an optional leading sign. Case is not significant, and there must be at least one hexadecimal digit in either the integer or the fraction. This syntax is similar to the syntax specified in section 6.4.4.2 of the C99 standard, and also to the syntax used in Java 1.5 onwards. In particular, the output of is usable as a hexadecimal floating-point literal in C or Java code, and hexadecimal strings produced by C’s format character or Java’s are accepted by . Note that the exponent is written in decimal rather than hexadecimal, and that it gives the power of 2 by which to multiply the coefficient. For example, the hexadecimal string represents the floating-point number , or : Applying the reverse conversion to gives a different hexadecimal string representing the same number: For numbers and , possibly of different types, it’s a requirement that whenever (see the method documentation for more details). For ease of implementation and efficiency across a variety of numeric types (including , , and ) Python’s hash for numeric types is based on a single mathematical function that’s defined for any rational number, and hence applies to all instances of and , and all finite instances of and . Essentially, this function is given by reduction modulo for a fixed prime . The value of is made available to Python as the attribute of . CPython implementation detail: Currently, the prime used is on machines with 32-bit C longs and on machines with 64-bit C longs. Here are the rules in detail:\n• None If is a nonnegative rational number and is not divisible by , define as , where gives the inverse of modulo .\n• None If is a nonnegative rational number and is divisible by (but is not) then has no inverse modulo and the rule above doesn’t apply; in this case define to be the constant value .\n• None If is a negative rational number define as . If the resulting hash is , replace it with .\n• None The particular values and are used as hash values for positive infinity or negative infinity (respectively).\n• None For a number , the hash values of the real and imaginary parts are combined by computing , reduced modulo so that it lies in . Again, if the result is , it’s replaced with . To clarify the above rules, here’s some example Python code, equivalent to the built-in hash, for computing the hash of a rational number, , or : Assumes m and n are integers, with n positive. # Remove common factors of P. (Unnecessary if m and n already coprime.) # Fermat's Little Theorem: pow(n, P-1, P) is 1, so # pow(n, P-2, P) gives the inverse of n modulo P.\n\nThere are three basic sequence types: lists, tuples, and range objects. Additional sequence types tailored for processing of binary data and text strings are described in dedicated sections. The operations in the following table are supported by most sequence types, both mutable and immutable. The ABC is provided to make it easier to correctly implement these operations on custom sequence types. This table lists the sequence operations sorted in ascending priority. In the table, s and t are sequences of the same type, n, i, j and k are integers and x is an arbitrary object that meets any type and value restrictions imposed by s. The and operations have the same priorities as the comparison operations. The (concatenation) and (repetition) operations have the same priority as the corresponding numeric operations. if an item of s is equal to x, else if an item of s is equal to x, else the concatenation of s and t equivalent to adding s to itself n times slice of s from i to j with step k index of the first occurrence of x in s (at or after index i and before index j) total number of occurrences of x in s Sequences of the same type also support comparisons. In particular, tuples and lists are compared lexicographically by comparing corresponding elements. This means that to compare equal, every element must compare equal and the two sequences must be of the same type and have the same length. (For full details see Comparisons in the language reference.) Forward and reversed iterators over mutable sequences access values using an index. That index will continue to march forward (or backward) even if the underlying sequence is mutated. The iterator terminates only when an or a is encountered (or when the index drops below zero).\n• None While the and operations are used only for simple containment testing in the general case, some specialised sequences (such as , and ) also use them for subsequence testing:\n• None Values of n less than are treated as (which yields an empty sequence of the same type as s). Note that items in the sequence s are not copied; they are referenced multiple times. This often haunts new Python programmers; consider: What has happened is that is a one-element list containing an empty list, so all three elements of are references to this single empty list. Modifying any of the elements of modifies this single list. You can create a list of different lists this way: Further explanation is available in the FAQ entry How do I create a multidimensional list?.\n• None If i or j is negative, the index is relative to the end of sequence s: or is substituted. But note that is still .\n• None The slice of s from i to j is defined as the sequence of items with index k such that . If i or j is greater than , use . If i is omitted or , use . If j is omitted or , use . If i is greater than or equal to j, the slice is empty.\n• None The slice of s from i to j with step k is defined as the sequence of items with index such that . In other words, the indices are , , , and so on, stopping when j is reached (but never including j). When k is positive, i and j are reduced to if they are greater. When k is negative, i and j are reduced to if they are greater. If i or j are omitted or , they become “end” values (which end depends on the sign of k). Note, k cannot be zero. If k is , it is treated like .\n• None Concatenating immutable sequences always results in a new object. This means that building up a sequence by repeated concatenation will have a quadratic runtime cost in the total sequence length. To get a linear runtime cost, you must switch to one of the alternatives below:\n• None if concatenating objects, you can build a list and use at the end or else write to an instance and retrieve its value when complete\n• None if concatenating objects, you can similarly use or , or you can do in-place concatenation with a object. objects are mutable and have an efficient overallocation mechanism\n• None for other types, investigate the relevant class documentation\n• None Some sequence types (such as ) only support item sequences that follow specific patterns, and hence don’t support sequence concatenation or repetition.\n• None raises when x is not found in s. Not all implementations support passing the additional arguments i and j. These arguments allow efficient searching of subsections of the sequence. Passing the extra arguments is roughly equivalent to using , only without copying any data and with the returned index being relative to the start of the sequence rather than the start of the slice. The only operation that immutable sequence types generally implement that is not also implemented by mutable sequence types is support for the built-in. This support allows immutable sequences, such as instances, to be used as keys and stored in and instances. Attempting to hash an immutable sequence that contains unhashable values will result in . The operations in the following table are defined on mutable sequence types. The ABC is provided to make it easier to correctly implement these operations on custom sequence types. In the table s is an instance of a mutable sequence type, t is any iterable object and x is an arbitrary object that meets any type and value restrictions imposed by s (for example, only accepts integers that meet the value restriction ). item i of s is replaced by x slice of s from i to j is replaced by the contents of the iterable t the elements of are replaced by those of t removes the elements of from the list appends x to the end of the sequence (same as ) removes all items from s (same as ) creates a shallow copy of s (same as ) extends s with the contents of t (for the most part the same as ) inserts x into s at the index given by i (same as ) retrieves the item at i and also removes it from s removes the first item from s where is equal to x reverses the items of s in place\n• None If k is not equal to , t must have the same length as the slice it is replacing.\n• None The optional argument i defaults to , so that by default the last item is removed and returned.\n• None raises when x is not found in s.\n• None The method modifies the sequence in place for economy of space when reversing a large sequence. To remind users that it operates by side effect, it does not return the reversed sequence.\n• None and are included for consistency with the interfaces of mutable containers that don’t support slicing operations (such as and ). is not part of the ABC, but most concrete mutable sequence classes provide it.\n• None The value n is an integer, or an object implementing . Zero and negative values of n clear the sequence. Items in the sequence are not copied; they are referenced multiple times, as explained for under Common Sequence Operations. Lists are mutable sequences, typically used to store collections of homogeneous items (where the precise degree of similarity will vary by application). Lists may be constructed in several ways:\n• None Using a pair of square brackets to denote the empty list:\n• None Using the type constructor: or The constructor builds a list whose items are the same and in the same order as iterable’s items. iterable may be either a sequence, a container that supports iteration, or an iterator object. If iterable is already a list, a copy is made and returned, similar to . For example, returns and returns . If no argument is given, the constructor creates a new empty list, . Many other operations also produce lists, including the built-in. Lists implement all of the common and mutable sequence operations. Lists also provide the following additional method: This method sorts the list in place, using only comparisons between items. Exceptions are not suppressed - if any comparison operations fail, the entire sort operation will fail (and the list will likely be left in a partially modified state). accepts two arguments that can only be passed by keyword (keyword-only arguments): key specifies a function of one argument that is used to extract a comparison key from each list element (for example, ). The key corresponding to each item in the list is calculated once and then used for the entire sorting process. The default value of means that list items are sorted directly without calculating a separate key value. The utility is available to convert a 2.x style cmp function to a key function. reverse is a boolean value. If set to , then the list elements are sorted as if each comparison were reversed. This method modifies the sequence in place for economy of space when sorting a large sequence. To remind users that it operates by side effect, it does not return the sorted sequence (use to explicitly request a new sorted list instance). The method is guaranteed to be stable. A sort is stable if it guarantees not to change the relative order of elements that compare equal — this is helpful for sorting in multiple passes (for example, sort by department, then by salary grade). For sorting examples and a brief sorting tutorial, see Sorting Techniques. CPython implementation detail: While a list is being sorted, the effect of attempting to mutate, or even inspect, the list is undefined. The C implementation of Python makes the list appear empty for the duration, and raises if it can detect that the list has been mutated during a sort. Tuples are immutable sequences, typically used to store collections of heterogeneous data (such as the 2-tuples produced by the built-in). Tuples are also used for cases where an immutable sequence of homogeneous data is needed (such as allowing storage in a or instance). Tuples may be constructed in a number of ways:\n• None Using a pair of parentheses to denote the empty tuple:\n• None Using a trailing comma for a singleton tuple: or\n• None Using the built-in: or The constructor builds a tuple whose items are the same and in the same order as iterable’s items. iterable may be either a sequence, a container that supports iteration, or an iterator object. If iterable is already a tuple, it is returned unchanged. For example, returns and returns . If no argument is given, the constructor creates a new empty tuple, . Note that it is actually the comma which makes a tuple, not the parentheses. The parentheses are optional, except in the empty tuple case, or when they are needed to avoid syntactic ambiguity. For example, is a function call with three arguments, while is a function call with a 3-tuple as the sole argument. Tuples implement all of the common sequence operations. For heterogeneous collections of data where access by name is clearer than access by index, may be a more appropriate choice than a simple tuple object. The type represents an immutable sequence of numbers and is commonly used for looping a specific number of times in loops. The arguments to the range constructor must be integers (either built-in or any object that implements the special method). If the step argument is omitted, it defaults to . If the start argument is omitted, it defaults to . If step is zero, is raised. For a positive step, the contents of a range are determined by the formula where and . For a negative step, the contents of the range are still determined by the formula , but the constraints are and . A range object will be empty if does not meet the value constraint. Ranges do support negative indices, but these are interpreted as indexing from the end of the sequence determined by the positive indices. Ranges containing absolute values larger than are permitted but some features (such as ) may raise . Ranges implement all of the common sequence operations except concatenation and repetition (due to the fact that range objects can only represent sequences that follow a strict pattern and repetition and concatenation will usually violate that pattern). The value of the start parameter (or if the parameter was not supplied) The value of the stop parameter The value of the step parameter (or if the parameter was not supplied) The advantage of the type over a regular or is that a object will always take the same (small) amount of memory, no matter the size of the range it represents (as it only stores the , and values, calculating individual items and subranges as needed). Range objects implement the ABC, and provide features such as containment tests, element index lookup, slicing and support for negative indices (see Sequence Types — list, tuple, range): Testing range objects for equality with and compares them as sequences. That is, two range objects are considered equal if they represent the same sequence of values. (Note that two range objects that compare equal might have different , and attributes, for example or .) Changed in version 3.2: Implement the Sequence ABC. Support slicing and negative indices. Test objects for membership in constant time instead of iterating through all items. Changed in version 3.3: Define ‘==’ and ‘!=’ to compare range objects based on the sequence of values they define (instead of comparing based on object identity).\n• None The linspace recipe shows how to implement a lazy version of range suitable for floating-point applications."
    },
    {
        "link": "https://docs.python.org/3/tutorial/controlflow.html",
        "document": ""
    },
    {
        "link": "https://realpython.com/python-built-in-functions",
        "document": "Python has many built-in functions that you can use directly without importing anything. These functions cover a wide variety of common programming tasks that include performing math operations, working with built-in data types, processing iterables of data, handling input and output in your programs, working with scopes, and more.\n• Get to know Python’s built-in functions\n• Learn about common use cases of Python’s built-in functions\n• Use these functions to solve practical problems\n\nTo get the most out of this tutorial, you’ll need to be familiar with Python programming, including topics like working with built-in data types, functions, classes, decorators, scopes, and the import system.\n\nIn Python, you’ll find a few built-in functions that take care of common math operations, like computing the absolute value of a number, calculating powers, and more. Here’s a summary of the math-related built-in functions in Python: Calculates the absolute value of a number Computes the quotient and remainder of integer division Finds the largest of the given arguments or items in an iterable Finds the smallest of the given arguments or items in an iterable Sums the values in an iterable In the following sections, you’ll learn how these functions work and how to use them in your Python code. Getting the Absolute Value of a Number: The absolute value or modulus of a real number is its non-negative value. In other words, the absolute value is the number without its sign. For example, the absolute value of -5 is 5, and the absolute value of 5 is also 5. Note: To learn more about , check out the How to Find an Absolute Value in Python tutorial. Python’s built-in function allows you to quickly compute the absolute value or modulus of a number: In these examples, you compute the absolute value of different numeric types using the function. First, you use integer numbers, then floating-point and complex numbers, and finally, fractional and decimal numbers. In all cases, when you call the function with a negative value, the final result removes the sign. For a practical example, say that you need to compute the total profits and losses of your company from a month’s transactions: In this example, to compute the expenses, you use the function to get the absolute value of the expenses, which results in a positive value. Finding the Quotient and Remainder in Division: Python provides a built-in function called that takes two numbers as arguments and returns a tuple with the quotient and remainder that result from the integer division of the input numbers: With integers as arguments, the result is the same as . With floating-point numbers, the result is , where is usually , but may be less than that. As a practical example of when to use this function, say that you want to code a function that takes a time value in milliseconds and returns a string with the format. Here’s a possible implementation using the function: In this function, you first convert the input milliseconds to seconds and round the result to the nearest whole number. Then, you use to divide the total seconds by 60 because there are 60 seconds in a minute. This computation gives you the minutes and the remaining seconds. Finally, you use again to divide the minutes by 60 because there are 60 minutes in an hour. This time, you get the hours and the remaining minutes. Sometimes, you need to find the smallest and largest values in an iterable or in a series of values. These can be common computations in programming, and Python has built-in functions for them. Note: To learn more about the and functions, check out the Python’s and : Find Smallest and Largest Values tutorial. The function allows you to find the minimum value in an iterable, while the function helps you find the maximum value. Here’s the signature of both functions: Both functions take a required argument called and return the minimum and maximum values, respectively. They also take two optional keyword-only arguments: Can hold the value you want to return if the input iterable is empty Here are some quick examples of how to use the and functions with different sets of arguments: In the first two examples, you use and with a list of numbers. You can also use these functions with a series of positional arguments. Then, you have two examples of using the argument to return a suitable value when the input iterable is empty. Finally, you have two examples of using the argument. In these examples, you use the function to provide the comparison criteria. When you need to compute powers in your code, you can use the built-in function. This function takes a number and raises it to a given power. Here’s the function’s signature: When you call , you get to the power of . With these two arguments, is equivalent to something like : This operation computes to the power of , which is . This is equivalent to a power operation with the operator, which you’ll find more often in real-world code. The argument allows you to do something like but computed more efficiently: In this example, you use the function from the module to measure the computation speed. Then, you define a few variables to do the computation. In the first call to , you use the argument. In the second call, you use the modulo operator ( ). When you compare the resulting time consumption, you can conclude that using the argument is way faster than computing the power and then applying the modulo operator like in . Python’s built-in function takes a numeric argument and returns it rounded to a given number of digits. Note: To learn more about rounding numbers and the function, check out the How to Round Numbers in Python tutorial. The signature of is shown in the code below: In this signature, is typically a floating-point number, while is an optional argument that should be an integer number. This latter argument will define the precision or number of digits after the decimal point. In these examples, you use the constant from the math module and the function to express the number using different precision. When you use with a single argument, you may get surprising results: In these two examples, the function rounds up to and down to . This is because rounds to the closest multiple of to the power minus . If two multiples are equally close, rounding is done toward the even choice. This rounding half to even strategy helps mitigate rounding bias. That’s why rounds to rather than . Python’s built-in function provides an efficient and Pythonic way to sum a list of numeric values, which is also a common intermediate step in many computations. So is a pretty handy tool for a Python programmer. Note: To dive deeper into how to use , check out the Python’s : The Pythonic Way to Sum Values tutorial. The function allows you to add together a series of values. Its signature is like the following: You can call with the following two arguments: A required argument that can hold any Python iterable. An optional argument that can hold an initial value. When you call , the function internally adds plus the values in . The items in the input are usually numeric values. However, you can also use lists or tuples. The argument can accept a number, list, or tuple, depending on what your contains. Here are a few examples of how to use with different inputs: When you call with an empty iterable, you get as a result because that’s the default value of . Calling the function with a list of values returns the total sum of the provided values. If you want to use a value other than , then you can provide it as a positional or keyword argument. However, the latter approach is more readable. The final two examples show that you can also use to concatenate lists and tuples. Note that for this trick to work, you need to set to the appropriate object. If you want to concatenate lists, then must hold a list, and so on. Even though this trick works, the practice isn’t efficient or common. Instead, you should use the plus operator ( ) for regular concatenations. A classic example of using is when you need to compute the mean or average of several numeric values. In this situation, you need to sum the input data as an intermediate step. Here’s an example: In this function, you use to sum the input values and then divide the result by the number of values in the input data.\n\nPython has several built-in functions that allow you to manipulate basic data types, such as integer and floating-point numbers, strings, and Boolean values. Here’s a summary of the built-in functions that help you process basic data types: Constructs an integer object from a number or string Converts an integer to an octal string Converts an argument to a Boolean value Looks up the integer code point of a character Looks up the character for the given integer code point Creates an object of the class In the following sections, you’ll learn the basics of working with these functions and how to use them in your Python code. Integer numbers are pretty useful in programming. Python has a built-in data type called that represents integers. When working with integers, sometimes you need to express them in different bases like , , or . You may also need to convert strings or other numeric types to integers. For the latter task, you can use the built-in function. Here are some examples of using it: : : invalid literal for int() with base 10: 'one' With no argument, returns . This behavior is especially useful when you need a factory function for classes like from the module. With floating-point numbers, just removes the decimal part and returns the whole part. Finally, with a string as an argument, returns the corresponding integer only if the string represents a valid integer number. You can also use to convert a binary, octal, or hexadecimal string representation into an integer number: In the first example, you use to convert a string representing a number in binary format to its equivalent decimal integer. Note that for this operation to work, you need to set the argument to the appropriate base, which is for binary numbers. Next, you do similar conversions with octal and hexadecimal strings. Again, you have to set to the appropriate value. The , , and functions allow you to do the opposite operation. With them, you can convert a given integer into its binary, octal, or hexadecimal representation: In these examples, you use an integer number as an argument to , , and . As a result, you get the string representation of the input value in binary, octal, and hexadecimal format, respectively. Python has basic built-in types to represent floating-point and complex numbers. These types have associated built-in functions for conversion purposes. So, for floating-point numbers, you have the function, and for complex numbers you have . Note: To dive deeper into complex numbers and the function, check out the Simplify Complex Numbers With Python tutorial. Here are the signatures of both functions: The function takes a single argument representing a numeric value. This argument accepts numbers or strings that represent valid numbers: : could not convert string to float: 'one' With no arguments, returns . With integer numbers, it returns the equivalent floating-point number with as the decimal part. With strings representing numbers, returns the equivalent floating-point number. However, it fails if the input string doesn’t represent a valid numeric value. The function allows you to work with complex numbers. This function has two different signatures. The first signature has two arguments: These arguments accept numeric values, such as integer or floating-point numbers. Here’s how this variation of works: You can call with numeric values, resulting in a complex number. Note that Python uses a to define the imaginary part. The second signature of takes a single argument that should be a string: When you use strings to create complex numbers with , you have to make sure that the input string has a valid format. It should consist of the real part, the sign, and the imaginary part. You can’t add spaces to separate these components. When it comes to creating and working with Python strings, you have two fundamental built-in functions to consider: With the function, you can create new strings or convert existing objects to strings: \"{'one': 1, 'two': 2, 'three': 3}\" In the first example, you use without an argument to create an empty string. In the other examples, you get strings with user-friendly representations of the input objects. For a practical use case, say that you have a list of numeric values and want to join them using the method, which only accepts iterables of strings. In this case, you can do something like the following: In this example, you use a generator expression to convert each number to its string representation before calling . This way, you avoid getting an error in your code. For its part, the built-in function gives you a developer-friendly representation of the object at hand: \"{'one': 1, 'two': 2, 'three': 3}\" For built-in types, the string representation you get with is the same as the one you get with the function. Note: Behind the function, you have the special method. Similarly, behind , you have the method. To learn more about these special methods, check out the When Should You Use vs in Python? tutorial. To see the difference between and , consider the following example that uses the module: The method gives you a developer-friendly string representation of the object. Ideally, you should be able to re-create the object using this representation. In other words, you should be able to copy and paste the resulting representation to re-create the object. That’s why this string representation is said to be developer-friendly. In contrast, the string representation that you get from calling should aim to be readable and informative for end users. Python’s built-in function allows you to determine the truth value of any Python object. It’s a predicate function because it always returns or . To figure out if an object is falsy, in other words, whether returns when applied to the object, Python uses the following internal rules:\n• Constants that are defined to be false: and\n• The zero of any numeric type: , , , , The rest of the objects are considered truthy in Python. Custom objects are considered truthy by default unless they provide a special method that defines a different behavior. Note: To learn more about Boolean values and logic, check out the Python Booleans: Use Truth Values in Your Code tutorial. Here are a few examples of how works: In the first example, you call without an argument and get as a result. In the rest of the examples, you can confirm that Python consistently applies the rules listed above. In practice, you’ll only need to use when your code explicitly requires a Boolean value instead of a different object. As an example of using , say that you have the following implementation of a stack data structure: In this example, your class implements the special method to support Boolean operations on its objects. This method guarantees that when a given object is empty, the function returns and otherwise. Here’s an example: In this code snippet, you first create an empty stack. When you pass this object to , you get . Then, you push a value into the stack and call again. This time, you get because the stack isn’t empty anymore. Character encoding is an important topic in most programming languages. In Python, strings use the Unicode characters set by default. Each Unicode character has an associated code point, which is an integer number. To get the code point of a given character, you can use the built-in function: Every Unicode character has an associated code point that uniquely identifies the character in the Unicode table. In these examples, you use the function to get the code point of a few characters. In practice, you can use the function to implement basic cryptographic techniques, sort strings or characters, validate input characters, and so on. Here’s a quick toy example of a function that only checks whether all the characters in a string are uppercase letters of the English alphabet: In this function, you use to determine whether the characters in a string are between and , which is the interval of code points for uppercase letters, A to Z, in the Unicode table. Sometimes, you may need to determine the code point that identifies a given Unicode character. In this situation, you can use the built-in function: The function does the opposite operation of . It allows you to find the code point associated with a specific character. The and functions are sort of complementary, and therefore, you’ll probably find them used together in tandem. Python’s bytes and byte arrays are built-in types that Python provides out of the box to manipulate binary data, encode and decode text, process file input and output, and communicate through networks. The data type is immutable, while the type is mutable. To create objects derived from these data types, you can use the built-in and functions. The and functions have the following signatures: Both functions have three different signatures. The first signature of both functions accepts a literal as an argument. These literals are similar to string literals, but they start with a and only accept ASCII characters. Here’s a summary of the arguments and their meaning: The character encoding to use for decoding if it holds a string The argument is only required if the argument is a string, in which case, you must provide the appropriate encoding so that Python can convert the string into bytes. Finally, the arguments is also optional and should hold one of the following error handlers: Raises a or exception when encoding problems appear Ignores the characters that can’t be encoded Replaces the characters that can’t be encoded with a question mark ( ) Replaces the characters that can’t be encoded with an XML character reference Replaces the characters that can’t be encoded with Python’s string backslash escape sequences By choosing the appropriate error handlers, you can set up a good strategy for those situations when you call the and functions with erroneous data. Here are a few examples of using the and functions: In these examples, you create and objects using literals, and strings with the correct encoding as an argument. Note that you can call the function with no arguments to create an empty object. Now consider the following examples that show how to use error handlers: \"Using non-ASCII characters with the ASCII encoding: ñ Ł\" : in position 52: ordinal not in range(128) \"Using non-ASCII characters with the ASCII encoding: ñ Ł\" \"Using non-ASCII characters with the ASCII encoding: ñ Ł\" \"Using non-ASCII characters with the ASCII encoding: ñ Ł\" \"Using non-ASCII characters with the ASCII encoding: ñ Ł\" In these examples, you only use because would work similarly. The only difference is that returns immutable objects while returns mutable ones. These examples use non-ASCII characters with the ASCII encoding, which will cause encoding errors that you’ll need to handle. The default value of the argument is . That’s why you get a exception in the first example above. Then you set to so that Python ignores any encoding error. In this case, the and characters are removed. If you set to , then and are each replaced with a question mark. Using as the error handler makes Python replace the and characters with their respective XML character reference. Finally, using escapes the problematic characters by using the appropriate escape sequence.\n\nIf you need to take input from the user or files and present output to the user, then you should know that the language has a few built-in functions that can help you with these tasks: Opens a file and provides access to a file object Prints to a text stream or the console In the following sections, you’ll dive into using these functions to process input and output operations in your Python code. Taking input from your users is a common operation in CLI and text-based interface (TUI) applications. Python has a built-in function that’s specifically targeted to this type of operation. The function is conveniently called . Note: To dive deeper into using the function, check out the How to Read User Input From the Keyboard in Python tutorial. The built-in function reads the user’s input and grabs it as a string. Here’s the function’s signature: The square brackets around are an indication that this argument is optional. This argument allows you to provide a prompt to ask the user for the required or desired input. As an example of using , say that you want to create a number-guessing game. The game will prompt the user to enter a number from 1 to 10 and check if the input value matches a secret number. Here’s the code for the game: \"You guessed it! The secret number is In this code, you define an infinite loop where you prompt the user to make their guess by entering a number between 1 and 10. The first line in the loop is a call to the built-in function. You’ve used a descriptive prompt to inform the users what to do. Go ahead and run the script from your command line to try it out: python guess.py Guess a number between 1 and 10 (greater than 2) 3 Guess a number between 1 and 10 (greater than 3) 8 Guess a number between 1 and 10 (less than 8) 6 You guessed it! The secret number is 6 Cool! Your game asks the user to enter a number, compares it with the secret number, and lets the users know when they guess correctly. The function plays a core role in the game’s flow, allowing you to get and process the user’s input. Reading from and writing to files are common programming tasks. In Python, you can use the built-in function for these purposes. You typically use the function in a statement. As a quick example, say that you have a text file with the following content: You want to open the file and read its content while you print it to the screen. To do this, you can use the following code: In this statement, you call with the filename as an argument. This call opens the file for reading. The function returns a file object, which the statement assigns to the variables with the specifier. Note: To learn more about working with files, check out the Reading and Writing Files in Python (Guide) tutorial. The function has the following signature: The function can take up to eight arguments. The first argument, , is the only required argument. The rest of the arguments are optional. Here’s a summary of the arguments’ meaning: A path-like object holding the path to the target file A string that specifies the mode in which you want to open the file It defaults to , which is the reading mode. You’ll learn about the available modes in a moment. An integer that sets the buffering policy You can pass to switch buffering off, which is only possible in binary mode. You can use to select line buffering, which is only usable in text mode. Finally, you can use an integer greater than to indicate the size in bytes of a fixed-size chunk buffer. The name of the encoding used to decode or encode the file You can only use this argument in text mode. A string that specifies how encoding and decoding errors are to be handled You can only use this argument in text mode. It can take one of the following values: , , , , , , or . These values have similar meanings to those you learned in the section about the and functions. A string that determines how to parse newline characters from the stream It can be , , , , or . A Boolean value that defines whether you want to close a file descriptor It can be when you provide a file descriptor instead of a filename and want the descriptor to remain open when the file is closed. Otherwise, it must be . A callable that you use as a custom opener for the target file The opener must return an open file descriptor. In this tutorial, you won’t cover all these arguments. Instead, you’ll learn about two of the most commonly used arguments, which are and . Opens the file for reading and is the default value Opens the file for writing, truncating the file first Opens the file for exclusive creation, failing if the file already exists Opens the file for writing, appending the new data to the end of the file if it already exists Opens the file in text mode, which is the default mode Opens the file for updating, which allows reading and writing operations In this table, the and values define two generic modes for binary and text files, respectively. You can combine these two modes with other modes. For example, the mode allows you to write binary data to a file, the mode enables you to read text-based data from a file, and so on. Note that is the default mode. So, if you set the mode to , Python assumes that you want to write text to the target file. Here’s a code snippet that writes some text to a file in your working directory: In this example, you open a file called so you can write text to it. In the code block of the statement, you call the method on the file object to write some text. Note that the method returns the number of written bytes. That’s why you get on the screen. After running the code, you’ll have the file in your working directory. Go ahead and open it to check its content. You can experiment with other modes and get an idea of how they work so that you can use them safely in your code. Take this as a practical exercise! Using the argument is another typical requirement when you’re working with text files. In this situation, it’s a best practice to explicitly state the text encoding that you’re using in your code. The UTF-8 encoding is a common example of a value that you’d pass to : In this example, you use the UTF-8 encoding to write and read from a text file. Note that you need to explicitly use the argument’s name to provide the encoding value. This is because the following argument in the list is rather than , and if you don’t use the explicit name, then you get a exception. Printing Text to the Screen or Another Output: Another common requirement that arises when you’re creating CLI or TUI applications is to display information on the screen to inform the user about the app’s state. In this case, you can use the built-in function, which is a fundamental tool in Python programming. Note: To dive deeper into using the function, check out the Your Guide to the Python Function tutorial. The function has the following signature: Calling will print the input objects to the screen by default. You can use the rest of the arguments to tweak how the function works. Here’s a summary of the arguments and their meaning: The string you want to use to separate input objects from one another The string to use after the last input object The open file object where you want to write the input objects A Boolean value that defines whether you want to flush the output buffer When you call , it takes the input , converts them into strings, joins them using , and appends . If you call with no argument, then it prints . Note that the arguments , , , and are keyword arguments. Here are a few examples of how to use the function: When you call with no arguments, then is printed on the screen. This argument defaults to a newline character, so that’s what you get. With an object as an argument, the object is printed, followed by a newline character. With several objects as arguments, the arguments are joined by , and a newline is added at the end. You can also tweak the value of and make Python print something different at the end of your output. The argument defaults to the standard output, which is your screen. The stream provides this default value. However, you can redirect the output to a file object of your preference: This code snippet will override your existing file from the previous section, writing the phrase into it. Finally, you have the argument that has to do with data buffering. By default, Python buffers the calls to in a RAM data buffer. This allows Python to make fewer system calls for write operations by batching characters in the buffer and writing them all at once with a single system call. You can set the argument to if you want your code’s output to display in real time. If you keep at its default value of , then Python will buffer the output, and that output will only show up once the data buffer is full or when your program finishes execution. Note: To dive deeper into flushing the output of , check out the How to Flush the Output of the Python Print Function tutorial. A cool example of using is when you need to create a progress bar for a CLI application. Consider the following function: This function generates a horizontal progress bar by taking advantage of the argument. Here’s how you can use it in your code: This loop calls with successive hypothetical progress values. The output of each call is flushed and the progress bar is displayed in the same line. Python has a couple of handy tools for string interpolation and formatting, including f-strings and the method. These tools take advantage of Python’s string formatting mini-language, which allows you to nicely format your strings using a dedicated syntax. The built-in function is another tool that you can use to format values. The function has the following signature: The function converts to a formatted representation. To define the desired format, you can use the argument, which accepts a string that follows the syntax defined in the string formatting mini-language. The argument defaults to an empty string, which causes the function to return the value as passed. Consider the following examples of using the function: In these examples, you’ve used several different format specifiers. The specifier formats the input value as a floating-point number with four decimal places. The specifier allows you to format the input value using scientific notation. Note: To learn more about format specifiers, check out the Python’s Format Mini-Language for Tidy Strings tutorial. With the format specifier, you can format a number using commas as thousand separators and with two decimal places, which is an appropriate format for currency values. Then, you use the specifier to format the string centered in a width of characters using the equal sign as a filler character. Finally, you use the to format a date.\n\nPython supports object-oriented programming (OOP) with classes, types, inheritance, and many other related features. In Python, everything is an object. So, the OOP paradigm is core to the language itself. You’ll have several built-in functions that help you with different tasks related to classes, types, attributes, methods, inheritance, and other OOP-related concepts. Returns the value of a named attribute of an object Sets the value of a named attribute of an object Deletes an attribute from an object Returns if an object has a given attribute Return the type of an object or allows for creating new classes dynamically Determines whether an object is an instance of a given class Determines whether a class is a subclass of a given class Returns if an object appears to be callable Returns a proxy object that delegates method calls to a parent or sibling class In the following sections, you’ll learn about all these functions and how to use them in your object-oriented Python code. Python’s built-in function allows you to create managed attributes in your classes. Managed attributes, also known as properties, have an associated value and an internal implementation or function-like behavior. To illustrate this with an example, say that you want to create a class. In Python, you’ll start with something like the following: In this class, you define two attributes, and , to represent the point’s coordinates. You can access and update the attributes directly using the dot notation. So, from now on, both attributes are part of your class’s public API. Now, say that you need to add some validation logic on top of and . For example, you may need to validate the input values for both attributes. How would you do that? In programming languages like Java or C++, you’d use the getter and setter methods, which translated into Python may look something like this: In this new implementation of , you’ve turned and into non-public attributes by prepending underscores to their names, which now are and . Then, you define getter and setter methods for both attributes. In the setter methods, and , you insert the validation logic defined in the method. Now, you have to use the class as in the following code: Your class works differently after the update. Instead of accessing the and attributes directly, you have to use the getter and setter methods. The validation logic works, which is great, but you’ve broken your class’s API. Your users won’t be able to do something like the following: Old users of your class will be surprised that their code is broken after updating to your new version of . So, how can you avoid this kind of issue? The Pythonic approach is to convert public attributes into properties instead of using getter and setter methods. You can use the built-in function to do this conversion. Here’s how you can keep your class’s API unchanged: now looks a bit different. It doesn’t have formal getter and setter methods. Instead, it has some methods that are decorated with . Yes, the built-in function is mostly used as a decorator. The methods that you decorate with are equivalent to getter methods. Meanwhile, the methods that you decorate with the getter’s name plus are equivalent to setter methods. The cool thing about properties is that you can still use the attributes as regular attributes: By turning regular attributes into properties, you can add function-like behavior to them without losing the ability to use them as regular attributes. Properties save you from introducing breaking changes into your code’s public API, so you don’t break your users’ code. Classes allow you to define reusable pieces of code that encapsulate data and behavior in a single entity. Usually, you store data in attributes, which are variables defined inside classes. When it comes to behaviors, you’ll use methods, which are functions defined in classes. In Python, you have three different types of methods:\n• Instance methods, which take the current object as their first argument\n• Class methods, which take the current class as their first argument\n• Static methods, which take neither the current instance nor the current class as arguments Instance methods need to take the current instance as an argument. By convention, this argument is called in Python. To create a class method, you need to decorate the method with the decorator. Similarly, to create a static method, you need to decorate the method with the decorator. Both decorators are part of Python’s built-in functions. A common use case for class methods is to provide multiple constructors for a class. To illustrate how to write a class method, say that you want a class that you can construct using either Cartesian or polar coordinates. In this situation, you can do something like the following: In this example, the method is a class method. It takes the current class as its first argument, which you typically call by convention. The method returns a new instance of the class by computing the Cartesian coordinates from the polar coordinates. Here’s how you can use this method in practice: In this code snippet, you create a new instance using the class method. In the example, you call the method on the class rather than on an instance to signal that this is a class method. You can call a class method on an instance of its containing class too. The third type of method is the static method. A static method doesn’t take the current instance or class as arguments. These methods are like regular functions that you decide to include in a given class for convenience. Functionally, they could also be defined as regular functions in a module. For example, consider the following class: This class defines two static methods. The first method takes a numeric value and formats it as a currency value. The second method takes a numeric value and expresses it as a percent. You could have defined these methods as regular functions at the module level. However, you’ve defined them in a class as a way to conveniently group them according to how they’ll be used. You can use this class as in the following examples: You can use static methods by calling them on the class or one of its instances. In this example, the class works as a namespace where you define related methods for convenience. However, you can get the same result by defining the methods as module-level functions. Note: For a deeper dive into instance, class, and static methods, check out the Python’s Instance, Class, and Static Methods Demystified tutorial. Sometimes, you may need to access, set, or delete attributes from your objects in Python. In most cases, you can do these operations directly using the dot notation, the assignment operator, and the statement. In other situations, you only know the attributes’ names at runtime, so you can’t access them with the regular syntax. In these cases, you can use the built-in , , and functions. These functions have the following signatures: In all cases, the argument must take an instance of an existing class. Similarly, must be the name of an attribute or method as a string. In the second signature of , the argument is an optional value that you’ll get if the desired attribute doesn’t exist in the target object. In the signature of , the argument must hold the new value that you want to assign to a given argument. To illustrate how these functions work, consider the following class: This class has two instance attributes, and . Here’s how you can access, set, or delete the attributes using their names as strings: In these examples, you use to retrieve the values stored in and . The first argument to this function is the object you need to retrieve an attribute from. The second argument is the attribute’s name as a string. Now say that you want to update Jane’s age. You can do this using the function: Then, you use the function to assign a new value to the attribute. This function takes three arguments: the object, the attribute’s name, and the new value. Finally, you can use the built-in function to delete an attribute from a given object: The function takes the object as its first argument and the attribute’s name as its second argument. After calling the function, trying to access will raise an exception. Note: To learn more about deleting objects in Python, check out the Python’s : Remove References From Scopes and Containers tutorial. In practice, the built-in , , and functions come in handy when you need to manipulate attributes using their names as strings. For example, say that you want to create a class to read and write CSV and JSON files. In this situation, you can have dedicated classes for processing each file type: In this file, you define two classes that can process CSV and JSON files, respectively. Both classes have the and methods. These classes look fine, but now you need to make them usable from your class. To write the class, you can use a technique called delegation, which consists of evaluating an object’s attribute or method in the context of another object. Here’s how you can do this in Python: In this class, you define the special method. This method supports attribute access operations in Python classes. In the method definition, you use the function to access attributes and methods from the provided processor object. In practice, you use the combination of the method and the function to implement delegation. The class delegates the file processing to the concrete processor class that you pass in during instantiation. Here’s how you can use the class in your code: In this code, you create a instance to process a CSV file with the . Even though the instance doesn’t have a method, you can call the method because of the delegation technique that relies on the function. Another built-in function closely related to attributes and methods is the function. This function allows you to check whether a given object has a certain attribute or method. The function has the following signature: In this signature, the argument can take any Python object, while the argument should hold the name of an attribute as a string. This function is a predicate that returns if the object has an attribute with the provided name and otherwise. In practice, you can use this function to check whether an object has a given attribute or method before you try to use it. For example, say that you have the following classes: These classes represent two different birds. Both birds are capable of flying, but only the duck is capable of swimming. Now, say that you want to use them in a loop like the following: This loop works for the instance of . However, it raises an exception when you call on a instance because the class doesn’t have this method. To avoid this error, you can use the function to check whether the method exists before calling it: Your code doesn’t fail now because you’ve used the function to ensure that the current bird has the method before calling it. Python is a dynamically typed language, which means that Python checks types only as the code runs, and the type of a variable can change over its lifetime. Because of this language feature, you may need to explicitly check an object’s type before using it so that your code doesn’t fail. Note: Because Python is a dynamically typed language, the duck typing style is favored over explicit type checking. To learn about duck typing, check out the Duck Typing in Python: Writing Flexible and Decoupled Code tutorial. To know the type of a given object, you can use the built-in function: When you call with any Python class as an argument, then you get the object’s type, which you can also call the object’s class. In this example, you call with an integer number as an argument and get the class as a response. Then, you use with a floating-point number and get the class, and so on. If you want to check an object’s type with , then you can do something like the following: This way of using works. However, it’s not the recommended approach. You’ll learn more about type checking in a moment. For now, you’ll continue to learn the basics of . To kick things off, here are the function’s signatures: You’ve already used the first signature. In this signature, the argument represents any Python object. The second signature is a bit more involved. You’ll use this signature to create new classes dynamically rather than to determine an object’s type. Here’s a summary of the arguments and their meaning: A dictionary of attributes and methods defined in the class body Additional keyword arguments that are passed to the metaclass constructor When you use with these arguments, you can build classes dynamically. In this way, is a dynamic form of the statement. Consider the following toy example: In this quick example, you use to create a demo class that automatically inherits from because the tuple is empty. The new class will have a method called , which you’ve defined beforehand. It also has a class attribute called that you set to . For attributes, you should provide the attribute’s name as a string and the attribute’s value. For methods, you should give the method’s name as a string and a method object, which is a method without the calling parentheses. Note that instance methods like must take the current object as an argument, which you typically call . For a more realistic example, say that you want to write a function that lets you build classes dynamically from different data schemas. In this situation, you can do something like the following: In this code, you create a function that takes two arguments. The first argument, , should be a string providing a valid class name. The second argument, , should be a dictionary of attributes and methods. Then, you define an inner function called , which you’ll use as the class initializer. The function will allow you to provide a string representation for the objects of your class. Next, you create a dictionary to include the functions as methods for your class and update the dictionary with the content of , which should come from the user. Finally, you use the function to generate the class with the provided name and the dictionary of members. Here are a couple of examples of how to use this function: In this code snippet, you first create two classes using . The first class represents users, and the second represents products. Both have different sets of instance attributes. Then, you create concrete instances of each class with proper values for the attributes. Finally, you access the attributes using the dot notation. That’s great! Your classes work as expected. The function is a great tool for creating classes dynamically. Even though you can also use this function to check for an object’s type, the recommended tool for explicit type checking is the built-in function because it takes subclasses into account. The signature for is like the following: In this signature, represents any Python object in which you’re interested. The argument is the class or classes that you want to check against. This argument can be a single class object, a tuple of class objects, or a union type. Consider the following examples where you use to check for numeric values: In the first example, you use to check whether is an instance of the class. In the second example, you use to check whether is an instance of either or . In this example, you use a tuple of classes to provide the argument. Finally, in the third example, you do the same check as in the second example. This time, you use the pipe character ( ) to create a union type with and . Note that is a predicate function that returns if the input object is an instance of one of the provided classes. The function also considers subclasses. For example, the class is a subclass of so if you compare an instance of with , then you’ll get as a result: Because is a subclass of , the function returns when you check a Boolean value against the class. Note that if you try to do a similar check with , then you get because doesn’t consider subclasses. There’s another built-in function that can be useful for type checking. The function is called and it checks whether a given class is a subclass of another class: In the first example, you check whether the class is a subclass of . In this case, you get because all Python classes derive from . Then, you check whether is a subclass of , which is also true, as you already learned. In the final example, you use to check whether is a subclass of , which is . The signature of is as below: In this case, the argument is the class that you want to check for, while the argument works the same as in . A callable in Python is any object that you can call using a pair of parentheses and a series of arguments if required. In Python, callable objects include functions, classes, methods, instances of classes with a method, closures, and generator functions. Sometimes, you may need to know whether an object is callable before calling it in your code. To do this, you can use the built-in function, which takes an object as an argument and returns if the object appears to be callable. Otherwise, it returns . Here are a few examples of using with some built-in objects: In the first three examples, the arguments to are all functions, so you get as a result. In the final two examples, you use the and objects as arguments. These objects aren’t callable, so you get as a result. As a practical example, say that you need to build an app that processes commands. Every command should be callable, otherwise it won’t be valid. To check this condition, you can use . Here’s a toy implementation: In this class, the method uses to check whether the input command is a callable object. If that’s the case, then you register the command as valid. Next, you have the method that runs the command as a callable. Here’s an example of how to use this class: In this example, you create a instance to process commands. Then, you write to use it as a command. Because is a callable object, you can register it as a valid command and run it with the method. Finally, you define the variable to hold the result of a subtraction operation. This variable isn’t callable. Therefore, you get a exception when registering it as a command. When working with inheritance in Python classes, you’ll often need to access a parent class’s attributes or methods in a subclass. The Pythonic way to do this is to use the built-in function. Note: To learn more about , check out the Supercharge Your Classes With Python tutorial. A common use case for is when you need to create a subclass of an existing class, and you need a proper way to initialize the parent class’s attributes. Consider the following classes that represent a rectangle and a square: In this code, you define a class with two attributes, and . It also has two methods for computing the rectangle’s area and perimeter. Next, you define the class. Since a square is a type of rectangle with equal sides, it makes sense to create as a subclass of and reuse the functionality that you’ve already implemented. In the constructor, you only need a single argument to represent the side length. You can use this argument to initialize the parent class using as you did in the highlighted line. The super() function gives you access to the parent class . Once you have access to the class, you can call its method to initialize the and attribute with the value of . In Python, every single class implicitly inherits from the class, which is built into the language. In other words, the class is the base class for every class in Python: No matter if the class you’re considering is a built-in or a custom class, it inherits from . In some situations, you may want to create instances of the class. To do this, you can use the built-in function, which is actually a class constructor rather than a function, but the Python documentation lists it among its built-in functions. The function doesn’t take an argument and returns a new featureless object, which has the methods that are common to all Python objects. Unlike regular objects, the object that you get from calling doesn’t have a attribute, so you can’t add attributes dynamically to this type of object: In this example, you create a new featureless object by calling . With the built-in function, you can list all the methods and attributes that this object provides. Finally, if you try to add an attribute to your featureless object dynamically, then you get an exception. In practice, you can use the function when you want to create unique sentinel values. A sentinel value is a unique marker that you can use to signify the absence of a value. You can also use it as a condition for stopping iterative or recursive algorithms. To illustrate how to use to create a sentinel value, consider the following class: In this class, you have a attribute that takes a value at instantiation time. Then, you have a non-public attribute called that you initialize with the constant. To create this constant, you use the function. Finally, you have the property, which computes the diameter from the provided radius. In this example, you use from the module to simulate that finding the diameter is a costly operation. Because of the computation cost, you decide to cache the diameter so that it’s computed a single time during the object’s life. To check whether the diameter was already computed, you compare its current value with the constant. In this example, you could’ve also used as the sentinel value because a circle’s diameter is unlikely to take a null value. However, when can be a valid value for the attribute at hand, then can be the way to go.\n\nIn rare situations, it may be useful to evaluate expressions or run code that comes as a string object. This practice isn’t common in real-world code because it may not be secure, especially when the target code comes from an untrusted source, such as the user’s input. Regardless of the security issues involved, Python has three built-in functions that allow you to evaluate expressions or run code that comes as a string. Here’s a summary of these functions: In the following sections, you’ll learn the basics of these functions. To kick things off, you’ll start by using the function to evaluate Python expressions. In Python, an expression is a combination of objects and operators that returns a value. You’ll find several types of expressions, including math, Boolean, comparison, bitwise expressions, and more. When working with expressions, you can run them as regular Python code. However, what if you need to evaluate expressions defined as strings? For example, think of how you would evaluate the following: If you want to evaluate this string as an expression, then you’ll have to parse the string and figure out how to extract the operands and operators. Then, you can reconstruct the expression and run it in the Python interpreter. This process may sound like a quick thing to do. However, it can be overwhelming in practice, especially if you consider the infinite number of different expressions that you may need to evaluate in real code. Fortunately, Python has a built-in function that helps you evaluate expressions that come as strings. Note: To learn more about , check out the Python : Evaluate Expressions Dynamically tutorial. If you have a string that holds a valid Python expression, then you can call with that string as an argument. The function will parse the string, compile it into bytecode, and finally evaluate it as a normal expression: Wow! That was quick and smooth! You just passed your string to , ran the code, and got the expression’s result. The signature of looks something like the following: The first argument, , holds the expression that you need to evaluate. The rest of the arguments are optional. That’s why they’re enclosed in square brackets. Here’s a summary of these arguments and their meaning: A dictionary holding a global namespace to use in the call to A dictionary holding a local namespace to use in the call to You’ve already seen an example of using the argument, so now you can focus on the other two arguments. In each example, you’ll need to provide an expression. Here’s an example of using the argument: : name 'numbers' is not defined By default, has access to the global scope, so you can use all the names defined in this scope in the expression you pass to the function. If you set to an empty dictionary, then you restrict access to the global scope, and the function fails. Finally, you can use an explicit dictionary, as you did in the final example, to provide the global variables that you want to use when evaluating the target expression. The argument works similarly. It takes a dictionary of local names: Inside the function, you define and as local variables. In the call to , you use an empty dictionary for , and a dictionary containing the local variables for . Even though the function may seem like an amazing tool, you must be careful when using it in your code. In practice, you’ll be safer if you don’t use this tool in real-world code. Why? The function has security implications that can be hard to circumvent. For example, if you use the function to evaluate expressions provided by external users, then you expose your system to the execution of arbitrary Python code. For more insights on how to reduce the security risks associated with , check out the Minimizing the Security Issues of in the Python : Evaluate Expressions Dynamically tutorial. The function is a powerful tool in Python. However, it’s designed to evaluate expressions. Sometimes, you may want to run more complex pieces of code that come as strings. For example, you may want to run loops, conditional statements, compound statements, and even entire scripts. In this scenario, you can use the built-in and functions. Note: To learn more about , check out the Python’s : Execute Dynamically Generated Code tutorial. Here’s the signature of the function: The argument can be a string containing valid Python code. It can also be a compiled code object, which you can create with the function. You’ll learn about in a moment. For now, you’ll use a string to provide the argument. If comes as a string, then parses it as a sequence of Python statements. Then, it compiles the code into bytecode, and finally, it executes the code unless a syntax error occurs during the parsing or compilation step. Consider the following example: In this example, you define a list of strings. Each string holds Python functions for a basic arithmetic operation. Then, you start a loop over the list. With , you execute the strings that define the functions. This step brings every function to your current global scope. Now, you can use them as you would a regular function: The arithmetic functions are now available in your global scope, so you can use them to run your calculations. Like , takes the and arguments, which again are optional. These arguments have similar meanings in both functions, so you can give them a try as an exercise. Note: The function also has security implications. To learn more about them, check out the Uncovering and Minimizing the Security Risks Behind section in the Python’s : Execute Dynamically Generated Code tutorial. When you have a string containing code that you’ll reuse several times, you can use the function to compile the code once and use it everywhere. This practice will make your code more efficient and fast because the compilation step runs only once. The signature of looks something like the following: This signature is a bit involved because it has several arguments that you need to understand. Here’s a summary of the arguments and their meaning: Holds the code that you need to compile into bytecode Hold the file from which the code was read Specifies what kind of code must be compiled Controls which compiler options should be activated and which future features should be allowed To read from a string object, you’ll have to set to the value. The argument can take one of the following values:\n• when is a sequence of statements Depending on the source code and the function you plan to use to run it, you’ll select the first or the second value. The argument comes in handy when you want to run a statement like that you’d typically run in an interactive session. To illustrate how to use , consider the following toy example: result = sum(number for number in iterable if not number % 2) In this example, you have a piece of code in a string. The code consists of a call to that wraps a generator expression that takes an iterable of numbers and returns the even numbers. Next, you use the function to compile the string into a code object ready for execution. The dictionary holds an iterable of numbers. You call with the compiled code and the context dictionary as arguments. Note that you use to provide the argument. The call to will update this dictionary with any name that you define in the compiled code. In this specific example, ends up holding the variable with the sum of the even numbers in the iterable. To access the computed value, you use the dictionary with the key. In the final example, you reuse the compiled code to perform a similar computation with a different list of values.\n\nPython has a few other built-in functions that cover miscellaneous topics. Here’s a summary of these functions: Calculates the hash value of an object In the following sections, you’ll learn the basics of these functions and how to use them in your Python code or in an interactive session of the language. To kick things off, you’ll start with the built-in function. The built-in function comes in handy when you’re working in a Python REPL session. This function gives you access to the built-in interactive help system. Go ahead and open an interactive Python session in your terminal. Then, call with no arguments. You’ll be presented with the help system: Welcome to Python 3.x's help utility! If this is your first time using Python, you should definitely check out the tutorial on the internet at https://docs.python.org/3.x/tutorial/. Enter the name of any module, keyword, or topic to get help on writing Python programs and using Python modules. To quit this help utility and return to the interpreter, just type \"quit\". To get a list of available modules, keywords, symbols, or topics, type \"modules\", \"keywords\", \"symbols\", or \"topics\". Each module also comes with a one-line summary of what it does; to list the modules whose name or summary contain a given string such as \"spam\", type \"modules spam\". The output gives you a warm welcome to the Python help utility. Then, it suggests that you take the official Python tutorial if you’re new to the language. In the third and fourth paragraphs, you’re given instructions for using the help system. At the end of the page, you have the prompt waiting for your input. Go ahead and type in the name and then press . You’ll see something like the following: Help on class str in module builtins: class str(object) | str(object='') -> str | str(bytes_or_buffer[, encoding[, errors]]) -> str | | Create a new string object from the given object. If encoding or | errors is specified, then the object must expose a data buffer | that will be decoded using the given encoding and error handler. | Otherwise, returns the result of object.__str__() (if defined) | or repr(object). | encoding defaults to sys.getdefaultencoding(). | errors defaults to 'strict'. | | Methods defined here: | | __add__(self, value, /) | Return self+value. | | __contains__(self, key, /) | Return key in self. ... This is the help page for the class. On this page, you’ll find detailed information about the class and its goals. To leave the page and get back to the help system, go ahead and press . While in the help system, you can consult the help for many Python objects, including built-in modules, functions, keywords, and much more. Go ahead and give it a try. You may find some useful information! There’s a second way you can use the function. First, type at prompt and then press to get back to your interactive session. Once in there, you can call with any Python object as an argument. For example, if you call the function with the class as an argument, then it’ll take you to same page you saw before: This way of calling gives you quick access to the help page of a given object. It’s important to note that you can either use the object directly as an argument to or the name of the object as a string like in . However, in most cases, using the name of the object as a string is safer: : name 'sys' is not defined In this example, you try to access the help page for the module. You use the module’s name as an argument and get a exception because the module isn’t present in your current scope. The call to will work safely if you use the module’s name as a string, as in . Go ahead and give it a try! If you work in fields like data integrity, security, or cryptography, then you may be familiar with hash codes. A hash code is a number that can act as a digital fingerprint for a given piece of data. It’s usually much smaller than the original data and lets you verify its integrity. To create a hash code for a given object, you need a hash function. Python has its own built-in function for creating hash codes. The function is conveniently called . Note: To learn more about hash tables, check out the Build a Hash Table in Python With TDD tutorial. The signature of is like the following: It takes an object as an argument and returns the hash value of the input object. The hash value has to be an integer number. Here are a few examples of using the function: In these examples, you’ve used the function with different objects, including numeric values, strings, function objects, and custom classes. In all cases, you get a unique hash code. In practice, there are objects that don’t have a hash value: You’ll note that mutable objects aren’t hashable in Python because you can change the value of a mutable object during its lifetime. Python’s built-in function is an advanced tool that isn’t common in everyday programming. The function is called internally by the statement. The direct use of is discouraged in favor of . However, it’s a built-in function, so you’ll learn a bit about it in this section. Note: To dive deeper into the import system, check out the Python : Advanced Techniques and Tips tutorial. The signature of looks something like the following: With this function, you can import a module by its . This should be a string. Here’s a summary of the function’s arguments and their meaning: A list of objects or submodules that should be imported from the module A positive value indicating the number of parent directories to search relative to the directory of the module calling To do something equivalent to with the function, you can do something like the following: In this example, you create a variable and assign it the result of calling with the string as an argument. This call to imports the module into your current global scope. The built-in function allows you to access the internal data of an object that supports the buffer protocol, such as , , and objects. You can use this function for manipulating large datasets or interfacing with binary data. For example, if you have a large dataset and want to use a chunk of it, then creating a copy would be inefficient. Instead, you can make a object to access the data without copying it. This allows you to use less memory and increases the execution speed. For example, say that you have the pixel data of an image represented as a , and you want to invert the pixel values. To do this operation efficiently, you can use the function: In this example, you create a object to access the data that represents your image. In the loop, you iterate over the data and invert the pixel values. The transformation reflects on the original data. In short, the function is a powerful tool for working with objects that support the buffer protocol without copying the data, which makes your code memory-efficient and faster."
    },
    {
        "link": "https://docs.python.org/3/library/itertools.html",
        "document": ""
    },
    {
        "link": "https://geeksforgeeks.org/python-program-for-sum-the-digits-of-a-given-number",
        "document": "The task of summing the digits of a given number in Python involves extracting each digit and computing their total . For example, given the number 12345, the sum of its digits is 1 + 2 + 3 + 4 + 5 = 15.\n\nThis method efficiently extracts each digit using the modulus (%) and integer division (//) operations, avoiding unnecessary string conversions. It is the fastest and most memory-efficient approach, making it ideal for performance-focused applications.\n\nExplanation: This code iterates through the digits of n, extracting each last digit using % 10, adding it to sum and removing it with // 10 until n becomes 0.\n\nThis method uses recursion to break the problem into smaller subproblems. It follows the same mathematical approach but introduces function call overhead, making it slightly less efficient than the iterative method. It is useful when a recursive solution is preferred.\n\nExplanation: fun(n) recursively sums the digits of n. If n is 0, it returns 0. Otherwise, it adds the last digit (% 10) to the sum of a recursive call on the remaining digits (// 10), repeating until n becomes 0.\n\nmap() apply the int() conversion directly, reducing memory usage. It provides a more functional programming style but still involves string conversion and making it less efficient than mathematical methods.\n\nExplanation: This code converts n to a string, maps each digit to an integer and sums them using sum().\n\nfunctools.reduce() applies a cumulative operation to the digits. Although some may prefer this approach, it adds unnecessary function call overhead, making it the least efficient method for this problem.\n\nExplanation: This converts n to a string, then applies a lambda function that iteratively adds each digit (converted to an integer) to an accumulator, starting from 0."
    },
    {
        "link": "https://stackoverflow.com/questions/48709246/numbers-that-are-a-power-of-their-sum-of-digits-codewars",
        "document": "I'm stuck in Codewars Kata, I hope someone could help me out (without spoiling the solution). In fact the problem is that I didn't fully understand how it should work, I got the idea of the exercise but things are a bit confusing especially in Sample tests.\n\nHere are the instructions:\n\nThe number 81 has a special property, a certain power of the sum of its digits is equal to 81 (nine squared). Eighty one (81), is the first number in having this property (not considering numbers of one digit). The next one, is 512. Let's see both cases with the details.\n\nWe need to make a function, power_sumDigTerm(), that receives a number n and may output the nth term of this sequence of numbers. The cases we presented above means that:\n\nAnd here are the sample tests:\n\nMy main problem is how did they get the results for the sample tests."
    },
    {
        "link": "https://stackoverflow.com/questions/15285534/isprime-function-for-python-language",
        "document": "P.s. I am very inexperienced and have just been introduced to programming a month ago.\n\nBut my question really is how to do it, but WHY. I understand that 1 is not considered a \"prime\" number even though it is, and I understand that if it divides by ANYTHING within the range it is automatically not a prime thus the return False statement. but my question is what role does the square-rooting the \"n\" play here ?\n\nSo I was able to solve this problem with a little bit of help from the internet and this is what I got:\n\nOf many prime number tests floating around the Internet, consider the following Python function: def is_prime(n): if n == 2 or n == 3: return True if n < 2 or n%2 == 0: return False if n < 9: return True if n%3 == 0: return False r = int(n**0.5) # since all primes > 3 are of the form 6n ± 1 # start with f=5 (which is prime) # and test f, f+2 for being prime # then loop by 6. f = 5 while f <= r: print('\\t',f) if n % f == 0: return False if n % (f+2) == 0: return False f += 6 return True Since all primes > 3 are of the form 6n ± 1, once we eliminate that is:\n• not 2 or 3 (which are prime) and\n• not even (with ) and\n• not divisible by 3 (with ) then we can test every 6th n ± 1. The line evaluates to 70 (the square root of 5003 is 70.7318881411 and truncates this value) Consider the next odd number (since all even numbers other than 2 are not prime) of 5005, same thing prints: The limit is the square root since The function only has to go 1 loop to find that 5005 is divisible by 5 and therefore not prime. Since (and both are 5005), we do not need to go all the way to 1001 in the loop to know what we know at 5! Now, let's look at the algorithm you have: def isPrime(n): for i in range(2, int(n**0.5)+1): if n % i == 0: return False return True\n• It does not test if is less than 2, and there are no primes less than 2;\n• It tests every number between 2 and n**0.5 including all even and all odd numbers. Since every number greater than 2 that is divisible by 2 is not prime, we can speed it up a little by only testing odd numbers greater than 2. def isPrime2(n): if n==2 or n==3: return True if n%2==0 or n<2: return False for i in range(3, int(n**0.5)+1, 2): # only odd numbers if n%i==0: return False return True OK -- that speeds it up by about 30% (I benchmarked it...) The algorithm I used is about 2x times faster still, since only every 6th integer is looping through the loop. (Once again, I benchmarked it.) Side note 2: primality testing is an interesting problem in computer science.\n\nWith , you are not squaring n, but taking the square root. Consider the number 20; the integer factors are 1, 2, 4, 5, 10, and 20. When you divide 20 by 2 and get 10, you know that it is also divisible by 10, without having to check. When you divide it by 4 and get 5, you know it is divisible by both 4 and 5, without having to check for 5. After reaching this halfway point in the factors, you will have no more numbers to check which you haven't already recognized as factors earlier. Therefore, you only need to go halfway to see if something is prime, and this halfway point can be found by taking the number's square root. Also, the reason 1 isn't a prime number is because prime numbers are defined as having 2 factors, 1 and itself. i.e 2 is 1*2, 3 is 1*3, 5 is 1*5. But 1 (1*1) only has 1 factor, itself. Therefore, it doesn't meet this definition.\n\nimport math def isPrime(n): 'Returns True if n is prime, False if n is not prime. Will not work if n is 0 or 1' # Make sure n is a positive integer n = abs(int(n)) # Case 1: the number is 2 (prime) if n == 2: return True # Case 2: the number is even (not prime) if n % 2 == 0: return False # Case 3: the number is odd (could be prime or not) # Check odd numbers less than the square root for possible factors r = math.sqrt(n) x = 3 while x <= r: if n % x == 0: return False # A factor was found, so number is not prime x += 2 # Increment to the next odd number # No factors found, so number is prime return True To answer the original question, n**0.5 is the same as the square of root of n. You can stop checking for factors after this number because a composite number will always have a factor less than or equal to its square root. This is faster than say just checking all of the factors between 2 and n for every n, because we check fewer numbers, which saves more time as n grows.\n\nI don't know if I am late but I will leave this here to help someone in future. We use the square root of (n) i.e int(n**0.5) to reduce the range of numbers your program will be forced to calculate. For example, we can do a trial division to test the primality of 100. Let's look at all the divisors of 100: 2, 4, 5, 10, 20, 25, 50 Here we see that the largest factor is 100/2 = 50. This is true for all n: all divisors are less than or equal to n/2. If we take a closer look at the divisors, we will see that some of them are redundant. If we write the list differently: 100 = 2 × 50 = 4 × 25 = 5 × 20 = 10 × 10 = 20 × 5 = 25 × 4 = 50 × 2 the redundancy becomes obvious. Once we reach 10, which is √100, the divisors just flip around and repeat. Therefore, we can further eliminate testing divisors greater than √n. Take another number like 16. You can note that after reaching 4, which is the square root of 16, we repeated 8 * 2 which we had already done as 2*8. This pattern is true for all numbers. To avoid repeating ourselves, we thus test for primality up to the square root of a number n. So we convert the square root to int because we do not want a range with floating numbers. Read the primality test on wikipedia for more info.\n\nWe know natural numbers starting from 2: {2, 3, 4, 5, 6, 7, ...} are considered prime if they are only divisible by 1 and themselves. The first and only even prime is 2. The next prime numbers are: 3, 5, 7, 11, 13, 17, 19, 23, 29, ..., and infinitely many more primes. Programmatically, there are many algorithms involving prime numbers. The most simple and inefficient way (naive version) is to test by definition, i.e., test if N is divisible by divisor 2 [2..N-1]. This works but runs in O(N) in terms of the number of divisions. This is not the best way, and there are several possible improvements. The first improvement is to test if N is divisible by a divisor 2 [2..sqrt(N)], i.e., we stop when the divisor is greater than sqrt(N). We claim that if a * b = N, then a <= sqrt(N) or b <= sqrt(N). Quick proof by contradiction: Let’s suppose that it is not the case, i.e., a > sqrt(N) and b > sqrt(N). This implies that a * b > sqrt(N) * sqrt(N) or a * b > N. This improvement is O(sqrt(N)), which is already much faster than the previous naive version but can still be improved to be twice as fast. The second improvement is to test if N is divisible by a divisor 2 [3, 5, ..., sqrt(N)], i.e., we only test odd numbers up to sqrt(N). This is because there is only one even prime number, i.e., number 2, which can be tested separately. Here's the code for it, but you can even optimize this code for better performance. def is_prime(number): if number <= 1: return False elif number == 2: return True elif number % 2 == 0: return False else: # Check for divisibility from 3 up to the square root of the number for i in range(3, int(number**0.5) + 1, 2): if number % i == 0: return False return True num = int(input(\"Enter a number: \")) if is_prime(num): print(f\"{num} is a prime number.\") else: print(f\"{num} is not a prime number.\")\n\nRemember kids order of operations is important. Doing it like this eliminates useless branches that costs performance and checks special rare cases only when necessary. there is no need to check if unless is odd. And there is no need to check if unless is not divisible by any positive numbers other than itself and 1 because it's a rare special case. Also checking is slower, atleast in python. That's why I stopped in 3. from math import sqrt def is_prime(n): if not n%2: return n==2 if not n%3: return n==3 for i in range(5,int(sqrt(n))+1,2): if not n%i: return False return n>1 This is even faster solution, which doesn't check numbers that are multipliers of 2 and 3 (in the loop) instead of 2 only. Btw, I stored to prevent the while loop from calculating it every iteration. def is_prime(n): if not n&1: return n==2 if not n%3: return n==3 i,r=5,int(sqrt(n)) while i<=r: if not n%i or not n%(i+2): return False i+=6 return n>1\n\nTo answer the question in the title: use . To answer your question about the \"square-rooting\": to check whether n is prime, it is sufficient to look for factors up to √n, because for any larger factor q, one would have the smaller factor n/q. Concerning the given algorithm, it is extremely inefficient to trial-divide by all numbers from 2 up to √n, because almost all of them (*) are not primes, and it's useless to try those, because if n were a multiple of i = p * q, then it would also be a multiple of the smaller factor p which would have been found much earlier. So one should at least check only the odd numbers i, which is extremely easy: just use with a step size — of course after first checking that n indeed is odd (with ). The \"better\" option to check only prime divisors would be more complicated and maybe not even more efficient, if you don't have/want to create a sufficiently large list of \"precomputed\" primes.) (*) \"almost all\" has precise mathematical meanings (google it), but here it is sufficient to read it as \"the vast majority\" - in particular, all even numbers > 2."
    },
    {
        "link": "https://upgrad.com/tutorials/software-engineering/python-tutorial/sum-of-prime-numbers-in-python",
        "document": "A prime number in Python is a number greater than 1 that has no divisors other than 1 and itself. Examples of prime numbers are 2, 3, 5, 7, and so on.\n\nYou’ll look at how the sum of prime numbers in Python using for loop, and other techniques. It can be tricky to check if a number is prime, especially when you want to sum a series of prime numbers efficiently.\n\nBy the end of this article, you will be able to calculate sum of n prime numbers in Python boosting your understanding of loops and prime number logic in Python.\n\n“Enhance your Python skills further with our and from top universities — take the next step in your learning journey!”\n\nFind the Sum of All Prime Numbers Using For Loop\n\nLet’s look at how to calculate the sum of prime numbers in using a .\n• None\n• None This function checks if a given number num is prime.\n• Base case : If num is less than or equal to 1, it returns False because 1 is not a prime number.\n• Divisibility check : The loop runs from 2 to the square root of num. If num is divisible by any number in this range, it's not prime, and the function returns False.\n• None If no divisors are found, the function returns True, indicating that num is prime.\n• None\n• None We initialize a variable sum_primes to 0, which will store the cumulative sum of prime numbers.\n• None\n• None The loop starts from 2 because 1 is not a prime number, and iterates through all numbers from 2 up to n.\n• None Inside the loop, we check if i is prime by calling the is_prime(i) function.\n• None\n• None If i is prime, we add it to the sum_primes variable.\n• None\n• None Once the loop completes, we the total sum of prime numbers between 1 and n.\n\nWhy Use a For Loop?\n\nUsing a for loop is an intuitive and straightforward approach when you want to check each number in a sequence. This method allows you to break down the task into manageable steps—checking each number and summing the primes efficiently.\n\nThis approach works well for relatively smaller values of n where performance is not a critical concern. However, as the value of n grows, this approach can become slower because it checks each number individually.\n\nWhen to Use This Method\n• None Use the sum of prime numbers in Python using for loop when:\n• None\n• None You are dealing with smaller values of n.\n• None You prefer an easy-to-understand approach for prime number summation.\n\n“Start your coding journey with our complimentary Python courses designed just for you — dive into , explore , and engage with !”\n\nFind the Sum of All Prime Numbers Using Sieve of Eratosthenes\n\nThe Sieve of Eratosthenes is an efficient algorithm for finding all prime numbers up to a given number n. This method is especially useful when you need to find multiple primes and calculate their sum, as it eliminates non-prime numbers in an efficient manner.\n\nLet’s look at how to calculate the sum of prime numbers in Python using the Sieve of Eratosthenes.\n• None\n• None prime = [True] * (n + 1): We create a list of boolean values representing whether each number from 0 to n is prime or not. Initially, all numbers are assumed to be prime (True).\n• None prime[0] = prime[1] = False: We manually mark 0 and 1 as non-prime because by definition, they aren't prime numbers.\n• None\n• None The for p in range(2, int(n**0.5) + 1) loop iterates over numbers starting from 2 up to the square root of n. We only need to check for divisibility up to the square root of n, as factors above the square root would already have corresponding smaller factors.\n• None If prime[p] is True, it means p is a prime number, and we mark all multiples of p as non-prime (prime[i] = False).\n• None\n• None prime_sum = sum(i for i in range(2, n + 1) if prime[i]): After applying the sieve, this line sums up all the indices that are still marked as True (indicating they are prime).\n• None\n• None The program calculates the sum of all primes up to n and prints the result.\n\nWhy Use the Sieve of Eratosthenes?\n\nThe Sieve of Eratosthenes is much more efficient than using a for loop for checking each number individually. The works in O(n log log n) time complexity, making it far more suitable for larger values of n compared to methods that check each number's primality individually, which can take O(n * sqrt(n)) time.\n\nFind the Sum of All Prime Numbers Using the Miller-Rabin Primality Test Method\n\nThe Miller-Rabin primality test is an efficient probabilistic algorithm used to check if a number is prime. Unlike the Sieve of Eratosthenes, which finds all primes up to n, the Miller-Rabin test is used for testing the primality of individual numbers.\n\nIt is particularly useful when dealing with large numbers due to its efficiency.\n\nThe Miller-Rabin primality test is a probabilistic algorithm, which means it can occasionally produce a false positive. However, by running the test multiple times, we can reduce the probability of such errors. It works by checking if a number passes certain conditions that hold for prime numbers.\n\nHere is the Python code to find the sum of prime numbers in Python:\n• None\n• None The function miller_rabin(n, k) checks if a number n is prime by performing k iterations of the test. Each iteration involves choosing a random base a, calculating a^d % n, and checking certain conditions to determine primality.\n• Base Case : If n <= 1, the number is not prime. If n == 2, the number is prime. If n is even, it is not prime.\n• None The number is expressed as n-1 = d * 2^r. The test checks if a^d % n equals 1 or n-1 and performs additional checks for non-trivial square roots\n• None\n• None sum_of_primes(n) iterates through each number from 2 to n, checking if each number is prime using the miller_rabin(i) function. If the number is prime, it is added to the sum_primes variable.\n• None\n• None After the loop completes, the sum of all prime numbers up to n is printed. For example, the sum of prime numbers up to 10 is 17, since the primes are 2, 3, 5, and 7.\n\nWhy Use the Miller-Rabin Primality Test?\n\nThe Miller-Rabin primality test is much faster than traditional methods for large numbers because it avoids checking every possible divisor. While it is a probabilistic test, it’s very efficient and can be made extremely accurate by running the test multiple times (adjustable with the k parameter).\n\nThis method is particularly useful for:\n• Large number primality testing : When you need to check the primality of very large numbers, such as in cryptography or number theory.\n• Efficiency : The Miller-Rabin test is faster for large values of n compared to traditional for loop methods of checking divisibility.\n\nAlso Read: Perfect Number Program In Python: How to check if a number is perfect or not?\n\n1. What is the sum of prime numbers in Python using for loop?\n\nThe sum of prime numbers in Python using for loop refers to the process of iterating through numbers, checking if they are prime, and summing the prime numbers found.\n\n2. How can I calculate the sum of n prime numbers in Python?\n\nTo calculate the sum of n prime numbers in Python, you can use a for loop to check if each number from 2 to n is prime and add them to the sum.\n\n3. What is the Miller-Rabin primality test?\n\nThe Miller-Rabin primality test is a probabilistic algorithm used to determine if a number is prime. It is more efficient for larger numbers compared to traditional primality tests.\n\n4. How do I find the sum of prime numbers in Python using the Sieve of Eratosthenes?\n\nThe Sieve of Eratosthenes finds all primes up to n by iterating through numbers and marking the multiples of each prime as non-prime. You can sum the primes found in this way.\n\n5. Can I use the sum of n prime numbers in Python with recursion?\n\nYes, you can use recursion to check if a number is prime and calculate the sum of n prime numbers in Python by recursively summing primes up to n.\n\n6. What is the time complexity of the Miller-Rabin test for large numbers?\n\nThe Miller-Rabin test runs in O(k log n) time complexity, where k is the number of iterations. This makes it much faster than traditional primality testing for large numbers.\n\n7. How does the for loop method for prime number summation compare to other methods?\n\nThe for loop method is straightforward but slower for large n compared to optimized methods like the Sieve of Eratosthenes or Miller-Rabin primality test.\n\n8. Is the Sieve of Eratosthenes method more efficient than the for loop method?\n\nYes, the Sieve of Eratosthenes is more efficient for finding multiple primes up to n because it avoids checking each number individually, unlike the sum of prime numbers in Python using for loop.\n\nYes, the Miller-Rabin test is probabilistic, meaning it can return false positives. However, increasing the number of iterations reduces this probability.\n\n10. Which method is the best for finding the sum of prime numbers in Python?\n\nFor small n, the sum of prime numbers in Python using for loop works fine. For larger values, the Sieve of Eratosthenes or Miller-Rabin test is more efficient. Choose based on the problem size.\n\n11. What is the difference between checking prime numbers using for loop and using the Miller-Rabin test?\n\nThe for loop method checks divisibility for each number, making it slower for large n. The Miller-Rabin test is a faster, probabilistic method for checking primality, especially with large numbers."
    },
    {
        "link": "https://geeksforgeeks.org/count-sum-of-digits-in-numbers-from-1-to-n",
        "document": "Compute sum of digits in all numbers from 1 to n\n\nGiven a number n, the task is to find the sum of digits in all numbers from 1 to n.\n\nThe idea is to traverse every number x from 1 to n and compute the sum in x by traversing all its digits.\n\n// C++ program to compute sum of // digits in numbers from 1 to n // of digits in a given number x // Returns sum of all digits in // One by one compute sum of digits // in every number from 1 to n // digits in numbers from 1 to n // of digits in a given number x // Returns sum of all digits in // One by one compute sum of digits // in every number from 1 to n # digits in numbers from 1 to n # of digits in a given number x # Returns sum of all digits in # One by one compute sum of digits # in every number from 1 to n // C# program to compute sum of // digits in numbers from 1 to n // of digits in a given number x // Returns sum of all digits in // One by one compute sum of digits // in every number from 1 to n // digits in numbers from 1 to n // of digits in a given number x // Returns sum of all digits in // One by one compute sum of digits // in every number from 1 to n\n\nAbove is a naive solution. We can do it more efficiently by finding a pattern.\n\nLet us take a few examples.\n\nIn general, we can compute sum(10d– 1) using the below formula:\n\nIn the below implementation, the above formula is implemented using dynamic programming as there are overlapping subproblems.\n\nBelow is the complete algorithm to find for sum(n)\n• None Find number of digits minus one in n. Let this value be ‘d\n• sum of digits 1 to 10d – 1. Let this sum be w 328 , we compute sum of digits from 1 to 99\n• sum is sum of following terms:\n• 1 to “msd * 10d – 1″. 328 , sum of digits in numbers from 1 to 299 3*sum(99) + (1 + 2)*100 sum(299) is sum(99) + sum of digits from 100 to 199 + sum of digits from 200 to 299. Sum of 100 to 199 is sum(99) + 1*100 and sum of 299 is sum(99) + 2*100. In general, this sum can be computed as w*msd + (msd*(msd-1)/2)*10d\n• msd * 10d to n 328 , sum of digits in 300 to 328. For 328, this sum is computed as 3*29 + recursive call “sum(28)” . In general, this sum can be computed as msd * (n % (msd*10d) + 1) + sum(n % (10d))\n\nBelow is the implementation of the above algorithm.\n\n// C++ program to compute sum of // digits in numbers from 1 to n // Function to computer sum of digits in numbers from 1 to n // Comments use example of 328 to explain the code // d = number of digits minus one in n. For 328, d is 2 // computing sum of digits from 1 to 10^d-1, // d=2 a[1]=sum of digit from 1 to 9 = 45 // d=3 a[2]=sum of digit from 1 to 99 = a[1]*10 + 45*10^1 = 900 // d=4 a[3]=sum of digit from 1 to 999 = a[2]*10 + 45*10^2 = 13500 // For 328, msd is 3 which can be obtained using 328/100 // EXPLANATION FOR FIRST and SECOND TERMS IN BELOW LINE OF CODE // First two terms compute sum of digits from 1 to 299 // (sum of digits in range 1-99 stored in a[d]) + // (sum of digits in range 100-199, can be calculated as 1*100 + a[d] // (sum of digits in range 200-299, can be calculated as 2*100 + a[d] // The above sum can be written as 3*a[d] + (1+2)*100 // EXPLANATION FOR THIRD AND FOURTH TERMS IN BELOW LINE OF CODE // The last two terms compute sum of digits in number from 300 to 328 // The third term adds 3*29 to sum as digit 3 occurs in all numbers // digits in numbers from 1 to n // Function to compute sum of digits in numbers from 1 to n // Comments use example of 328 to explain the code // d = number of digits minus one in n. For 328, d is 2 // computing sum of digits from 1 to 10^d-1, // d=2 a[1]=sum of digit from 1 to 9 = 45 // d=3 a[2]=sum of digit from 1 to 99 = a[1]*10 + 45*10^1 = 900 // d=4 a[3]=sum of digit from 1 to 999 = a[2]*10 + 45*10^2 = 13500 // For 328, msd is 3 which can be obtained using 328/100 // EXPLANATION FOR FIRST and SECOND TERMS IN BELOW LINE OF CODE // First two terms compute sum of digits from 1 to 299 // (sum of digits in range 1-99 stored in a[d]) + // (sum of digits in range 100-199, can be calculated as 1*100 + a[d] // (sum of digits in range 200-299, can be calculated as 2*100 + a[d] // The above sum can be written as 3*a[d] + (1+2)*100 // EXPLANATION FOR THIRD AND FOURTH TERMS IN BELOW LINE OF CODE // The last two terms compute sum of digits in number from 300 to 328 // The third term adds 3*29 to sum as digit 3 occurs in all numbers # digits in numbers from 1 to n # Function to compute sum of digits in numbers from 1 to n # Comments use example of 328 to explain the code # d = number of digits minus one in n. For 328, d is 2 # computing sum of digits from 1 to 10^d-1, # d=2 a[1]=sum of digit from 1 to 9 = 45 # d=3 a[2]=sum of digit from 1 to 99 = a[1]*10 + 45*10^1 = 900 # d=4 a[3]=sum of digit from 1 to 999 = a[2]*10 + 45*10^2 = 13500 # For 328, msd is 3 which can be obtained using 328//100 # EXPLANATION FOR FIRST and SECOND TERMS IN BELOW LINE OF CODE # First two terms compute sum of digits from 1 to 299 # (sum of digits in range 1-99 stored in a[d]) + # (sum of digits in range 100-199, can be calculated as 1*100 + a[d] # (sum of digits in range 200-299, can be calculated as 2*100 + a[d] # The above sum can be written as 3*a[d] + (1+2)*100 # EXPLANATION FOR THIRD AND FOURTH TERMS IN BELOW LINE OF CODE # The last two terms compute sum of digits in number from 300 to 328 # The third term adds 3*29 to sum as digit 3 occurs in all numbers // C# program to compute sum of // digits in numbers from 1 to n // Function to compute sum of digits in numbers from 1 to n // Comments use example of 328 to explain the code // d = number of digits minus one in n. For 328, d is 2 // computing sum of digits from 1 to 10^d-1, // d=2 a[1]=sum of digit from 1 to 9 = 45 // d=3 a[2]=sum of digit from 1 to 99 = a[1]*10 + 45*10^1 = 900 // d=4 a[3]=sum of digit from 1 to 999 = a[2]*10 + 45*10^2 = 13500 // For 328, msd is 3 which can be obtained using 328/100 // EXPLANATION FOR FIRST and SECOND TERMS IN BELOW LINE OF CODE // First two terms compute sum of digits from 1 to 299 // (sum of digits in range 1-99 stored in a[d]) + // (sum of digits in range 100-199, can be calculated as 1*100 + a[d] // (sum of digits in range 200-299, can be calculated as 2*100 + a[d] // The above sum can be written as 3*a[d] + (1+2)*100 // EXPLANATION FOR THIRD AND FOURTH TERMS IN BELOW LINE OF CODE // The last two terms compute sum of digits in number from 300 to 328 // The third term adds 3*29 to sum as digit 3 occurs in all numbers // digits in numbers from 1 to n // Function to compute sum of digits in numbers from 1 to n // Comments use example of 328 to explain the code // d = number of digits minus one in n. For 328, d is 2 // computing sum of digits from 1 to 10^d-1, // d=2 a[1]=sum of digit from 1 to 9 = 45 // d=3 a[2]=sum of digit from 1 to 99 = a[1]*10 + 45*10^1 = 900 // d=4 a[3]=sum of digit from 1 to 999 = a[2]*10 + 45*10^2 = 13500 // For 328, msd is 3 which can be obtained using 328/100 // EXPLANATION FOR FIRST and SECOND TERMS IN BELOW LINE OF CODE // First two terms compute sum of digits from 1 to 299 // (sum of digits in range 1-99 stored in a[d]) + // (sum of digits in range 100-199, can be calculated as 1*100 + a[d] // (sum of digits in range 200-299, can be calculated as 2*100 + a[d] // The above sum can be written as 3*a[d] + (1+2)*100 // EXPLANATION FOR THIRD AND FOURTH TERMS IN BELOW LINE OF CODE // The last two terms compute sum of digits in number from 300 to 328 // The third term adds 3*29 to sum as digit 3 occurs in all numbers\n\nThe efficient algorithm has one more advantage that we need to compute the array ‘a[]’ only once even when we are given multiple inputs."
    }
]