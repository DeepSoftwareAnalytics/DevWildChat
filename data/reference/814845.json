[
    {
        "link": "https://docs.soliditylang.org/en/latest/security-considerations.html",
        "document": "While it is usually quite easy to build software that works as expected, it is much harder to check that nobody can use it in a way that was not anticipated.\n\nIn Solidity, this is even more important because you can use smart contracts to handle tokens or, possibly, even more valuable things. Furthermore, every execution of a smart contract happens in public and, in addition to that, the source code is often available.\n\nOf course, you always have to consider how much is at stake: You can compare a smart contract with a web service that is open to the public (and thus, also to malicious actors) and perhaps even open-source. If you only store your grocery list on that web service, you might not have to take too much care, but if you manage your bank account using that web service, you should be more careful.\n\nThis section will list some pitfalls and general security recommendations but can, of course, never be complete. Also, keep in mind that even if your smart contract code is bug-free, the compiler or the platform itself might have a bug. A list of some publicly known security-relevant bugs of the compiler can be found in the list of known bugs, which is also machine-readable. Note that there is a Bug Bounty Program that covers the code generator of the Solidity compiler.\n\nAs always, with open-source documentation, please help us extend this section (especially, some examples would not hurt)!\n\nNOTE: In addition to the list below, you can find more security recommendations and best practices in Guy Lando’s knowledge list and the Consensys GitHub repo.\n\nEverything you use in a smart contract is publicly visible, even local variables and state variables marked . Using random numbers in smart contracts is quite tricky if you do not want block builders to be able to cheat. Any interaction from a contract (A) with another contract (B) and any transfer of Ether hands over control to that contract (B). This makes it possible for B to call back into A before this interaction is completed. To give an example, the following code contains a bug (it is just a snippet and not a complete contract): // THIS CONTRACT CONTAINS A BUG - DO NOT USE /// @dev Mapping of ether shares of the contract. shares send shares shares The problem is not too serious here because of the limited gas as part of , but it still exposes a weakness: Ether transfer can always include code execution, so the recipient could be a contract that calls back into . This would let it get multiple refunds and, basically, retrieve all the Ether in the contract. In particular, the following contract will allow an attacker to refund multiple times as it uses which forwards all remaining gas by default: // THIS CONTRACT CONTAINS A BUG - DO NOT USE /// @dev Mapping of ether shares of the contract. shares call value shares success shares To avoid reentrancy, you can use the Checks-Effects-Interactions pattern as demonstrated below: /// @dev Mapping of ether shares of the contract. shares shares shares transfer share The Checks-Effects-Interactions pattern ensures that all code paths through a contract complete all required checks of the supplied parameters before modifying the contract’s state (Checks); only then it makes any changes to the state (Effects); it may make calls to functions in other contracts after all planned state changes have been written to storage (Interactions). This is a common foolproof way to prevent reentrancy attacks, where an externally called malicious contract can double-spend an allowance, double-withdraw a balance, among other things, by using logic that calls back into the original contract before it has finalized its transaction. Note that reentrancy is not only an effect of Ether transfer but of any function call on another contract. Furthermore, you also have to take multi-contract situations into account. A called contract could modify the state of another contract you depend on. Loops that do not have a fixed number of iterations, for example, loops that depend on storage values, have to be used carefully: Due to the block gas limit, transactions can only consume a certain amount of gas. Either explicitly or just due to normal operation, the number of iterations in a loop can grow beyond the block gas limit which can cause the complete contract to be stalled at a certain point. This may not apply to functions that are only executed to read data from the blockchain. Still, such functions may be called by other contracts as part of on-chain operations and stall those. Please be explicit about such cases in the documentation of your contracts.\n• None Neither contracts nor “external accounts” are currently able to prevent someone from sending them Ether. Contracts can react on and reject a regular transfer, but there are ways to move Ether without creating a message call. One way is to simply “mine to” the contract address and the second way is using .\n• None If a contract receives Ether (without a function being called), either the receive Ether or the fallback function is executed. If it does not have a nor a function, the Ether will be rejected (by throwing an exception). During the execution of one of these functions, the contract can only rely on the “gas stipend” it is passed (2300 gas) being available to it at that time. This stipend is not enough to modify storage (do not take this for granted though, the stipend might change with future hard forks). To be sure that your contract can receive Ether in that way, check the gas requirements of the receive and fallback functions (for example in the “details” section in Remix).\n• None There is a way to forward more gas to the receiving contract using . This is essentially the same as , only that it forwards all remaining gas and opens up the ability for the recipient to perform more expensive actions (and it returns a failure code instead of automatically propagating the error). This might include calling back into the sending contract or other state changes you might not have thought of. So it allows for great flexibility for honest users but also for malicious actors.\n• None Use the most precise units to represent the Wei amount as possible, as you lose any that is rounded due to a lack of precision.\n• None If you want to send Ether using , there are certain details to be aware of:\n• None If the recipient is a contract, it causes its receive or fallback function to be executed which can, in turn, call back the sending contract.\n• None Sending Ether can fail due to the call depth going above 1024. Since the caller is in total control of the call depth, they can force the transfer to fail; take this possibility into account or use and make sure to always check its return value. Better yet, write your contract using a pattern where the recipient can withdraw Ether instead.\n• None Sending Ether can also fail because the execution of the recipient contract requires more than the allotted amount of gas (explicitly by using require, assert, revert or because the operation is too expensive) - it “runs out of gas” (OOG). If you use or with a return value check, this might provide a means for the recipient to block progress in the sending contract. Again, the best practice here is to use a “withdraw” pattern instead of a “send” pattern. External function calls can fail at any time because they exceed the maximum call stack size limit of 1024. In such situations, Solidity throws an exception. Malicious actors might be able to force the call stack to a high value before they interact with your contract. Note that, since Tangerine Whistle hardfork, the 63/64 rule makes call stack depth attack impractical. Also note that the call stack and the expression stack are unrelated, even though both have a size limit of 1024 stack slots. Note that does not throw an exception if the call stack is depleted but rather returns in that case. The low-level functions , and behave in the same way. If your contract can act as a proxy, i.e. if it can call arbitrary contracts with user-supplied data, then the user can essentially assume the identity of the proxy contract. Even if you have other protective measures in place, it is best to build your contract system such that the proxy does not have any permissions (not even for itself). If needed, you can accomplish that using a second proxy: PermissionlessProxy proxy payload proxy callOther addr payload // Other functions and other functionality // This is the full contract, it has no other functionality and payload addr call payload Never use for authorization. Let’s say you have a wallet contract like this: // THIS CONTRACT CONTAINS A BUG - DO NOT USE owner dest // THE BUG IS RIGHT HERE, you must use msg.sender instead of tx.origin owner dest transfer amount Now someone tricks you into sending Ether to the address of this attack wallet: If your wallet had checked for authorization, it would get the address of the attack wallet, instead of the owner’s address. But by checking , it gets the original address that kicked off the transaction, which is still the owner’s address. The attack wallet instantly drains all your funds. As in many programming languages, Solidity’s integer types are not actually integers. They resemble integers when the values are small, but cannot represent arbitrarily large numbers. The following code causes an overflow because the result of the addition is too large to be stored in the type : Solidity has two modes in which it deals with these overflows: Checked and Unchecked or “wrapping” mode. The default checked mode will detect overflows and cause a failing assertion. You can disable this check using , causing the overflow to be silently ignored. The above code would return if wrapped in . Even in checked mode, do not assume you are protected from overflow bugs. In this mode, overflows will always revert. If it is not possible to avoid the overflow, this can lead to a smart contract being stuck in a certain state. In general, read about the limits of two’s complement representation, which even has some more special edge cases for signed numbers. Try to use to limit the size of inputs to a reasonable range and use the SMT checker to find potential overflows. The Solidity type (see Mapping Types) is a storage-only key-value data structure that does not keep track of the keys that were assigned a non-zero value. Because of that, cleaning a mapping without extra information about the written keys is not possible. If a is used as the base type of a dynamic storage array, deleting or popping the array will have no effect over the elements. The same happens, for example, if a is used as the type of a member field of a that is the base type of a dynamic storage array. The is also ignored in assignments of structs or arrays containing a . Consider the example above and the following sequence of calls: , . At this point, calling returns 256. If we call , the length of the state variable is zeroed, but since its elements cannot be zeroed, their information stays alive in the contract’s storage. After deleting , calling allows us to access again, and calling returns 256 even without another call to . If your information must be deleted, consider using a library similar to iterable mapping, allowing you to traverse the keys and delete their values in the appropriate . Updating the code of your contract may invalidate the values of variables of internal function types. Consider such values ephemeral and avoid storing them in state variables. If you do, you must ensure that they never persist across code updates and are never used by other contracts having access to the same storage space as a result of a delegatecall or account abstraction.\n• None Types that do not occupy the full 32 bytes might contain “dirty higher order bits”. This is especially important if you access - it poses a malleability risk: You can craft transactions that call a function with a raw byte argument of and with . Both are fed to the contract and both will look like the number as far as is concerned, but will be different, so if you use for anything, you will get different results.\n\nIf the compiler warns you about something, you should change it. Even if you do not think that this particular warning has security implications, there might be another issue buried beneath it. Any compiler warning we issue can be silenced by slight changes to the code. Always use the latest version of the compiler to be notified about all recently introduced warnings. Messages of type , issued by the compiler, are not dangerous and simply represent extra suggestions and optional information that the compiler thinks might be useful to the user. Restrict the amount of Ether (or other tokens) that can be stored in a smart contract. If your source code, the compiler or the platform has a bug, these funds may be lost. If you want to limit your loss, limit the amount of Ether. Keep it Small and Modular Keep your contracts small and easily understandable. Single out unrelated functionality in other contracts or into libraries. General recommendations about the source code quality of course apply: Limit the amount of local variables, the length of functions and so on. Document your functions so that others can see what your intention was and whether it is different than what the code does. Most functions will first perform some checks and they should be done first (who called the function, are the arguments in range, did they send enough Ether, does the person have tokens, etc.). As the second step, if all checks passed, effects to the state variables of the current contract should be made. Interaction with other contracts should be the very last step in any function. Early contracts delayed some effects and waited for external function calls to return in a non-error state. This is often a serious mistake because of the reentrancy problem explained above. Note that, also, calls to known contracts might in turn cause calls to unknown contracts, so it is probably better to just always apply this pattern. While making your system fully decentralized will remove any intermediary, it might be a good idea, especially for new code, to include some kind of fail-safe mechanism: You can add a function in your smart contract that performs some self-checks like “Has any Ether leaked?”, “Is the sum of the tokens equal to the balance of the contract?” or similar things. Keep in mind that you cannot use too much gas for that, so help through off-chain computations might be needed there. If the self-check fails, the contract automatically switches into some kind of “failsafe” mode, which, for example, disables most of the features, hands over control to a fixed and trusted third party or just converts the contract into a simple “give me back my Ether” contract. The more people examine a piece of code, the more issues are found. Asking people to review your code also helps as a cross-check to find out whether your code is easy to understand - a very important criterion for good smart contracts."
    },
    {
        "link": "https://ethereum.stackexchange.com/questions/120410/re-entrancy-attack-solidity-0-8-10",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://dev.to/hackthechain/understanding-solidity-smart-contract-attack-vectors-an-introductory-guide-4jo1",
        "document": "Smart contracts have transformed transactions and agreements on the Ethereum blockchain, offering trustless, automated, and immutable solutions. Solidity, the main programming language for smart contracts, enables developers to create complex and innovative decentralized applications (DApps). However, this power comes with significant responsibility. Ensuring the security of smart contracts is crucial, as vulnerabilities can result in major financial losses and damage trust in the blockchain.\n\nThis guide introduces the common and advanced attack vectors targeting Solidity smart contracts. We cover reentrancy attacks, integer overflows, Denial of Service, and Invariant breaks, among others. Each section includes a brief overview of an attack, real-world examples, mitigation strategies, and links for further reading.\n\nUnderstanding these vulnerabilities and adopting best practices for secure smart contract development can greatly reduce the risk of exploits and help maintain a safer blockchain environment. Explore the essential aspects of Solidity smart contract security that every developer needs to know.\n\nIn recent years, billions of dollars in cryptocurrencies have been lost due to smart contract vulnerabilities. Notable incidents, like the DAO attack in 2016 which resulted in a $60 million loss of Ether, underscore the urgent need for better security.\n\nEach vector poses unique challenges, but with proper awareness and mitigation techniques, these risks can be minimized. The following sections provide brief introductions to each attack vector, along with links for detailed discussions, attack reproductions, and defense strategies.\n\nA reentrancy attack happens when a contract calls an external contract before updating its state. This allows the external contract to repeatedly call back into the original contract, potentially exploiting the un-updated state.\n\nConsider a contract with a withdraw function that sends Ether to a caller before updating the balance.\n\n\n\nIn this example, the function in the contract sends Ether to the caller ( ) before updating their balance.\n\nAn contract can exploit this by using its function to repeatedly call , draining the contract's funds.\n• Checks-Effects-Interactions Pattern: Ensures all checks and state updates occur before interacting with external contracts.\n• Checks: Verify the caller has enough balance.\n• Using Reentrancy Guards: The contract from OpenZeppelin, prevents reentrant calls by using a state variable to lock the contract during execution.\n\nInteger Overflow happens when a calculation produces a number larger than the maximum that can be stored in that type of integer. For instance, in an 8-bit unsigned integer ( ), the maximum value is 255. Adding 1 to 255 in this type would result in 0 due to overflow.\n\nInteger Underflow, on the other hand, occurs when a calculation results in a number smaller than the minimum that can be stored. For example, subtracting 1 from 0 in a type would wrap around 255 instead of going negative, because the type cannot store negative numbers.\n\nIn this example, if the total supply of tokens approaches the maximum value for uint256 (2^256 - 1), adding more tokens that exceed this limit causes an overflow. This overflow wraps the total supply to a significantly lower number, potentially enabling an attacker to mint an unusually large number of tokens.\n\nTo prevent vulnerabilities, use the SafeMath library. It includes functions like add, subtract, multiply, and divide, all of which check for overflow and underflow. For instance, ensures that adding b to a won't cause an overflow; if it would, the operation is reversed to keep the contract valid.\n\n\n\nFrom Solidity version 0.8.0 onwards, the language includes built-in checks for overflow and underflow. This means that any arithmetic operation that results in overflow or underflow will automatically revert the transaction.\n\nA Denial of Service (DoS) attack in the context of smart contracts is an attempt to prevent contract functions from executing properly. This can be achieved by consuming excessive resources, manipulating gas limits, or exploiting vulnerabilities in the contract’s logic.\n\nAn attacker might send a transaction with a large amount of gas to a contract function that has a loop or an expensive operation. This can cause the function to run out of gas and fail to execute.\n\nConsider a contract function that processes an array of user addresses. If the array is too large, the function may exceed the block gas limit and fail, preventing the contract from functioning correctly.\n\n\n\nIn this example, if the array becomes too large, the function may run out of gas, causing a DoS.\n• Gas Limit Management: Limit the amount of work a function can do in a single transaction by using fixed-size data structures or limiting the number of iterations in loops.\n\nDesign functions to minimize the risk of DoS by avoiding unbounded loops and expensive operations that depend on user input.\n\nYou can also break large operations into smaller, manageable pieces that can be executed over multiple transactions.\n\n\n\nAccess control issues occur when authorization checks in a smart contract are not properly implemented. This can let unauthorized users perform restricted actions, which could lead to serious security breaches.\n\nIf a contract does not correctly verify the sender’s identity, unauthorized users may gain admin privileges and perform restricted actions such as changing contract settings or transferring funds.\n\n\n\nIn this example, anyone can call the function and set themselves as the admin because there is no check to ensure that only the current admin can change the admin.\n\nThe contract by OpenZeppelin allows an owner, typically the contract deployer, to control certain functions. The modifier ensures these functions can only be called by the owner. The function ensures that only the current owner can transfer ownership to another address, thus securing the admin role.\n\n\n\nFor advanced access control needs, use OpenZeppelin’s contract to manage roles and permissions.\n\nThe contract enables precise role-based access control. Roles are identified using , and you can assign or remove roles from addresses. The modifier verifies if an address possesses the required role to execute a function.\n\n\n\nCentralization in smart contracts means that control over important functions or assets is concentrated in one entity or a small group. This setup can pose risks like censorship, single points of failure, and abuse of power due to the lack of decentralization.\n\nRug pulling occurs when the creator or administrator of a decentralized application (DApp) or smart contract unexpectedly withdraws all funds, causing significant financial losses to users who have invested or deposited funds.\n\n\n\nIn this example, the function lets the owner take out all funds and shut down the contract, leaving users unable to recover any deposited funds.\n• None Decentralization and Community Governance: Implement decentralized governance mechanisms where critical decisions are made collectively by the community rather than by a single entity. Use governance tokens or decentralized autonomous organizations (DAOs) to distribute control and decision-making power among stakeholders.\n• None Transparency and Audits: Ensure transparency in contract operations and conduct regular security audits by independent third parties to verify the integrity and security of the smart contract code.\n• None Open Source and Code Review: Make smart contract code open source to allow community scrutiny and encourage peer review. This helps identify vulnerabilities and ensures that the contract operates as intended without hidden functionalities.\n• None Multi-Signature Wallets: Use multi-signature wallets for managing contract funds or making critical decisions. This distributes control among multiple parties and prevents any single entity from unilaterally accessing funds or performing actions.\n• None Timelocks and Emergency Stops: Implement timelocks or emergency stop mechanisms that require a waiting period before executing critical transactions or stopping contract operations. This provides a window for intervention or dispute resolution in case of unexpected events.\n\nOracle manipulation involves using external data sources (oracles) that smart contracts depend on. If these oracles provide incorrect or malicious data, it can lead to problems like inaccurate pricing, triggering unintended transactions, or causing financial harm.\n\nA decentralized exchange (DEX) relies on an oracle to fetch external price data for trading pairs. If an attacker gains control over or manipulates this oracle, they could provide false price information that benefits them (e.g., setting a much lower price for buying tokens than the actual market price).\n\nIn the example below, the DEX contract fetches token prices from an oracle but does not verify or validate the data received. If the oracle provides manipulated or incorrect price data, the DEX may execute trades at incorrect prices, leading to financial losses for traders.\n• None Use Trusted Oracles: Utilize oracles from reputable sources or implement mechanisms to verify data integrity and authenticity before using them in smart contracts.\n• None Data Aggregation and Consensus: Use multiple oracles or data sources and implement consensus mechanisms to ensure that data is accurate and not manipulated.\n• None Price Averaging and Thresholds: Implement logic in smart contracts to use averaged prices over time or set price thresholds to detect and prevent sudden spikes or drops that could be caused by manipulated data.\n• None Security Audits: Conduct regular security audits of smart contracts, including Oracle integrations, to identify vulnerabilities and ensure robust protection against manipulation.\n\nAn invariant in refers to a condition that is expected to remain true throughout the execution of a program or a specific section of code. In the context of smart contracts, an invariant break occurs when a fundamental condition or rule established for the contract is violated during its execution. This can lead to unexpected behavior, vulnerabilities, or loss of contract integrity.\n\nLet’s consider a token contract where the invariant is that the total supply of tokens should always equal the sum of balances across all accounts. If the contract allows minting tokens without properly updating the total supply, it could lead to an invariant break.\n\n\n\nIn this example, the function increases the balance of without updating . This breaks the invariant that should always reflect the total amount of tokens in circulation.\n• None Consistent State Updates: Ensure that any state changes or updates in the contract are accompanied by corresponding updates to maintain invariants.\n• None Invariant Checks: Implement checks and validations within functions to ensure that invariants are not violated before and after executing critical operations.\n\nRegular code reviews and audits by experienced developers are crucial to identify potential vulnerabilities, ensure code quality, and verify that best practices and security guidelines are followed throughout the development process.\n\nUtilize tools such as MythX, Slither, and Echidna for static analysis, automated testing, and vulnerability detection. These tools help identify common security issues, ensure code consistency, and improve overall contract reliability.\n\nImplement upgradeable contract patterns, such as Proxy and External Storage patterns, to facilitate contract upgradability while maintaining security. Ensure that upgrade mechanisms are carefully designed and thoroughly tested to prevent unintended behavior or vulnerabilities.\n\nEngage with the developer community and encourage external reviews through bug bounty programs. Incentivize security researchers to discover and responsibly disclose vulnerabilities in your contracts. This proactive approach helps identify and mitigate potential threats before deployment.\n• None Principle of Least Privilege: Limit access and permissions for different contract functions and roles. Use access controls to enforce security and prevent unauthorized actions.\n• None Secure Coding Practices: Follow secure coding principles like validating inputs, handling external calls carefully, avoiding outdated functions, and using safe arithmetic libraries (e.g., SafeMath) to prevent common vulnerabilities such as reentrancy and integer overflows.\n• None Gas Limit Management: Optimize contract functions and consider gas limits to prevent denial-of-service attacks. Use efficient algorithms and data structures for cost-effective execution and scalable contracts.\n• None Regular Updates and Patching: Keep informed about Solidity updates and security best practices. Update contracts promptly to protect against newly discovered vulnerabilities.\n• None Documentation and Transparency: Maintain clear documentation of contract features, security considerations, and risks. Transparency helps stakeholders understand the contract's behavior and security measures.\n• None Continuous Learning and Improvement: Engage with Ethereum and smart contract communities to stay updated on threats and best practices through conferences, workshops, and active participation.\n\nSecuring Ethereum smart contracts is crucial for the reliability of decentralized applications (DApps). Preventing vulnerabilities like reentrancy, integer overflows, denial of service, access control issues, and price manipulation is key to avoiding financial losses. Best practices include thorough code reviews, automated testing, and engaging with the community through bug bounties. Adherence to secure coding practices, managing gas limits, applying security patches, and maintaining clear documentation also enhance contract security. Continuous learning and active community participation help developers stay ahead of threats and strengthen blockchain security overall."
    },
    {
        "link": "https://rareskills.io/post/solidity-beginner-mistakes",
        "document": "Try Catch and all the ways Solidity can revert This article describes all the kinds of errors that can happen when a smart contract is called, and how the Solidity Try / Catch block responds (or fails to respond) to each of them. To understand how Try / Catch works in Solidity, we must understand […]"
    },
    {
        "link": "https://medium.com/immunefi/the-ultimate-guide-to-reentrancy-19526f105ac",
        "document": "Reentrancy has a long history in Ethereum and is the vulnerability class responsible for The DAO Hack, one of the biggest attacks on the early Ethereum network in 2016. Since then, many standards have been introduced to mitigate this class of vulnerability, such as limiting gas forwarded by an external guard, reentrancy guards, and following Checks-Effects-Interactions (CEI) patterns.\n\nMany now even question reentrancy’s relevance as an important vulnerability, given widespread knowledge of the attack vector and its patterns. However, taking a look at recent hacks and events tell a different story.\n\nIt’s been some time since Paweł Kuryłowicz wrote his article on whether reentrancy attacks are still a problem in Solidity. In 2021, Pawel asked:\n\nAll this time later, are reentrancy attacks still a significant problem?\n\nThe answer is yes, and will likely continue to be yes for the foreseeable future.\n\nHow has reentrancy affected the ecosystem?\n\nSince Pawel posted his article, hundreds of millions of dollars have been lost to reentrancy attacks, most notably in Fei’s Rari Fuse Pools incident, which had a reported loss of over $80 million dollars. Even though reentrancy is the most commonly referenced smart contract bug and is many security researchers’ first introduction to smart contract security, there are many projects still falling prey to attacks which at their core are a result of reentrancy. You can take a look at affected projects in pcaversaccio’s repository A Historical Collection of Reentrancy Attacks.\n\nReentrancy is a state synchronization problem. When an external call is made to another smart contract, execution flow control is transferred. The calling contract has to make sure all globally shared state is fully synchronized before transferring control. Since the EVM is a single threaded machine, if a function does not fully synchronize state before transferring execution control, the function can be reentered with the same state as if it were being called for the first time. This can cause the function to execute actions repeatedly which were only intended to be executed once.\n\nIf we make one simple modification to the WETH contract, which wraps the native asset ether into an ERC20-compatible token, we can get a better understanding of an anti-pattern which can lead to reentrancy. The deposit function receives ether and increases the users’ balance stored in the mapping.\n\nWhen a user would like to convert their WETH back to ether, they call . When the function uses a low-level call to transfer ether to the user, execution flow is transferred to the receiver. In this example, the external call is being made before the balance is updated. If the caller is an EOA, the transfer completes successfully and execution continues within the withdraw function. However, if the caller were a smart contract, the default payable function is invoked which can be controlled to do anything we like.\n\nDuring our execution of the default payable function, the WETH contract does not know it has sent the ether yet since the mapping has not yet been modified! If we call back into the function, the require statement that checks we have enough balance of WETH to withdraw ether will pass. We’ve just hacked the WETH contract and gained infinite ether!\n\n* Once all reentrant calls resolve, the mapping is still decreased according to the number of times the function was called. In Solidity versions >= 0.8.0 this will cause the entire function to revert because of underflow/overflow checks which occur by default. However, any Solidity version below this will underflow the balance and the attacker will additionally end up with a very large balance.\n\nWhat can you do to prevent reentrancy?\n\nThe first cases of reentrancy occurred on transfers of ether, since code execution is transferred to the receiver function during a transfer of the native asset. The functions and were introduced to Address types to transfer ether, but limit the amount of gas forwarded to the receiver to restrict the logic which can be executed. This mitigated potential gas griefing risks, as well as prevented reentrancy since the inner call would run out of gas before being able to perform the necessary logic. There are downfalls to this solution, however. The use of or will break composability with smart contracts which may have some necessary logic occur in the fallback function, such as proxies, which delegate their logic to an implementation contract.\n\nUse of and has been recommended against, due to potential changes to the gas costs of opcodes which may break existing contracts that rely on the limited amount of gas passed during those calls. ConsenSys details this issue more in their article Stop Using Solidity’s transfer() Now, but because gas costs are subject to change and there are more effective ways to mitigate reentrancy risks, and should not be used if following best practices.\n\nThe most recommended and simplest way to prevent reentrancy is to implement a checks-effects-interactions (CEI) pattern. Those functions which execute external calls should ensure that all external interactions occur after any checks or state changes. This is also commonly known as the tail call pattern in traditional concurrent programming. If we were to fix the previous example in the function of WETH, we would first have the require statement which checks the user has enough WETH balance (check), make our changes to storage which updates the users balance (effect), and finally make the external call to the user to transfer the funds (interactions).\n\nFinally, if there are unknown risks which may be introduced through permissionless operation of a protocol, a may be used as a way to ensure there is no way to call the function more than once within the same call frame. OpenZeppelin provides a library for implementing ReentrancyGuards. However, the extra gas cost of performing a SLOAD and SSTORE to check if the function has already been called will increase gas costs and may not be necessary if following recommended patterns. Additionally, this type of reentrancy guard will not protect against cross-contract reentrancy.\n\n* EIP-1153 aims to reduce this cost by introducing new opcodes for data which is discarded after every transaction\n\nAny external call can lead to reentrancy if the proper CEI patterns are not being followed. Slither is an open source static analysis framework which can help auditors and bug hunters find potential entry points for reentrancy vulnerabilities. However, the following standards are a few examples of ways execution flow may be transferred to an arbitrary contract:\n• functions such as or of ERC721 tokens\n• of certain ERC20 tokens which may have implemented a custom callback function for receivers\n\nWhat are the different types of reentrancy?\n\nThis is the simplest type of reentrancy which led to The DAO Hack of $60 million dollars and the hard fork of the Ethereum network, resulting in the creation of separate blockchains, the unaltered “Ethereum Classic”, and the altered history Ethereum network we know today.\n\nSingle-function reentrancy occurs when a contract makes an external call before finalizing state changes, and the same function is reentered within the external call.\n\nAn attacker may also be able to do a similar attack using two different functions that share the same state. If the first function makes an external call before the shared data is updated, an attacker may enter the second function with the unchanged state.\n\nOpenZeppelin’s reentrancy guard may prevent this issue if both functions have a guard, since they share the same storage value as the value which is checked to tell if the function has already been called. This also prevents functions with the modifier from being called within the same call frame.\n\nReentrancy is not limited to calls to functions within the same contract. Multiple contracts which share the same state can also be susceptible to reentrancy. Again, the CEI pattern would prevent any risks of reentrancy. However, if the shared state is not updated before the external call, reentrancy could cause a critical vulnerability. You can read more about cross-contract reentrancy in this example by Phuwanai Thummavet.\n\nTypically, auditors and bug hunters are only concerned with entry points that modify state when looking for reentrancy. However, read-only reentrancy can occur when a protocol relies on reading the state of another. Most notably, Curves’ was susceptible to this type of attack by reentering the view function in the middle of removing liquidity. In many cases, this will affect protocols which rely on a pricing mechanism of another, so projects should be very careful when integrating price oracles of exchanges or other liquidity management protocols. Read more about read only reentrancy in the wild in Curve LP Oracle Manipulation: Post Mortem by Chain Security. Additionally, you can find examples of read only reentrancy in SunWeb3Sec’s DeFiVulnLabs common smart contract vulnerabilities repository.\n\nCross-chain reentrancy is the newest type of reentrancy attack which only recently started to become a concern with the rise of cross-chain messaging protocols. There is no precedent for cross-chain reentrancy attacks in the wild. However, with the rise in cross-chain interoperability and unified vision of a multi-chain future, this paradigm must be understood and reviewed by any protocols which bridge assets between chains, or utilize cross-chain messaging. An example created specifically to demonstrate cross-chain reentrancy can be seen here.\n\nThe introduction of new transient storage opcodes and in EIP-1153 presents an opportunity to improve reentrancy protections in smart contracts. These opcodes allow for the storage of data in a temporary location that is reset after a contract function completes, making it impossible for an attacker to reenter a function. Typically, reentrant guards were achieved using storage. That being said, and opcodes have significant gas costs. OpenZeppelin’s reentrancy guards may likely change to using more gas-efficient transient storage opcodes.\n\nWith the addition of these new opcodes, there are also initiatives to disable reentrancy by default at the compiler level. This would provide an additional layer of protection against reentrancy attacks and help ensure that developers are aware of the risks associated with reentrant code. The Vyper and Solidity programming languages are both considering implementing this feature, which would make it easier for developers to write secure contracts and may lead to a paradigm shift for developers when considering external calls within their smart contracts.\n\nUntil then, reentrancy attacks are still a serious concern in the world of smart contracts.\n\nTherefore, it is essential for developers to remain vigilant in their coding practices and adopt best security practices to minimize the risk of reentrancy attacks. Additionally, auditors and security researchers play a crucial role in identifying vulnerabilities and providing feedback to developers. By working together, the blockchain community can continue to improve the security of smart contracts and prevent reentrancy attacks from causing further harm through bug bounties and audits."
    },
    {
        "link": "https://medium.com/coinmonks/advanced-solidity-event-logging-and-error-handling-7262d341982a",
        "document": "Solidity, the primary language for writing smart contracts on Ethereum, has unique features to handle logging and error management. Understanding these mechanisms is essential for developing robust and maintainable decentralized applications (dApps). This article delves into the intricacies of event logging and error handling in Solidity, providing a comprehensive guide for both beginners and experienced developers.\n\nIn Solidity, events are a convenient way to log data on the Ethereum blockchain. They facilitate communication between smart contracts and their external users, enabling the creation of logs that can be easily accessed and monitored.\n\nEvents are typically emitted by smart contracts to signal that something significant has occurred. Once emitted, events are stored in the transaction logs of the blockchain, making them accessible for future reference.\n\nEvents have several practical applications in smart contract development, including:\n• Transaction Notifications: Informing external applications when a particular action has taken place within the smart contract.\n• State Changes: Logging changes in the state of the contract for auditing and debugging purposes.\n• Data Storage: Storing historical data in an efficient manner that is cheaper than using contract storage.\n\nDefining an event in Solidity is straightforward. The syntax involves the keyword followed by the event name and parameters.\n\nIn this example, we define an event with two parameters: and . The event is emitted inside the function, logging the values passed to it.\n\nIndexed parameters allow for efficient filtering of event logs. By marking a parameter with the keyword, you can create up to three indexed parameters per event, enabling faster and more targeted searches.\n\nIn this example, both and are indexed, allowing for efficient querying based on these parameters.\n\nTo listen for events emitted by a smart contract, you can use Web3.js, a popular JavaScript library for interacting with the Ethereum blockchain.\n\nFirst, you need to set up a Web3 instance and connect to an Ethereum node.\n\nThen, you can subscribe to the event using the property of the contract instance.\n\nThis code listens for the event, optionally filtering by the address and starting from block 0.\n\nLet’s consider a more practical example: a simple voting contract.\n\nIn this example, we define two events, and , to log voting activities and the addition of new proposals. These events can be listened to in a dApp to update the UI in real-time whenever a vote is cast or a new proposal is added.\n\nError handling is crucial in smart contract development to ensure the integrity and reliability of the contract. Effective error handling helps prevent unexpected behaviors, secure funds, and provide meaningful feedback to users and developers.\n\nIn Solidity, errors can be broadly categorized into:\n• Assertion Failures: Using to enforce invariants and check internal errors.\n• Requirement Failures: Using to validate inputs and conditions.\n• Reversions: Using to handle errors explicitly and revert the state.\n\nis used to check for conditions that should never be false. It is typically used to enforce invariants within the code. If an statement fails, it indicates a bug in the contract.\n\nIn this example, ensures that the addition operation does not overflow.\n\nis used to validate inputs and conditions before executing the rest of the function. It is commonly used for input validation and to check conditions that should be true before proceeding.\n\nHere, checks if the sender has sufficient balance before proceeding with the transfer.\n\nis used to handle errors explicitly and revert the state changes. It can be used with or without an error message.\n\nIn this example, is used to handle the case where the balance is insufficient, providing an explicit error message.\n\nSolidity 0.8.4 introduced custom errors, which are more gas-efficient than revert strings. Custom errors allow developers to define and use specific error types within their contracts."
    },
    {
        "link": "https://dev.to/superxdev/advanced-solidity-event-logging-and-error-handling-4k68",
        "document": "Solidity, the primary language for writing smart contracts on Ethereum, has unique features to handle logging and error management. Understanding these mechanisms is essential for developing robust and maintainable decentralized applications (dApps). This article delves into the intricacies of event logging and error handling in Solidity, providing a comprehensive guide for both beginners and experienced developers.\n\nIn Solidity, events are a convenient way to log data on the Ethereum blockchain. They facilitate communication between smart contracts and their external users, enabling the creation of logs that can be easily accessed and monitored.\n\nEvents are typically emitted by smart contracts to signal that something significant has occurred. Once emitted, events are stored in the transaction logs of the blockchain, making them accessible for future reference.\n\nEvents have several practical applications in smart contract development, including:\n• Transaction Notifications: Informing external applications when a particular action has taken place within the smart contract.\n• State Changes: Logging changes in the state of the contract for auditing and debugging purposes.\n• Data Storage: Storing historical data in an efficient manner that is cheaper than using contract storage.\n\nDefining an event in Solidity is straightforward. The syntax involves the keyword followed by the event name and parameters.\n\n\n\nIn this example, we define an event with two parameters: and . The event is emitted inside the function, logging the values passed to it.\n\nIndexed parameters allow for efficient filtering of event logs. By marking a parameter with the keyword, you can create up to three indexed parameters per event, enabling faster and more targeted searches.\n\n\n\nIn this example, both and are indexed, allowing for efficient querying based on these parameters.\n\nTo listen for events emitted by a smart contract, you can use Web3.js, a popular JavaScript library for interacting with the Ethereum blockchain.\n\nFirst, you need to set up a Web3 instance and connect to an Ethereum node.\n\n\n\nThen, you can subscribe to the event using the property of the contract instance.\n\n\n\nThis code listens for the event, optionally filtering by the address and starting from block 0.\n\nLet's consider a more practical example: a simple voting contract.\n\n\n\nIn this example, we define two events, and , to log voting activities and the addition of new proposals. These events can be listened to in a dApp to update the UI in real-time whenever a vote is cast or a new proposal is added.\n\nError handling is crucial in smart contract development to ensure the integrity and reliability of the contract. Effective error handling helps prevent unexpected behaviors, secure funds, and provide meaningful feedback to users and developers.\n\nIn Solidity, errors can be broadly categorized into:\n• Assertion Failures: Using to enforce invariants and check internal errors.\n• Requirement Failures: Using to validate inputs and conditions.\n• Reversions: Using to handle errors explicitly and revert the state.\n\nis used to check for conditions that should never be false. It is typically used to enforce invariants within the code. If an statement fails, it indicates a bug in the contract.\n\n\n\nIn this example, ensures that the addition operation does not overflow.\n\nis used to validate inputs and conditions before executing the rest of the function. It is commonly used for input validation and to check conditions that should be true before proceeding.\n\n\n\nHere, checks if the sender has sufficient balance before proceeding with the transfer.\n\nis used to handle errors explicitly and revert the state changes. It can be used with or without an error message.\n\n\n\nIn this example, is used to handle the case where the balance is insufficient, providing an explicit error message.\n\nSolidity 0.8.4 introduced custom errors, which are more gas-efficient than revert strings. Custom errors allow developers to define and use specific error types within their contracts."
    },
    {
        "link": "https://consensys.io/blog/solidity-best-practices-for-smart-contract-security",
        "document": "By Consensys Diligence, our team of blockchain security experts.\n\nIf you’ve taken the smart contract security mindset to heart and are getting a handle on the EVM’s idiosyncrasies, it’s time to consider some security patterns that are specific to the Solidity programming language. In this roundup, we’ll focus on secure development recommendations for Solidity that may also be instructive for developing smart contracts in other languages.\n\nThe convenience functions assert and require can be used to check for conditions and throw an exception if the condition is not met.\n\nThe assert function should only be used to test for internal errors, and to check invariants.\n\nThe require function should be used to ensure valid conditions, such as inputs, or contract state variables are met, or to validate return values from calls to external contracts.\n\nFollowing this paradigm allows formal analysis tools to verify that the invalid opcode can never be reached: meaning no invariants in the code are violated and that the code is formally verified.\n\nUse modifiers only for checks\n\nThe code inside a modifier is usually executed before the function body, so any state changes or external calls will violate the Checks-Effects-Interactions pattern. Moreover, these statements may also remain unnoticed by the developer, as the code for modifier may be far from the function declaration. For example, an external call in modifier can lead to the reentrancy attack:\n\nIn this case, the contract can make a reentracy attack by calling inside .\n\nNote: Use modifiers to replace duplicate condition checks in multiple functions, such as , otherwise use or inside the function. This makes your smart contract code more readable and easier to audit.\n\nAll integer division rounds down to the nearest integer. If you need more precision, consider using a multiplier, or store both the numerator and denominator.\n\nUsing a multiplier prevents rounding down, this multiplier needs to be accounted for when working with x in the future:\n\nStoring the numerator and denominator means you can calculate the result of off-chain:\n\nBe aware of the tradeoffs between abstract contracts and interfaces\n\nBoth interfaces and abstract contracts provide one with a customizable and re-usable approach for smart contracts. Interfaces, which were introduced in Solidity 0.4.11, are similar to abstract contracts but cannot have any functions implemented. Interfaces also have limitations such as not being able to access storage or inherit from other interfaces which generally makes abstract contracts more practical. Although, interfaces are certainly useful for designing contracts prior to implementation. Additionally, it is important to keep in mind that if a contract inherits from an abstract contract it must implement all non-implemented functions via overriding or it will be abstract as well.\n\nFallback functions are called when a contract is sent a message with no arguments (or when no function matches), and only has access to 2,300 gas when called from a or . If you wish to be able to receive Ether from a or , the most you can do in a fallback function is log an event. Use a proper function if a computation of more gas is required.\n\nSince the fallback functions is not only called for plain ether transfers (without data) but also when no other function matches, you should check that the data is empty if the fallback function is intended to be used only for the purpose of logging received Ether. Otherwise, callers will not notice if your contract is used incorrectly and functions that do not exist are called.\n\nStarting from Solidity , every function that is receiving ether must use modifier, otherwise if the transaction has will revert (except when forced).\n\nNote: Something that might not be obvious: The modifier only applies to calls from external contracts. If I call a non-payable function in the payable function in the same contract, the non-payable function won't fail, though is still set.\n\nExplicitly label the visibility of functions and state variables. Functions can be specified as being , , or . Please understand the differences between them, for example, may be sufficient instead of . For state variables, is not possible. Labeling the visibility explicitly will make it easier to catch incorrect assumptions about who can call the function or access the variable.\n• None functions are part of the contract interface. An external function cannot be called internally (i.e. does not work, but works). External functions are sometimes more efficient when they receive large arrays of data.\n• None functions are part of the contract interface and can be either called internally or via messages. For public state variables, an automatic getter function (see below) is generated.\n• None functions and state variables can only be accessed internally, without using .\n• None functions and state variables are only visible for the contract they are defined in and not in derived contracts. Note: Everything that is inside a contract is visible to all observers external to the blockchain, even variables.\n\nContracts should be deployed with the same compiler version and flags that they have been tested the most with. Locking the pragma helps ensure that contracts do not accidentally get deployed using, for example, the latest compiler which may have higher risks of undiscovered bugs. Contracts may also be deployed by others and the pragma indicates the compiler version intended by the original authors.\n\nNote: a floating pragma version (ie. ) will compile fine with , however nightly builds should never be used to compile code for production.\n\nWarning: Pragma statements can be allowed to float when a contract is intended for consumption by other developers, as in the case with contracts in a library or EthPM package. Otherwise, the developer would need to manually update the pragma in order to compile locally.\n\nIt can be useful to have a way to monitor the contract's activity after it was deployed. One way to accomplish this is to look at all transactions of the contract, however that may be insufficient, as message calls between contracts are not recorded in the blockchain. Moreover, it shows only the input parameters, not the actual changes being made to the state. Also events could be used to trigger functions in the user interface.\n\nHere, contract will make an internal call to . This transaction won't appear in the external transaction list of , but only visible in the internal transactions.\n\nAn event is a convenient way to log something that happened in the contract. Events that were emitted stay in the blockchain along with the other contract data and they are available for future audit. Here is an improvement to the example above, using events to provide a history of the Charity's donations.\n\nHere, all transactions that go through the contract, either directly or not, will show up in the event list of that contract along with the amount of donated money.\n\nNote: Prefer newer Solidity constructs. Prefer constructs/aliases such as (over ) and (over ). Patterns like can also be simplified to using , as in . Check out Solidity Change log for more similar changes.\n\nBe aware that 'Built-ins' can be shadowed\n\nIt is currently possible to shadow built-in globals in Solidity. This allows contracts to override the functionality of built-ins such as and . Although this is intended, it can mislead users of a contract as to the contract's true behavior.\n\nContract users (and auditors) should be aware of the full smart contract source code of any application they intend to use.\n\nNever use for authorization, another contract can have a method which will call your contract (where the user has some funds for instance) and your contract will authorize that transaction as your address is in .\n\nYou should use for authorization (if another contract calls your contract will be the address of the contract and not the address of the user who called the contract).\n\nYou can read more about it here: Solidity docs\n\nWarning: Besides the issue with authorization, there is a chance that will be removed from the Ethereum protocol in the future, so code that uses won't be compatible with future releases Vitalik: 'Do NOT assume that tx.origin will continue to be usable or meaningful.'\n\nIt's also worth mentioning that by using you're limiting interoperability between contracts because the contract that uses tx.origin cannot be used by another contract as a contract can't be the .\n\nThere are three main considerations when using a timestamp to execute a critical function in a contract, especially when actions involve fund transfer.\n\nBe aware that the timestamp of the block can be manipulated by a miner. Consider this contract:\n\nWhen the contract uses the timestamp to seed a random number, the miner can actually post a timestamp within 15 seconds of the block being validated, effectively allowing the miner to precompute an option more favorable to their chances in the lottery. Timestamps are not random and should not be used in that context.\n\nThe Yellow Paper (Ethereum's reference specification) does not specify a constraint on how much blocks can drift in time, but it does specify that each timestamp should be bigger than the timestamp of its parent. Popular Ethereum protocol implementations Geth and Parity both reject blocks with timestamp more than 15 seconds in future. Therefore, a good rule of thumb in evaluating timestamp usage is: if the scale of your time-dependent event can vary by 15 seconds and maintain integrity, it is safe to use a .\n\nIt is possible to estimate a time delta using the property and average block time, however this is not future proof as block times may change (such as fork reorganisations and the difficulty bomb). In a sale spanning days, the 15-second rule allows one to achieve a more reliable estimate of time.\n\nWhen utilizing multiple inheritance in Solidity, it is important to understand how the compiler composes the inheritance graph.\n\nWhen a contract is deployed, the compiler will linearize the inheritance from right to left (after the keyword is the parents are listed from the most base-like to the most derived). Here is contract A's linearization:\n\nThe consequence of the linearization will yield a value of 5, since C is the most derived contract. This may seem obvious, but imagine scenarios where C is able to shadow crucial functions, reorder boolean clauses, and cause the developer to write exploitable contracts. Static analysis currently does not raise issue with overshadowed functions, so it must be manually inspected.\n\nTo help contribute, Solidity's Github has a project with all inheritance-related issues.\n\nUse interface type instead of the address for type safety\n\nWhen a function takes a contract address as an argument, it is better to pass an interface or contract type rather than raw . If the function is called elsewhere within the source code, the compiler it will provide additional type safety guarantees.\n\nHere we see two alternatives:\n\nThe benefits of using the contract above can then be seen from the following example. If is called with an argument, or a contract type other than , the compiler will throw this error:\n\nAvoid using to check for externally owned accounts\n\nThe following modifier (or a similar check) is often used to verify whether a call was made from an externally owned account (EOA) or a contract account:\n\nThe idea is straight forward: if an address contains code, it's not an EOA but a contract account. However, a contract does not have source code available during construction. This means that while the constructor is running, it can make calls to other contracts, but for its address returns zero. Below is a minimal example that shows how this check can be circumvented:\n\nBecause contract addresses can be pre-computed, this check could also fail if it checks an address which is empty at block , but which has a contract deployed to it at some block greater than .\n\nWarning: This issue is nuanced. If your goal is to prevent other contracts from being able to call your contract, the check is probably sufficient. An alternative approach is to check the value of , though this also has drawbacks.\n\nThere may be other situations in which the check serves your purpose. Describing all of them here is out of scope. Understand the underlying behaviors of the EVM and use your judgement."
    },
    {
        "link": "https://medium.com/@jefferyokesamuel1/effective-use-of-events-in-solidity-smart-contracts-35644692378e",
        "document": "Solidity, Ethereum’s native smart contract programming language uses “events” to log important information during contract execution. These events are very powerful tools for communicating state changes, capturing transaction data and providing essential insights into smart contract operations, making them invaluable for building and interacting with decentralized applications (DApps).\n\nIn this article, i’ll dive deep into the effective use of events in Solidity, exploring best practices, some optimisation techniques and use cases.\n\nWhat Are Events in Solidity?\n\nEvents are Solidity’s logging mechanism, primarily for storing data in transaction logs on the blockchain. When triggered within a contract function, events record the specified information onto the blockchain in a cost-effective way. Since transaction logs exist outside of the contract’s storage, they provide a more efficient alternative for tracking data without consuming a lot of gas or contract memory.\n\nThese logs aren’t accessible within the contract directly. Instead, they’re available through the Ethereum Virtual Machine (EVM) and can be indexed for quick retrieval by applications outside the blockchain, such as front-end DApps or monitoring services.\n\nIn Solidity, an event is defined like this:\n\nThe `indexed` keyword can be used for up to three parameters per event, making it easier to filter and query logs in external applications. Indexed parameters can be thought of as “search keys” that DApps can use to find specific event logs efficiently.\n\nIn this example, the `Transfer` event logs each transaction, with `from` and `to` as indexed fields and `value` as a non-indexed field.\n\nUse Cases for Events in Solidity\n\nEvents provide an efficient and effective way to log transactions, which is particularly important for DApps that need real-time updates. Events allow developers to listen for specific actions such as fund transfers, contract updates or state changes and immediately reflect these changes on the user interface or execute actions.\n\nEvents serve as a valuable tool for debugging contracts. Developers can insert events at critical stages in a contract’s logic to record the contract’s state at that point. This can reveal hidden bugs or unexpected behaviors in a test environment without needing to store data on-chain.\n\nEvents are useful for signaling state changes in a contract. For instance, a decentralized lending platform might use events to alert users when their loans are approved, partially repaid, or liquidated. This allows DApps to respond immediately to state changes and provide timely updates to end users.\n\nSince events log data off-chain, they can be used for calculations that don’t need to affect the contract’s state directly. For instance, a DApp might calculate aggregate statistics or average values based on emitted events rather than querying the contract’s state, saving on gas and reducing on-chain storage.\n\nBest Practices for Using Events in Solidity\n\nIndexed parameters allow DApps to filter and search through event logs efficiently. However, the number of indexed fields is limited to three, so it’s essential to use these slots wisely. Indexed parameters should capture the core elements of an event. For instance, in a financial transaction, the sender and receiver addresses are generally more critical than the transaction amount.\n\nWhile events are more gas-efficient than storage variables, they still incur gas costs. It’s a good practice to limit the number of events to those genuinely necessary. Overusing events can lead to bloated transaction logs, making it more challenging to retrieve relevant data.\n\nEvents should be emitted after a significant action has completed successfully. Emitting an event too early or at unnecessary stages can lead to inaccurate logs. For instance, in a transfer function, the `Transfer` event should be emitted after the balance updates are confirmed.\n\nEvents are off-chain, meaning they can’t be accessed by other contracts or influence contract logic directly. They are not intended for critical, in-contract state management. Instead, use events as supplementary information for off-chain use cases.\n\nEvents are often used by external applications to track specific actions within a smart contract. Clear, descriptive event names make the contract easier to understand for future developers and external applications. A name like `DepositMade` or `LoanRepaid` is more informative than simply calling an event `Action`.\n\n1. Use Events Instead of Storage\n\nOne of the most gas-efficient practices is to use events for logging data that doesn’t need to be stored within the contract. While storage variables have a gas cost for both writing and reading, events are only written to the log once and are retrievable by DApps off-chain.\n\nIf you need to log a set of related information, combine them in a single event instead of using multiple events. This reduces the number of operations and gas consumed, making the contract more efficient.\n\nIn this example, `actionType` could be used to represent different types of user actions (e.g deposits, withdrawals) instead of creating separate events for each type.\n\nEmitting events within loops can quickly consume gas. Instead, consider logging a summary event outside the loop or batching multiple actions and emitting a single event to represent the entire batch.\n\nHere’s an example of a simple marketplace contract demonstrating the effective use of events.\n\n- ItemListed: Logs details when a new item is listed. The item ID and seller’s address are indexed to allow for efficient searching.\n\n- ItemPurchased: Logs the sale of an item, including the item ID and the buyer’s address.\n\nThis contract enables a DApp to display a real-time marketplace view and notify users of new listings and purchases by watching for these events.\n\nEvents in Solidity are essential for building efficient, transparent, and interactive DApps. By following best practices such as choosing indexed parameters carefully, minimizing unnecessary events, and using events outside of critical state logic, you can optimize both gas efficiency and DApp performance. Events not only serve as logs but as the backbone of event-driven systems in the Ethereum ecosystem, making them indispensable for creating robust decentralized applications."
    },
    {
        "link": "https://geeksforgeeks.org/solidity-error-handling",
        "document": "Solidity has many functions for error handling. Errors can occur at compile time or runtime. Solidity is compiled to byte code and there a syntax error check happens at compile-time, while runtime errors are difficult to catch and occurs mainly while executing the contracts. Some of the runtime errors are out-of-gas error, data type overflow error, divide by zero error, array-out-of-index error, etc. Until version 4.10 a single throw statement was there in solidity to handle errors, so to handle errors multiple if…else statements, one has to implement for checking the values and throw errors which consume more gas. After version 4.10 new error handling construct assert, require, revert statements were introduced and the throw was made absolute.\n\nThe ‘require’ statements declare prerequisites for running the function i.e. it declares the constraints which should be satisfied before executing the code. It accepts a single argument and returns a boolean value after evaluation, it also has a custom string message option. If false then exception is raised and execution is terminated. The unused gas is returned back to the caller and the state is reversed to its original state. Following are some cases when require type of exception is triggered :\n• When require() is called with the arguments which result as false.\n• When a function called by a message does not end properly.\n• When a contract is created using the new keyword and the process does not end properly.\n• When a codeless contract is targeted to an external function.\n• When ethers are sent to the contract using the public getter method.\n• When .transfer() method fails.\n• When an assert is called with a condition that results in false.\n• When a zero-initialized variable of a function is called.\n• When a large or a negative value is converted to an enum.\n• When a value is divided or modulo by zero.\n• When accessing an array in an index which is too big or negative.\n\nExample: In the below example, the contract requireStatement demonstrates how to use the ‘require statement’.\n\nIts syntax is similar to the require statement. It returns a boolean value after the evaluation of the condition. Based on the return value either the program will continue its execution or it will throw an exception. Instead of returning the unused gas, the assert statement consumes the entire gas supply and the state is then reversed to the original state. Assert is used to check the current state and function conditions before the execution of the contract. Below are some cases with assert type exceptions :\n• When an assert is called with a condition that results in false.\n• When a zero-initialized variable of a function is called.\n• When a large or a negative value is converted to an enum.\n• When a value is divided or modulo by zero.\n• When accessing an array in an index which is too big or negative.\n\nExample: In the below example, the contract assert Statement demonstrates how to use an ‘assert statement’.\n\nThis statement is similar to the require statement. It does not evaluate any condition and does not depends on any state or statement. It is used to generate exceptions, display errors, and revert the function call. This statement contains a string message which indicates the issue related to the information of the exception. Calling a revert statement implies an exception is thrown, the unused gas is returned and the state reverts to its original state. Revert is used to handle the same exception types as require handles, but with little bit more complex logic.\n\nExample: In the below example, the contract revertStatement demonstrates the ‘revert statement’.\n\nTo define the custom error in the smart contract by using the “Error statement” . Error statement is used either inside the smart contract or outside the smart contract along with revert statement. The main purpose of using custom error in the smart contract is to save gas.\n\nExample : In the below example some amount is deposited to the owner address and if owner wants to transfer this amount to given address than first we checks withdraw amount is less than owner address amount if the condition is matched than withdraw amount is successfully transferred to the given address. Otherwise, If the condition is not matched than transaction is reverted with the help of Error statement provided by the contract."
    }
]