[
    {
        "link": "https://github.com/dnSpy/dnSpy",
        "document": "dnSpy is a debugger and .NET assembly editor. You can use it to edit and debug assemblies even if you don't have any source code available. Main features:\n\nSee below for more features\n\nTo debug Unity games, you need this repo too: https://github.com/dnSpy/dnSpy-Unity-mono (or get the binaries from https://github.com/dnSpy/dnSpy/releases/unity)\n• Set breakpoints and step into any assembly\n• Variables windows support saving variables (eg. decrypted byte arrays) to disk or view them in the hex editor (memory window)\n• Multiple processes can be debugged at the same time\n• Dynamic modules can be debugged (but not dynamic methods due to CLR limitations)\n• Output window logs various debugging events, and it shows timestamps by default :)\n• Assemblies that decrypt themselves at runtime can be debugged, dnSpy will use the in-memory image. You can also force dnSpy to always use in-memory images instead of disk files.\n• Public API, you can write an extension or use the C# Interactive window to control the debugger\n• All metadata can be edited\n• Edit methods and classes in C# or Visual Basic with IntelliSense, no source code required\n• Add new methods, classes or members in C# or Visual Basic\n• Low-level metadata tables can be edited. This uses the hex editor internally.\n• Click on an address in the decompiled code to go to its IL code in the hex editor\n• The reverse of the above, press F12 in an IL body in the hex editor to go to the decompiled code or other high-level representation of the bits. It's great to find out which statement a patch modified.\n• Tooltips show more info about the selected .NET metadata / PE field\n• Go to .NET metadata token, method body, #Blob / #Strings / #US heap offset or #GUID heap index\n• C# Interactive window can be used to script dnSpy\n• References are highlighted, use Tab / Shift+Tab to move to the next reference\n• Go to the entry point and module initializer commands\n• Go to metadata token or metadata row commands\n• dnlib (.NET metadata reader/writer which can also read obfuscated assemblies)\n• ClrMD (Access to lower level debugging info not provided by the CorDebug API)\n\nClick here if you want to help with translating dnSpy to your native language.\n\nSee the Wiki for build instructions and other documentation."
    },
    {
        "link": "https://github.com/icsharpcode/ILSpy",
        "document": "ILSpy is the open-source .NET assembly browser and decompiler.\n\nAside from the WPF UI ILSpy (downloadable via Releases, see also plugins), the following other frontends are available:\n• Visual Studio 2022 ships with decompilation support for F12 enabled by default (using our engine v8.1).\n• In Visual Studio 2019, you have to manually enable F12 support. Go to Tools / Options / Text Editor / C# / Advanced and check \"Enable navigation to decompiled source\"\n• C# for Visual Studio Code ships with decompilation support as well. To enable, activate the setting \"Enable Decompilation Support\".\n• Our Linux/Mac/Windows ILSpy UI based on Avalonia - check out https://github.com/icsharpcode/AvaloniaILSpy\n• Our ICSharpCode.Decompiler NuGet for your own projects\n• Our dotnet tool for Linux/Mac/Windows - check out ILSpyCmd in this repository\n• Our Linux/Mac/Windows PowerShell cmdlets in this repository\n• Decompilation to C# (check out the language support status)\n• Search for types/methods/properties (learn about the options)\n• ReadyToRun binary support for .NET Core (see the tutorial)\n• Additional features in DEBUG builds (for the devs)\n\nILSpy is distributed under the MIT License. Please see the About doc for details, as well as third party notices for included open-source libraries.\n• Make sure Windows PowerShell (at least version) 5.0 or PowerShell 7+ is installed.\n• Execute to download the ILSpy-Tests submodule (used by some test cases).\n• Install Visual Studio (documented version: 17.8). You can install the necessary components in one of 3 ways:\n• Follow Microsoft's instructions for importing a configuration, and import the .vsconfig file located at the root of the solution.\n• Alternatively, you can open the ILSpy solution (ILSpy.sln) and Visual Studio will prompt you to install the missing components.\n• Finally, you can manually install the necessary components via the Visual Studio Installer. The workloads/components are as follows:\n• Workload \".NET Desktop Development\". This workload includes the .NET Framework 4.8 SDK and the .NET Framework 4.7.2 targeting pack, as well as the .NET 8.0 SDK (ILSpy.csproj targets .NET 8.0, but we have net472 projects too). Note: The optional components of this workload are not required for ILSpy\n• Workload \"Visual Studio extension development\" (ILSpy.sln contains a VS extension project) Note: The optional components of this workload are not required for ILSpy\n• Individual Component \"MSVC v143 - VS 2022 C++ x64/x86 build tools\" (or similar)\n• The VC++ toolset is optional; if present it is used for to modify the stack size used by ILSpy.exe from 1MB to 16MB, because the decompiler makes heavy use of recursion, where small stack sizes lead to problems in very complex methods.\n• Open ILSpy.sln in Visual Studio.\n• Use the Visual Studio \"Test Explorer\" to see/run the tests\n• If you are only interested in a specific subset of ILSpy, you can also use\n• ILSpy.XPlat.slnf: for the cross-platform CLI or PowerShell cmdlets\n\nNote: Visual Studio includes a version of the .NET SDK that is managed by the Visual Studio installer - once you update, it may get upgraded too. Please note that ILSpy is only compatible with the .NET 8.0 SDK and Visual Studio will refuse to load some projects in the solution (and unit tests will fail). If this problem occurs, please manually install the .NET 8.0 SDK from here.\n• Make sure PowerShell is installed (formerly known as PowerShell Core)\n• Execute to download the ILSpy-Tests submodule (used by some test cases).\n• Use to build the non-Windows flavors of ILSpy (.NET Core Global Tool and PowerShell Core).\n• If you want to contribute a pull request, please add https://github.com/icsharpcode/ILSpy/blob/master/BuildTools/pre-commit to your to prevent checking in code with wrong formatting. We use tabs and not spaces. The build server runs the same script, so any pull requests using wrong formatting will fail.\n\nILSpy does not collect any personally identifiable information, nor does it send user files to 3rd party services. ILSpy does not use any APM (Application Performance Management) service to collect telemetry or metrics."
    },
    {
        "link": "https://infosecwriteups.com/fundamentals-of-net-decompilation-with-dnspy-e7456707b1d2",
        "document": "Recently, I’ve picked up an interest in testing compiled applications. Historically, I’ve had the most experience performing network pentesting and web application assessments/bug bounty, so I was interested in finding an approachable way to get acclimated to the concept. After doing some digging and testing, I found testing .NET applications to be exactly what I was looking for. There are tons of .NET applications to test that can be quickly decompiled to their near original form, making it an easier introduction to static and dynamic code analysis. Below, I’ve detailed some of the fundamentals I’ve learned while using dnSpy to test .NET apps.\n\nInterested in discussing .NET app hacking? Find me on Twitter @JowardBince.\n\nA full explanation of .NET is beyond the scope of this article, but we’ll talk about it briefly for the uninitiated. As the .NET ecosystem is so large, discussing all of it’s components would be an article of it’s own. For those interested, I’d recommend Microsoft’s official overview here.\n\nIn short, the .NET ecosystem provides tools and packages for fast and efficient software development on numerous platforms in multiple languages. It provides compilers and runtime components to develop in C#, F#, and Visual Basic with multiple other languages providing their own support. It’s possible to write a piece of software in any of these languages and immediately compile it for use on desktop, mobile, web, and more.\n\nEven better, it provides a ton of out of the box packages and templates for quick project setup. You can create a new desktop GUI app, an ASP.NET web app, or a mobile app straight from a template. The packages include Windows functionality and other common functions. What’s more, you can easily import other packages for use in your project. These features make .NET an extremely popular choice for all types of development and companies and thus a very rich target for pentesters and bug bounty hunters.\n\nOne of the things that make .NET interesting to work with and hack on is the ability to decompile to source. Decompilation is the opposite of compilation, where we take a compiled binary file and get source code from it.\n\nWhen decompiling other compiled languages such as C, the source code is inferred from the assembly code present in the binary. Therefore, it requires a lot more leg work to get it back to an easily readable, near source format. However, because of the nature of the .NET framework, we can decompile a .NET DLL or executable back to it’s original source code; complete with package imports and everything. This makes it a great starting point for those interested in reverse engineering and binary exploitation.\n\nSince my focus is offensive security research, we’ll use a vulnerable application for our tests and examples. We’ll be using the Damn Vulnerable C Sharp API. This has a number of different common .NET vulnerabilities that are great to poke around with.\n\nFor the actual task of decompilation, I prefer dnSpy. It’s feature rich, has an attractive UI (dark mode by default), and it’s totally open source. For those getting more advanced, JetBrains dotPeek provides a number of advanced features.\n\nWith dnSpy, decompilation is straight forward: open dnSpy, drag and drop your executable, and you’re good to go.\n\nMost worthwhile decompilers will include a debugger. With this, we can run the binary we’re working with and review the code as we test features. dnSpy let’s you execute a loaded DLL through the .NET framework under Debug -> Start Debugging. You’d select your debug engine, the executable, the working directory, and any run time arguments.\n\nIf it’s a web app, by default it will run on .\n\nOne of the most important features for testing .NET binaries is the ability to set tracepoints and breakpoints. Tracepoints log actions as they occur, and breakpointst pause the execution of the program when a certain line of code is reached.\n\nWith dnSpy, you can set tracepoints and breakpoints on the functionality of entire classes. dnSpy offers a rich logging suite that let’s us control exactly what’s being logged, including the name of a function or the values of local variables.\n\nBy right clicking a class and selecting Add Class Tracepoint, we can define an entire suite of tracepoints and exactly what’s being logged.\n\nIt also provides all of the values to log different variables like the function name, memory addresses, process name, etc.\n\nIn DVCSharp API, we’ll set a class tracepoint on the ProductsController class and log the function name.\n\nNow anytime we send a request to the API that calls a function in the ProductsController, we’ll see the function name in the log.\n\nBreakpoints are very similar. The key difference is that, instead of just logging the function executed, it will actually pause the program execution as it hits a specific line of code. Breakpoints can be created through the same contextual menu on a class or by clicking in the left hand margin of the decompiled code.\n\nStepping Into and Over\n\nWhen using a breakpoint to debug an application, we may want to inspect each instruction as it’s executed. We can step into or step over functions. Stepping into , will move on to the next sequential instruction in the function call. Stepping over will execute the entire function and pause at the next function call. This lets you get extremely granular in your inspection of function execution.\n\nOf course, using breakpoints to walk through code execution is great. However, you’ll usually want to see how variables are being manipulated at each step of execution. dnSpy allows us to easily view the values of local variables and objects at each step of execution. As an example, we’ll send a request to DVCSharp API to create a product, but create a breakpoint at the start of the function.\n\nAfter sending the API request, the program execution pauses and we can inspect the product object in the Locals tab.\n\nBetter yet, we can even include these variables and their values in our logging messages. If we go back to modify our tracepoint or breakpoint and, for example, wanted to include the product name in the log message, we could do the following. This works exactly the same way for both tracepoints and breakpoints.\n\nWhen inspecting the logs, we’d see the following.\n\nDecompiling and testing .NET applications can be a a great introduction to testing and reverse engineering compiled applications. I personally have very little experience with either, and I’ve found this to be an approachable and digestible way to get acclimated with many of the core concepts of decompliation and debugging. dnSpy has a load of features such as modifying the source code, recompiling, and much more that are worth exploring. Hopefully, the above intro should be sufficient as an intro to the topic."
    },
    {
        "link": "https://preemptive.com/blog/reverse-engineering-tools-are-awesome",
        "document": "Earlier this month, I came across Scott Hanselman’s excellent blog post, What’s better than ILDasm? ILSpy and dnSpy are tools to Decompile .NET Code, where he shared his insights on the strengths and limitations of a laundry list of reverse engineering and debugging tools. In the following comments, someone had asked for an obfuscation recommendation for when a developer wants to protect their code against reverse-engineering (a reasonable question to be sure).\n\nUnfortunately, comments had been disabled by that point, so I emailed Scott, mapping Dotfuscator’s anti-reverse-engineering/tamper/debugging capabilities to the collection of developer tools he had covered.\n\nIt seemed like an excellent opportunity—not to self-promote our work (which we are very proud of) but to call out one of our most labor-intensive aspects: tracking and responding to real-world app-monitoring/tampering developments.\n\nIn the same way that antivirus software vendors update their products in response to shifting real-world threats, we always update our “in-app protection” and code obfuscation tools to counter evolving reverse-engineering, debugging, and monitoring tool capabilities.\n\n…and soon after, Scott made an excellent suggestion: that we turn those notes into a generally available blog. Thanks, Scott!\n\nBy the time you read this, we will have already released another version of Dotfuscator, so the table below may well be outdated. We have another comparable table for PreEmptive Protection / Obfuscation for Android and Java (DashO) and, coming soon, PreEmptive Protection / Obfuscation for JavaScript.\n\nRegardless, there are a few points that persist across versions and product lines:\n• If you are evaluating in-app protection tools (obfuscation, encryption and root, debug, tamper detection, etc.), satisfy yourself that the vendor regularly publishes updates (would you run a 2-year-old version of your anti-virus software?).\n• If you HAVE our tools (or a competitor’s), keep your software up-to-date! (same reason)\n• Don’t lose sight of WHY you’re securing your code – this is also a key requirement driver.\n\nUse cases for “in-app protection” are multiplying, and so are requirements. Are you trying to protect Intellectual Property? (a traditional use case) Or do you need to meet a PCI Compliance requirement to secure the data flowing through a Xamarin.Android app (or any of a dozen other data privacy/security requirements)? Are there audit requirements? Incident detection and/or response requirements?\n\nThanks to Azure, business logic and sensitive data are migrating from the desktop to the relative safety of the cloud. However, Xamarin, .NET Core, and (soon) client-side Blazor each push code and data in the opposite direction—onto unknown devices and often beyond any kind of trusted control.\n\nDevelopers increasingly have to translate abstract directives like “security by design and by default” into concrete controls and processes.\n\nWith all of this in mind, here’s a table based on the tools referenced in Scott’s post. I would encourage every organization to validate its own tool list.\n\nThe following snapshot table shows to what extent these development tools can (and mostly cannot) overcome (in this case) Dotfuscator’s obfuscation, encryption, hardening, and shielding transforms.\n\nImpressive? We think so, but don’t take out word for it. You can always evaluate the latest version of any of our products HERE."
    },
    {
        "link": "https://hanselman.com/blog/whats-better-than-ildasm-ilspy-and-dnspy-are-tools-to-decompile-net-code",
        "document": ".NET code (C#, VB, F#, etc) compiles (for the most part) into Intermediate Language (IL) and then makes it way to native code usually by Just-in-time (JIT) compilation on the target machine. When you get a DLL/Assembly, it's pre-chewed but not full juiced, to mix my metaphors.\n\nOften you'll come along a DLL that you want to learn more about. Sometimes you'll want to just see the structure of classes, methods, etc, and other times you want to see the IL - or a close representation of the original C#/VB/F#, etc. You're not looking at the source, you're seeing a backwards projection of the IL as whatever language you want. You're basically taking this pre-chewed food and taking it out of your mouth and getting a decent idea of what it was originally.\n\nI've used ILDasm for years, but it's old and lame and people tease you for using it because they are cruel. ;)\n\nSeriously, though, I use ILDasm - the IL Disassembler - simply because it's already installed. Those tweets got me thinking though that I need to update my options, so I'm trying out ILSpy and dnSpy.\n\nILSpy has been around for a while and has multiple front-ends, including ones for Linux/Mac/Windows based on Avalonia in the form of AvaloniaSpy. You can also integrate ILSpy into Visual Studio 2017 or 2019 with this extension. There is also a console decompiler and, interestingly, cross-platform PowerShell cmdlets.\n\nI've always liked the \"Open List\" feature of ILSpy where you can open a preconfigured list of assemblies you want to browse, like ASP.NET MVC, .NET 4, etc. A fun open source contribution for you might be to update the included lists with newer defaults. There's so many folks doing great work in open source out there, why not jump in and help them out?\n\ndnSpy has a lovely UI AND a great Console app using the same engine. It's amazingly polished and VERY complete. I was surprised that it also has a full hex editor as well as property pages for common EXE file headers. From their GitHub, dnSpy features\n• Edit assemblies in C# or Visual Basic or IL, and edit all metadata\n\ndnSpy takes it to the next level with an integrated Debugger, meaning you can attach to a running process and debug it without source code - but it feels like source code because it's decompiling for you. Note where it says C#, I can choose C#, VB, or IL as a \"view\" on my decompiled code.\n\nHere is dnSpy actually debugging ILSpy and stopped at a decompiled breakpoint.\n\nThere's a lot of great low-level stuff in this space. Another cool tool is Reflexil, a .NET Assembly Editor as well as de4dot by the same mysterious author as dnSpy. JetBrains has the excellent dotPeek and Telerik has JustDecompile. Commercial Tools include Reflector.\n\nSponsor: Manage GitHub Pull Requests right from the IDE with the latest JetBrains Rider. An integrated performance profiler on Windows comes to the rescue as well."
    },
    {
        "link": "https://stackoverflow.com/questions/13796802/edit-net-assembly-and-recompile",
        "document": "Exporting & recompiling might not be possible for large applications with many assembies, so I'd suggest a different approach:\n\nThe most comfortable way to go might be to use Reflexil(discontinued) in combination with .NET Reflector (not free) or JustDecompile from Telerik (very free but discontinued). I did this a few times and had the best result with JustDecompile - even if I'd prefer ILSpy over JustDecompile at any other time. also check dnEditor(repo archived)\n\n\"Now, how\"? you might ask: Here's a small tutorial from the guys at Telerik.\n\nYou should definitely look at the new kid on the block: dnSpy"
    },
    {
        "link": "https://stackoverflow.com/questions/18810500/how-to-modify-net-property-using-reflexil-v1-5",
        "document": "I need to modify a .net Assembly that I have lost source for and the only modification I need is to set the property to return 0 instead of 1.\n\nThe property is a get only property and there are code inside the get method. I'm trying to do this using the Reflexil v1.5 plugin inside the Telerik JustDecompile but Reflexil just lets me modify the IL inside the methods and not inside the property get or set blocks.\n\nDoes anyone know how to modify the IL inside a Property using Reflexil please?"
    },
    {
        "link": "https://hanselman.com/blog/whats-better-than-ildasm-ilspy-and-dnspy-are-tools-to-decompile-net-code",
        "document": ".NET code (C#, VB, F#, etc) compiles (for the most part) into Intermediate Language (IL) and then makes it way to native code usually by Just-in-time (JIT) compilation on the target machine. When you get a DLL/Assembly, it's pre-chewed but not full juiced, to mix my metaphors.\n\nOften you'll come along a DLL that you want to learn more about. Sometimes you'll want to just see the structure of classes, methods, etc, and other times you want to see the IL - or a close representation of the original C#/VB/F#, etc. You're not looking at the source, you're seeing a backwards projection of the IL as whatever language you want. You're basically taking this pre-chewed food and taking it out of your mouth and getting a decent idea of what it was originally.\n\nI've used ILDasm for years, but it's old and lame and people tease you for using it because they are cruel. ;)\n\nSeriously, though, I use ILDasm - the IL Disassembler - simply because it's already installed. Those tweets got me thinking though that I need to update my options, so I'm trying out ILSpy and dnSpy.\n\nILSpy has been around for a while and has multiple front-ends, including ones for Linux/Mac/Windows based on Avalonia in the form of AvaloniaSpy. You can also integrate ILSpy into Visual Studio 2017 or 2019 with this extension. There is also a console decompiler and, interestingly, cross-platform PowerShell cmdlets.\n\nI've always liked the \"Open List\" feature of ILSpy where you can open a preconfigured list of assemblies you want to browse, like ASP.NET MVC, .NET 4, etc. A fun open source contribution for you might be to update the included lists with newer defaults. There's so many folks doing great work in open source out there, why not jump in and help them out?\n\ndnSpy has a lovely UI AND a great Console app using the same engine. It's amazingly polished and VERY complete. I was surprised that it also has a full hex editor as well as property pages for common EXE file headers. From their GitHub, dnSpy features\n• Edit assemblies in C# or Visual Basic or IL, and edit all metadata\n\ndnSpy takes it to the next level with an integrated Debugger, meaning you can attach to a running process and debug it without source code - but it feels like source code because it's decompiling for you. Note where it says C#, I can choose C#, VB, or IL as a \"view\" on my decompiled code.\n\nHere is dnSpy actually debugging ILSpy and stopped at a decompiled breakpoint.\n\nThere's a lot of great low-level stuff in this space. Another cool tool is Reflexil, a .NET Assembly Editor as well as de4dot by the same mysterious author as dnSpy. JetBrains has the excellent dotPeek and Telerik has JustDecompile. Commercial Tools include Reflector.\n\nSponsor: Manage GitHub Pull Requests right from the IDE with the latest JetBrains Rider. An integrated performance profiler on Windows comes to the rescue as well."
    },
    {
        "link": "https://github.com/sailro/Reflexil",
        "document": "After 16 years of proud service, this project has been discontinued. ILSpy 8 moved to .NET Core, and many changes would be required to keep it running, including:\n• Migrate CodeDomProvider (that we use to compile stuff) to Roslyn\n• Use Roslyn instead of NRefactory for completion\n\nAll these tasks have already been done by dnSpy, now taken over by dnSpyEx. I recommend using this project going forward."
    },
    {
        "link": "https://telerik.com/blogs/don-rsquo-t-just-decompile-master-the-assembly-with-justdecompile-plugins",
        "document": "If you have a newer version of JustDecompile, you may have noticed a rather interesting main menu item (if you need to update, check out the brand new Telerik Control Panel).\n\nYou may find that your menu only has the Plugins Manager, which means you need to install a plugin! You can do this by going to the Plugins Manager. At this time, the manager displays a list of installed plugins and gives you a button to obtain new one. Manual intervention is required for this; look for the plugin installation story to be improved in upcoming releases.\n\nClicking the Get Plugins button in the Plugins Manager will take you to our extensions page where you can download plugins we have published. At this time, there is only one available, but more are coming. To install a plugin, click the download button on the page.\n\nThis will download a zip file containing the plugin. It also contains a readme with instructions on installing the plugins.\n\nThe plugin is contained in a folder with the zip file. Simply extract the entire folders (not just the contents) to the Plugins folder under your JustDecompile installation folder. Mine is located at c:\\Program Files (x86)\\Telerik\\JustDecompile\\Libraries\\Plugins. If you have a different Program Files folder, or you changed the installation path of JustDecompile, it may be in a different location.\n\nAfter you’re finished extracting the folder to the appropriate location, start JustDecompile and you will find your new plugin listed in the Plugins menu or Plugins Manager depending on the type of plugin installed.\n\nThe first plugin we ported to JustDecompile is Reflexil, a well-known assembly editor by Sébastien LEBRETON. It enhances JustDecompile by providing IL manipulation, c# code injection, a resource editor, and the ability to remove strong naming. This package also includes the De4Dot deobfuscator, so you’re really getting two plugins in one package!\n\nTo get started, simply click the Reflexil menu option under Plugins. A new panel will open beneath the code viewer, providing you with an easy to use interface to modify assemblies.\n\nWith an assembly selected in the JustDecompile assembly browser, you can use Reflexil to change which method is the entry point (not that you’d need one in a class library):\n\nYou can change the definition of the assembly name including the culture, version, and public key. You can also remove a strong name from a signed assembly:\n\nAnd you can modify the assembly’s custom attributes:\n\nSelecting a type in the assembly browser provides even more details that you can modify.\n\nHave you ever had a type in a 3rd party assembly that you wish was marked with as Serializable? Make the change yourself:\n\nAnd we’ve all experienced this: a type implicitly has an interface, but it isn’t explicitly declared. You can now easily apply the interface:\n\nSelecting a method will enable you to modify the IL instructions, add or remove variables and parameters,and much more.\n\nAnd the coolest option of all is Replace all with code… clicking this will open a code editor with IntelliSense support. Make sure you click the Compile button when you’re finished making your changes.\n\nYou can also inject new types, references, or resources through the context menu in the assembly explorer.\n\nThe most important thing on this menu is Save as. To be safe, Reflexil doesn’t modify your assemblies on the disk. You will need to save a new copy and deploy it yourself. I recommend testing it for correctness beforehand.\n\nThe plugin feature is brand new for JustDecompile Q2 2012, and we will be making many improvements. The API currently exists, and you can create your own plugins by looking at how we did it in the Reflexil source code. Since Reflexil is licensed under the GPL, you may wish to look at the assembly using JustDecompile if you want to use a non-compatible license for your plugin. We are currently making changes to the API for general public consumption, and when we’re finished we will release documentation and samples to get you started.\n\nIf you’re interested in seeing specific plugins, please leave a comment! And remember: with great power comes great responsibility. Use JustDecompile responsibly."
    }
]