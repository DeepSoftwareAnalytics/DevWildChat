[
    {
        "link": "https://stackoverflow.com/questions/71897028/unity-rts-style-move-object-without-navmesh-agent",
        "document": "Looks to me like rather than just setting a destination, the function actually moves every frame. Once you click another unit, presumably changes to the newly selected unit, meaning every object’s code is always moving the same single object.\n\nYou’ll want to do something like save the destination in an instance variable when is first called and then have the move code change either:\n• change transform.position if the script is attached to the object you want to move\n• or if not: save the current in an instance variable when is first called and then change its position in the move code.\n\nEdit: Here’s an attempt to show what I mean but note that this assumes the script is attached to the GameObject you want to move. It also preserves your existing system of setting the destination every frame while the unit is selected (it may be more desirable to update it only when the mouse is clicked?)"
    },
    {
        "link": "https://discussions.unity.com/t/unity-rts-style-movement-without-navmesh-agent/878617",
        "document": ""
    },
    {
        "link": "https://discussions.unity.com/t/how-can-i-make-an-ai-that-avoids-obstacles-without-using-navmesh/180802",
        "document": ""
    },
    {
        "link": "https://docs.unity3d.com/6000.0/Documentation/ScriptReference/AI.NavMeshAgent.html",
        "document": "Suggest a change Thank you for helping us improve the quality of Unity Documentation. Although we cannot accept all submissions, we do read each suggested change from our users and will make updates where applicable. Close For some reason your suggested change could not be submitted. Please <a>try again</a> in a few minutes. And thank you for taking the time to help us improve the quality of Unity Documentation. Close\n\nAttach this component to a mobile character in the game to allow the character to use the NavMesh to navigate the scene. For more details refer to AI Navigation."
    },
    {
        "link": "https://discussions.unity.com/t/scripting-alternate-to-nav-agent/507940",
        "document": ""
    },
    {
        "link": "https://docs.unity3d.com/Manual/CollidersOverview.html",
        "document": "In Unity, a collision happens when two GameObjectsThe fundamental object in Unity scenes, which can represent characters, props, scenery, cameras, waypoints, and more. A GameObject’s functionality is defined by the Components attached to it. More info\n\nSee in Glossary that are configured for collision occupy the same physical space. Collision is a foundational part of most games, and many interactive applications and simulators.\n\nTo handle collision between GameObjects, Unity uses colliders. A collider is a Unity component that defines the shape of a GameObject for the purposes of physical collisions. Colliders are invisible, and do not need to be the same shape as the GameObject’s mesh.\n\nFor guidance on how to add components to a GameObject, see Use Components.\n\nEach 3D collider has a 2D equivalent. In Unity, 2D and 3D physics run on different physics simulation systems. For guidance on 2D physics colliders, see Collider 2D.\n\nA collider’s type is based on the configuration of its GameObject’s Collider and RigidbodyA component that allows a GameObject to be affected by simulated gravity and other forces. More info\n\nSee in Glossary components. This configuration determines how a collider behaves, and how it interacts with other colliders.\n• Static colliders: The GameObject has a collider but no Rigidbody.\n• Rigidbody colliders: The GameObject has a collider and a Rigidbody.\n• Dynamic colliders: The Rigidbody is dynamic (that is, it has Is Kinematic disabled).\n• Kinematic colliders: The Rigidbody is kinematic (that is, it has Is Kinematic enabled).\n\nThere is also a sub-type of collider called a Trigger collider. Trigger colliders do not physically collide with other colliders; instead, Unity calls a function when other colliders pass through them.\n\nTrigger colliders don’t cause collisions. Instead, they detect other Colliders that pass through them, and call functions that you can use to initiate events (see Use collisions to trigger other events).\n\nTo turn a collider into a trigger collider, enable the Is Trigger property on the Collider component. A trigger collider does not collide with other colliders; instead, other colliders pass through it.\n\nFor a trigger collider to work, at least one GameObject involved in the collision must have a Rigidbody. Trigger colliders can be any collider type (static or Rigidbody), but in most cases it’s good practice to make the trigger collider a static collider. and add a Rigidbody to the GameObject that passes through the trigger. If several GameObjects are passing through one trigger, there must be a Rigidbody on at least one GameObject in each collision pair.\n\nTriggers can be any collider shape (see Collider shapes), and they can be visible or invisible. To make a trigger invisible, add the collider to an empty GameObject. Only add a trigger to a visible GameObject if it is okay for other GameObjects to visibly pass through it.\n\nFor gameplay and simulation, triggers might need some adjustment to make them feel intuitive for the player. For example, you could experiment with making a trigger collider slightly larger than its associated visible GameObject, so that it has a wider radius.\n\nFor information on how different collider types interact with each other on collision, see Interaction between collider types.\n\nCollider components are available in different shape configurations. There are three main shape types for colliders:\n\nPrimitive colliders are built-in simple shapes that you can attach to your GameObject and scale to approximately the same size and shape. You can also combine several primitive collider shapes to create compound colliders. Mesh collidersA free-form collider component which accepts a mesh reference to define its collision surface shape. More info\n\nSee in Glossary exactly match the shape of the GameObject’s MeshThe main graphics primitive of Unity. Meshes make up a large part of your 3D worlds. Unity supports triangulated or Quadrangulated polygon meshes. Nurbs, Nurms, Subdiv surfaces must be converted to polygons. More info\n\nSee in Glossary. They are more accurate than primitive colliders for complex shapes, but require more computational resources. Wheel collidersA special collider for grounded vehicles. It has built-in collision detection, wheel physics, and a slip-based tire friction model. It can be used for objects other than wheels, but it is specifically designed for vehicles with wheels. More info\n\nSee in Glossary are raycast-based Colliders specifically for in-game items that have physics-simulated wheels (for example, vehicles). They have built-in wheel physics, and controls for friction.\n\nYou can control the friction and bounciness of a collider’s surface. When two colliders meet, the physics system uses the properties of each surface to calculate the friction and bounce between them.\n\nFor more information, see Collider surfaces."
    },
    {
        "link": "https://discussions.unity.com/t/make-object-move-to-follow-another-object-plus-turn-towards-it/18200",
        "document": ""
    },
    {
        "link": "https://docs.unity3d.com/Manual/class-Transform.html",
        "document": "The Transform stores a GameObjectThe fundamental object in Unity scenes, which can represent characters, props, scenery, cameras, waypoints, and more. A GameObject’s functionality is defined by the Components attached to it. More info\n\nSee in Glossary’s Position, Rotation, Scale and parenting state. A GameObject always has a Transform component attached: you can’t remove a Transform or create a GameObject without a Transform component.\n\nThe Transform component determines the Position, Rotation, and Scale of each GameObject in the sceneA Scene contains the environments and menus of your game. Think of each unique Scene file as a unique level. In each Scene, you place your environments, obstacles, and decorations, essentially designing and building your game in pieces. More info\n\nSee in Glossary. Every GameObject has a Transform.\n\nTip: You can change the colors of the Transform axes (and other UI elements) (Menu: Unity > Preferences and then select the Colors & keys panel).\n\nUnity measures the Position, Rotation and Scale values of a Transform relative to the Transform’s parent. If the Transform has no parent, Unity measures the properties in world space.\n\nIn 2D space, you can manipulate Transforms on the x-axis or the y-axis only. In 3D space, you can manipulate Transforms on the x-axis, y-axis, and z-axis. In Unity, these axes are represented by the colors red, green, and blue respectively.\n\nThere are three primary ways you can edit a Transform’s properties:\n• In the Scene view \n\n An interactive view into the world you are creating. You use the Scene View to select and position scenery, characters, cameras, lights, and all other types of Game Object. More info .\n• In your C# scripts.\n\nIn the Scene view, you can use the Move, Rotate and Scale tools to modify Transforms. These tools are located in the upper left-hand corner of the Unity Editor.\n\nYou can use the Transform tools on any GameObject in a scene. When you select a GameObject, the tool GizmoA graphic overlay associated with a GameObject in a Scene, and displayed in the Scene View. Built-in scene tools such as the move tool are Gizmos, and you can create custom Gizmos using textures or scripting. Some Gizmos are only drawn when the GameObject is selected, while other Gizmos are drawn by the Editor regardless of which GameObjects are selected. More info\n\nSee in Glossary appears within it. The appearance of the Gizmo depends on which tool you select.\n\nWhen you click and drag on one of the three Gizmo axes, the axis’s color changes to yellow. While you drag the mouse, the GameObject moves, rotates, or scales along the selected axis. When you release the mouse button, the axis remains selected\n\nWhile moving the GameObject, you can lock movement to a particular plane (that is, change two of the axes and keep the third unchanged). To activate the lock for each plane, select the three small coloured squares around the center of the Move Gizmo. The colors correspond to the axis that locks when you select the square (for example, select the blue square to lock the z-axis).\n\nIn the InspectorA Unity window that displays information about the currently selected GameObject, asset or project settings, allowing you to inspect and edit the values. More info\n\nSee in Glossary window, you can use the Transform component to edit the Transform properties of a selected GameObject. There are two ways to edit the Transform property values in the component:\n• Enter values into the property value fields manually. This is useful for very specific adjustments.\n• Click a value field and drag up or down to increase or decrease the value. This is useful for less specific adjustments.\n\nUse the API to edit the Transform of a GameObject through script.\n\nIn Unity, you can group GameObjects into parent-child hierarchies:\n• A parent GameObject has other GameObjects connected to it that take on its Transform properties.\n• A child GameObject is connected to another GameObject, and takes on that GameObject’s Transform properties.\n\nIn the Hierarchy window, child GameObjects appear directly underneath parent GameObjects and are indented in the list. You can select the fold-out icon to hide or reveal a parent GameObject’s child GameObjects.\n\nA child GameObject moves, rotates, and scales exactly as its parent does. Child GameObjects can also have child GameObjects of their own. A GameObject can have multiple child GameObjects, but only one parent GameObject.\n\nThese multiple levels of parent-child relationships between GameObjects form a Transform hierarchy. The GameObject at the top of a hierarchy (that is, the only GameObject in the hierarchy that doesn’t have a parent) is known as the root GameObject.\n\nTo create a parent GameObject, drag any GameObject in the Hierarchy window onto another. This creates a parent-child relationship between the two GameObjects.\n\nYou can group GameObjects into parent-child hierarchies.\n\nThe Transform values for any child GameObject are displayed relative to the parent GameObject’s Transform values. These values are called local coordinates. For scene construction, it is usually sufficient to work with local coordinates for child GameObjects. In gameplay, it is often useful to find their global coordinates or their exact position in world space. The scripting API for the Transform component has separate properties for local and global Position, Rotation and Scale, and lets you convert between local and global coordinates.\n\nTip: When you parent Transforms, it is useful to set the parent’s location to <0,0,0> before you add the child Transform. This means that the local coordinates for the child Transform will be the same as the global coordinates, which makes it easier to ensure the child Transform is in the right position.\n\nThe Scale of the Transform determines the difference between the size of a meshThe main graphics primitive of Unity. Meshes make up a large part of your 3D worlds. Unity supports triangulated or Quadrangulated polygon meshes. Nurbs, Nurms, Subdiv surfaces must be converted to polygons. More info\n\nSee in Glossary in your modeling application and the size of that mesh in Unity. The mesh’s size in Unity (and therefore the Transform’s Scale) is important, especially during physics simulation. By default, the physics engineA system that simulates aspects of physical systems so that objects can accelerate correctly and be affected by collisions, gravity and other forces. More info\n\nSee in Glossary assumes that one unit in world space corresponds to one meter. If a GameObject is very large, it can appear to fall in “slow motion”; the simulation is correct because you are watching a very large GameObject fall a great distance.\n\nThree factors affect the Scale of your GameObject:\n• The size of your mesh in your 3D modeling application.\n• The Mesh Scale Factor setting in the GameObject’s Import Settings.\n• The Scale values of your Transform Component.\n\nDon’t adjust the Scale of your GameObject in the Transform component. If you create your models at real-life scale, you won’t have to change your Transform’s Scale. You can also adjust the scale at which your mesh is imported because some optimizations occur based on the import size. Do this in the Import settings for your individual mesh. Instantiating a GameObject that has an adjusted Scale value can decrease performance.\n\nNote: Changing the Scale affects the position of child Transforms. For example, scaling the parent Transform to (0,0,0) positions all child Transforms at (0,0,0) relative to the parent Transform.\n\nNon-uniform scaling is when the Scale in a Transform has different values for x, y, and z; for example (2, 4, 2). In contrast, uniform scaling has the same value for x, y, and z; for example (3, 3, 3). Non-uniform scaling can be useful in a few specific cases but it behaves differently to uniform scaling:\n• Some components don’t fully support non-uniform scaling. For example, some components have a circular or spherical element defined by a Radius property, such as Sphere Collider \n\n An invisible shape that is used to handle physical collisions for an object. A collider doesn’t need to be exactly the same shape as the object’s mesh - a rough approximation is often more efficient and indistinguishable in gameplay. More info , Capsule Collider \n\n A capsule-shaped collider component that handles collisions for GameObjects like barrels and character limbs. More info , Light and Audio Source \n\n A component which plays back an Audio Clip in the scene to an audio listener or through an audio mixer. More info . This means the circular shape remains circular under non-uniform scaling instead of elliptical.\n• If a child GameObject has a non-uniformly scaled parent GameObject and is rotated relative to that parent GameObject, it might appear skewed or “sheared”. There are components that support simple non-uniform scaling but that don’t work correctly when skewed like this. For example, a skewed Box Collider \n\n A cube-shaped collider component that handles collisions for GameObjects like dice and ice cubes. More info does not match the shape of the rendered mesh accurately.\n• A child GameObject of a non-uniformly scaled parent GameObject does not have its scale automatically updated when it rotates. As a result, the child GameObject’s shape might appear to change abruptly when you eventually update the scale, for example, if the child GameObject is detached from the parent GameObject."
    },
    {
        "link": "https://medium.com/@Scriptie/follow-after-an-object-in-unity-c54fb23b6ec0",
        "document": "This project is about following or escaping from a target game object. In the process, follower looks at the target while following(without using Transform.LookAt) and the escapee looks opposite from where the target is while escaping.\n\nI was introduced to the game Blocksbuster! by a friend of mine. In this game, there are hole collecting game objects. If you also played Hole.io, you can get the idea. In this game, blocks gravitated towards the collector hole. That mechanism took my interest and prompted me to implement a magnetic force implementation.\n\nIn this iteration, there is a target object that attracts or repels charged objects with GetMagnetized MonoBehaviour. The magnetic field of charged objects is represented with resized colliders with the charge value of the object. Attraction or repellent movement decided with the sign of the charge.\n\nIn the demo, we have a blue “target” object representing water. Green squares represent grass and yellow ones represent oil. Leading to grass following water and oil avoiding water.\n\nWhile I am not sure what kind of jargon should I use to describe the project, I did try to implement a version of Coulomb’s law. In which the target is charged -1 and was not included in the equation. Grass objects are charged positive and oil objects are charged negative, causing attraction and repelling. Using 1/distance² provided faster movement when the distance between the target and the charged object decreased.\n\nMove and Rotate After The Target\n\nGetMagnetized behavior does all work. It moves the charged the object according to its charge value. Throughout the implementation, you will see Vector3.Scale(Vector3 x, new Vector3(1, 0, 1)). This is because I chose to move objects only in the x-z plane. Masking y values of the vectors disables movement in the y-axis.\n\nThere are global variables used for both moving and rotating which are Distance, OneOverDistanceSquare, target, and TargetDirection. Charge’s sign and value also contained in absCharge and ChargeSign. There are movement speeds and threshold values to stop these movements.\n\nBlue lines represent the path between the target and the charged objects. Red lines represent the forward vector of the charged object’s transform.\n\nAt the start, constant charge values are calculated and the size of the charged object’s collider set to its original size times the absolute value of the charge. This way the bigger the charge more force-interaction field for the charged object.\n\nIf the target collides with the charged game object, commonly used variables are calculated. Rotation and movement functions are called.\n\nTo rotate the object first we need to calculate the value of rotation. The rotation done till the forward vector of the charged object is linear with TargetDirection vector. If positively charged they look the same direction, otherwise the vectors look to opposite directions. newRotation is calculated from the forward vector of the charged game object to TargetDirection vector. Multiplying TargetDirection with the sign enables us to rotate the charged object to the direction of the movement. Using quaternion math target rotation calculated as transform.rotation * newRotation, as multiplication adds quaternion values. Absolute charge value and reverse of distance are used to effect rotation speed.\n\nTo look at the target object when it enters the charged object’s field, there is was a built-in function in Unity, Transform.LookAt. But as you can see from the gif, it does not smooth the transition. Object instantly looks at the target which causes a rough transition.\n\nMovement is done by interpolating the current transform of the object to its moved point by the target direction times charge value. Using charge value as it enables both attraction and repellent movement. Speed is proportional to the reverse of distance squared.\n\nWith this script, the target object is moved with WASD and arrow keys on the keyboard.\n\nIn this project, I tried to find the answer to the question of how to follow a game object while looking at it smoothly. This has been my answer. It is still very possible to improve the implementation and add other features in it.\n\nYou can find the project files here."
    },
    {
        "link": "https://gamedevbeginner.com/how-to-move-objects-in-unity",
        "document": "Moving an object in Unity can be very straightforward.\n\nIt typically involves modifying the properties of an object’s Transform component, which is used to manage a game object’s scale, rotation and, importantly, its position in the world.\n\nHowever, there are many different ways that you can do that, such as by modifying the values directly, using built-in movement functions, or by using physics, which avoids using the transform component at all. The exact method you use will depend on the type of movement it is that you want to create.\n\nFor example, you might modify an object’s transform position to create movement that’s directly attached to player input. Or, to move an object to a specific position, you might use the Move Towards function, or Lerp.\n\nAlternatively, if you don’t want to move an object manually, you can also apply force to it with a rigidbody, moving it using simulated physics instead.\n\nIn this article, you’ll learn how and when to use each of the different methods for moving an object in Unity, so that you can choose the one that’s right for your project.\n\nHow to move an object in Unity\n\nThe most straightforward method of changing an object’s position in Unity is to set it directly, which will instantly move it to a new vector 3 position in the world.\n\nThis works by setting the Position property of an object’s Transform component to a new position.\n\nOr you can add a vector to an object’s position, to move it by a set amount in a specific direction.\n\nWhich looks like this:\n\nAll this really does is change the object’s position in the game world using the transform component which, typically, all game objects have.\n\nBut, apart from when moving an object using physics, all movement in Unity involves modifying the object’s position value in some way, since movement is just a change in position that’s made frame by frame.\n\nMeaning that you’ll normally always be working with the transform component to move an object.\n\nAs a result, you’re going to be working the transform component a lot. Luckily, it’s easy to get a reference to an object’s own transform, without having to set it up yourself.\n\nThis works by accessing the Transform Property for an object, which is the word transform, with a lowercase T.\n\nThe Transform Property allows you to reference the transform component of an object from a script that’s attached to it, without needing to get a reference to it first.\n\nWhich is useful, as it means that any script can easily get, or change, an object’s position through the transform shortcut.\n\nMovement can then be created by changing the position of an object gradually, little by little every frame.\n\nThis works by adding a Vector 3 value, which is the distance and direction you want to move that frame, to the existing position of the object.\n\nBy default, this moves the object forward in world space.\n\nIt’s also possible to move an object relative to its local position, by changing the Local Position value instead.\n\nBut what is an object’s local position?\n\nLocal position refers to an object’s position and orientation relative to its parent.\n\nMeaning that an object’s local position value is the offset between a child object and the parent it’s attached to.\n\nBy default, if both objects are in the same place, the local position will be (0, 0, 0) and the child will adopt the position of its parent.\n\nChanging the local position changes the offset, and moves the object relative to its parent’s position plus whatever offset is applied, which can be useful for moving an object when it’s attached to something else.\n\nBut only if it’s attached to something else.\n\nIf the object doesn’t have a parent, its local position is the same as its world position.\n\nThis can sometimes be confusing, as it’s easy to assume that local position refers to the movement of an object relative to itself, where adding a forward vector would move it along its own Z-Axis.\n\nInstead, in order to move an object relative to its own orientation, such as to move it in the direction it’s facing, you’ll either need to use a relative direction vector (more on those later) or the Translate function.\n\nHow to use Transform Translate in Unity\n\nThe Translate function in Unity moves an object by a set amount, relative to its current position and orientation.\n\nThis is different to simply adding a vector to the object’s position, which would move it relative to world space, or its local position, which would move it relative to its parent if it has one.\n\nInstead, Translate will, by default, move an object relative to its own local space.\n\nThis means that, when using Translate, passing in a forward vector will move the object in the direction of its blue Z-Axis.\n• How to use Transform Translate in Unity\n\nWhen it’s called once, Translate moves an object by a set amount one time.\n\nHowever, just like when changing an object’s position manually, it’s possible to create continuous movement by calling the function every frame.\n\nHowever, there’s a problem with this method.\n\nFrame rates vary between devices and, because each frame often takes a different amount of time to process than the last one did, the speed of an object’s movement will change depending on the framerate.\n\nThis is because, right now, the object is always being moved two units every frame, even though every frame is different.\n\nTo avoid this, you’ll need to scale the object’s movement by Delta Time.\n\nDelta time is a constantly updated value that measures how long the previous frame took to process.\n\nTypically, when doing anything over time, such as movement, you’ll need to use delta time to scale the rate of change so that it’s consistent.\n\nThis works by multiplying the speed of the change, such as an object’s movement amount, by the delta time value.\n\nWhat this does is change the movement amount that’s applied from a units per frame value, to a units per second value.\n• How to use Delta Time in Unity (and when not to)\n\nThis means that you can change the framerate, or it can dip up and down, as it’s likely to do, and the rate of movement will always be the same.\n\nWhich looks like this:\n\nThis works fine, however, it can sometimes be more convenient to manage movement direction and speed separately, by using a Unit Vector to determine the direction that an object will move, and a separate float value to control the speed.\n\nThis has the same effect as manually typing out the vector, except that the speed is now separate and can easily be changed.\n\nIn this example, Vector3.forward is shorthand for (0,0,1) which is the forward direction in world space.\n\nMultiplying Vector3.forward by the speed value, in this case 2, creates the vector (0,0,2) which, when multiplied by Delta Time, creates a forward movement of two units per second.\n\nThe result is the same as when manually typing out the vector, except that the speed is now separate and can be controlled much more easily.\n\nCreating object-relative movement in this way can be useful for adding player controls, where the player can move an object forward, backwards or sideways using input axes, such as from the keyboard.\n\nYou’d usually use object-relative movement like this when allowing the player to control an object.\n\nBut how can you turn player input into object movement?\n\nHow to move an object with the keyboard in Unity\n\nTo move an object with the keyboard, or with any other input device, simply multiply the direction of movement you want to apply, such as forward, for example, by the Input Axis you want to use to control it.\n\nIn Unity, when using the default Input Manager, you’ll find an Input Axis for Horizontal and Vertical movement already set up and mapped to the WASD keys and arrow keys on the keyboard.\n• Input in Unity made easy (a complete guide to the new system)\n\nEach axis returns a value between -1 and 1, which means that you can use the value that’s returned to create a movement vector.\n\nThis allows you to create object-relative movement controls using the keyboard or any other input device.\n\nWhich looks like this:\n\nThe Translate function creates movement that’s relative to the Transform component that it’s called from.\n\nHowever, you may not always want to create player-relative movement.\n\nSo how can you move an object in a direction that’s relative to a different object, such as the camera, for example?\n\nHow to move an object, relative to the camera\n\nIt’s possible to move an object relative to the position of the camera in Unity by using the camera’s forward vector in place of the object’s forward vector.\n\nBecause the movement is relative to the camera’s position, the Relative To parameter in the Translate function needs to be set to World Space for this to work.\n\nHowever, because the forward vector of the camera may, in some cases, be facing down at an angle, you’ll need to remove the height offset between the camera and the object and manually calculate the direction towards it.\n• How to create Camera Relative movement in Unity\n\nEssentially, this is to stop the object moving down through the floor, instead of forwards.\n\nTo calculate the direction, subtract the position of the origin from the position of the target and then, normalise the result.\n\nThen, to remove the height difference between the two objects, create a new Vector 3 that replaces the camera’s height with the object’s Y position instead.\n\nThis will return a direction that is looking towards the object, but isn’t looking up or down.\n\nYou can then use the corrected direction that’s created to calculate movement that’s relative to the camera on a flat plane.\n\nWhich looks like this:\n\nBy understanding the relative direction of an object, it’s possible to create any kind of movement control that you want.\n\nHowever, a lot of the time, you may want to move an object in a different way, that’s not directly controlled by the player.\n\nFor example, moving an object to a set position or towards another object.\n\nHow to move an object to a position in Unity\n\nGenerally speaking, there are two different ways to move an object into a specific position.\n• By Speed, where the object moves towards a target at a specific speed,\n• By Time, where the movement between the two points takes a specific amount of time to complete.\n\nThe method you use to move the object will depend on how you want to control its movement, by time or by speed.\n\nSo how does it work?\n\nHow to move an object to a position at a set speed (using Move Towards)\n\nIt’s possible to move an object towards another object or a specific position in the scene using the Move Towards function.\n\nMove Towards is a function of the Vector 3 Class that will modify a Vector 3 value to move towards a target at a set speed without overshooting.\n\nWhich works great for moving an object towards a position in the world at a speed you can control.\n\nThe movement can also be smoothed, by using the Smooth Damp function, which eases the movement as it starts and ends.\n\nThis works by setting the position of the object to the Vector 3 result of the Smooth Damp function, passing in a target, the current position and a reference Vector 3 value, which the function uses to process the velocity of the object between frames.\n\nThis can be useful for smoothed continuous movement, where the target position may change from one moment to the next such as when following the player with a camera.\n\nSuch as in this example of a smooth camera follow script using Smooth Damp:\n\nIn this example, the camera will smoothly move towards the player and turn to face them, while keeping at a height of 3 units and trying to stay at a distance of 5 units away.\n• How to make a Follow Camera in Unity\n\nMove Towards works great as a way to move an object towards a position dynamically.\n\nThis is because the movement is speed-based, and can be easily controlled even if the target position moves while the object is moving towards it.\n\nHowever, there may be times when you want to control the movement of an object using time, not speed.\n\nSuch as when moving a platform, or opening a door.\n\nSo how can you create time based movement in Unity?\n\nHow to move an object to a position in a set amount of time (using Lerp)\n\nLerp, or Linear Interpolation, is used to find a value between a minimum and maximum based on a position value, ‘t’, which is a float between zero and one.\n\nThe value that’s returned depends on the value of t where, if t is 0 the minimum value is returned, while 1 returns the maximum value.\n\nAny other value in between 0 and 1 will return a representative value between the minimum and maximum ends of the scale.\n\nLerp is, actually, very simple, and all it really does is return a weighted value between two others.\n• The right way to use Lerp in Unity (with examples)\n\nHowever, in practice, Lerp is often used to change a value over a known period of time, by incrementing t every frame to return a new value on the scale that’s closer to a target.\n\nThis can be used to change a colour, fade an audio source or move an object between two points.\n\nIt works by passing in the amount of time that has elapsed during the Lerp, divided by the total duration. This returns a 0-1 float that can be used for the t value, and allows you to control the length of the Lerp movement by simply choosing how long you’d like it to take.\n\nVector3.Lerp works in the same way except that, instead of returning a float, it returns a point in the world between two others, based on the t value.\n\nThis can be useful for moving an object between two different positions, such as a door with an open and closed state.\n\nIn this example, I’ve used a coroutine to move the door object up by a set distance from the door’s starting position, whenever the Operate Door function is called.\n\nWhich looks like this:\n\nThis creates a linear movement from one position to another, however, it’s also possible to smooth the Lerp’s movement using the Smooth Step function.\n\nThis works by modifying the t value with the Smooth Step function before passing it into Lerp.\n\nThis will ease the movement of the object at the beginning and end of the Lerp.\n\nThese methods work well for creating controlled precise movements in Unity.\n\nBut, what if you don’t want to control an object’s movement precisely?\n\nWhat if you’d rather push, pull or throw an object, to create movement using physical forces instead?\n\nHow to move an object using physics\n\nMost rendered objects in Unity have a Collider component attached to them, which gives them a physical presence in the world.\n\nHowever, an object with just a collider is considered, by Unity, to be Static, meaning that it’s not supposed to move.\n\nTo move an object under physics simulation, you’ll also need to add a Rigidbody component to it, which allows it to move, and be moved, by physical forces, such as gravity.\n\nYou can also move a physics object by applying force to its Rigidbody using the Add Force function.\n\nThis works in a similar way to the Translate function except that the vector you pass in is a physical force, not a movement amount.\n\nHow much the object moves as a result will depend on physical properties such as mass, drag and gravity.\n\nThere are two main ways to apply physical force on an object.\n\nYou can either apply force continuously, building momentum and speed over time, or all at once in an impulse, like hitting an object to move it.\n\nBy default, the Add Force function applies a continuous force, like a thruster gradually lifting a rocket.\n\nNotice that I’ve used Fixed Update, and not Update, to apply the force to the object.\n\nThis is because Fixed Update is called in sync with the physics system, which runs at a different frequency to Update, which is often faster and can vary from frame to frame.\n\nDoing it this way means that the application of force is in sync with the physics system that it affects.\n\nAlternatively, you can also apply force in a single burst, using the Impulse Force Mode.\n\nThis will apply an amount of force to an object all at once:\n\nWhich can be useful for faster, more explosive movements, such as making an object jump.\n• How to jump in Unity (with or without physics)\n\nHow to move a Rigidbody (without using force)\n\nNormally, when you’re moving an object using physics, you might typically apply force to move it around in a realistic way.\n\nBut, what if you want to use the physics system but you want to move the object directly, in the same way as moving it using its transform component?\n\nIt’s possible to do this by using the Move Position function, which is a rigidbody method that will move an object to a precise position in a similar way to setting its transform position.\n\nThis is slightly different to setting the rigidbody’s position value directly, which effectively teleports an object to a new position using its rigidbody.\n\nThe Move Position function, however, while it basically does the same thing, is assumed to be moving the object from one position to the next.\n• How to use the Move Position function in Unity\n\nWhat this means is that, if you’ve enabled interpolation on the rigidbody, its visual position will still be smoothed between the, typically slower, fixed update calls, even though the object is being moved manually and not with forces.\n\nAs a result, if you want to change the position of a physics object immediately, to teleport it somewhere else, set its Rigidbody Position value, but if you want to move it, gradually, use the Move Position function instead."
    }
]