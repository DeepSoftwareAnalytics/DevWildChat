[
    {
        "link": "https://wiki.osdev.org/Inline_Assembly",
        "document": "The idea behind Inline Assembly is to embed assembler instructions in your C/C++ code, using the keyword, when there's no option but to use Assembly language.\n\nSometimes, even though C/C++ is your language of choice, you need to use some assembler code in your operating system. Be it because of extreme optimization needs or because the code you're implementing is highly hardware-specific (like, say, outputting data through a port), the result is the same: there's no way around it. You must use assembly.\n\nOne of the options you have is writing an assembly function and calling it, however there can be times when even the \"call\" overhead is too much for you. In that case, what you need is inline assembly, which means inserting arbitrary assembly snippets in the middle of your code, using the keyword. The way this keyword works is compiler-specific. This article describes the way it works in GCC since it is by far the most used compiler in the OS world.\n\nThis is the syntax for using the keyword in your C/C++ code:\n\nAssembler template is basically GAS-compatible code, except when you have constraints, in which case register names must start with %% instead of %. This means that the following two lines of code will both move the contents of the register into :\n\nNow, you may wonder why this %% comes in. This is where an interesting feature of inline assembly comes in: you can make use of some of your C variables in your assembly code. And since, in order to make implementation of this mechanism simpler, GCC names these variables %0, %1, and so on in your assembly code, starting from the first variable mentioned in the input/output operand sections. You're required to use this %% syntax in order to help GCC differentiate between registers and parameters.\n\nHow exactly operands work will be explained in more details in later sections. For now, it is sufficient to say that if you write something like that:\n\nthen you've managed to copy the value of \"a\" into \"b\" using assembly code, effectively using some C variables in your assembly code. Congratulations!\n\nThe last \"clobbered register\" section is used in order to tell GCC that your code is using some of the processor's registers, and that it should move any active data from the running program out of this register before executing the asm snippet. In the example above, we move to eax in the first instruction, effectively erasing its content, so we need to ask GCC to clear this register from unsaved data before operation.\n\nThe Assembler Template defines the assembler instructions to inline. The default is to use AT&T syntax here. If you want to use Intel syntax, should be specified as a command-line option.\n\nAs an example, to halt the CPU, you just have to use the following command:\n\nThe Output Operands section is used in order to tell the compiler / assembler how it should handle C variables used to store some output from the ASM code. The Output Operands are a list of pairs, each operand consisting of a string literal, known as \"constraint\", stating where the C variable should be mapped (registers are generally used for optimal performance), and a C variable to map to (in parentheses).\n\nIn the constraint, 'a' refers to EAX, 'b' to EBX, 'c' to ECX, 'd' to EDX, 'S' to ESI, and 'D' to EDI (read the GCC manual for a full list), assuming that you are coding for the IA32 architecture. An equation sign indicates that your assembly code does not care about the initial value of the mapped variable (which allows some optimization). With all that in mind, it's now pretty clear that the following code sets EAX = 0.\n\nNotice that the compiler enumerates the operand starting with %0, and that you don't have to add a register to the clobbered register list if it's used to store an output operand. GCC is smart enough to figure out what to do all by itself.\n\nStarting with GCC 3.1, you can use more readable labels instead of the error-prone enumeration:\n\nThese labels are in a namespace of their own, and will not collide with any C identifiers. The same can be done for input operands, too.\n\nWhile the Output Operands are generally used for... well... output, the Input Operands allows to parametrize the ASM code; i.e., passing read-only parameters from C code to ASM block. Again, string literals are used to specify the details.\n\nIf you want to move some value to EAX, you can do it the following way (even though it would certainly be pretty useless to do so instead of directly mapping the value to EAX):\n\nNote that GCC will always assume that input operands are read-only (unchanged). The correct thing to do when input operands are written to is to list them as outputs, but without using the equation sign because this time their original value matters. Here is a simple example:\n\nEax will contain \"amount\" and be moved into ebx.\n\nIt is important to remember one thing: The C/C++ compiler knows nothing about Assembler. For the compiler, the asm statement is opaque, and if you did not specify any output, it might even come to the conclusion that it's a no-op and optimize it away. Some third-party docs indicate that using asm volatile will cause the keyword to not be moved. However, according to the GCC documentation, The volatile keyword indicates that the instruction has important side-effects. GCC will not delete a volatile asm if it is reachable., which only indicates that it will not be deleted (i.e. whether it may still be moved is an unanswered question). An approach that should work is to use asm (volatile) and put memory in the clobber registers, like so:\n\nSince the compiler uses CPU registers for internal optimization of your C/C++ variables, and doesn't know about ASM opcodes, you have to warn it about any registers that might get clobbered as a side effect, so the compiler can save their contents before making your ASM call.\n\nThe Clobbered Registers List is a comma-separated list of register names, as string literals.\n\nWildcards: How you can let the compiler choose\n\nYou don't need to tell the compiler which specific register it should use in each operation, and in general, except you have good reasons to prefer one register specifically, you should better let the compiler decide for you.\n\nForcing to use EAX over any other register, for instance, may force the compiler to issue code that will save what was previously in eax in some other register or may introduce unwanted dependencies between operations (pipeline optimization broken)\n\nThe 'wildcards' constraints allows you to give more freedom to GCC when it comes to input/output mapping:\n\nThere are of course a lot more constraints you can put on the operand selection, machine-dependent or not, which are listed in GCC's manual (see [1], [2], [3], and [4]).\n\nis not a keyword when using . Simply use to use C99 with GNU extensions. Alternatively, you can use as an alternate keyword that works even when the compiler strictly adheres to the standard.\n\nIt is possible to assign so-called ASM labels to C/C++ keywords. You can do this by using the command on variable definitions, as seen in this example:\n\nHere's an example of how you can access these variables if you don't explicitly state a name:\n\nNote that you might also be obliged to use _some_obscure_name (with a leading underscore), depending on your linkage options.\n\nBefore GCC 4.5, jumping across inline assembly blocks is not supported. The compiler has no way of keeping track of what's going on, so incorrect code is almost guaranteed to be generated. \n\nYou might have been told that \"gotos are evil\". If you believe that is so, then asm gotos are your worst nightmare coming true. However, they do offer some interesting code optimization options.\n\nasm goto's are not well documented, but their syntax is as follows:\n\nOne example where this can be useful, is the CMPXCHG instruction (see Compare and Swap), which the Linux kernel source code defines as follows:\n\nIn addition to returning the current value in EAX, CMPXCHG sets the zero flag (Z) when successful. Without asm gotos, your code will have to check the returned value; this CMP instruction can be avoided as follows:\n\nThis new macro could then be used as follows:\n\nYou can let GCC use intel syntax by enabling it in inline Assembly, like so:\n\nSimilarly, you can switch back to AT&T syntax by using the following snippet:\n\nThis way you can combine Intel syntax and AT&T syntax inline Assembly. Note that once you trigger one of these syntax types, everything below the command in the source file will be assembled using this syntax, so don't forget to switch back when necessary, or you might get lots of compile errors!\n\nThere is also a command-line option to globally trigger Intel syntax.\n\nGCC also supports multiple assembler dialects by wrapping text in braces separated by a vertical bar. The two examples above can be combined as follows, where the first version will be emitted when is used, or no is provided, and the second will be used when is provided.\n• Inline Assembly/Examples - useful and commonly used functions\n• Inline assembly for x86 in Linux (by IBM)"
    },
    {
        "link": "https://learn.microsoft.com/en-us/cpp/assembler/inline/inline-assembler?view=msvc-170",
        "document": "Assembly language serves many purposes, such as improving program speed, reducing memory needs, and controlling hardware. You can use the inline assembler to embed assembly-language instructions directly in your C and C++ source programs without extra assembly and link steps. The inline assembler is built into the compiler, so you don't need a separate assembler such as the Microsoft Macro Assembler (MASM).\n\nPrograms with inline assembler code are not fully portable to other hardware platforms. If you are designing for portability, avoid using inline assembler.\n\nInline assembly is not supported on the ARM and x64 processors. The following topics explain how to use the Visual C/C++ inline assembler with x86 processors:\n• None Using C or C++ in __asm Blocks\n• None Using and Preserving Registers in Inline Assembly"
    },
    {
        "link": "https://stackoverflow.com/questions/15534899/simple-x86-64-c-inline-assembly-hello-world-example",
        "document": "The code you have posted is 16-bit code. 64-bit Windows (or any version of Linux) doesn't support 16-bit code. [And it's a bit buggy, since it sets the length to 6, when the actual length of the string is 12...]\n\nYou could possibly figure out how to do the same thing in Windows code, but I fail to see the point of learning how to make system calls in Windows from assembler. Write some code that does something that you can actually apply in real life, such as counting the number of characters in a string.\n\nOf course, you will need to use either Intel or GCC compilers, since the Microsoft compiler doesn't allow inline assembler in 64-bit mode.\n\nHere's a little sample of inline assembler using the \"read timestamp counter\" instruction, which will work with the gcc compiler (and by compatibility should work with the Intel compiler too)."
    },
    {
        "link": "https://reddit.com/r/programming/comments/dmzyy4/i_went_through_gccs_inline_assembly_documentation",
        "document": "Create your account and connect with a world of communities.\n\nBy continuing, you agree to our\n\nand acknowledge that you understand the"
    },
    {
        "link": "https://learn.microsoft.com/en-us/cpp/intrinsics/compiler-intrinsics-and-assembly-language?view=msvc-170",
        "document": "This section of the documentation contains information about compiler intrinsics and the assembly language."
    },
    {
        "link": "https://stackoverflow.com/questions/53960240/armv8-floating-point-output-inline-assembly",
        "document": "is the constraint for GP integer registers.\n\nThe GCC manual claims that is the constraint for an FP / SIMD register on AArch64. But if you try that, you get not , which won't assemble. I don't know a workaround here, you should probably report on the gcc bugzilla that the constraint documented in the manual doesn't work for scalar FP.\n\nOn Godbolt I tried this source:\n\nclang7.0 (with its built-in assembler) requires the asm to be actually valid. But for gcc we're only compiling to asm, and Godbolt doesn't have a \"binary mode\" for non-x86.\n\nclang produces the same asm, and its built-in assembler errors with:\n\nOn 32-bit ARM, for single works, but for (which the manual says you should use for double-precision) also gives you with gcc. It works with clang, though. You have to use and a something with an FPU, e.g.\n\nSo you can use for single just fine with gcc, but for presumably you need a modifier to print the register name as instead of , with a output.\n\nObviously these asm statements would only be useful for anything beyond learning the syntax if you add constraints to specify the input operands as well, instead of reading whatever happened to be sitting in s3 and s4."
    },
    {
        "link": "https://stackoverflow.com/questions/58958751/creating-a-c-pre-increment-operation-with-clang-inline-assembly",
        "document": "Your code is overly complex and it appears you might have looked at compiler generated code from elsewhere to create an answer.\n\nWhat does do? It first increments and then assigns that value to . In such an expression is both used as input and output. The value of is read, incremented by 1, saved and the result copied to . With GCC's extended inline assembly you can treat as an input and output operand using the modifier on the constraint. can be used with an output only operand using the modifier on the constraint. The instruction can be used to increment and the instruction to copy that value .\n\nThe inline assembly could simply look like:\n\nThe output should be:\n\nNote: Since there are no side effects other than the registers we told the compiler we'd modify it isn't necessary to use on the statement."
    },
    {
        "link": "https://firexfly.com/clang-inline-assembly",
        "document": "This was originally intended as a follow-up to my LLDB and Clang cheat sheet to jot down what I learned about writing inline assembly on macOS and how it differs from the Visual Studio implementation on Windows which was taught in my programming class. Only I never got around to writing it because of work and studies taking up all my time. So three and half years later, here’s how to write inline assembly on macOS and Clang.\n\nIn this post, I will introduce the concept of inline assembly and its usage. I will then describe what I learned about inline assembly before delving into what I found out when I replicated the Windows material from my class notes on my mac. This is not a post on assembly language so it will only be referenced at a relatively high level and the examples will be fairly simplistic. There is some exceptionally good material to learn inline assembly from but it is hard to find and mostly referenced in obscure places. This post references the best resources I found all in one place.\n\nWhen C programs are compiled, they are first converted into assembly language and then assembled and linked to create an executable. The process is described in the book ‘Computer Systems A Programmer’s Perspective’ by Randal Bryant and David O’Hallaron.\n• Preprocessor – The C source code is preprocessed to remove comments, replace constants with their values and insert the contents of the included header files.\n• Compiler – The modified source is compiled into assembly language.\n• Assembler – The assembly code is assembled and relocatable object programs are output. Unlike the previous stages, these files are in binary format.\n• Linker – Links the relocatable objects and outputs the final executable binary. This stage will link the code from the standard library and other libraries with your code.\n\nConversion to assembly language is a part of the compilation process however, the major compilers allow assembly to be written inline, within a program. The main reason for using inline assembly is writing highly optimized code where efficiency is of the utmost importance and the optimizations provided by the compiler are insufficient. It’s likely many programmers will never encounter inline assembly but if you work with an operating system kernel you may come across asm macros.\n\nThere are differences between 32-bit and 64-bit x86 assembly, most notably for this blog post:\n• The calling convention on 32-bit systems involved pushing the function arguments onto the stack before calling the function. The 64-bit convention involves using the registers , , , , , for the first six arguments and pushing the remainder onto the stack in reverse order, such that they are popped off in order.\n• The addition of new registers: – .\n• The addition of the 64-bit registers: 32-bit systems use registers such as which are 32 bits in size. These are still available as the lower 32 bits of their 64-bit equivalents. The 64-bit registers start with an r so for a full example: , , , for the register’s 64, 32, 16 and 8 bit variations. Microsoft published a useful table for each register.\n\nOn Windows, the Visual Studio IDE is capable of handling inline assembly. The syntax is fairly straightforward. Intel assembly syntax is used and enclosed in an block. All variables in scope of the block are accessible using inline assembly and can even be accessed using their high level variable name. Visual Studio will generate the appropriate assembly code to allow this to work, making its inline assembly much like a hybrid between C and Assembly.\n\nA very simple example to demonstrate these features is shown below. This code sets two integer variables ( and ) in C and then uses inline assembly to set the value of the variable to equal the value in the variable. This code is also using 32-bit x86 assembly language.\n\nThe default compiler on modern versions of macOS is Clang with the LLVM toolchain which can be installed with the Xcode developer tools. Clang is compatible with GCC inline assembly. The use of Extended Asm allows the reading and writing of C variables within inline assembly blocks.\n\nWhen writing inline assembly on a mac, it is required to use AT&T syntax, rather than Intel, as Windows does. The main differences to be aware of are that AT&T register operands are preceded by as opposed to their undelimited Intel equivalents. The order for source and destination operands is reversed e.g. . And mnemonic suffixes of , , and are used in AT&T assembly to specify the size of memory operands e.g. to move a 32-bit (word). Intel, on the other hand, prefixes memory operands.\n\nAnother requirement on macOS is to use 64-bit assembly language. Modern macs removed support for 32-bit applications and I wasn’t even able to find a way to compile 32-bit applications when I studied this module. As a result, all of the examples in this section use x86_64 assembly.\n\nAll of the examples in this post will use extended assembly. An example of the general format is shown below. The keen-eyed will notice that this is the same program demonstrated in the Windows section, translated to GCC inline assembly.\n\nThe assembly code is contained in an statement, though is also valid if conflicts with something in your code. The use of extended assembly is indicated by the presence of the input, output and clobber lists, beginning with colon characters at the end of the assembly code. The format is to show a variable that will be written in the output list, for a variable that will be read in the input list. And the clobber list is just a list of clobbered (changed) registers. Multiple entries are entered by comma separating a list of items in this format.\n\nIn this example, a few things should stand out that differentiate inline assembly from assembly code. Firstly, the and are the variables which were passed in using the input/output lists. It is possible to specify a register here, such as to store an input variable in the register ( ) but in this case the compiler will choose a register and this may ultimately lead to better optimization. Because there is no way to know which register the compiler chose, the registers and so on are used. This leads to the next point: registers have two percent signs for example . The single percent syntax is already in use for the variables, GCC inline assembly uses two to refer to literal registers. Furthermore, each instruction is enclosed in quotes.\n\nIn another very simple example, a constant (the decimal value five hundred) will be written to a variable using a compiler-chosen register. Constants have a prepended because this is the syntax used to identify an immediate operand in AT&T assembler. Furthermore, the decimal value could also be entered as hexadecimal using the syntax\n\nFunctions can be called using the instruction. As described above, registers are used to pass parameters so a simple example, to call , looks like the following:\n\nNot all registers are saved across calls. Some, for example, the register which is used for passing the 1st argument to a function, are not. In the following example, only the first call to has the argument “Hello world!”.\n\nA function like takes parameters but does not return any values. In this example, I have written a user defined function – – which takes two integers and returns the value of the first minus the second. This demonstrates that the return value is placed in the register and in this case, it is moved to as a final step to assign the result variable to it.\n\nAnother example, using 32-bit registers and a compiler-chosen register is also shown for demonstration:\n\nIn the last example, I used a C function to subtract an integer from another integer which demonstrated a point about return values nicely but is contrived. In real life, the inbuilt instructions for math operations would be used instead. In this section some basic math instructions will be introduced. Division is a little more complex and not shown here because it was out of scope of the module.\n\nTying it all together\n\nIn this final example, the arguments passed to the program via are printed. Many of the techniques shown in this post and more are demonstrated here. This is not a perfect snippet, I did not manage to get everything to work exactly like I wanted in the week I had to learn all this. The main compromise I had to make was to hard code the number of arguments to print. To stay true to the original post (and because I’m lazy), I will not be updating this code.\n\nWith the release of the M1 chip, Apple is making a move away from Intel and towards using their own silicon in macs. In terms of inline assembly, this means none of the examples above will work anymore. However, Clang is entirely capable of supporting ARM assembly language and the extended assembly format remains largely valid, but the code must be written using ARM assembly. This incompatibility highlights the fact that assembly language is not very portable and why using inline assembly should be avoided where possible in favor of portable C/C++ (or maybe Rust). Full disclosure, as a poor student, I am still using the same mac I was before I started at university. As such, while I can cross-compile a program using inline assembly, I can’t actually try running it on an M1 mac – sad.\n\nThe very first example is shown below, translated to ARM. For a full explanation of the ARM registers, see the documentation.\n\nI had a fair few problems getting this to compile and in the end, the single line from to is the only thing that actually didn’t throw any errors. Of course this is still untested and may not work anyway. Some interesting differences with ARM is how new lines are inserted, the size is indicated in the variables and the source/destination operands are the same way around as Intel assembly. For a tutorial on ARM assembly, see Azeria’s blog series.\n\nBy learning how code in a high level language, such as C, translates into machine code is useful because it can help during debugging. Understanding the low level details can lead to becoming a better programmer in general. Inline assembly can be a useful tool for those writing highly optimized code. However, the limitations with the lack of portability and added complexity of the language make it impractical for many general purpose situations.\n\nIn Cyber Security, understanding assembly helps to uncover how janky computers really are ‘under the hood’. Higher level languages hide the details behind a beautiful veil of magic where functions take parameters and return results in near English language. Learning assembly can show the sometimes ugly truth of what’s really going on and how your variables are even represented. Therefore, understanding assembly language is a vital skill in many security jobs such as reverse engineering and exploit development. Inline assembly can make starting to write assembly code more accessible."
    },
    {
        "link": "https://reddit.com/r/cpp/comments/4bur2d/how_do_i_pass_floating_point_values_from_c_to",
        "document": "So I've been stuck on trying to write a function that takes a floating point input and returns an integer value. At the moment I'm stuck on where the floating point value is stored when it is being passed to the assembly function. Here's what I've got so far. C++ file:\n\nThe function is supposed to take a latitude value and convert it to an x position for a bitmap image. This isn't near being finished but I'm getting flustered and overwhelmed trying to figure out the nuances of assembly language.\n\nTL; DR in which register is a floating point value held when being passed to an assembly function?"
    },
    {
        "link": "https://clang.llvm.org/docs/UsersManual.html",
        "document": "This section is generally an index into other sections. It does not go into depth on the ones that are covered by other sections. However, the first part introduces the language selection and other high level options like , , etc. Turn warning “foo” into a warning even if is specified. Enable warning “foo”. See the diagnostics reference for a complete list of the warning flags that can be specified in this way. Stop emitting diagnostics after 123 errors have been produced. The default is 20, and the error limit can be disabled with . Only emit up to 123 template instantiation notes within the template instantiation backtrace for a single warning or error. The default is 10, and the limit can be disabled with . Suppress certain diagnostics for certain files. Clang aims to produce beautiful diagnostics by default, particularly for new users that first come to Clang. However, different people have different preferences, and sometimes Clang is driven not by a human, but by a program that wants consistent and easily parsable output. For these cases, Clang provides a wide range of options to control the exact output format of the diagnostics that it generates. This option, which defaults to on, controls whether or not Clang prints the column number of a diagnostic. For example, when this is enabled, Clang will print something like: When this is disabled, Clang will print “test.c:28: warning…” with no column number. The printed column numbers count bytes from the beginning of the line; take care if your source contains multibyte characters. This option, which defaults to on, controls whether or not Clang prints the filename, line number and column number of a diagnostic. For example, when this is enabled, Clang will print something like: When this is disabled, Clang will not print the “test.c:28:8: ” part. Print source line and ranges from source code in diagnostic. This option, which defaults to on, controls whether or not Clang prints the source line, source ranges, and caret when emitting a diagnostic. For example, when this is enabled, Clang will print something like: This option, which defaults to on when a color-capable terminal is detected, controls whether or not Clang prints diagnostics in color. When this option is enabled, Clang will use colors to highlight specific parts of the diagnostic, e.g., When this is disabled, Clang will just print: If the environment variable is defined and not empty (regardless of value), color diagnostics are disabled. If is defined and is passed on the command line, Clang will honor the command line argument. Controls whether ANSI escape codes are used instead of the Windows Console API to output colored diagnostics. This option is only used on Windows and defaults to off. Changes diagnostic output format to better match IDEs and command line tools. This option controls the output format of the filename, line number, and column printed in diagnostic messages. The options, and their affect on formatting a simple conversion diagnostic, follow: This option, which defaults to on, controls whether or not Clang prints the associated warning group option name when outputting a warning diagnostic. For example, in this output: Passing -fno-diagnostics-show-option will prevent Clang from printing the [ ] information in the diagnostic. This information tells you the flag needed to enable or disable the diagnostic, either from the command line or through #pragma GCC diagnostic. This option, which defaults to “none”, controls whether or not Clang prints the category associated with a diagnostic when emitting it. Each diagnostic may or many not have an associated category, if it has one, it is listed in the diagnostic categorization field of the diagnostic line (in the []’s). For example, a format string warning will produce these three renditions based on the setting of this option: This category can be used by clients that want to group diagnostics by category, so it should be a high level category. We want dozens of these, not hundreds or thousands of them. Enable optimization remarks during compilation and write them to a separate file. This option, which defaults to off, controls whether Clang writes optimization reports to a separate file. By recording diagnostics in a file, users can parse or sort the remarks in a convenient way. By default, the serialization format is YAML. The output file is controlled by . In the absence of an explicit output file, the file is chosen using the following scheme: where is based on the output file of the compilation (whether it’s explicitly specified through or not) when used with or . For example: When targeting (Thin)LTO, the base is derived from the output filename, and the extension is not dropped. When targeting ThinLTO, the following scheme is used: Darwin-only: when used for generating a linked binary from a source file (through an intermediate object file), the driver will invoke to generate a temporary object file. The temporary remark file will be emitted next to the object file, which will then be picked up by and emitted in the .dSYM bundle. This is available for all formats except YAML. Darwin-only: compiling for multiple architectures will use the following scheme: Note that this is incompatible with passing the option. Control the file to which optimization reports are written. This implies -fsave-optimization-record. On Darwin platforms, this is incompatible with passing multiple options. Only include passes which match a specified regular expression. When optimization reports are being output (see -fsave-optimization-record), this option controls the passes that will be included in the final report. If this option is not used, all the passes are included in the optimization record. This option controls whether Clang prints the profile hotness associated with diagnostics in the presence of profile-guided optimization information. This is currently supported with optimization remarks (see Options to Emit Optimization Reports). The hotness information allows users to focus on the hot optimization remarks that are likely to be more relevant for run-time performance. For example, in this output, the block containing the callsite of was executed 3000 times according to the profile data: This option is implied when -fsave-optimization-record is used. Otherwise, it defaults to off. Prevent optimization remarks from being output if they do not have at least this hotness value. This option, which defaults to zero, controls the minimum hotness an optimization remark would need in order to be output by Clang. This is currently supported with optimization remarks (see Options to Emit Optimization Reports) when profile hotness information in diagnostics is enabled (see -fdiagnostics-show-hotness). This option, which defaults to on, controls whether or not Clang prints the information on how to fix a specific diagnostic underneath it when it knows. For example, in this output: Passing -fno-diagnostics-fixit-info will prevent Clang from printing the “//” line at the end of the message. This information is useful for users who may not understand what is wrong, but can be confusing for machine parsing. Print machine parsable information about source ranges. This option makes Clang print information about source ranges in a machine parsable format after the file/line/column number information. The information is a simple sequence of brace enclosed ranges, where each range lists the start and end line/column locations. For example, in this output: The {}’s are generated by -fdiagnostics-print-source-range-info. The printed column numbers count bytes from the beginning of the line; take care if your source contains multibyte characters. This option makes Clang print available Fix-Its in a machine parseable format at the end of diagnostics. The following example illustrates the format: The range printed is a half-open range, so in this example the characters at column 25 up to but not including column 29 on line 7 in t.cpp should be replaced with the string “Gamma”. Either the range or the replacement string may be empty (representing strict insertions and strict erasures, respectively). Both the file name and the insertion string escape backslash (as “\\\\”), tabs (as “\\t”), newlines (as “\n\n”), double quotes(as “\\””) and non-printable characters (as octal “\\xxx”). The printed column numbers count bytes from the beginning of the line; take care if your source contains multibyte characters. The default for template type printing is to elide as many template arguments as possible, removing those which are the same in both template types, leaving only the differences. Adding this flag will print all the template arguments. If supported by the terminal, highlighting will still appear on differing arguments. For diffing large templated types, this option will cause Clang to display the templates as an indented text tree, one argument per line, with differences marked inline. This is compatible with -fno-elide-type. Controls how many lines of code clang prints for diagnostics. By default, clang prints a maximum of 16 lines of code. Controls whether clang will print a margin containing the line number on the left of each line of code it prints for diagnostics. TODO: Generate this from tblgen. Define one anchor per warning group. Warn about excess tokens at the end of a preprocessor directive. This option, which defaults to on, enables warnings about extra tokens at the end of preprocessor directives. For example: These extra tokens are not strictly conforming, and are usually best handled by commenting them out. Warn about unqualified uses of a member template whose name resolves to another template at the location of the use. This option, which defaults to on, enables a warning in the following code: C++ [basic.lookup.classref] requires this to be an error, but, because it’s hard to work around, Clang downgrades it to a warning as an extension. Warn about an unusable copy constructor when binding a reference to a temporary. This option enables warnings about binding a reference to a temporary when the temporary doesn’t have a usable copy constructor. For example: Note that if has a default argument whose instantiation produces a compile error, that error will still be a hard error in C++98 mode even if this warning is turned off. As unbelievable as it may sound, Clang does crash from time to time. Generally, this only occurs to those living on the bleeding edge. Clang goes to great lengths to assist you in filing a bug report. Specifically, Clang generates preprocessed source file(s) and associated run script(s) upon a crash. These files should be attached to a bug report to ease reproducibility of the failure. Below are the command line options to control the crash diagnostics. The -fno-crash-diagnostics flag can be helpful for speeding the process of generating a delta reduced test case. Specify where to write the crash diagnostics files; defaults to the usual location for temporary files. Like , specifies where to write the crash diagnostics files, but with lower precedence than the option. Clang is also capable of generating preprocessed source file(s) and associated run script(s) even without a crash. This is specially useful when trying to generate a reproducer for warnings or errors while using modules. Generates preprocessed source files, a reproducer script and if relevant, a cache containing: built module pcm’s and all headers needed to rebuild the same modules. Optimization reports trace, at a high-level, all the major decisions done by compiler transformations. For instance, when the inliner decides to inline function into , or the loop unroller decides to unroll a loop N times, or the vectorizer decides to vectorize a loop body. Clang offers a family of flags which the optimizers can use to emit a diagnostic in three cases:\n• None When the pass fails to make a transformation ( ).\n• None When the pass determines whether or not to make a transformation ( ). NOTE: Although the discussion below focuses on , the exact same options apply to and . Since there are dozens of passes inside the compiler, each of these flags take a regular expression that identifies the name of the pass which should emit the associated diagnostic. For example, to get a report from the inliner, compile the code with: Note that remarks from the inliner are identified with . To request a report from every optimization pass, you should use (in fact, you can use any valid POSIX regular expression). However, do not expect a report from every transformation made by the compiler. Optimization remarks do not really make sense outside of the major transformations (e.g., inlining, vectorization, loop optimizations) and not every optimization pass supports this feature. Note that when using profile-guided optimization information, profile hotness information can be included in the remarks (see -fdiagnostics-show-hotness).\n• None Optimization remarks that refer to function names will display the mangled name of the function. Since these remarks are emitted by the back end of the compiler, it does not know anything about the input language, nor its mangling rules.\n• None Some source locations are not displayed correctly. The front end has a more detailed source location tracking than the locations included in the debug info (e.g., the front end can locate code inside macro expansions). However, the locations used by are translated from debug annotations. That translation can be lossy, which results in some remarks having no location information. These are options that report execution time and consumed memory of different compilations steps. This option requests driver to print used memory and execution time of each compilation step. The driver during execution calls different tools, like compiler, assembler, linker etc. With this option the driver reports total execution time, the execution time spent in user mode and peak memory usage of each the called tool. Value of the option specifies where the report is sent to. If it specifies a regular file, the data are saved to this file in CSV format: The data on each row represent:\n• None file name of the tool executable, It is possible to specify this option without any value. In this case statistics are printed on standard output in human readable format: The report file specified in the option is locked for write, so this option can be used to collect statistics in parallel builds. The report file is not cleared, new data is appended to it, thus making possible to accumulate build statistics. You can also use environment variables to control the process statistics reporting. Setting to enables the feature, the report goes to stdout in human readable format. Setting to a fully qualified file path makes it report process statistics to the given file in the CSV format. Specifying a relative path will likely lead to multiple files with the same name created in different directories, since the path is relative to a changing working directory. These environment variables are handy when you need to request the statistics report without changing your build scripts or alter the existing set of compiler options. Note that take precedence over and . Clang options that don’t fit neatly into other categories. This flag controls the value of and related macros. This flag does not enable or disable any GCC extensions implemented in Clang. Setting the version to zero causes Clang to leave and other GNU-namespaced macros, such as , undefined. When emitting a dependency file, use formatting conventions appropriate for NMake or Jom. Ignored unless another option causes Clang to emit a dependency file. When Clang emits a dependency file (e.g., you supplied the -M option) most filenames can be written to the file without any special formatting. Different Make tools will treat different sets of characters as “special” and use different conventions for telling the Make tool that the character is actually part of the filename. Normally Clang uses backslash to “escape” a special character, which is the convention used by GNU Make. The -MV option tells Clang to put double-quotes around the entire filename, which is the convention used by NMake and Jom. When to emit DWARF unwind (EH frame) info. This is a Mach-O-specific option.\n• None - Only emit DWARF unwind when compact unwind encodings aren’t available. This is the default for arm64.\n• None - Use the platform-specific default ( for all non-arm64-platforms). is a performance optimization – Clang will emit smaller object files that are more quickly processed by the linker. This may cause binary compatibility issues on older x86_64 targets, however, so use it with caution. Instruct clang not to emit the signature string for blocks. Disabling the string can potentially break existing code that relies on it. Users should carefully consider this possibiilty when using the flag. Configuration files group command-line options and allow all of them to be specified just by referencing the configuration file. They may be used, for example, to collect options required to tune compilation for particular target, such as , , , , codegen options, etc. Configuration files can be either specified on the command line or loaded from default locations. If both variants are present, the default configuration files are loaded first. The command line option can be used to specify explicit configuration files in a Clang invocation. If the option is used multiple times, all specified files are loaded, in order. For example: If the provided argument contains a directory separator, it is considered as a file path, and options are read from that file. Otherwise the argument is treated as a file name and is searched for sequentially in the directories: Both user and system directories for configuration files can be specified either during build or during runtime. At build time, use and . At run time use the and command line options. Specifying config directories at runtime overrides the config directories set at build time The first file found is used. It is an error if the required file cannot be found. The default configuration files are searched for in the same directories following the rules described in the next paragraphs. Loading default configuration files can be disabled entirely via passing the flag. First, the algorithm searches for a configuration file named where is the triple for the target being built for, and is the name of the currently used driver. The algorithm first attempts to use the canonical name for the driver used, then falls back to the one found in the executable name. The following canonical driver names are used:\n• None for the driver (used to compile C programs)\n• None for the driver (used to compile C++ programs) For example, when calling , the driver will first attempt to use the configuration file named: If this file is not found, it will attempt to use the name found in the executable instead: Note that options such as , , affect the search algorithm. For example, the aforementioned executable called with argument will instead search for: If none of the aforementioned files are found, the driver will instead search for separate driver and target configuration files and attempt to load both. The former is named while the latter is named . Similarly to the previous variants, the canonical driver name will be preferred, and the compiler will fall back to the actual name. For example, will attempt to load two configuration files named respectively: It is not an error if either of these files is not found. The configuration file consists of command-line options specified on one or more lines. Lines composed of whitespace characters only are ignored as well as lines in which the first non-blank character is . Long options may be split between several lines by a trailing backslash. Here is example of a configuration file: \\ # other config files may be included Files included by directives in configuration files are resolved relative to the including file. For example, if a configuration file contains the directive , the file is searched for in the directory . Another way to include a file content is using the command line option . It works similarly but the included file is searched for using the rules for configuration files. To generate paths relative to the configuration file, the token may be used. This will expand to the absolute path of the directory containing the configuration file. In cases where a configuration file is deployed alongside SDK contents, the SDK directory can remain fully portable by using prefixed paths. In this way, the user may only need to specify a root configuration file with to establish every aspect of the SDK with the compiler: Usually, config file options are placed before command-line options, regardless of the actual operation to be performed. The exception is being made for the options prefixed with the character. These will be used only when linker is being invoked, and added after all of the command-line specified linker inputs. Here is some example of -prefixed options:\n\nThe support for X86 (both 32-bit and 64-bit) is considered stable on Darwin (macOS), Linux, FreeBSD, and Dragonfly BSD: it has been tested to correctly compile many large C, C++, Objective-C, and Objective-C++ codebases. On , passing i128(by value) is incompatible with the Microsoft x64 calling convention. You might need to tweak in lib/CodeGen/Targets/X86.cpp. For the X86 target, clang supports the command line argument which enables 16-bit code output. This is broadly similar to using with the GNU toolchain. The generated code and the ABI remains 32-bit but the assembler emits instructions appropriate for a CPU running in 16-bit mode, with address-size and operand-size prefixes to enable 32-bit addressing and operations. Several micro-architecture levels as specified by the x86-64 psABI are defined. They are cumulative in the sense that features from previous levels are implicitly included in later levels. Intel AVX10 ISA is a major new vector ISA incorporating the modern vectorization aspects of Intel AVX-512. This ISA will be supported on all future Intel processors. Users are supposed to use the new options and on these processors and should not use traditional AVX512 options anymore. The in represents a continuous integer number starting from . is an alias of , which means to enable all instructions within AVX10 version N at a maximum vector length of 256 bits. enables all instructions at a maximum vector length of 512 bits, which is a superset of instructions enabled. Current binaries built with AVX512 features can run on Intel AVX10/512 capable processors without re-compile, but cannot run on AVX10/256 capable processors. Users need to re-compile their code with , and maybe update some code that calling to 512-bit X86 specific intrinsics and passing or returning 512-bit vector types in function call, if they want to run on AVX10/256 capable processors. Binaries built with can run on both AVX10/256 and AVX10/512 capable processors. Users can add a in the command line with AVX512 options if they want to run the binary on both legacy AVX512 and new AVX10/256 capable processors. The option has the same constraints as , i.e., cannot call to 512-bit X86 specific intrinsics and pass or return 512-bit vector types in function call. Users should avoid using AVX512 features in function target attributes when developing code for AVX10. If they have to do so, they need to add an explicit or together with AVX512 features for 512-bit or non-512-bit functions respectively to avoid unexpected code generation. Both command line option and target attribute of EVEX512 feature can only be used with AVX512. They don’t affect vector size of AVX10. User should not mix the use AVX10 and AVX512 options together at any time, because the option combinations are conflicting sometimes. For example, a combination of doesn’t show a clear intention to compiler, since instructions in AVX512F and AVX10.1/256 intersect but do not overlap. In this case, compiler will emit warning for it, but the behavior is determined. It will generate the same code as option . A similar case is , which equals to , because implies and equals to . There are some new macros introduced with AVX10 support. will enable and , while enables , , and . Besides, both and will enable all AVX512 feature specific macros. A AVX512 feature will enable both , and its own macro. So can be used to guard code that can run on both legacy AVX512 and AVX10/512 capable processors but cannot run on AVX10/256, while a AVX512 macro like cannot tell the difference among the three options. Users need to check additional macros and if they want to make distinction. The support for ARM (specifically ARMv6 and ARMv7) is considered stable on Darwin (iOS): it has been tested to correctly compile many large C, C++, Objective-C, and Objective-C++ codebases. Clang only supports a limited number of ARM architectures. It does not yet fully support ARMv5, for example. The support for PowerPC (especially PowerPC64) is considered stable on Linux and FreeBSD: it has been tested to correctly compile many large C and C++ codebases. PowerPC (32bit) is still missing certain features (e.g. PIC code on ELF platforms). clang currently contains some support for other architectures (e.g. Sparc); however, significant pieces of code generation are still missing, and they haven’t undergone significant testing. clang contains limited support for the MSP430 embedded processor, but both the clang support and the LLVM backend support are highly experimental. Other platforms are completely unsupported at the moment. Adding the minimal support needed for parsing and semantic analysis on a new platform is quite easy; see in the clang source tree. This level of support is also sufficient for conversion to LLVM IR for simple programs. Proper support for conversion to LLVM IR requires adding code to at the moment; this is likely to change soon, though. Generating assembly requires a suitable LLVM backend. Clang works on some mingw32 distributions. Clang assumes directories as below; On MSYS, a few tests might fail. For 32-bit (i686-w64-mingw32), and 64-bit (x86_64-w64-mingw32), Clang assumes as below;\n• None GCC versions 4.5.0 to 4.5.3, 4.6.0 to 4.6.2, or 4.7.0 (for the C++ header search path) This directory layout is standard for any toolchain you will find on the official MinGW-w64 website. Clang expects the GCC executable “gcc.exe” compiled for (or ) to be present on PATH. Some tests might fail on . TOC data transformation is off by default ( ). When is specified, the TOC data transformation will be applied to all suitable variables with static storage duration, including static data members of classes and block-scope static variables (if not marked as exceptions, see further below).\n• None be independently generated (i.e., not placed in a pool)\n• None be at most as large as a pointer\n• None not be aligned more strictly than a pointer\n• None not be structs containing flexible array members The TOC data transformation results in the variable, not its address, being placed in the TOC. This eliminates the need to load the address of the variable from the TOC. Note: If the TOC data transformation is applied to a variable whose definition is imported, the linker will generate fixup code for reading or writing to the variable. When multiple toc-data options are used, the last option used has the affect. For example: -mno-tocdata=g5,g1 -mtocdata=g1,g2 -mno-tocdata=g2 -mtocdata=g3,g4 results in -mtocdata=g1,g3,g4 Names of variables not having external linkage will be ignored. This is the default behaviour. Only variables explicitly specified with will have the TOC data transformation applied. Apply the TOC data transformation to all suitable variables with static storage duration (including static data members of classes and block-scope static variables) that are not explicitly specified with . Can be used in conjunction with to mark the comma-separated list of external linkage variables, specified using their mangled names, as exceptions to . Apply the TOC data transformation to the comma-separated list of external linkage variables, specified using their mangled names, if they are suitable. Emit diagnostics for all unsuitable variables specified. The option can be used to control mapping of default visibility to an explicit shared object export (i.e. XCOFF exported visibility). Three values are provided for the option:\n• None : no additional export information is created for entities with default visibility.\n• None : mark entities for export if they have explicit (e.g. via an attribute) default visibility from the source, including RTTI.\n• None : set XCOFF exported visibility for all entities with default visibility from any source. This gives a export behavior similar to ELF platforms where all entities with default visibility are exported. Clang supports generation of SPIR-V conformant to the OpenCL Environment Specification. To generate SPIR-V binaries, Clang uses the in-tree LLVM SPIR-V backend. Both invocations of Clang will result in the generation of a SPIR-V binary file for 32 bit and 64 bit respectively. This file can be imported by an OpenCL driver that support SPIR-V consumption or it can be compiled further by offline SPIR-V consumer tools. Converting to SPIR-V produced with the optimization levels other than is currently available as an experimental feature and it is not guaranteed to work in all cases. Linking is done using from the SPIRV-Tools project. Similar to other external linkers, Clang will expect to be installed separately and to be present in the environment variable. Please refer to the build and installation instructions. More information about the SPIR-V target settings and supported versions of SPIR-V format can be found in the SPIR-V target guide.\n\nclang-cl is an alternative command-line interface to Clang, designed for compatibility with the Visual C++ compiler, cl.exe. To enable clang-cl to find system headers, libraries, and the linker when run from the command-line, it should be executed inside a Visual Studio Native Tools Command Prompt or a regular Command Prompt where the environment has been set up using e.g. vcvarsall.bat. clang-cl can also be used from inside Visual Studio by selecting the LLVM Platform Toolset. The toolset is not part of the installer, but may be installed separately from the Visual Studio Marketplace. To use the toolset, select a project in Solution Explorer, open its Property Page (Alt+F7), and in the “General” section of “Configuration Properties” change “Platform Toolset” to LLVM. Doing so enables an additional Property Page for selecting the clang-cl executable to use for builds. To use the toolset with MSBuild directly, invoke it with e.g. . This allows trying out the clang-cl toolchain without modifying your project files. It’s also possible to point MSBuild at clang-cl without changing toolset by passing . When using CMake and the Visual Studio generators, the toolset can be set with the flag: When using CMake with the Ninja generator, set the and variables to clang-cl: To be compatible with cl.exe, clang-cl supports most of the same command-line options. Those options can start with either or . It also supports some of Clang’s core options, such as the options. Options that are known to clang-cl, but not currently supported, are ignored with a warning. For example: To suppress warnings about unused arguments, use the option. Options that are not known to clang-cl will be ignored by default. Use the option in order to treat them as errors. If these options are spelled with a leading , they will be mistaken for a filename: Please file a bug for any valid cl.exe flags that clang-cl does not understand. Execute to see a list of supported options: CL.EXE COMPATIBILITY OPTIONS: /? Display available options /arch:<value> Set architecture for code generation /Brepro- Emit an object file which cannot be reproduced over time /Brepro Emit an object file which can be reproduced over time /clang:<arg> Pass <arg> to the clang driver /C Don't discard comments when preprocessing /c Compile only /d1PP Retain macro definitions in /E mode /d1reportAllClassLayout Dump record layout information /diagnostics:caret Enable caret and column diagnostics (on by default) /diagnostics:classic Disable column and caret diagnostics /diagnostics:column Disable caret diagnostics but keep column info /D <macro[=value]> Define macro /EH<value> Exception handling model /EP Disable linemarker output and preprocess to stdout /execution-charset:<value> Runtime encoding, supports only UTF-8 /E Preprocess to stdout /FA Output assembly code file during compilation /Fa<file or directory> Output assembly code to this file during compilation (with /FA) /Fe<file or directory> Set output executable file or directory (ends in / or \\) /FI <value> Include file before parsing /Fi<file> Set preprocess output file name (with /P) /Fo<file or directory> Set output object file, or directory (ends in / or \\) (with /c) /fp:except- /fp:except /fp:fast /fp:precise /fp:strict /Fp<filename> Set pch filename (with /Yc and /Yu) /GA Assume thread-local variables are defined in the executable /Gd Set __cdecl as a default calling convention /GF- Disable string pooling /GF Enable string pooling (default) /GR- Disable emission of RTTI data /Gregcall Set __regcall as a default calling convention /GR Enable emission of RTTI data /Gr Set __fastcall as a default calling convention /GS- Disable buffer security check /GS Enable buffer security check (default) /Gs Use stack probes (default) /Gs<value> Set stack probe size (default 4096) /guard:<value> Enable Control Flow Guard with /guard:cf, or only the table with /guard:cf,nochecks. Enable EH Continuation Guard with /guard:ehcont /Gv Set __vectorcall as a default calling convention /Gw- Don't put each data item in its own section /Gw Put each data item in its own section /GX- Disable exception handling /GX Enable exception handling /Gy- Don't put each function in its own section (default) /Gy Put each function in its own section /Gz Set __stdcall as a default calling convention /help Display available options /imsvc <dir> Add directory to system include search path, as if part of %INCLUDE% /I <dir> Add directory to include search path /J Make char type unsigned /LDd Create debug DLL /LD Create DLL /link <options> Forward options to the linker /MDd Use DLL debug run-time /MD Use DLL run-time /MTd Use static debug run-time /MT Use static run-time /O0 Disable optimization /O1 Optimize for size (same as /Og /Os /Oy /Ob2 /GF /Gy) /O2 Optimize for speed (same as /Og /Oi /Ot /Oy /Ob2 /GF /Gy) /Ob0 Disable function inlining /Ob1 Only inline functions which are (explicitly or implicitly) marked inline /Ob2 Inline functions as deemed beneficial by the compiler /Ob3 Same as /Ob2 /Od Disable optimization /Og No effect /Oi- Disable use of builtin functions /Oi Enable use of builtin functions /Os Optimize for size (like clang -Os) /Ot Optimize for speed (like clang -O3) /Ox Deprecated (same as /Og /Oi /Ot /Oy /Ob2); use /O2 instead /Oy- Disable frame pointer omission (x86 only, default) /Oy Enable frame pointer omission (x86 only) /O<flags> Set multiple /O flags at once; e.g. '/O2y-' for '/O2 /Oy-' /o <file or directory> Set output file or directory (ends in / or \\) /P Preprocess to file /Qvec- Disable the loop vectorization passes /Qvec Enable the loop vectorization passes /showFilenames- Don't print the name of each compiled file (default) /showFilenames Print the name of each compiled file /showIncludes Print info about included files to stderr /source-charset:<value> Source encoding, supports only UTF-8 /std:<value> Language standard to compile for /TC Treat all source files as C /Tc <filename> Specify a C source file /TP Treat all source files as C++ /Tp <filename> Specify a C++ source file /utf-8 Set source and runtime encoding to UTF-8 (default) /U <macro> Undefine macro /vd<value> Control vtordisp placement /vmb Use a best-case representation method for member pointers /vmg Use a most-general representation for member pointers /vmm Set the default most-general representation to multiple inheritance /vms Set the default most-general representation to single inheritance /vmv Set the default most-general representation to virtual inheritance /volatile:iso Volatile loads and stores have standard semantics /volatile:ms Volatile loads and stores have acquire and release semantics /W0 Disable all warnings /W1 Enable -Wall /W2 Enable -Wall /W3 Enable -Wall /W4 Enable -Wall and -Wextra /Wall Enable -Weverything /WX- Do not treat warnings as errors /WX Treat warnings as errors /w Disable all warnings /X Don't add %INCLUDE% to the include search path /Y- Disable precompiled headers, overrides /Yc and /Yu /Yc<filename> Generate a pch file for all code up to and including <filename> /Yu<filename> Load a pch file and use it instead of all code up to and including <filename> /Z7 Enable CodeView debug information in object files /Zc:char8_t Enable C++20 char8_t type /Zc:char8_t- Disable C++20 char8_t type /Zc:dllexportInlines- Don't dllexport/dllimport inline member functions of dllexport/import classes /Zc:dllexportInlines dllexport/dllimport inline member functions of dllexport/import classes (default) /Zc:sizedDealloc- Disable C++14 sized global deallocation functions /Zc:sizedDealloc Enable C++14 sized global deallocation functions /Zc:strictStrings Treat string literals as const /Zc:threadSafeInit- Disable thread-safe initialization of static variables /Zc:threadSafeInit Enable thread-safe initialization of static variables /Zc:trigraphs- Disable trigraphs (default) /Zc:trigraphs Enable trigraphs /Zc:twoPhase- Disable two-phase name lookup in templates /Zc:twoPhase Enable two-phase name lookup in templates /Zi Alias for /Z7. Does not produce PDBs. /Zl Don't mention any default libraries in the object file /Zp Set the default maximum struct packing alignment to 1 /Zp<value> Specify the default maximum struct packing alignment /Zs Run the preprocessor, parser and semantic analysis stages OPTIONS: -### Print (but do not run) the commands to run for this compilation --analyze Run the static analyzer -faddrsig Emit an address-significance table -fansi-escape-codes Use ANSI escape codes for diagnostics -fblocks Enable the 'blocks' language feature -fcf-protection=<value> Instrument control-flow architecture protection. Options: return, branch, full, none. -fcf-protection Enable cf-protection in 'full' mode -fcolor-diagnostics Use colors in diagnostics -fcomplete-member-pointers Require member pointer base types to be complete if they would be significant under the Microsoft ABI -fcoverage-mapping Generate coverage mapping to enable code coverage analysis -fcrash-diagnostics-dir=<dir> Put crash-report files in <dir> -fdebug-macro Emit macro debug information -fdelayed-template-parsing Parse templated function definitions at the end of the translation unit -fdiagnostics-absolute-paths Print absolute paths in diagnostics -fdiagnostics-parseable-fixits Print fix-its in machine parseable form -flto=<value> Set LTO mode to either 'full' or 'thin' -flto Enable LTO in 'full' mode -fmerge-all-constants Allow merging of constants -fmodule-file=<module_name>=<module-file> Use the specified module file that provides the module <module_name> -fmodule-header=<header> Build <header> as a C++20 header unit -fmodule-output=<path> Save intermediate module file results when compiling a standard C++ module unit. -fms-compatibility-version=<value> Dot-separated value representing the Microsoft compiler version number to report in _MSC_VER (0 = don't define it; default is same value as installed cl.exe, or 1933) -fms-compatibility Enable full Microsoft Visual C++ compatibility -fms-extensions Accept some non-standard constructs supported by the Microsoft compiler -fmsc-version=<value> Microsoft compiler version number to report in _MSC_VER (0 = don't define it; default is same value as installed cl.exe, or 1933) -fno-addrsig Don't emit an address-significance table -fno-builtin-<value> Disable implicit builtin knowledge of a specific function -fno-builtin Disable implicit builtin knowledge of functions -fno-complete-member-pointers Do not require member pointer base types to be complete if they would be significant under the Microsoft ABI -fno-coverage-mapping Disable code coverage analysis -fno-crash-diagnostics Disable auto-generation of preprocessed source files and a script for reproduction during a clang crash -fno-debug-macro Do not emit macro debug information -fno-delayed-template-parsing Disable delayed template parsing -fno-sanitize-address-poison-custom-array-cookie Disable poisoning array cookies when using custom operator new[] in AddressSanitizer -fno-sanitize-address-use-after-scope Disable use-after-scope detection in AddressSanitizer -fno-sanitize-address-use-odr-indicator Disable ODR indicator globals -fno-sanitize-ignorelist Don't use ignorelist file for sanitizers -fno-sanitize-cfi-cross-dso Disable control flow integrity (CFI) checks for cross-DSO calls. -fno-sanitize-coverage=<value> Disable specified features of coverage instrumentation for Sanitizers -fno-sanitize-memory-track-origins Disable origins tracking in MemorySanitizer -fno-sanitize-memory-use-after-dtor Disable use-after-destroy detection in MemorySanitizer -fno-sanitize-recover=<value> Disable recovery for specified sanitizers -fno-sanitize-stats Disable sanitizer statistics gathering. -fno-sanitize-thread-atomics Disable atomic operations instrumentation in ThreadSanitizer -fno-sanitize-thread-func-entry-exit Disable function entry/exit instrumentation in ThreadSanitizer -fno-sanitize-thread-memory-access Disable memory access instrumentation in ThreadSanitizer -fno-sanitize-trap=<value> Disable trapping for specified sanitizers -fno-standalone-debug Limit debug information produced to reduce size of debug binary -fno-strict-aliasing Disable optimizations based on strict aliasing rules (default) -fobjc-runtime=<value> Specify the target Objective-C runtime kind and version -fprofile-exclude-files=<value> Instrument only functions from files where names don't match all the regexes separated by a semi-colon -fprofile-filter-files=<value> Instrument only functions from files where names match any regex separated by a semi-colon -fprofile-generate=<dirname> Generate instrumented code to collect execution counts into a raw profile file in the directory specified by the argument. The filename uses default_%m.profraw pattern (overridden by LLVM_PROFILE_FILE env var) -fprofile-generate Generate instrumented code to collect execution counts into default_%m.profraw file (overridden by '=' form of option or LLVM_PROFILE_FILE env var) -fprofile-instr-generate=<file_name_pattern> Generate instrumented code to collect execution counts into the file whose name pattern is specified as the argument (overridden by LLVM_PROFILE_FILE env var) -fprofile-instr-generate Generate instrumented code to collect execution counts into default.profraw file (overridden by '=' form of option or LLVM_PROFILE_FILE env var) -fprofile-instr-use=<value> Use instrumentation data for coverage testing or profile-guided optimization -fprofile-use=<value> Use instrumentation data for profile-guided optimization -fprofile-remapping-file=<file> Use the remappings described in <file> to match the profile data against names in the program -fprofile-list=<file> Filename defining the list of functions/files to instrument -fsanitize-address-field-padding=<value> Level of field padding for AddressSanitizer -fsanitize-address-globals-dead-stripping Enable linker dead stripping of globals in AddressSanitizer -fsanitize-address-poison-custom-array-cookie Enable poisoning array cookies when using custom operator new[] in AddressSanitizer -fsanitize-address-use-after-return=<mode> Select the mode of detecting stack use-after-return in AddressSanitizer: never | runtime (default) | always -fsanitize-address-use-after-scope Enable use-after-scope detection in AddressSanitizer -fsanitize-address-use-odr-indicator Enable ODR indicator globals to avoid false ODR violation reports in partially sanitized programs at the cost of an increase in binary size -fsanitize-ignorelist=<value> Path to ignorelist file for sanitizers -fsanitize-cfi-cross-dso Enable control flow integrity (CFI) checks for cross-DSO calls. -fsanitize-cfi-icall-generalize-pointers Generalize pointers in CFI indirect call type signature checks -fsanitize-coverage=<value> Specify the type of coverage instrumentation for Sanitizers -fsanitize-hwaddress-abi=<value> Select the HWAddressSanitizer ABI to target (interceptor or platform, default interceptor) -fsanitize-memory-track-origins=<value> Enable origins tracking in MemorySanitizer -fsanitize-memory-track-origins Enable origins tracking in MemorySanitizer -fsanitize-memory-use-after-dtor Enable use-after-destroy detection in MemorySanitizer -fsanitize-recover=<value> Enable recovery for specified sanitizers -fsanitize-stats Enable sanitizer statistics gathering. -fsanitize-thread-atomics Enable atomic operations instrumentation in ThreadSanitizer (default) -fsanitize-thread-func-entry-exit Enable function entry/exit instrumentation in ThreadSanitizer (default) -fsanitize-thread-memory-access Enable memory access instrumentation in ThreadSanitizer (default) -fsanitize-trap=<value> Enable trapping for specified sanitizers -fsanitize-undefined-strip-path-components=<number> Strip (or keep only, if negative) a given number of path components when emitting check metadata. -fsanitize=<check> Turn on runtime checks for various forms of undefined or suspicious behavior. See user manual for available checks -fsplit-lto-unit Enables splitting of the LTO unit. -fstandalone-debug Emit full debug info for all types used by the program -fstrict-aliasing Enable optimizations based on strict aliasing rules -fsyntax-only Run the preprocessor, parser and semantic analysis stages -fwhole-program-vtables Enables whole-program vtable optimization. Requires -flto -gcodeview-ghash Emit type record hashes in a .debug$H section -gcodeview Generate CodeView debug information -gline-directives-only Emit debug line info directives only -gline-tables-only Emit debug line number tables only -miamcu Use Intel MCU ABI -mllvm <value> Additional arguments to forward to LLVM's option processing -nobuiltininc Disable builtin #include directories -Qunused-arguments Don't emit warning for unused driver arguments -R<remark> Enable the specified remark --target=<value> Generate code for the given target --version Print version information -v Show commands to run and use verbose output -W<warning> Enable the specified warning -Xclang <arg> Pass <arg> to the clang compiler When clang-cl is run with a set of options, it will gather all of the arguments and process them as if they were passed to the clang driver. This mechanism allows you to pass flags that are not exposed in the clang-cl options or flags that have a different meaning when passed to the clang driver. Regardless of where they appear in the command line, the arguments are treated as if they were passed at the end of the clang-cl command line. This causes the class-level and attributes to not apply to inline member functions, as they otherwise would. For example, in the code below would normally be defined and exported by the DLL, but when using the flag it is not: This has the benefit that the compiler doesn’t need to emit a definition of in every translation unit where the declaration is included, as it would otherwise do to ensure there’s a definition in the DLL even if it’s not used there. If the declaration occurs in a header file that’s widely used, this can save significant compilation time and output size. It also reduces the number of functions exported by the DLL similarly to what does for shared objects on ELF and Mach-O. Since the function declaration comes with an inline definition, users of the library can use that definition directly instead of importing it from the DLL. Note that the Microsoft Visual C++ compiler does not support this option, and if code in a DLL is compiled with , the code using the DLL must be compiled in the same way so that it doesn’t attempt to dllimport the inline member functions. The reverse scenario should generally work though: a DLL compiled without this flag (such as a system library compiled with Visual C++) can be referenced from code compiled using the flag, meaning that the referencing code will use the inline definitions instead of importing them from the DLL. Also note that like when using , the address of will be different inside and outside the DLL, breaking the C/C++ standard requirement that functions have a unique address. The flag does not apply to explicit class template instantiation definitions or declarations, as those are typically used to explicitly provide a single definition in a DLL, (dllexported instantiation definition) or to signal that the definition is available elsewhere (dllimport instantiation declaration). It also doesn’t apply to inline members with static local variables, to ensure that the same instance of the variable is used inside and outside the DLL. Using this flag can cause problems when inline functions that would otherwise be dllexported refer to internal symbols of a DLL. For example: Normally, references to would use the definition in the DLL from which it was exported, and which presumably also has the definition of . However, when using , the inline definition of is used directly, resulting in a link error since is not available. Even worse, if there is an inline definition of containing a static local variable, we will now refer to a different instance of that variable than in the DLL: This could lead to very subtle bugs. Using can lead to the same issue. To avoid it in this case, make or non-inline, or mark them explicitly. In order to use these features, the user must link the right runtime libraries into their program. These libraries are distributed alongside Clang in the library resource directory. Clang searches for the resource directory by searching relative to the Clang executable. For example, if LLVM is installed in , then the profile runtime library will be located at the path . For UBSan, PGO, and coverage, Clang will emit object files that auto-link the appropriate runtime library, but the user generally needs to help the linker (whether it is or MSVC ) find the library resource directory. Using the example installation above, this would mean passing to the linker. If the user links the program with the or drivers, the driver will pass this flag for them. The auto-linking can be disabled with -fno-rtlib-defaultlib. If that flag is used, pass the complete flag to required libraries as described for ASan below. If the linker cannot find the appropriate library, it will emit an error like this: $ clang-cl -c -fsanitize=undefined t.cpp $ lld-link t.obj -dll lld-link: error: could not open 'clang_rt.ubsan_standalone-x86_64.lib': no such file or directory lld-link: error: could not open 'clang_rt.ubsan_standalone_cxx-x86_64.lib': no such file or directory $ link t.obj -dll -nologo LINK : fatal error LNK1104: cannot open file 'clang_rt.ubsan_standalone-x86_64.lib' To fix the error, add the appropriate flag to the link line. For ASan, as of this writing, the user is also responsible for linking against the correct ASan libraries. If the user is using the dynamic CRT ( ), then they should add to the link line as a regular input. For other architectures, replace x86_64 with the appropriate name here and below. If the user is using the static CRT ( ), then different runtimes are used to produce DLLs and EXEs. To link a DLL, pass . To link an EXE, pass . clang-cl uses a set of different approaches to locate the right system libraries to link against when building code. The Windows environment uses libraries from three distinct sources: The Windows SDK provides the import libraries and headers required to build programs against the Windows system packages. Underlying the Windows SDK is the UCRT, the universal C runtime. This difference is best illustrated by the various headers that one would find in the different categories. The WinSDK would contain headers such as which is part of the Windows API surface, providing the Windows socketing interfaces for networking. UCRT provides the C library headers, including e.g. . Finally, the Visual C++ tools provides the underlying Visual C++ Runtime headers such as or . There are various controls that allow the user control over where clang-cl will locate these headers. The default behaviour for the Windows SDK and UCRT is as follows:\n• Anything the user specifies is always given precedence. The following extensions are part of the clang-cl toolset: The is used as an equivalent to on Unix environments. It allows the control of an alternate location to be treated as a system root. When specified, it will be used as the root where the is located. If is not specified, the argument is consulted as a location to identify where the Windows SDK is located. Contrary to , is expected to be the complete path rather than a root to locate . The flag allows the user to specify a version identifier for the SDK to prefer. When this is specified, no additional validation is performed and this version is preferred. If the version is not specified, the highest detected version number will be used.\n• TODO: This is not yet implemented. This will consult the environment variables:\n• If no arguments are used to indicate where the SDK is present, and the compiler is running on Windows, the registry is consulted to locate the installation. The Visual C++ Toolset has a slightly more elaborate mechanism for detection.\n• The is used as an equivalent to on Unix environments. It allows the control of an alternate location to be treated as a system root. When specified, it will be used as the root where the directory is located. If is not specified, the argument is consulted as a location to identify where the Visual C++ Tools are located. If is specified, that version is preferred, otherwise, the highest version detected is used.\n• \n• This specifies a user identified environment variable which is treated as a path delimiter ( ) separated list of paths to map into arguments which are treated as .\n• The path delimiter ( ) separated list of paths will be mapped to arguments which are treated as .\n• The linker or will honour the environment variable which is a path delimiter ( ) set of paths to consult for the import libraries to use when linking the final target. The following environment variables will be consulted and used to form paths to validate and load content from as appropriate:\n• Assuming that the toolchain is built with defined and is running on Windows, the Visual Studio COM interface will be used to locate the installation of the MSVC toolset.\n• The registry information is used to help locate the installation as a final fallback. This is only possible for pre-VS2017 installations and is considered deprecated. Strict aliasing (TBAA) is always off by default in clang-cl whereas in clang, strict aliasing is turned on by default for all optimization levels. For more details, see Strict aliasing."
    }
]