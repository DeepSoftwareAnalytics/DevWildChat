[
    {
        "link": "https://projecthub.arduino.cc/arduino_uno_guy/i2c-liquid-crystal-displays-5eb615",
        "document": "All you need to know about I2C LCD screens on an Arduino Uno."
    },
    {
        "link": "https://arduino.cc/en/Tutorial/HelloWorld",
        "document": ""
    },
    {
        "link": "https://docs.oyoclass.com/unoeditor/Libraries/liquid_crystal",
        "document": "The LiquidCrystal_I2C library allows you to program an Arduino to print messages to an LCD screen using an I2C backpack. I2C is a communication protocol that allows you to communicate with multiple devices using only a few pins.\n\nTo include the library into the sketch you're working on, include the two libraries shown below at the top of your sketch.\n\nTo create an LCD object, follow the line of code below.\n\nThe first argument is the address of your LCD screen. This can be found by using the scanner script at the bottom of this page.\n• x: the number of horizontal characters of the lcd screen\n• y: the number of vertical characters of the lcd screen\n\nInitialize the LCD screen with the height and width of the displays\n\nClear all characters from the LCD screen\n\nPrints characters to the LCD screen starting at the current location of the cursor. This method does not skip to the next line when it reaches the end of the line.\n\nPlaces the cursor at the (0,0) point (upper left-hand corner)"
    },
    {
        "link": "https://docs.arduino.cc/libraries/liquidcrystal-i2c",
        "document": ""
    },
    {
        "link": "https://docs.arduino.cc/libraries/liquidcrystal",
        "document": ""
    },
    {
        "link": "https://howtomechatronics.com/tutorials/arduino/arduino-dc-motor-control-tutorial-l298n-pwm-h-bridge",
        "document": "In this Arduino Tutorial we will learn how to control DC motors using Arduino. We well take a look at some basic techniques for controlling DC motors and make two example through which we will learn how to control DC motors using the L298N motor driver and the Arduino board.\n\nYou can watch the following video or read the written tutorial below.\n\nWe can control the speed of the DC motor by simply controlling the input voltage to the motor and the most common method of doing that is by using PWM signal.\n\nPWM, or pulse width modulation is a technique which allows us to adjust the average value of the voltage that’s going to the electronic device by turning on and off the power at a fast rate. The average voltage depends on the duty cycle, or the amount of time the signal is ON versus the amount of time the signal is OFF in a single period of time.\n\nSo depending on the size of the motor, we can simply connect an Arduino PWM output to the base of transistor or the gate of a MOSFET and control the speed of the motor by controlling the PWM output. The low power Arduino PWM signal switches on and off the gate at the MOSFET through which the high power motor is driven.\n\nOn the other hand, for controlling the rotation direction, we just need to inverse the direction of the current flow through the motor, and the most common method of doing that is by using an H-Bridge. An H-Bridge circuit contains four switching elements, transistors or MOSFETs, with the motor at the center forming an H-like configuration. By activating two particular switches at the same time we can change the direction of the current flow, thus change the rotation direction of the motor.\n\nSo if we combine these two methods, the PWM and the H-Bridge, we can have a complete control over the DC motor. There are many DC motor drivers that have these features and the L298N is one of them.\n\nThe L298N is a dual H-Bridge motor driver which allows speed and direction control of two DC motors at the same time. The module can drive DC motors that have voltages between 5 and 35V, with a peak current up to 2A.\n\nLet’s take a closer look at the pinout of L298N module and explain how it works. The module has two screw terminal blocks for the motor A and B, and another screw terminal block for the Ground pin, the VCC for motor and a 5V pin which can either be an input or output.\n\nThis depends on the voltage used at the motors VCC. The module have an onboard 5V regulator which is either enabled or disabled using a jumper. If the motor supply voltage is up to 12V we can enable the 5V regulator and the 5V pin can be used as output, for example for powering our Arduino board. But if the motor voltage is greater than 12V we must disconnect the jumper because those voltages will cause damage to the onboard 5V regulator. In this case the 5V pin will be used as input as we need connect it to a 5V power supply in order the IC to work properly.\n\nWe can note here that this IC makes a voltage drop of about 2V. So for example, if we use a 12V power supply, the voltage at motors terminals will be about 10V, which means that we won’t be able to get the maximum speed out of our 12V DC motor.\n\nNext are the logic control inputs. The Enable A and Enable B pins are used for enabling and controlling the speed of the motor. If a jumper is present on this pin, the motor will be enabled and work at maximum speed, and if we remove the jumper we can connect a PWM input to this pin and in that way control the speed of the motor. If we connect this pin to a Ground the motor will be disabled.\n\nNext, the Input 1 and Input 2 pins are used for controlling the rotation direction of the motor A, and the inputs 3 and 4 for the motor B. Using these pins we actually control the switches of the H-Bridge inside the L298N IC. If input 1 is LOW and input 2 is HIGH the motor will move forward, and vice versa, if input 1 is HIGH and input 2 is LOW the motor will move backward. In case both inputs are same, either LOW or HIGH the motor will stop. The same applies for the inputs 3 and 4 and the motor B.\n\nNow let’s make some practical applications. In the first example we will control the speed of the motor using a potentiometer and change the rotation direction using a push button. Here’s the circuit schematics.\n\nSo we need an L298N motor driver, a DC motor, a potentiometer, a push button and an Arduino board.\n\nYou can get the components needed for this Arduino Tutorial from the links below:\n\nDisclosure: These are affiliate links. As an Amazon Associate I earn from qualifying purchases.\n\nDescription: So first we need to define the pins and some variables needed for the program. In the setup section we need to set the pin modes and the initial rotation direction of the motor. In the loop section we start by reading the potentiometer value and then map the value that we get from it which is from 0 to 1023, to a value from 0 to 255 for the PWM signal, or that’s 0 to 100% duty cycle of the PWM signal. Then using the analogWrite() function we send the PWM signal to the Enable pin of the L298N board, which actually drives the motor.\n\nNext, we check whether we have pressed the button, and if that’s true, we will change the rotation direction of the motor by setting the Input 1 and Input 2 states inversely. The push button will work as toggle button and each time we press it, it will change the rotation direction of the motor.\n\nSo once we have learned this, now we can build our own Arduino robot car. Here’s the circuit schematic:\n\nAll we need is 2 DC Motors, the L298N motor driver, an Arduino board and a joystick for the control. As for the power supply, I chose to use three 3.7V Li-ion batteries, providing total of 11V. I made the chassis out of 3 mm tick plywood, attached the motors to it using metal brackets, attached wheels to the motors and in front attached a swivel wheel.\n\nNow let’s take a look at the Arduino code and see how it works. (Down below you can find the complete code)\n\nAfter defining the pins, in the loop section, we start with reading the joystick X and Y axis values. The joystick is actually made of two potentiometers which are connected to the analog inputs of the Arduino and they have values from 0 to 1023. When the joystick stays in its center position the value of both potentiometers, or axes is around 512.\n\nWe will add a little tolerance and consider the values from 470 to 550 as center. So if we move the Y axis of joystick backward and the value goes below 470 we will set the two motors rotation direction to backward using the four input pins. Then, we will convert the declining values from 470 to 0 into increasing PWM values from 0 to 255 which is actually the speed of the motor.\n\nSimilar, if we move the Y axis of the joystick forward and the value goes above 550 we will set the motors to move forward and convert the readings from 550 to 1023 into PWM values from 0 to 255. If the joystick stays in its center the motors speed will be zero.\n\nNext, let’s see how we use the X axis for the left and right control of the car.\n\nSo again, first we need to convert the X axis readings into speed values from 0 to 255. For moving left, we use this value to decrease the left motor speed and increase the right motor speed. Here, because of the arithmetic functions we use two additional “if” statements to confine the range of the motor speed from 0 to 255.\n\nThe same method is used for moving the car to the right.\n\nRelated: How To Make a PWM DC Motor Speed Controller using the 555 Timer IC\n\nDepending on the applied voltage and the motor itself, at lower speeds the motor is not able to start moving and it produces a buzzing sound. In my case, the motors were not able to move if the value of the PWM signal was below 70. Therefore using this two if statements I actually confined to speed range from 70 to 255. At the end we just send the final motor speeds or PWM signal to the enable pins of the L298N driver.\n\nHere’s the complete code of the Arduino robot car example:\n\nSo that would be all for this tutorial, and in my next video we will upgrade this Arduino robot car, by adding a Bluetooth and Radio devices for enabling smartphone and wireless control.\n\nFeel free to ask any question in the comments section below and don’t forget to check my collection of Arduino Projects."
    },
    {
        "link": "https://forum.arduino.cc/t/pwm-with-arduino-and-l298n/1150869",
        "document": "Learn about L298N Motor Driver module along with PWM, H-bridge Working, Pinout, Wiring, Arduino Code for controlling speed & direction of DC motor."
    },
    {
        "link": "https://forum.arduino.cc/t/controlling-2-dc-motors-via-pwm-by-using-l298n-h-bridge-driver/1005540",
        "document": "Hi. I have followed this tutorial in order to control 2 DC motors. The only difference is that I have Arduino Mega 2560. The connections are\n\n enA = D9\n\n IN1 = D5\n\n IN2 = D6\n\n IN3 = D7\n\n IN4 = D8\n\n enB = D10\n\n VSS = 5V from Arduino\n\n GND = GND from Arduino\n\n MotorA = First motor\n\n MotorB = Second motor The problem is that there is no voltage so motors are not turning. At the same config without changing connections, when I changed enA = 11 (connection is 10), the motors are working separately. I have not been able to find explanation of the behavior. Thank you in advance. // Motor A connections const int enA = 9; // when it is 11 at the same config it is working separately const int in1 = 5; const int in2 = 6; // Motor B connections const int enB = 10; const int in3 = 7; const int in4 = 8; // Set the speed (0 = off and 255 = max speed) const int motorSpeed = 255; void setup() { Serial.begin(9600); // Motor control pins are outputs pinMode(enA, OUTPUT); pinMode(enB, OUTPUT); pinMode(in1, OUTPUT); pinMode(in2, OUTPUT); pinMode(in3, OUTPUT); pinMode(in4, OUTPUT); // Turn off motors - Initial state digitalWrite(in1, LOW); digitalWrite(in2, LOW); digitalWrite(in3, LOW); digitalWrite(in4, LOW); // Set the motor speed analogWrite(enA, motorSpeed); analogWrite(enB, motorSpeed); } void loop() { Serial.println(\"Main loop\"); // Go forwards go_forward(); delay(3000); // Go backwards go_backwards(); delay(3000); // Go right go_right(); delay(3000); // Go left go_left(); delay(3000); // Stop stop_all(); delay(3000); } /* * Forwards, backwards, right, left, stop. */ void go_forward() { Serial.println(\"Forward\"); digitalWrite(in1, HIGH); digitalWrite(in2, LOW); digitalWrite(in3, HIGH); digitalWrite(in4, LOW); } void go_backwards() { Serial.println(\"Backward\"); digitalWrite(in1, LOW); digitalWrite(in2, HIGH); digitalWrite(in3, LOW); digitalWrite(in4, HIGH); } void go_right() { Serial.println(\"Right\"); digitalWrite(in1, HIGH); digitalWrite(in2, LOW); digitalWrite(in3, LOW); digitalWrite(in4, HIGH); } void go_left() { Serial.println(\"Left\"); digitalWrite(in1, LOW); digitalWrite(in2, HIGH); digitalWrite(in3, HIGH); digitalWrite(in4, LOW); } void stop_all() { Serial.println(\"Stop All\"); digitalWrite(in1, LOW); digitalWrite(in2, LOW); digitalWrite(in3, LOW); digitalWrite(in4, LOW); }\n\nHi, @oguzkah\n\n Welcome to the forum. Thanks for using code tags when you posted your code. As well as a hand drawn circuit can you please post some images of your project so we can see your component layout? What are you using for the motor power supply?\n\n Have you got the jumpers set correctly?\n\nHi,\n\n Can you please post a proper circuit diagram?\n\n An image of a hand drawn circuit will be fine, unfortunately the Fritzy picture is just a crisscross of coloured wires.\n\n Please include power supply, component names and pin labels. An image of your project would be good as well, so we can see your component layout.\n\n... then the L298 datasheet explains why there's no volts at the motor: The L298 is a really cr@p choice for low voltage motors. If your motors were say 30V odd, then the losses are relatively less, but if you start with only 5V....\n\nI recently had exclty the same problem with my H bridge but trying everything the only solution i found was if you conect the pins 9 and 11 it works\n\n \n\n the solder in this one it's not great but it's just for reference\n\n First try to link them with a screwdriver or something similar , if it works solder it if it doesen't i don't know what's happening. the solder in this one it's not great but it's just for referenceFirst try to link them with a screwdriver or something similar , if it works solder it if it doesen't i don't know what's happening."
    },
    {
        "link": "https://lastminuteengineers.com/l298n-dc-stepper-driver-arduino-tutorial",
        "document": "While you’ll eventually need to learn to control DC motors in order to build your own robot, you’ll probably need something a little easier to get started – which is where the L298N motor driver comes in. It can control the speed and spinning direction of two DC motors.\n\nIn addition, it can control a bipolar stepper motor, such as the NEMA 17. If you want to learn more about it, check out this tutorial.\n\nWe can only have full control over a DC motor if we can control its speed and spinning direction. This is possible by combining these two techniques.\n\nLet’s learn more about these techniques.\n\nThe speed of a DC motor can be controlled by changing its input voltage. A widely used technique to accomplish this is Pulse Width Modulation (PWM).\n\nPWM is a technique in which the average value of the input voltage is adjusted by sending a series of ON-OFF pulses. This average voltage is proportional to the width of the pulses, which is referred to as the Duty Cycle.\n\nThe higher the duty cycle, the higher the average voltage applied to the DC motor, resulting in an increase in motor speed. The shorter the duty cycle, the lower the average voltage applied to the DC motor, resulting in a decrease in motor speed.\n\nThe image below shows PWM technique with various duty cycles and average voltages.\n\nThe spinning direction of a DC motor can be controlled by changing the polarity of its input voltage. A widely used technique to accomplish this is to use an H-bridge.\n\nAn H-bridge circuit is made up of four switches arranged in a H shape, with the motor in the center.\n\nClosing two specific switches at the same time reverses the polarity of the voltage applied to the motor. This causes a change in the spinning direction of the motor.\n\nThe following animation shows the working of the H-bridge circuit.\n\nAt the center of the module is a big, black chip with a chunky heat sink – the L298N.\n\nThe L298N chip contains two standard H-bridges capable of driving a pair of DC motors, making it ideal for building a two-wheeled robotic platform.\n\nThe L298N motor driver has a supply range of 5V to 35V and is capable of 2A continuous current per channel, so it works very well with most of our DC motors.\n\nHere are the specifications:\n\nFor more details, please refer below datasheet.\n\nThe L298N module has 11 pins that allow it to communicate with the outside world. The pinout is as follows:\n\nLet’s get acquainted with each pin one by one.\n\nThe L298N motor driver has two input power pins: VS and VSS.\n\nVS pin powers the IC’s internal H-Bridge, which drives the motors. This pin accepts input voltages ranging from 5 to 12V.\n\nVSS is used to power the logic circuitry within the L298N IC, and can range between 5V and 7V.\n\nThe output channels of the L298N motor driver, OUT1 and OUT2 for motor A and OUT3 and OUT4 for motor B, are broken out to the edge of the module with two 3.5mm-pitch screw terminals. You can connect two 5-12V DC motors to these terminals.\n\nEach channel on the module can supply up to 2A to the DC motor. The amount of current supplied to the motor, however, depends on the capacity of the motor power supply.\n\nThe direction control pins allow you to control whether the motor rotates forward or backward. These pins actually control the switches of the H-Bridge circuit within the L298N chip.\n\nThe module has two direction control pins. The IN1 and IN2 pins control the spinning direction of motor A; While IN3 and IN4 control the spinning direction of motor B.\n\nThe spinning direction of the motor can be controlled by applying logic HIGH (5V) or logic LOW (Ground) to these inputs. The chart below shows various combinations and their outcomes.\n\nThe speed control pins ENA and ENB are used to turn on/off the motors and control their speed.\n\nPulling these pins HIGH will cause the motors to spin, while pulling them LOW will stop them. However, with Pulse Width Modulation (PWM), the speed of the motors can be controlled.\n\nThe module usually comes with a jumper on these pins. When this jumper is in place, the motor spins at full speed. If you want to control the speed of the motors programmatically, remove the jumpers and connect them to the Arduino’s PWM-enabled pins.\n\nThe module includes a 78M05 5V regulator that can be enabled or disabled via a jumper.\n\nWhen this jumper is in place, the 5V regulator is enabled, and the logic power supply (VSS) is derived from the motor power supply (VS). In this case, the 5V input terminal acts as the output pin, delivering 5V 0.5A. You can use it to power an Arduino or other circuitry that needs 5V power.\n\nWhen the jumper is removed, the 5V regulator is disabled, and we have to supply 5V separately through the VSS pin.\n\nThe L298N has a voltage drop of approximately 2V. This is due to the fact that internal switching transistors have a voltage drop of approximately 1V when forward biased, and because an H-Bridge requires the current to pass through two transistors, the total voltage drop is 2V.\n\nSo, if you connect 12V to the motor power supply terminal, the motors will receive approximately 10V. This means that a 12V DC motor will never spin at full speed.\n\nIn order to get the motor to run at its maximum speed, the motor power supply should have a voltage that is slightly higher (+2V) than the actual voltage requirement of the motor.\n\nTaking into account a voltage drop of 2V, if you are using 5V motors, you will need to provide 7V at the motor power supply terminal. If you have 12V motors then your motor supply voltage should be 14V.\n\nWiring an L298N Motor Driver Module to an Arduino\n\nNow that we know everything about the module, we can start hooking it up to our Arduino!\n\nLet’s begin by connecting the motor power supply. In our experiment, we are using DC gearbox motors, also called “TT” motors, which are often found in two-wheel-drive robots. They are rated for 3 to 12V. We will therefore connect an external 12V power source to the VS terminal. Because L298N has a voltage drop of about 2V, the motors will receive 10V and spin at a slightly lower RPM. But that’s okay.\n\nNext, we need to supply 5V to the logic circuitry of the L298N. We’ll use the on-board 5V regulator to draw 5V from the motor power supply, so keep the 5V-EN jumper in place.\n\nNow connect the L298N module’s Input and Enable pins (ENA, IN1, IN2, IN3, IN4 and ENB) to the six Arduino digital output pins (9, 8, 7, 5, 4 and 3). Note that both Arduino output pins 9 and 3 are PWM-enabled.\n\nFinally, wire one motor to terminal A (OUT1 and OUT2) and the other to terminal B (OUT3 and OUT4). You can swap out your motor’s connections. There is technically no right or wrong way.\n\nThe sketch below will show you how to control the speed and spinning direction of a DC motor using the L298N Motor Driver and can serve as the basis for more practical experiments and projects.\n\nThe sketch moves the motor in one direction for one revolution, then in the opposite direction. There is also some acceleration and deceleration involved.\n\nThe Arduino code is fairly simple. It does not require any libraries to work. The sketch starts by declaring the Arduino pins that are connected to the L298N’s control pins.\n\nIn the setup section of the code, all of the motor control pins, including the direction and speed control pins, are configured as digital OUTPUT. And the direction control pins are pulled LOW to initially disable both motors.\n\nIn the loop section of the code, we call two user-defined functions with a one-second delay.\n• None – This function causes both motors to spin at full speed for two seconds. It then reverses the spinning direction of the motors and spins for two seconds. Finally, it stops the motors. () { // For PWM maximum possible values are 0 to 255 (enA, ); (enB, ); (in1, HIGH); (in2, LOW); (in3, HIGH); (in4, LOW); ( ); (in1, LOW); (in2, HIGH); (in3, LOW); (in4, HIGH); ( ); (in1, LOW); (in2, LOW); (in3, LOW); (in4, LOW); }\n• None – This function uses the analogWrite() function to generate a PWM signal that accelerates both motors from zero to maximum speed before decelerating them back to zero. Finally, it stops the motors. () { (in1, LOW); (in2, HIGH); (in3, LOW); (in4, HIGH); // Accelerate from zero to maximum speed ( i = ; i < ; i++) { (enA, i); (enB, i); ( ); } // Decelerate from maximum speed to zero ( i = ; i >= ; --i) { (enA, i); (enB, i); ( ); } (in1, LOW); (in2, LOW); (in3, LOW); (in4, LOW); }"
    },
    {
        "link": "https://instructables.com/Arduino-DC-Motor-Control-and-PWM-Signal-With-L298N",
        "document": "About: Maker 101; Beginner and intermediate level Maker projects! You can find projects such as \"How to\" and \"DIY\" on programmable boards such as Arduino, ESP8266, ESP32 and Raspberry Pi on this channel. The projects…\n\nMore by the author:\n\nIn this tutorial we will learn how to use the L298N H-Bridge Motor Controller.\n\nWe will control the dual DC motor with using the PWM Signals via L298N."
    },
    {
        "link": "https://docs.arduino.cc/language-reference/en/functions/advanced-io/pulseIn",
        "document": ""
    },
    {
        "link": "https://forum.arduino.cc/t/how-can-i-read-pulse-or-4-20-ma-output-from-arduino/266896",
        "document": "The Arduino programming language Reference, organized into Functions, Variable and Constant, and Structure keywords."
    },
    {
        "link": "https://forum.arduino.cc/t/reading-flowmeter-pulse-output/555295",
        "document": ""
    },
    {
        "link": "https://bc-robotics.com/tutorials/using-a-flow-sensor-with-arduino?srsltid=AfmBOoo0edfDjd2mBcLp5X6eBn2wg8nMk3mfz5bUW6s-k31aA0UVXDdK",
        "document": ""
    },
    {
        "link": "https://forum.arduino.cc/t/counting-pulses-with-a-flow-meter/246568",
        "document": "I am very new to Arduino, and have been given a project that, from what I see, requires years of experience. Basically I need to calculate how much water is flowing through a pipe. I am using a _______ Flow meter, that produces pulses from what I understand. I have done the wiring from an outlet to a converter, which drops the voltage down from 110 volts to 24 volts. I than wired the PulseOut wire to drop to 5 volts to be plugged into the arduino Leonardo that I am using. I guess my question is how can I write a program to \"count\" the pulses per sometime? I did a lot of reading on the forum the last couple of days and still cannot piece together a code that will allow me to count the pulses, which I can than convert to gallons per minute. I am assuming I will have to use some interrupts, or pulseIn functions, and use the PWM ports. I just do not understand how they piece together. And maybe I am having troubles connecting to the correct ports to read pulses. Do I use PWM ports or serial data ports or another? I am very confused. Here is a small code I pieced together, that I thought might work, but turned out it did not. /* * HardwareCounting sketch * * uses pin 5 on 168/328 */ const int hardwareCounterPin = 5; // input pin fixed to internal Timer const int ledPin = 13; const int samplePeriod = 5000; // the sample period in milliseconds unsigned int count; int calc; #include <LiquidCrystal.h> #include <Wire.h> // initialize the library with the numbers of the interface pins LiquidCrystal lcd(12, 11, 5, 4, 3, 2); void setup() { Serial.begin(9600); pinMode(ledPin,OUTPUT); // hardware counter setup (see ATmega data sheet for details) TCCR1A=0; // reset timer/counter control register A lcd.begin(16, 2); // Print a message to the LCD. } void loop() { digitalWrite(ledPin, LOW); delay(1000); digitalWrite(ledPin, HIGH); // start the counting bitSet(TCCR1B ,CS12); // Counter Clock source is external pin bitSet(TCCR1B ,CS11); // Clock on rising edge delay(samplePeriod); // stop the counting TCCR1B = 0; count = TCNT1; TCNT1 = 0; // reset the hardware counter if(count >= 0) calc= (count); Serial.print (calc, DEC); Serial.println(\" Pulse\\r\n\n\"); lcd.setCursor(0, 1); // print the number of seconds since reset: lcd.print(calc, DEC); lcd.println(\" Pulse\\r\n\n\"); } Thank you guys/girls for any help!\n\nI think you will be better off using an interrupt unless you know how long the pulse takes connect your sensor outputting 5V to pin 2 (Interrupt 0), so you will have to rejigger your LCD pins. Since you are not using it in the code, you should be OK . There are comments in the code for you to understand... Try something like this (not tested): #include <LiquidCrystal.h> #include <Wire.h> const int hardwareCounterPin = 2; // Interrupt 0 is pin2 const int ledPin = 13; const unsigned long samplePeriod = 5000UL; // the sample period in milliseconds unsigned long startTime; unsigned int pulseCount = 0; unsigned long startFlash; unsigned long flashTime = 250UL; boolean flashToggle = false; int lastPulseCount = 0; int calc; LiquidCrystal lcd(12, 11, 5, 4, 3, 2);// initialize the LCD library with the numbers of the interface pins void setup() { Serial.begin(9600); pinMode(ledPin,OUTPUT); lcd.begin(16, 2); // Print a message to the LCD...? attachInterrupt( 0, wasPulse, RISING); startTime = millis(); } void loop() { if (flashToggle) flashLED(); //ledPin will flash for 250ms each pulse. if (pulseCount > lastPulseCount) // if you detect a pulse, initiate a flash { startFlash = millis(); flashToggle = true; lastPulseCount = pulseCount; } if (millis() - startTime >= samplePeriod) // this will 'wait' for samplePeriod and then calculate the rate without using a delay { calculateGPM(); } } void calculateGPM() { int pulses = pulseCount; // start to ignore any more interrupts Serial.print(\"there were this many pulses: \"); // do the math to convert pulses to GPM Serial.println (pulses); // Print to your LCD here... startTime = millis(); pulseCount = 0; //reset the pulseCount variable and return to loop() function } void flashLED() { digitalWrite(ledPin, HIGH); // turn led on if (millis() - startFlash >= flashTime) { digitalWrite(ledPin, LOW); flashToggle = false; //after timer expired, turn led off } } void wasPulse() { pulseCount++; //the interrupt increments the counter, that is it and all it should do. }\n\nI tried the code, and I still cannot get a pulse read back. I have an LCD attached for future versions, I am trying to make it portable. I changed the LCD code around to allow DIGITAL Pin 2 to be open, and I plugged my 5v positive into the port. And I grounded the sensor through the Arduino. I did make some adjustments to the code and I will attach below, but I was wondering what else I could try? I personally waited too long to start on this project and I am in a crunch to finish as soon as possible. Do I need an LED attached? Thank you for taking time to try and help! I really appreciate it! #include <LiquidCrystal.h> #include <Wire.h> const int hardwareCounterPin = 2; // Interrupt 0 is pin2 const int ledPin = 13; const unsigned long samplePeriod = 10000UL; // the sample period in milliseconds unsigned long startTime; unsigned int pulseCount = 0; unsigned long startFlash; unsigned long flashTime = 250UL; boolean flashToggle = false; int lastPulseCount = 0; int calc; LiquidCrystal lcd(12, 11, 5, 4, 3, 6);// initialize the LCD library with the numbers of the interface pins void setup() { Serial.begin(9600); pinMode(ledPin,OUTPUT); lcd.begin(16, 2); // Print a message to the LCD...? attachInterrupt( 0, wasPulse, RISING); startTime = millis(); } void loop() { if (flashToggle) flashLED(); //ledPin will flash for 250ms each pulse. if (pulseCount > lastPulseCount) // if you detect a pulse, initiate a flash { startFlash = millis(); flashToggle = true; lastPulseCount = pulseCount; } if (millis() - startTime >= samplePeriod) // this will 'wait' for samplePeriod and then calculate the rate without using a delay { calculateGPM(); } } void calculateGPM() { int pulses = pulseCount; // start to ignore any more interrupts Serial.print(\"Gallons per Minute: \"); // do the math to convert pulses to GPM Serial.println (pulses*.08); // Print to your LCD here... lcd.setCursor(0, 1); lcd.println(\"Gallons Per Minute: \"); lcd.setCursor(0, 0); lcd.print(pulses*.08); startTime = millis(); pulseCount = 0; //reset the pulseCount variable and return to loop() function } void flashLED() { digitalWrite(ledPin, HIGH); // turn led on if (millis() - startFlash >= flashTime) { digitalWrite(ledPin, LOW); flashToggle = false; //after timer expired, turn led off } } void wasPulse() { pulseCount++; //the interrupt increments the counter, that is it and all it should do. }\n\nI tried the code, and I still cannot get a pulse read back. I have an LCD attached for future versions, I am trying to make it portable. I changed the LCD code around to allow DIGITAL Pin 2 to be open, and I plugged my 5v positive into the port. And I grounded the sensor through the Arduino. I did make some adjustments to the code and I will attach below, but I was wondering what else I could try? I personally waited too long to start on this project and I am in a crunch to finish as soon as possible. Do I need an LED attached? Thank you for taking time to try and help! I really appreciate it! it is blinking the on-board led connected to pin13, your leonardo has different interrupts than my Uno: External Interrupts: 3 (interrupt 0), 2 (interrupt 1), 0 (interrupt 2), 1 (interrupt 3) and 7 (interrupt 4). These pins can be configured to trigger an interrupt on a low value, a rising or falling edge, or a change in value. See the attachInterrupt() function for details. so if you are on Pin2, you need to change this: are you sure that the sensor outputs 5V? did you verify with a multimeter? I would comment out all of the LCD stuff until you get the Serial output right. add a debug line here and see if you get a pulse: if (pulseCount > lastPulseCount) // if you detect a pulse, initiate a flash { Serial.println(\"PULSE DETECTED\"); startFlash = millis(); flashToggle = true; lastPulseCount = pulseCount; } if you have a voltage, and are detecting it, well that't progress...."
    }
]