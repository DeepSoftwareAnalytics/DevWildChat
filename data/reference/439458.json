[
    {
        "link": "https://w3schools.com/js/js_best_practices.asp",
        "document": "Minimize the use of global variables.\n\nThis includes all data types, objects, and functions.\n\nGlobal variables and functions can be overwritten by other scripts.\n\nUse local variables instead, and learn how to use closures.\n\nAll variables used in a function should be declared as local variables.\n\nLocal variables must be declared with the , the , or the keyword, otherwise they will become global variables.\n\nIt is a good coding practice to put all declarations at the top of each script or function.\n• Provide a single place to look for local variables\n\nThis also goes for loop variables:\n\nIt is a good coding practice to initialize variables when you declare them.\n\nDeclaring objects with const will prevent any accidental change of type:\n\nDeclaring arrays with const will prevent any accidential change of type:\n• Use instead of\n• Use instead of\n• Use instead of\n• Use instead of\n• Use instead of\n• Use instead of\n• Use instead of\n\nA variable can contain all data types.\n\nBeware that numbers can accidentally be converted to strings or (Not a Number).\n\nWhen doing mathematical operations, JavaScript can convert numbers to strings:\n\nSubtracting a string from a string, does not generate an error but returns (Not a Number):\n\nThe comparison operator always converts (to matching types) before comparison.\n\nThe operator forces comparison of values and type:\n\nIf a function is called with a missing argument, the value of the missing argument is set to .\n\nUndefined values can break your code. It is a good habit to assign default values to arguments.\n\nRead more about function parameters and arguments at Function Parameters\n\nAlways end your statements with a . Even if you think there is no need for it.\n\nAlways treat numbers, strings, or booleans as primitive values. Not as objects.\n\nDeclaring these types as objects, slows down execution speed, and produces nasty side effects:\n\nThe function is used to run text as code. In almost all cases, it should not be necessary to use it.\n\nBecause it allows arbitrary code to be run, it also represents a security problem."
    },
    {
        "link": "https://medium.com/@onix_react/best-practices-for-writing-clean-javascript-code-a4e5755de69a",
        "document": "JavaScript is one of the most popular programming languages in web development, known for its flexibility and wide application across browsers and servers. But with great power comes great responsibility — maintaining clean, efficient, and readable code is crucial, especially when multiple developers are collaborating on a project. In this article, we’ll dive into essential best practices that will help you write better JavaScript, improve performance, and ensure long-term maintainability.\n\n1. Use and Instead of\n\nGone are the days of using to declare variables. Modern JavaScript encourages the use of and to improve code clarity and prevent issues caused by function scoping. should be used for variables that won’t be reassigned, while should be used for variables that can change.\n\nUnlike , which is function-scoped, and are block-scoped, which helps prevent unintended side effects in your code. This is especially useful in large codebases where variables are declared in different scopes.\n\nGlobal variables are accessible from any part of your code, making them prone to overwriting or unintended modifications. This not only introduces bugs but also makes debugging difficult, as you may not easily trace where the global variable was changed.\n\nTo avoid this, limit the use of global variables by encapsulating your code in functions, modules, or immediately invoked function expressions (IIFE). This practice helps protect your variables from being accessed or altered unexpectedly.\n• Risk of Overwriting: Global variables can be easily overwritten by other scripts or parts of your application, potentially causing bugs or unexpected behavior.\n• Difficulty in Debugging: Tracking down the location where a global variable was modified can be challenging, especially in large applications.\n• Namespace Pollution: Excessive use of global variables can lead to namespace pollution, where many variables are defined in the global scope, increasing the risk of naming conflicts.\n\nArrow functions provide a more concise and readable way to write functions in JavaScript, particularly when dealing with callbacks and functional programming. They also solve the long-standing issue of lexical scoping of the this keyword, making it behave more predictably.\n\nIn addition to simplifying syntax, arrow functions are often used to make short, single-line functions more compact. They implicitly return values without requiring the return keyword, which can significantly reduce boilerplate code in your projects.\n\nAsynchronous programming is essential for tasks like making API calls or interacting with a database without blocking the rest of your code. provides a cleaner and more readable way to write asynchronous code compared to traditional callbacks or promise chains.\n\nThis approach allows you to write asynchronous code that looks synchronous, making it easier to follow and understand. Error handling is also simplified, as you can use blocks with .\n\nThe directive enables JavaScript's strict mode, which was introduced in ECMAScript 5. This mode enforces a stricter set of rules on how JavaScript should behave, helping you catch common mistakes early. By using strict mode, silent errors that JavaScript normally overlooks are caught and reported as actual errors, allowing you to fix them before they cause larger issues.\n\nStrict mode also helps JavaScript engines optimize your code by removing ambiguities, sometimes resulting in performance improvements. Moreover, it disallows certain syntax that might be introduced in future ECMAScript versions, helping ensure your code remains compatible with modern standards.\n\nIn JavaScript, you can apply strict mode either globally to an entire script or within specific functions. Below is an example where strict mode is applied at the function level:\n\nEffective error handling is essential to ensure that minor issues don’t snowball into major crashes. In JavaScript, blocks are commonly used to manage errors. By catching and logging errors, you can debug issues more easily and prevent your application from breaking entirely.\n\nError handling is especially important in scenarios like network requests, where failures can occur unexpectedly. Always provide detailed error logs so that you can identify and fix issues quickly.\n\nTraditional for loops are often verbose and can lead to errors, especially when handling large arrays or objects. Instead, modern iteration methods like , , , and offer a more expressive and declarative way to work with collections in JavaScript. These methods not only improve readability but also help minimize errors by abstracting the iteration process.\n\nFor example, instead of manually tracking the index in a for loop, you can use to iterate over an array, ensuring that the logic remains clean and easy to follow.\n\nManipulating the DOM is one of the most resource-intensive operations in JavaScript. Every time you change the DOM, the browser has to re-render parts of the page, which can significantly slow down performance. To minimize this, it’s best to batch DOM manipulations together and apply them all at once.\n\nUsing is one technique for batching DOM updates. By first appending elements to a fragment and then appending the fragment to the DOM, you reduce the number of individual updates, thereby improving performance.\n\nAdditionally, caching DOM references prevents the need to repeatedly query the DOM, which can be slow. Event delegation is another powerful technique that minimizes the number of event listeners needed, by attaching them to a parent element instead of individual child elements.\n\n9. Choose One Style Guide and Stick to It\n\nMaintaining a consistent coding style across a project is essential, especially when multiple developers are contributing. Adopting a well-established style guide, such as Airbnb’s JavaScript Style Guide or Idiomatic JavaScript, ensures that your code follows a consistent pattern, making it easier for others to read and understand. These guides cover everything from indentation and naming conventions to best practices for code structure and formatting.\n\nBy choosing a style guide and sticking to it, you prevent unnecessary debates about formatting, improve readability, and reduce the likelihood of errors creeping into the codebase. It’s as if everyone is speaking the same language — making collaboration smoother and more efficient.\n\nComments and documentation are crucial for maintaining clarity in JavaScript code, especially in large projects or collaborative environments. Clear documentation ensures that all developers can understand and contribute to the codebase, even if they didn’t write it themselves.\n\nComments provide explanations for specific code segments and help others (or your future self) understand complex logic. However, comments should be concise and to the point, used only when necessary to explain non-obvious parts of the code.\n• Linters: Tools like ESLint are a must-have for enforcing consistent code style and catching errors early. Linters help maintain a clean, error-free codebase, which is especially crucial in collaborative projects.\n• Code Formatters: Tools like Prettier ensure consistent code formatting across the team and improve code readability.\n• Version Control Systems: Use Git for version control to manage and track changes in your project, enabling better collaboration among team members.\n• Package Managers: Tools like npm or Yarn help you install, manage, and update JavaScript dependencies, ensuring your project is always using the correct version of libraries and packages.\n• Testing Frameworks: Jest, Mocha, and Jasmine are popular testing frameworks for writing unit and integration tests, ensuring your code works as expected and preventing regressions during future development.\n\nIn the fast-paced world of JavaScript development, following best practices is key to writing code that lasts. By adhering to a style guide, enabling strict mode, optimizing loops, and embracing modern JavaScript features like async/await, you ensure that your codebase remains clean, maintainable, and performant.\n\nWhether you’re building a small project or a large-scale application, these best practices will help you write code that not only works well but also stands the test of time. Remember, good code isn’t just about functionality — it’s about creating a foundation that allows for easy collaboration, scaling, and long-term success."
    },
    {
        "link": "https://daily.dev/blog/js-best-practices-for-efficient-code",
        "document": "Looking to improve your JavaScript skills? Here's a concise guide to writing efficient, clean, and faster JavaScript code:\n• Embrace Modern JavaScript: Utilize , , arrow functions, async/await, and other ES6+ features for cleaner code.\n• Optimize Loops and Data Handling: Use array methods like and for better performance.\n• Efficient DOM Manipulation: Make changes in batches and use frameworks to minimize direct DOM changes.\n• Asynchronous Programming: Use for better readability and handling of asynchronous operations.\n• Code Organization: Keep your code modular with ES6 modules and avoid global variables to reduce conflicts.\n• Performance Optimization: Minify and bundle your code, optimize network requests, and choose efficient data structures.\n• Tooling: Utilize tools like Visual Studio Code or WebStorm and libraries thoughtfully, considering factors like size and performance.\n\nThis guide is designed to make your JavaScript projects more efficient and your code easier to maintain and understand.\n\nJavaScript is a programming language that makes websites interactive. It’s what allows you to have moving elements, forms that respond as you fill them out, and more on web pages. Here’s what you should know about it:\n• JavaScript code works in your web browser, making pages react quickly to what you do without having to wait for the server.\n• It’s one of the main tools for making websites along with HTML and CSS. They all work together to build the parts of a website you interact with.\n• Although JavaScript looks a bit like the programming language C, it’s actually a scripting language. This means it runs right away in your web browser, without needing to be turned into another form first.\n• JavaScript isn’t just for making websites look good. It’s also used on servers with something called Node.js, in mobile app development, and even in making games.\n\nIn short, JavaScript lets web pages do cool stuff, working right in the browser to make sites lively and interactive.\n\nSince 2015, JavaScript got some updates that made writing code easier and cleaner:\n• let and const - These are ways to name things in your code that are better than the old way (using var).\n• Arrow functions - A shorter way to write functions, which are bits of code that do something.\n• Template literals - A way to mix words and data together in a string using backticks (`).\n• Destructuring - A shortcut for pulling specific items out of a list or object and giving them their own names.\n• Promises - A way to deal with code that runs on its own time, like downloading a picture. It lets you say, \"Do this, then do that when you’re done, or let me know if there’s a problem.\"\n• Classes - A template for making objects that can do certain things and know certain information.\n\nAnd there are more cool updates:\n• Async/await - Helps you write code that waits on something, like data from the internet, in a way that’s easy to read.\n• Import/export modules - Lets you organize your code into different files so it’s easier to handle.\n• Enhanced object literals - A simpler way to make objects, which are collections of data and actions.\n• Optional chaining - A safety net that prevents errors if you try to get information that isn’t there.\n\nThese updates help make JavaScript code easier to write, read, and manage, especially for big projects.\n\nJavaScript is a super handy language that lets you make web pages do fun and interactive stuff. But to keep everything running smoothly, it's important to write your code in a smart way. Let's dive into some key tips for making your JavaScript code work better.\n\nWhen you're naming things in your code, it's best to use and instead of :\n• is for things that might change.\n• is for things that stay the same.\n• is old-school and can lead to mistakes.\n\nChoosing and helps make your code clearer and keeps you from running into unexpected issues.\n\nWhen you're working with lists (arrays), it's a good idea to use special commands like , , and instead of the old and loops. These commands are not only easier to read but also tend to be more efficient:\n\nPlus, try to figure out how big your list needs to be ahead of time, instead of making it bigger little by little.\n\nChanging web page elements too often can make your site slow. To avoid this:\n• Group changes together before making them all at once.\n• Use tools like React that don't change the page directly.\n• Wait a bit before making changes if lots of them are happening fast.\n\nThis helps your pages run faster and smoother.\n\nUsing lets your code wait for things like data from the internet without stopping everything else. This makes your site feel quicker.\n\nIt's like saying, \"Go get this data, but keep everything else running while you wait.\"\n\nGood error handling keeps small problems from turning into big crashes:\n• Use to catch errors in risky spots.\n• Write down errors with details so you can fix them.\n• Make sure your site keeps working, even if there's an error.\n\nThis way, you're ready for errors and can handle them without stopping your site.\n\nBy following these tips, you'll make your JavaScript code work better and faster.\n\nIt's smart to keep your JavaScript code in different files and sections, especially if you're working on a big project. Here's how:\n• Break up your code based on what it does. For example, keep all the login stuff in one file, and all the chat stuff in another.\n• Use ES6's import and export to let pieces of your code talk to each other. Like this:\n• Only share code between files if you really need to. Not everything needs to be exported.\n• Make sure your code doesn't go in circles with imports (like file A needing something from file B, but file B also needs something from file A).\n\nPlanning your code like this makes it cleaner and easier to work with.\n\nKeeping your code to itself helps avoid mix-ups:\n• Wrap your code in an IIFE (a function that runs right away) so it doesn't spill out:\n• Use and for your variables, not , which can be seen everywhere.\n• If you have data or utilities that need to be shared, put them in one big object instead of spreading them out:\n\nThis way, your data is neat and not all over the place.\n\nPicking good names for things in your code makes it easier to understand:\n• Use camelCase for naming variables and functions.\n• Start global constants with GLOBAL_ so you know they're important and everywhere.\n• Give functions names that tell you what they do.\n• Choose meaningful names for your variables, not just a, b, c.\n\nSticking to these naming rules helps everyone get what your code is about.\n\nLeaving notes in your code helps others (and you later) understand it:\n• Give a quick overview of what sections of code do.\n• Use comments to explain tricky parts or why you made certain choices.\n• Document functions with JSDoc so tools can help explain them to you.\n• Keep a README file that talks about your project, how to set it up, and how it works.\n• Don't leave a bunch of commented-out code or notes on super obvious stuff.\n\nGood notes make your code friendlier for everyone.\n\nMaking your JavaScript files smaller and combining them helps your website load faster. Here's how you can do it:\n• Use tools like Webpack or Parcel to mix several JavaScript files into one. This means fewer pieces for the browser to load.\n• Turn on options in your tool to make files smaller by removing extra spaces and making names shorter without changing what the code does.\n• Split your code into smaller parts that load only when needed. This stops unnecessary code from loading.\n• Get rid of code you're not using with a trick called tree shaking.\n• Also, make images, CSS, and HTML smaller along with your JavaScript code.\n\nDoing all this can really help your website load quicker.\n\nMaking sure the browser doesn't ask for more than it needs is key:\n• Use cache settings so the browser doesn't keep asking for the same stuff.\n• Use CDNs to send your content from a place closer to your users. This makes things faster.\n• Load big things like images only when you need them, not all at once.\n• Avoid too many redirects that make extra trips.\n• Make things smaller with gzip to cut down on transfer size.\n• Don't send all your requests at once. Spread them out.\n• Have a plan for when requests don't go through, like setting timeouts and retries.\n\nPlanning your network requests can make your website more efficient.\n\nPicking the right way to store and use data makes your code run better:\n• Use Maps for quick lookups and changes instead of objects.\n• Use Sets when you just need a list without key-value pairs. They're faster for checking if something is there.\n• Choose array methods like .filter and .map instead of slow loops.\n• When you need specific types of numbers, use typed arrays like Int32Array.\n• If you have complicated data, try to simplify it. This makes accessing data quicker.\n\nKnowing which data structure to use can make your code more efficient.\n\nComparison table in Markdown format with key criteria like supported languages, debugging, extensions, pricing etc.\n\nBoth Visual Studio Code and WebStorm are great for writing JavaScript. VS Code is lighter and can be customized with add-ons, while WebStorm has lots of built-in features for web projects. Think about your budget, what you need for your project, and what you like to use when choosing.\n\nWhen picking a JavaScript library, think about:\n• Size: Smaller ones are usually easier to handle. Make sure you really need all the features it offers.\n• Performance: See how fast it does things like changing webpage elements or handling data. Lighter libraries usually work faster.\n• Browser Support: Some libraries might not work in older web browsers. Make sure it fits what you need.\n• Modularity: Some libraries, like Lodash, let you only use the bits you need, which helps keep things light.\n• Activity Level: Make sure the library is still being updated and that people are fixing bugs.\n• Licensing: Check if there are any rules about how you can use it, especially for work stuff.\n\nStart with well-known ones like React, Vue, jQuery, and Lodash. But also look at simpler options like Alpine.js or date-fns for certain jobs. Focus on what you really need and try not to add stuff you won't use much.\n\nWhen it comes to writing JavaScript, it's all about making code that's quick, easy to handle, and less likely to mess up. By sticking to the smart tips we talked about, you can:\n• Make things run faster by choosing the right way to name things, making loops smarter, organizing data better, putting code together, and more.\n• Make your code easier to read by using names that make sense, breaking your code into parts, and explaining your code with comments.\n• Make your code more trustworthy by using exact matches, handling errors well, and building things step by step.\n• Make your life easier by using cool shortcuts like async/await for code that waits around.\n• Work better with others by writing clear code and not mixing everything together.\n\nEven trying just a few of these smart moves can make your JavaScript code cleaner, simpler, and easier to keep up with. Start with what helps your project the most. As you get the hang of it, adding more good habits will feel like a breeze.\n\nAim for code that's easy to get, don't rush to make things complicated, and only tweak working code if you really need to. Finding the sweet spot leads to JavaScript that works well, grows with you, and sets you up for winning as your projects get bigger. Keep using these coding tricks, and you'll get better and better at JavaScript.\n\nHow can I measure the performance of my JavaScript code?\n\nTo check how fast your JavaScript code runs, you can use tools built into your web browser, like Chrome's DevTools. Look for the Performance tab to see how long your code takes to run and find parts that might be slowing things down. Tools like Lighthouse are also great for spotting ways to make your web app faster.\n\nFor making your JavaScript code smaller (which helps it load faster), you can use:\n\nThese tools strip out stuff like extra spaces and notes that aren't needed for the code to work.\n\nHow do I optimize network requests in JavaScript?\n\nTo make sure your web page doesn't wait too long for things to load:\n• Use caching so your browser remembers stuff it's already seen\n• Use async requests with something like the Fetch API to keep the page responsive\n• Add timeouts and retry strategies for when things go slow\n\nWhat is the best way to handle errors in JavaScript?\n• Catching mistakes with so they don't crash your app\n• Keeping track of errors to help fix them\n• Making sure your app still works, even if something goes wrong\n• Showing a backup plan on the screen if there's an error\n\nThis way, small problems don't turn into big ones.\n\nYes, it's a good idea to keep your tools up to date. This gives you:\n• New features to use\n\nAlways read the update notes, follow safe update steps, and test your code to make sure everything still works right after an update.\n\nHow can I make my JavaScript code more efficient?\n\nTo make your JavaScript code run better, you can:\n• Make your code smaller by getting rid of extra spaces and comments. Tools like UglifyJS can help.\n• Combine several scripts into one file to cut down on how many times your page has to ask for files.\n• Use Gzip to make your files smaller so they move faster.\n• Put your files on a CDN so they get to users quicker.\n• Load scripts without blocking other stuff by using async.\n• Keep some data on the user's device to reduce network requests.\n• Make sure loops and functions are as simple as possible, and pick the right way to store data.\n\nHow to improve code quality in JavaScript?\n\nTo make your JavaScript code better, you should:\n• Split your code into parts with specific jobs.\n• Get rid of stuff you don't need like extra variables or functions.\n• Keep your code clean with consistent spaces and lines.\n• Check your code with tools like ESLint.\n• Test different parts of your code to catch mistakes.\n• Tidy up your code to keep it simple.\n\nWhich JavaScript code is more efficient?\n\nUsually, a loop runs a bit faster than a loop in JavaScript because it doesn't check conditions as much. But, the difference is small. What's more important is writing code that's easy to read. Use loops for straightforward tasks and loops when you need more control. Making your code clear is more important than making it a tiny bit faster.\n\nWhat is the best way to write JavaScript code?\n\nHere are some good habits for writing JavaScript:\n• Use and instead of .\n• Set up your variables when you create them.\n• Name your functions clearly.\n• Use try/catch to deal with mistakes.\n• Comment on your code to explain the tough parts.\n\nFollowing these tips will make your JavaScript code easier to work with and understand."
    },
    {
        "link": "https://medium.com/@earlred/11-tips-to-simplify-and-enhance-your-javascript-5175d3e4bd83",
        "document": "Ready to take your coding skills to the next level?\n\nIn today’s fast-paced world, writing clean and expressive code is essential for any JavaScript developer. Whether you are a seasoned professional or just starting out, following best practices and adopting certain techniques can greatly improve the readability and maintainability of your code. In this article, we will explore 11 tips that will help simplify your JavaScript code and make it easily understandable by other developers.\n\n1. Declare and Initialize Variables at the Top\n\nOne of the most important steps in simplifying your JavaScript code is to declare and initialize variables at the top of your function or script. Late declarations can disrupt readability and make it difficult for others to understand how variables are being used throughout the code. Coupled with, initializing variables at the time of creation ensures that none are left undefined, which can lead to unexpected errors down the line.\n\nTo improve both efficiency and readability, it is best practice to build modular, specialized functions. Instead of having one function that tries to do everything, consider breaking it down into smaller functions with specific tasks. This approach makes each function inherently simpler and easier to understand. It also allows you to reuse these functions in different programs if needed.\n\nAnother advantage of using modular functions is reducing visual clutter in your code. If you find yourself duplicating code in multiple places, it’s a sign that you should move that duplicated code into a separate function and call it wherever necessary. This not only improves readability but also aids in debugging as you only need to look at one function instead of multiple usage sections.\n\nWhile recursion can be a powerful tool for solving problems, nesting recursive functions too many levels deep can significantly impact code readability. It becomes challenging to understand the logic at a glance, making debugging and maintenance more difficult. To avoid confusion, it’s important to be mindful of where recursive functions can be pulled out of their nested place without incurring significant runtime cost. Whenever possible, try to simplify your recursive functions to improve readability.\n\nAccessing the Document Object Model (DOM) is crucial for manipulating web pages dynamically. However, repeatedly accessing the DOM can lead to visual clutter and slow down your program’s performance. Instead of accessing the DOM multiple times, consider accessing it once and caching the result in a variable for later use. This approach not only improves performance but also makes your code visually cleaner and easier to read.\n\nGlobal variables should be avoided whenever possible in JavaScript development due to their potential impact on code stability and maintainability. Variables declared outside of functions have global scope, meaning they can be accessed from anywhere within the program. If you have both a local variable and a global variable with the same name, JavaScript will prioritize the local variable over the global one.\n\nUsing global variables excessively can lead to naming conflicts and inconsistent behavior if JavaScript resolves silent errors in multiple ways. It is crucial to minimize side effects by keeping variables as local as possible within their respective scopes.\n\nWhen creating objects in JavaScript, setting default values for some or all properties can greatly enhance readability and prevent undefined values. By explicitly defining default values for object properties, you provide clarity about what type of data is expected for each attribute.\n\nFor example, consider an object representing a person with properties like name, age, gender, and email. You can set default values for each property to ensure that they are not undefined. This practice also makes it easier for other developers to understand the structure of the object and its expected data types.\n\nConcatenating strings in JavaScript can be cumbersome, especially when combining them with variables or dynamic values. Fortunately, JavaScript provides template literals as a more efficient and readable alternative. Template literals allow you to embed expressions directly within string literals using backticks (`) instead of quotation marks (‘ or “).\n\nBy using template literals, you can easily combine strings and variables without resorting to manual concatenation or complex string manipulation methods. This approach improves code readability by making it clear which parts of the string are static text and which parts are dynamic values.\n\nUnderstanding how equality operators work in JavaScript is essential for writing expressive code. The double equals (==) operator checks if two objects share the same values but may not be of the same type. On the other hand, the triple equals (===) operator checks if two objects are both of the same type and have identical values.\n\nBy utilizing these equality operators effectively in your code, you can simplify conditional statements and reduce unnecessary type coercion or conversion. It’s important to choose the appropriate equality operator based on your specific needs to ensure accurate comparisons.\n\nWhen naming variables, functions, or classes in your JavaScript code, it is crucial to avoid cryptic abbreviations that may be difficult for other developers to understand. Instead, opt for descriptive names that convey the purpose and functionality of the code element.\n\nChoosing meaningful names not only improves code readability but also enhances maintainability. When revisiting your code after some time or when collaborating with other developers, clear and descriptive names can provide valuable context and make it easier to understand the logic of the program.\n\nFollowing the principle of single responsibility helps in creating more expressive JavaScript code. Functions and classes should have a clear and specific purpose, focusing on a single task rather than trying to do too much. This approach improves readability, reusability, and maintainability.\n\nBy keeping functions and classes independent of each other, you create modular components that can be easily understood and tested individually. It also reduces complexity by breaking down complex tasks into smaller manageable parts.\n\nEfficient looping techniques are crucial for performance optimization in JavaScript. Avoiding unnecessary iterations or using inefficient looping constructs can lead to slower execution times or even memory issues.\n\nConsider utilizing higher-order functions like map(), filter(), reduce() instead of traditional loops whenever possible. These higher-order functions provide a more expressive way to manipulate arrays without explicitly writing loop constructs. They often result in cleaner and shorter code while improving readability.\n\nManipulating the DOM is an essential part of web development, but excessive DOM manipulation can impact performance significantly. Each time you modify elements in the DOM, it triggers rendering updates that can be resource-intensive operations.\n\nTo optimize your JavaScript code’s efficiency, consider techniques like document fragment caching or batching DOM updates together before applying them to the actual document structure. Additionally, leveraging modern libraries/frameworks like React or Vue.js can help optimize DOM rendering processes while providing additional benefits such as virtual DOM diffing algorithms.\n\nJavaScript is a versatile programming language with new features and updates regularly being introduced. To write clean and expressive code, it’s important to keep learning about JavaScript and staying up-to-date with the latest advancements in the language. There are various resources available online such as tutorials, documentation, and online courses that can help you deepen your understanding of JavaScript concepts and best practices.\n\nIn this article, we have explored several techniques for writing more effective and expressive JavaScript code. By following these tips, you can simplify your code, improve its readability, and make it easily understandable by other developers.\n\nBy adopting these tips in your JavaScript development workflow and continuously improving your skills and knowledge of the language’s best practices and features. You’ll become a more efficient developer and produce cleaner code that is easier to maintain and understand.\n• Java Script Tips To Help You Build Better Web Development Projects\n• 50 Java Script Tips To Help You Learn Faster And Write Better Code"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Performance/JavaScript",
        "document": "It is very important to consider how you are using JavaScript on your websites and think about how to mitigate any performance issues that it might be causing. While images and video account for over 70% of the bytes downloaded for the average website, byte per byte, JavaScript has a greater potential for negative performance impact — it can significantly impact download times, rendering performance, and CPU and battery usage. This article introduces tips and techniques for optimizing JavaScript to enhance the performance of your website. To learn about the effects of JavaScript on web performance and how to mitigate or fix related issues.\n\nTo optimize or not to optimize The first question you should answer before starting to optimize your code is \"what do I need to optimize?\". Some of the tips and techniques discussed below are good practices that will benefit just about any web project, whereas some are only needed in certain situations. Trying to apply all these techniques everywhere is probably unnecessary, and may be a waste of your time. You should figure out what performance optimizations are actually needed in each project. To do this, you need to measure the performance of your site. As the previous link shows, there are several different ways to measure performance, some involving sophisticated performance APIs. The best way to get started however, is to learn how to use tools such as built-in browser network and performance tools, to see what parts of the page load are taking a long time and need optimizing.\n\nThe most performant, least blocking JavaScript you can use is JavaScript that you don't use at all. You should use as little JavaScript as possible. Some tips to bear in mind:\n• You don't always need a framework: You might be familiar with using a JavaScript framework. If you are experienced and confident with using this framework, and like all of the tooling it provides, then it might be your go-to tool for building most projects. However, frameworks are JavaScript-heavy. If you are creating a fairly static experience with few JavaScript requirements, you probably don't need that framework. You might be able to implement what you need using a few lines of standard JavaScript.\n• Consider a simpler solution: You might have a flashy, interesting solution to implement, but consider whether your users will appreciate it. Would they prefer something simpler?\n• Remove unused code: This may sound obvious, but it is surprising how many developers forget to clean up unused functionality that was added during the development process. You need to be careful and deliberate about what is added and removed. All script gets parsed, whether it is used or not; therefore, a quick win to speed up downloads would be to get rid of any functionality not being used. Consider also that often you will only use a small amount of the functionality available in a framework. Is it possible to create a custom build of the framework that only contains the part that you need?\n• Consider built-in browser features: It might be that you can use a feature the browser already has, rather than creating your own via JavaScript. For example:\n• Use the browser's own player.\n• Use CSS animations instead of a JavaScript animation library (see also Handling animations). You should also split your JavaScript into multiple files representing critical and non-critical parts. JavaScript modules allow you to do this more efficiently than just using separate external JavaScript files. Then you can optimize these smaller files. Minification reduces the number of characters in your file, thereby reducing the number of bytes or weight of your JavaScript. Gzipping compresses the file further and should be used even if you don't minify your code. Brotli is similar to Gzip, but generally outperforms Gzip compression. You can split and optimize your code manually, but often a module bundler like webpack will do a better job of this.\n\nBefore looking at the tips contained in this section, it is important to talk about where in the process of browser page rendering JavaScript is handled. When a web page is loaded:\n• The HTML is generally parsed first, in the order in which it appears on the page.\n• Whenever CSS is encountered, it is parsed to understand the styles that need to be applied to the page. During this time, linked assets such as images and web fonts start to be fetched.\n• Whenever JavaScript is encountered, the browser parses, evaluates, and runs it against the page.\n• Slightly later on, the browser works out how each HTML element should be styled, given the CSS applied to it.\n• The styled result is then painted to the screen. Note: This is a very simplified account of what happens, but it does give you an idea. The key step here is Step 3. By default, JavaScript parsing and execution are render-blocking. This means that the browser blocks the parsing of any HTML that appears after the JavaScript is encountered, until the script has been handled. As a result, styling and painting are blocked too. This means that you need to think carefully not only about what you are downloading, but also about when and how that code is being executed. The next few sections provide useful techniques for optimizing the parsing and execution of your JavaScript.\n\nLoading critical assets as soon as possible If a script is really important and you are concerned that it is affecting performance by not being loaded quickly enough, you can load it inside the of the document: This works OK, but is render-blocking. A better strategy is to use to create a preloader for critical JavaScript: The preload fetches the JavaScript as soon as possible, without blocking rendering. You can then use it wherever you want in your page: or inside your script, in the case of a JavaScript module: Note: Preloading does not guarantee that the script will be loaded by the time you include it, but it does mean that it will start being downloaded sooner. Render-blocking time will still be shortened, even if it is not completely removed.\n\nOn the other hand, you should aim to defer parsing and execution of non-critical JavaScript to later on, when it is needed. Loading it all up-front blocks rendering unnecessarily. First of all, you can add the attribute to your elements: This causes the script to be fetched in parallel with the DOM parsing, so it will be ready at the same time and won't block rendering. Note: There is another attribute, , which causes the script to be executed after the document has been parsed, but before firing the event. This has a similar effect to . You could also just not load the JavaScript at all until an event occurs when it is needed. This could be done via DOM scripting, for example: const scriptElem = document.createElement(\"script\"); scriptElem.src = \"index.js\"; scriptElem.addEventListener(\"load\", () => { // Run a function contained within index.js once it has definitely loaded init(); }); document.head.append(scriptElem); JavaScript modules can be dynamically loaded using the function: import(\"./modules/myModule.js\").then((module) => { // Do something with the module });\n\nWhen the browser runs your JavaScript, it will organize the script into tasks that are run sequentially, such as making fetch requests, driving user interactions and input through event handlers, running JavaScript-driven animation, and so on. Most of this happens on the main thread, with exceptions including JavaScript that runs in Web Workers. The main thread can run only one task at a time. When a single task takes longer than 50 ms to run, it is classified as a long task. If the user attempts to interact with the page or an important UI update is requested while a long task is running, their experience will be affected. An expected response or visual update will be delayed, resulting in the UI appearing sluggish or unresponsive. To mitigate this issue, you need to break down long tasks into smaller tasks. This gives the browser more chances to perform vital user interaction handling or UI rendering updates — the browser can potentially do them between each smaller task, rather than only before or after the long task. In your JavaScript, you might do this by breaking your code into separate functions. This also makes sense for several other reasons, such as easier maintenance, debugging, and writing tests. However, this kind of structure doesn't help with main thread blocking. Since all the five functions are being run inside one main function, the browser runs them all as a single long task. To handle this, we tend to run a \"yield\" function periodically to get the code to yield to the main thread. This means that our code is split into multiple tasks, between the execution of which the browser is given the opportunity to handle high-priority tasks such as updating the UI. A common pattern for this function uses to postpone execution into a separate task: This can be used inside a task runner pattern like so, to yield to the main thread after each task has been run: async function main() { // Create an array of functions to run const tasks = [a, b, c, d, e]; // Loop over the tasks while (tasks.length > 0) { // Shift the first task off the tasks array const task = tasks.shift(); // Run the task task(); // Yield to the main thread await yield(); } } To improve this further, we can use where available to allow this code to continue executing ahead of other less critical tasks in the queue: function yield() { // Use scheduler.yield() if available if (\"scheduler\" in window && \"yield\" in scheduler) { return scheduler.yield(); } // Fall back to setTimeout: return new Promise((resolve) => { setTimeout(resolve, 0); }); }\n\nAnimations can improve perceived performance, making interfaces feel snappier and making users feel like progress is being made when they are waiting for a page to load (loading spinners, for example). However, larger animations and a higher number of animations will naturally require more processing power to handle, which can degrade performance. The most obvious piece of animation advice is to use less animations — cut out any non-essential animations, or consider giving your users a preference they can set to turn off animations, for example if they are using a low-powered device or a mobile device with limited battery power. For essential DOM animations, you are advised to use CSS animations where possible, rather than JavaScript animations (the Web Animations API provides a way to directly hook into CSS animations using JavaScript). Using the browser to directly perform DOM animations rather than manipulating inline styles using JavaScript is much faster and more efficient. See also CSS performance optimization > Handling animations. For animations that can't be handled in JavaScript, for example, animating an HTML , you are advised to use rather than older options such as . The method is specially designed for handling animation frames efficiently and consistently, for a smooth user experience. The basic pattern looks like this: function loop() { // Clear the canvas before drawing the next frame of the animation ctx.fillStyle = \"rgb(0 0 0 / 25%)\"; ctx.fillRect(0, 0, width, height); // Draw objects on the canvas and update their positioning data // ready for the next frame for (const ball of balls) { ball.draw(); ball.update(); } // Call requestAnimationFrame to run the loop() function again // at the right time to keep the animation smooth requestAnimationFrame(loop); } // Call the loop() function once to set the animation running loop(); You can find a nice introduction to canvas animations at Drawing graphics > Animations, and a more in-depth example at Object building practice. You can also find a full set of canvas tutorials at Canvas tutorial.\n\nEvents can be expensive for the browser to track and handle, especially when you are running an event continuously. For example, you might be tracking the position of the mouse using the event to check whether it is still inside a certain area of the page: function handleMouseMove() { // Do stuff while mouse pointer is inside elem } elem.addEventListener(\"mousemove\", handleMouseMove); You might be running a game in your page. While the mouse is inside the canvas, you will want to constantly check for mouse movement and cursor position and update the game state — including the score, the time, the position of all the sprites, collision detection information, etc. Once the game is over, you will no longer need to do all that, and in fact, it will be a waste of processing power to keeping listening for that event. It is, therefore, a good idea to remove event listeners that are no longer needed. This can be done using : Another tip is to use event delegation wherever possible. When you have some code to run in response to a user interacting with any one of a large number of child elements, you can set an event listener on their parent. Events fired on any child element will bubble up to their parent, so you don't need to set the event listener on each child individually. Less event listeners to keep track of means better performance. See Event delegation for more details and a useful example.\n\nThere are several general best practices that will make your code run more efficiently.\n• Reduce DOM manipulation: Accessing and updating the DOM is computationally expensive, so you should minimize the amount that your JavaScript does, especially when performing constant DOM animation (see Handling JavaScript animations above).\n• Batch DOM changes: For essential DOM changes, you should batch them into groups that get done together, rather than just firing off each individual change as it occurs. This can reduce the amount of work the browser is doing in real terms, but also improve perceived performance. It can make the UI look smoother to get several updates out of the way in one go, rather than constantly making small updates. A useful tip here is — when you have a large chunk of HTML to add to the page, build the entire fragment first (typically inside a ) and then append it all to the DOM in one go, rather than appending each item separately.\n• Simplify your HTML: The simpler your DOM tree is, the faster it can be accessed and manipulated with JavaScript. Think carefully about what your UI needs, and remove unnecessary cruft.\n• Reduce the amount of looped code: Loops are expensive, so reduce the amount of loop usage in your code wherever possible. In cases where loops are unavoidable:\n• Avoid running the full loop when it is unnecessary, using or statements as appropriate. For example, if you are searching arrays for a specific name, you should break out of the loop once the name is found; there is no need to run further loop iterations: function processGroup(array) { const toFind = \"Bob\"; for (let i = 0; i < array.length - 1; i++) { if (array[i] === toFind) { processMatchingArray(array); break; } } }\n• Do work that is only needed once outside the loop. This may sound a bit obvious, but it is easy to overlook. Take the following snippet, which fetches a JSON object containing data to be processed in some way. In this case the operation is being done on every iteration of the loop, which is a waste of computing power. The fetching, which does not depend on , could be moved outside the loop, so it is only done once.\n• Run computation off the main thread: Earlier on we talked about how JavaScript generally runs tasks on the main thread, and how long operations can block the main thread, potentially leading to bad UI performance. We also showed how to break long tasks up into smaller tasks, mitigating this problem. Another way to handle such problems is to move tasks off the main thread altogether. There are a few ways to achieve this:\n• Use asynchronous code: Asynchronous JavaScript is basically JavaScript that does not block the main thread. Asynchronous APIs tend to handle operations such as fetching resources from the network, accessing a file on the local file system, or opening a stream to a user's web cam. Because those operations could take a long time, it would be bad to just block the main thread while we wait for them to complete. Instead, the browser executes those functions, keeps the main thread running subsequent code, and those functions will return results once they are available at some point in the future. Modern asynchronous APIs are -based, which is a JavaScript language feature designed for handling asynchronous operations. It is possible to write your own Promise-based functions if you have functionality that would benefit from being run asynchronously.\n• Run computation in web workers: Web Workers are a mechanism allowing you to open a separate thread to run a chunk of JavaScript in, so that it won't block the main thread. Workers do have some major restrictions, the biggest being that you can't do any DOM scripting inside a worker. You can do most other things, and workers can send and receive messages to and from the main thread. The main use case for workers is if you have a lot of computation to do, and you don't want it to block the main thread. Do that computation in a worker, wait for the result, and send it back to the main thread when it is ready.\n• Use WebGPU: WebGPU is a browser API that allows web developers to use the underlying system's GPU (Graphics Processing Unit) to carry out high-performance computations and draw complex images that can be rendered in the browser. It is fairly complex, but it can provide even better performance benefits than web workers."
    },
    {
        "link": "https://medium.com/@raygunio/best-practices-for-writing-clean-maintainable-javascript-cca3d4174f5a",
        "document": "The world’s biggest language comes with a huge collection of conventions and guidelines from the community’s collective wisdom. Following JavaScript best practices can help achieve faster page loads and better performance, improve code readability, and make maintenance and debugging easier. Carefully crafted code can also prevent errors and security issues, especially if it’s complemented with real-time diagnostic tools such as JavaScript error monitoring.\n\nIn this article, we’ll look into a selection of JavaScript best practices that you can use in front-end development.\n\n1. Choose a JavaScript coding style guide and stick to it\n\nEven though you can set up your own coding guidelines that fit with your goals, you don’t necessarily have to. There are multiple ready-to-use JavaScript coding style guides that are well tested and widely used across the industry. Some examples include the community-based Idiomatic JavaScript, the Google JavaScript Style Guide, and AirBnB’s JavaScript Style Guide.\n\nUsing a coding style guide is especially important in teamwork, where multiple developers are working on the same project. As Idiomatic JavaScript puts it, “all code in any code base should look like a single person typed it, no matter how many people contributed.” Whether you create your own style guide or use a third-party one, consistent code will be easier to read, write, debug, and maintain.\n\nMake the names of your variables, functions, and other code structures easy to understand for anyone who works with your code. Don’t use names that are either too short or too long, and take care that they succinctly describe their own purpose.\n\nSome good examples are (from the DOM API):\n\nAlso keep in mind that JavaScript is a case-sensitive language. As camel case capitalization is the most common naming system in JavaScript programming, you should use lower camelcase for variables and functions and upper camelcase for classes and interfaces for better code readability.\n\n3. Use shorthands, but be careful with them\n\nJavaScript includes many shorthands that allow you to write code faster and make your scripts load faster.\n\nThere are older shorthands that have been part of the JavaScript syntax for ages, such as the shorthand:\n\nAnd of course, there are newer ones, too, such as arrow functions introduced in ECMAScript 6:\n\nSometimes, however, shorthands might return surprising results. So, always be sure of what you’re doing, check the documentation, find relevant JavaScript code examples, and test the outcome.\n\n4. Comment your code, but keep it short\n\nCommenting is a hot topic in programming. Some say it’s not necessary at all, but code without any comments gets hard to read after a while — especially when working on team or legacy projects. On the other hand, overly long and verbose comments are unnecessary because they’ll take extra time to read through and understand.\n\nAs a rule of thumb, comment your code, especially functions, classes, objects, and interfaces, but only include key information. To keep your comments concise and easy to read, use tags such as , , , , and others.\n\nHere’s an example of a short but descriptive comment from JSDoc’s guidelines:\n\nIf you comment your JavaScript code properly, you can also use a tool such as JSDoc to automatically generate documentation for your project.\n\nTaking separation of concerns (SoC) seriously is one of the most important JavaScript coding practices. Technically, JavaScript allows you to directly change the CSS code using the property. However, to make debugging easier and improve code maintainability, it’s best to avoid it.\n\nAs an alternative, you can add and remove classes using the API as follows (then add the style rules with CSS):\n\nAs global variables are available to all the scripts running on your page, they can easily be overridden by other variables using the same name. There are various ways to reduce the number of global variables, but ECMAScript 6 has introduced two new JavaScript statements you can use to declare variables in the local scope: and .\n\nBoth and create block-scoped local variables, but can be re-declared (in a different scope) while can’t. As opposed to , neither nor becomes a property of the object, so they can’t be accessed, and therefore overridden, by other scripts — even when they are declared globally (in the highest scope).\n\nYou can define with or without a value (however, it can only be read and written after full initialization), but you can’t declare without a value:\n\n7. Use instead of loops\n\nLoops can get costly performance-wise because you repeat the same operation over and over again. However, if you optimize them, you can make them run faster.\n\nThere are many JavaScript best practices to write more performant loops, such as avoiding nesting, keeping DOM manipulation outside of loops, and declaring a separate variable for the length of the loop (e.g. ).\n\nUsing the statement instead of is such a JavaScript coding practice, too. This syntax has been introduced by ECMAScript 6, and it includes a built-in iterator so that you don’t have to define the variable and the length value:\n\nYou can use the loop to iterate over any iterable object, such as arrays, strings, nodelists, maps, and more.\n\nThe topic of modularization comes up frequently in discussions of JavaScript best practices. Modularization means the splitting of larger files into smaller parts — a.k.a. reusable modules. ECMAScript modules and module bundlers such as Webpack help with setting up such architecture, but creating modular and reusable functions is just as important.\n\nAs the first SOLID design principle (single responsibility principle) states, every function, interface, class, and other code structure should perform only one task. Creating helper functions for common tasks is one way to follow this principle. Helper functions should be context-independent so that they can be called from any module.\n\nTo see some JavaScript functionality examples, check out The Vanilla JS Toolkit that includes smart helper functions such as , , , , and others. For example, here’s the function — as you can see, it performs one single action:\n\nUsing classes is another hot topic in JavaScript programming. Even though JavaScript has a prototypical inheritance model, ECMAScript 6 has introduced the class syntax to improve code readability. It’s frequently referred to as “syntactic sugar” as it doesn’t add any new functionality, and, as stated by the MDN Docs, classes are “being converted into Prototypal Inheritance models” under the hood.\n\nSo whether you use classes or not mainly depends on your preferences and project requirements — but if you do decide to use the class syntax, there are, of course, some JavaScript best practices to follow.\n\nFirst and foremost, you need to avoid creating irrelevant classes to build a well-structured application. Classes can be irrelevant for a couple of reasons, including:\n• Catch-all classes that do more than one thing (or everything)\n• Classes that only have data (properties) but no actions (methods) — try to move the data into another class\n• Classes that only include behavior (methods) but no data (properties) — in this case, it’s better to create a function\n\nOverall, classes should respect the single responsibility principle (similar to functions) and include both data and behavior, for example:\n\n10. Pay attention to (the lack of) hoisting when using classes\n\nIn JavaScript, classes are a special type of function, but they don’t always behave like ordinary functions, which can lead to some confusion.\n\nFor instance, unlike functions, classes are not hoisted. Hoisting means that the JavaScript interpreter moves function declarations to the top of their scope so that they can be called before being declared. When working with classes, you can’t take advantage of this feature, however.\n\nYou always need to declare a class before you call it, otherwise you’ll get an uncaught reference error. Following the previous example with the class:\n\nThe JavaScript coding practices discussed above can help you write cleaner and better-structured code that’s easier to maintain and debug. However, creating development code is just the first step of the software life cycle.\n\nEven if you’re diligently following these JavaScript best practices, errors can (and will) still occur when your end-users interact with your application. To ensure your users experience your code as intended, you need to detect and address errors in production. With JavaScript error tracking, you can take care of errors on the production side, monitoring your application in real-time, catching errors as they happen, and taking immediate action."
    },
    {
        "link": "https://raygun.com/blog/javascript-best-practices",
        "document": "The world’s biggest language comes with a huge collection of conventions and guidelines from the community’s collective wisdom. Following JavaScript best practices can help achieve faster page loads and better performance, improve code readability, and make maintenance and debugging easier. Carefully crafted code can also prevent errors and security issues, especially if it’s complemented with real-time diagnostic tools such as JavaScript error monitoring.\n\nIn this article, we’ll look into a selection of JavaScript best practices that you can use in frontend development.\n\n1. Choose a JavaScript coding style guide and stick to it\n\nEven though you can set up your own coding guidelines that fit with your goals, you don’t necessarily have to. There are multiple ready-to-use JavaScript coding style guides that are well tested and widely used across the industry. Some examples include the community-based Idiomatic JavaScript, the Google JavaScript Style Guide, and AirBnB’s JavaScript Style Guide.\n\nUsing a coding style guide is especially important in teamwork, where multiple developers are working on the same project. As Idiomatic JavaScript puts it, “all code in any code base should look like a single person typed it, no matter how many people contributed.” Whether you create your own style guide or use a third-party one, consistent code will be easier to read, write, debug, and maintain.\n\nMake the names of your variables, functions, and other code structures easy to understand for anyone who works with your code. Don’t use names that are either too short or too long, and take care that they succinctly describe their own purpose.\n\nSome good examples are (from the DOM API):\n\nAlso keep in mind that JavaScript is a case-sensitive language. As camel case capitalization is the most common naming system in JavaScript programming, you should use lower camelcase for variables and functions and upper camelcase for classes and interfaces for better code readability.\n\n3. Use shorthands, but be careful with them\n\nJavaScript includes many shorthands that allow you to write code faster and make your scripts load faster.\n\nThere are older shorthands that have been part of the JavaScript syntax for ages, such as the shorthand:\n\nAnd of course, there are newer ones, too, such as arrow functions introduced in ECMAScript 6:\n\nSometimes, however, shorthands might return surprising results. So, always be sure of what you’re doing, check the documentation, find relevant JavaScript code examples, and test the outcome.\n\nCommenting is a hot topic in programming. Some say it’s not necessary at all, but code without any comments gets hard to read after a while — especially when working on team or legacy projects. On the other hand, overly long and verbose comments are unnecessary because they’ll take extra time to read through and understand.\n\nAs a rule of thumb, comment your code, especially functions, classes, objects, and interfaces, but only include key information. To keep your comments concise and easy to read, use tags such as , , , , and others.\n\nHere’s an example of a short but descriptive comment from JSDoc’s guidelines:\n\nIf you comment your JavaScript code properly, you can also use a tool such as JSDoc to automatically generate documentation for your project.\n\nTaking separation of concerns (SoC) seriously is one of the most important JavaScript coding practices. Technically, JavaScript allows you to directly change the CSS code using the property. However, to make debugging easier and improve code maintainability, it’s best to avoid it.\n\nAs an alternative, you can add and remove classes using the API as follows (then add the style rules with CSS):\n\nAs global variables are available to all the scripts running on your page, they can easily be overridden by other variables using the same name. There are various ways to reduce the number of global variables, but ECMAScript 6 has introduced two new JavaScript statements you can use to declare variables in the local scope: and .\n\nBoth and create block-scoped local variables, but can be re-declared (in a different scope) while can’t. As opposed to , neither nor becomes a property of the object, so they can’t be accessed, and therefore overridden, by other scripts — even when they are declared globally (in the highest scope).\n\nYou can define with or without a value (however, it can only be read and written after full initialization), but you can’t declare without a value:\n\n7. Use instead of loops\n\nLoops can get costly performance-wise because you repeat the same operation over and over again. However, if you optimize them, you can make them run faster.\n\nThere are many JavaScript best practices to write more performant loops, such as avoiding nesting, keeping DOM manipulation outside of loops, and declaring a separate variable for the length of the loop (e.g. ).\n\nUsing the statement instead of is such a JavaScript coding practice, too. This syntax has been introduced by ECMAScript 6, and it includes a built-in iterator so that you don’t have to define the variable and the length value:\n\nYou can use the loop to iterate over any iterable object, such as arrays, strings, nodelists, maps, and more.\n\nThe topic of modularization comes up frequently in discussions of JavaScript best practices. Modularization means the splitting of larger files into smaller parts — a.k.a. reusable modules. ECMAScript modules and module bundlers such as Webpack help with setting up such architecture, but creating modular and reusable functions is just as important.\n\nAs the first SOLID design principle (single responsibility principle) states, every function, interface, class, and other code structure should perform only one task. Creating helper functions for common tasks is one way to follow this principle. Helper functions should be context-independent so that they can be called from any module.\n\nTo see some JavaScript functionality examples, check out The Vanilla JS Toolkit that includes smart helper functions such as , , , , and others. For example, here’s the function — as you can see, it performs one single action:\n\nUsing classes is another hot topic in JavaScript programming. Even though JavaScript has a prototypical inheritance model, ECMAScript 6 has introduced the class syntax to improve code readability. It’s frequently referred to as “syntactic sugar” as it doesn’t add any new functionality, and, as stated by the MDN Docs, classes are “being converted into Prototypal Inheritance models” under the hood.\n\nSo whether you use classes or not mainly depends on your preferences and project requirements — but if you do decide to use the class syntax, there are, of course, some JavaScript best practices to follow.\n\nFirst and foremost, you need to avoid creating irrelevant classes to build a well-structured application. Classes can be irrelevant for a couple of reasons, including:\n• Catch-all classes that do more than one thing (or everything)\n• Classes that only have data (properties) but no actions (methods) – try to move the data into another class\n• Classes that only include behavior (methods) but no data (properties) – in this case, it’s better to create a function\n\nOverall, classes should respect the single responsibility principle (similar to functions) and include both data and behavior, for example:\n\n10. Pay attention to (the lack of) hoisting when using classes\n\nIn JavaScript, classes are a special type of function, but they don’t always behave like ordinary functions, which can lead to some confusion.\n\nFor instance, unlike functions, classes are not hoisted. Hoisting means that the JavaScript interpreter moves function declarations to the top of their scope so that they can be called before being declared. When working with classes, you can’t take advantage of this feature, however.\n\nYou always need to declare a class before you call it, otherwise you’ll get an uncaught reference error. Following the previous example with the class:\n\nThe JavaScript coding practices discussed above can help you write cleaner and better-structured code that’s easier to maintain and debug. However, creating development code is just the first step of the software life cycle.\n\nEven if you’re diligently following these JavaScript best practices, errors can (and will) still occur when your end-users interact with your application. To ensure your users experience your code as intended, you need to detect and address errors in production. With JavaScript error tracking, you can take care of errors on the production side, monitoring your application in real-time, catching errors as they happen, and taking immediate action."
    },
    {
        "link": "https://dev.to/alaa-samy/clean-code-in-javascript-a-comprehensive-guide-152j",
        "document": "Writing clean code is an essential skill for any developer. Clean code isn't just about making your code work—it's about making it work elegantly, efficiently, and in a way that other developers (including your future self) can easily understand and maintain. In this comprehensive guide, we'll explore the principles and best practices of writing clean JavaScript code.\n\nClean code is code that is:\n• Reusable: Can be repurposed for different scenarios\n• Scalable: Can grow without becoming complex\n\nYour variable names should clearly indicate their purpose and context.\n\n\n\nWhen a value won't change, use instead of or .\n\n\n\nUse consistent naming patterns throughout your codebase.\n\n\n\nUse private fields and methods to protect object data.\n\n\n\nEach function should do exactly one thing.\n\n\n\nFunction names should clearly describe what they do.\n\n\n\n4. Comments: When and How to Use Them\n\nYour code should be clear enough that it doesn't need extensive comments.\n\n\n\nComments should explain \"why\" not \"what\".\n\n\n\nWriting clean code is an ongoing journey of improvement. It's not just about following rules—it's about developing a mindset that values clarity, simplicity, and maintainability. Remember:\n• Write code for humans first, computers second\n• Keep your functions small and focused\n• Use meaningful names for variables and functions\n\nBy following these principles and continuously refining your approach, you'll write code that's not just functional, but truly professional and maintainable."
    },
    {
        "link": "https://dev.to/nozibul_islam_113b1d5334f/the-art-of-clean-code-a-practical-guide-to-writing-maintainable-javascript-1eb9",
        "document": "The Art of Clean Code: A Practical Guide to Writing Maintainable JavaScript.\n\nWriting clean code is more than an aesthetic choice—it's a fundamental practice that reduces bugs, enhances collaboration, and ensures long-term maintainability of software projects. This guide explores the principles, practices, and pragmatic approaches to writing clean JavaScript code.\n\nCode is read far more often than it's written. Good code tells a story that other developers (including your future self) can easily understand.\n\nMaintainable code is modular, follows SOLID principles, and minimizes dependencies.\n\nClean code is inherently testable. Break down complex operations into smaller, verifiable units.\n\nWhile pure functions are ideal, real applications need side effects. Isolate and manage them carefully:\n• Variables should indicate their purpose\n• Each function should do one thing well\n• Aim for no more than 20 lines per function\n• Use named constants for all numeric values\n\nClean code is a journey, not a destination. While perfect cleanliness might be unattainable, striving for clean code through consistent practices and pragmatic trade-offs leads to more maintainable, reliable, and collaborative codebases. Remember that context matters—what's clean in one situation might not be in another. The key is finding the right balance for your specific needs while maintaining code that others (including your future self) will thank you for writing.\n\n🔗 Connect with me on LinkedIn:\n\nLet’s dive deeper into the world of software engineering together! I regularly share insights on JavaScript, TypeScript, Node.js, React, Next.js, data structures, algorithms, web development, and much more. Whether you're looking to enhance your skills or collaborate on exciting topics, I’d love to connect and grow with you."
    },
    {
        "link": "https://quora.com/What-are-some-tips-for-writing-clean-and-maintainable-code-in-JavaScript-for-beginners",
        "document": "Something went wrong. Wait a moment and try again."
    }
]