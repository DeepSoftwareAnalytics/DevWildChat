[
    {
        "link": "https://dlib.net",
        "document": "Dlib is a modern C++ toolkit containing machine learning algorithms and tools for creating complex software in C++ to solve real world problems. It is used in both industry and academia in a wide range of domains including robotics, embedded devices, mobile phones, and large high performance computing environments. Dlib's open source licensing allows you to use it in any application, free of charge.\n\nTo follow or participate in the development of dlib subscribe to dlib on github. Also be sure to read the how to contribute page if you intend to submit code to the project.\n\nTo quickly get started using dlib, follow these instructions to build dlib.\n• Documentation\n• Unlike a lot of open source projects, this one provides complete and precise documentation for every class and function. There are also debugging modes that check the documented preconditions for functions. When this is enabled it will catch the vast majority of bugs caused by calling functions incorrectly or using objects in an incorrect manner.\n• Lots of example programs are provided\n• I consider the documentation to be the most important part of the library. So if you find anything that isn't documented, isn't clear, or has out of date documentation, tell me and I will fix it.\n• High Quality Portable Code\n• Good unit test coverage. The ratio of unit test lines of code to library lines of code is about 1 to 4.\n• The library is tested regularly on MS Windows, Linux, and Mac OS X systems. However, it should work on any POSIX system and has been used on Solaris, HPUX, and the BSDs.\n• No other packages are required to use the library. Only APIs that are provided by an out of the box OS are needed.\n• There is no installation or configure step needed before you can use the library. See the How to compile page for details.\n• All operating system specific code is isolated inside the OS abstraction layers which are kept as small as possible. The rest of the library is either layered on top of the OS abstraction layers or is pure ISO standard C++.\n• Machine Learning Algorithms\n• A tool for solving the optimization problem associated with structural support vector machines.\n• Structural SVM tools for object detection in images as well as more powerful (but slower) deep learning tools for object detection.\n• Numerical Algorithms\n• A fast matrix object implemented using the expression templates technique and capable of using BLAS and LAPACK libraries when available.\n• Numerous linear algebra and mathematical operations are defined for the matrix object such as the singular value decomposition, transpose, trig functions, etc.\n• General purpose unconstrained non-linear optimization algorithms using the conjugate gradient, BFGS, and L-BFGS techniques\n• An implementation of the Optimized Cutting Plane Algorithm\n• Combinatorial optimization tools for solving optimal assignment and min cut/max flow problems as well as the CKY algorithm for finding the most probable parse tree\n• Graphical Model Inference Algorithms\n• Routines for performing MAP inference in chain-structured, Potts, or general factor graphs.\n• Image Processing\n• Common image operations such as edge finding and morphological operations\n• Implementations of the SURF, HOG, and FHOG feature extraction algorithms.\n• Tools for detecting objects in images including frontal face detection and object pose estimation.\n• Threading\n• The library provides a portable and simple threading API\n• A timer object capable of generating events that are regularly spaced in time\n• Networking\n• The library provides a portable and simple TCP sockets API\n• An object to help you make TCP based servers\n• iostream and streambuf objects that enables TCP sockets to interoperate with the C++ iostreams library\n• A simple HTTP server object you can use to embed a web server into your applications\n• A tool used to implement algorithms using the Bulk Synchronous Parallel (BSP) computing model\n• Graphical User Interfaces\n• The library provides a portable and simple core GUI API\n• Implemented on top of the core GUI API are numerous widgets\n• Unlike many other GUI toolkits, the entire dlib GUI toolkit is threadsafe\n• Data Compression and Integrity Algorithms\n• Various abstracted objects representing parts of data compression algorithms. Many forms of the PPM algorithm are included.\n• Testing\n• Various assert macros useful for testing preconditions\n• General Utilities\n• A type-safe object to convert between big and little endian byte orderings\n• A command line parser with the ability to parse and validate command lines with various types of arguments and options\n• An object that can perform base64 conversions\n• Many memory manager objects that implement different memory pooling strategies\n• A tool that lets you easily call C++ from MATLAB"
    },
    {
        "link": "https://dlib.net/face_recognition.py.html",
        "document": "# The contents of this file are in the public domain. See LICENSE_FOR_EXAMPLE_PROGRAMS.txt # This example shows how to use dlib's face recognition tool. This tool maps # an image of a human face to a 128 dimensional vector space where images of # the same person are near to each other and images from different people are # far apart. Therefore, you can perform face recognition by mapping faces to # the 128D space and then checking if their Euclidean distance is small # When using a distance threshold of 0.6, the dlib model obtains an accuracy # of 99.38% on the standard LFW face recognition benchmark, which is # comparable to other state-of-the-art methods for face recognition as of # February 2017. This accuracy means that, when presented with a pair of face # images, the tool will correctly identify if the pair belongs to the same # person or is from different people 99.38% of the time. # Finally, for an in-depth discussion of how dlib's tool works you should # refer to the C++ example program dnn_face_recognition_ex.cpp and the # You can install dlib using the command: # Alternatively, if you want to compile dlib yourself then go into the dlib # Compiling dlib should work on any operating system so long as you have # CMake installed. On Ubuntu, this can be done easily by running the # Also note that this example requires Numpy which can be installed \"Call this program like this: \"You can download a trained facial shape predictor and recognition model from: # Load all the models we need: a detector to find the faces, a shape predictor # to find face landmarks so we can precisely localize the face, and finally the # Now process all the images # Ask the detector to find the bounding boxes of each face. The 1 in the # second argument indicates that we should upsample the image 1 time. This # will make everything bigger and allow us to detect more faces. # Now process each face we found. # Get the landmarks/parts for the face in box d. # Draw the face landmarks on the screen so we can see what face is currently being processed. # Compute the 128D vector that describes the face in img identified by # shape. In general, if two face descriptor vectors have a Euclidean # distance between them less than 0.6 then they are from the same # person, otherwise they are from different people. Here we just print # the vector to the screen. # It should also be noted that you can also call this function like this: # The version of the call without the 100 gets 99.13% accuracy on LFW # while the version with 100 gets 99.38%. However, the 100 makes the # call 100x slower to execute, so choose whatever version you like. To # explain a little, the 3rd argument tells the code how many times to # jitter/resample the image. When you set it to 100 it executes the # the face and returns the average result. You could also pick a more # middle value, such as 10, which is only 10x slower but still gets an # 4th value (0.25) is padding around the face. If padding == 0 then the chip will # be closely cropped around the face. Setting larger padding values will result a looser cropping. # In particular, a padding of 0.5 would double the width of the cropped area, a value of 1. # would triple it, and so forth. # There is another overload of compute_face_descriptor that can take # as an input an aligned image. # Note that it is important to generate the aligned image as # dlib.get_face_chip would do it i.e. the size must be 150x150, # Here is a sample usage of that # Now we simply pass this chip (aligned image) to the api"
    },
    {
        "link": "https://medium.com/@abhishekjainindore24/face-detection-using-opencv-and-dlib-library-in-c-592d9bf269ff",
        "document": "In this blog, we are going to do the following:\n• Face detection on an image and live video using opencv and dlib\n• Saving the image in opencv and dlib\n\nFace detection on an image and live video using opencv and dlib\n\nDownload haarcascade_frontal_face_default.xml from this link and place it in your project directory https://github.com/kipr/opencv/blob/master/data/haarcascades/haarcascade_frontalface_default.xml\n\n#include <opencv2/opencv.hpp>\n\n#include <iostream>\n\n\n\nusing namespace cv;\n\nusing namespace std;\n\n\n\nint main() {\n\n // Load the pre-trained Haar cascade for face detection\n\n CascadeClassifier faceCascade;\n\n faceCascade.load(\"/home/abhishaikjain/Desktop/opencv_in_C++/haarcascade_frontalface_default.xml\");\n\n\n\n // Open the default camera\n\n VideoCapture video(0);\n\n if (!video.isOpened()) {\n\n cout << \"Could not open the video capture device\" << endl;\n\n return -1;\n\n }\n\n\n\n // Process frames from the camera\n\n while (true) {\n\n Mat frame;\n\n video >> frame;\n\n if (frame.empty())\n\n break;\n\n\n\n // Convert the frame to grayscale\n\n Mat gray;\n\n cvtColor(frame, gray, COLOR_BGR2GRAY);\n\n\n\n // Detect faces in the grayscale frame\n\n vector<Rect> faces;\n\n faceCascade.detectMultiScale(gray, faces, 1.1, 3, 0, Size(30, 30));\n\n\n\n // Draw rectangles around the detected faces\n\n for (const Rect& face : faces) {\n\n rectangle(frame, face, Scalar(255, 0, 0), 2); // Blue rectangle, thickness: 2\n\n }\n\n\n\n // Display the frame with detected faces\n\n imshow(\"Face Detection\", frame);\n\n\n\n // Press ESC to exit\n\n if (waitKey(1) == 27)\n\n break;\n\n }\n\n\n\n return 0;\n\n}\n\n#include <opencv2/opencv.hpp>\n\n#include <iostream>\n\n\n\nusing namespace cv;\n\nusing namespace std;\n\n\n\nint main() {\n\n // Load the pre-trained Haar cascade for face detection\n\n CascadeClassifier faceCascade;\n\n faceCascade.load(\"/home/abhishaikjain/Desktop/opencv_in_C++/haarcascade_frontalface_default.xml\");\n\n\n\n // Read the input image\n\n Mat image = imread(\"/home/abhishaikjain/Desktop/opencv_in_C++/picture_of_face.jpeg\");\n\n if (image.empty()) {\n\n cout << \"Could not open or find the image\" << endl;\n\n return -1;\n\n }\n\n\n\n // Convert the image to grayscale\n\n Mat gray;\n\n cvtColor(image, gray, COLOR_BGR2GRAY);\n\n\n\n // Detect faces in the grayscale image\n\n vector<Rect> faces;\n\n faceCascade.detectMultiScale(gray, faces, 1.1, 3, 0, Size(30, 30));\n\n\n\n // Draw rectangles around the detected faces\n\n for (const Rect& face : faces) {\n\n rectangle(image, face, Scalar(255, 0, 0), 2); // Blue rectangle, thickness: 2\n\n }\n\n\n\n // Display the image with detected faces\n\n imshow(\"Detected Faces\", image);\n\n waitKey(0);\n\n\n\n return 0;\n\n}\n\n#include <dlib/image_processing/frontal_face_detector.h>\n\n#include <opencv2/opencv.hpp>\n\n#include <dlib/image_io.h>\n\n#include <iostream>\n\n#include <dlib/gui_widgets/widgets.h>\n\n#include <dlib/image_processing.h>\n\n#include <dlib/opencv.h>\n\n#include <opencv2/highgui/highgui_c.h>\n\n\n\n\n\nusing namespace dlib;\n\nusing namespace cv;\n\nusing namespace std;\n\n\n\nint main() {\n\n try {\n\n VideoCapture video(0);\n\n if (!video.isOpened()) {\n\n cout << \"Could not open the video capture device\" << endl;\n\n return -1;\n\n }\n\n\n\n // Process frames from the camera\n\n while (true) {\n\n Mat frame;\n\n video >> frame;\n\n \n\n IplImage ipl_img = cvIplImage(frame);\n\n dlib::cv_image<dlib::bgr_pixel> cimg(&ipl_img);\n\n\n\n array2d<unsigned char> dlib_img;\n\n assign_image(dlib_img, cimg);\n\n\n\n dlib::frontal_face_detector detector = dlib::get_frontal_face_detector();\n\n\n\n // Detect faces\n\n std::vector<dlib::rectangle> dets = detector(dlib_img);\n\n\n\n // Draw rectangles around detected faces\n\n for (const auto& face : dets) {\n\n cv::rectangle(frame, \n\n cv::Point(face.left(), face.top()), \n\n cv::Point(face.right(), face.bottom()), \n\n cv::Scalar(0, 255, 0), 2); // Green color\n\n }\n\n\n\n // Display the frame with detected faces\n\n cv::imshow(\"Face Detection\", frame);\n\n\n\n // Break the loop on 'q' key press\n\n if (cv::waitKey(30) == 'q') break;\n\n\n\n cout<<\"END OF PROGRAM\"<<endl;\n\n } \n\n }\n\n catch (std::exception& e) {\n\n std::cout << \"Exception: \" << e.what() << std::endl;\n\n }\n\n return 0;\n\n}\n\n4. Face detection in an image using dlib"
    },
    {
        "link": "https://stackoverflow.com/questions/44151673/dlib-shape-predictor-68-face-landmarks-dat-documentation",
        "document": "I'm wondering if there is any documentation about the NOT in terms about \"how to compile\" or \"how to use\" more like how it is set up?, what are the training data (what kind of images, how many, ...)?, who did it? and stuff like this.\n\nI was just able to find a lot code samples that are using the file more or less without questioning :D\n\nI'm using dlib as stated in the headline, but it may be the case that its working with other library's as well?!"
    },
    {
        "link": "https://github.com/davisking/dlib/blob/master/examples/face_landmark_detection_ex.cpp",
        "document": ""
    },
    {
        "link": "https://en.cppreference.com/w/cpp/filesystem",
        "document": "The Filesystem library provides facilities for performing operations on file systems and their components, such as paths, regular files, and directories.\n\nThe filesystem library was originally developed as boost.filesystem, was published as the technical specification ISO/IEC TS 18822:2015, and finally merged to ISO C++ as of C++17. The boost implementation is currently available on more compilers and platforms than the C++17 library.\n\nThe filesystem library facilities may be unavailable if a hierarchical file system is not accessible to the implementation, or if it does not provide the necessary capabilities. Some features may not be available if they are not supported by the underlying file system (e.g. the FAT filesystem lacks symbolic links and forbids multiple hardlinks). In those cases, errors must be reported.\n\nThe behavior is undefined if the calls to functions in this library introduce a file system race, that is, when multiple threads, processes, or computers interleave access and modification to the same object in a file system.\n• file: a file system object that holds data, can be written to, read from, or both. Files have names, attributes, one of which is file type:\n• file name: a string of characters that names a file. Permissible characters, case sensitivity, maximum length, and the disallowed names are implementation-defined. Names (dot) and (dot-dot) have special meaning at library level.\n• path: sequence of elements that identifies a file. It begins with an optional (e.g. or on Windows), followed by an optional (e.g. on Unix), followed by a sequence of zero or more file names (all but last of which have to be directories or links to directories). The native format (e.g. which characters are used as separators) and character encoding of the string representation of a path (the pathname) is implementation-defined, this library provides portable representation of paths.\n\nUsing this library may require additional compiler/linker options. GNU implementation prior to 9.1 requires linking with and LLVM implementation prior to LLVM 9.0 requires linking with ."
    },
    {
        "link": "https://geeksforgeeks.org/file-system-library-in-cpp-17",
        "document": "In this article, we will learn about the File System library in C++17 and with examples. <filesystem> header was added in C++17 and introduces a set of classes, functions, and types that simplify file system operations. In simple words, we can say that the filesystem library provides tools that help us to simplify working with files and directories.\n\nIn earlier versions, performing file and directory operations was often a bulky and mistake-susceptible task as it required the use of platform-specific functions and libraries. The file system library was added to cope with these troubles, offering a portable and standardized way to paint with the file system.\n\nTo use the features of the file system library, we have to import <filesystem> header using #include preprocessor.\n\nAll the identifiers of <filesystem> headers are defined inside the std::filesystem namespace.\n\nThe following are some commonly used classes of file system libraries.\n\nIn this example, we will create a new file in a newly created directory. The parent directory looks like this before execution:\n\nIn this example, a directory is created named “mydirectory”. It checks if the directory exists and creates it if no longer. Sooner or later, a file named “my_file.Txt” is defined within this directory. The code then opens this file for writing using std::ofstream. If a success, it writes the text “Hello, FileSystem!” to the file and closes it. If any errors occur in the directory of the listing or file advent procedure, suitable error messages are displayed.\n\nIn this example, first, we define the directorypath to indicate the target directory. Then we wrote the condition to check if the directory exists or not using fs::exists() and fs::is_directory(). If it exists, it iterates through its contents using a range-based for loop with fs::directory_iterator(), and prints each item’s path to the standard output.\n\nIn this example, first, we define the path for the old file and the new file. Then, wrote a condition to check if the old file exists in the directory or not with fs::exists(), and if it is discovered, then rename it using fs::rename(). A success message will be displayed with the new file path. and if the old file isn’t found, it prints an error message.\n\nLet’s explore some of the key features provided by the <filesystem> library:\n• Path Manipulation: The file system library introduces the std::filesystem::path class to represent file system paths. This class encapsulates the platform-specific path representation and provides an easy way to manipulate and inspect paths.\n• File and Directory Operations: The file system library includes functions to perform common file and directory operations such as creating, removing, renaming, and checking for the existence of files and directories.\n• Error Handling: The <filesystem> library provides exceptions to handle errors during file system operations. You can catch exceptions like std::filesystem::filesystem_error to gracefully handle failures.\n• Portable Code: One of the main advantages of using <filesystem> is the portability it brings to your code. Since it abstracts platform-specific details, you can write code that works consistently across different operating systems."
    },
    {
        "link": "https://stackoverflow.com/questions/67273/how-do-you-iterate-through-every-file-directory-recursively-in-standard-c",
        "document": "How do you iterate through every file/directory recursively in standard C++?\n\nFrom C++17 onward, the header, and range- , you can simply do this: As of C++17, is part of the standard library and can be found in the header (no longer \"experimental\").\n\nIf using the Win32 API you can use the FindFirstFile and FindNextFile functions. For recursive traversal of directories you must inspect each WIN32_FIND_DATA.dwFileAttributes to check if the FILE_ATTRIBUTE_DIRECTORY bit is set. If the bit is set then you can recursively call the function with that directory. Alternatively you can use a stack for providing the same effect of a recursive call but avoiding stack overflow for very long path trees. #include <windows.h> #include <string> #include <vector> #include <stack> #include <iostream> using namespace std; bool ListFiles(wstring path, wstring mask, vector<wstring>& files) { HANDLE hFind = INVALID_HANDLE_VALUE; WIN32_FIND_DATA ffd; wstring spec; stack<wstring> directories; directories.push(path); files.clear(); while (!directories.empty()) { path = directories.top(); spec = path + L\"\\\\\" + mask; directories.pop(); hFind = FindFirstFile(spec.c_str(), &ffd); if (hFind == INVALID_HANDLE_VALUE) { return false; } do { if (wcscmp(ffd.cFileName, L\".\") != 0 && wcscmp(ffd.cFileName, L\"..\") != 0) { if (ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) { directories.push(path + L\"\\\\\" + ffd.cFileName); } else { files.push_back(path + L\"\\\\\" + ffd.cFileName); } } } while (FindNextFile(hFind, &ffd) != 0); if (GetLastError() != ERROR_NO_MORE_FILES) { FindClose(hFind); return false; } FindClose(hFind); hFind = INVALID_HANDLE_VALUE; } return true; } int main(int argc, char* argv[]) { vector<wstring> files; if (ListFiles(L\"F:\\\\cvsrepos\", L\"*\", files)) { for (vector<wstring>::iterator it = files.begin(); it != files.end(); ++it) { wcout << it->c_str() << endl; } } return 0; }\n\nIn addition to the above mentioned boost::filesystem you may want to examine wxWidgets::wxDir and Qt::QDir. Both wxWidgets and Qt are open source, cross platform C++ frameworks. provides a flexible way to traverse files recursively using or a simpler function. As well you can implement the traversal with and functions (I assume that Traverse() and GetAllFiles() are wrappers that eventually use GetFirst() and GetNext() functions). provides access to directory structures and their contents. There are several ways to traverse directories with QDir. You can iterate over the directory contents (including sub-directories) with QDirIterator that was instantiated with QDirIterator::Subdirectories flag. Another way is to use QDir's GetEntryList() function and implement a recursive traversal. Here is sample code (taken from here # Example 8-5) that shows how to iterate over all sub directories.\n\nWe are in 2019. We have filesystem standard library in . The provides facilities for performing operations on file systems and their components, such as paths, regular files, and directories. There is an important note on this link if you are considering portability issues. It says: The filesystem library facilities may be unavailable if a hierarchical file system is not accessible to the implementation, or if it does not provide the necessary capabilities. Some features may not be available if they are not supported by the underlying file system (e.g. the FAT filesystem lacks symbolic links and forbids multiple hardlinks). In those cases, errors must be reported. The filesystem library was originally developed as , was published as the technical specification ISO/IEC TS 18822:2015, and finally merged to ISO C++ as of C++17. The boost implementation is currently available on more compilers and platforms than the C++17 library. @adi-shavit has answered this question when it was part of std::experimental and he has updated this answer in 2017. I want to give more details about the library and show more detailed example. std::filesystem::recursive_directory_iterator is an that iterates over the directory_entry elements of a directory, and, recursively, over the entries of all subdirectories. The iteration order is unspecified, except that each directory entry is visited only once. If you don't want to recursively iterate over the entries of subdirectories, then directory_iterator should be used. Both iterators returns an object of directory_entry. has various useful member functions like , , , etc. The member function returns an object of std::filesystem::path and it can be used to get , , . Consider the example below. I have been using and compiled it over the terminal using\n\nYou would probably be best with either boost or c++14's experimental filesystem stuff. IF you are parsing an internal directory (ie. used for your program to store data after the program was closed), then make an index file that has an index of the file contents. By the way, you probably would need to use boost in the future, so if you don't have it installed, install it! Second of all, you could use a conditional compilation, e.g.: #ifdef WINDOWS //define WINDOWS in your code to compile for windows #endif The code for each case is taken from https://stackoverflow.com/a/67336/7077165 #ifdef POSIX //unix, linux, etc. #include <stdio.h> #include <dirent.h> int listdir(const char *path) { struct dirent *entry; DIR *dp; dp = opendir(path); if (dp == NULL) { perror(\"opendir: Path does not exist or could not be read.\"); return -1; } while ((entry = readdir(dp))) puts(entry->d_name); closedir(dp); return 0; } #endif #ifdef WINDOWS #include <windows.h> #include <string> #include <vector> #include <stack> #include <iostream> using namespace std; bool ListFiles(wstring path, wstring mask, vector<wstring>& files) { HANDLE hFind = INVALID_HANDLE_VALUE; WIN32_FIND_DATA ffd; wstring spec; stack<wstring> directories; directories.push(path); files.clear(); while (!directories.empty()) { path = directories.top(); spec = path + L\"\\\\\" + mask; directories.pop(); hFind = FindFirstFile(spec.c_str(), &ffd); if (hFind == INVALID_HANDLE_VALUE) { return false; } do { if (wcscmp(ffd.cFileName, L\".\") != 0 && wcscmp(ffd.cFileName, L\"..\") != 0) { if (ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) { directories.push(path + L\"\\\\\" + ffd.cFileName); } else { files.push_back(path + L\"\\\\\" + ffd.cFileName); } } } while (FindNextFile(hFind, &ffd) != 0); if (GetLastError() != ERROR_NO_MORE_FILES) { FindClose(hFind); return false; } FindClose(hFind); hFind = INVALID_HANDLE_VALUE; } return true; } #endif //so on and so forth.\n\nYou don't. The C++ standard has no concept of directories. It is up to the implementation to turn a string into a file handle. The contents of that string and what it maps to is OS dependent. Keep in mind that C++ can be used to write that OS, so it gets used at a level where asking how to iterate through a directory is not yet defined (because you are writing the directory management code). Look at your OS API documentation for how to do this. If you need to be portable, you will have to have a bunch of #ifdefs for various OSes.\n\nFile tree walk is a recursive way to wall the whole directory tree in the path. More details are here. NOTE : You can also use that can skip hidden files like or or #include <ftw.h> #include <stdio.h> #include <sys/stat.h> #include <string.h> int list(const char *name, const struct stat *status, int type) { if (type == FTW_NS) { return 0; } if (type == FTW_F) { printf(\"0%3o\\t%s\n\n\", status->st_mode&0777, name); } if (type == FTW_D && strcmp(\".\", name) != 0) { printf(\"0%3o\\t%s/\n\n\", status->st_mode&0777, name); } return 0; } int main(int argc, char *argv[]) { if(argc == 1) { ftw(\".\", list, 1); } else { ftw(argv[1], list, 1); } return 0; } output looks like following: Let us say if you want to match a filename (example: searching for all the files.) for a specific needs, use . #include <ftw.h> #include <stdio.h> #include <sys/stat.h> #include <iostream> #include <fnmatch.h> static const char *filters[] = { \"*.jpg\", \"*.jpeg\", \"*.png\" }; int list(const char *name, const struct stat *status, int type) { if (type == FTW_NS) { return 0; } if (type == FTW_F) { int i; for (i = 0; i < sizeof(filters) / sizeof(filters[0]); i++) { /* if the filename matches the filter, */ if (fnmatch(filters[i], name, FNM_CASEFOLD) == 0) { printf(\"0%3o\\t%s\n\n\", status->st_mode&0777, name); break; } } } if (type == FTW_D && strcmp(\".\", name) != 0) { //printf(\"0%3o\\t%s/\n\n\", status->st_mode&0777, name); } return 0; } int main(int argc, char *argv[]) { if(argc == 1) { ftw(\".\", list, 1); } else { ftw(argv[1], list, 1); } return 0; }"
    },
    {
        "link": "https://learn.microsoft.com/en-us/cpp/standard-library/filesystem?view=msvc-170",
        "document": "Include the header for access to classes and functions that manipulate and retrieve information about paths, files, and directories.\n\nAt the release of Visual Studio 2017, the header was not yet a C++ standard. C++ in Visual Studio 2017 RTW implements the final draft standard, found in ISO/IEC JTC 1/SC 22/WG 21 N4100. Visual Studio 2017 version 15.7 and later supports the new C++17 standard. This is a completely new implementation, incompatible with the previous version. It was made necessary by symlink support, bug fixes, and changes in standard-required behavior. In Visual Studio 2019 version 16.3 and later, including provides only the new . Including provides only the old experimental implementation. The experimental implementation will be removed in the next ABI-breaking release of the libraries.\n\nThis header supports file systems for one of two broad classes of host operating systems: Microsoft Windows and POSIX.\n\nWhile most functionality is common to both operating systems, this document identifies where differences occur. For example:\n• None Windows supports multiple root names, such as or . A file system consists of a forest of trees, each with its own root directory, such as or , and each with its own current directory, for completing a relative pathname (one that's not an absolute pathname).\n• None POSIX supports a single tree, with no root name, the single root directory , and a single current directory.\n\nAnother significant difference is the native representation of pathnames:\n• None Windows uses a null-terminated sequence of , encoded as UTF-16 (one or more elements for each character).\n• None POSIX uses a null-terminated sequence of , encoded as UTF-8 (one or more elements for each character).\n• None An object of class stores the pathname in native form, but supports easy conversion between this stored form and several external forms:\n• None A null-terminated sequence of , encoded as favored by the operating system.\n• None A null-terminated sequence of , encoded as favored by the operating system. Interconversions between these representations are mediated, as needed, by the use of one or more facets. If no specific locale object is specified, these facets are obtained from the global locale.\n\nAnother difference is the detail with which each operating system lets you specify file or directory access permissions:\n• None Windows records whether a file is read-only or writable, an attribute that has no meaning for directories.\n• None POSIX records whether a file can be read, written, or executed (scanned, if a directory). And, whether each operation is allowed for the owner, the owner's group, or for everybody, plus a few other permissions.\n\nCommon to both systems is the structure imposed on a pathname once you get past the root name. For the pathname :\n• None The root name is .\n\nA minor difference is the preferred separator between the sequence of directories in a pathname. Both operating systems let you write a forward slash , but in some contexts Windows prefers a backslash . The implementation stores its preferred separator in the data member in .\n\nFinally, objects have an important feature: You can use them wherever a filename argument is required in the classes defined in the header .\n\nFor more information and code examples, see File system navigation (C++)."
    },
    {
        "link": "https://en.cppreference.com/w/cpp/filesystem/directory_iterator",
        "document": "is a LegacyInputIterator that iterates over the elements of a directory (but does not visit the subdirectories). The iteration order is unspecified, except that each directory entry is visited only once. The special pathnames dot and dot-dot are skipped.\n\nIf the reports an error or is advanced past the last directory entry, it becomes equal to the default-constructed iterator, also known as the end iterator. Two end iterators are always equal, dereferencing or incrementing the end iterator is undefined behavior.\n\nIf a file or a directory is deleted or added to the directory tree after the directory iterator has been created, it is unspecified whether the change would be observed through the iterator.\n\nAdditionally, and are(until C++20) is(since C++20) provided as required by LegacyInputIterator.\n\nIt is unspecified whether is provided because it can be synthesized from , and(since C++20) whether an equality operator is a member or non-member.\n\nThese specializations for make it a and a .\n\nMany low-level OS APIs for directory traversal retrieve file attributes along with the next directory entry. The constructors and the non-const member functions of std::filesystem::directory_iterator store these attributes, if any, in the pointed-to std::filesystem::directory_entry without calling , which makes it possible to examine the attributes of the directory entries as they are being iterated over, without making additional system calls.\n\nThe following behavior-changing defect reports were applied retroactively to previously published C++ standards."
    }
]