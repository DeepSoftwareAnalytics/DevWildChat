[
    {
        "link": "https://docs.amd.com/r/en-US/ug585-zynq-7000-SoC-TRM/Memory-Management-Unit-MMU",
        "document": ""
    },
    {
        "link": "https://documentation-service.arm.com/static/64d5f38f4a92140bb31d7f03?token=",
        "document": "%PDF-1.4 %���� 1 0 obj << /Title (Learn the architecture - AArch64 memory management examples) /Author (Arm Ltd.) /Subject (In this guide, learn what Memory Management Unit \\(MMU\\) is and certain examples which can be applied.) /Keywords (1bd84ff, Learn the architecture) /Creator (Arm DITA Open Toolkit v1.0.17) /Producer (Apache FOP Version 2.7) /CreationDate (D:20230811082736Z) >> endobj 2 0 obj << /N 3 /Length 3 0 R /Filter /FlateDecode >> stream x��gPTY��{� �M���I��$�$A��@w�i��AQdpFI� ���AFQŀ((��N#��2�\"**K�٭���U[�g��x�sO�s�[����1������M��:�1��C� H�( �JN���� �!���c ����sϑ��>��qy�v�y����%��. ��ʱlN2k�w�r4;�-�� 8=%1 �{�i��W�-��o�!�o\\�V��k��� ���Z�kL�0+�� �t�j� +���|iA/�o3���`?�(��O��f+�y�S/T�����7����o��r�L@�ʿr��`� Q�WN� �= t����8@W) ��X���o9��� Ȁ��"
    },
    {
        "link": "https://github.com/ARM-software/u-boot",
        "document": ""
    },
    {
        "link": "https://lowenware.com/blog/aarch64-mmu-programming",
        "document": "MMU stands for Memory Management Unit and it is responsible for virtual memory address translation and memory access control. Being one of the most important subjects of the OS development, it could be at the same time very confusing. In this post I will try to clear out MMU programming process.\n\nI've just merged the commit containing MMU support implementation into master branch of LeOS repository. This post is not supposed to be a step by step tutorial, but more a developer's guide. So if you are looking for the code, go straight to GitHub.\n\nLet's start from the beginning of the boot process of application from previous post. It was compiled for the entry point at address. This exact address comes from the design of QEMU virtual device:\n• is an area of memory mapped peripherals. Using addresses from this range you can access registers of multiple peripherals to configure and control them, just as we used output register located at of UART to output a text string to the terminal.\n\nInitial address, where your kernel will be loaded depends on the bootloader implementation and if you are using existing hardware or emulator, then most likely you will deal with existing bootloader, that will load your kernel file at some predefined address.\n\nAlso for some bootloaders you will have to use stripped binary instead of an ELF file, so there will be no information about the entry point address for your specific kernel at all. Being loaded somewhere in the memory, your kernel will still work and even some branch operations could be successfully performed, until you need to access or perform a long jump to an absolute address. If your kernel was compiled for the entry point matching the load address, it will work, otherwise behavior is undefined. This problem could be completely solved by using of the MMU.\n\nSo instead of having separate Kernel builds of each bootloader, we do following:\n• Choose a virtual address that will be set as an entry point for the Kernel at compilation stage. For LeOS kernel I've chosen . Later I will explain why.\n• As a first instruction of the Kernel code, save current address in some register that will be kept untouched for a while:\n• Perform a long jump to an entry function of the Kernel, in case of .\n\nWhat you also may want to do is to map mentioned above peripherals memory area, that differs from SoC to SoC to a fixed virtual address. For LeOS it is set to be .\n• MMU checks if highest 63..37 bits of the address are all set to 1 or to 0. In the first case, MMU will continue lookup using register and in the second case with . Difference between them will be explained later.\n• From chosen register MMU gets real memory address of the so called translation table L1. That table is just an array of 512 descriptors 8 bytes long each.\n• MMU uses bits 36..30 of the address as an index of the descriptor from L1 table. For the example address it is index 64. The 64th descriptor of the L1 contain address of L2 translation table.\n• MMU uses bits 29..21 as a descriptor's index of L2 table, which is 0 for the example. That descriptor contains an address of the last L3 translation table.\n• And bits 20..12 of the address are used by MMU as an index of a descriptor inside L3 translation table. For the example it is also 0. That descriptor contains an address of target 4KB memory page.\n• As a last step of the translation, MMU takes first 12 bits of the address as an offset inside target memory page. For the address the offset would be 0x278 = 632 bytes.\n\nFor complete overview, here is a format of translation table descriptor for this case:\n\nLong story short, for security. MMU allows to build independent isolated virtual address spaces. Each process inside the operating system can run in his own address space, thinking he is alone in the memory, without any possibility of access to code or data of other processes. In fact the process could be allocated at any address of physical memory and even be fragmented.\n\nBy splitting memory into pages, MMU allows to specify special attributes for each page in the descriptors inside translation tables. Using these attributes OS can control write and execute permissions, priviliged access, cache options and even OS itself specific features.\n\nAArch64 MMU comes with separate translation table base registers for specific exception levels. It allows, for example, always to keep Kernel address space loaded inside register, keeping its cache always valid even during context switching, that will affect only user space, by reloading of .\n\nAddress translation example from above is not comprehensive. There are various options that developer can choose between and the choice can significantly change the behavior of MMU, so it is important to understand them all.\n• Configuration of the MMU is done by Exception Level specific translation control register. EL1 exception level is supposed to be used by a Kernel, while EL0 as a less privileged, for user applications. There are also EL2 and EL3 for virtualization and hypervisor. From here I will speak mainly about EL1, but keep in mind there are other exception levels too.\n• AArch64 splits address space into lower and higher half giving possibility to configure them separately. Registers and their properties for lower half part are marked with 0: , , while higher half ones are marked with 1: , .\n• Translation Granule is the size of a page - a minimal memory area that could be mapped. It is controlled by and fields of register and can be 4KB, 16KB or 64KB. A change of the translation granule changes everything: size of page, so size of translation table too, so number of address bits treated as indexes, so number of translation levels and size of output address inside the descriptor.\n• Size of address space is also configurable by and fields of register. Value inside the fields represents number of higher bits excluded from translation process. These bits must be all 1 or all 0 in dependency of address space half. If you scroll up to address translation example, you may see that for index of L1 table only 7 bits are used, while for other tables there are 9. It is because is set to 27. It also removes one extra translation level L0 as unnecessary, because address space is limited by bits, which still allows to address up to 128GB of RAM, that is 8 times higher than I have on my current workstation. Worth to mention, that number of translation levels affects speed of translation process.\n• Descriptor validity is controlled by zero bit of descriptor in translation table. If the bit is set to 1, descriptor is valid and MMU will use the descriptor for translation. If the bit is set to 0, MMU will trigger an Exception and OS can handle it in some way, by memory allocation or termination of the process that tried to access wrong memory address.\n• Block mapping is another option of descriptors in translation tables. It is controlled by first bit of the descriptor, defining, how MMU should treat target address: as address of next translation table or as target address. This feature allows to map larger areas of memory than page size defined by translation granule. For 4KB granule it is possible to map blocks of and , which is very useful on practice.\n• OS can controll access to memory pages and blocks by field of the descriptor, marking some pages as and explicitly allowing or closing access from unprivileged .\n• AArch64 also provides 2 **Memory Attribute Indirection Registers (MAIR) for flexible configuration of memory areas. You can think about MAIRs as of an array with 8 elements each of 8 bits long. You can store inside MAIRs up to 8 attributes sets and reffer them by the index 0..7 stored in field of the descriptor.\n\nFor small applications 4KB size is a good choice and as an adept of simple kernels, I would also recommend it for a kernel. But most important is to focus only on one case if you are just starting with MMU programming, because otherwise it could produce unwanted mess in your head, so keep it simple.\n\nIt is enough to start with just one translation table and with just one descriptor stored inside, that will map, for example, 1GB of RAM, covering all the area of your kernel or even all available memory. Translation process is hard to debug, so as less places where you can make a mistake, as easier it will be to find where is the problem.\n\nIdentity is way of memory mapping when your virtual addresses map to the same addresses of physical memory. It is not a good practice in general, because it is less secure and more confusing on complex systems, but for the beginning it is absolutely normal and even necessary thing to do.\n\nIt is necessary because after you enable MMU, link register of the CPU will point to next instruction by real physical address and in case if there is no identity mapping, MMU will trigger an exception. Handling this exception could be a solution, but probably it is not a way for proof-of-concept application.\n\nConfigure your memory block in the descriptor as executable and writeable for all exception levels, initialize with value (normal memory) and reffer it as .\n\nWhen you got your translation for identity mapping working, try add next level of translation. When it is ready add next, until you reach the final level for your granule size.\n\nWhen you have all translation levels, you can configure differently pages for code, read-only data and normal data. Write attempt to read-only memory will trigger an Exception and you should easily notice it in your debugger.\n\nIt is a common practice to map kernel at higher half and applications at lower half. It helps to isolate kernel from user applications and even simplify life of the developer a bit, because by the address of some value or instruction you can easily guess where did the error or exception happen.\n\nDebugger, pencil and a sheet paper are your best friends. It is useful to draw a scheme like one above for your granule size and pretend you are an MMU and just follow each step of translation. I was also writing down addresses of some instructions to manualy put breakpoints in GDB after I did changes to the code.\n• If you changed values of these fields, you have also updated linker script with actual entry point for your kernel\n\nI hope it was useful. I have found several code examples of MMU programming, some of them were even working out of the box. But when I tried to make it on my own, I have faced many issues and it was hard to find practical tips on what to do, so I decided to gather them all in one place and maybe describe everything from another side, so reader can have better overview of the techniques.\n\nIf you have any question regarding MMU, feel free to leave a comment bellow, I would be glad to help. Also let me know if I have missed something or you would like to have more information on subject in format of text or video."
    },
    {
        "link": "https://stackoverflow.com/questions/26016361/linux-page-table-management-and-mmu",
        "document": "The OS and MMU page management responsibilities are 2 sides of the same mechanism, that lives on the boundary between architecture and micro-architecture.\n\nThe first side defines the \"contract\" between the hardware and the software that runs over it (in this case - the OS) - if you want to use virtual memory, you need build and maintain a page table as described in that contract. The MMU side, on the other hand, is a hardware unit that's responsible for performing the HW tasks of the address translation. This may or may not include hardware optimizations, these are usually hidden and may be implemented in various ways to run under the hood, as long as it maintains the hardware side of the contract.\n\nIn theory, the MMU may decide to issue a set of memory accesses for each translation (a page walk), in order to achieve the required behavior. However, since it's a performance critical element, most MMUs optimize this by caching the results of previous page walks inside the TLB, just like a cache stores the results of previous accesses (actually, on some implementations, the caches themselves may also store some of the accesses to the page table since it usually resides in cacheable memory). The MMU can manage multiple TLBs (most implementations separate the ones for data and code pages, and some have 2nd level TLBs), and provide the translation from there without you noticing that except for the faster access time.\n\nIt should also be noted that the hardware must guard against many corner cases that can harm the coherency of such TLB \"caching\" of previous translations, for example page aliasing or remaps during usage. On some machines, the nastier cases even require a massive flush flow called TLB shootdown."
    },
    {
        "link": "https://stackoverflow.com/questions/25152073/does-armv7-u-boot-use-mmu",
        "document": "We are using a Beaglebone black based custom board. I edited a linker script file to add section of memory to log some information there:\n\nI defined the array in the C file as follows:\n\nNow if I print address, it outputs , but when I check the file, I see is at the address .\n\nIs u-boot using MMU? As far as I know it's turned off in the assembly-written startup code. When I try to use in the code by defining it as , u-boot code compilation breaks and throws the error:\n\nWhen I search for this error I get some patch which says \"ensure u-boot only uses relative relocations\". What does this mean?"
    },
    {
        "link": "https://github.com/u-boot/u-boot/blob/master/doc/arch/arm64.rst",
        "document": "The initial arm64 U-Boot port was developed before hardware was available, so the first supported platforms were the Foundation and Fast Model for ARMv8. These days U-Boot runs on a variety of 64-bit capable ARM hardware, from embedded development boards to servers.\n• U-Boot can run at any exception level it is entered in, it is recommened to enter it in EL3 if U-Boot takes some responsibilities of a classical firmware (like initial hardware setup, CPU errata workarounds or SMP bringup). U-Boot can be entered in EL2 when its main purpose is that of a boot loader. It can drop to lower exception levels before entering the OS. For ARMv8-R it is recommened to enter at S-EL1, as for this architecture there is no S-EL3.\n• U-Boot for arm64 is compiled with AArch64-gcc. AArch64-gcc use rela relocation format, a tool(tools/relocate-rela) by Scott Wood is used to encode the initial addend of rela to u-boot.bin. After running, the U-Boot will be relocated to destination again.\n• Earlier Linux kernel versions required the FDT to be placed at a 2 MB boundary and within the same 512 MB section as the kernel image, resulting in fdt_high to be defined specially. Since kernel version 4.2 Linux is more relaxed about the DT location, so it can be placed anywhere in memory. Please reference linux/Documentation/arm64/booting.txt for detail.\n• Spin-table is used to wake up secondary processors. One location (or per processor location) is defined to hold the kernel entry point for secondary processors. It must be ensured that the location is accessible and zero immediately after secondary processor enter slave_cpu branch execution in start.S. The location address is encoded in cpu node of DTS. Linux kernel store the entry point of secondary processors to it and send event to wakeup secondary processors. Please reference linux/Documentation/arm64/booting.txt for detail.\n• CONFIG_ARM64 instead of CONFIG_ARMV8 is used to distinguish aarch64 and aarch32 specific codes.\n\nU-Boot uses a simple page table for MMU setup. It uses the smallest number of bits possible for the virtual address based on the maximum memory address (see the logic in ). If this is less than 39 bits, the MMU will use only 3 levels for address translation.\n\nAs with all platforms, U-Boot on ARM64 uses a 1:1 mapping of virtual to physical addresses. In general, the memory map is expected to remain static once the MMU is enabled.\n\nIt is possible to debug the pagetable generated by U-Boot with the built in and functions (the former being a simple wrapper for the latter). For example the following can be added to after the first call to :\n\nThe pagetable walker can be used as follows:\n\nThis will result in a print like the following:\n\nFor more information, please refer to the additional function documentation in ."
    },
    {
        "link": "https://stackoverflow.com/questions/21262014/arm-bootloader-disable-mmu-and-caches",
        "document": "Last question is why D-cache is disabled but I-caches is able? To speed up instrument process?\n\nThe MMU has settings to determine which memory regions are cacheable or not. If you do not have the mmu on but you have the data cache on (if possible) then you cannot safely talk to peripherals. if you read the uart status register for example that goes through the cache just like any other data operation, whatever that status is stays in the cache for subsequent reads until such time as that cache line is evicted and you get one more shot at the actual register. Lets say for example you have some code that polls the uart status register waiting for a character in the rx buffer. If that first read shows there is no character, that status goes in the cache, you will remain in the loop forever since you will never get to talk to the status register again you will simply get the cached copy of the register. if there was a character in there then that status also gets cached, you read the rx register, and perhaps do something, if when you come back again if the status has not been evicted from the data cache then you get the stale status which shows there is a character, you rx buffer read may or may not also be cached so you may get the stale value in the cache, you may get a stale value or whatever the peripheral does when you read and there is no new value or you might get a new value, but what you dont get in these situations is proper access to the peripheral. When the mmu is on, you use the mmu to mark the address space used by that peripheral as non-(data)-cacheable, and you dont have this problem. With the mmu off you need the data cache off for arm systems.\n\nLeaving the I-cache on is okay because instruction fetches only read instructions...Well for a bare metal application that is okay, it helps for example if you are using a flash that has a potential for read disturb (spi or i2c flashes). The problem is this application is a bootloader, so you must take some extra care. For example your bootloader has some code at address 0x8000 that it runs through at least once, then you choose to use it as a bootloader, the bootloader might be at say address 0x10000000 allowing you to load a new program at 0x8000, this load uses data accesses so it does not go through the instruction cache. So there is a potential that the instruction cache has some or all of the code from the last time you were in the 0x8000 area, and when you branch to the bootloaded code at 0x8000 you will get either the old program from cache or a nasty mixture of old program and new program for the parts that are cached and not cached. So if your bootloader allows for the i-cache to be on, you need to invalidate the cache before branching to bootloaded code.\n\nLastly, if you or anyone using this bootloader wants to use jtag, then you have that same problem but worse, data cycles that do not go through the i-cache are used to write the new program to ram, when you tell the jtag debugger to then run the new program you will get 1) only the new program, 2) a mixture of the new program and old program fragments from cache 3) the old program from cache.\n\nSo d-cache is bad without an mmu because of things that are not in ram, peripherals, etc. The i-cache is a use at your own risk kind of thing which you can mitigate except for the times that jtag is used for debugging.\n\nIf you have concerns or have confirmed read-disturb in your (external) flash, then I recommend turn on the i-cache, use a tight loop to copy your application to ram, branch to the ram copy and run there, turn off the i-cache (or use at your own risk) and dont touch the flash again, certainly not heavy read accesses to small areas. A tight uart polling loop like you might have for a command line parser, is a really good place to get hit with read-disturb."
    },
    {
        "link": "https://wiki.st.com/stm32mpu/wiki/How_to_configure_U-Boot_for_your_board",
        "document": "This page explains how to configure the U-Boot source for your board.\n\nMany existing ressources [1] [2] explain the porting of U-Boot on a new board. This article only provides basic guidelines for STM32 Arm® Cortex® MPUs .\n\nTo summarize, you need to configure U-Boot for your <VENDOR> <BOARD> with the following steps:\n\nAdd the board device tree files <board>.dts and <board>-u-boot.dtsi in arch/arm/dts , following the steps below:\n• Copy the Linux kernel device tree in the directory arch/arm/dts : .dts.\n• Add a U-Boot addon device tree for your board in the arch/arm/dts directory: -u-boot.dtsi\n\nThis file is automatically included during .dts processing.\n\nIt includes the <STM32MP series>-u-boot.dtsi file provided by STMicroelectronics in arch/arm/dts/ (stm32mp13-u-boot.dtsi , stm32mp15-scmi-u-boot.dtsi , stm32mp25-u-boot.dtsi ) and add all the properties on nodes needed by U-Boot (added nodes, config nodes and bootph-all or bootph-pre-ram attributes as described in U-Boot overview, device tree).\n\nAt this point you can use the generic STM32 MPU defconfig with the STMicroelectronics board directory, but with your board device tree.\n\nThe board-specific features are not correctly managed, but should be sufficient for a simple board derived from STMicroelectronics designs.\n\nYou can use the STMicroelectronics code with your device tree as follows:\n\nThe next steps are required if the STMicroelectronics generic board does not comply with all of the expected behavioral aspects for your board (for example MAC address not located in OTP, specific PMIC, specific boot command).\n\nThe U-Boot console use defined in the node of the Linux kernel device tree as described in the Linux kernel binding[3].\n\nAs the console is used before relocation, you must add the flags bootph-all for each associated nodes (and sub-nodes).\n\nFor example in device tree from kernel = <board>.dts:\n\nAnd in the U-Boot add-on file = <board>-u-boot.dtsi:\n\nThe variable baudrate, initialized with CONFIG_BAUDRATE value, is used to configure the desired baud rate; the default value is 115200 bauds.\n\nAn early DEBUG trace, before the device tree parsing, can be also activated with CONFIG_DEBUG_UART and board_debug_uart_init() (see U-Boot-How to debug page for details).\n\nSome properties in the 'config' node are also used to dynamically configure the U-Boot behavior in the board device tree as follows:\n• Generic U-Boot configuration: doc/device-tree-bindings/config.txt\n• = name of partition used to save U-Boot environment\n• = name of error indicator LED (only for STM32MP1 series)\n• Some STMicroelectronics properties only for STM32MP1 series, managed in board/st/stm32mp1/stm32mp1.c :\n• = GPIO used to force Android Fastboot mode only\n\nThese parameters are managed in U-Boot generic code or in STMicroelectronics board code (board/st/stm32mp1/stm32mp1.c or board/st/stm32mp2/stm32mp2.c ) in line with LEDs and buttons on STM32 MPU boards; they can only be used if your board reuses the associated code.\n\nE.g for STM32MP15x lines , in arch/arm/dts/stm32mp157a-dk1-u-boot.dtsi , the properties are:\n\nThe U-Boot drivers for USB OTG internal peripheral, with the compatible st,stm32mp15-hsotg, does not have a full OTG support with USB host and USB device detection; to avoid issue only the gadget driver is used in STM32 MPU boards with drivers/usb/gadget/dwc2_udc_otg.c activated by CONFIG_USB_GADGET_DWC2_OTG; the host driver drivers/usb/host/dwc2.c is not activated with CONFIG_USB_DWC2.\n\nTwo methods exist to support USB OTG in U-Boot device tree:\n• Two U-Boot specific properties are added to support the possible USB connection of ID pin and VBUS on the board (method used in ecosystem release ≤ v5.1.0 ):\n• : This property forces USB B session (by deactivating the detection with ID pin) and deactivates VBus sensing. It is used when all these features are managed by the board.\n• : This property forces Vbus sensing when u-boot,force-b-session-valid is used (typically when the ID pin is not correctly managed).\n• Alternately the generic USB properties can be used to force the usb role switch (recommended on STM32MP21x lines )\n• : Add usb-role-switch property to OTG controller node, it indicates that the device is capable of assigning the USB data role (USB host or USB device).\n• : Add role-switch-default-mode = \"host\" or \"peripheral\" according to dr_mode, it forces corresponding valid session in OTG driver\n\nSee Linux Generic USB OTG Controller binding file (Documentation/devicetree/bindings/usb/usb-drd.yaml ) for USB properties description such as dr_mode, usb-role-switch, role-switch-default-mode...\n• B session forced as device mode, USB ID pin not used and VBus sensing deactivated:\n• B session and VBus sensing forced (deactived by default with \"force-b-session-valid\")\n\nThe U-Boot drivers for the USB3DR internal peripheral, with the st,stm32mp25-dwc3 compatible, only supports the peripheral mode. E.g. only the gadget driver (drivers/usb/dwc3/gadget.c ) is used in STM32 MPU boards. It is activated by CONFIG_USB_DWC3_GADGET. Full Dual-Role support with automatic USB host and USB device detection isn't supported.\n\nCreate your own board support subdirectory = board/<vendor>/<board> and add a Makefile file.\n\nYou can add any source files needed for your board.\n\nIn this Makefile, you can compile the STMicroelectronics files (in board/st/stm32mp1 or in board/st/common) or just copy them as starting point then modify them.\n\nFor example board/dhelectronics/dh_stm32mp1/Makefile uses STMicroelectronics board files in ../../st/stm32mp1 directory and local file \"board.c\"\n\nYou need to support your board in Kconfig with a new configuration flag: TARGET_<VENDOR>_<BOARD>\n\nThis flag will replace the flags for STMicroelectronics boards support TARGET_ST_<BOARD> used in our defconfig.\n• Add new CONFIG_TARGET_ _ and for this new option, select the required CONFIG_\n• Include your board Kconfig (source \"board/ / /Kconfig\") in the SoC Konfig file\n\nWith the minal SoC options CONFIG to select and Kconfig file to modified :\n\nE.g for STM32MP15x lines , the file arch/arm/mach-stm32mp/Kconfig.15x is modified:\n\nThe mininimal content of this file is:\n\nFor example see board/dhelectronics/dh_stm32mp1/Kconfig .\n\nAdd a new defconfig for your board in configs .\n• copy the correct defconfig to your \" _ _defconfig\" (configs/stm32mp13_defconfig , configs/stm32mp15_defconfig , configs/stm32mp25_defconfig )\n• use to change your defconfig\n• change CONFIG_DEFAULT_DEVICE_TREE to the name of the board device tree: \" \"\n• verify and copy the file \"defconfig\" in configs/ _ _defconfig\n\nFor example see the file configs/stm32mp15_dhcom_basic_defconfig .\n\nThe configuration file is the include file in include/configs directory selected in Makefile.autoconf by CONFIG_SYS_CONFIG_NAME.\n\nThis file defines the CONFIG_ flags of the boards that are not defined with Kconfig.\n\nFor example, in this configuration file, you can choose the initial U-Boot environment through CONFIG_EXTRA_ENV_SETTINGS, including the boot command.\n\nA generic configuration file is provided for each family:\n\nFor STMicroelectronics boards in OpenSTLinux, some configuration (bootcmd) are modified with CONFIG_SYS_CONFIG_NAME =\n• STM32MP13x lines : and the configuration file is include/configs/stm32mp13_st_common.h\n• STM32MP15x lines : and the configuration file is include/configs/stm32mp15_st_common.h\n• STM32MP21x lines : and the configuration file is include/configs/stm32mp25_st_common.h\n• STM32MP23x lines : and the configuration file is include/configs/stm32mp25_st_common.h\n• STM32MP25x lines : and the configuration file is include/configs/stm32mp25_st_common.h\n\nThese STMicroelectronics configuration files can be:\n• either used in your project without modification through = a file in the list:\n• included in your board configuration file (e.g. #include \" \") before to override them or\n• used a starting point for your configuration file (copy and update it).\n\nIn U-Boot, all the mtd fixed partitions are managed in U-Boot device tree based on the binding defined in Linux kernel file Documentation/devicetree/bindings/mtd/partitions/fixed-partitions.yaml .\n\nFor example in arch/arm/dts/stm32mp157c-ev1-u-boot.dtsi with:\n\nThe customer can modify the MTD in U-Boot device tree for its board.\n\nU-Boot dynamically update the Linux® kernel device tree with these information with call fdt_copy_fixed_partitions() under CONFIG_OF_BOARD_SETUP in ft_board_setup() in board/st/stm32mp1/stm32mp1.c or board/st/stm32mp2/stm32mp2.c .\n\nThis device tree update enables the alignment of MTD configuration between U-Boot and Linux, and avoids STM32CubeProgrammer support issues as the MTD partition sizes has to be aligned with Flashlayout.\n\nTo define the MTD partitions in Linux device tree, no more call fdt_copy_fixed_partitions() in your board code or deactivate CONFIG_OF_BOARD_SETUP in the customer defconfig. However this might result in misalignment with U-Boot.\n\nFor information, you can also define the MTD configuration directly through this U-Boot configuration\n• or by directly setting variable in your board configuration file:\n\nThis corresponds to a generic U-Boot configuration (see U-Boot documentation for additional details).\n\nThe memory used by U-Boot is defined by several configurations.\n• : Load Address of U-Boot, aligned with TF-A configuration (see in TF-A FW config)\n\nFor STM32MP1 series, the beginning of the DDR is mapped, limited by CONFIG_DDR_CACHEABLE_SIZE to avoid overlapping with OP-TEE reserved memory, and used by U-Boot.\n\nFor STM32MP2 series, the beginning of the DDR, before CONFIG_TEXT_BASE is NOT mapped, this memory is secured by OP-TEE and used by the secured world of the co-processor.\n\nIf you change the default configurations in your board defconfig file, you need to avoid overlap, particularly for stack and OP-TEE. The default values, used for STMicroelectronics boards, are defined:\n• for STM32MP13x lines , in arch/arm/mach-stm32mp/Kconfig.13x or in defconfig file :\n• for STM32MP15x lines , in arch/arm/mach-stm32mp/Kconfig.15x or in defconfig file :\n• for STM32MP21x lines , in arch/arm/mach-stm32mp/Kconfig.21x or in defconfig file \n\nfor STM32MP23x lines , in arch/arm/mach-stm32mp/Kconfig.23x or in defconfig file \n\nfor STM32MP25x lines , in arch/arm/mach-stm32mp/Kconfig.25x or in defconfig file :\n\nU-Boot is reloaded at the end of the DDR, where it found enough available memory to its code and other reserved memory in common/board_r.c , e.g CONFIG_SYS_MALLOC_LEN and framebuffer.\n\nThis relocation address can be checked with command in U-Boot console.\n\nThe DDR size is retrieved by U-Boot:\n• for STM32MP1 series, from DDRCTRL configuration with ADDRMAP1-6 registers in RAM driver (see stm32mp1_ddr_size() in drivers/ram/stm32mp1/stm32mp1_ram.c )\n• for STM32MP2 series, without RAM driver, from the device tree\n\nThe reserved-memory nodes present in its device tree are preserved by U-Boot (see board_get_usable_ram_top() in arch/arm/mach-stm32mp/dram_init.c ).\n\nTo avoid U-Boot violation access, the secure memory used OP-TEE needs to be aligned with OP-TEE reserved memory nodes in U-Boot device tree for your board device tree, for example arch/arm/dts/stm32mp135f-dk.dts :\n\nThe beginning of DDR is used by U-Boot commands (bootm or booti for example) and scripts (DISTRO) as defined with variables in U-Boot environment or config:\n• = , used by some U-Boot commands.\n• = , used by some U-Boot commands.\n• = , used by booti command during decompression of Image.gz\n• = , used by booti command, max size of Image.gz\n• = , load address of Image / Image.gz and address of decompressed image\n\nThese default values, define in generic configuration files, allow to load 32MB (for STM32MP1 series) / 96MB (for STM32MP2 series) kernel or FIT (uncompressed/compressed), 1MB device tree file (fdt), 1MB script, 1MB pxe file and 1MB for overlay file and the ramdisk at the end.\n\nFor STM32MP1 series the kernel is loaded (from uImage) at its final location, normally 0xC0000000, by the command.\n\nFor STM32MP2 series the kernel is executed in place by the command, at 0x8a000000, after possible decompression.\n\nYou can change these value in the configuration file of your board to allow bigger files or optimized loading address, e.g. without relocation (device tree with fdt_high=0xFFFFFFFF or RAMDISK with initrd_high=0xffffffff) or load kernel at a final location (see zImage in arm/booting.html).\n\nSee U-Boot documentation (usage/environment.html) for details on these variables fdt_high and initrd_high."
    },
    {
        "link": "https://community.arm.com/support-forums/f/architectures-and-processors-forum/8476/enable-mmu-and-d-cache-on-armv8-for-u-boot",
        "document": "This discussion has been locked. You can no longer post new replies to this discussion. If you have a question you can start a new discussion You can no longer post new replies to this discussion. If you have a question you can start a new discussion Enable MMU and d-cache on ARMv8 for u-boot Hi,\n\nThis question is for MMU and d-cache. When I tried to enable MMU and d-cache for u-boot I ran into Synchronous Abort handler while writing to PCIe device registers which I mapped as uncached memory. The dump is shown below\n\n\"Synchronous Abort\" handler,\n• Your ESR code is reporting Data Abort due to Translation Fault from the level 3 table. So it looks like you're trying to access a page that you've not yet mapped.\n• Thanks and appreciate your quick response. After I mapped the page I could run the code. Could you please let me know if there is any documentation to decode ESR?\n\n Regards\n\n Pavan Hi Martin,Thanks and appreciate your quick response. After I mapped the page I could run the code. Could you please let me know if there is any documentation to decode ESR?RegardsPavan\n• The \"ARM Architecture Reference Manual ARMv8, for ARMv8-A architecture\" has details in section D7.2.28 \"ESR_ELx, Exception Syndrome Register (ELx)\".\n\n It details the various fields of the ESR such as EC, IL and ISS, and details their meaning.\n\n In your case for example, EC = 0b100101, which is \"Data Abort taken without a change in Exception level\". Hi,The \"ARM Architecture Reference Manual ARMv8, for ARMv8-A architecture\" has details in section D7.2.28 \"ESR_ELx, Exception Syndrome Register (ELx)\".It details the various fields of the ESR such as EC, IL and ISS, and details their meaning.In your case for example, EC = 0b100101, which is \"Data Abort taken without a change in Exception level\".\n• Alternatively, you could download the system register XML and view in a browser. Personally, I find this easier.\n\n \n\n developer.arm.com/.../exploration-tools\n\n \n\n In the XML, look for \"ESR_ELx\". You can find all the system register descriptions in ARM Architecture Reference Manual.Alternatively, you could download the system register XML and view in a browser. Personally, I find this easier.In the XML, look for \"ESR_ELx\"."
    }
]