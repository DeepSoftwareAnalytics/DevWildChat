[
    {
        "link": "https://developer.android.com/ndk/guides/prebuilts",
        "document": "The NDK supports the use of prebuilt libraries, both static and shared. There are two principal use cases for this functionality:\n• Distributing your own libraries to third-party NDK developers without distributing your sources.\n• Using a prebuilt version of your own libraries to speed up your build.\n\nThis page explains how to use prebuilt libraries.\n\nYou must declare each prebuilt library you use as an independent module. To do so, perform the following steps:\n• Give the module a name. This name does not need to be the same as that of the prebuilt library, itself.\n• None In the module's Android.mk file, assign to the path to the prebuilt library you are providing. Specify the path relative to the value of your variable. Note: You must make sure to select the version of your prebuilt library appropriate to your target ABI. For more information on ensuring library support for ABIs, see Select ABIs for prebuilt libraries\n• None Include or , depending on whether you are using a shared ( ) or static ( ) library.\n\nHere is a trivial example that assumes the prebuilt library resides in the same directory as the Android.mk file that describes it.\n\nIn this example, the name of the module is the same as that of the prebuilt library.\n\nThe build system places a copy of your prebuilt shared library into , and another copy, stripped of debug information, into . Here, is the root directory of your project.\n\nReference the prebuilt library from other modules\n\nTo reference a prebuilt library from other modules, specify its name as the value of the or variable in the Android.mk files associated with those other modules.\n\nFor example, the description of a module using might be as follows:\n\nHere, is the name of the module referring to the prebuilt; is the name of the prebuilt, itself.\n\nThe code in depends on specific declarations that normally reside in a header file, such as , distributed with the prebuilt library. For example, might have a line like the following:\n\nIn such a case, you need to provide the header and its include path to the compiler when you build the module. A simple way to accomplish this task is to use exports in the prebuilt module definition. For example, as long as header is located under the directory associated with the prebuilt module, you can declare it as follows:\n\nThe definition here ensures that the build system exports the path to the prebuilt library's directory, prepending that path onto the value of the for the module dependent on it.\n\nThis operation allows the build system to find the necessary headers.\n\nWe recommend that you provide prebuilt shared libraries containing debug symbols. The NDK build system always strips the symbols from the version of the library that it installs into , but you can use the debug version for debugging with .\n\nYou must make sure to select the right version of your prebuilt shared library for your targeted ABI. The variable in the Android.mk file can point the build system at the appropriate version of the library.\n\nFor example, assume that your project contains two versions of library :\n\nThe following snippet shows how to use so that the build system selects the appropriate version of the library:\n\nIf you have specified as the value of , the build system uses the version of located in the directory. If you have specified as the value , the build system uses the version in the directory."
    },
    {
        "link": "https://stackoverflow.com/questions/19200359/android-how-to-link-my-own-static-libraries-correctly",
        "document": "I have an Android project written in C++ and have a problem in linking phase. The code is put in some static libraries which should be linked together.\n\nI have found a lot of questions and answers on the net about this topic and most of them suggest to put my libraries to in the Android.mk file. But, if I do this, I found the content of is simply ignored: my libraries are not linked, and adding any dummy text here does not generate any error or warning message.\n\nI tried it this way:\n\nnone of them worked.\n\nIf I put my static libraries to then it is linked, but I got a warning message about non-system libraries are used, and probably the build will be wrong.\n\nThe content of my Android.mk file is:\n\nand I got this message:\n\nI could not find how to use right way, please help me!\n\nI have android-ndk-r9 and android-sdk_r22.2.1 on a OpenSuSE x86 and using target=android-18"
    },
    {
        "link": "https://developer.android.com/ndk/downloads/revision_history",
        "document": "Stay organized with collections Save and categorize content based on your preferences.\n\nThis page provides information on changes in all released stable versions of the NDK. To download the latest stable version of the NDK or any currently available beta version, see the NDK downloads page.\n\nSee the android-ndk-announce Google Group for more complete information, and subscribe to receive release announcements.\n\nThis release of the NDK includes support for MIPS ABI and a few additional fixes.\n• Added support for the MIPS ABI, which allows you to generate machine code that runs on compatible MIPS-based Android devices. Major features for MIPS include MIPS-specific toolchains, system headers, libraries and debugging support. For more details regarding MIPS support, see in the NDK package. By default, code is generated for ARM-based devices. You can add to your definition in your file to build for MIPS platforms. For example, the following line instructs to build your code for three distinct ABIs: Unless you rely on architecture-specific assembly sources, such as ARM assembly code, you should not need to touch your files to build MIPS machine code.\n• You can build a standalone MIPS toolchain using the option when calling . See for more details. Note: To ensure that your applications are available to users only if their devices are capable of running them, Google Play filters applications based on the instruction set information included in your application ? no action is needed on your part to enable the filtering. Additionally, the Android system itself also checks your application at install time and allows the installation to continue only if the application provides a library that is compiled for the device's CPU architecture.\n• Fixed a typo in GAbi++ implementation where the result of of base class object to derived class is incorrectly adjusted in the opposite direction from the base class. (Issue 28721)\n• Fixed an issue in which fails to copy .\n• Fixed to ensure that works correctly even if the user has redefined the environment variable, which may be changed when installing a variety of development tools in Windows environments.\n\nThis release of the NDK includes new features to support the Android 4.0 platform as well as many other additions and improvements:\n• Added official NDK APIs for Android 4.0 (API level 14), which adds the following native features to the platform:\n• Added native multimedia API based on the Khronos Group OpenMAX AL 1.0.1 standard. The new and headers allow applications targeting API level 14 to perform multimedia output directly from native code by using a new Android-specific buffer queue interface. For more details, see and http://www.khronos.org/openmax/.\n• Updated the native audio API based on the Khronos Group OpenSL ES 1.0.1 standard. With API Level 14, you can now decode compressed audio (e.g. MP3, AAC, Vorbis) to PCM. For more details, see and http://www.khronos.org/opensles/.\n• Added CCache support. To speed up large rebuilds, define the environment variable to (or the path to your binary). When declared, the NDK build system automatically uses CCache when compiling any source file. For example: Note: CCache is not included in the NDK release so you must have it installed prior to using it. For more information about CCache, see http://ccache.samba.org.\n• Added support for setting to to indicate that you want to build your NDK modules for all the ABIs supported by your given NDK release. This means that either one of the following two lines in your are equivalent with this release: This also works if you define when calling from the command-line, which is a quick way to check that your project builds for all supported ABIs without changing the project's . For example:\n• Added a variable in that allows you to declare which C++ features (RTTI or Exceptions) your module uses. This ensures that the final linking works correctly if you have prebuilt modules that depend on these features. See and for more details.\n• Shortened paths to source and object files that are used in build commands. When invoking from your project path, the paths to the source, object, and binary files that are passed to the build commands are significantly shorter now, because they are passed relative to the current directory. This is useful when building projects with a lot of source files, to avoid limits on the maximum command line length supported by your host operating system. The behavior is unchanged if you invoke from a sub-directory of your project tree, or if you define to point to a specific directory. You can now build your NDK source files on Windows without Cygwin by calling the script from the command line from your project path. The script takes exactly the same arguments as the original script. The Windows NDK package comes with its own prebuilt binaries for GNU Make, Awk and other tools required by the build. You should not need to install anything else to get a working build system. Important: does not work on Windows, so you still need Cygwin to debug. This feature is still experimental, so feel free to try it and report issues on the public bug database or public forum. All samples and unit tests shipped with the NDK successfully compile with this feature.\n• Imported shared libraries are now installed by default to the target installation location ( ) if is not defined in your . For example, if a top-level module imports a module , then both and are copied to the install location. Previously, only was copied, unless you listed in your too. If you define explicitly, the behavior is unchanged.\n• now works correctly for activities with multiple categories in their MAIN intent filters.\n• Static library imports are now properly transitive. For example, if a top-level module imports static library that imports static library , the will now be linked against both and .\n• : Fixed typo. The minimum API level should be 9, not 8 for native activities.\n• : Updated to download the toolchain sources from android.googlesource.com, which is the new location for the AOSP servers.\n• Added a new C++ support runtime named . More details about it are available in the updated .\n• Added a new C++ support runtime named that corresponds to the shared library version of GNU libstdc++ v3 (GPLv3 license). See more info at\n• Added support for RTTI in the STLport C++ runtimes (no support for exceptions).\n• Added support for multiple file extensions in . For example, to compile both and as C++ sources, declare the following:\n• Removed many unwanted exported symbols from the link-time shared system libraries provided by the NDK. This ensures that code generated with the standalone toolchain doesn't risk to accidentally depend on a non-stable ABI symbol (e.g. any libgcc.a symbol that changes each time the toolchain used to build the platform is changed)\n• Refreshed the EGL and OpenGLES Khronos headers to support more extensions. Note that this does not change the NDK ABIs for the corresponding libraries, because each extension must be probed at runtime by the client application. The extensions that are available depend on your actual device and GPU drivers, not the platform version the device runs on. The header changes simply add new constants and types to make it easier to use the extensions when they have been probed with or . The following list describes the newly supported extensions:\n\nThis release of the NDK includes many new APIs, most of which are introduced to support the development of games and similar applications that make extensive use of native code. Using the APIs, developers have direct native access to events, audio, graphics and window management, assets, and storage. Developers can also implement the Android application lifecycle in native code with help from the new class. For detailed information describing the changes in this release, read the document included in the downloaded NDK package.\n• Adds support for native activities, which allows you to implement the Android application lifecycle in native code.\n• Adds native support for the following:\n• Input subsystem (such as the keyboard and touch screen)\n• Event loop APIs to wait for things such as input and sensor events.\n• Audio APIs based on the OpenSL ES standard that support playback and recording as well as control over platform audio effects\n• Access to assets packaged in an file.\n• Includes a new toolchain (based on GCC 4.4.3), which generates better code, and can also now be used as a standalone cross-compiler, for people who want to build their stuff with . See docs/STANDALONE-TOOLCHAIN.html for the details. The binaries for GCC 4.4.0 are still provided, but the 4.2.1 binaries were removed.\n• Adds support for prebuilt static and shared libraries (docs/PREBUILTS.html) and module exports and imports to make sharing and reuse of third-party modules much easier (docs/IMPORT-MODULE.html explains why).\n• Provides a default C++ STL implementation (based on STLport) as a helper module. It can be used either as a static or shared library (details and usage examples are in sources/android/stlport/README). Prebuilt binaries for STLport (static or shared) and GNU libstdc++ (static only) are also provided if you choose to compile against those libraries instead of the default C++ STL implementation. C++ Exceptions and RTTI are not supported in the default STL implementation. For more information, see docs/CPLUSPLUS-SUPPORT.HTML.\n• Includes improvements to the helper library that improves reporting of the CPU type (some devices previously reported ARMv7 CPU when the device really was an ARMv6). We recommend developers that use this library to rebuild their applications then upload to Google Play to benefit from the improvements.\n• Adds an EGL library that lets you create and manage OpenGL ES textures and services.\n• Adds new sample applications, and , to demonstrate how to write a native activity.\n• Includes many bugfixes and other small improvements; see docs/CHANGES.html for a more detailed list of changes."
    },
    {
        "link": "https://github.com/wireapp/wire-audio-video-signaling/issues/18",
        "document": "/home/ryan/wire-audio-video-signaling/build/toolchains/android-arm64/ndk/ndk-build -C android -I ../build/android-arm64\n\n Android NDK: WARNING: APP_PLATFORM android-21 is higher than android:minSdkVersion 1 in ./AndroidManifest.xml. NDK binaries will not be comptible with devices older than android-21. See https://android.googlesource.com/platform/ndk/+/master/docs/user/common_problems.md for more information.\n\n Android NDK: WARNING:jni/Android.mk:avs: non-system libraries in linker flags: -lavscore -lre -lrew -lsodium -lwebrtc -lc++_static -lc++abi\n\n Android NDK: This is likely to result in incorrect builds. Try using LOCAL_STATIC_LIBRARIES\n\n Android NDK: or LOCAL_SHARED_LIBRARIES instead to list the library dependencies of the\n\n Android NDK: current module\n\n/home/ryan/devtools/android-ndk-r16b/build/../sources/cxx-stl/llvm-libc++/libs/arm64-v8a/libc++_static.a(locale.o): In function strtof_l'\n\n /home/ryan/devtools/android-ndk-r16b/build/../sources/cxx-stl/llvm-libc++/libs/arm64-v8a/libc++_static.a(locale.o): In function strtod_l'\n\n clang++: error: linker command failed with exit code 1 (use -v to see invocation)\n\n make[1]: *** [obj/local/arm64-v8a/libavs.so] Error 1\n\n make[1]: Leaving directory `/home/ryan/wire-audio-video-signaling/android'\n\n mk/dist.mk:149: recipe for target '/home/ryan/wire-audio-video-signaling/build/dist/android/avs.aar' failed\n\n make: *** [/home/ryan/wire-audio-video-signaling/build/dist/android/avs.aar] Error 2\n\nI had try NDK r16b 、r17、r18、r19、r20. All are same error.\n\n I don't know how to solve this problem. who can help me? thanks."
    },
    {
        "link": "https://stackoverflow.com/questions/13637450/android-ndk-how-to-link-multiple-3rd-party-libraries",
        "document": "Let's say we're building a shared library A that needs to link to 2 external static libs B and C. All you've got are libB.a and libC.a, along with their header files.\n\nAFAIK, the way linking works for shared libraries is:\n• grab all object files of B and C\n• resolve references in B and C\n\nThis gives link errors because B and C call each other, specifically they call functions that got stripped out in step 2 because A didn't call them.\n\nIf we built the static libs ourselves, then it's simply a matter of replacing LOCAL_STATIC_LIBRARIES with LOCAL_WHOLE_STATIC_LIBRARIES, which prevents code stripping (at the expense of code size). Under the hood, it passes --whole-archive to the linker.\n\nSince we didn't build B and C (and don't even have the source to rebuild them), what are the options?\n• manually reference the missing functions from A, so that they don't get stripped\n• figure out how to pass --whole-archive to the linker for the external static libraries\n• use the PREBUILT_STATIC_LIBRARY (seen it mentioned, but never used it, and the according to the docs it doesn't sound applicable in this case)\n• build an executable instead of a shared library (which won't strip code the same way)\n• move/rename external libs to trick the NDK build system into thinking they're mine, so that I can add them to LOCAL_WHOLE_STATIC_LIBRARIES.\n\nI've gone with option 1 because it's the first thing that worked, but obviously it's not great. I'm asking whether there's a better solution.\n\nThe answer to this question ( Linking issue when prebuilt static and shared libraries with the Android NDK ) made me wonder if I need to re-evaluate my build setup (shared library linking to external static library). I'm unable to comment there, so I asked my own question here."
    },
    {
        "link": "https://developer.android.com/ndk/reference/group/logging",
        "document": "Save and categorize content based on your preferences.\n\n) and to stderr, before calling Writes an assertion failure to the log (as) and to stderr, before calling abort(3) Writes a formatted string to log buffer , with priority and tag . Writes the constant string to the log buffer , with priority and tag . Gets the minimum priority that will be logged for this process. \" along with the minimum priority from __android_log_set_minimum_priority() to determine if a log message with a given prio and tag will be printed. \" along with the minimum priority from __android_log_set_minimum_priority() to determine if a log message with a given prio and tag will be printed. Writes a formatted string to the log, with priority and tag . Sets a user defined aborter function that is called for __android_log_assert() failures. Sets the default tag if no tag is provided when writing a log message. Sets the minimum priority that will be logged for this process. Writes the constant string to the log, with priority and tag . Writes the log message specified by log_message.\n\nWrites an assertion failure to the log (as ) and to stderr, before calling abort(3). If is non-null, is unused. If is null, the string is used with as the string argument. If both and are null, a default string is provided. Most callers should use assert(3) from instead, or the and functions provided by bionic if more control is needed. They support automatically including the source filename and line number more conveniently than this function.\n\nUse the per-tag properties \"log.tag. \" along with the minimum priority from __android_log_set_minimum_priority() to determine if a log message with a given prio and tag will be printed. A non-zero result indicates yes, zero indicates false. If both a priority for a tag and a minimum priority are set by __android_log_set_minimum_priority(), then the lowest of the two values are to determine the minimum priority needed to log. If only one is set, then that value is used to determine the minimum priority needed. If none are set, then default_priority is used. the default priority to use if no properties or minimum priority are set. an integer where 1 indicates that the message is loggable and 0 indicates that it is not.\n\nUse the per-tag properties \"log.tag. \" along with the minimum priority from __android_log_set_minimum_priority() to determine if a log message with a given prio and tag will be printed. A non-zero result indicates yes, zero indicates false. If both a priority for a tag and a minimum priority are set by __android_log_set_minimum_priority(), then the lowest of the two values are to determine the minimum priority needed to log. If only one is set, then that value is used to determine the minimum priority needed. If none are set, then default_priority is used. the default priority to use if no properties or minimum priority are set. an integer where 1 indicates that the message is loggable and 0 indicates that it is not."
    },
    {
        "link": "https://developer.android.com/ndk/guides/stable_apis",
        "document": "Stay organized with collections Save and categorize content based on your preferences.\n\nThis page gives an overview of the libraries included in the NDK, with links to the relevant parts of the NDK API reference, and to guides where they exist.\n\nThere are two steps to using a library that the NDK provides:\n• None Tell the build system to link against the library.\n• None If you are using ndk-build: Add the library to in your Android.mk. Note that you strip the leading and say instead. For example, to link against and , you'd write: For more about , see the Android.mk docs documentation.\n• None If you are using CMake: Follow the instructions in Studio's Add NDK APIs documentation.\n• None the appropriate headers from your code.\n\nNote that APIs which are newer than your application's won't be callable by default, and you must instead use them via and . For an easier approach, see Using newer APIs.\n\nThe standard C11 library headers such as and are available as usual.\n\nNote that on Android, unlike Linux, there are no separate or libraries. That functionality is included directly in , which does not need to be explicitly linked against.\n\nThere is a separate for math functions (following the usual Unix tradition), but like this is automatically linked by the build systems.\n\nDynamic linker functionality in such as dlopen(3) and dlsym(3) is available, but you must explicitly link against .\n\nC++17 support is available. For more information on C++ library support, see C++ library support.\n\ncontains APIs for logging to logcat.\n\nThe native tracing API provides the native equivalent of the class in the Java programming language. This API lets you trace named units of work in your code by writing trace events to the system trace buffer. You can then collect and analyze the trace events using the Systrace tool.\n\nYou can use the Zlib compression library by including and linking against .\n\nThe NDK always includes the latest zlib header files at the time of release, and the included in the NDK for static linking is always that same version, but the for dynamic linking comes from the device, and be whatever version happened to be released on that device. In particular, this means that the headers you built against do not match the version of zlib on the device, so the usual warnings against making assumptions about implementation details are especially valid here. We are not aware of any issues with public API, but struct layout in particular has changed over time and will likely continue to do so. Note that new API in later zlib versions will obviously not be available on OS versions that predate the API. It is possible to avoid all these problems (at the cost of increased APK size) by always using the static instead of .\n\nAvailable since API level 3 (but see note above).\n\nThe standard OpenGL ES 1.x headers ( and ), 2.0 headers ( and ), 3.0 headers ( and ), 3.1 headers ( and ), and 3.2 headers ( and ) contain the declarations necessary for OpenGL ES.\n\nTo use OpenGL ES 1.x, link your native module to .\n\nTo use OpenGL ES 2.0, link your native module to .\n\nTo use OpenGL ES 3.x, link your native module to .\n\nOnly Android devices that have the necessary GPU fully support later versions of OpenGL ES, but the libraries are present on all devices that support the API level where they were introduced. It's safe to link against the libraries, but an app must query the OpenGL ES version string and extension string to determine whether the current device supports the features it needs. For information on how to perform this query, see the description of in the OpenGL specification.\n\nAdditionally, you must put a tag in your manifest file to indicate the version of OpenGL ES that you require.\n\nOpenGL ES 1.0 is available since API level 4.\n\nOpenGL ES 2.0 is available since API level 5.\n\nOpenGL ES 3.0 is available since API level 18.\n\nOpenGL ES 3.1 is available since API level 21.\n\nOpenGL ES 3.2 is available since API level 24.\n\nEGL provides a native platform interface via the and headers for allocating and managing OpenGL ES contexts and surfaces.\n\nEGL allows you to perform the following operations from native code:\n\nAPI level 24 added support for the , , and extensions.\n\nVulkan is a low-overhead, cross-platform API for high-performance 3D graphics rendering. Vulkan is an open standard maintained by the Khronos Group. The standard header file contains the declarations needed to perform Vulkan rendering calls from your code.\n\nFor code samples, see the LunarG VulkanSamples and android-vulkan-tutorials projects on GitHub.\n\nThe Vulkan library is present on all devices supporting API level 24 or later, but apps must check at runtime that the necessary GPU hardware support is available. Devices without Vulkan support will return zero devices from .\n\nThe library exposes API that allows access to the pixel buffers of Java objects. The workflow is as follows:\n• None Call to retrieve information, such as width and height, about a given bitmap handle.\n• None Call to lock the pixel buffer and retrieve a pointer to it. Doing so ensures that the pixels do not move until the app calls .\n• None Modify the pixel buffer as appropriate for its pixel format, width, and other characteristics.\n\nThe native camera APIs perform fine-grained photo capture and processing. Unlike the Java camera2 API, the native camera API does not support deprecated camera HAL 1.0 implementations (that is, the available camera list in the native camera API won’t list camera devices that have the LEGACY hardware level).\n\nThe Media APIs provide low-level native interfaces similar to , and other related Java APIs.\n\nThe standard OpenMAX AL headers and contain the declarations necessary for performing multimedia output from the native side of Android.\n\nThe NDK distribution of OpenMAX AL also provides Android-specific extensions. For information about these extensions, see the comments in .\n\nFor more information, see the Android NDK API reference documentation.\n\nBinder APIs allow you to create communication channels between processes. This is the low level implementation of Android interprocess communication. When possible, prefer higher-level components. However, this library is available for advanced use cases.\n\nThere are two native APIs that let you create your own pipelines for cross-process buffer management.\n\nThe native hardware buffer API lets you directly allocate buffers to create your own pipelines for cross-process buffer management. You can allocate an and use it to obtain an resource type via the extension. You can pass that buffer to to create an resource type, which may then be bound to a texture via on supported devices. This can be useful for creating textures that may be shared cross-process.\n\nThe native hardware buffer JNI API ( ) lets you obtain a object, which is a Parcelable and thus may be transported between two different processes. This gives your app similar capabilities to SurfaceFlinger such as creating your own queue of buffers between processes without accessing internal Android APIs.\n\nAAudio is the currently-supported native audio API. It replaced OpenSL ES, and provides better support for high-performance audio apps that require low-latency audio.\n\nOpenSL ES is another native audio API which is also supported, but see the note at the Guide below.\n\nThe Neural Networks API (NNAPI) provides apps with hardware acceleration for on-device machine learning operations. The API supports on-device model creation, compilation, and execution. Apps typically do not use NNAPI directly; instead, the API is meant to be called by machine learning libraries, frameworks, and tools that let developers train their models and deploy them on Android devices."
    },
    {
        "link": "https://stackoverflow.com/questions/4629308/any-simple-way-to-log-in-android-ndk-code",
        "document": "ADT 20 includes an NDK plugin that provides support for building and debugging NDK projects in Eclipse. This document describes how to install and use the NDK plugin. Instructions are pretty straightforward and consist of only a few steps.\n\nThis is the simplest solution I found and it worked for me.\n\nNote: If you are using ADT bundle you only need to install C development tools with install new software (see the screenshot) and you can go to \"Using the NDK plugin\" part immediately.\n\nEdit: It seems there is an issue with CDT in eclipse juno http://code.google.com/p/android/issues/detail?id=33788 causing eclipse's debugger to be unable to find breakpoints. Workaround I used is to start app in debug mode (not debug as native app but 'regular' debug) and then in command line I went to my project root and typed (this creates file in folder). After that breakpoints worked as usual.\n\nIn comments related to the issue on the link above they suggest some other workarounds but I didn't try them since they seemed to require more effort than this."
    },
    {
        "link": "https://stackoverflow.com/questions/10274920/how-to-get-printf-messages-written-in-ndk-application",
        "document": "use instead. You have to include header\n\nYou can also use format specifier like printf -\n\nMake sure you also link against the logging library, in your Android.mk file:\n\nOhh.. forgot .. The output will be shown in with tag\n\nAdd the following lines to your common header file.\n\nNow just call like .\n\nIf you define empty, all logs will be gone. Just comment after ."
    },
    {
        "link": "https://github.com/android/ndk/issues/1908",
        "document": "I'm getting a small but consistent number of crash reports in my app related to the Python library's use of readlink() during its initialization. I've built everything using ndk 25.2.9519653 and target api 21. I'm unfortunately not able to reproduce the issue locally but have added some logging to try and slowly diagnose things remotely and am curious if anyone can offer any insight on whether this might be a compiler bug or ndk issue or something else.\n\nBasically, the relevant code is this:\n\nres is a Py_ssize_t (should be same as ssize_t), and cpath in this case is a nonexistent path so the readlink should always be returning -1.\n\nThe problem I am running into is that every so often it seems there's a device that gets a -1 value returned but the (res == -1) evaluates to false. This leads to it skipping the return clause and then a crash further down. Interestingly, my logging shows that, in these cases, while evaluates to false, evaluates to true. (see below for exact logging code).\n\nIs there some logical explanation for a single binary exhibiting this broken behavior only on a handful of devices and correct behavior everywhere else? Such as particular kernel versions returning differently sized return values for readlink or something?\n\nOutput from that logging on crashing devices:\n\n\n\nNote that is -1, is 0 and is 1\n\nPossibly of note: when testing the 32 bit arm version locally I see and arm64 shows me . Remote crash logs, however, show a combination of those: . Not sure if that's meaningful or just a printf quirk of some sort.\n\nAm seeing crash reports for Android 8 through 13 devices"
    }
]