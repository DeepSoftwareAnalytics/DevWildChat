[
    {
        "link": "https://spring.io/guides/gs/batch-processing",
        "document": "How to complete this guide Like most Spring Getting Started guides, you can start from scratch and complete each step or you can bypass basic setup steps that are already familiar to you. Either way, you end up with working code. To start from scratch, move on to Starting with Spring Initializr. To skip the basics, do the following:\n• Download and unzip the source repository for this guide, or clone it using Git: When you finish, you can check your results against the code in .\n\nYou can use this pre-initialized project and click Generate to download a ZIP file. This project is configured to fit the examples in this tutorial.\n• Navigate to https://start.spring.io. This service pulls in all the dependencies you need for an application and does most of the setup for you.\n• Choose either Gradle or Maven and the language you want to use. This guide assumes that you chose Java.\n• Download the resulting ZIP file, which is an archive of an application that is configured with your choices. If your IDE has the Spring Initializr integration, you can complete this process from your IDE. You can also fork the project from GitHub and open it in your IDE or other editor.\n\nTypically, your customer or a business analyst supplies a spreadsheet. For this simple example, you can find some made-up data in : This spreadsheet contains a first name and a last name on each row, separated by a comma. This is a fairly common pattern that Spring can handle without customization. Next, you need to write an SQL script to create a table to store the data. You can find such a script in : Spring Boot runs automatically during startup. is the default for all platforms.\n\nA common paradigm in batch processing is to ingest data, transform it, and then pipe it out somewhere else. Here, you need to write a simple transformer that converts the names to uppercase. The following listing (from ) shows how to do so: implements Spring Batch’s interface. This makes it easy to wire the code into a batch job that you will define later in this guide. According to the interface, you receive an incoming object, after which you transform it to an upper-cased . The input and output types need not be the same. In fact, after one source of data is read, sometimes the application’s data flow needs a different data type.\n\nNow you need to put together the actual batch job. Spring Batch provides many utility classes that reduce the need to write custom code. Instead, you can focus on the business logic. To configure your job, you must first create a Spring class like the following example in . This example uses a memory-based database, meaning that, when it is done, the data is gone. Now add the following beans to your class to define a reader, a processor, and a writer: @Bean public FlatFileItemReader<Person> reader() { return new FlatFileItemReaderBuilder<Person>() .name(\"personItemReader\") .resource(new ClassPathResource(\"sample-data.csv\")) .delimited() .names(\"firstName\", \"lastName\") .targetType(Person.class) .build(); } @Bean public PersonItemProcessor processor() { return new PersonItemProcessor(); } @Bean public JdbcBatchItemWriter<Person> writer(DataSource dataSource) { return new JdbcBatchItemWriterBuilder<Person>() .sql(\"INSERT INTO people (first_name, last_name) VALUES (:firstName, :lastName)\") .dataSource(dataSource) .beanMapped() .build(); } The first chunk of code defines the input, processor, and output.\n• creates an . It looks for a file called and parses each line item with enough information to turn it into a .\n• creates an instance of the that you defined earlier, meant to convert the data to upper case.\n• creates an . This one is aimed at a JDBC destination and automatically gets a created by Spring Boot. It includes the SQL statement needed to insert a single , driven by Java record components. The last chunk (from ) shows the actual job configuration: The first method defines the job, and the second one defines a single step. Jobs are built from steps, where each step can involve a reader, a processor, and a writer. You then list each step, (though this job has only one step). The job ends, and the Java API produces a perfectly configured job. In the step definition, you define how much data to write at a time. In this case, it writes up to three records at a time. Next, you configure the reader, processor, and writer by using the beans injected earlier. is prefixed because it is a generic method. This represents the input and output types of each “chunk” of processing and lines up with and . The last bit of batch configuration is a way to get notified when the job completes. The following example (from ) shows such a class: package com.example.batchprocessing; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.batch.core.BatchStatus; import org.springframework.batch.core.JobExecution; import org.springframework.batch.core.JobExecutionListener; import org.springframework.jdbc.core.DataClassRowMapper; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.stereotype.Component; @Component public class JobCompletionNotificationListener implements JobExecutionListener { private static final Logger log = LoggerFactory.getLogger(JobCompletionNotificationListener.class); private final JdbcTemplate jdbcTemplate; public JobCompletionNotificationListener(JdbcTemplate jdbcTemplate) { this.jdbcTemplate = jdbcTemplate; } @Override public void afterJob(JobExecution jobExecution) { if (jobExecution.getStatus() == BatchStatus.COMPLETED) { log.info(\"!!! JOB FINISHED! Time to verify the results\"); jdbcTemplate .query(\"SELECT first_name, last_name FROM people\", new DataClassRowMapper<>(Person.class)) .forEach(person -> log.info(\"Found <{}> in the database.\", person)); } } } The listens for when a job is and then uses to inspect the results.\n\nAlthough batch processing can be embedded in web apps and WAR files, the simpler approach demonstrated below creates a standalone application. You package everything in a single, executable JAR file, driven by a good old Java method. The Spring Initializr created an application class for you. For this simple example, it works without further modification. The following listing (from ) shows the application class: is a convenience annotation that adds all of the following:\n• : Tags the class as a source of bean definitions for the application context.\n• : Tells Spring Boot to start adding beans based on classpath settings, other beans, and various property settings. For example, if is on the classpath, this annotation flags the application as a web application and activates key behaviors, such as setting up a .\n• : Tells Spring to look for other components, configurations, and services in the package, letting it find the controllers. The method uses Spring Boot’s method to launch an application. Did you notice that there was not a single line of XML? There is no file, either. This web application is 100% pure Java and you did not have to deal with configuring any plumbing or infrastructure. Note that and ensure that the JVM exits upon job completion. See the Application Exit section in Spring Boot Reference documentation for more details. For demonstration purposes, there is code to inject a , query the database, and print out the names of people the batch job inserts. Note how the application does not use the annotation. Previously, could be used to enable Spring Boot’s auto-configuration of Spring Batch. A bean that is annotated with or that extends Spring Batch’s can now be defined to tell the auto-configuration to back off, allowing the application to take complete control of how Spring Batch is configured. You can run the application from the command line with Gradle or Maven. You can also build a single executable JAR file that contains all the necessary dependencies, classes, and resources and run that. Building an executable jar makes it easy to ship, version, and deploy the service as an application throughout the development lifecycle, across different environments, and so forth. If you use Gradle, you can run the application by using . Alternatively, you can build the JAR file by using and then run the JAR file, as follows: If you use Maven, you can run the application by using . Alternatively, you can build the JAR file with and then run the JAR file, as follows: The steps described here create a runnable JAR. You can also build a classic WAR file. The job prints out a line for each person that gets transformed. After the job runs, you can also see the output from querying the database. It should resemble the following output: Converting (Person[firstName=Jill, lastName=Doe]) into (Person[firstName=JILL, lastName=DOE]) Converting (Person[firstName=Joe, lastName=Doe]) into (Person[firstName=JOE, lastName=DOE]) Converting (Person[firstName=Justin, lastName=Doe]) into (Person[firstName=JUSTIN, lastName=DOE]) Converting (Person[firstName=Jane, lastName=Doe]) into (Person[firstName=JANE, lastName=DOE]) Converting (Person[firstName=John, lastName=Doe]) into (Person[firstName=JOHN, lastName=DOE]) Found <Person[firstName=JILL, lastName=DOE]> in the database. Found <Person[firstName=JOE, lastName=DOE]> in the database. Found <Person[firstName=JUSTIN, lastName=DOE]> in the database. Found <Person[firstName=JANE, lastName=DOE]> in the database. Found <Person[firstName=JOHN, lastName=DOE]> in the database."
    },
    {
        "link": "https://docs.spring.io/spring-batch/reference/job/java-config.html",
        "document": "Spring 3 brought the ability to configure applications with Java instead of XML. As of Spring Batch 2.2.0, you can configure batch jobs by using the same Java configuration. There are three components for the Java-based configuration: the annotation and two builders.\n\nThe annotation works similarly to the other annotations in the Spring family. In this case, provides a base configuration for building batch jobs. Within this base configuration, an instance of and are created, in addition to a number of beans being made available to be autowired:\n\nThe default implementation provides the beans mentioned in the preceding list and requires a and a to be provided as beans within the context. The data source and transaction manager are used by the and instances. By default, the data source named and the transaction manager named will be used. You can customize any of these beans by using the attributes of the annotation. The following example shows how to provide a custom data source and transaction manager:\n\nStarting from v5.0, an alternative, programmatic way of configuring base infrastrucutre beans is provided through the class. This class provides the same beans provided by and can be used as a base class to configure batch jobs. The following snippet is a typical example of how to use it:\n\nThe data source and transaction manager will be resolved from the application context and set on the job repository and job explorer. You can customize the configuration of any infrastructure bean by overriding the required setter. The following example shows how to customize the character encoding for instance:"
    },
    {
        "link": "https://toptal.com/spring/spring-batch-tutorial",
        "document": "Batch processing—typified by bulk-oriented, non-interactive, and frequently long running, background execution—is widely used across virtually every industry and is applied to a diverse array of tasks. Batch processing may be data or computationally intensive, execute sequentially or in parallel, and may be initiated through various invocation models, including ad hoc, scheduled, and on-demand.\n\nThis Spring Batch tutorial explains the programming model and the domain language of batch applications in general and, in particular, shows some useful approaches to the design and development of batch applications using the current Spring Batch 3.0.7 version.\n\nSpring Batch is a lightweight, comprehensive framework designed to facilitate development of robust batch applications. It also provides more advanced technical services and features that support extremely high volume and high performance batch jobs through its optimization and partitioning techniques. Spring Batch builds upon the POJO-based development approach of the Spring Framework, familiar to all experienced Spring developers.\n\nBy way of example, this article considers source code from a sample project that loads an XML-formatted customer file, filters customers by various attributes, and outputs the filtered entries to a text file. The source code for our Spring Batch example (which makes use of Lombok annotations) is available here on GitHub and requires Java SE 8 and Maven.\n\nWhat is Batch Processing? Key Concepts and Terminology\n\nIt is important for any batch developer to be familiar and comfortable with the main concepts of batch processing. The diagram below is a simplified version of the batch reference architecture that has been proven through decades of implementations on many different platforms. It introduces the key concepts and terms relevant to batch processing, as used by Spring Batch.\n\nAs shown in our batch processing example, a batch process is typically encapsulated by a consisting of multiple s. Each typically has a single , , and . A is executed by a , and metadata about configured and executed jobs is stored in a .\n\nEach may be associated with multiple s, each of which is defined uniquely by its particular that are used to start a batch job. Each run of a is referred to as a . Each typically tracks what happened during a run, such as current and exit statuses, start and end times, etc.\n\nA is an independent, specific phase of a batch , such that every is composed of one or more s. Similar to a , a has an individual that represents a single attempt to execute a . stores the information about current and exit statuses, start and end times, and so on, as well as references to its corresponding and instances.\n\nAn is a set of key-value pairs containing information that is scoped to either or . Spring Batch persists the , which helps in cases where you want to restart a batch run (e.g., when a fatal error has occurred, etc.). All that is needed is to put any object to be shared between steps into the context and the framework will take care of the rest. After restart, the values from the prior are restored from the database and applied.\n\nis the mechanism in Spring Batch that makes all this persistence possible. It provides CRUD operations for , , and instantiations. Once a is launched, a is obtained from the repository and, during the course of execution, and instances are persisted to the repository.\n\nOne of the advantages of Spring Batch is that project dependencies are minimal, which makes it easier to get up and running quickly. The few dependencies that do exist are clearly specified and explained in the project’s , which can be accessed here.\n\nThe actual startup of the application happens in a class looking something like the following:\n\nThe annotation enables Spring Batch features and provides a base configuration for setting up batch jobs.\n\nThe annotation comes from the Spring Boot project that provides standalone, production-ready, Spring-based applications. It specifies a configuration class that declares one or more Spring beans and also triggers auto-configuration and Spring’s component scanning.\n\nOur sample project has only one job that is configured by with an injected and . The minimal job configuration can be defined in as follows:\n\nThere are two main approaches to building a step.\n\nOne approach, as shown in the above example, is tasklet-based. A supports a simple interface that has only one method, , which is called repeatedly until it either returns or throws an exception to signal a failure. Each call to the is wrapped in a transaction.\n\nAnother approach, chunk-oriented processing, refers to reading the data sequentially and creating “chunks” that will be written out within a transaction boundary. Each individual item is read in from an , handed to an , and aggregated. Once the number of items read equals the commit interval, the entire chunk is written out via the , and then the transaction is committed. A chunk-oriented step can be configured as follows:\n\nThe method builds a step that processes items in chunks with the size provided, with each chunk then being passed to the specified reader, processor, and writer. These methods are discussed in more detail in the next sections of this article.\n\nFor our Spring Batch sample application, in order to read a list of customers from an XML file, we need to provide an implementation of the interface :\n\nAn provides the data and is expected to be stateful. It is typically called multiple times for each batch, with each call to returning the next value and finally returning when all input data has been exhausted.\n\nSpring Batch provides some out-of-the-box implementations of , which can be used for a variety of purposes such as reading collections, files, integrating JMS and JDBC as well as multiple sources, and so on.\n\nIn our sample application, the class delegates actual calls to a lazily initialized instance of the class:\n\nA Spring bean for this implementation is created with the and annotations, letting Spring know that this class is a step-scoped Spring component and will be created once per step execution as follows:\n\ntransform input items and introduce business logic in an item-oriented processing scenario. They must provide an implementation of the interface :\n\nThe method accepts one instance of the class and may or may not return an instance of the same type. Returning indicates that the item should not continue to be processed. As usual, Spring provides few standard processors, such as that passes the item through a sequence of injected s and a that validates input.\n\nIn the case of our sample application, processors are used to filter customers by the following requirements:\n• A customer must be born in the current month (e.g., to flag for birthday specials, etc.)\n• A customer must have less than five completed transactions (e.g., to identify newer customers)\n\nThe “current month” requirement is implemented via a custom :\n\nThe “limited number of transactions” requirement is implemented as a :\n\nThis pair of processors is then encapsulated within a that implements the delegate pattern:\n\nFor outputting the data, Spring Batch provides the interface for serializing objects as necessary:\n\nThe method is responsible for making sure that any internal buffers are flushed. If a transaction is active, it will also usually be necessary to discard the output on a subsequent rollback. The resource to which the writer is sending data should normally be able to handle this itself. There are standard implementations such as , , , , , and others.\n\nIn our sample application, the list of filtered customers is written out as follows:\n\nBy default, Spring Batch executes all jobs it can find (i.e., that are configured as in ) at startup. To change this behavior, disable job execution at startup by adding the following property to :\n\nThe actual scheduling is then achieved by adding the annotation to a configuration class and the annotation to the method that executes the job itself. Scheduling can be configured with delay, rates, or cron expressions:\n\nThere is a problem with the above example though. At run time, the job will succeed the first time only. When it launches the second time (i.e. after five seconds), it will generate the following messages in the logs (note that in previous versions of Spring Batch a would have been thrown):\n\nThis happens because only unique s may be created and executed and Spring Batch has no way of distinguishing between the first and second .\n\nThere are two ways of avoiding this problem when you schedule a batch job.\n\nOne is to be sure to introduce one or more unique parameters (e.g., actual start time in nanoseconds) to each job:\n\nAlternatively, you can launch the next job in a sequence of s determined by the attached to the specified job with :\n\nUsually, to run unit tests in a Spring Boot application, the framework must load a corresponding . Two annotations are used for this purpose:\n\nThere is a utility class to test batch jobs. It provides methods for launching an entire job as well as allowing for end-to-end testing of individual steps without having to run every step in the job. It must be declared as a Spring bean:\n\nA typical test for a job and a step looks as follows (and can use any mocking frameworks as well):\n\nSpring Batch introduces additional scopes for step and job contexts. Objects in these scopes use the Spring container as an object factory, so there is only one instance of each such bean per execution step or job. In addition, support is provided for late binding of references accessible from the or . The components that are configured at runtime to be step- or job-scoped are tricky to test as standalone components unless you have a way to set the context as if they were in a step or job execution. That is the goal of the and components in Spring Batch, as well as and .\n\nThe are declared at the class level, and its job is to create a step execution context for each test method. For example:\n\nThere are two s. One is from the regular Spring Test framework and handles dependency injection from the configured application context. The other is the Spring Batch that sets up step-scope context for dependency injection into unit tests. A is created for the duration of a test method and made available to any dependencies that are injected. The default behavior is just to create a with fixed properties. Alternatively, the can be provided by the test case as a factory method returning the correct type.\n\nAnother approach is based on the utility class. This class is used to create and manipulate in unit tests in a more flexible way without using dependency injection. For example, reading the ID of the customer filtered by the processor above could be done as follows:\n\nThis article introduces some of the basics of design and development of Spring Batch applications. However, there are many more advanced topics and capabilities—such as scaling, parallel processing, listeners, and more—that are not addressed in this article. Hopefully, this article provides a useful foundation for getting started.\n\nInformation on these more advanced topics can then be found in the official Spring Back documentation for Spring Batch."
    },
    {
        "link": "https://docs.spring.io/spring-batch/docs/current/api/org/springframework/batch/core/configuration/annotation/EnableBatchProcessing.html",
        "document": "Enable Spring Batch features and provide a base configuration for setting up batch jobs in an @Configuration class, roughly equivalent to using the XML namespace.\n\nThis annotation configures JDBC-based Batch infrastructure beans, so you must provide a and aas beans in the application context. Note that only one of your configuration classes needs to have theannotation. Once you have anclass in your configuration, you have an instance of and , so your beans inside steps can haveandrespectively. You can also useto insert some useful beans into your context:If the configuration is specified as, the context also contains an . The job registrar is useful for modularizing your configuration if there are multiple jobs. It works by creating separate child application contexts to contain job configurations and register those jobs. The jobs can then create steps and other dependent components without needing to worry about bean definition name clashes. Beans of type are automatically registered with the job registrar. Example:Note that a modular parent context, in general, should not itself contain @Bean definitions for job, because cyclic configuration dependencies are likely to develop.\n\nFor reference, compare the first example shown earlier to the following Spring XML configuration:"
    },
    {
        "link": "https://stackoverflow.com/questions/74154573/defaultbatchconfiguration-extending-in-spring-batch-5-not-working",
        "document": "Just to implement a custom Batch Configuration for Spring Batch 5, following the official documentation on Blog: Spring Batch 5 Milestone 6 and JavaDoc Spring Batch 5 Milestone 8, I wrote this code, using Spring Batch 5 via Spring Boot 3 RC1:\n\nBut I only get an error about my Bean, illegally overriding the Bean. Which is weird, because has no .\n\nDoes anyone know how to solve this?\n\nError: \n\nConfigServletWebServerApplicationContext : Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.BeanDefinitionStoreException: Invalid bean definition with name 'jobRepository' defined in class path resource [my/package/MyBatchConfiguration.class]: @Bean definition illegally overridden by existing bean definition: Generic bean: class [org.springframework.batch.core.repository.support.JobRepositoryFactoryBean]; scope=; abstract=false; lazyInit=null; autowireMode=0; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=null; factoryMethodName=null; initMethodNames=null; destroyMethodNames=null"
    },
    {
        "link": "https://docs.spring.io/spring-data/mongodb/docs/current-SNAPSHOT/reference/html",
        "document": "The MongoDB support contains a wide range of features:\n• Spring configuration support with Java-based classes or an XML namespace for a Mongo driver instance and replica sets.\n• helper class that increases productivity when performing common Mongo operations.Includes integrated object mapping between documents and POJOs.\n• Annotation-based mapping metadata that is extensible to support other metadata formats.\n• Cross-store persistence support for JPA Entities with fields transparently persisted and retrieved with MongoDB (deprecated - to be removed without replacement). For most tasks, you should use or the Repository support, which both leverage the rich mapping functionality. is the place to look for accessing functionality such as incrementing counters or ad-hoc CRUD operations. also provides callback methods so that it is easy for you to get the low-level API artifacts, such as , to communicate directly with MongoDB. The goal with naming conventions on various API artifacts is to copy those in the base MongoDB Java driver so you can easily map your existing knowledge onto the Spring APIs. An easy way to bootstrap setting up a working environment is to create a Spring-based project in STS. First, you need to set up a running MongoDB server. Refer to the MongoDB Quick Start guide for an explanation on how to startup a MongoDB instance. Once installed, starting MongoDB is typically a matter of running the following command:\n• Go to File → New → Spring Template Project → Simple Spring Utility Project, and press Yes when prompted. Then enter a project and a package name, such as .\n• Add the following to the pom.xml files element:\n• Change the version of Spring in the pom.xml to be\n• Add the following location of the Spring Milestone repository for Maven to your such that it is at the same level of your element: The repository is also browseable here. You may also want to set the logging level to to see some additional information. To do so, edit the file to have the following content: Then you can create a class to persist: package org.spring.mongodb.example; public class Person { private String id; private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getId() { return id; } public String getName() { return name; } public int getAge() { return age; } @Override public String toString() { return \"Person [id=\" + id + \", name=\" + name + \", age=\" + age + \"]\"; } } You also need a main application to run: When you run the main program, the preceding examples produce the following output: 10:01:32,062 DEBUG apping.MongoPersistentEntityIndexCreator: 80 - Analyzing class class org.spring.example.Person for index information. 10:01:32,265 DEBUG ramework.data.mongodb.core.MongoTemplate: 631 - insert Document containing fields: [_class, age, name] in collection: Person 10:01:32,765 DEBUG ramework.data.mongodb.core.MongoTemplate:1243 - findOne using query: { \"name\" : \"Joe\"} in db.collection: database.Person 10:01:32,953 INFO org.spring.mongodb.example.MongoApp: 25 - Person [id=4ddbba3c0be56b7e1b210166, name=Joe, age=34] 10:01:32,984 DEBUG ramework.data.mongodb.core.MongoTemplate: 375 - Dropped collection [database.person] Even in this simple example, there are few things to notice:\n• You can instantiate the central helper class of Spring Mongo, , by using the standard object and the name of the database to use.\n• The mapper works against standard POJO objects without the need for any additional metadata (though you can optionally provide that information. See here.).\n• Conventions are used for handling the field, converting it to be an when stored in the database.\n• Mapping conventions can use field access. Notice that the class has only getters.\n• If the constructor argument names match the field names of the stored document, they are used to instantiate the object There is a GitHub repository with several examples that you can download and play around with to get a feel for how the library works. One of the first tasks when using MongoDB and Spring is to create a object using the IoC container. There are two main ways to do this, either by using Java-based bean metadata or by using XML-based bean metadata. Both are discussed in the following sections. For those not familiar with how to configure the Spring container using Java-based bean metadata instead of XML-based metadata, see the high-level introduction in the reference docs here as well as the detailed documentation here. The following example shows an example of using Java-based bean metadata to register an instance of a : @Configuration public class AppConfig { /* * Use the standard Mongo driver API to create a com.mongodb.client.MongoClient instance. */ public @Bean MongoClient mongoClient() { return MongoClients.create(\"mongodb://localhost:27017\"); } } This approach lets you use the standard instance, with the container using Spring’s . As compared to instantiating a instance directly, the has the added advantage of also providing the container with an implementation that translates MongoDB exceptions to exceptions in Spring’s portable hierarchy for data access classes annotated with the annotation. This hierarchy and the use of is described in Spring’s DAO support features. The following example shows an example of a Java-based bean metadata that supports exception translation on annotated classes: Example 4. Registering a object by using Spring’s and enabling Spring’s exception translation support @Configuration public class AppConfig { /* * Factory bean that creates the com.mongodb.client.MongoClient instance */ public @Bean MongoClientFactoryBean mongo() { MongoClientFactoryBean mongo = new MongoClientFactoryBean(); mongo.setHost(\"localhost\"); return mongo; } } To access the object created by the in other classes or your own classes, use a field. While you can use Spring’s traditional XML namespace to register an instance of with the container, the XML can be quite verbose, as it is general-purpose. XML namespaces are a better alternative to configuring commonly used objects, such as the Mongo instance. The mongo namespace lets you create a Mongo instance server location, replica-sets, and options. To use the Mongo namespace elements, you need to reference the Mongo schema, as follows: The following example shows a more advanced configuration with (note that these are not recommended values): Example 6. XML schema to configure a object with The following example shows a configuration using replica sets: Example 7. XML schema to configure a object with Replica Sets While is the entry point to the MongoDB driver API, connecting to a specific MongoDB database instance requires additional information, such as the database name and an optional username and password. With that information, you can obtain a object and access all the functionality of a specific MongoDB database instance. Spring provides the interface, shown in the following listing, to bootstrap connectivity to the database: The following sections show how you can use the container with either Java-based or XML-based metadata to configure an instance of the interface. In turn, you can use the instance to configure . Instead of using the IoC container to create an instance of MongoTemplate, you can use them in standard Java code, as follows: The code in bold highlights the use of and is the only difference between the listing shown in the getting started section. Use when choosing as the entrypoint of choice. To register a instance with the container, you write code much like what was highlighted in the previous code listing. The following listing shows a simple example: MongoDB Server generation 3 changed the authentication model when connecting to the DB. Therefore, some of the configuration options available for authentication are no longer valid. You should use the -specific options for setting credentials through to provide authentication data, as shown in the following example: In order to use authentication with XML-based configuration, use the attribute on the element. Username and password credentials used in XML-based configuration must be URL-encoded when these contain reserved characters, such as , , , or . The following example shows encoded credentials: → See section 2.2 of RFC 3986 for further details. The namespace provides a convenient way to create a , as compared to using the namespace, as shown in the following example: If you need to configure additional options on the instance that is used to create a , you can refer to an existing bean by using the attribute as shown in the following example. To show another common usage pattern, the following listing shows the use of a property placeholder, which lets you parametrize the configuration and the creation of a : The class, located in the package, is the central class of Spring’s MongoDB support and provides a rich feature set for interacting with the database. The template offers convenience operations to create, update, delete, and query MongoDB documents and provides a mapping between your domain objects and MongoDB documents. Once configured, is thread-safe and can be reused across multiple instances. The mapping between MongoDB documents and domain classes is done by delegating to an implementation of the interface. Spring provides , but you can also write your own converter. See “Custom Conversions - Overriding Default Mapping” for more detailed information. The class implements the interface . In as much as possible, the methods on are named after methods available on the MongoDB driver object, to make the API familiar to existing MongoDB developers who are used to the driver API. For example, you can find methods such as , , , , , , , , and . The design goal was to make it as easy as possible to transition between the use of the base MongoDB driver and . A major difference between the two APIs is that can be passed domain objects instead of . Also, has fluent APIs for , , and operations instead of populating a to specify the parameters for those operations. The preferred way to reference the operations on instance is through its interface, . The default converter implementation used by is . While the can use additional metadata to specify the mapping of objects to documents, it can also convert objects that contain no additional metadata by using some conventions for the mapping of IDs and collection names. These conventions, as well as the use of mapping annotations, are explained in the “Mapping” chapter. Another central feature of is translation of exceptions thrown by the MongoDB Java driver into Spring’s portable Data Access Exception hierarchy. See “Exception Translation” for more information. offers many convenience methods to help you easily perform common tasks. However, if you need to directly access the MongoDB driver API, you can use one of several callback methods. The callbacks gives you a reference to either a or a object. See the “Execution Callbacks” section for more information. The next section contains an example of how to work with the in the context of the Spring container. You can use Java to create and register an instance of , as the following example shows: There are several overloaded constructors of :\n• : Takes the object and the default database name to operate against.\n• : Takes a MongoDbFactory object that encapsulated the object, database name, and username and password.\n• : Adds a to use for mapping. You can also configure a MongoTemplate by using Spring’s XML <beans/> schema, as the following example shows: Other optional properties that you might like to set when creating a are the default , , and properties. The preferred way to reference the operations on instance is through its interface, . When in development, it is handy to either log or throw an exception if the returned from any MongoDB operation contains an error. It is quite common to forget to do this during development and then end up with an application that looks like it runs successfully when, in fact, the database was not modified according to your expectations. You can set the property of to one of the following values: or , to either throw an or do nothing, respectively. The default is to use a value of . If it has not yet been specified through the driver at a higher level (such as ), you can set the property that the uses for write operations. If the property is not set, it defaults to the one set in the MongoDB driver’s DB or Collection setting. For more advanced cases where you want to set different values on a per-operation basis (for remove, update, insert, and save operations), a strategy interface called can be configured on . Since is used to persist POJOs, the lets you create a policy that can map a specific POJO class to a value. The following listing shows the interface: You can use the argument to determine the value or use the value of the Template itself as a default. contains the collection name being written to, the of the POJO, the converted , the operation ( , , , , or ), and a few other pieces of contextual information. The following example shows two sets of classes getting different settings: private class MyAppWriteConcernResolver implements WriteConcernResolver { public WriteConcern resolve(MongoAction action) { if (action.getEntityClass().getSimpleName().contains(\"Audit\")) { return WriteConcern.NONE; } else if (action.getEntityClass().getSimpleName().contains(\"Metadata\")) { return WriteConcern.JOURNAL_SAFE; } return action.getDefaultWriteConcern(); } } lets you save, update, and delete your domain objects and map those objects to documents stored in MongoDB. Consider the following class: public class Person { private String id; private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getId() { return id; } public String getName() { return name; } public int getAge() { return age; } @Override public String toString() { return \"Person [id=\" + id + \", name=\" + name + \", age=\" + age + \"]\"; } } Given the class in the preceding example, you can save, update and delete the object, as the following example shows: is the interface that implements. package org.spring.example; import static org.springframework.data.mongodb.core.query.Criteria.where; import static org.springframework.data.mongodb.core.query.Update.update; import static org.springframework.data.mongodb.core.query.Query.query; import java.util.List; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import org.springframework.data.mongodb.core.MongoOperations; import org.springframework.data.mongodb.core.MongoTemplate; import org.springframework.data.mongodb.core.SimpleMongoClientDbFactory; import com.mongodb.client.MongoClients; public class MongoApp { private static final Log log = LogFactory.getLog(MongoApp.class); public static void main(String[] args) { MongoOperations mongoOps = new MongoTemplate(new SimpleMongoClientDbFactory(MongoClients.create(), \"database\")); Person p = new Person(\"Joe\", 34); // Insert is used to initially store the object into the database. mongoOps.insert(p); log.info(\"Insert: \" + p); // Find p = mongoOps.findById(p.getId(), Person.class); log.info(\"Found: \" + p); // Update mongoOps.updateFirst(query(where(\"name\").is(\"Joe\")), update(\"age\", 35), Person.class); p = mongoOps.findOne(query(where(\"name\").is(\"Joe\")), Person.class); log.info(\"Updated: \" + p); // Delete mongoOps.remove(p); // Check that deletion worked List<Person> people = mongoOps.findAll(Person.class); log.info(\"Number of people = : \" + people.size()); mongoOps.dropCollection(Person.class); } } The preceding example would produce the following log output (including debug messages from ): DEBUG apping.MongoPersistentEntityIndexCreator: 80 - Analyzing class class org.spring.example.Person for index information. DEBUG work.data.mongodb.core.MongoTemplate: 632 - insert Document containing fields: [_class, age, name] in collection: person INFO org.spring.example.MongoApp: 30 - Insert: Person [id=4ddc6e784ce5b1eba3ceaf5c, name=Joe, age=34] DEBUG work.data.mongodb.core.MongoTemplate:1246 - findOne using query: { \"_id\" : { \"$oid\" : \"4ddc6e784ce5b1eba3ceaf5c\"}} in db.collection: database.person INFO org.spring.example.MongoApp: 34 - Found: Person [id=4ddc6e784ce5b1eba3ceaf5c, name=Joe, age=34] DEBUG work.data.mongodb.core.MongoTemplate: 778 - calling update using query: { \"name\" : \"Joe\"} and update: { \"$set\" : { \"age\" : 35}} in collection: person DEBUG work.data.mongodb.core.MongoTemplate:1246 - findOne using query: { \"name\" : \"Joe\"} in db.collection: database.person INFO org.spring.example.MongoApp: 39 - Updated: Person [id=4ddc6e784ce5b1eba3ceaf5c, name=Joe, age=35] DEBUG work.data.mongodb.core.MongoTemplate: 823 - remove using query: { \"id\" : \"4ddc6e784ce5b1eba3ceaf5c\"} in collection: person INFO org.spring.example.MongoApp: 46 - Number of people = : 0 DEBUG work.data.mongodb.core.MongoTemplate: 376 - Dropped collection [database.person] caused implicit conversion between a and an stored in the database by recognizing (through convention) the property name. The preceding example is meant to show the use of save, update, and remove operations on and not to show complex mapping functionality. The query syntax used in the preceding example is explained in more detail in the section “Querying Documents”. 9.5.1. How the Field is Handled in the Mapping Layer MongoDB requires that you have an field for all documents. If you do not provide one, the driver assigns an with a generated value. When you use the , certain rules govern how properties from the Java class are mapped to this field:\n• A property or field annotated with ( ) maps to the field.\n• A property or field without an annotation but named maps to the field. The following outlines what type conversion, if any, is done on the property mapped to the document field when using the (the default for ).\n• If possible, an property or field declared as a in the Java class is converted to and stored as an by using a Spring . Valid conversion rules are delegated to the MongoDB Java driver. If it cannot be converted to an , then the value is stored as a string in the database.\n• An property or field declared as in the Java class is converted to and stored as an by using a Spring . If no field or property specified in the previous sets of rules is present in the Java class, an implicit file is generated by the driver but not mapped to a property or field of the Java class. When querying and updating, uses the converter that corresponds to the preceding rules for saving documents so that field names and types used in your queries can match what is in your domain classes. Some environments require a customized approach to map values such as data stored in MongoDB that did not run through the Spring Data mapping layer. Documents can contain values that can be represented either as or as . Reading documents from the store back to the domain type works just fine. Querying for documents via their can be cumbersome due to the implicit conversion. Therefore documents cannot be retrieved that way. For those cases provides more control over the actual id mapping attempts. The id is treated as without further conversion. The id is treated as . The id is treated as if the given is a valid hex, otherwise as . Corresponds to usage. MongoDB collections can contain documents that represent instances of a variety of types.This feature can be useful if you store a hierarchy of classes or have a class with a property of type .In the latter case, the values held inside that property have to be read in correctly when retrieving the object.Thus, we need a mechanism to store type information alongside the actual document. To achieve that, the uses a abstraction with as its main implementation.Its default behavior to store the fully qualified classname under inside the document.Type hints are written for top-level documents as well as for every value (if it is a complex type and a subtype of the declared property type).The following example (with a JSON representation at the end) shows how the mapping works: public class Sample { Contact value; } public abstract class Contact { … } public class Person extends Contact { … } Sample sample = new Sample(); sample.value = new Person(); mongoTemplate.save(sample); { \"value\" : { \"_class\" : \"com.acme.Person\" }, \"_class\" : \"com.acme.Sample\" } Spring Data MongoDB stores the type information as the last field for the actual root class as well as for the nested type (because it is complex and a subtype of ).So, if you now use , you can find out that the document stored is a instance.You can also find out that the value property is actually a . If you want to avoid writing the entire Java class name as type information but would rather like to use a key, you can use the annotation on the entity class.If you need to customize the mapping even more, have a look at the interface.An instance of that interface can be configured at the , which can, in turn, be configured on .The following example shows how to define a type alias for an entity: Example 11. Defining a type alias for an Entity Note that the resulting document contains as the value in the Field. Type aliases only work if the mapping context is aware of the actual type. The required entity metadata is determined either on first save or has to be provided via the configurations initial entity set. By default, the configuration class scans the base package for potential candidates. The following example shows how to configure a custom in : Note that the preceding example extends the class and overrides the bean definition of the where we configured our custom . The following example shows how to use XML to configure a custom : There are several convenient methods on for saving and inserting your objects. To have more fine-grained control over the conversion process, you can register Spring converters with the — for example and . The difference between insert and save operations is that a save operation performs an insert if the object is not already present. The simple case of using the save operation is to save a POJO. In this case, the collection name is determined by name (not fully qualified) of the class. You may also call the save operation with a specific collection name. You can use mapping metadata to override the collection in which to store the object. When inserting or saving, if the property is not set, the assumption is that its value will be auto-generated by the database. Consequently, for auto-generation of an to succeed, the type of the property or field in your class must be a , an , or a . The following example shows how to save a document and retrieving its contents: Example 14. Inserting and retrieving documents using the MongoTemplate The following insert and save operations are available:\n• save : Save the object to the default collection.\n• save : Save the object to the specified collection. A similar set of insert operations is also available:\n• insert : Insert the object to the default collection.\n• insert : Insert the object to the specified collection. Into Which Collection Are My Documents Saved? There are two ways to manage the collection name that is used for the documents. The default collection name that is used is the class name changed to start with a lower-case letter. So a class is stored in the collection. You can customize this by providing a different collection name with the annotation. You can also override the collection name by providing your own collection name as the last parameter for the selected method calls. The MongoDB driver supports inserting a collection of documents in a single operation. The following methods in the interface support this functionality:\n• insert: Inserts an object. If there is an existing document with the same , an error is generated.\n• insertAll: Takes a of objects as the first parameter. This method inspects each object and inserts it into the appropriate collection, based on the rules specified earlier.\n• save: Saves the object, overwriting any object that might have the same . The MongoDB driver supports inserting a collection of documents in one operation. The following methods in the interface support this functionality:\n• insert methods: Take a as the first argument. They insert a list of objects in a single batch write to the database. For updates, you can update the first document found by using or you can update all documents that were found to match the query by using the method. The following example shows an update of all accounts where we are adding a one-time $50.00 bonus to the balance by using the operator: Example 15. Updating documents by using the In addition to the discussed earlier, we provide the update definition by using an object. The class has methods that match the update modifiers available for MongoDB. Most methods return the object to provide a fluent style for the API.\n• updateFirst: Updates the first document that matches the query document criteria with the updated document.\n• updateMulti: Updates all objects that match the query document criteria with the updated document. does not support ordering. Please use findAndModify to apply . You can use a little \"'syntax sugar'\" with the class, as its methods are meant to be chained together. Also, you can kick-start the creation of a new instance by using and using static imports. The class contains the following methods:\n• currentTimestamp Update using the update modifier with\n• inc Update using the update modifier Some update modifiers, such as and , allow nesting of additional operators. // { $push : { \"category\" : { \"$each\" : [ \"spring\" , \"data\" ] } } } new Update().push(\"category\").each(\"spring\", \"data\") // { $push : { \"key\" : { \"$position\" : 0 , \"$each\" : [ \"Arya\" , \"Arry\" , \"Weasel\" ] } } } new Update().push(\"key\").atPosition(Position.FIRST).each(Arrays.asList(\"Arya\", \"Arry\", \"Weasel\")); // { $push : { \"key\" : { \"$slice\" : 5 , \"$each\" : [ \"Arya\" , \"Arry\" , \"Weasel\" ] } } } new Update().push(\"key\").slice(5).each(Arrays.asList(\"Arya\", \"Arry\", \"Weasel\")); // { $addToSet : { \"values\" : { \"$each\" : [ \"spring\" , \"data\" , \"mongodb\" ] } } } new Update().addToSet(\"values\").each(\"spring\", \"data\", \"mongodb\"); Related to performing an operation, you can also perform an “upsert” operation, which will perform an insert if no document is found that matches the query. The document that is inserted is a combination of the query document and the update document. The following example shows how to use the method: does not support ordering. Please use findAndModify to apply . The method on can update a document and return either the old or newly updated document in a single operation. provides four overloaded methods that take and classes and converts from to your POJOs: The following example inserts a few objects into the container and performs a operation: template.insert(new Person(\"Tom\", 21)); template.insert(new Person(\"Dick\", 22)); template.insert(new Person(\"Harry\", 23)); Query query = new Query(Criteria.where(\"firstName\").is(\"Harry\")); Update update = new Update().inc(\"age\", 1); Person oldValue = template.update(Person.class) .matching(query) .apply(update) .findAndModifyValue(); // return's old person object assertThat(oldValue.getFirstName()).isEqualTo(\"Harry\"); assertThat(oldValue.getAge()).isEqualTo(23); Person newValue = template.query(Person.class) .matching(query) .findOneValue(); assertThat(newValue.getAge()).isEqualTo(24); Person newestValue = template.update(Person.class) .matching(query) .apply(update) .withOptions(FindAndModifyOptions.options().returnNew(true)) // Now return the newly updated document when updating .findAndModifyValue(); assertThat(newestValue.getAge()).isEqualTo(25); The method lets you set the options of , , and .An example extending from the previous code snippet follows: Update methods exposed by and also accept an Aggregation Pipeline via . Using allows leveraging MongoDB 4.2 aggregations in an update operation. Using aggregations in an update allows updating one or more fields by expressing multiple stages and multiple conditions with a single operation. The update can consist of the following stages: db.students.update( (3) { }, [ { $set: { average : { $avg: \"$tests\" } } }, (1) { $set: { grade: { $switch: { (2) branches: [ { case: { $gte: [ \"$average\", 90 ] }, then: \"A\" }, { case: { $gte: [ \"$average\", 80 ] }, then: \"B\" }, { case: { $gte: [ \"$average\", 70 ] }, then: \"C\" }, { case: { $gte: [ \"$average\", 60 ] }, then: \"D\" } ], default: \"F\" } } } } ], { multi: true } (4) ) The 1st stage calculates a new field average based on the average of the tests field. The 2nd stage calculates a new field grade based on the average field calculated by the first aggregation stage. The pipeline is run on the students collection and uses for the aggregation field mapping. Apply the update to all matching documents in the collection. The most straight forward method of replacing an entire is via its using the method. However this might not always be feasible. offers an alternative that allows to identify the document to replace via a simple query. Use the fluent update API with the domain type given for mapping the query and deriving the collection name or just use . The actual match query mapped against the given domain type. Provide , and settings via the query. Additional optional hook to provide options other than the defaults, like . An optional projection type used for mapping the operation result. If none given the initial domain type is used. Trigger the actual processing. Use to obtain the nullable result instead of an . Please note that the replacement must not hold an itself as the of the existing will be carried over to the replacement by the store itself. Also keep in mind that will only replace the first document matching the query criteria depending on a potentially given sort order. You can use one of five overloaded methods to remove an object from the database: template.remove(tywin, \"GOT\"); (1) template.remove(query(where(\"lastname\").is(\"lannister\")), \"GOT\"); (2) template.remove(new Query().limit(3), \"GOT\"); (3) template.findAllAndRemove(query(where(\"lastname\").is(\"lannister\"), \"GOT\"); (4) template.findAllAndRemove(new Query().limit(3), \"GOT\"); (5) Remove a single entity specified by its from the associated collection. Remove all documents that match the criteria of the query from the collection. Remove the first three documents in the collection. Unlike <2>, the documents to remove are identified by their , running the given query, applying , , and options first, and then removing all at once in a separate step. Remove all documents matching the criteria of the query from the collection. Unlike <3>, documents do not get deleted in a batch but one by one. Remove the first three documents in the collection. Unlike <3>, documents do not get deleted in a batch but one by one. The annotation provides syntax similar to that of JPA in the context of MongoDB and makes sure updates are only applied to documents with a matching version. Therefore, the actual value of the version property is added to the update query in such a way that the update does not have any effect if another operation altered the document in the meantime. In that case, an is thrown. The following example shows these features: Load the just inserted document. is still . Update the document with . Set the and bump to . Try to update the previously loaded document that still has . The operation fails with an , as the current is . Optimistic Locking requires to set the to . Otherwise can be silently swallowed. As of Version 2.2 also includes the property when removing an entity from the database. To remove a without version check use instead of . As of Version 2.2 repositories check for the outcome of acknowledged deletes when removing versioned entities. An is raised if a versioned entity cannot be deleted through . In such case, the version was changed or the object was deleted in the meantime. Use to bypass optimistic locking functionality and delete objects regardless of their version. You can use the and classes to express your queries.They have method names that mirror the native MongoDB operator names, such as , , , and others.The and classes follow a fluent API style so that you can chain together multiple method criteria and queries while having easy-to-understand code.To improve readability, static imports let you avoid using the 'new' keyword for creating and instances.You can also use to create instances from plain JSON Strings, as shown in the following example: Spring MongoDB also supports GeoSpatial queries (see the GeoSpatial Queries section) and Map-Reduce operations (see the Map-Reduce section.). Earlier, we saw how to retrieve a single document by using the and methods on . These methods return a single domain object. We can also query for a collection of documents to be returned as a list of domain objects. Assuming that we have a number of objects with name and age stored as documents in a collection and that each person has an embedded account document with a balance, we can now run a query using the following code: Example 19. Querying for documents using the MongoTemplate All find methods take a object as a parameter. This object defines the criteria and options used to perform the query. The criteria are specified by using a object that has a static factory method named to instantiate a new object. We recommend using static imports for and to make the query more readable. The query should return a list of objects that meet the specified criteria. The rest of this section lists the methods of the and classes that correspond to the operators provided in MongoDB. Most methods return the object, to provide a fluent style for the API. The class provides the following methods, all of which correspond to operators in MongoDB:\n• all Creates a criterion using the operator\n• and Adds a chained with the specified to the current and returns the newly created one\n• andOperator Creates an and query using the operator for all of the provided criteria (requires MongoDB 2.0 or later)\n• andOperator Creates an and query using the operator for all of the provided criteria (requires MongoDB 2.0 or later)\n• in Creates a criterion using the operator for a varargs argument.\n• in Creates a criterion using the operator using a collection\n• is Creates a criterion using field matching ( ). If the specified value is a document, the order of the fields and exact equality in the document matters.\n• norOperator Creates an nor query using the operator for all of the provided criteria\n• norOperator Creates an nor query using the operator for all of the provided criteria\n• not Creates a criterion using the meta operator which affects the clause directly following\n• orOperator Creates an or query using the operator for all of the provided criteria\n• orOperator Creates an or query using the operator for all of the provided criteria\n• matchingDocumentStructure Creates a criterion using the operator for JSON schema criteria. can only be applied on the top level of a query and not property specific. Use the attribute of the schema to match against nested fields.\n• bits() is the gateway to MongoDB bitwise query operators like . The Criteria class also provides the following methods for geospatial queries (see the GeoSpatial Queries section to see them in action):\n• nearSphere Creates a geospatial criterion using operations. This is only available for MongoDB 1.7 and higher.\n• minDistance Creates a geospatial criterion using the operation, for use with $near.\n• maxDistance Creates a geospatial criterion using the operation, for use with $near. The class has some additional methods that provide options for the query:\n• addCriteria used to add additional criteria to the query\n• fields used to define fields to be included in the query results\n• limit used to limit the size of the returned results to the provided limit (used for paging)\n• skip used to skip the provided number of documents in the results (used for paging)\n• with used to provide sort definition for the results MongoDB supports projecting fields returned by a query. A projection can include and exclude fields (the field is always included unless explicitly excluded) based on their name. Result will contain both and via . Result will only contain the via . Result will contain the and entire object via . Result will contain the and and object that only contains the field via . Starting with MongoDB 4.4 you can use aggregation expressions for field projections as shown below: Use a native expression. The used field name must refer to field names within the database document. Assign the field name to which the expression result is projected. The resulting field name is not mapped against the domain model. Use an . Other than native , field names are mapped to the ones used in the domain model. Use SpEL along with an to invoke expression functions. Field names are mapped to the ones used in the domain model. allows usage of expression field projections at level as described in MongoDB JSON-based Query Methods and Field Restriction. The query methods need to specify the target type that is returned, and they are overloaded with an explicit collection name for queries that should operate on a collection other than the one indicated by the return type. The following query methods let you find one or more documents:\n• findAll: Query for a list of objects of type from the collection.\n• findOne: Map the results of an ad-hoc query on the collection to a single instance of an object of the specified type.\n• findById: Return an object of the given ID and target class.\n• find: Map the results of an ad-hoc query on the collection to a of the specified type.\n• findAndRemove: Map the results of an ad-hoc query on the collection to a single instance of an object of the specified type. The first document that matches the query is returned and removed from the collection in the database. MongoDB provides an operation to obtain distinct values for a single field by using a query from the resulting documents. Resulting values are not required to have the same data type, nor is the feature limited to simple types. For retrieval, the actual result type does matter for the sake of conversion and typing. The following example shows how to query for distinct values: Select distinct values of the field. The field name is mapped according to the domain types property declaration, taking potential annotations into account. Retrieve all distinct values as a of (due to no explicit result type being specified). Retrieving distinct values into a of is the most flexible way, as it tries to determine the property value of the domain type and convert results to the desired type or mapping structures. Sometimes, when all values of the desired field are fixed to a certain type, it is more convenient to directly obtain a correctly typed , as shown in the following example: Select distinct values of the field. The fieldname is mapped according to the domain types property declaration, taking potential annotations into account. Retrieved values are converted into the desired target type — in this case, . It is also possible to map the values to a more complex type if the stored field contains a document. Retrieve all distinct values as a of . If the type cannot be converted into the desired target type, this method throws a . MongoDB supports GeoSpatial queries through the use of operators such as , , , and . Methods specific to geospatial queries are available on the class. There are also a few shape classes ( , , and ) that are used in conjunction with geospatial related methods. Using GeoSpatial queries requires attention when used within MongoDB transactions, see Special behavior inside transactions. To understand how to perform GeoSpatial queries, consider the following class (taken from the integration tests and relying on the rich ): @Document(collection=\"newyork\") public class Venue { @Id private String id; private String name; private double[] location; @PersistenceConstructor Venue(String name, double[] location) { super(); this.name = name; this.location = location; } public Venue(String name, double x, double y) { super(); this.name = name; this.location = new double[] { x, y }; } public String getName() { return name; } public double[] getLocation() { return location; } @Override public String toString() { return \"Venue [id=\" + id + \", name=\" + name + \", location=\" + Arrays.toString(location) + \"]\"; } } To find locations within a , you can use the following query: To find venues within a using spherical coordinates, you can use the following query: To find venues within a , you can use the following query: //lower-left then upper-right Box box = new Box(new Point(-73.99756, 40.73083), new Point(-73.988135, 40.741404)); List<Venue> venues = template.find(new Query(Criteria.where(\"location\").within(box)), Venue.class); To find venues near a , you can use the following queries: To find venues near a using spherical coordinates, you can use the following query: Changed in 2.2!\n\n MongoDB 4.2 removed support for the command which had been previously used to run the . Spring Data MongoDB 2.2 uses the aggregation instead of the command to run a . The calculated distance (the when using a geoNear command) previously returned within a wrapper type now is embedded into the resulting document. If the given domain type already contains a property with that name, the calculated distance is named with a potentially random postfix. Target types may contain a property named after the returned distance to (additionally) read it back directly into the domain type as shown below. Domain type used to identify the target collection and potential query mapping. MongoDB supports querying the database for geo locations and calculating the distance from a given origin at the same time. With geo-near queries, you can express queries such as \"find all restaurants in the surrounding 10 miles\". To let you do so, provides methods that take a as an argument (as well as the already familiar entity type and collection), as shown in the following example: We use the builder API to set up a query to return all instances surrounding the given out to 10 miles. The enum used here actually implements an interface so that other metrics could be plugged into a distance as well. A is backed by a multiplier to transform the distance value of the given metric into native distances. The sample shown here would consider the 10 to be miles. Using one of the built-in metrics (miles and kilometers) automatically triggers the spherical flag to be set on the query. If you want to avoid that, pass plain values into . For more information, see the JavaDoc of and . The geo-near operations return a wrapper object that encapsulates instances. Wrapping allows accessing the average distance of all results. A single object carries the entity found plus its distance from the origin. MongoDB supports GeoJSON and simple (legacy) coordinate pairs for geospatial data. Those formats can both be used for storing as well as querying data. See the MongoDB manual on GeoJSON support to learn about requirements and restrictions. Usage of GeoJSON types in domain classes is straightforward. The package contains types such as , , and others. These types are extend the existing types. The following example uses a : Using GeoJSON types as repository query parameters forces usage of the operator when creating the query, as the following example shows: public interface StoreRepository extends CrudRepository<Store, String> { List<Store> findByLocationWithin(Polygon polygon); (1) } /* * { * \"location\": { * \"$geoWithin\": { * \"$geometry\": { * \"type\": \"Polygon\", * \"coordinates\": [ * [ * [-73.992514,40.758934], * [-73.961138,40.760348], * [-73.991658,40.730006], * [-73.992514,40.758934] * ] * ] * } * } * } * } */ repo.findByLocationWithin( (2) new GeoJsonPolygon( new Point(-73.992514, 40.758934), new Point(-73.961138, 40.760348), new Point(-73.991658, 40.730006), new Point(-73.992514, 40.758934))); (3) /* * { * \"location\" : { * \"$geoWithin\" : { * \"$polygon\" : [ [-73.992514,40.758934] , [-73.961138,40.760348] , [-73.991658,40.730006] ] * } * } * } */ repo.findByLocationWithin( (4) new Polygon( new Point(-73.992514, 40.758934), new Point(-73.961138, 40.760348), new Point(-73.991658, 40.730006))); Repository method definition using the commons type allows calling it with both the GeoJSON and the legacy format. Use GeoJSON type to make use of operator. Note that GeoJSON polygons need to define a closed ring. Then MongoDB operator allows usage of a GeoJSON Point or legacy coordinate pairs. Though syntactically different the server is fine accepting both no matter what format the target Document within the collection is using. There is a huge difference in the distance calculation. Using the legacy format operates upon Radians on an Earth like sphere, whereas the GeoJSON format uses Meters. To avoid a serious headache make sure to set the to the desired unit of measure which ensures the distance to be calculated correctly. Assume you’ve got 5 Documents like the ones below: { \"_id\" : ObjectId(\"5c10f3735d38908db52796a5\"), \"name\" : \"Penn Station\", \"location\" : { \"type\" : \"Point\", \"coordinates\" : [ -73.99408, 40.75057 ] } } { \"_id\" : ObjectId(\"5c10f3735d38908db52796a6\"), \"name\" : \"10gen Office\", \"location\" : { \"type\" : \"Point\", \"coordinates\" : [ -73.99171, 40.738868 ] } } { \"_id\" : ObjectId(\"5c10f3735d38908db52796a9\"), \"name\" : \"City Bakery \", \"location\" : { \"type\" : \"Point\", \"coordinates\" : [ -73.992491, 40.738673 ] } } { \"_id\" : ObjectId(\"5c10f3735d38908db52796aa\"), \"name\" : \"Splash Bar\", \"location\" : { \"type\" : \"Point\", \"coordinates\" : [ -73.992491, 40.738673 ] } } { \"_id\" : ObjectId(\"5c10f3735d38908db52796ab\"), \"name\" : \"Momofuku Milk Bar\", \"location\" : { \"type\" : \"Point\", \"coordinates\" : [ -73.985839, 40.731698 ] } } Fetching all Documents within a 400 Meter radius from would look like this using GeoJSON: { \"_id\" : ObjectId(\"5c10f3735d38908db52796a6\"), \"name\" : \"10gen Office\", \"location\" : { \"type\" : \"Point\", \"coordinates\" : [ -73.99171, 40.738868 ] } \"distance\" : 0.0 (3) } { \"_id\" : ObjectId(\"5c10f3735d38908db52796a9\"), \"name\" : \"City Bakery \", \"location\" : { \"type\" : \"Point\", \"coordinates\" : [ -73.992491, 40.738673 ] } \"distance\" : 69.3582262492474 (3) } { \"_id\" : ObjectId(\"5c10f3735d38908db52796aa\"), \"name\" : \"Splash Bar\", \"location\" : { \"type\" : \"Point\", \"coordinates\" : [ -73.992491, 40.738673 ] } \"distance\" : 69.3582262492474 (3) } Now, when using legacy coordinate pairs one operates upon Radians as discussed before. So we use command. The makes sure the distance multiplier is set correctly. Returning the 3 Documents just like the GeoJSON variant: { \"_id\" : ObjectId(\"5c10f3735d38908db52796a6\"), \"name\" : \"10gen Office\", \"location\" : { \"type\" : \"Point\", \"coordinates\" : [ -73.99171, 40.738868 ] } \"distance\" : 0.0 (4) } { \"_id\" : ObjectId(\"5c10f3735d38908db52796a9\"), \"name\" : \"City Bakery \", \"location\" : { \"type\" : \"Point\", \"coordinates\" : [ -73.992491, 40.738673 ] } \"distance\" : 0.0693586286032982 (4) } { \"_id\" : ObjectId(\"5c10f3735d38908db52796aa\"), \"name\" : \"Splash Bar\", \"location\" : { \"type\" : \"Point\", \"coordinates\" : [ -73.992491, 40.738673 ] } \"distance\" : 0.0693586286032982 (4) } The distance multiplier so we get Kilometers as resulting distance. Make sure we operate on a 2d_sphere index. Distance from center point in Kilometers - take it times 1000 to match Meters of the GeoJSON variant. By using the [core.web], Spring Data registers additional Jackson s to the for de-/serializing common Spring Data domain types. Please refer to the [core.web.basic.jackson-mappers] section to learn more about the infrastructure setup of this feature. The MongoDB module additionally registers s for the following GeoJSON types via its exposing the . The only registers s!\n\n To equip the with a symmetric set of s you need to either manually configure those for the or provide a custom configuration exposing as a Spring Bean. The next major version ( ) will register both, s and s for GeoJSON types by default. Since version 2.6 of MongoDB, you can run full-text queries by using the operator. Methods and operations specific to full-text queries are available in and . When doing full text search, see the MongoDB reference for its behavior and limitations. Before you can actually use full-text search, you must set up the search index correctly. See Text Index for more detail on how to create index structures. The following example shows how to set up a full-text search: A query searching for can be defined and run as follows: To sort results by relevance according to the use . Use the score property for sorting results by relevance which triggers . Use to include the calculated relevance in the resulting . You can exclude search terms by prefixing the term with or by using , as shown in the following example (note that the two lines have the same effect and are thus redundant): // search for 'coffee' and not 'cake' TextQuery.queryText(new TextCriteria().matching(\"coffee\").matching(\"-cake\")); TextQuery.queryText(new TextCriteria().matching(\"coffee\").notMatching(\"cake\")); takes the provided term as is. Therefore, you can define phrases by putting them between double quotation marks (for example, or using by The following example shows both ways of defining a phrase: You can set flags for and by using the corresponding methods on . Note that these two optional flags have been introduced in MongoDB 3.2 and are not included in the query unless explicitly set. Since version 3.4, MongoDB supports collations for collection and index creation and various query operations. Collations define string comparison rules based on the ICU collations. A collation document consists of various properties that are encapsulated in , as the following listing shows: requires a locale for creation. This can be either a string representation of the locale, a (considering language, country, and variant) or a . The locale is mandatory for creation. Collation strength defines comparison levels that denote differences between characters. You can configure various options (case-sensitivity, case-ordering, and others), depending on the selected strength. Specify whether to compare numeric strings as numbers or as strings. Specify whether the collation should consider whitespace and punctuation as base characters for purposes of comparison. Specify whether strings with diacritics sort from back of the string, such as with some French dictionary ordering. Specify whether to check whether text requires normalization and whether to perform normalization. Collations can be used to create collections and indexes. If you create a collection that specifies a collation, the collation is applied to index creation and queries unless you specify a different collation. A collation is valid for a whole operation and cannot be specified on a per-field basis. Like other metadata, collations can be be derived from the domain type via the attribute of the annotation and will be applied directly when running queries, creating collections or indexes. Annotated collations will not be used when a collection is auto created by MongoDB on first interaction. This would require additional store interaction delaying the entire process. Please use for those cases. MongoDB uses simple binary comparison if no collation is specified ( ). Using collations with collection operations is a matter of specifying a instance in your query or operation options, as the following two examples show: Example 28. Using collation with Example 29. Using collation with Indexes are only used if the collation used for the operation matches the index collation. MongoDB Repositories support via the attribute of the annotation. Dynamic collation depending on 2nd method argument. Allowed types include (eg. 'en_US'), (eg. Locacle.US) and (eg. new Document(\"locale\", \"en_US\")) Apply the method parameter to the query. The method parameter overrides the default from if not null. In case you enabled the automatic index creation for repository finder methods a potential static collation definition, as shown in (1) and (2), will be included when creating the index. The most specifc outroules potentially defined others. Which means Method argument over query method annotation over doamin type annotation. As of version 3.6, MongoDB supports collections that validate documents against a provided JSON Schema. The schema itself and both validation action and level can be defined when creating the collection, as the following example shows: JSON schema documents always describe a whole document from its root. A schema is a schema object itself that can contain embedded schema objects that describe properties and subdocuments. is a property that describes which properties are required in a document. It can be specified optionally, along with other schema constraints. See MongoDB’s documentation on available keywords. is related to a schema object that describes an type. It contains property-specific schema constraints. specifies constraints for the field inside the document. Here, it is a string-based element declaring possible field values. is a subdocument defining a schema for values in its field. You can provide a schema either by specifying a schema document (that is, by using the API to parse or build a document object) or by building it with Spring Data’s JSON schema utilities in . is the entry point for all JSON schema-related operations. The following example shows how use to create a JSON schema: Obtain a schema builder to configure the schema with a fluent API. Configure required properties either directly as shown here or with more details as in 3. Configure the required String-typed field, allowing only and values. Properties can be typed or untyped. Use a static import of to make the syntax slightly more compact and to get entry points such as . Build the schema object. Use the schema to create either a collection or query documents. There are already some predefined and strongly typed schema objects ( and ) available through static methods on the gateway interfaces. However, you may need to build custom property validation rules, which can be created through the builder API, as the following example shows: // \"birthdate\" : { \"bsonType\": \"date\" } JsonSchemaProperty.named(\"birthdate\").ofType(Type.dateType()); // \"birthdate\" : { \"bsonType\": \"date\", \"description\", \"Must be a date\" } JsonSchemaProperty.named(\"birthdate\").with(JsonSchemaObject.of(Type.dateType()).description(\"Must be a date\")); provides the entry point to schema support for collections, as the following example shows: Setting up a schema can be a time consuming task and we encourage everyone who decides to do so, to really take the time it takes. It’s important, schema changes can be hard. However, there might be times when one does not want to balked with it, and that is where comes into play. and its default implementation generates a out of domain types metadata provided by the mapping infrastructure. This means, that annotated properties as well as potential custom conversions are considered. Enums are restricted to possible values. Object type properties are inspected and represented as nested documents. type property that is converted to by the converter. properties are omitted when generating the schema. properties using types that can be converted into like are mapped to unless there is more specific information available via the annotation. with if metadata available. with property holding the possible enumeration values. You can use a schema to query any collection for documents that match a given structure defined by a JSON schema, as the following example shows: Properties can be wrapped within an encrypted property when setting up the JSON Schema as shown in the example below. Instead of defining encrypted fields manually it is possible leverage the annotation as shown in the snippet below. Default encryption settings that will be set for . The Annoation supports resolving keyIds via SpEL Expressions. To do so additional environment metadata (via the ) is required and must be provided. The function is defined via an as shown in the snippet below. Providing a custom extension provides the most flexible way of computing keyIds. public class EncryptionExtension implements EvaluationContextExtension { @Override public String getExtensionId() { return \"mongocrypt\"; } @Override public Map<String, Function> getFunctions() { return Collections.singletonMap(\"keyId\", new Function(getMethod(\"computeKeyId\", String.class), this)); } public String computeKeyId(String target) { // ... lookup via target element name } } To combine derived encryption settings with in a Spring Boot application use the . Make sure to set the drivers to use client-side encryption. MongoDB does not support encryption for all field types. Specific data types require deterministic encryption to preserve equality comparison functionality. The following table shows the supported JSON schema types: is a generic type that is inherited by all typed schema types. It provides all schema properties to typed schema types. For more information, see $jsonSchema. The interface is one of the central components when it comes to more low-level interaction with MongoDB. It offers a wide range of methods covering needs from collection creation, index creation, and CRUD operations to more advanced functionality, such as Map-Reduce and aggregations. You can find multiple overloads for each method. Most of them cover optional or nullable parts of the API. provides a more narrow interface for the common methods of and provides a more readable, fluent API. The entry points ( , , , and others) follow a natural naming schema based on the operation to be run. Moving on from the entry point, the API is designed to offer only context-dependent methods that lead to a terminating method that invokes the actual counterpart — the method in the case of the following example: Skip this step if defines the collection with or if you use the class name as the collection name, which is fine. Sometimes, a collection in MongoDB holds entities of different types, such as a within a collection of . To use different types for and return value mapping, you can use to map results differently, as the following example shows: The query fields are mapped against the type. You can directly apply [projections] to result documents by providing the target type via . Using projections allows to optimize result mapping by limiting the actual response to fields required by the projection target type. This applies as long as the itself does not contain any field restriction and the target type is a closed interface or DTO projection. You can switch between retrieving a single entity and retrieving multiple entities as a or a through the terminating methods: , , , or . When writing a geo-spatial query with , the number of terminating methods is altered to include only the methods that are valid for running a command in MongoDB (fetching entities as a within ), as the following example shows: Kotlin embraces domain-specific language creation through its language syntax and its extension system. Spring Data MongoDB ships with a Kotlin Extension for using Kotlin property references to build type-safe queries. Queries using this extension are typically benefit from improved readability. Most keywords on have a matching Kotlin extension, such as and . Consider the following example explaining Type-safe Queries: is an infix extension function with receiver type that returns . For bitwise operators, pass a lambda argument where you call one of the methods of . To construct nested properties, use the character (overloaded operator ). MongoDB offers various ways of applying meta information, like a comment or a batch size, to a query.Using the API directly there are several methods for those options. The comment propagated to the MongoDB profile log. The number of documents to return in each response batch. On the repository level the annotation provides means to add query options in a declarative way. The following example shows how to query by example when using a repository (of objects, in this case): Example 38. Query by Example using a repository An containing an untyped uses the Repository type and its collection name. Typed instances use their type as the result type and the collection name from the instance. When including values in the , Spring Data Mongo uses embedded document matching instead of dot notation property matching. Doing so forces exact document matching for all property values and the property order in the embedded document. Spring Data MongoDB provides support for the following matching options: By default is strictly typed. This means that the mapped query has an included type match, restricting it to probe assignable types. For example, when sticking with the default type key ( ), the query has restrictions such as ( ). By using the , it is possible to bypass the default behavior and skip the type restriction. So, as long as field names match, nearly any domain type can be used as the probe for creating the reference, as the following example shows: class JustAnArbitraryClassWithMatchingFieldName { @Field(\"lastname\") String value; } JustAnArbitraryClassWithMatchingFieldNames probe = new JustAnArbitraryClassWithMatchingFieldNames(); probe.value = \"stark\"; Example example = Example.of(probe, UntypedExampleMatcher.matching()); Query query = new Query(new Criteria().alike(example)); List<Person> result = template.find(query, Person.class); is likely the right choice for you if you are storing different entities within a single collection or opted out of writing type hints. Also, keep in mind that using requires eager initialization of the . To do so, configure to to ensure proper alias resolution for read operations. In pre-3.x versions of SpringData MongoDB the count operation used MongoDBs internal collection statistics. With the introduction of MongoDB Transactions this was no longer possible because statistics would not correctly reflect potential changes during a transaction requiring an aggregation-based count approach. So in version 2.x would use the collection statistics if no transaction was in progress, and the aggregation variant if so. As of Spring Data MongoDB 3.x any operation uses regardless the existence of filter criteria the aggregation-based count approach via MongoDBs . If the application is fine with the limitations of working upon collection statistics offers an alternative. MongoDBs native method and the aggregation, do not support and but require along with or which does not support (see https://jira.mongodb.org/browse/SERVER-37043). Therefore a given will be rewritten for operations using -/ to bypass the issue like shown below. { location : { $near : [-73.99171, 40.738868], $maxDistance : 1.1 } } (1) { location : { $geoWithin : { $center: [ [-73.99171, 40.738868], 1.1] } } } (2) { location : { $near : [-73.99171, 40.738868], $minDistance : 0.1, $maxDistance : 1.1 } } (3) {$and :[ { $nor :[ { location :{ $geoWithin :{ $center :[ [-73.99171, 40.738868 ], 0.01] } } } ]}, { location :{ $geoWithin :{ $center :[ [-73.99171, 40.738868 ], 1.1] } } } ] } (4) Rewritten query now using with . Count source query using with and . Rewritten query now a combination of critierias to work around unsupported . You can query MongoDB by using Map-Reduce, which is useful for batch processing, for data aggregation, and for when the query language does not fulfill your needs. Spring provides integration with MongoDB’s Map-Reduce by providing methods on to simplify the creation and running of Map-Reduce operations.It can convert the results of a Map-Reduce operation to a POJO and integrates with Spring’s Resource abstraction.This lets you place your JavaScript files on the file system, classpath, HTTP server, or any other Spring Resource implementation and then reference the JavaScript resources through an easy URI style syntax — for example, .Externalizing JavaScript code in files is often preferable to embedding them as Java strings in your code.Note that you can still pass JavaScript code as Java strings if you prefer. To understand how to perform Map-Reduce operations, we use an example from the book, MongoDB - The Definitive Guide .In this example, we create three documents that have the values [a,b], [b,c], and [c,d], respectively.The values in each document are associated with the key, 'x', as the following example shows (assume these documents are in a collection named ): The following map function counts the occurrence of each letter in the array for each document: The follwing reduce function sums up the occurrence of each letter across all the documents: Running the preceding functions result in the following collection: { \"_id\" : \"a\", \"value\" : 1 } { \"_id\" : \"b\", \"value\" : 2 } { \"_id\" : \"c\", \"value\" : 2 } { \"_id\" : \"d\", \"value\" : 1 } Assuming that the map and reduce functions are located in and and bundled in your jar so they are available on the classpath, you can run a Map-Reduce operation as follows: The preceding exmaple produces the following output: The class implements and provides access to the raw output and timing and count statistics.The following listing shows the class: public class ValueObject { private String id; private float value; public String getId() { return id; } public float getValue() { return value; } public void setValue(float value) { this.value = value; } @Override public String toString() { return \"ValueObject [id=\" + id + \", value=\" + value + \"]\"; } } By default, the output type of is used so that you need not specify an output collection.To specify additional Map-Reduce options, use an overloaded method that takes an additional argument.The class has a fluent API, so adding additional options can be done in a compact syntax.The following example sets the output collection to (note that setting only the output collection assumes a default output type of ): There is also a static import ( ) that can be used to make the syntax slightly more compact, as the following example shows: You can also specify a query to reduce the set of data that is fed into the Map-Reduce operation.The following example removes the document that contains [a,b] from consideration for Map-Reduce operations: Note that you can specify additional limit and sort values on the query, but you cannot skip values. MongoDB 4.2 removed support for the command used by .\n\n There is no replacement for the removed functionality. MongoDB allows running JavaScript functions on the server by either directly sending the script or calling a stored one. can be accessed through and provides basic abstraction for usage. The following example shows how to us the class: ScriptOperations scriptOps = template.scriptOps(); ExecutableMongoScript echoScript = new ExecutableMongoScript(\"function(x) { return x; }\"); scriptOps.execute(echoScript, \"directly execute script\"); (1) scriptOps.register(new NamedMongoScript(\"echo\", echoScript)); (2) scriptOps.call(\"echo\", \"execute script via name\"); (3) Run the script directly without storing the function on server side. Store the script using 'echo' as its name. The given name identifies the script and allows calling it later. Run the script with name 'echo' using the provided parameters. As an alternative to using Map-Reduce to perform data aggregation, you can use the operation which feels similar to using SQL’s group by query style, so it may feel more approachable vs. using Map-Reduce. Using the group operations does have some limitations, for example it is not supported in a shared environment and it returns the full result set in a single BSON object, so the result should be small, less than 10,000 keys. Spring provides integration with MongoDB’s group operation by providing methods on MongoOperations to simplify the creation and running of group operations. It can convert the results of the group operation to a POJO and also integrates with Spring’s Resource abstraction abstraction. This will let you place your JavaScript files on the file system, classpath, http server or any other Spring Resource implementation and then reference the JavaScript resources via an easy URI style syntax, e.g. 'classpath:reduce.js;. Externalizing JavaScript code in files if often preferable to embedding them as Java strings in your code. Note that you can still pass JavaScript code as Java strings if you prefer. In order to understand how group operations work the following example is used, which is somewhat artificial. For a more realistic example consult the book 'MongoDB - The definitive guide'. A collection named created with the following rows. We would like to group by the only field in each row, the field and aggregate the number of times each specific value of occurs. To do this we need to create an initial document that contains our count variable and also a reduce function which will increment it each time it is encountered. The Java code to run the group operation is shown below The first argument is the name of the collection to run the group operation over, the second is a fluent API that specifies properties of the group operation via a class. In this example we are using just the and methods. You can also specify a key-function, as well as a finalizer as part of the fluent API. If you have multiple keys to group by, you can pass in a comma separated list of keys. The raw results of the group operation is a JSON document that looks like this The document under the \"retval\" field is mapped onto the third argument in the group method, in this case XObject which is shown below. You can also obtain the raw result as a by calling the method on the class. There is an additional method overload of the group method on which lets you specify a object for selecting a subset of the rows. An example which uses a object, with some syntax sugar using static imports, as well as referencing a key-function and reduce function javascript files via a Spring Resource string is shown below. Spring Data MongoDB provides support for the Aggregation Framework introduced to MongoDB in version 2.2. For further information, see the full reference documentation of the aggregation framework and other data aggregation tools for MongoDB. The Aggregation Framework support in Spring Data MongoDB is based on the following key abstractions: , , and .\n• An represents a MongoDB operation and holds the description of the aggregation pipeline instructions. Aggregations are created by invoking the appropriate static factory method of the class, which takes a list of and an optional input class. The actual aggregate operation is run by the method of the , which takes the desired output class as a parameter.\n• A , just like an , holds the instructions of the aggregation pipeline and a reference to the input type, that is used for mapping domain properties to actual document fields. At runtime, field references get checked against the given input type, considering potential annotations. Changed in 3.2 referencing non-existent properties does no longer raise errors. To restore the previous behaviour use the option of .\n• An represents a MongoDB aggregation pipeline operation and describes the processing that should be performed in this aggregation step. Although you could manually create an , we recommend using the static factory methods provided by the class to construct an .\n• is the container for the result of an aggregate operation. It provides access to the raw aggregation result, in the form of a to the mapped objects and other information about the aggregation. The following listing shows the canonical example for using the Spring Data MongoDB support for the MongoDB Aggregation Framework: Note that, if you provide an input class as the first parameter to the method, the derives the name of the input collection from this class. Otherwise, if you do not not specify an input class, you must provide the name of the input collection explicitly. If both an input class and an input collection are provided, the latter takes precedence. The MongoDB Aggregation Framework provides the following types of aggregation operations: At the time of this writing, we provide support for the following Aggregation Operations in Spring Data MongoDB: * The operation is mapped or added by Spring Data MongoDB. Note that the aggregation operations not listed here are currently not supported by Spring Data MongoDB. Comparison aggregation operators are expressed as expressions. Projection expressions are used to define the fields that are the outcome of a particular aggregation step. Projection expressions can be defined through the method of the class, either by passing a list of objects or an aggregation framework object. The projection can be extended with additional fields through a fluent API by using the method and aliased by using the method. Note that you can also define fields with aliases by using the static factory method of the aggregation framework, which you can then use to construct a new instance. References to projected fields in later aggregation stages are valid only for the field names of included fields or their aliases (including newly defined fields and their aliases). Fields not included in the projection cannot be referenced in later aggregation stages. The following listings show examples of projection expression: Example 41. Multi-Stage Aggregation using Projection and Sorting // generates {$project: {name: 1, netPrice: 1}}, {$sort: {name: 1}} project(\"name\", \"netPrice\"), sort(ASC, \"name\") // generates {$project: {name: $firstname}}, {$sort: {name: 1}} project().and(\"firstname\").as(\"name\"), sort(ASC, \"name\") // does not work project().and(\"firstname\").as(\"name\"), sort(ASC, \"firstname\") More examples for project operations can be found in the class. Note that further details regarding the projection expressions can be found in the corresponding section of the MongoDB Aggregation Framework reference documentation. As of Version 3.4, MongoDB supports faceted classification by using the Aggregation Framework. A faceted classification uses semantic categories (either general or subject-specific) that are combined to create the full classification entry. Documents flowing through the aggregation pipeline are classified into buckets. A multi-faceted classification enables various aggregations on the same set of input documents, without needing to retrieve the input documents multiple times. Bucket operations categorize incoming documents into groups, called buckets, based on a specified expression and bucket boundaries. Bucket operations require a grouping field or a grouping expression. You can define them by using the and methods of the class. and can expose accumulations based on aggregation expressions for input documents. You can extend the bucket operation with additional parameters through a fluent API by using the methods and the method. You can alias the operation by using the method. Each bucket is represented as a document in the output. takes a defined set of boundaries to group incoming documents into these categories. Boundaries are required to be sorted. The following listing shows some examples of bucket operations: determines boundaries in an attempt to evenly distribute documents into a specified number of buckets. optionally takes a granularity value that specifies the preferred number series to use to ensure that the calculated boundary edges end on preferred round numbers or on powers of 10. The following listing shows examples of bucket operations: To create output fields in buckets, bucket operations can use through and SpEL expressions through . Note that further details regarding bucket expressions can be found in the section and section of the MongoDB Aggregation Framework reference documentation. Multiple aggregation pipelines can be used to create multi-faceted aggregations that characterize data across multiple dimensions (or facets) within a single aggregation stage. Multi-faceted aggregations provide multiple filters and categorizations to guide data browsing and analysis. A common implementation of faceting is how many online retailers provide ways to narrow down search results by applying filters on product price, manufacturer, size, and other factors. You can define a by using the method of the class. You can customize it with multiple aggregation pipelines by using the method. Each sub-pipeline has its own field in the output document where its results are stored as an array of documents. Sub-pipelines can project and filter input documents prior to grouping. Common use cases include extraction of date parts or calculations before categorization. The following listing shows facet operation examples: Note that further details regarding facet operation can be found in the section of the MongoDB Aggregation Framework reference documentation. Sort by count operations group incoming documents based on the value of a specified expression, compute the count of documents in each distinct group, and sort the results by count. It offers a handy shortcut to apply sorting when using Faceted Classification. Sort by count operations require a grouping field or grouping expression. The following listing shows a sort by count example: Example 45. Sort by count example A sort by count operation is equivalent to the following BSON (Binary JSON): We support the use of SpEL expressions in projection expressions through the method of the and classes. This feature lets you define the desired expression as a SpEL expression. On running a query, the SpEL expression is translated into a corresponding MongoDB projection expression part. This arrangement makes it much easier to express complex calculations. Consider the following SpEL expression: The preceding expression is translated into the following projection expression part: You can see examples in more context in Aggregation Framework Example 5 and Aggregation Framework Example 6. You can find more usage examples for supported SpEL expression constructs in . The following table shows the SpEL transformations supported by Spring Data MongoDB: In addition to the transformations shown in the preceding table, you can use standard SpEL operations such as to (for example) create arrays and reference expressions through their names (followed by the arguments to use in brackets). The following example shows how to create an array in this fashion: The examples in this section demonstrate the usage patterns for the MongoDB Aggregation Framework with Spring Data MongoDB. In this introductory example, we want to aggregate a list of tags to get the occurrence count of a particular tag from a MongoDB collection (called ) sorted by the occurrence count in descending order. This example demonstrates the usage of grouping, sorting, projections (selection), and unwinding (result splitting). The preceding listing uses the following algorithm:\n• Create a new aggregation by using the static factory method, to which we pass a list of aggregation operations. These aggregate operations define the aggregation pipeline of our .\n• Use the operation to select the field (which is an array of strings) from the input collection.\n• Use the operation to generate a new document for each tag within the array.\n• Use the operation to define a group for each value for which we aggregate the occurrence count (by using the aggregation operator and collecting the result in a new field called ).\n• Select the field and create an alias for the ID field generated from the previous group operation (hence the call to ) with a name of .\n• Use the operation to sort the resulting list of tags by their occurrence count in descending order.\n• Call the method on to let MongoDB perform the actual aggregation operation, with the created as an argument. Note that the input collection is explicitly specified as the parameter to the Method. If the name of the input collection is not specified explicitly, it is derived from the input class passed as the first parameter to the method. This example is based on the Largest and Smallest Cities by State example from the MongoDB Aggregation Framework documentation. We added additional sorting to produce stable results with different MongoDB versions. Here we want to return the smallest and largest cities by population for each state by using the aggregation framework. This example demonstrates grouping, sorting, and projections (selection). Note that the class maps the structure of the given input-collection. The class defines the structure in the desired output format. The preceding listings use the following algorithm:\n• Use the operation to define a group from the input-collection. The grouping criteria is the combination of the and fields, which forms the ID structure of the group. We aggregate the value of the property from the grouped elements by using the operator and save the result in the field.\n• Use the operation to sort the intermediate-result by the , and fields, in ascending order, such that the smallest city is at the top and the biggest city is at the bottom of the result. Note that the sorting on and is implicitly performed against the group ID fields (which Spring Data MongoDB handled).\n• Use a operation again to group the intermediate result by . Note that again implicitly references a group ID field. We select the name and the population count of the biggest and smallest city with calls to the and operators, respectively, in the operation.\n• Select the field from the previous operation. Note that again implicitly references a group ID field. Because we do not want an implicitly generated ID to appear, we exclude the ID from the previous operation by using . Because we want to populate the nested structures in our output class, we have to emit appropriate sub-documents by using the nested method.\n• Sort the resulting list of by their state name in ascending order in the operation. Note that we derive the name of the input collection from the class passed as the first parameter to the method. This example is based on the States with Populations Over 10 Million example from the MongoDB Aggregation Framework documentation. We added additional sorting to produce stable results with different MongoDB versions. Here we want to return all states with a population greater than 10 million, using the aggregation framework. This example demonstrates grouping, sorting, and matching (filtering). The preceding listings use the following algorithm:\n• Group the input collection by the field and calculate the sum of the field and store the result in the new field .\n• Sort the intermediate result by the id-reference of the previous group operation in addition to the field in ascending order.\n• Filter the intermediate result by using a operation which accepts a query as an argument. Note that we derive the name of the input collection from the class passed as first parameter to the method. This example demonstrates the use of simple arithmetic operations in the projection operation. Note that we derive the name of the input collection from the class passed as first parameter to the method. This example demonstrates the use of simple arithmetic operations derived from SpEL Expressions in the projection operation. This example demonstrates the use of complex arithmetic operations derived from SpEL Expressions in the projection operation. Note: The additional parameters passed to the method can be referenced with indexer expressions according to their position. In this example, we reference the first parameter of the parameters array with . When the SpEL expression is transformed into a MongoDB aggregation framework expression, external parameter expressions are replaced with their respective values. Note that we can also refer to other fields of the document within the SpEL expression. This example uses conditional projection. It is derived from the $cond reference documentation. This one-step aggregation uses a projection operation with the collection. We project the field by using a conditional operation for all inventory items that have a greater than or equal to . A second conditional projection is performed for the field. We apply the description to all items that either do not have a field or items that have a description. As of MongoDB 3.6, it is possible to exclude fields from the projection by using a conditional expression. If the value of the field does not contain a value, then use to exclude the field. Otherwise, add the field value of . provides a few methods for managing indexes and collections. These methods are collected into a helper interface called . You can access these operations by calling the method and passing in either the collection name or the of your entity (the collection name is derived from the , either by name or from annotation metadata). The following listing shows the interface: You can create an index on a collection to improve query performance by using the MongoTemplate class, as the following example shows: makes sure that an index for the provided IndexDefinition exists for the collection. You can create standard, geospatial, and text indexes by using the , and classes. For example, given the class defined in a previous section, you could declare a geospatial query, as the following example shows: The interface has the method that returns a list of objects. This list contains all the indexes defined on the collection. The following example defines an index on the class that has an property: The following example shows how to create a collection: Example 47. Working with collections by using\n• collectionExists: Checks to see if a collection with a given name exists.\n• getCollection: Gets a collection by name, creating it if it does not exist. Collection creation allows customization with and supports collations. You can get at the MongoDB driver’s method by using the methods on . These methods also perform exception translation into Spring’s hierarchy.\n• executeCommand : Run a MongoDB command with the given nullable MongoDB . The MongoDB mapping framework includes several events that your application can respond to by registering special beans in the . Being based on Spring’s event infrastructure enables other products, such as Spring Integration, to easily receive these events, as they are a well known eventing mechanism in Spring-based applications. To intercept an object before it goes through the conversion process (which turns your domain object into a ), you can register a subclass of that overrides the method. When the event is dispatched, your listener is called and passed the domain object before it goes into the converter. The following example shows how to do so: public class BeforeConvertListener extends AbstractMongoEventListener<Person> { @Override public void onBeforeConvert(BeforeConvertEvent<Person> event) { ... does some auditing manipulation, set timestamps, whatever ... } } To intercept an object before it goes into the database, you can register a subclass of that overrides the method. When the event is dispatched, your listener is called and passed the domain object and the converted . The following example shows how to do so: Declaring these beans in your Spring ApplicationContext causes them to be invoked whenever the event is dispatched. The following callback methods are present in :\n• : Called in , , and operations before the object is converted to a by a .\n• : Called in , , and operations before inserting or saving the in the database.\n• : Called in , , and operations after inserting or saving the in the database.\n• : Called in , , , and methods after the has been retrieved from the database.\n• : Called in , , , and methods after the has been retrieved from the database was converted to a POJO. Lifecycle events are only emitted for root level types. Complex types used as properties within a document root are not subject to event publication unless they are document references annotated with . Lifecycle events depend on an , which in case of the can be configured with a , and therefore gives no guarantees when an Event is processed.\n\nSpring Data MongoDB uses the API for its auditing support and reacts on the following callbacks. Invoked before a domain object is converted to . Invoked after a domain object is loaded.\n\n Can modify the domain object after reading it from a . Invoked before a domain object is saved.\n\n Can modify the target, to be persisted, containing all mapped entity information. Invoked before a domain object is saved.\n\n Can modify the domain object, to be returned after save, containing all mapped entity information. The Spring framework provides exception translation for a wide variety of database and mapping technologies. This has traditionally been for JDBC and JPA. The Spring support for MongoDB extends this feature to the MongoDB Database by providing an implementation of the interface. The motivation behind mapping to Spring’s consistent data access exception hierarchy is that you are then able to write portable and descriptive exception handling code without resorting to coding against MongoDB error codes. All of Spring’s data access exceptions are inherited from the root class so that you can be sure to catch all database related exception within a single try-catch block. Note that not all exceptions thrown by the MongoDB driver inherit from the class. The inner exception and message are preserved so that no information is lost. Some of the mappings performed by the are and error codes 1003, 12001, 12010, 12011, and 12012 to . Look into the implementation for more details on the mapping. One common design feature of all Spring template classes is that all functionality is routed into one of the template’s callback methods. Doing so helps to ensure that exceptions and any resource management that may be required are performed consistently. While JDBC and JMS need this feature much more than MongoDB does, it still offers a single spot for exception translation and logging to occur. Consequently, using these callbacks is the preferred way to access the MongoDB driver’s and objects to perform uncommon operations that were not exposed as methods on . The following list describes the callback methods.\n• execute : Runs the given for the entity collection of the specified class.\n• execute : Runs the given on the collection of the given name.\n• execute : Runs a DbCallback, translating any exceptions as necessary. Spring Data MongoDB provides support for the Aggregation Framework introduced to MongoDB in version 2.2.\n• execute : Runs a on the collection of the given name translating any exceptions as necessary.\n• executeInSession : Runs the given within the same connection to the database so as to ensure consistency in a write-heavy environment where you may read the data that you wrote. The following example uses the to return information about an index: boolean hasIndex = template.execute(\"geolocation\", new CollectionCallbackBoolean>() { public Boolean doInCollection(Venue.class, DBCollection collection) throws MongoException, DataAccessException { List<Document> indexes = collection.getIndexInfo(); for (Document document : indexes) { if (\"location_2d\".equals(document.get(\"name\"))) { return true; } } return false; } }); MongoDB supports storing binary files inside its filesystem, GridFS. Spring Data MongoDB provides a interface as well as the corresponding implementation, , to let you interact with the filesystem. You can set up a instance by handing it a as well as a , as the following example shows: The corresponding XML configuration follows: The template can now be injected and used to perform storage and retrieval operations, as the following example shows: Example 50. Using GridFsTemplate to store files The operations take an , a filename, and (optionally) metadata information about the file to store. The metadata can be an arbitrary object, which will be marshaled by the configured with the . Alternatively, you can also provide a . You can read files from the filesystem through either the or the methods. Let’s have a look at the methods first. You can either find a single file or multiple files that match a . You can use the helper class to define queries. It provides static factory methods to encapsulate default metadata fields (such as and ) or a custom one through . The following example shows how to use to query for files: Example 51. Using GridFsTemplate to query for files Currently, MongoDB does not support defining sort criteria when retrieving files from GridFS. For this reason, any sort criteria defined on the instance handed into the method are disregarded. The other option to read files from the GridFs is to use the methods introduced by the interface. They allow handing an Ant path into the method and can thus retrieve files matching the given pattern. The following example shows how to use to read files: Example 52. Using GridFsTemplate to read files extends and lets the (for example) to be plugged into an to read Spring Config files from MongoDB database. By default, MongoDB automatically closes a cursor when the client exhausts all results supplied by the cursor. Closing a cursor on exhaustion turns a stream into a finite stream. For capped collections, you can use a Tailable Cursor that remains open after the client consumed all initially returned data. Capped collections can be created with . To do so, provide the required . Tailable cursors can be consumed with both, the imperative and the reactive MongoDB API. It is highly recommended to use the reactive variant, as it is less resource-intensive. However, if you cannot use the reactive API, you can still use a messaging concept that is already prevalent in the Spring ecosystem. Listening to a capped collection using a Sync Driver creates a long running, blocking task that needs to be delegated to a separate component. In this case, we need to first create a , which will be the main entry point for running the specific . Spring Data MongoDB already ships with a default implementation that operates on and is capable of creating and running instances for a . The following example shows how to use tailable cursors with instances: Starting the container intializes the resources and starts instances for already registered instances. Requests added after startup are ran immediately. Define the listener called when a is received. The is converted to the requested domain type. Use to receive raw results without conversion. Set the collection to listen to. Provide an optional filter for documents to receive. Set the message listener to publish incoming s to. Register the request. The returned can be used to check the current state and cancel it to free resources. Do not forget to stop the container once you are sure you no longer need it. Doing so stops all running instances within the container. Using tailable cursors with a reactive data types allows construction of infinite streams. A tailable cursor remains open until it is closed externally. It emits data as new documents arrive in a capped collection. Tailable cursors may become dead, or invalid, if either the query returns no match or the cursor returns the document at the “end” of the collection and the application then deletes that document. The following example shows how to create and use an infinite stream query: Flux<Person> stream = template.tail(query(where(\"name\").is(\"Joe\")), Person.class); Disposable subscription = stream.doOnNext(person -> System.out.println(person)).subscribe(); // … // Later: Dispose the subscription to close the stream subscription.dispose(); Spring Data MongoDB Reactive repositories support infinite streams by annotating a query method with . This works for methods that return and other reactive types capable of emitting multiple elements, as the following example shows: public interface PersonRepository extends ReactiveMongoRepository<Person, String> { @Tailable Flux<Person> findByFirstname(String firstname); } Flux<Person> stream = repository.findByFirstname(\"Joe\"); Disposable subscription = stream.doOnNext(System.out::println).subscribe(); // … // Later: Dispose the subscription to close the stream subscription.dispose(); As of MongoDB 3.6, Change Streams let applications get notified about changes without having to tail the oplog. Change Stream support is only possible for replica sets or for a sharded cluster. Change Streams can be consumed with both, the imperative and the reactive MongoDB Java driver. It is highly recommended to use the reactive variant, as it is less resource-intensive. However, if you cannot use the reactive API, you can still obtain change events by using the messaging concept that is already prevalent in the Spring ecosystem. It is possible to watch both on a collection as well as database level, whereas the database level variant publishes changes from all collections within the database. When subscribing to a database change stream, make sure to use a suitable type for the event type as conversion might not apply correctly across different entity types. In doubt, use . Listening to a Change Stream by using a Sync Driver creates a long running, blocking task that needs to be delegated to a separate component. In this case, we need to first create a , which will be the main entry point for running the specific tasks. Spring Data MongoDB already ships with a default implementation that operates on and is capable of creating and running instances for a . The following example shows how to use Change Streams with instances: Starting the container initializes the resources and starts instances for already registered instances. Requests added after startup are ran immediately. Define the listener called when a is received. The is converted to the requested domain type. Use to receive raw results without conversion. Set the collection to listen to and provide additional options through . Register the request. The returned can be used to check the current state and cancel it to free resources. Do not forget to stop the container once you are sure you no longer need it. Doing so stops all running instances within the container. Errors while processing are passed on to an . If not stated otherwise a log appending gets applied by default.\n\n Please use to provide additional functionality. Subscribing to Change Streams with the reactive API is a more natural approach to work with streams. Still, the essential building blocks, such as , remain the same. The following example shows how to use Change Streams emitting s: The event target type the underlying document should be converted to. Leave this out to receive raw results without conversion. Use an aggregation pipeline or just a query to filter events. Obtain a of change stream events. The is converted to the requested domain type from (2). Change Streams can be resumed and resume emitting events where you left. To resume the stream, you need to supply either a resume token or the last known server time (in UTC). Use to set the value accordingly. The following example shows how to set the resume offset using server time: You may obtain the server time of an through the method or use the exposed through . In some cases an might not be a precise enough measure when resuming a Change Stream. Use a MongoDB native BsonTimestamp for that purpose. MongoDB 5.0 introduced Time Series collections that are optimized to efficiently store documents over time such as measurements or events. Those collections need to be created as such before inserting any data. Collections can be created by either running the command, defining time series collection options or extracting options from a annotation as shown in the examples below. The snippets above can easily be transferred to the reactive API offering the very same methods. Make sure to properly subscribe to the returned publishers.\n\nThe reactive MongoDB support contains the following basic set of features:\n• Spring configuration support that uses Java-based classes, a instance, and replica sets.\n• , which is a helper class that increases productivity by using in a reactive manner. It includes integrated object mapping between instances and POJOs.\n• Annotation-based mapping metadata that is extensible to support other metadata formats. For most tasks, you should use or the repository support, both of which use the rich mapping functionality. is the place to look for accessing functionality such as incrementing counters or ad-hoc CRUD operations. also provides callback methods so that you can use the low-level API artifacts (such as ) to communicate directly with MongoDB. The goal with naming conventions on various API artifacts is to copy those in the base MongoDB Java driver so that you can map your existing knowledge onto the Spring APIs. Spring MongoDB support requires MongoDB 2.6 or higher and Java SE 8 or higher. First, you need to set up a running MongoDB server. Refer to the MongoDB Quick Start guide for an explanation on how to startup a MongoDB instance. Once installed, starting MongoDB is typically a matter of running the following command: To create a Spring project in STS, go to File → New → Spring Template Project → Simple Spring Utility Project and press Yes when prompted. Then enter a project and a package name, such as org.spring.mongodb.example. Then add the following to the pom.xml dependencies section. MongoDB uses two different drivers for blocking and reactive (non-blocking) data access. While blocking operations are provided by default, you can opt-in for reactive usage. To get started with a working example, create a simple class to persist, as follows: @Document public class Person { private String id; private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getId() { return id; } public String getName() { return name; } public int getAge() { return age; } @Override public String toString() { return \"Person [id=\" + id + \", name=\" + name + \", age=\" + age + \"]\"; } } Then create an application to run, as follows: Running the preceding class produces the following output: 2016-09-20 14:56:57,373 DEBUG .index.MongoPersistentEntityIndexCreator: 124 - Analyzing class class example.ReactiveMongoApp$Person for index information. 2016-09-20 14:56:57,452 DEBUG .data.mongodb.core.ReactiveMongoTemplate: 975 - Inserting Document containing fields: [_class, name, age] in collection: person 2016-09-20 14:56:57,541 DEBUG .data.mongodb.core.ReactiveMongoTemplate:1503 - findOne using query: { \"name\" : \"Joe\"} fields: null for class: class example.ReactiveMongoApp$Person in collection: person 2016-09-20 14:56:57,545 DEBUG .data.mongodb.core.ReactiveMongoTemplate:1979 - findOne using query: { \"name\" : \"Joe\"} in db.collection: database.person 2016-09-20 14:56:57,567 INFO example.ReactiveMongoApp: 43 - Person [id=57e1321977ac501c68d73104, name=Joe, age=34] 2016-09-20 14:56:57,573 DEBUG .data.mongodb.core.ReactiveMongoTemplate: 528 - Dropped collection [person] Even in this simple example, there are a few things to take notice of:\n• You can instantiate the central helper class of Spring Mongo ( ) by using the standard object and the name of the database to use.\n• The mapper works against standard POJO objects without the need for any additional metadata (though you can optionally provide that information. See here.).\n• Conventions are used for handling the ID field, converting it to be an when stored in the database.\n• Mapping conventions can use field access. Notice that the class has only getters.\n• If the constructor argument names match the field names of the stored document, they are used to instantiate the object There is a GitHub repository with several examples that you can download and play around with to get a feel for how the library works. 13.2. Connecting to MongoDB with Spring and the Reactive Streams Driver One of the first tasks when using MongoDB and Spring is to create a object by using the IoC container. The following example shows how to use Java-based bean metadata to register an instance of a : @Configuration public class AppConfig { /* * Use the Reactive Streams Mongo Client API to create a com.mongodb.reactivestreams.client.MongoClient instance. */ public @Bean MongoClient reactiveMongoClient() { return MongoClients.create(\"mongodb://localhost\"); } } This approach lets you use the standard API (which you may already know). An alternative is to register an instance of instance with the container by using Spring’s . As compared to instantiating a instance directly, the approach has the added advantage of also providing the container with an implementation that translates MongoDB exceptions to exceptions in Spring’s portable hierarchy for data access classes annotated with the annotation. This hierarchy and use of is described in Spring’s DAO support features. The following example shows Java-based bean metadata that supports exception translation on annotated classes: Example 69. Registering a object using Spring’s MongoClientFactoryBean and enabling Spring’s exception translation support @Configuration public class AppConfig { /* * Factory bean that creates the com.mongodb.reactivestreams.client.MongoClient instance */ public @Bean ReactiveMongoClientFactoryBean mongoClient() { ReactiveMongoClientFactoryBean clientFactory = new ReactiveMongoClientFactoryBean(); clientFactory.setHost(\"localhost\"); return clientFactory; } } To access the object created by the in other or your own classes, get the from the context. While is the entry point to the reactive MongoDB driver API, connecting to a specific MongoDB database instance requires additional information, such as the database name. With that information, you can obtain a object and access all the functionality of a specific MongoDB database instance. Spring provides the interface to bootstrap connectivity to the database. The following listing shows the interface: public interface ReactiveMongoDatabaseFactory { /** * Creates a default {@link MongoDatabase} instance. * * @return * @throws DataAccessException */ MongoDatabase getMongoDatabase() throws DataAccessException; /** * Creates a {@link MongoDatabase} instance to access the database with the given name. * * @param dbName must not be {@literal null} or empty. * @return * @throws DataAccessException */ MongoDatabase getMongoDatabase(String dbName) throws DataAccessException; /** * Exposes a shared {@link MongoExceptionTranslator}. * * @return will never be {@literal null}. */ PersistenceExceptionTranslator getExceptionTranslator(); } The class implements the interface and is created with a standard instance and the database name. Instead of using the IoC container to create an instance of , you can use them in standard Java code, as follows: The use of is the only difference between the listing shown in the getting started section. To register a instance with the container, you can write code much like what was highlighted in the previous code listing, as the following example shows: To define the username and password, create a MongoDB connection string and pass it into the factory method, as the next listing shows. The following listing also shows how to use to register an instance of with the container: The class, located in the package, is the central class of the Spring’s Reactive MongoDB support and provides a rich feature set to interact with the database. The template offers convenience operations to create, update, delete, and query for MongoDB documents and provides a mapping between your domain objects and MongoDB documents. Once configured, is thread-safe and can be reused across multiple instances. The mapping between MongoDB documents and domain classes is done by delegating to an implementation of the interface. Spring provides a default implementation with , but you can also write your own converter. See the section on instances for more detailed information. The class implements the interface. As much as possible, the methods on mirror methods available on the MongoDB driver object, to make the API familiar to existing MongoDB developers who are used to the driver API. For example, you can find methods such as , , , , , , , and . The design goal is to make it as easy as possible to transition between the use of the base MongoDB driver and . A major difference between the two APIs is that can be passed domain objects instead of , and there are fluent APIs for , , and operations instead of populating a to specify the parameters for those operations. The preferred way to reference the operations on instance is through its interface. The default converter implementation used by is . While the can use additional metadata to specify the mapping of objects to documents, it can also convert objects that contain no additional metadata by using some conventions for the mapping of IDs and collection names. These conventions as well as the use of mapping annotations are explained in the Mapping chapter. Another central feature of is exception translation of exceptions thrown in the MongoDB Java driver into Spring’s portable Data Access Exception hierarchy. See the section on exception translation for more information. There are many convenience methods on to help you easily perform common tasks. However, if you need to access the MongoDB driver API directly to access functionality not explicitly exposed by the MongoTemplate, you can use one of several callback methods to access underlying driver APIs. The callbacks give you a reference to either a or a object. See Execution Callbacks for more information. You can use Java to create and register an instance of , as follows: There are several overloaded constructors of , including:\n• : Takes the object and the default database name to operate against.\n• : Takes a object that encapsulated the object and database name.\n• : Adds a to use for mapping. When creating a , you might also want to set the following properties: The preferred way to reference the operations on instance is through its interface. When in development, it is handy to either log or throw an if the returned from any MongoDB operation contains an error. It is quite common to forget to do this during development and then end up with an application that looks like it runs successfully when, in fact, the database was not modified according to your expectations. Set the property to an enum with the following values, , , or to either log the error, throw and exception or do nothing. The default is to use a value of . If it has not yet been specified through the driver at a higher level (such as ), you can set the property that the uses for write operations. If ReactiveMongoTemplate’s property is not set, it defaults to the one set in the MongoDB driver’s or setting. For more advanced cases where you want to set different values on a per-operation basis (for remove, update, insert, and save operations), a strategy interface called can be configured on . Since is used to persist POJOs, the lets you create a policy that can map a specific POJO class to a value. The following listing shows the interface: The argument, , determines the value to be used and whether to use the value of the template itself as a default. contains the collection name being written to, the of the POJO, the converted , the operation as a value from the enumeration (one of , , , , and ), and a few other pieces of contextual information. The following example shows how to create a : private class MyAppWriteConcernResolver implements WriteConcernResolver { public WriteConcern resolve(MongoAction action) { if (action.getEntityClass().getSimpleName().contains(\"Audit\")) { return WriteConcern.NONE; } else if (action.getEntityClass().getSimpleName().contains(\"Metadata\")) { return WriteConcern.JOURNAL_SAFE; } return action.getDefaultWriteConcern(); } } lets you save, update, and delete your domain objects and map those objects to documents stored in MongoDB. Consider the following class: public class Person { private String id; private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getId() { return id; } public String getName() { return name; } public int getAge() { return age; } @Override public String toString() { return \"Person [id=\" + id + \", name=\" + name + \", age=\" + age + \"]\"; } } The following listing shows how you can save, update, and delete the object: public class ReactiveMongoApp { private static final Logger log = LoggerFactory.getLogger(ReactiveMongoApp.class); public static void main(String[] args) throws Exception { CountDownLatch latch = new CountDownLatch(1); ReactiveMongoTemplate mongoOps = new ReactiveMongoTemplate(MongoClients.create(), \"database\"); mongoOps.insert(new Person(\"Joe\", 34)).doOnNext(person -> log.info(\"Insert: \" + person)) .flatMap(person -> mongoOps.findById(person.getId(), Person.class)) .doOnNext(person -> log.info(\"Found: \" + person)) .zipWith(person -> mongoOps.updateFirst(query(where(\"name\").is(\"Joe\")), update(\"age\", 35), Person.class)) .flatMap(tuple -> mongoOps.remove(tuple.getT1())).flatMap(deleteResult -> mongoOps.findAll(Person.class)) .count().doOnSuccess(count -> { log.info(\"Number of people: \" + count); latch.countDown(); }) .subscribe(); latch.await(); } } The preceding example includes implicit conversion between a and (by using the ) as stored in the database and recognizing a convention of the property name. The preceding example is meant to show the use of save, update, and remove operations on and not to show complex mapping or chaining functionality. “Querying Documents” explains the query syntax used in the preceding example in more detail. Additional documentation can be found in the blocking section. One common design feature of all Spring template classes is that all functionality is routed into one of the templates that run callback methods. This helps ensure that exceptions and any resource management that maybe required are performed consistency. While this was of much greater need in the case of JDBC and JMS than with MongoDB, it still offers a single spot for exception translation and logging to occur. As such, using the callback is the preferred way to access the MongoDB driver’s and objects to perform uncommon operations that were not exposed as methods on . Here is a list of callback methods.\n• execute : Runs the given for the entity collection of the specified class.\n• execute : Runs the given on the collection of the given name.\n• execute : Runs a translating any exceptions as necessary. The following example uses the to return information about an index: MongoDB supports storing binary files inside its filesystem, GridFS. Spring Data MongoDB provides a interface as well as the corresponding implementation, , to let you interact with the filesystem. You can set up a instance by handing it a as well as a , as the following example shows: The template can now be injected and used to perform storage and retrieval operations, as the following example shows: Example 72. Using ReactiveGridFsTemplate to store files The operations take an , a filename, and (optionally) metadata information about the file to store. The metadata can be an arbitrary object, which will be marshaled by the configured with the . Alternatively, you can also provide a . MongoDB’s driver uses and interfaces to exchange binary streams. Spring Data MongoDB adapts these interfaces to . Read more about in Spring’s reference documentation. You can read files from the filesystem through either the or the methods. Let’s have a look at the methods first. You can either find a single file or multiple files that match a . You can use the helper class to define queries. It provides static factory methods to encapsulate default metadata fields (such as and ) or a custom one through . The following example shows how to use to query for files: Example 73. Using ReactiveGridFsTemplate to query for files Currently, MongoDB does not support defining sort criteria when retrieving files from GridFS. For this reason, any sort criteria defined on the instance handed into the method are disregarded. The other option to read files from the GridFs is to use the methods modeled along the lines of . uses reactive types to defer running while uses a synchronous interface. These methods allow handing an Ant path into the method and can thus retrieve files matching the given pattern. The following example shows how to use to read files: Example 74. Using ReactiveGridFsTemplate to read files\n\nThis chapter points out the specialties for repository support for MongoDB. This chapter builds on the core repository support explained in [repositories]. You should have a sound understanding of the basic concepts explained there. To access domain entities stored in a MongoDB, you can use our sophisticated repository support that eases implementation quite significantly.To do so, create an interface for your repository, as the following example shows: Note that the domain type shown in the preceding example has a property named of type .The default serialization mechanism used in (which backs the repository support) regards properties named as the document ID. Currently, we support , , and as ID types. Please see ID mapping for more information about on how the field is handled in the mapping layer. Now that we have a domain object, we can define an interface that uses it, as follows: Right now this interface serves only to provide type information, but we can add additional methods to it later. To start using the repository, use the annotation. That annotation carries the same attributes as the namespace element.If no base package is configured, the infrastructure scans the package of the annotated configuration class.The following example shows how to use Java configuration for a repository: If you would rather go with XML based configuration add the following content: This namespace element causes the base packages to be scanned for interfaces that extend and create Spring beans for each one found.By default, the repositories get a Spring bean wired that is called , so you only need to configure explicitly if you deviate from this convention. Because our domain repository extends , it provides you with CRUD operations as well as methods for paginated and sorted access to the entities.Working with the repository instance is just a matter of dependency injecting it into a client.Consequently, accessing the second page of objects at a page size of 10 would resemble the following code: The preceding example creates an application context with Spring’s unit test support, which performs annotation-based dependency injection into test cases.Inside the test method, we use the repository to query the datastore.We hand the repository a instance that requests the first page of objects at a page size of 10. Most of the data access operations you usually trigger on a repository result in a query being executed against the MongoDB databases.Defining such a query is a matter of declaring a method on the repository interface, as the following example shows: The method shows a query for all people with the given last name. The query is derived by parsing the method name for constraints that can be concatenated with and . Thus, the method name results in a query expression of . Applies pagination to a query. You can equip your method signature with a parameter and let the method return a instance and Spring Data automatically pages the query accordingly. Shows that you can query based on properties that are not primitive types. Throws if more than one match is found. Uses the keyword to restrict the query to only the first result. Unlike <3>, this method does not throw an exception if more than one match is found. Uses a Java 8 that reads and converts individual elements while iterating the stream. We do not support referring to parameters that are mapped as in the domain class. The following table shows the keywords that are supported for query methods: {\"firstname\" : name} (name as regex) {\"firstname\" : { \"$not\" : name }} (name as regex) {\"firstname\" : name} (name as regex) {\"firstname\" : { \"$not\" : name}} (name as regex) If the property criterion compares a document, the order of the fields and exact equality in the document matters. The keywords in the preceding table can be used in conjunction with or to create queries that delete matching documents. Using a return type of retrieves and returns all matching documents before actually deleting them. A numeric return type directly removes the matching documents, returning the total number of documents removed. A single domain type result retrieves and removes the first matching document. Same as in 3 but wrapped in an type. As you saw in the preceding table of keywords, a few keywords trigger geo-spatial operations within a MongoDB query. The keyword allows some further modification, as the next few examples show. The following example shows how to define a query that finds all persons with a given distance of a given point: Adding a parameter to the query method allows restricting results to those within the given distance. If the was set up containing a , we transparently use instead of , as the following example shows: Example 83. Using with Using a with a causes a (instead of a plain ) clause to be added. Beyond that, the actual distance gets calculated according to the used. Using on the target property forces usage of the operator. Spring Data MongoDb supports geo-near queries, as the following example shows: public interface PersonRepository extends MongoRepository<Person, String> { // {'geoNear' : 'location', 'near' : [x, y] } GeoResults<Person> findByLocationNear(Point location); // No metric: {'geoNear' : 'person', 'near' : [x, y], maxDistance : distance } // Metric: {'geoNear' : 'person', 'near' : [x, y], 'maxDistance' : distance, // 'distanceMultiplier' : metric.multiplier, 'spherical' : true } GeoResults<Person> findByLocationNear(Point location, Distance distance); // Metric: {'geoNear' : 'person', 'near' : [x, y], 'minDistance' : min, // 'maxDistance' : max, 'distanceMultiplier' : metric.multiplier, // 'spherical' : true } GeoResults<Person> findByLocationNear(Point location, Distance min, Distance max); // {'geoNear' : 'location', 'near' : [x, y] } GeoResults<Person> findByLocationNear(Point location); } By adding the annotation to your repository query methods, you can specify a MongoDB JSON query string to use instead of having the query be derived from the method name, as the following example shows: The placeholder lets you substitute the value from the method arguments into the JSON query string. parameter values are escaped during the binding process, which means that it is not possible to add MongoDB specific operators through the argument. You can also use the filter property to restrict the set of properties that is mapped into the Java object, as the following example shows: The query in the preceding example returns only the , and properties of the objects. The property, a , is not set and its value is therefore null. MongoDB repositories allow various approaches to define sorting order. Let’s take a look at the following example: Static sorting derived from method name. results in for the sort parameter. Dynamic sorting using a method argument. creates for the sort parameter. Static sorting via annotation. Sort parameter applied as stated in the attribute. Default sorting via annotation combined with dynamic one via a method argument. results in . Using overrides the defaults and creates . alters the default and results in . Query strings and field definitions can be used together with SpEL expressions to create dynamic queries at runtime. SpEL expressions can provide predicate values and can be used to extend predicates with subdocuments. Expressions expose method arguments through an array that contains all the arguments.The following query uses to declare the predicate value for (which is equivalent to the parameter binding): Expressions can be used to invoke functions, evaluate conditionals, and construct values.SpEL expressions used in conjunction with JSON reveal a side-effect, because Map-like declarations inside of SpEL read like JSON, as the following example shows: SpEL in query strings can be a powerful way to enhance queries.However, they can also accept a broad range of unwanted arguments. You should make sure to sanitize strings before passing them to the query to avoid unwanted changes to your query. Expression support is extensible through the Query SPI: . The Query SPI can contribute properties and functions and can customize the root object.Extensions are retrieved from the application context at the time of SpEL evaluation when the query is built.The following example shows how to use : Bootstrapping yourself is not application context-aware and requires further configuration to pick up Query SPI extensions. Reactive query methods can make use of . MongoDB repository support integrates with the Querydsl project, which provides a way to perform type-safe queries. To quote from the project description, \"Instead of writing queries as inline strings or externalizing them into XML files they are constructed via a fluent API.\" It provides the following features:\n• Code completion in the IDE (all properties, methods, and operations can be expanded in your favorite Java IDE).\n• Almost no syntactically invalid queries allowed (type-safe on all levels).\n• Domain types and properties can be referenced safely — no strings involved!\n• Adapts better to refactoring changes in domain types. See the QueryDSL documentation for how to bootstrap your environment for APT-based code generation using Maven or Ant. QueryDSL lets you write queries such as the following: is a class that is generated by the Java annotation post-processing tool.It is a that lets you write type-safe queries.Notice that there are no strings in the query other than the value. You can use the generated class by using the interface, which the following listing shows: To use this in your repository implementation, add it to the list of repository interfaces from which your interface inherits, as the following example shows: MongoDB’s full-text search feature is store-specific and, therefore, can be found on rather than on the more general . We need a document with a full-text index (see “Text Indexes” to learn how to create a full-text index). Additional methods on take as an input parameter. In addition to those explicit methods, it is also possible to add a -derived repository method. The criteria are added as an additional criteria. Once the entity contains a -annotated property, the document’s full-text score can be retrieved. Furthermore, the annotated also makes it possible to sort by the document’s score, as the following example shows: @Document class FullTextDocument { @Id String id; @TextIndexed String title; @TextIndexed String content; @TextScore Float score; } interface FullTextRepository extends Repository<FullTextDocument, String> { // Execute a full-text search and define sorting dynamically List<FullTextDocument> findAllBy(TextCriteria criteria, Sort sort); // Paginate over a full-text search result Page<FullTextDocument> findAllBy(TextCriteria criteria, Pageable pageable); // Combine a derived query with a full-text search List<FullTextDocument> findByTitleOrderByScoreDesc(String title, TextCriteria criteria); } Sort sort = Sort.by(\"score\"); TextCriteria criteria = TextCriteria.forDefaultLanguage().matchingAny(\"spring\", \"data\"); List<FullTextDocument> result = repository.findAllBy(criteria, sort); criteria = TextCriteria.forDefaultLanguage().matching(\"film\"); Page<FullTextDocument> page = repository.findAllBy(criteria, PageRequest.of(1, 1, sort)); List<FullTextDocument> result = repository.findByTitleOrderByScoreDesc(\"mongodb\", criteria); The repository layer offers means to interact with the aggregation framework via annotated repository query methods. Similar to the JSON based queries, you can define a pipeline using the annotation. The definition may contain simple placeholders like as well as SpEL expressions . Aggregation pipeline to group first names by in the collection returning these as . If argument is present, is appended after the declared pipeline stages so that it only affects the order of the final results after having passed all other aggregation stages. Therefore, the properties are mapped against the methods return type which turns into because is annotated with . Replaces with the given value for for a dynamic aggregation pipeline. , and can be passed on via a argument. Same as in <2>, the operators are appended to the pipeline definition. Methods accepting can return for easier pagination. Aggregation methods can return to consume results directly from an underlying cursor. Make sure to close the stream after consuming it to release the server-side cursor by either calling or through . Map the result of an aggregation returning a single to an instance of a desired target type. Aggregations resulting in single document holding just an accumulation result like eg. can be extracted directly from the result . To gain more control, you might consider as method return type as shown in <7>. Obtain the raw mapped to the generic target wrapper type or . Like in <6>, a single value can be directly obtained from multiple result s. In some scenarios, aggregations might require additional options, such as a maximum run time, additional log comments, or the permission to temporarily write data to disk. Use the annotation to set those options via , or . Or use to create your own annotation as shown in the sample below. You can use also with Reactive Repositories. Simple-type single-result inspects the returned and checks for the following:\n• Only one entry in the document, return it.\n• Two entries, one is the value. Return the other.\n• Return for the first value assignable to the return type.\n• Throw an exception if none of the above is applicable. The return type is not supported for repository methods using . However, you can use a argument to add , and to the pipeline and let the method return . Instances of the repository interfaces are usually created by a container, and Spring is the most natural choice when working with Spring Data. As of version 1.3.0, Spring Data MongoDB ships with a custom CDI extension that lets you use the repository abstraction in CDI environments. The extension is part of the JAR. To activate it, drop the Spring Data MongoDB JAR into your classpath. You can now set up the infrastructure by implementing a CDI Producer for the , as the following example shows: The Spring Data MongoDB CDI extension picks up the available as a CDI bean and creates a proxy for a Spring Data repository whenever a bean of a repository type is requested by the container. Thus, obtaining an instance of a Spring Data repository is a matter of declaring an -ed property, as the following example shows:\n\nRich mapping support is provided by the . has a rich metadata model that provides a full feature set to map domain objects to MongoDB documents. The mapping metadata model is populated by using annotations on your domain objects. However, the infrastructure is not limited to using annotations as the only source of metadata information. The also lets you map objects to documents without providing any additional metadata, by following a set of conventions. This section describes the features of the , including fundamentals, how to use conventions for mapping objects to documents and how to override those conventions with annotation-based mapping metadata. has a few conventions for mapping objects to documents when no additional mapping metadata is provided. The conventions are:\n• The short Java class name is mapped to the collection name in the following manner. The class maps to the collection name.\n• All nested objects are stored as nested objects in the document and not as DBRefs.\n• The converter uses any Spring Converters registered with it to override the default mapping of object properties to document fields and values.\n• The fields of an object are used to convert to and from fields in the document. Public properties are not used.\n• If you have a single non-zero-argument constructor whose constructor argument names match top-level field names of document, that constructor is used. Otherwise, the zero-argument constructor is used. If there is more than one non-zero-argument constructor, an exception will be thrown. 17.1.1. How the field is handled in the mapping layer. MongoDB requires that you have an field for all documents. If you don’t provide one the driver will assign a ObjectId with a generated value. The \"_id\" field can be of any type the, other than arrays, so long as it is unique. The driver naturally supports all primitive types and Dates. When using the there are certain rules that govern how properties from the Java class is mapped to this field. The following outlines what field will be mapped to the document field:\n• A field annotated with ( ) will be mapped to the field.\n• A field without an annotation but named will be mapped to the field.\n• The default field name for identifiers is and can be customized via the annotation. Table 14. Examples for the translation of field definitions The following outlines what type conversion, if any, will be done on the property mapped to the _id document field.\n• If a field named is declared as a String or BigInteger in the Java class it will be converted to and stored as an ObjectId if possible. ObjectId as a field type is also valid. If you specify a value for in your application, the conversion to an ObjectId is detected to the MongoDB driver. If the specified value cannot be converted to an ObjectId, then the value will be stored as is in the document’s _id field. This also applies if the field is annotated with .\n• If a field is annotated with in the Java class it will be converted to and stored as using its actual type. No further conversion happens unless declares a desired field type.\n• If a field is annotated with in the Java class it will be attempted to convert the value to the declared\n• If a field named id field is not declared as a String, BigInteger, or ObjectID in the Java class then you should assign it a value in your application so it can be stored 'as-is' in the document’s _id field.\n• If no field named is present in the Java class then an implicit file will be generated by the driver but not mapped to a property or field of the Java class. When querying and updating will use the converter to handle conversions of the and objects that correspond to the above rules for saving documents so field names and types used in your queries will be able to match what is in your domain classes. This section explains how types are mapped to and from a MongoDB representation. Spring Data MongoDB supports all types that can be represented as BSON, MongoDB’s internal document format. In addition to these types, Spring Data MongoDB provides a set of built-in converters to map additional types. You can provide your own converters to adjust type conversion. See [mapping-explicit-converters] for further details. The following provides samples of each available type conversion: {\"_id\" : \"script name\", value: (some javascript code) } Unless explicitly configured, an instance of is created by default when you create a . You can create your own instance of the . Doing so lets you dictate where in the classpath your domain classes can be found, so that Spring Data MongoDB can extract metadata and construct indexes. Also, by creating your own instance, you can register Spring converters to map specific classes to and from the database. You can configure the as well as and MongoTemplate by using either Java-based or XML-based metadata. The following example uses Spring’s Java-based configuration: @Configuration public class MongoConfig extends AbstractMongoClientConfiguration { @Override public String getDatabaseName() { return \"database\"; } // the following are optional @Override public String getMappingBasePackage() { (1) return \"com.bigbank.domain\"; } @Override void configureConverters(MongoConverterConfigurationAdapter adapter) { (2) adapter.registerConverter(new org.springframework.data.mongodb.test.PersonReadConverter()); adapter.registerConverter(new org.springframework.data.mongodb.test.PersonWriteConverter()); } @Bean public LoggingEventListener<MongoMappingEvent> mappingEventsListener() { return new LoggingEventListener<MongoMappingEvent>(); } } The mapping base package defines the root path used to scan for entities used to pre initialize the . By default the configuration classes package is used. Configure additional custom converters for specific domain types that replace the default mapping procedure for those types with your custom implementation. requires you to implement methods that define a as well as provide a database name. also has a method named that you can override to tell the converter where to scan for classes annotated with the annotation. You can add additional converters to the converter by overriding the method. MongoDB’s native JSR-310 support can be enabled through . Also shown in the preceding example is a , which logs instances that are posted onto Spring’s infrastructure. creates a instance and registers it with the container under the name . Spring’s MongoDB namespace lets you enable mapping functionality in XML, as the following example shows: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mongo=\"http://www.springframework.org/schema/data/mongo\" xsi:schemaLocation=\" http://www.springframework.org/schema/data/mongo https://www.springframework.org/schema/data/mongo/spring-mongo.xsd http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"> <!-- Default bean name is 'mongo' --> <mongo:mongo-client host=\"localhost\" port=\"27017\"/> <mongo:db-factory dbname=\"database\" mongo-ref=\"mongoClient\"/> <!-- by default look for a Mongo object named 'mongo' - default name used for the converter is 'mappingConverter' --> <mongo:mapping-converter base-package=\"com.bigbank.domain\"> <mongo:custom-converters> <mongo:converter ref=\"readConverter\"/> <mongo:converter> <bean class=\"org.springframework.data.mongodb.test.PersonWriteConverter\"/> </mongo:converter> </mongo:custom-converters> </mongo:mapping-converter> <bean id=\"readConverter\" class=\"org.springframework.data.mongodb.test.PersonReadConverter\"/> <!-- set the mapping converter to be used by the MongoTemplate --> <bean id=\"mongoTemplate\" class=\"org.springframework.data.mongodb.core.MongoTemplate\"> <constructor-arg name=\"mongoDbFactory\" ref=\"mongoDbFactory\"/> <constructor-arg name=\"mongoConverter\" ref=\"mappingConverter\"/> </bean> <bean class=\"org.springframework.data.mongodb.core.mapping.event.LoggingEventListener\"/> </beans> The property tells it where to scan for classes annotated with the annotation. To take full advantage of the object mapping functionality inside the Spring Data MongoDB support, you should annotate your mapped objects with the annotation. Although it is not necessary for the mapping framework to have this annotation (your POJOs are mapped correctly, even without any annotations), it lets the classpath scanner find and pre-process your domain objects to extract the necessary metadata. If you do not use this annotation, your application takes a slight performance hit the first time you store a domain object, because the mapping framework needs to build up its internal metadata model so that it knows about the properties of your domain object and how to persist them. The following example shows a domain object: The annotation tells the mapper which property you want to use for the MongoDB property, and the annotation tells the mapping framework to call on that property of your document, making searches faster. Automatic index creation is only done for types annotated with . Auto index creation is disabled by default and needs to be enabled through the configuration (see Index Creation). Spring Data MongoDB can automatically create indexes for entity types annotated with . Index creation must be explicitly enabled since version 3.0 to prevent undesired effects with collection lifecyle and performance impact. Indexes are automatically created for the initial entity set on application startup and when accessing an entity type for the first time while the application runs. We generally recommend explicit index creation for application-based control of indexes as Spring Data cannot automatically create indexes for collections that were recreated while the application was running. provides an abstraction for programmatic index definition creation if you want to make use of annotations such as , , . You can use index definitions with to create indexes. A good point in time for index creation is on application startup, specifically after the application context was refreshed, triggered by observing . This event guarantees that the context is fully initialized. Note that at this time other components, especially bean factories might have access to the MongoDB database. Example 102. Programmatic Index Creation for all Initial Entities class MyListener{ @EventListener(ContextRefreshedEvent.class) public void initIndicesAfterStartup() { MappingContext<? extends MongoPersistentEntity<?>, MongoPersistentProperty> mappingContext = mongoTemplate .getConverter().getMappingContext(); // consider only entities that are annotated with @Document mappingContext.getPersistentEntities() .stream() .filter(it -> it.isAnnotationPresent(Document.class)) .forEach(it -> { IndexOperations indexOps = mongoTemplate.indexOps(it.getType()); resolver.resolveIndexFor(it.getType()).forEach(indexOps::ensureIndex); }); } } Alternatively, if you want to ensure index and collection presence before any component is able to access your database from your application, declare a method for and include the code from above before returning the object. To turn automatic index creation ON please override in your configuration. Automatic index creation is turned OFF by default as of version 3.0. The MappingMongoConverter can use metadata to drive the mapping of objects to documents. The following annotations are available:\n• : Applied at the field level to mark the field used for identity purpose.\n• : Applied at the field level to mark the field used for identity purpose. Accepts an optional to customize id conversion.\n• : Applied at the class level to indicate this class is a candidate for mapping to the database. You can specify the name of the collection where the data will be stored.\n• : Applied at the field to indicate it is to be stored using a com.mongodb.DBRef.\n• : Applied at the field to indicate it is to be stored as a pointer to another document. This can be a single value (the id by default), or a provided via a converter.\n• : Applied at the field level to describe how to index the field.\n• (repeatable): Applied at the type level to declare Compound Indexes.\n• : Applied at the field level to describe how to geoindex the field.\n• : Applied at the field level to mark the field to be included in the text index.\n• : Applied at the field level for usage within a hashed index to partition data across a sharded cluster.\n• : Applied at the field level to set the language override property for text index.\n• : By default, all fields are mapped to the document. This annotation excludes the field where it is applied from being stored in the database. Transient properties cannot be used within a persistence constructor as the converter cannot materialize a value for the constructor argument.\n• : Marks a given constructor - even a package protected one - to use when instantiating the object from the database. Constructor arguments are mapped by name to the key values in the retrieved Document.\n• : This annotation is part of the Spring Framework . Within the mapping framework it can be applied to constructor arguments. This lets you use a Spring Expression Language statement to transform a key’s value retrieved in the database before it is used to construct a domain object. In order to reference a property of a given document one has to use expressions like: where refers to the root of the given document.\n• : Applied at the field level it allows to describe the name and type of the field as it will be represented in the MongoDB BSON document thus allowing the name and type to be different than the fieldname of the class as well as the property type.\n• : Applied at field level is used for optimistic locking and checked for modification on save operations. The initial value is ( for primitive types) which is bumped automatically on every update. The mapping metadata infrastructure is defined in a separate spring-data-commons project that is technology agnostic. Specific subclasses are using in the MongoDB support to support annotation based metadata. Other strategies are also possible to put in place if there is demand. Here is an example of a more complex mapping. @Document @CompoundIndex(name = \"age_idx\", def = \"{'lastName': 1, 'age': -1}\") public class Person<T extends Address> { @Id private String id; @Indexed(unique = true) private Integer ssn; @Field(\"fName\") private String firstName; @Indexed private String lastName; private Integer age; @Transient private Integer accountTotal; @DBRef private List<Account> accounts; private T address; public Person(Integer ssn) { this.ssn = ssn; } @PersistenceConstructor public Person(Integer ssn, String firstName, String lastName, Integer age, T address) { this.ssn = ssn; this.firstName = firstName; this.lastName = lastName; this.age = age; this.address = address; } public String getId() { return id; } // no setter for Id. (getter is only exposed for some unit testing) public Integer getSsn() { return ssn; } // other getters/setters omitted } can come in handy when the native MongoDB type inferred by the mapping infrastructure does not match the expected one. Like for , which is represented as instead of , just because earlier versions of MongoDB Server did not have support for it. You may even consider your own, custom annotation. The mapping subsystem allows the customization of the object construction by annotating a constructor with the annotation. The values to be used for the constructor parameters are resolved in the following way:\n• If a parameter is annotated with the annotation, the given expression is evaluated and the result is used as the parameter value.\n• If the Java type has a property whose name matches the given field of the input document, then it’s property information is used to select the appropriate constructor parameter to pass the input field value to. This works only if the parameter name information is present in the java files which can be achieved by compiling the source with debug information or using the new command-line switch for javac in Java 8.\n• Otherwise a will be thrown indicating that the given constructor parameter could not be bound. The SpEL expression in the annotation of the parameter falls back to the value if the given property path cannot be resolved. Additional examples for using the annotation can be found in the MappingMongoConverterUnitTests test suite. Compound indexes are also supported. They are defined at the class level, rather than on individual properties. Compound indexes are very important to improve the performance of queries that involve criteria on multiple fields Here’s an example that creates a compound index of in ascending order and in descending order: is repeatable using as its container. Hashed indexes allow hash based sharding within a sharded cluster. Using hashed field values to shard collections results in a more random distribution. For details, refer to the MongoDB Documentation. Here’s an example that creates a hashed index for : Hashed indexes can be created next to other index definitions like shown below, in that case both indices are created: Example 105. Example Hashed Index Usage togehter with simple index In case the example above is too verbose, a compound annotation allows to reduce the number of annotations that need to be declared on a property: @Document public class DomainType { @IndexAndHash(name = \"idx...\") (1) String value; // ... } @Indexed @HashIndexed @Retention(RetentionPolicy.RUNTIME) public @interface IndexAndHash { @AliasFor(annotation = Indexed.class, attribute = \"name\") (1) String name() default \"\"; } Potentially register an alias for certain attributes of the meta annotation. Although index creation via annotations comes in handy for many scenarios cosider taking over more control by setting up indices manually via . A is an index that can be used to include all fields or specific ones based a given (wildcard) pattern. For details, refer to the MongoDB Documentation. The index can be set up programmatically using via . The annotation allows a declarative index setup that can used either with a document type or property. If placed on a type that is a root level domain entity (one annotated with ) , the index resolver will create a wildcard index for it. The can be used to specify keys to in-/exclude in the index. Wildcard indexes can also be expressed by adding the annotation directly to the field. Please note that is not allowed on nested paths such as properties. Projections on types annotated with are omitted during index creation. The text index feature is disabled by default for MongoDB v.2.4. Creating a text index allows accumulating several fields into a searchable full-text index. It is only possible to have one text index per collection, so all fields marked with are combined into this index. Properties can be weighted to influence the document score for ranking results. The default language for the text index is English.To change the default language, set the attribute to whichever language you want (for example, ). Using a property called or lets you define a language override on a per-document base. The following example shows how to created a text index and set the language to Spanish: The mapping framework does not have to store child objects embedded within the document. You can also store them separately and use a to refer to that document. When the object is loaded from MongoDB, those references are eagerly resolved so that you get back a mapped object that looks the same as if it had been stored embedded within your top-level document. The following example uses a DBRef to refer to a specific document that exists independently of the object in which it is referenced (both classes are shown in-line for brevity’s sake): You need not use or similar mechanisms because the List of objects tells the mapping framework that you want a one-to-many relationship. When the object is stored in MongoDB, there is a list of DBRefs rather than the objects themselves. When it comes to loading collections of s it is advisable to restrict references held in collection types to a specific MongoDB collection. This allows bulk loading of all references, whereas references pointing to different MongoDB collections need to be resolved one by one. The mapping framework does not handle cascading saves. If you change an object that is referenced by a object, you must save the object separately. Calling on the object does not automatically save the objects in the property. s can also be resolved lazily. In this case the actual or of references is resolved on first access of the property. Use the attribute of to specify this. Required properties that are also defined as lazy loading and used as constructor arguments are also decorated with the lazy loading proxy making sure to put as little pressure on the database and network as possible. Lazily loaded s can be hard to debug. Make sure tooling does not accidentally trigger proxy resolution by e.g. calling or some inline debug rendering invoking property getters. Please consider to enable trace logging for to gain insight on resolution. Lazy loading may require class proxies, that in turn, might need access to jdk internals, that are not open, starting with Java 16+, due to JEP 396: Strongly Encapsulate JDK Internals by Default. For those cases please consider falling back to an interface type (eg. switch from to ) or provide the required argument. Using offers a flexible way of referencing entities in MongoDB. While the goal is the same as when using DBRefs, the store representation is different. resolves to a document with a fixed structure as outlined in the MongoDB Reference documentation.\n\n Document references, do not follow a specific format. They can be literally anything, a single value, an entire document, basically everything that can be stored in MongoDB. By default, the mapping layer will use the referenced entities id value for storage and retrieval, like in the sample below. Mark the collection of values to be referenced. The mapping framework does not handle cascading saves, so make sure to persist the referenced entity individually. Add the reference to the existing entity. Referenced entities are represented as an array of their values. The sample above uses an -based fetch query ( ) for data retrieval and resolves linked entities eagerly. It is possible to alter resolution defaults (listed below) using the attributes of The target database name for collection lookup. The annotated property’s domain type, respectively the value type in case of like or properties, collection name. The single document lookup query evaluating placeholders via SpEL expressions using as the marker for a given source value. like or properties combine individual lookups via an operator. An field based query ( ) using the loaded source value. Used for sorting result documents on server side. None by default. Result order of like properties is restored based on the used lookup query on a best-effort basis. If set to value resolution is delayed upon first access of the property. Lazy loading may require class proxies, that in turn, might need access to jdk internals, that are not open, starting with Java 16+, due to JEP 396: Strongly Encapsulate JDK Internals by Default. For those cases please consider falling back to an interface type (eg. switch from to ) or provide the required argument. allows defining filter queries that can be different from the field and therefore offer a flexible way of defining references between entities as demonstrated in the sample below, where the of a book is referenced by its acronym instead of the internal . Use the field to query for entities in the collection. The above snippet shows the reading side of things when working with custom referenced objects. Writing requires a bit of additional setup as the mapping information do not express where stems from. The mapping layer requires registration of a between the target document and , like the one below: If no converter is provided the target reference document can be computed based on the given lookup query. In this case the association target properties are evaluated as shown in the following sample. Use the field to query for entities in the collection. The field value placeholders of the lookup query (like ) is used to form the reference document. It is also possible to model relational style One-To-Many references using a combination of and . This approach allows link types without storing the linking values within the owning document but rather on the referencing document as shown in the example below. Set up the link from (reference) to (owner) by storing the within the document. Mark the property holding the references to be readonly. This prevents storing references to individual s with the document. Use the variable to access values within the document and in this retrieve with matching . With all the above in place it is possible to model all kind of associations between entities. Have a look at the non-exhaustive list of samples below to get feeling for what is possible. MongoDB simple type can be directly used without further configuration. Example 113. Simple Document Reference using id field with explicit lookup query target defines the reference value itself. Example 114. Document Reference extracting the field for the lookup query The key used for obtaining the reference value must be the one used during write. Example 115. Document Reference with multiple values forming the lookup query Read/wirte the keys & from/to the linkage document based on the lookup query. Use non id fields for the lookup of the target documents. Read/wirte the keys from/to the reference document to use them in the lookup query. The collection name can be read from the reference document using its key. We know it is tempting to use all kinds of MongoDB query operators in the lookup query and this is fine. But there a few aspects to consider:\n• Make sure to have indexes in place that support your lookup.\n• A collection of document references is bulk loaded using the operator.\n\n The original element order is restored in memory on a best-effort basis. Restoring the order is only possible when using equality expressions and cannot be done when using MongoDB query operators. In this case results will be ordered as they are received from the store or via the provided attribute.\n• Do you use cyclic references? Ask your self if you need them.\n• Lazy document references are hard to debug. Make sure tooling does not accidentally trigger proxy resolution by e.g. calling .\n• There is no support for reading document references using reactive infrastructure. Events are fired throughout the lifecycle of the mapping process. This is described in the Lifecycle Events section. Declaring these beans in your Spring ApplicationContext causes them to be invoked whenever the event is dispatched. Unwrapped entities are used to design value objects in your Java domain model whose properties are flattened out into the parent’s MongoDB Document. Consider the following domain model where is annotated with . The annotation signals that all properties of should be flattened out into the document that owns the property. When loading the property its value is set to if both and are either or not present. By using an empty , with potential value for its properties, will be created. For less verbose embeddable type declarations use and instead and . Both annotations are meta-annotated with JSR-305 to aid with nullability inspections. It is possible to use complex types within an unwrapped object. However, those must not be, nor contain unwrapped fields themselves. A value object can be unwrapped multiple times by using the optional attribute of the annotation. By dosing so the chosen prefix is prepended to each property or name in the unwrapped object. Please note that values will overwrite each other if multiple properties render to the same field name. Example 118. Sample Code of unwrapped object with name prefix All properties of are prefixed with . All properties of are prefixed with . While combining the annotation with on the very same property does not make sense and therefore leads to an error. It is a totally valid approach to use on any of the unwrapped types properties. All properties of are prefixed with . Final field names are a result of concatenating and . Defining queries on unwrapped properties is possible on type- as well as field-level as the provided is matched against the domain type. Prefixes and potential custom field names will be considered when rendering the actual query. Use the property name of the unwrapped object to match against all contained fields as shown in the sample below. It is also possible to address any field of the unwrapped object directly using its property name as shown in the snippet below. Example 121. Query on field of unwrapped object Fields of unwrapped objects can be used for sorting via their property path as shown in the sample below. Though possible, using the unwrapped object itself as sort criteria includes all of its fields in unpredictable order and may result in inaccurate ordering. Fields of unwrapped objects can be subject for projection either as a whole or via single fields as shown in the samples below. A field projection on an unwrapped object includes all of its properties. Example 124. Project on a field of an unwrapped object. A field projection on an unwrapped object includes all of its properties. Query By Example on unwrapped object. Unwrapped objects can be used within an probe just as any other type. Please review the Query By Example section, to learn more about this feature. The abstraction allows deriving queries on fields of unwrapped objects as well as the entire object. Matches against all fields of the unwrapped object. Index creation for unwrapped objects is suspended even if the repository namespace attribute is set to . Unwrapped objects can be updated as any other object that is part of the domain model. The mapping layer takes care of flattening structures into their surroundings. It is possible to update single attributes of the unwrapped object as well as the entire value as shown in the examples below. Example 126. Update a single field of an unwrapped object. The Aggregation Framework will attempt to map unwrapped values of typed aggregations. Please make sure to work with the property path including the wrapper object when referencing one of its values. Other than that no special action is required. It is possible to attach the annotation to properties of an unwrapped type just as it is done with regular objects. It is not possible to use along with the annotation on the owning property. The most trivial way of influencing the mapping result is by specifying the desired native MongoDB target type via the annotation. This allows to work with non MongoDB types like in the domain model while persisting values in native format. String id values that represent a valid are converted automatically. See How the Field is Handled in the Mapping Layer for details. The desired target type is explicitly defined as which translates to . Otherwise the value would have been truned into a . values are handled by the MongoDB driver itself an are stored as . The snippet above is handy for providing simple type hints. To gain more fine-grained control over the mapping process, you can register Spring converters with the implementations, such as the . The checks to see if any Spring converters can handle a specific class before attempting to map the object itself. To 'hijack' the normal mapping strategies of the , perhaps for increased performance or other custom mapping needs, you first need to create an implementation of the Spring interface and then register it with the . For more information on the Spring type conversion service, see the reference docs here. The following example shows an implementation of the that converts from a object to a : The following example shows an implementation of a that converts from a to a object:"
    },
    {
        "link": "https://stackoverflow.com/questions/34427241/in-spring-data-mongodb-how-to-achieve-pagination-for-aggregation",
        "document": "This is an answer to an old post, but I'll provide an answer in case anyone else comes along while searching for something like this.\n\nBuilding on the previous solution by Fırat KÜÇÜK, giving the results.size() as the value for the \"total\" field in the PageImpl constructor will not making paging work the way, well, you expect paging to work. It sets the total size to the page size every time, so instead, you need to find out the actual total number of results that your query would return:\n\nNow, then, the best way to get the total number of results is another question, and it is one that I am currently trying to figure out. The method that I tried (and it worked) was to almost run the same aggregation twice, (once to get the total count, and again to get the actual results for paging) but using only the MatchOperation followed by a GroupOperation to get the count:\n\nIt seems kind of inefficient to run nearly the same query twice, but if you are going to page results, the pageable object must know the total number of results if you really want it to behave like paging. If anyone can improve on my method to get the total count of results, that would be awesome!\n\nEdit: This will also provide the count, and it is simpler because you do not need a wrapper object to hold the result, so you can replace the entire previous code block with this one:"
    },
    {
        "link": "https://mongodb.com/community/forums/t/pagination-in-mongodb-right-way-to-do-it-vs-common-mistakes/208429",
        "document": "I’m excited to share my latest article: Pagination in MongoDB: The Only Right Way to Implement it (Avoid Common Mistakes).\n\nI noticed that many articles, tutorials, and courses do not implement pagination correctly, leading to issues such as data inconsistency and decreased performance. So, in this article I showed how to implement the pagination correctly in MongoDB with the use of Aggregation Framework, as well as how to avoid common mistakes.\n\nI’ve put a lot of effort into creating and I would be thrilled if you could take a look and provide me with any feedback you have. Your input would be greatly appreciated as I am just starting my blog.\n\nThank you for your time and support!"
    },
    {
        "link": "https://docs.spring.io/spring-data/data-document/docs/current/reference/html",
        "document": "This document is the reference guide for Spring Data - Document Support. It explains Document module concepts and semantics and the syntax for various stores namespaces. This section provides some basic introduction to Spring and Document database. The rest of the document refers only to Spring Data Document features and assumes the user is familiar with document databases such as MongoDB and CouchDB as well as Spring concepts. Spring Data uses Spring framework's core functionality, such as the IoC container, type conv ersion system, expression language, JMX integration, and portable DAO exception hierarchy. While it is not important to know the Spring APIs, understanding the concepts behind them is. At a minimum, the idea behind IoC should be familiar for whatever IoC container you choose to use. The core functionality of the MongoDB and CouchDB support can be used directly, with no need to invoke the IoC services of the Spring Container. This is much like which can be used 'standalone' without any other services of the Spring container. To leverage all the features of Spring Data document, such as the repository support, you will need to configure some parts of the library using Spring. To learn more about Spring, you can refer to the comprehensive (and sometimes disarming) documentation that explains in detail the Spring Framework. There are a lot of articles, blog entries and books on the matter - take a look at the Spring framework home page for more information. NoSQL stores have taken the storage world by storm. It is a vast domain with a plethora of solutions, terms and patterns (to make things worth even the term itself has multiple meanings). While some of the principles are common, it is crucial that the user is familiar to some degree with the stores supported by DATADOC. The best way to get acquainted to this solutions is to read their documentation and follow their examples - it usually doesn't take more then 5-10 minutes to go through them and if you are coming from an RDMBS-only background many times these exercises can be an eye opener. The jumping off ground for learning about MongoDB is www.mongodb.org. Here is a list of other useful resources.\n• None The online shell provides a convenient way to interact with a MongoDB instance in combination with the online tutorial.\n• None Several books available for purchase The Spring Framework is the leading full-stack Java/JEE application framework. It provides a lightweight container and a non-invasive programming model enabled by the use of dependency injection, AOP, and portable service abstractions. NoSQL storages provide an alternative to classical RDBMS for horizontal scalability and speed. In terms of implementation, Document stores represent one of the most popular types of stores in the NoSQL space. The document database supported by Spring Data are MongoDB and CouchDB, though just MongoDB integration has been released to date. The goal of the Spring Data Document (or DATADOC) framework is to provide an extension to the Spring programming model that supports writing applications that use Document databases. The Spring framework has always promoted a POJO programming model with a strong emphasis on portability and productivity. These values are caried over into Spring Data Document. Notable features that are used in Spring Data Document from the Spring framework are the Features that particular, features from the Spring framework that are used are the Conversion Service, JMX Exporters, portable Data Access Exception hierarchy, Spring Expression Language, and Java based IoC container configuration. The programming model follows the familiar Spring 'template' style, so if you are familar with Spring template classes such as JdbcTemplate, JmsTemplate, RestTemplate, you will feel right at home. For example, MongoTemplate removes much of the boilerplate code you would have to write when using the MongoDB driver to save POJOs as well as a rich java based query interface to retrieve POJOs. The programming model also offers a new Repository approach in which the Spring container will provide an implementation of a Repository based soley off an interface definition which can also include custom finder methods. Spring Data Document 1.x binaries requires JDK level 6.0 and above, and Spring Framework 3.0.x and above. In terms of document stores, MongoDB preferably version 1.6.5 or later or CouchDB 1.0.1 or later are required. Learning a new framework is not always straight forward. In this section, we try to provide what we think is an easy to follow guide for starting with Spring Data Document module. However, if you encounter issues or you are just looking for an advice, feel free to use one of the links below: There are a few support options available: The Spring Data forum is a message board for all Spring Data (not just Document) users to share information and help each other. Note that registration is needed only for posting. Professional, from-the-source support, with guaranteed response time, is available from SpringSource, the company behind Spring Data and Spring. For information on the Spring Data Mongo source code repository, nightly builds and snapshot artifacts please see the Spring Data Mongo homepage. You can help make Spring Data best serve the needs of the Spring community by interacting with developers through the Spring Community forums. To follow developer activity look for the mailing list information on the Spring Data Mongo homepage. If you encounter a bug or want to suggest an improvement, please create a ticket on the Spring Data issue tracker. To stay up to date with the latest news and announcements in the Spring eco system, subscribe to the Spring Community Portal. Lastly, you can follow the SpringSource Data blog or the project team on Twitter (SpringData) Implementing a data access layer of an application has been cumbersome for quite a while. Too much boilerplate code had to be written. Domain classes were anemic and not designed in a real object oriented or domain driven manner. Using both of these technologies makes developers life a lot easier regarding rich domain model's persistence. Nevertheless the amount of boilerplate code to implement repositories especially is still quite high. So the goal of the repository abstraction of Spring Data is to reduce the effort to implement data access layers for various persistence stores significantly. The following chapters will introduce the core concepts and interfaces of Spring Data repositories. The central interface in Spring Data repository abstraction is (probably not that much of a surprise). It is typeable to the domain class to manage as well as the id type of the domain class. This interface mainly acts as marker interface to capture the types to deal with and help us when discovering interfaces that extend this one. Beyond that there's which provides some sophisticated functionality around CRUD for the entity being managed. Returns the entity identified by the given id. Returns whether an entity with the given id exists. \n\n Usually we will have persistence technology specific sub-interfaces to include additional technology specific methods. We will now ship implementations for a variety of Spring Data modules that implement this interface. On top of the there is a abstraction that adds additional methods to ease paginated access to entities: \n\n Accessing the second page of by a page size of 20 you could simply do something like this: Next to standard CRUD functionality repositories are usually queries on the underlying datastore. With Spring Data declaring those queries becomes a four-step process:\n• None Declare an interface extending or one of its sub-interfaces and type it to the domain class it shall handle.\n• None Setup Spring to create proxy instances for those interfaces.\n• None Get the repository instance injected and use it. At this stage we barely scratched the surface of what's possible with the repositories but the general approach should be clear. Let's go through each of these steps and figure out details and various options that you have at each stage. As a very first step you define a domain class specific repository interface. It's got to extend and be typed to the domain class and an ID type. If you want to expose CRUD methods for that domain type, extend instead of . Usually you will have your repository interface extend , or . If you don't like extending Spring Data interfaces at all you can also annotate your repository interface with . Extending will expose a complete set of methods to manipulate your entities. If you would rather be selective about the methods being exposed, simply copy the ones you want to expose from into your domain repository. \n\n In the first step we define a common base interface for all our domain repositories and expose as well as .These methods will be routed into the base repository implementation of the store of your choice because they are matching the method signatures in . So our will now be able to save users, find single ones by id as well as triggering a query to find s by their email address. The next thing we have to discuss is the definition of query methods. There are two main ways that the repository proxy is able to come up with the store specific query from the method name. The first option is to derive the query from the method name directly, the second is using some kind of additionally created query. What detailed options are available pretty much depends on the actual store, however, there's got to be some algorithm that decides what actual query is created. There are three strategies available for the repository infrastructure to resolve the query. The strategy to be used can be configured at the namespace through the attribute. However, It might be the case that some of the strategies are not supported for specific datastores. Here are your options: This strategy will try to construct a store specific query from the query method's name. The general approach is to remove a given set of well-known prefixes from the method name and parse the rest of the method. Read more about query construction in Section 4.3.2.2, “Query creation”. This strategy tries to find a declared query which will be used for execution first. The query could be defined by an annotation somewhere or declared by other means. Please consult the documentation of the specific store to find out what options are available for that store. If the repository infrastructure does not find a declared query for the method at bootstrap time it will fail. This strategy is actually a combination of and . It will try to lookup a declared query first but create a custom method name based query if no declared query was found. This is the default lookup strategy and thus will be used if you don't configure anything explicitly. It allows quick query definition by method names but also custom tuning of these queries by introducing declared queries as needed. The query builder mechanism built into Spring Data repository infrastructure is useful to build constraining queries over entities of the repository. We will strip the prefixes , , , , as well as from the method and start parsing the rest of it. At a very basic level you can define conditions on entity properties and concatenate them with and . \n\n The actual result of parsing that method will of course depend on the persistence store we create the query for, however, there are some general things to notice. The expressions are usually property traversals combined with operators that can be concatenated. As you can see in the example you can combine property expressions with And and Or. Beyond that you also get support for various operators like , , , for the property expressions. As the operators supported can vary from datastore to datastore please consult the according part of the reference documentation. Property expressions can just refer to a direct property of the managed entity (as you just saw in the example above). On query creation time we already make sure that the parsed property is at a property of the managed domain class. However, you can also define constraints by traversing nested properties. Assume s have es with s. In that case a method name of will create the property traversal . The resolution algorithm starts with interpreting the entire part ( ) as property and checks the domain class for a property with that name (uncapitalized). If it succeeds it just uses that. If not it starts splitting up the source at the camel case parts from the right side into a head and a tail and tries to find the according property, e.g. and . If we find a property with that head we take the tail and continue building the tree down from there. As in our case the first split does not match we move the split point to the left ( , ). Although this should work for most cases, there might be cases where the algorithm could select the wrong property. Suppose our class has an property as well. Then our algorithm would match in the first split round already and essentially choose the wrong property and finally fail (as the type of probably has no code property). To resolve this ambiguity you can use inside your method name to manually define traversal points. So our method name would end up like so: To hand parameters to your query you simply define method parameters as already seen in the examples above. Besides that we will recognizes certain specific types to apply pagination and sorting to your queries dynamically. Example 4.5. Using Pageable and Sort in query methods \n\n The first method allows you to pass a instance to the query method to dynamically add paging to your statically defined query. options are handed via the instance too. If you only need sorting, simply add a parameter to your method. As you also can see, simply returning a is possible as well. We will then not retrieve the additional metadata required to build the actual instance but rather simply restrict the query to lookup only the given range of entities. To find out how many pages you get for a query entirely we have to trigger an additional count query. This will be derived from the query you actually trigger by default. So now the question is how to create instances and bean definitions for the repository interfaces defined. The easiest way to do so is by using the Spring namespace that is shipped with each Spring Data module that supports the repository mechanism. Each of those includes a repositories element that allows you to simply define a base package that Spring will scan for you. In this case we instruct Spring to scan com.acme.repositories and all its sub packages for interfaces extending or one of its sub-interfaces. For each interface found it will register the persistence technology specific to create the according proxies that handle invocations of the query methods. Each of these beans will be registered under a bean name that is derived from the interface name, so an interface of would be registered under . The attribute allows the use of wildcards, so that you can have a pattern of scanned packages. By default we will pick up every interface extending the persistence technology specific sub-interface located underneath the configured base package and create a bean instance for it. However, you might want finer grained control over which interfaces bean instances get created for. To do this we support the use of and elements inside . The semantics are exactly equivalent to the elements in Spring's context namespace. For details see Spring reference documentation on these elements. E.g. to exclude certain interfaces from instantiation as repository, you could use the following configuration: This would exclude all interfaces ending in from being instantiated. \n\n If you'd rather like to manually define which repository instances to create you can do this with nested elements. You can also use the repository infrastructure outside of a Spring container usage. You will still need to have some of the Spring libraries on your classpath but you can generally setup repositories programmatically as well. The Spring Data modules providing repository support ship a persistence technology specific that can be used as follows: \n\n Often it is necessary to provide a custom implementation for a few repository methods. Spring Data repositories easily allow you to provide custom repository code and integrate it with generic CRUD abstraction and query method functionality. To enrich a repository with custom functionality you have to define an interface and an implementation for that functionality first and let the repository interface you provided so far extend that custom interface. \n\n Note that the implementation itself does not depend on Spring Data and can be a regular Spring bean. So you can use standard dependency injection behaviour to inject references to other beans, take part in aspects and so on. \n\n Example 4.10. Changes to the your basic repository interface Let your standard repository interface extend the custom one. This makes CRUD and custom functionality available to clients. \n\n If you use namespace configuration the repository infrastructure tries to autodetect custom implementations by looking up classes in the package we found a repository using the naming conventions appending the namespace element's attribute to the classname. This suffix defaults to . \n\n The first configuration example will try to lookup a class to act as custom repository implementation, where the second example will try to lookup . The approach above works perfectly well if your custom implementation uses annotation based configuration and autowiring entirely as it will be treated as any other Spring bean. If your custom implementation bean needs some special wiring you simply declare the bean and name it after the conventions just described. We will then pick up the custom bean by name rather than creating an instance. This also works if you use automatic repository lookup without defining single elements. \n\n In case you are not in control of the implementation bean name (e.g. if you wrap a generic repository facade around an existing repository implementation) you can explicitly tell the element which bean to use as custom implementation by using the attribute. \n\n In other cases you might want to add a single method to all of your repository interfaces. So the approach just shown is not feasible. The first step to achieve this is adding and intermediate interface to declare the shared behaviour \n\n Now your individual repository interfaces will extend this intermediate interface to include the functionality declared. The second step is to create an implementation of this interface that extends the persistence technology specific repository base class which will act as custom base class for the repository proxies then. If you're using automatic repository interface detection using the Spring namespace using the interface just as is will cause Spring to create an instance of . This is of course not desired as it just acts as intermediary between and the actual repository interfaces you want to define for each entity. To exclude an interface extending from being instantiated as repository instance annotate it with . \n\n The last step to get this implementation used as base class for Spring Data repositories is replacing the standard with a custom one using a custom that in turn creates instances of your class. \n\n Finally you can either declare beans of the custom factory directly or use the attribute of the Spring namespace to tell the repository infrastructure to use your custom factory implementation. Example 4.17. Using the custom factory with the namespace \n\n\n\nThis part of the reference documentation explains the core functionality offered by Spring Data Document. The MongoDB support contains a wide range of features which are summarized below.\n• None Spring configuration support using Java based @Configuration classes or an XML namespace for a Mongo driver instance and replica sets\n• None MongoTemplate helper class that increases productivity performing common Mongo operations. Includes integrated object mapping between documents and POJOs.\n• None Annotation based mapping metadata but extensible to support other metadata formats\n• None Cross-store persistance - support for JPA Entities with fields transparently persisted/retrieved using MongoDB For most tasks you will find yourself using or the Repository support that both leverage the rich mapping functionality. MongoTemplate is the place to look for accessing functionality such as incrementing counters or ad-hoc CRUD operations. MongoTemplate also provides callback methods so that it is easy for you to get a hold of the low level API artifacts such as to communicate directly with MongoDB. The goal with naming conventions on various API artifacts is to copy those in the base MongoDB Java driver so you can easily map your existing knowledge onto the Spring APIs. Spring MongoDB support requires MongoDB 1.4 or higher and Java SE 5 or higher. The latest production release (2.0.x as of this writing) is recommended. An easy way to bootstrap setting up a working environment is to create a Spring based project in STS. First you need to set up a running Mongodb server. Refer to the Mongodb Quick Start guide for an explanation on how to startup a Mongo instance. Once installed starting Mongo is typically a matter of executing the following command: To create a Spring project in STS go to File -> New -> Spring Template Project -> Simple Spring Utility Project --> press Yes when prompted. Then enter a project and a package name such as org.spring.mongodb.example. Then add the following to pom.xml dependencies section. Also change the version of Spring in the pom.xml to be You will also need to add the location of the Spring Milestone repository for maven to your pom.xml which is at the same level of your <dependencies/> element The repository is also browseable here. You may also want to set the logging level to DEBUG to see some additional information, edit the log4j.properties file to have org.spring.mongodb.example; Person { String id; String name; age; Person(String name, age) { .name = name; .age = age; } String getId() { id; } String getName() { name; } getAge() { age; } @Override String toString() { + id + + name + + age + ; } } This will produce the following output 10:01:32,062 DEBUG apping.MongoPersistentEntityIndexCreator: 80 - Analyzing class class org.spring.example.Person for index information. 10:01:32,265 DEBUG work.data.mongodb.core.MongoTemplate: 631 - insert DBObject containing fields: [_class, age, name] in collection: Person 10:01:32,765 DEBUG work.data.mongodb.core.MongoTemplate:1243 - findOne using query: { \"name\" : \"Joe\"} in db.collection: database.Person 10:01:32,953 INFO org.spring.mongodb.example.MongoApp: 25 - Person [id=4ddbba3c0be56b7e1b210166, name=Joe, age=34] 10:01:32,984 DEBUG work.data.mongodb.core.MongoTemplate: 375 - Dropped collection [database.person] Even in this simple example, there are few things to take notice of\n• None You can instantiate the central helper class of Spring Mongo, MongoTemplate, using the standard object and the name of the database to use.\n• None The mapper works against standard POJO objects without the need for any additional metadata (though you can optionally provide that information. See here.).\n• None Conventions are used for handling the id field, converting it to be a ObjectId when stored in the database.\n• None Mapping conventions can use field access. Notice the Person class has only getters.\n• None If the constructor argument names match the field names of the stored document, they will be used to instantiate the object The following jars are required to use Spring Data Mongo In addition to the above listed Spring Data jars you need to provide the following dependencies: The following jars are required to use Spring Data MongoIn addition to the above listed Spring Data jars you need to provide the following dependencies: There were several API changes introduced in the M3 release. To upgrade from M2 to M3 you will need to make. For a full listing of API changes please refer to this JDiff Report. The major changes are with respect to MongoTemplate\n• None Constructors have changed on . and were removed. were added. These changes will also effect usage of wiring up in <bean/> XML defintions.\n• None no longer takes a default collection name. The collection name is now either specified when the method is invoked or inferred from the Java class, either the class name or via mapping metadata.\n• None Reordered parameters in some methods to make signatures more consistent across the board.\n• None Removed methods that use and . As an alternative register a Spring converter with the MappingMongoConverter. See here for details. There is an github repository with several examples that you can download and play around with to get a feel for how the library works. One of the first tasks when using MongoDB and Spring is to create a object using the IoC container. There are two main ways to do this, either using Java based bean metadata or XML based bean metadata. These are discussed in the following sections. For those not familiar with how to configure the Spring container using Java based bean metadata instead of XML based metadata see the high level introduction in the reference docs here as well as the detailed documentation here. An example of using Java based bean metadata to register an instance of a is shown below This approach allows you to use the standard API that you may already be used to using but also pollutes the code with the UnknownHostException checked exception. The use of the checked exception is not desirable as Java based bean metadata uses methods as a means to set object dependencies, making the calling code cluttered. An alternative is to register an instance of instance with the container using Spring's . As compared to instantiating a instance directly, the FactoryBean approach does not throw a checked exception and has the added advantage of also providing the container with an ExceptionTranslator implementation that translates Mongo exceptions to exceptions in Spring's portable hierarchy for data access classes annoated with the annotation. This hierarchy and use of is described in Spring's DAO support features. An example of a Java based bean metadata that supports exception translation on annotated classes is shown below: Example 5.2. Registering a com.mongodb.Mongo object using Spring's MongoFactoryBean and enabling Spring's exception translation support To access the object created by the in other or your own classes, use a \" \" field. \n\n While you can use Spring's traditional XML namespace to register an instance of with the container, the XML can be quite verbose as it is general purpose. XML namespaces are a better alternative to configuring commonly used objects such as the Mongo instance. The mongo namespace alows you to create a Mongo instance server location, replica-sets, and options. To use the Mongo namespace elements you will need to reference the Mongo schema: \n\n A more advanced configuration with MongoOptions is shown below (note these are not recommended values) Example 5.4. XML schema to configure a com.mongodb.Mongo object with MongoOptions \n\n A configuration using replica sets is shown below. Example 5.5. XML schema to configure com.mongodb.Mongo object with Replica Sets While com.mongodb.Mongo is the entry point to the MongoDB driver API, connecting to a specific MongoDB database instance requires additional information such as the database name and an optional username and password. With that information you can obtain a com.mongodb.DB object and access all the functionality of a specific MongoDB database instance. Spring provides the interface shown below to bootstrap connectivity to the database. The following sections show how you can use the contiainer with either Java or the XML based metadata to configure an instance of the interface. In turn, you can use the instance to configure MongoTemplate. The class provides implements the MongoDbFactory interface and is created with a standard instance, the database name and an optional constructor argument. Instead of using the IoC container to create an instance of MongoTemplate, you can just use them in standard Java code as shown below. The code in bold highlights the use of SimpleMongoDbFactory and is the only difference between the listing shown in the getting started section. To register a MongoDbFactory instance with the container, you write code much like what was highlighted in the previous code listing. A simple example is shown below To define the username and password create an instance of and pass it into the constructor as shown below. This listing also shows using register an instance of MongoTemplate with the container. The mongo namespace provides a convient way to create a as compared to using the namespace. Simple usage is shown below In the above example a instance is created using the default host and port number. The registered with the container is identified by the id 'mongoDbFactory' unless a value for the id attribute is specified. You can also provide the host and port for the underlying com.mongodb.Mongo instance as shown below, in addition to username and password for the database. If you need to configure additional options on the instance that is used to create a you can refer to an existing bean using the attribute as shown below. To show another common usage pattern, this listing show the use of a property placeholder to parameterise the configuration and creating . The class , located in the package , is the central class of the Spring's MongoDB support providng a rich feature set to interact with the database. The template offers convenience operations to create, update, delete and query for MongoDB documents and provides a mapping between your domain objects and MongoDB documents. Once configured, is thread-safe and can be reused across multiple instances. The mapping between Mongo documents and domain classes is done by delegating to an implementation of the interface . Spring provides two implementations, and , but you can also write your own converter. Please refer to the section on MongoCoverters for more detailed information. The class implements the interface . In as much as possible, the methods on are named after methods available on the MongoDB driver object as as to make the API familiar to existing MongoDB developers who are used to the driver API. For example, you will find methods such as \"find\", \"findAndModify\", \"findOne\", \"insert\", \"remove\", \"save\", \"update\" and \"updateMulti\". The design goal was to make it as easy as possible to transition between the use of the base MongoDB driver and . A major difference in between the two APIs is that MongOperations can be passed domain objects instead of and there are fluent APIs for , , and operations instead of populating a to specify the parameters for those operatiosn. The preferred way to reference the operations on instance is via its interface . The default converter implementation used by is MongoMappingConverter. While the can make use of additional metadata to specify the mapping of objects to documents it is also capable of converting objects that contain no additonal metadata by using some conventions for the mapping of IDs and collection names. These conventions as well as the use of mapping annotations is explained in the Mapping chapter. In the M2 release , was the default and this class is now deprecated as its functionality has been subsumed by the MongoMappingConverter. Another central feature of MongoTemplate is exception translation of exceptions thrown in the Mongo Java driver into Spring's portable Data Access Exception hierarchy. Refer to the section on exception translation for more information. While there are many convenience methods on to help you easily perform common tasks if you should need to access the Mongo driver API directly to access functionality not explicitly exposed by the MongoTemplate you can use one of several Execute callback methods to access underlying driver APIs. The execute callbacks will give you a reference to either a or a object. Please see the section Execution Callbacks for more information. Now let's look at a examples of how to work with the in the context of the Spring container. You can use Java to create and register an instance of MongoTemplate as shown below. \n\n There are several overloaded constructors of MongoTemplate. These are\n• None MongoTemplate - takes the com.mongodb.Mongo object and the default database name to operate against.\n• None MongoTemplate - adds the username and password for authenticating with the database.\n• None MongoTemplate - takes a MongoDbFactory object that encapsulated the com.mongodb.Mongo object, database name, and username and password.\n• None MongoTemplate - adds a MongoConverter to use for mapping. You can also configure a MongoTemplate using Spring's XML <beans/> schema. Other optional properties that you might like to set when creating a are the default , , and write option. The preferred way to reference the operations on instance is via its interface . When in development it is very handy to either log or throw an exception if the returned from any MongoDB operation contains an error. It is quite common to forget to do this during development and then end up with an application that looks like it runs successfully but in fact the database was not modified according to your expectations. Set MongoTemplate's WriteResultChecking property to an enum with the following values, LOG, EXCEPTION, or NONE to either log the error, throw and exception or do nothing. The default is to use a value of NONE. You can set the property that the will use for write operations if it has not yet been specified via the driver at a higher level such as com.mongodb.Mongo. If MongoTemplate's property is not set it will default to the one set in the MongoDB driver's DB or Collection setting. Setting the to different values when saving an object will be provided in a future release. This will most likely be handled using mapping metadata provided either in the form of annotations on the domain object or by an external fluent DSL. provides a simple way for you to save, update, and delete your domain objects and map those objects to documents stored in MongoDB. Given a simple class such as Person Person { String id; String name; age; Person(String name, age) { .name = name; .age = age; } String getId() { id; } String getName() { name; } getAge() { age; } @Override String toString() { + id + + name + + age + ; } } You can save, update and delete the object as shown below. is the interface that implements. This would produce the following log output (including debug messages from itself) DEBUG apping.MongoPersistentEntityIndexCreator: 80 - Analyzing class class org.spring.example.Person for index information. DEBUG work.data.mongodb.core.MongoTemplate: 632 - insert DBObject containing fields: [_class, age, name] in collection: person INFO org.spring.example.MongoApp: 30 - Insert: Person [id=4ddc6e784ce5b1eba3ceaf5c, name=Joe, age=34] DEBUG work.data.mongodb.core.MongoTemplate:1246 - findOne using query: { \"_id\" : { \"$oid\" : \"4ddc6e784ce5b1eba3ceaf5c\"}} in db.collection: database.person INFO org.spring.example.MongoApp: 34 - Found: Person [id=4ddc6e784ce5b1eba3ceaf5c, name=Joe, age=34] DEBUG work.data.mongodb.core.MongoTemplate: 778 - calling update using query: { \"name\" : \"Joe\"} and update: { \"$set\" : { \"age\" : 35}} in collection: person DEBUG work.data.mongodb.core.MongoTemplate:1246 - findOne using query: { \"name\" : \"Joe\"} in db.collection: database.person INFO org.spring.example.MongoApp: 39 - Updated: Person [id=4ddc6e784ce5b1eba3ceaf5c, name=Joe, age=35] DEBUG work.data.mongodb.core.MongoTemplate: 823 - remove using query: { \"id\" : \"4ddc6e784ce5b1eba3ceaf5c\"} in collection: person INFO org.spring.example.MongoApp: 46 - Number of people = : 0 DEBUG work.data.mongodb.core.MongoTemplate: 376 - Dropped collection [database.person] There was implicit conversion using the MongoConverter between a String and ObjectId as stored in the database and recognizing a convention of the property \"Id\" name. This example is meant to show the use of save, update and remove operations on MongoTemplate and not to show complex mapping functionality The query stynax used in the example is explained in more detail in the section Querying Documents. 5.5.1. How the '_id' field is handled in the mapping layer Mongo requires that you have an '_id' field for all documents. If you don't provide one the driver will assign a ObjectId with a generated value. When using the there are certain rules that govern how properties from the Java class is mapped to this '_id' field. The following outlines what property will be mapped to the '_id' document field:\n• None A property or field annotated with ( ) will be mapped to the '_id' field.\n• None A property or field without an annotation but named will be mapped to the '_id' field. The following outlines what type conversion, if any, will be done on the property mapped to the _id document field when using the , the default for .\n• None An id property or field declared as a String in the Java class will be converted to and stored as an ObjectId if possible using a Spring Converter<String, ObjectId>. Valid conversion rules are delegated to the Mongo Java driver. If it cannot be converted to an ObjectId, then the value will be stored as a string in the database.\n• None An id property or field declared as BigInteger in the Java class will be converted to and stored as an ObjectId using a Spring Converter<BigInteger, ObjectId>. If no field or property specified above is present in the Java class then an implicit '_id' file will be generated by the driver but not mapped to a property or field of the Java class. When querying and updating will use the converter to handle conversions of the and objects that correspond to the above rules for saving documents so field names and types used in your queries will be able to match what is in your domain classes. There are several convenient methods on for saving and inserting your objects. To have more fine grained control over the conversion process you can register Spring converters with the MappingMongoConverter, for example Converter<Person, DBObject> and Converter<DBObject, Person>. The difference between insert and save operations is that a save operation will perform an insert if the object is not already present. The simple case of using the save operation is to save a POJO. In this case the collection name will be determined by name (not fully qualfied) of the class. You may also call the save operation with a specific collection name. The collection to store the object can be overriden using mapping metadata. When inserting or saving, if the Id property is not set, the assumption is that its value will be autogenerated by the database. As such, for autogeneration of an ObjectId to succeed the type of the Id property/field in your class must be either a , , or . Here is a basic example of using the save operation and retrieving its contents. Example 5.7. Inserting and retrieving documents using the MongoTemplate \n\n The insert/save operations available to you are listed below.\n• None save Save the object to the default collection.\n• None save Save the object to the specified collection. A similar set of insert operations is listed below\n• None insert Insert the object to the default collection.\n• None insert Insert the object to the specified collection. 5.5.2.1. Which collection will my documents be saved into? There are two ways to manage the collection name that is used for operating on the documents. The default collection name that is used is the class name changed to start with a lower-case letter. So a class would be stored in the \"person\" collection. You can customize this by providing a different collection name using the @Document annotation. You can also override the collection name by providing your own collection name as the last parameter for the selected MongoTemplate method calls. The MongoDB driver supports inserting a collection of documents in one operation. The methods in the MongoOperations interface that support this functionality are listed below\n• None insert Insert an object. If there is an existing document with the same id then an error is generated.\n• None insertAll Takes a of objects as the first parameter. This method ispects each object and inserts it to the appropriate collection based on the rules specified above.\n• None save Save the object ovewriting any object that might exist with the same id. The MongoDB driver supports inserting a collection of documents in one operation. The methods in the MongoOperations interface that support this functionality are listed below\n• None insert as the first argument. This inserts a list of objects in a single batch write to the database. For updates we can elect to update the first document found using 's method or we can update all documents that were found to match the query using the method . Here is an example of an update of all SAVINGS accounts where we are adding a one time $50.00 bonus to the balance using the operator. Example 5.8. Updating documents using the MongoTemplate \n\n In addition to the discussed above we provide the update definition using an object. The class has methods that match the update modifiers available for MongoDB. As you can see most methods return the object to provide a fluent style for the API.\n• None updateFirst Updates the first document that matches the query document criteria with the provided updated document.\n• None updateMulti Updates all objects that match the query document criteria with the provided updated document. The Update class can be used with a little 'syntax sugar' as its methods are meant to be chained together and you can kickstart the creation of a new Update instance via the static method and using static imports. Here is a listing of methods on the Update class\n• None inc Update using the update modifier You can use several overloaded methods to remove an object from the database.\n• None remove Remove the given document based on one of the following: a specific object instance, a query document criteria combined with a class or a query document criteria combined with a specific collection name. You can express your queries using the and classes which have method names that mirror the native MongoDB operator names such as , , , and others. The and classes follow a fluent API style so that you can easily chain together multiple method criteria and queries while having easy to understand code. Static imports in Java are used to help remove the need to see the 'new' keyword for creating Query and Criteria instances so as to improve readability. GeoSpatial queries are also supported and are described more in the section GeoSpatial Queries. Map-Reduce operations are also supported and are described more in the section Map-Reduce. We saw how to retrieve a single document using the findOne and findById methods on MongoTemplate in previous sections which return a single domain object. We can also query for a collection of documents to be returned as a list of domain objects. Assuming that we have a number of Person objects with name and age stored as documents in a collection and that each person has an embedded account document with a balance. We can now run a query using the following code. Example 5.9. Querying for documents using the MongoTemplate \n\n All find methods take a object as a parameter. This object defines the criteria and options used to perform the query. The criteria is specified using a object that has a static factory method named used to instantiate a new object. We recommend using a static import for and to make the query more readable. This query should return a list of Person objects that meet the specified criteria. The Criteria class has the following methods that correspond to the operators provided in MongoDB. As you can see most methods return the object to provide a fluent style for the API.\n• None all Creates a criterion using the operator\n• None and Adds a chained with the specified to the current and retuns the newly created one\n• None andOperator Creates an and query using the operator for all of the provided criteria (requires MongoDB 2.0 or later)\n• None in Creates a criterion using the operator for a varargs argument.\n• None in Creates a criterion using the operator using a collection\n• None is Creates a criterion using the operator\n• None norOperator Creates an nor query using the operator for all of the provided criteria\n• None not Creates a criterion using the meta operator which affects the clause directly following\n• None orOperator Creates an or query using the operator for all of the provided criteria There are also methods on the Criteria class for geospatial queries. Here is al isting but look at the section on GeoSpatial Queries to see them in action.\n• None withinCenterSphere Creates a geospatial criterion using operators. This is only available for Mongo 1.7 and higher.\n• None nearSphere Creates a geospatial criterion using operations. This is only available for Mongo 1.7 and higher.\n• None maxDistance Creates a geospatial criterion using the operation, for use with $near. The class has some additional methods used to provide options for the query.\n• None addCriteria used to add additional criteria to the query\n• None fields used to define fields to be included in the query results\n• None limit used to limit the size of the returned results to the provided limit (used for paging)\n• None skip used to skip the provided number of documents in the results (used for paging)\n• None sort used to provide sort definition for the results The query methods need to specify the target type T that will be returned and they are also overloaded with an explicit collection name for queries that should operate on a collection other than the one indicated by the return type.\n• None findAll Query for a list of objects of type T from the collection.\n• None findOne Map the results of an ad-hoc query on the collection to a single instance of an object of the specified type.\n• None findById Return an object of the given id and target class.\n• None find Map the results of an ad-hoc query on the collection to a List of the specified type.\n• None findAndRemove Map the results of an ad-hoc query on the collection to a single instance of an object of the specified type. The first document that matches the query is returned and also removed from the collection in the database. MongoDB supports GeoSpatial queries through the use of operators such as , , and . Methods specific to geospatial queries are available on the class. There are also a few shape classes, , , and that are used in conjunction with geospatial related Criteria methods. To understand how to perform GeoSpatial queries we will use the following Venue class taken from the integration tests.which relies on using the rich . @Document(collection= ) Venue { @Id String id; String name; [] location; @PersistenceConstructor Venue(String name, [] location) { (); .name = name; .location = location; } Venue(String name, x, y) { (); .name = name; .location = [] { x, y }; } String getName() { name; } [] getLocation() { location; } @Override String toString() { + id + + name + + Arrays.toString(location) + ; } } To find locations within a , the following query can be used. To find venues within a using spherical coordinates the following query can be used To find venues within a the following query can be used To find venues near a , the following query can be used To find venues near a using spherical coordines the following query can be used MongoDB supports querying the database for geo locations and calculation the distance from a given origin at the very same time. With geo-near queries it's possible to express queries like: \"find all restaurants in the surrounding 10 miles\". To do so provides methods taking a as argument as well as the already familiar entity type and collection As you can see we use the builder API to set up a query to return all instances surrounding the given by 10 miles maximum. The enum used here actually implements an interface so that other metrics could be plugged into a distance as well. A is backed by a multiplier to transform the distance value of the given metric into native distances. The sample shown here would consider the 10 to be miles. Using one of the pre-built in metrics (miles and kilometers) will automatically trigger the spherical flag to be set on the query. If you want to avoid that, simply hand in plain values into . For more information see the JavaDoc of and . The geo near operations return a wrapper object that encapsulates instances. The wrapping allows to access the average distance of all results. A single object simply carries the entity found plus its distance from the origin. You can query MongoDB using Map-Reduce which is useful for batch processing, data aggregation, and for when the query language doesn't fulfill your needs. Spring provides integration with MongoDB's map reduce by providing methods on MongoOperations to simplify the creation and execution of Map-Reduce operations. It also integrates with Spring's Resource abstraction abstraction. This will let you place your JavaScript files on the file system, classpath, http server or any other Spring Resource implementation and then reference the JavaScript resources via an easy URI style syntax, e.g. 'classpath:reduce.js;. Externalizing JavaScript code in files is preferable to embedding them as Java strings in your code. You can still pass JavaScript code as Java strings if you prefer. To understand how to perform Map-Reduce operations an example from the book 'MongoDB - The definitive guide' is used. In this example we will create three documents that have the values [a,b], [b,c], and [c,d] respectfully. The values in each document are associated with the key 'x' as shown below. For this example assume these documents are in the collection named \"jmr1\". A map function that will count the occurance of each letter in the array for each document is shown below The reduce function that will sum up the occurance of each letter across all the documents is shown below Executing this will result in a collection as shown below. { \"_id\" : \"a\", \"value\" : 1 } { \"_id\" : \"b\", \"value\" : 2 } { \"_id\" : \"c\", \"value\" : 2 } { \"_id\" : \"d\", \"value\" : 1 } Assuming that the map and reduce functions are located in map.js and reduce.js and bundled in your jar so they are available on the classpath, you can execute a map-reduce operation and obtain the results as shown below The output of the above code is The MapReduceResults class implements and provides access to the raw output, as well as timing and count statistics. The class is simply ValueObject { String id; value; String getId() { id; } getValue() { value; } setValue( value) { .value = value; } @Override String toString() { + id + + value + ; } } By default the output type of INLINE is used so you don't have to specify an output collection. To specify additional map-reduce options use an overloaded method that takes an additional argument. The class has a fluent API so adding additional options can be done in a very compact syntax. Here an example that sets the output collection to \"jmr1_out\". Note that setting only the output collection assumes a default output type of REPLACE. There is also a static import that can be used to make the syntax slightly more compact You can also specify a query to reduce the set of data that will be used to feed into the map-reduce operation. This will remove the document that contains [a,b] from consideration for map-reduce operations. Note that you can specify additional limit and sort values as well on the query but not skip values. In order to have more fine grained control over the mapping process you can register Spring converters with the implementations such as the . The checks to see if there are any Spring converters that can handle a specific class before attempting to map the object itself. To 'hijack' the normal mapping strategies of the , perhaps for increased performance or other custom mapping needs, you first need to create an implementation of the Spring interface and then register it with the MappingConverter. For more information on the Spring type conversion service see the reference docs here. An example implementation of the that converts from a Person object to a is shown below An example implemention of a Converter that converts from a DBObject ot a Person object is shownn below The mongo XSD namespace provides a convenience way to register Spring Converters as shown below as well as configuring it into a MongoTemplate. MongoTemplate provides a few methods for managing indexes and collections. We can create an index on a collection to improve query performance. Example 5.10. Creating an index using the MongoTemplate\n• None ensureIndex Ensure that an index for the provided IndexDefinition exists for the collection. You can create both standard indexes and geospatial indexes using the classes and respectfully. For example, given the Venue class defined in a previous section, you would declare a geospatial query as shown below It's time to look at some code examples showing how to use the . First we look at creating our first collection. Example 5.11. Working with collections using the MongoTemplate\n• None collectionExists Check to see if a collection with a given name exists.\n• None getCollection Get a collection by name, creating it if it doesn't exist. You can also get at the Mongo driver's method using the executeCommand methods on MongoTemplate. These will also perform exception translation into Spring's Data Access Exception hierarchy. Built into the MongoDB mapping framework are several events that your application can respond to by registering special beans in the . By being based off Spring's ApplicationContext event infastructure this enables other products, such as Spring Integration, to easily receive these events as they are a well known eventing mechanism in Spring based applications. To intercept an object before it goes through the conversion process (which turns your domain object into a ), you'd register a subclass of that overrides the method. When the event is dispatched, your listener will be called and passed the domain object before it goes into the converter. BeforeConvertListener AbstractMongoEventListener<Person> { @Override onBeforeConvert(Person p) { ... does some auditing manipulation, set timestamps, whatever ... } } \n\n To intercept an object before it goes into the database, you'd register a subclass of that overrides the method. When the event is dispatched, your listener will be called and passed the domain object and the converted . \n\n Simply declaring these beans in your Spring ApplicationContext will cause them to be invoked whenever the event is dispatched. The list of callback methods that are present in AbstractMappingEventListener are\n• None - called in MongoTemplate insert, insertList and save operations before the object is converted to a DBObject using a MongoConveter.\n• None - called in MongoTemplate insert, insertList and save operations before inserting/saving the DBObject in the database.\n• None - called in MongoTemplate insert, insertList and save operations after inserting/saving the DBObject in the database.\n• None - called in MongoTempnlate find, findAndRemove, findOne and getCollection methods after the DBObject is retrieved from the database.\n• None - called in MongoTempnlate find, findAndRemove, findOne and getCollection methods after the DBObject retrieved from the database was converted to a POJO. The Spring framework provides exception translation for a wide variety of database and mapping technologies. This has traditionally been for JDBC and JPA. The Spring support for Mongo extends this feature to the MongoDB Database by providing an implementation of the interface. The motivation behind mapping to Spring's consistent data access exception hierarchy is that you are then able to write portable and descriptive exception handling code without resorting to coding against MongoDB error codes. All of Spring's data access exceptions are inherited from the root class so you can be sure that you will be able to catch all database related exception within a single try-catch block. Note, that not all exceptions thrown by the MongoDB driver inherit from the MongoException class. The inner exception and message are preserved so no information is lost. Some of the mappings performed by the MongoExceptionTranslator are: com.mongodb.Network to DataAccessResourceFailureException and MongoException error codes 1003, 12001, 12010, 12011, 12012 to InvalidDataAccessApiUsageException. Look into the implementation for more details on the mapping. One common design feature of all Spring template classes is that all functionality is routed into one of the templates execute callback methods. This helps ensure that exceptions and any resource management that maybe required are performed consistency. While this was of much greater need in the case of JDBC and JMS than with MongoDB, it still offers a single spot for exception translation and logging to occur. As such, using thexe execute callback is the preferred way to access the Mongo driver's DB and Collection objects to perform uncommon operations that were not exposed as methods on . Here is a list of execute callback methods.\n• None execute Executes the given CollectionCallback for the entity collection of the specified class.\n• None execute Executes the given CollectionCallback on the collection of the given name.\n• None execute Executes a DbCallback translating any exceptions as necessary.\n• None execute Executes a DbCallback on the collection of the given name translating any exceptions as necessary.\n• None executeInSession Executes the given DbCallback within the same connection to the database so as to ensure consistency in a write heavy environment where you may read the data that you wrote. Here is an example that uses the CollectionCallback to return information about an index. This chapter will point out the specialties for repository support for MongoDB. This builds on the core repository support explained in Chapter 4, Repositories. So make sure you've got a sound understanding of the basic concepts explained there. To access domain entities stored in a MongoDB you can leverage our sophisticated repository support that eases implementing those quite significantly. To do so, simply create an interface for your repository: \n\n We have a quite simple domain object here. Note that it has a property named of type . The default serialization mechanism used in (which is backing the repository support) regards properties named id as document id. Currently we support , and as id-types. \n\n Right now this interface simply serves typing purposes but we will add additional methods to it later. In your Spring configuration simply add \n\n This namespace element will cause the base packages to be scanned for interfaces extending and create Spring beans for each of them found. By default the repositories will get a Spring bean wired that is called , so you only need to configure explicitly if you deviate from this convention. As our domain repository extends it provides you with CRUD operations as well as methods for paginated and sorted access to the entities. Working with the repository instance is just a matter of dependency injecting it into a client. So accessing the second page of s at a page size of 10 would simply look something like this: \n\n The sample creates an application context with Spring's unit test support which will perform annotation based dependency injection into test cases. Inside the test method we simply use the repository to query the datastore. We hand the repository a instance that requests the first page of persons at a page size of 10. Most of the data access operations you usually trigger on a repository result a query being executed against the Mongo databases. Defining such a query is just a matter of declaring a method on the repository interface \n\n The first method shows a query for all people with the given lastname. The query will be derived parsing the method name for constraints which can be concatenated with and . Thus the method name will result in a query expression of . The second example shows how pagination is applied to a query. Just equip your method signature with a parameter and let the method return a instance and we will automatically page the query accordingly. The third examples shows that you can query based on properties which are not a primitive type. As you've just seen there are a few keywords triggering geo-spatial operations within a MongoDB query. The keyword allows some further modification. Let's have look at some examples: \n\n Adding a parameter to the query method allows restricting results to those within the given distance. If the was set up containing a we will transparently use instead of $code. Example 6.7. Using with \n\n As you can see using a equipped with a causes clause to be added instead of a plain . Beyond that the actual distance gets calculated according to the used. By adding the annotation repository finder methods you can specify a Mongo JSON query string to use instead of having the query derived from the method name. For example The placeholder ?0 lets you substitute the value from the method arguments into the JSON query string. You can also use the filter property to restrict the set of properties that will be mapped into the Java object. For example, This will return only the firstname, lastname and Id properties of the Person objects. The age property, a java.lang.Integer, will not be set and its value will therefore be null. Mongo repository support integrates with the QueryDSL project which provides a means to perform type-safe queries in Java. To quote from the project description, \"Instead of writing queries as inline strings or externalizing them into XML files they are constructed via a fluent API.\" It provides the following features\n• None Code completion in IDE (all properties, methods and operations can be expanded in your favorite Java IDE)\n• None Almost no syntactically invalid queries allowed (type-safe on all levels)\n• None Domain types and properties can be referenced safely (no Strings involved!)\n• None Adopts better to refactoring changes in domain types Please refer to the QueryDSL documentation which describes how to bootstrap your environment for APT based code generation using Maven or using Ant. Using QueryDSL you will be able to write queries as shown below is a class that is generated (via the Java annotation post processing tool) which is a that allows you to write type safe queries. Notice that there are no strings in the query other than the value \"C0123\". You can use the generated class via the interface which is shown below To use this in your repository implementation, simply inherit from it in additiion to other repository interfaces. This is shown below We think you will find this an extremely powerful tool for writing MongoDB queries. Rich maping support is provided by the . has a rich metadata model that provides a full feature set of functionality to map domain objects to MongoDB documents.The mapping metadata model is populated using annotations on your domain objects. However, the infrastructure is not limited to using annotations as the only source of metadata information. The also allows you to map objects to documents without providing any additional metadata, by following a set of conventions. In this section we will describe the features of the MongoMappingConverter. How to use conventions for mapping objects to documents and how to override those conventions with annotation based mapping metadata. has been deprecated in Spring Data MongoDB M3 as all of its functionality has been subsumed into . has a few conventions for mapping objects to documents when no additional mapping metadata is provided. The conventions are:\n• None The short Java class name is mapped to the collection name in the following manner. The class ' ' maps to ' ' collection name.\n• None All nested objects are stored as nested objects in the document and *not* as DBRefs\n• None The converter will use any Spring Converters registered with it to override the default mapping of object properties to document field/values.\n• None The fields of an object are used to convert to and from fields in the document. Public JavaBean properties are not used.\n• None You can have a single non-zero argument constructor whose constructor argument names match top level field names of document, that constructor will be used. Otherewise the zero arg constructor will be used. if there is more than one non-zero argument constructor an exception will be thrown. 7.1.1. How the '_id' field is handled in the mapping layer Mongo requires that you have an '_id' field for all documents. If you don't provide one the driver will assign a ObjectId with a generated value. The \"_id\" field can be of any type the, other than arrays, so long as it is unique. The driver naturally supports all primitive types and Dates. When using the there are certain rules that govern how properties from the Java class is mapped to this '_id' field. The following outlines what field will be mapped to the '_id' document field:\n• None A field annotated with ( ) will be mapped to the '_id' field.\n• None A field without an annotation but named will be mapped to the '_id' field. The following outlines what type conversion, if any, will be done on the property mapped to the _id document field.\n• None If a field named 'id' is declared as a String or BigInteger in the Java class it will be converted to and stored as an ObjectId if possible. ObjectId as a field type is also valid. If you specify a value for 'id' in your application, the conversion to an ObjectId is delected to the MongoDBdriver. If the specified 'id' value cannot be converted to an ObjectId, then the value will be stored as is in the document's _id field.\n• None If a field named ' id' id field is not declared as a String, BigInteger, or ObjectID in the Java class then you should assign it a value in your application so it can be stored 'as-is' in the document's _id field.\n• None If no field named 'id' is present in the Java class then an implicit '_id' file will be generated by the driver but not mapped to a property or field of the Java class. When querying and updating will use the converter to handle conversions of the and objects that correspond to the above rules for saving documents so field names and types used in your queries will be able to match what is in your domain classes. Unless explicitly configured, an instance of is created by default when creating a . You can create your own instance of the so as to tell it where to scan the classpath at startup your domain classes in order to extract metadata and construct indexes. Also, by creating your own instance you can register Spring converters to use for mapping specific classes to and from the database. You can configure the as well as and MongoTemplate either using Java or XML based metadata. Here is an example using Spring's Java based configuration \n\n requires you to implement methods that define a as well as provide a database name. also has a method you can override named ' ' which tells the converter where to scan for classes annotated with the annotation. You can add additional converters to the converter by overriding the method afterMappingMongoConverterCreation. Also shown in the above example is a which logs s that are posted onto Spring's infrastructure. AbstractMongoConfiguration will create a MongoTemplate instance and registered with the container under the name 'mongoTemplate'. You can also override the method to provide the username and password information to connect to the database. Spring's Mongo namespace enables you to easily enable mapping functionality in XML \n\n The property tells it where to scan for classes annotated with the annotation. To take full advantage of the object mapping functionality inside the Spring Data/MongoDB support, you should annotate your mapped objects with the annotation. Although it is not necessary for the mapping framework to have this annotation (your POJOs will be mapped correctly, even without any annotations), it allows the classpath scanner to find and pre-process your domain objects to extract the necessary metadata. If you don't use this annotation, your application will take a slight performance hit the first time you store a domain object because the mapping framework needs to build up its internal metadata model so it knows about the properties of your domain object and how to persist them. \n\n The annotation tells the mapper which property you want to use for the MongoDB property and the annotation tells the mapping framework to call on that property of your document, making searches faster. The MappingMongoConverter can use metadata to drive the mapping of objects to documents. An overview of the annotations is provided below\n• None - applied at the field level to mark the field used for identiy purpose.\n• None - applied at the class level to indicate this class is a candidate for mapping to the database. You can specify the name of the collection where the database will be stored.\n• None - applied at the field to indicate it is to be stored using a com.mongodb.DBRef.\n• None - applied at the field level to describe how to index the field.\n• None - applied at the type level to declare Compound Indexes\n• None - applied at the field level to describe how to geoindex the field.\n• None - by default all private fields are mapped to the document, this annotation excludes the field where it is applied from being stored in the database\n• None - marks a given constructor - even a package protected one - to use when instantiating the object from the database. Constructor arguments are mapped by name to the key values in the retrieved DBObject.\n• None - this annotation is part of the Spring Framework . Within the mapping framework it can be applied to constructor arguments. This lets you use a Spring Expression Language statement to transform a key's value retrieved in the database before it is used to construct a domain object. The mapping metadata infrastructure is defined in a seperate spring-data-commons project that is technology agnostic. Specific subclasses are using in the Mongo support to support annotation based metadata. Other strategies are also possible to put in place if there is demand. Here is an example of a more complex mapping. Compound indexes are also supported. They are defined at the class level, rather than on indidvidual properties. Compound indexes are very important to improve the performance of queries that involve criteria on multiple fields Here's an example that creates a compound index of in ascending order and in descending order: The mapping framework doesn't have to store child objects embedded within the document. You can also store them separately and use a DBRef to refer to that document. When the object is loaded from MongoDB, those references will be eagerly resolved and you will get back a mapped object that looks the same as if it had been stored embedded within your master document. Here's an example of using a DBRef to refer to a specific document that exists independently of the object in which it is referenced (both classes are shown in-line for brevity's sake): \n\n There's no need to use something like because the mapping framework sees that you're wanting a one-to-many relationship because there is a List of objects. When the object is stored in MongoDB, there will be a list of DBRefs rather than the objects themselves. The mapping framework does not handle cascading saves. If you change an object that is referenced by a object, you must save the Account object separately. Calling on the object will not automatically save the objects in the property . Events are fired throughout the lifecycle of the mapping process. This is described in the Lifecycle Events section. Simply declaring these beans in your Spring ApplicationContext will cause them to be invoked whenever the event is dispatched. When storing and querying your objects it is convenient to have a instance handle the mapping of all Java types to DBObjects. However, sometimes you may want the 's do most of the work but allow you to selectivly handle the conversion for a particular type or to optimize performance. To selectivly handle the conversion yourself, register one or more one or more instances with the MongoConverter. Spring 3.0 introduced a core.convert package that provides a general type conversion system. This is described in detail in the Spring reference documentation section entitled Spring 3 Type Conversion. The method on and should be used for this purpose. The method in can be overriden to configure a MappingMongoConverter. The examples here at the begining of this chapter show how to perform the configuration using Java and XML. Below is an example of a Spring Converter implementation that converts from a DBObject to a Person POJO. Here is an example that converts from a Person to a DBObject. Sometimes you need to store data in multiple data stores and these data stores can be of different types. One might be relational while the other a document store. For this use case we have created a separate module in the MongoDB support that handles what we call cross-store support. The current implemenatation is based on JPA as the driver for the relational database and we allow select fields in the Entities to be stored in a Mongo database. In addition to allowing you to store your data in two stores we also coordinate persistence operations for the non-transactional MongoDB store with the transaction life-cycle for the relational database. Assuming that you have a working JPA application and would like to add some cross-store persistence for MongoDB. What do you have to add to your configuration? First of all you need to add a dependency on the module. Using Maven this is done by adding a dependency to your pom: Example 8.1. Example Maven pom.xml with spring-data-mongodb-cross-store dependency \n\n Once this is done we need to enable AspectJ for the project. The cross-store support is implemented using AspectJ aspects so by enabling compile time AspectJ support the cross-store features will become available to your project. In Maven you would add an additional plugin to the <build> section of the pom: Example 8.2. Example Maven pom.xml with AspectJ plugin enabled \n\n Finally, you need to configure your project to use MongoDB and also configure the aspects that are used. The following XML snippet should be added to your application context: Example 8.3. Example application context with MongoDB and cross-store aspect support \n\n We are assuming that you have a working JPA application so we will only cover the additional steps needed to persist part of your Entity in your Mongo database. First you need to identify the field you want persited. It should be a domain class and follow the general rules for the Mongo mapping support covered in previous chapters. The field you want persisted in MongoDB should be annotated using the annotation. That is really all you need to do!. The cross-store aspects take care of the rest. This includes marking the field with @Transient so it won't be persisted using JPA, keeping track of any changes made to the field value and writing them to the database on succesfull transaction completion, loading the document from MongoDB the first time the value is used in your application. Here is an example of a simple Entity that has a field annotated with @RelatedEntity. Example 8.4. Example of Entity with @RelatedDocument \n\n Example 8.5. Example of domain class to be stored as document \n\n Once the SurveyInfo has been set on the Customer object above the MongoTemplate that was configured above is used to save the SurveyInfo along with some metadata about the JPA Entity is stored in a MongoDB collection named after the fully qualified name of the JPA Entity class. The following code: Example 8.6. Example of code using the JPA Entity configured for cross-store persistence \n\n Executing the code above results in the following JSON document stored in MongoDB. Example 8.7. Example of JSON document stored in MongoDB \n\n An appender for Log4j is provided in the maven module \"spring-data-mongodb-log4j\". Note, there is no dependency on other Spring Mongo modules, only the MongoDB driver. Here is an example configuration The important configuration to look at aside from host and port is the database and collectionPattern. The variables year, month, day and hour are available for you to use in forming a collection name. This is to support the common convention of grouping log information in a collection that corresponds to a specific time period, for example a collection per day. There is also an applicationId which is put into the stored message. The document stored from logging as the following keys: level, name, applicationId, timestamp, properties, traceback, and message. The JMX support for MongoDB exposes the results of executing the 'serverStatus' command on the admin database for a single MongoDB server instance. It also exposes an administrative MBean, MongoAdmin which will let you perform administrative operations such as drop or create a database. The JMX features build upon the JMX feature set available in the Spring Framework. See here for more details. \n\n This will expose several MBeans This is shown below in a screenshot from JConsole"
    },
    {
        "link": "https://stackoverflow.com/questions/20366666/spring-data-mongo-pagination",
        "document": "I want to implement pagination with Spring Data Mongo. There are many tutorials and docs suggest to use PagingAndSortingRepository, like this:\n\nAnd so because PagingAndSortingRepository provides api for query with paging, I can use it like:\n\nMy question is where actually is this findAll method here implemented? Do I need to write its implementation by myself? The StoryRepoImpl which implements StoryRepo needs to implement this method?"
    }
]