[
    {
        "link": "https://docs.python.org/3/library/email.mime.html",
        "document": "This module is part of the legacy ( ) email API. Its functionality is partially replaced by the in the new API, but in certain applications these classes may still be useful, even in non-legacy code.\n\nOrdinarily, you get a message object structure by passing a file or some text to a parser, which parses the text and returns the root message object. However you can also build a complete message structure from scratch, or even individual objects by hand. In fact, you can also take an existing structure and add new objects, move them around, etc. This makes a very convenient interface for slicing-and-dicing MIME messages.\n\nYou can create a new object structure by creating instances, adding attachments and all the appropriate headers manually. For MIME messages though, the package provides some convenient subclasses to make things easier.\n\nHere are the classes:\n\nThis is the base class for all the MIME-specific subclasses of . Ordinarily you won’t create instances specifically of , although you could. is provided primarily as a convenient base class for more specific MIME-aware subclasses. _maintype is the Content-Type major type (e.g. text or image), and _subtype is the Content-Type minor type (e.g. plain or gif). _params is a parameter key/value dictionary and is passed directly to . If policy is specified, (defaults to the policy) it will be passed to . The class always adds a Content-Type header (based on _maintype, _subtype, and _params), and a MIME-Version header (always set to ).\n\nA subclass of , this is an intermediate base class for MIME messages that are multipart. Optional _subtype defaults to mixed, but can be used to specify the subtype of the message. A Content-Type header of multipart/_subtype will be added to the message object. A MIME-Version header will also be added. Optional boundary is the multipart boundary string. When (the default), the boundary is calculated when needed (for example, when the message is serialized). _subparts is a sequence of initial subparts for the payload. It must be possible to convert this sequence to a list. You can always attach new subparts to the message by using the method. Additional parameters for the Content-Type header are taken from the keyword arguments, or passed into the _params argument, which is a keyword dictionary.\n\nA subclass of , the class is used to represent MIME message objects of major type application. _data contains the bytes for the raw application data. Optional _subtype specifies the MIME subtype and defaults to octet-stream. Optional _encoder is a callable (i.e. function) which will perform the actual encoding of the data for transport. This callable takes one argument, which is the instance. It should use and to change the payload to encoded form. It should also add any Content-Transfer-Encoding or other headers to the message object as necessary. The default encoding is base64. See the module for a list of the built-in encoders. _params are passed straight through to the base class constructor.\n\nA subclass of , the class is used to create MIME message objects of major type audio. _audiodata contains the bytes for the raw audio data. If this data can be decoded as au, wav, aiff, or aifc, then the subtype will be automatically included in the Content-Type header. Otherwise you can explicitly specify the audio subtype via the _subtype argument. If the minor type could not be guessed and _subtype was not given, then is raised. Optional _encoder is a callable (i.e. function) which will perform the actual encoding of the audio data for transport. This callable takes one argument, which is the instance. It should use and to change the payload to encoded form. It should also add any Content-Transfer-Encoding or other headers to the message object as necessary. The default encoding is base64. See the module for a list of the built-in encoders. _params are passed straight through to the base class constructor.\n\nA subclass of , the class is used to create MIME message objects of major type image. _imagedata contains the bytes for the raw image data. If this data type can be detected (jpeg, png, gif, tiff, rgb, pbm, pgm, ppm, rast, xbm, bmp, webp, and exr attempted), then the subtype will be automatically included in the Content-Type header. Otherwise you can explicitly specify the image subtype via the _subtype argument. If the minor type could not be guessed and _subtype was not given, then is raised. Optional _encoder is a callable (i.e. function) which will perform the actual encoding of the image data for transport. This callable takes one argument, which is the instance. It should use and to change the payload to encoded form. It should also add any Content-Transfer-Encoding or other headers to the message object as necessary. The default encoding is base64. See the module for a list of the built-in encoders. _params are passed straight through to the constructor."
    },
    {
        "link": "https://docs.python.org/3/library/email.examples.html",
        "document": "Here are a few examples of how to use the package to read, write, and send simple email messages, as well as more complex MIME messages.\n\nFirst, let’s see how to create and send a simple text message (both the text content and the addresses may contain unicode characters):\n\nParsing RFC 822 headers can easily be done by the using the classes from the module:\n\n# Import the email modules we'll need # If the e-mail headers are in a file, uncomment these two lines: # Or for parsing headers in a string (this is an uncommon operation), use: # Now the header items can be accessed as a dictionary: # You can also access the parts of the addresses:\n\nHere’s an example of how to send a MIME message containing a bunch of family pictures that may be residing in a directory:\n\n# Here are the email package modules we'll need. # family = the list of all recipients' email addresses 'You will not see this in a MIME-aware mail reader. # Open the files in binary mode. You can also omit the subtype # if you want MIMEImage to guess it. # Send the email via our own SMTP server.\n\nHere’s an example of how to send the entire contents of a directory as an email message:\n\n\"\"\"Send the contents of a directory as a MIME message.\"\"\" # For guessing MIME type based on file name extension Send the contents of a directory as a MIME message. Unless the -o option is given, the email is sent by forwarding to your local SMTP server, which then does the normal delivery process. Your local machine must be running an SMTP server. \"\"\"Mail the contents of the specified directory, otherwise use the current directory. Only the regular files in the directory are sent, and we don't recurse to \"\"\"Print the composed message to FILE instead of sending the message to the SMTP server.\"\"\" 'The value of the From: header (required)' 'A To: header value (at least one required)' 'You will not see this in a MIME-aware mail reader. # Guess the content type based on the file's extension. Encoding # will be ignored, although we should check for simple things like # No guess could be made, or the file is encoded (compressed), so # Now send or store the message\n\nHere’s an example of how to unpack a MIME message like the one above, into a directory of files:\n\nHere’s an example of how to create an HTML message with an alternative plain text version. To make things a bit more interesting, we include a related image in the html part, and we save a copy of what we are going to send to disk, as well as sending it.\n\n# Add the html version. This converts the message into a multipart/alternative # container, with the original text message as the first part and the new html # message as the second part. # note that we needed to peel the <> off the msgid for use in the html. # Now add the related image to the html part. # Make a local copy of what we are going to send.\n\nIf we were sent the message from the last example, here is one way we could process it:\n\n# Import the email modules we'll need Rewrite the href=\"cid:....\" attributes to point to the filenames in partfiles. Though not trivial, this should be possible using html.parser. # In a real program you'd get the filename from the arguments. # Now the header items can be accessed as a dictionary, and any non-ASCII will # If we want to print a preview of the message content, we can extract whatever # the least formatted payload is and print the first three lines. Of course, # if the message has no plain text part printing the first three lines of html # is probably useless, but this is just a conceptual example. # We can extract the richest alternative in order to display it: \"Don't know how to display # again strip the <> to go from email form of cid to html form. \"Don't know how to display # Of course, there are lots of email messages that could break this simple # minded program, but it will handle the most common ones.\n\nUp to the prompt, the output from the above is:"
    },
    {
        "link": "https://python.readthedocs.io/fr/hack-in-language/library/email-examples.html",
        "document": "Here are a few examples of how to use the package to read, write, and send simple email messages, as well as more complex MIME messages.\n\nFirst, let’s see how to create and send a simple text message:\n\nAnd parsing RFC822 headers can easily be done by the parse(filename) or parsestr(message_as_string) methods of the Parser() class:\n\nHere’s an example of how to send a MIME message containing a bunch of family pictures that may be residing in a directory:\n\nHere’s an example of how to send the entire contents of a directory as an email message:\n\n\"\"\"Send the contents of a directory as a MIME message.\"\"\" Send the contents of a directory as a MIME message. Unless the -o option is given, the email is sent by forwarding to your local \"\"\"Mail the contents of the specified directory, files in the directory are sent, and we don't recurse to \"\"\"Print the composed message to FILE instead of sending the message to the SMTP server.\"\"\" 'The value of the From: header (required)' 'A To: header value (at least one required)' 'You will not see this in a MIME-aware mail reader. # Guess the content type based on the file's extension. Encoding # will be ignored, although we should check for simple things like # No guess could be made, or the file is encoded (compressed), so\n\nHere’s an example of how to unpack a MIME message like the one above, into a directory of files:\n\nHere’s an example of how to create an HTML message with an alternative plain text version:\n\n# Create the body of the message (a plain-text and an HTML version). Here is the <a href=\"https://www.python.org\">link</a> you wanted. # Record the MIME types of both parts - text/plain and text/html. # According to RFC 2046, the last part of a multipart message, in this case # the HTML message, is best and preferred. # and message to send - here it is sent as one string.\n\nHere is a reworking of the last example using the provisional API. To make things a bit more interesting, we include a related image in the html part, and we save a copy of what we are going to send to disk, as well as sending it. This example also shows how easy it is to include non-ASCII, and simplifies the sending of the message using the method of the module. \"Ayons asperges pour le déjeuner\" # Add the html version. This converts the message into a multipart/alternative # container, with the original text message as the first part and the new html # note that we needed to peel the <> off the msgid for use in the html. # Now add the related image to the html part. # Make a local copy of what we are going to send. If we were instead sent the message from the last example, here is one way we could process it: # An imaginary module that would make this work and be safe. # In a real program you'd get the filename from the arguments. # Now the header items can be accessed as a dictionary, and any non-ASCII will # If we want to print a priview of the message content, we can extract whatever # the least formatted payload is and print the first three lines. Of course, # if the message has no plain text part printing the first three lines of html # is probably useless, but this is just a conceptual example. # We can extract the richest alternative in order to display it: # again strip the <> to go from email form of cid to html form. # The magic_html_parser has to rewrite the href=\"cid:....\" attributes to # point to the filenames in partfiles. It also has to do a safety-sanitize # of the html. It could be written using html.parser. # Of course, there are lots of email messages that could break this simple # minded program, but it will handle the most common ones. Up to the prompt, the output from the above is: To: Penelope Pussycat <\"penelope@example.com\">, Fabrette Pussycat <\"fabrette@example.com\"> From: Pepé Le Pew <pepe@example.com> Subject: Ayons asperges pour le déjeuner Salut! Cela ressemble à un excellent recipie[1] déjeuner."
    },
    {
        "link": "https://mailtrap.io/blog/python-send-email",
        "document": "This article covers everything you need to know about sending emails in Python including code examples, security, and email testing.\n\nIf you have smtplib configured, go straight to sending using SMTP or sending using email API.\n\nPython’s ‘smtplib’ module simplifies the process of sending emails directly from your applications, offering a straightforward interface to interact with SMTP servers.\n\nThis section guides you through importing ‘smtplib’, creating an SMTP object for your server, and leveraging its core functions to send emails. Follow along to learn how to integrate email functionalities into your Python scripts.\n\nThe built-in smtplib module can be imported using the following statement:\n\nTo send an email later, create one SMTP (Simple Mail Transfer Protocol) object:\n• − this is an optional argument and is the host running your SMTP server. The IP address of the host or a domain name can be specified.\n• − if the host argument is specified, specify a port, where the SMTP server is listening.\n• − if the used SMTP server is running on your local machine, specify localhost.\n\nAn SMTP object has an instance method called that is used to send a message and has three parameters:\n• − string with the address of the sender.\n• − list of strings, one for each recipient.\n• − a message as a string formatted as specified in RFCs.\n\nTo make sure that the email module has been imported properly and get the full description of its classes and arguments, type in an interactive Python session:\n\nRefer to Python documentation to further review the rest of the SMTP Objects (e.g., ; etc.) and how to apply them.\n\nThe following section tells you how to send emails via Python using Mailtrap Email Sending, a feature of Mailtrap Email Delivery Platform. First, I’ll cover the SMTP method and later show you how to do it with our Python SDK.\n\nThe method is very similar to what I covered under the ‘smtplib’ above, however, you need to set up custom SMTP credentials. Here, I assume that you already signed up for Mailtrap and verified your domain.\n\nIf not, check out our detailed guide.\n\nAlso make sure to check out our video instructions on how to send emails in Python with Mailtrap using smtplib.\n\nNote: The code below contains dummy Mailtrap credentials (bar the server endpoint) make sure to replace it with your real credentials.\n\nHere’s a bare-bones script to send ‘plaintext’ emails with Python using Mailtrap SMTP.\n• Imports and setup – I’ve imported the necessary modules from Python’s standard library for emailing (‘smtplib’, and ‘MIMEText’,).\n• Email server configuration – The SMTP server details including the server address, port number, and authentication credentials.\n• Email content – I’ve created a message that can hold plain text only. Later, I’ll show you how to include HTML and plain text versions of the email.\n• Sending the email – I’ve used a context manager ( statement) to ensure the connection to the SMTP server is properly closed after sending the email.\n\nBonus tip: Hardcoding sensitive data such as login credentials and server information in your script can pose a security risk. That’s why I recommend using environment variables to store sensitive information. This makes your code more secure and flexible when moving between different environments (development, testing, production).\n\nIf you want to learn more about sending HTML emails in Python, check out our dedicated tutorial.\n\nTo modify the script for sending HTML emails (while still including multiple recipients), I’ll adjust how the email body is created and attached. Here’s the revised script:\n• Attaching the HTML content – The HTML content is attached to the email message using ‘MIMEText(html, “html”)’ instead of ‘MIMEText (text, “plain”)’. By specifying as the second argument, we inform the email client that this part of the email should be interpreted as HTML.\n\nHere, I’ll reuse the script above and adjust how the receivers’ addresses are handled.\n\nQuick breakdown of what’s different from the original script:\n• Multiple recipients configuration – I changed the variable to . It’s now a list of email addresses instead of a single string.\n• Setting the header – The header in the MIMEText message object is set by joining the list of recipient emails into a single string separated by commas. This is important for the email header to correctly display all recipients when they receive the email.\n• Note: Some email clients (Outlook, Yahoo, Gmail etc.) may show all recipients in the field to each recipient, which isn’t desirable for privacy reasons. You can “fix” it by using and/or .\n• Sending emails in a loop – Instead of sending the email once, the script now loops through each recipient in the list and sends them the email individually.\n\nPro tip: ⬆️ This approach works well for a small number of recipients. However, for sending emails to a large number of recipients, it might be more efficient to use the SMTP server’s capability to handle multiple recipients in a single send operation, depending on the server’s limitations and policies.\n\nI’ll be using since attachments require a multipart email. Also, I’ll use the class for attaching files. Here’s the updated script:\n• Using – I switched from for the body to for the overall message structure. This allows us to add both the text part and the attachment as separate parts of the email.\n• Adding the attachment:\n• File preparation – The attachment file is opened in binary mode , and its content is read.\n• object – A object is created for the attachment, with the type set to . This type is a generic binary stream, which means it’s suitable for any file type, and email clients will typically treat it as an attachment.\n• Encoding – The file content is encoded in base64 to ensure it can be safely transmitted over email. This is done using the function.\n• Adding headers – A header is added to the attachment part to indicate the file name and that it should be treated as an attachment ( header).\n• Attaching the file to the message – The attachment part is then attached to the message using .\n\nSend an email with an embedded image\n\nTo send emails with an embedded image (in the HTML content), I’ll use the class.\n\nEmbedding an image directly in the email allows it to be displayed as part of the email content rather than as a separate attachment. Here’s how you can do it:\n• HTML content update: The HTML content now includes an tag with a attribute pointing to the of the image you want to embed. This must match the header value of the image attachment.\n• Embedding the image:\n• Using – The script now includes the class to handle the image file. This class is specifically designed for attaching images to emails.\n• Open image file – The image you want to embed is opened in binary mode.\n• Create object – The binary data of the image is used to create a object. This object represents the image attachment.\n• Content-ID header – The object is given a header, which is referenced by the attribute in the HTML content’s tag. This linkage is what allows the email client to embed the image directly in the email body instead of showing it as a downloadable attachment.\n• Attaching the image – The object is attached to the multipart message, similar to how other parts are attached.\n\nFor asynchronous email sending you need to use Python’s asyncio library along with aiosmtplib, an asynchronous SMTP client.\n\nThis modification allows your script to send emails without blocking the execution of your program, making it more efficient, especially when sending multiple emails or performing other tasks concurrently.\n\nFor simplicity, I’ll be sending a text/plain email to a single recipient without attachments and embedded images. Here’s how it works.\n\nFirst, make sure to install the aiosmtplib.\n• Asynchronous function definition: The script now defines asynchronous functions using .\n• Async functionality: Utilizing ‘asyncio and ‘aiosmtplib’, the script establishes an SMTP connection asynchronously, logs in, and sends the email. This approach allows for non-blocking email sending, which is particularly useful in applications that require maintaining responsiveness while performing network operations.\n• Running the script: The async function sets up the email details and calls send_email_async to send the email. It demonstrates how to run asynchronous tasks in Python effectively, with bootstrapping the asynchronous execution.\n\nThe code above uses which is the endpoint for transactional emails. But Mailtrap Email Delivery Platform’s email package allows you to send bulk emails via a separate stream under the same plan.\n\nNow, the only different thing is the Host (endpoint), and you’d need to adjust your script to that. But keep in mind that Transactional and Bulk emails have separate infrastructures, even though your credentials are almost the same. That helps improve deliverability and email management.\n\nTo illustrate the changes, I created a simple script using the given SMTP endpoint.\n• usage: Even though the email is plain text and sent to a single recipient, I’ve retained the use of . This approach offers flexibility if you decide to add attachments or HTML content in the future. However, you could simplify further by using alone.\n• Sending the email: The call to is straightforward, specifying the sender, the recipient, and convert the message object to a string format to be sent.\n\nPro Tip: If you’re using environment variables or external configuration file for the SMTP credentials, it’s best to have separate files for Transactional and Bulk configuration.\n\nTo make your integration more straightforward, Mailtrap has an official Python SDK (check the GitHub link ◀️). I’ll use that to show you how to send a plain text email, send it to multiple recipients, send bulk emails, etc.\n\nHere, I won’t cover the asynchronous email sending method as Mailtrap doesn’t support it, and it doesn’t make much sense in the API contexts.\n\nAs a reminder, you’ll need to connect and verify your domain with Mailtrap. Check out our detailed guide and a bonus video instruction on how to do this.\n\nOnce that’s done, go back to your Python app and install Mailtrap’s official Python SDK with the following command:\n\nNote: make sure the package version is 3.6+ or higher.\n\nThen you should create the mail object and fill in variables (such as email and name) with your Mailtrap credentials. Keep in mind that you should indicate the address with the verified sending domain in it.\n\nYou’ll also need to create the client with your API token. Go to your Mailtrap account by expanding the ‘Settings’ dropdown, then choose the ‘API Tokens’ tab. Copy the credentials by pressing ‘Copy’ next to your token.\n\nThen, you can use the command below to send the email.\n\nThat out of the way, I’ll proceed to show you how to leverage the SDK for different use cases.\n• Importing classes: Only the classes ‘Mail’, ‘Address’, and ‘MailtrapClient’ from the Mailtrap library are imported since we’re focusing on sending a simple plain text email.\n• Creating the object:\n• – constructor is used to create an email object.\n• – Uses the ‘Address’ class to define the sender’s email and name.\n• – A list of ‘Address’ objects for each recipient. For plain text email, you typically have one or more direct recipients listed here.\n• – The subject line of the email.\n• – The actual content of the email, in plain text format.\n• and – Optional fields that allow for additional categorization and custom headers. While not strictly necessary for sending a plain text email, these can be useful for organizational or technical purposes within the Mailtrap service or for email client handling.\n• Sending the email:\n• An instance of is created, and authenticated with an API token.\n• The ‘send’ method of the is then called, passing the object as an argument to send the email.\n• Finally, a confirmation message is printed to indicate that the email has been sent.\n\nI’ll adjust the script by specifying the parameter in the object with the HTML content.\n• HTML content: The parameter of the ‘Mail’ object is where you put your HTML content. This is the part of the email that will be rendered by email clients capable of displaying HTML.\n• Fallback text content: The plain text version of the email content serves as a fallback for email clients that do not render HTML or for users who prefer plain text emails.\n• Sending the email: With the HTML content defined, the rest of the process for sending the email remains the same.\n\nI’ll modify the recipient part of the email setup to include multiple recipients.\n\nThere are comments throughout the script to explain how to handle multiple recipients for both the field and adding (Carbon Copy) and (Blind Carbon Copy) recipients. So, I won’t be adding the Quick breakdown section in this case as the method is simple and the logic is obvious in the script.\n\nHere, I’ll primarily need to focus on how the class is used to include files in your email. This example will demonstrate attaching a generic file, but the approach is similar for any file type.\n• Preparing the file: The script starts by specifying the path to the file you want to attach and reading its content as bytes. It’s important to read the file in binary mode (‘read_bytes()’ method) to ensure the content is correctly encoded and transmitted.\n• Base64 encoding: Since email protocols are not binary-safe, the file content needs to be encoded in base64. This encoding converts binary data into a text format that can be safely transmitted over email. The ‘base64.b64encode’ method is used for this purpose.\n• Creating the attachment: The Attachment class is instantiated with several parameters:\n• – The base64 encoded content of the file.\n• – The name of the file as you want it to appear in the email.\n• – This is set to ‘Disposition.ATTACHMENT’ to indicate that the file is an attachment (as opposed to inline, which would be used for embedded images).\n• – The MIME file type, which helps email clients understand how to handle the file. For a PDF, this is ‘application/pdf’.\n\nSend an email with an embedded image\n\nHere, I’ll attach the image so that it can be displayed directly within the HTML content of the email. This is usually achieved by attaching the image with a Content-ID ( ) that can be referenced in the HTML. Here’s how to do it:\n• Prepare the image: Before attaching the image, you read its content as bytes and then encode it in base64. This encoding is necessary because email content (including attachments) needs to be transmitted in a text-based format.\n• HTML content: In the parameter of the object, you include an tag where the attribute uses a scheme followed by the Content-ID of the image attachment ( in this case). This links the embedded image in the HTML content to the attached image file.\n• Attaching the image: The image is attached using the Attachment class with several specific parameters:\n• – The image file name. It’s used as a fallback in some email clients if the image cannot be displayed.\n• – Set to to indicate the attachment should be displayed in line with the HTML content, not as a separate, downloadable attachment.\n• – Specifies the MIME type of the image (e.g., “image/jpeg”). This helps the email client understand how to handle the file.\n• – A unique identifier for the attachment referenced in the HTML attribute to embed the image.\n• Sending the email – The process for sending the email remains unchanged.\n\nTo remind you, Mailtrap Email Deliver Platform allows you to send bulk emails on top of transactional, under the same plan. You need to select the stream, hit the API button, and choose the Python integration.\n\nThat out of the way, here’s what else you need to do.\n• Ensure you have the ‘requests’ library installed. If not, you can install it using pip:\n• Construct a JSON payload that specifies the email’s details and adjust the field to include multiple recipients.\n• Using the requests library, you make a POST request to the Mailtrap Bulk API endpoint, providing the necessary headers (including authorization) and the payload. Check the exemplary script below.\n• – It’s a dictionary that matches the JSON structure expected by the Mailtrap Bulk API. You can modify this dictionary to include the details of your email, such as the sender, recipient(s), subject, and body.\n• – The function encapsulates the process of sending the email. It takes the payload as input, converts it to JSON format, and makes a POST request to the Mailtrap Bulk API.\n\nIf you plan to automate sending emails and send them to a large number of recipients consistently, it’s best to take extra precautions. (Mostly relating to the SMTP method.)\n\nHere, I’ll cover some tried and tested methods to avoid hardcoding credentials into your scripts and handle errors. Note that the tips below apply regardless of the email provider you’re using (SendGrid, SES, Gmail account, etc.)\n\nEnvironment variables are a secure way to manage configuration settings and sensitive information outside of your application code.\n\n\n\nIn Python, you can use the module to access environment variables.\n\nBefore running your script, set the environment variables in your operating system. For example, in a Linux or macOS terminal, you can set them temporarily like this:\n\nIn Windows, you can set them via the command line as follows:\n\nHere’s how to manage unexpected errors, such as network errors, authentication problems, or other exceptions that may occur during the email sending process.\n\nHere’s a basic outline of how you might use in a script to send an email:\n\nStoring configuration data (like SMTP server details and email addresses) in external files or environment variables enhances your script’s security and flexibility. For more complex configurations, you might consider using a JSON file or similar.\n\nTip: If you want to send emails from your Google account and leverage Gmail’s SMTP server (smtp.gmail.com), we already blogged about it. Check the article here.\n\nWhen creating a new app or adding any functionality, especially when doing it for the first time, it’s essential to experiment on a test server. Here is a brief list of reasons:\n• You won’t hit your friends’ and customers’ inboxes. This is vital when you test bulk email sending or work with an email database.\n• You won’t flood your inbox with testing emails.\n• Your domain won’t be blacklisted for spam.\n\nA testing SMTP server environment imitates the work of a real 3rd party web server. In the following examples, I’ll use Mailtrap Email Testing, which allows devs to capture SMTP traffic from staging and inspect and debug emails before they go out to actual recipients.\n\nOn top of that, the Email Testing can help validate your HTML/CSS, analyze the email’s content, preview and content, and give a relevant spam score. The tool is easy to set up; all you need is to copy the credentials generated by the app and paste them into your code.\n\nNote: I’ll be covering SMTP and API methods separately. And if you wan’t in-depth tutorial on testing with Python, check this article.\n\nGo to Mailtrap, select Email Testing, then My Inbox. Under the SMTP Settings tab, click “Show credentials” to reveal the testing credentials.\n\nHere is how it looks in practice:\n\nMailtrap makes things even easier. Go to the Integrations section in the SMTP settings tab and get the ready-to-use template of the simple text message with your Mailtrap credentials.\n\nImportant note: The snippets use dummy credentials for safety, please make sure to copy-paste your real credentials into the code.\n\nThe most basic option for instructing your Python code on who sends what to who is the sendmail() instance method, which I’ll use here. But we also have exemplary integrations for Django and Flask.\n\nLet’s take a closer look at the example and add some error handling (see the #explanations in between). To catch errors, we use the and blocks. Refer to the documentation for the list of exceptions here.\n\nOnce you get the Sent result in Shell, you should see your message in your Mailtrap inbox:\n\nIf you prefer working in the local environment, the local SMTP debugging server might be an option. For this purpose, Python offers an smtpd module. It has a DebuggingServer feature, which will discard messages you are sending out and will print them to stdout. It is compatible with all operations systems.\n\nIn order to run SMTP email server on port number 25, you’ll need root permissions:\n\nIt will help you verify whether your code is working and point out the possible problems if there are any. However, it won’t allow you to check how your HTML email template is rendered.\n\nYou can check our API docs for full details on API testing. I’ll be using Python 3 to show you the method, and lead you the way step-by-step.\n• Establish a connection to the Mailtrap Email Testing API endpoint using .\n• Define your email content, including recipients ( , , ), sender ( ), subject, text content, and any attachments or custom variables as a JSON payload.\n• Make a POST request to the Mailtrap Email Testing API with your payload and necessary headers, including your API token for authorization. Here’s an example:\n• Payload: The dictionary contains all the details of the email you want to test. Make sure to replace placeholder values with actual data relevant to your test case. For attachments, encode your file content to Base64 and include it in the field.\n• Headers: Include your , , and headers. The Api-Token should be your Mailtrap API token.\n• Request and response: The script makes a POST request to the endpoint, replacing with your actual inbox ID. Then, it reads and prints the response to check the result.\n\nNext steps with emails in Python\n\nI demonstrated the options of sending emails with Python to describe the logic and a range of its capabilities. But I recommend reviewing the Python documentation and experimenting with your own code to get great results!\n\nThere are a bunch of various Python frameworks and libraries that make creating apps more elegant and dedicated. In particular, some of them can help improve your experience with building email-sending functionality:\n\nThe most popular frameworks are:\n• Flask, which offers a simple interface for email sending— Flask Mail. Feel free to learn more in our guide on how to send emails with Flask.\n• Django can be a great option for building HTML templates. Also, take a look at our Django email sending tutorial.\n• Zope comes in handy for website development.\n• Plotly and its Dash can help with mailing graphs and reports.\n\nGood luck, and don’t forget to stay on the safe side when sending your emails!"
    },
    {
        "link": "https://realpython.com/python-send-email",
        "document": "You probably found this tutorial because you want to send emails using Python. Perhaps you want to receive email reminders from your code, send a confirmation email to users when they create an account, or send emails to members of your organization to remind them to pay their dues. Sending emails manually is a time-consuming and error-prone task, but it’s easy to automate with Python.\n\nIn this tutorial you’ll learn how to:\n• Set up a secure connection using and\n• Send emails with HTML content and attachments using the package\n• Use the Yagmail package to send email through your Gmail account using only a few lines of code\n\nYou’ll find a few transactional email services at the end of this tutorial, which will come in useful when you want to send a large number of emails.\n\nPython comes with the built-in module for sending emails using the Simple Mail Transfer Protocol (SMTP). uses the RFC 821 protocol for SMTP. The examples in this tutorial will use the Gmail SMTP server to send emails, but the same principles apply to other email services. Although the majority of email providers use the same connection ports as the ones in this tutorial, you can run a quick Google search to confirm yours. To get started with this tutorial, set up a Gmail account for development, or set up an SMTP debugging server that discards emails you send and prints them to the command prompt instead. Both options are laid out for you below. A local SMTP debugging server can be useful for fixing any issues with email functionality and ensuring your email functions are bug-free before sending out any emails. If you decide to use a Gmail account to send your emails, I highly recommend setting up a throwaway account for the development of your code. This is because you’ll have to adjust your Gmail account’s security settings to allow access from your Python code, and because there’s a chance you might accidentally expose your login details. Also, I found that the inbox of my testing account rapidly filled up with test emails, which is reason enough to set up a new Gmail account for development. A nice feature of Gmail is that you can use the sign to add any modifiers to your email address, right before the sign. For example, mail sent to and will both arrive at . When testing email functionality, you can use this to emulate multiple addresses that all point to the same inbox. To set up a Gmail address for testing your code, do the following:\n• Turn Allow less secure apps to ON. Be aware that this makes it easier for others to gain access to your account. If you don’t want to lower the security settings of your Gmail account, check out Google’s documentation on how to gain access credentials for your Python script, using the OAuth2 authorization framework. You can test email functionality by running a local SMTP debugging server, using the module that comes pre-installed with Python. Rather than sending emails to the specified address, it discards them and prints their content to the console. Running a local debugging server means it’s not necessary to deal with encryption of messages or use credentials to log in to an email server. You can start a local SMTP debugging server by typing the following in Command Prompt: On Linux, use the same command preceded by . Any emails sent through this server will be discarded and shown in the terminal window as a object for each line: b'Hello there, here is a test email' For the rest of the tutorial, I’ll assume you’re using a Gmail account, but if you’re using a local debugging server, just make sure to use as your SMTP server and use port 1025 rather than port 465 or 587. Besides this, you won’t need to use or encrypt the communication using SSL/TLS.\n\nBefore we dive into sending emails with HTML content and attachments, you’ll learn to send plain-text emails using Python. These are emails that you could write up in a simple text editor. There’s no fancy stuff like text formatting or hyperlinks. You’ll learn that a bit later. When you send emails through Python, you should make sure that your SMTP connection is encrypted, so that your message and login credentials are not easily accessed by others. SSL (Secure Sockets Layer) and TLS (Transport Layer Security) are two protocols that can be used to encrypt an SMTP connection. It’s not necessary to use either of these when using a local debugging server. There are two ways to start a secure connection with your email server:\n• Start an SMTP connection that is secured from the beginning using .\n• Start an unsecured SMTP connection that can then be encrypted using . In both instances, Gmail will encrypt emails using TLS, as this is the more secure successor of SSL. As per Python’s Security considerations, it is highly recommended that you use from the module. This will load the system’s trusted CA certificates, enable host name checking and certificate validation, and try to choose reasonably secure protocol and cipher settings. If you want to check the encryption for an email in your Gmail inbox, go to More → Show original to see the encryption type listed under the Received header. is Python’s built-in module for sending emails to any Internet machine with an SMTP or ESMTP listener daemon. I’ll show you how to use first, as it instantiates a connection that is secure from the outset and is slightly more concise than the alternative. Keep in mind that Gmail requires that you connect to port 465 if using , and to port 587 when using . The code example below creates a secure connection with Gmail’s SMTP server, using the of to initiate a TLS-encrypted connection. The default context of validates the host name and its certificates and optimizes the security of the connection. Make sure to fill in your own email address instead of : Using makes sure that the connection is automatically closed at the end of the indented code block. If is zero, or not specified, will use the standard port for SMTP over SSL (port 465). It’s not safe practice to store your email password in your code, especially if you intend to share it with others. Instead, use to let the user type in their password when running the script, as in the example above. If you don’t want your password to show on your screen when you type it, you can import the module and use instead for blind input of your password. Instead of using to create a connection that is secure from the outset, we can create an unsecured SMTP connection and encrypt it using . To do this, create an instance of , which encapsulates an SMTP connection and allows you access to its methods. I recommend defining your SMTP server and port at the beginning of your script to configure them easily. The code snippet below uses the construction , rather than the format which we used in the previous example. To make sure that your code doesn’t crash when something goes wrong, put your main code in a block, and let an block print any error messages to : # Try to log in to server and send email To identify yourself to the server, (SMTP) or (ESMTP) should be called after creating an object, and again after . This function is implicitly called by and if needed, so unless you want to check the SMTP service extensions of the server, it is not necessary to use or explicitly. After you initiated a secure SMTP connection using either of the above methods, you can send your email using , which pretty much does what it says on the tin: I recommend defining the email addresses and message content at the top of your script, after the imports, so you can change them easily: This message is sent from Python.\"\"\" The string starts with followed by two newlines ( ). This ensures shows up as the subject of the email, and the text following the newlines will be treated as the message body. The code example below sends a plain-text email using : This message is sent from Python.\"\"\" For comparison, here is a code example that sends a plain-text email over an SMTP connection secured with . The lines may be omitted, as they are called implicitly by and , if required: This message is sent from Python.\"\"\"\n\nPython’s built-in package allows you to structure more fancy emails, which can then be transferred with as you have done already. Below, you’ll learn how use the package to send emails with HTML content and attachments. If you want to format the text in your email (bold, italics, and so on), or if you want to add any images, hyperlinks, or responsive content, then HTML comes in very handy. Today’s most common type of email is the MIME (Multipurpose Internet Mail Extensions) Multipart email, combining HTML and plain-text. MIME messages are handled by Python’s module. For a detailed description, check the documentation. As not all email clients display HTML content by default, and some people choose only to receive plain-text emails for security reasons, it is important to include a plain-text alternative for HTML messages. As the email client will render the last multipart attachment first, make sure to add the HTML message after the plain-text version. In the example below, our objects will contain the HTML and plain-text versions of our message, and the instance combines these into a single message with two alternative rendering options: # Create the plain-text and HTML version of your message # The email client will try to render the last part first In this example, you first define the plain-text and HTML message as string literals, and then store them as / objects. These can then be added in this order to the message and sent through your secure connection with the email server. Remember to add the HTML message after the plain-text alternative, as email clients will try to render the last subpart first. In order to send binary files to an email server that is designed to work with textual data, they need to be encoded before transport. This is most commonly done using , which encodes binary data into printable ASCII characters. The code example below shows how to send an email with a PDF file as an attachment: \"An email with attachment from Python\" \"This is an email with attachment sent from Python\" # In same directory as script # Email client can usually download this automatically as attachment # Encode file in ASCII characters to send by email # Add attachment to message and convert message to string # Log in to server using secure context and send email The message accepts parameters in the form of RFC5233-style key/value pairs, which are stored in a dictionary and passed to the method of the base class. Check out the documentation for Python’s module to learn more about using MIME classes.\n\nImagine you want to send emails to members of your organization, to remind them to pay their contribution fees. Or maybe you want to send students in your class personalized emails with the grades for their recent assignment. These tasks are a breeze in Python. An easy starting point for sending multiple personalized emails is to create a CSV (comma-separated values) file that contains all the required personal information. (Make sure not to share other people’s private information without their consent.) A CSV file can be thought of as a simple table, where the first line often contains the column headers. Below are the contents of the file , which I saved in the same folder as my Python code. It contains the names, addresses, and grades for a set of fictional people. I used constructions to make sure all emails end up in my own inbox, which in this example is my@gmail.com: When creating a CSV file, make sure to separate your values by a comma, without any surrounding whitespaces. The code example below shows you how to open a CSV file and loop over its lines of content (skipping the header row). To make sure that the code works correctly before you send emails to all your contacts, I’ve printed for each contact, which we can later replace with functionality that actually sends out emails: In the example above, using makes sure that your file closes at the end of the code block. makes it easy to read a CSV file line by line and extract its values. The line skips the header row, so that the following line for name, email, grade in reader: splits subsequent rows at each comma, and stores the resulting values in the strings , and for the current contact. If the values in your CSV file contain whitespaces on either or both sides, you can remove them using the method. You can put personalized content in a message by using to fill in curly-bracket placeholders. For example, \"hi {name}, you {result} your assignment\".format(name=\"John\", result=\"passed\") will give you \"hi John, you passed your assignment\" . As of Python 3.6, string formatting can be done more elegantly using f-strings, but these require the placeholders to be defined before the f-string itself. In order to define the email message at the beginning of the script, and fill in placeholders for each contact when looping over the CSV file, the older method is used. With this in mind, you can set up a general message body, with placeholders that can be tailored to individuals. The following code example lets you send personalized emails to multiple contacts. It loops over a CSV file with for each contact, as in the example above. The general message is defined in the beginning of the script, and for each contact in the CSV file its and placeholders are filled in, and a personalized email is sent out through a secure connection with the Gmail server, as you saw before:\n\nThere are multiple libraries designed to make sending emails easier, such as Envelopes, Flanker and Yagmail. Yagmail is designed to work specifically with Gmail, and it greatly simplifies the process of sending emails through a friendly API, as you can see in the code example below: \"Hello there from Yagmail\" This code example sends an email with a PDF attachment in a fraction of the lines needed for our example using and . When setting up Yagmail, you can add your Gmail validations to the keyring of your OS, as described in the documentation. If you don’t do this, Yagmail will prompt you to enter your password when required and store it in the keyring automatically.\n\nIf you plan to send a large volume of emails, want to see email statistics, and want to ensure reliable delivery, it may be worth looking into transactional email services. Although all of the following services have paid plans for sending large volumes of emails, they also come with a free plan so you can try them out. Some of these free plans are valid indefinitely and may be sufficient for your email needs. Below is an overview of the free plans for some of the major transactional email services. Clicking on the provider name will take you to the pricing section of their website. 40,000 emails for your first 30 days, then 100/day You can run a Google search to see which provider best fits your needs, or just try out a few of the free plans to see which API you like working with most."
    },
    {
        "link": "https://realpython.com/python-send-email",
        "document": "You probably found this tutorial because you want to send emails using Python. Perhaps you want to receive email reminders from your code, send a confirmation email to users when they create an account, or send emails to members of your organization to remind them to pay their dues. Sending emails manually is a time-consuming and error-prone task, but it’s easy to automate with Python.\n\nIn this tutorial you’ll learn how to:\n• Set up a secure connection using and\n• Send emails with HTML content and attachments using the package\n• Use the Yagmail package to send email through your Gmail account using only a few lines of code\n\nYou’ll find a few transactional email services at the end of this tutorial, which will come in useful when you want to send a large number of emails.\n\nPython comes with the built-in module for sending emails using the Simple Mail Transfer Protocol (SMTP). uses the RFC 821 protocol for SMTP. The examples in this tutorial will use the Gmail SMTP server to send emails, but the same principles apply to other email services. Although the majority of email providers use the same connection ports as the ones in this tutorial, you can run a quick Google search to confirm yours. To get started with this tutorial, set up a Gmail account for development, or set up an SMTP debugging server that discards emails you send and prints them to the command prompt instead. Both options are laid out for you below. A local SMTP debugging server can be useful for fixing any issues with email functionality and ensuring your email functions are bug-free before sending out any emails. If you decide to use a Gmail account to send your emails, I highly recommend setting up a throwaway account for the development of your code. This is because you’ll have to adjust your Gmail account’s security settings to allow access from your Python code, and because there’s a chance you might accidentally expose your login details. Also, I found that the inbox of my testing account rapidly filled up with test emails, which is reason enough to set up a new Gmail account for development. A nice feature of Gmail is that you can use the sign to add any modifiers to your email address, right before the sign. For example, mail sent to and will both arrive at . When testing email functionality, you can use this to emulate multiple addresses that all point to the same inbox. To set up a Gmail address for testing your code, do the following:\n• Turn Allow less secure apps to ON. Be aware that this makes it easier for others to gain access to your account. If you don’t want to lower the security settings of your Gmail account, check out Google’s documentation on how to gain access credentials for your Python script, using the OAuth2 authorization framework. You can test email functionality by running a local SMTP debugging server, using the module that comes pre-installed with Python. Rather than sending emails to the specified address, it discards them and prints their content to the console. Running a local debugging server means it’s not necessary to deal with encryption of messages or use credentials to log in to an email server. You can start a local SMTP debugging server by typing the following in Command Prompt: On Linux, use the same command preceded by . Any emails sent through this server will be discarded and shown in the terminal window as a object for each line: b'Hello there, here is a test email' For the rest of the tutorial, I’ll assume you’re using a Gmail account, but if you’re using a local debugging server, just make sure to use as your SMTP server and use port 1025 rather than port 465 or 587. Besides this, you won’t need to use or encrypt the communication using SSL/TLS.\n\nBefore we dive into sending emails with HTML content and attachments, you’ll learn to send plain-text emails using Python. These are emails that you could write up in a simple text editor. There’s no fancy stuff like text formatting or hyperlinks. You’ll learn that a bit later. When you send emails through Python, you should make sure that your SMTP connection is encrypted, so that your message and login credentials are not easily accessed by others. SSL (Secure Sockets Layer) and TLS (Transport Layer Security) are two protocols that can be used to encrypt an SMTP connection. It’s not necessary to use either of these when using a local debugging server. There are two ways to start a secure connection with your email server:\n• Start an SMTP connection that is secured from the beginning using .\n• Start an unsecured SMTP connection that can then be encrypted using . In both instances, Gmail will encrypt emails using TLS, as this is the more secure successor of SSL. As per Python’s Security considerations, it is highly recommended that you use from the module. This will load the system’s trusted CA certificates, enable host name checking and certificate validation, and try to choose reasonably secure protocol and cipher settings. If you want to check the encryption for an email in your Gmail inbox, go to More → Show original to see the encryption type listed under the Received header. is Python’s built-in module for sending emails to any Internet machine with an SMTP or ESMTP listener daemon. I’ll show you how to use first, as it instantiates a connection that is secure from the outset and is slightly more concise than the alternative. Keep in mind that Gmail requires that you connect to port 465 if using , and to port 587 when using . The code example below creates a secure connection with Gmail’s SMTP server, using the of to initiate a TLS-encrypted connection. The default context of validates the host name and its certificates and optimizes the security of the connection. Make sure to fill in your own email address instead of : Using makes sure that the connection is automatically closed at the end of the indented code block. If is zero, or not specified, will use the standard port for SMTP over SSL (port 465). It’s not safe practice to store your email password in your code, especially if you intend to share it with others. Instead, use to let the user type in their password when running the script, as in the example above. If you don’t want your password to show on your screen when you type it, you can import the module and use instead for blind input of your password. Instead of using to create a connection that is secure from the outset, we can create an unsecured SMTP connection and encrypt it using . To do this, create an instance of , which encapsulates an SMTP connection and allows you access to its methods. I recommend defining your SMTP server and port at the beginning of your script to configure them easily. The code snippet below uses the construction , rather than the format which we used in the previous example. To make sure that your code doesn’t crash when something goes wrong, put your main code in a block, and let an block print any error messages to : # Try to log in to server and send email To identify yourself to the server, (SMTP) or (ESMTP) should be called after creating an object, and again after . This function is implicitly called by and if needed, so unless you want to check the SMTP service extensions of the server, it is not necessary to use or explicitly. After you initiated a secure SMTP connection using either of the above methods, you can send your email using , which pretty much does what it says on the tin: I recommend defining the email addresses and message content at the top of your script, after the imports, so you can change them easily: This message is sent from Python.\"\"\" The string starts with followed by two newlines ( ). This ensures shows up as the subject of the email, and the text following the newlines will be treated as the message body. The code example below sends a plain-text email using : This message is sent from Python.\"\"\" For comparison, here is a code example that sends a plain-text email over an SMTP connection secured with . The lines may be omitted, as they are called implicitly by and , if required: This message is sent from Python.\"\"\"\n\nPython’s built-in package allows you to structure more fancy emails, which can then be transferred with as you have done already. Below, you’ll learn how use the package to send emails with HTML content and attachments. If you want to format the text in your email (bold, italics, and so on), or if you want to add any images, hyperlinks, or responsive content, then HTML comes in very handy. Today’s most common type of email is the MIME (Multipurpose Internet Mail Extensions) Multipart email, combining HTML and plain-text. MIME messages are handled by Python’s module. For a detailed description, check the documentation. As not all email clients display HTML content by default, and some people choose only to receive plain-text emails for security reasons, it is important to include a plain-text alternative for HTML messages. As the email client will render the last multipart attachment first, make sure to add the HTML message after the plain-text version. In the example below, our objects will contain the HTML and plain-text versions of our message, and the instance combines these into a single message with two alternative rendering options: # Create the plain-text and HTML version of your message # The email client will try to render the last part first In this example, you first define the plain-text and HTML message as string literals, and then store them as / objects. These can then be added in this order to the message and sent through your secure connection with the email server. Remember to add the HTML message after the plain-text alternative, as email clients will try to render the last subpart first. In order to send binary files to an email server that is designed to work with textual data, they need to be encoded before transport. This is most commonly done using , which encodes binary data into printable ASCII characters. The code example below shows how to send an email with a PDF file as an attachment: \"An email with attachment from Python\" \"This is an email with attachment sent from Python\" # In same directory as script # Email client can usually download this automatically as attachment # Encode file in ASCII characters to send by email # Add attachment to message and convert message to string # Log in to server using secure context and send email The message accepts parameters in the form of RFC5233-style key/value pairs, which are stored in a dictionary and passed to the method of the base class. Check out the documentation for Python’s module to learn more about using MIME classes.\n\nImagine you want to send emails to members of your organization, to remind them to pay their contribution fees. Or maybe you want to send students in your class personalized emails with the grades for their recent assignment. These tasks are a breeze in Python. An easy starting point for sending multiple personalized emails is to create a CSV (comma-separated values) file that contains all the required personal information. (Make sure not to share other people’s private information without their consent.) A CSV file can be thought of as a simple table, where the first line often contains the column headers. Below are the contents of the file , which I saved in the same folder as my Python code. It contains the names, addresses, and grades for a set of fictional people. I used constructions to make sure all emails end up in my own inbox, which in this example is my@gmail.com: When creating a CSV file, make sure to separate your values by a comma, without any surrounding whitespaces. The code example below shows you how to open a CSV file and loop over its lines of content (skipping the header row). To make sure that the code works correctly before you send emails to all your contacts, I’ve printed for each contact, which we can later replace with functionality that actually sends out emails: In the example above, using makes sure that your file closes at the end of the code block. makes it easy to read a CSV file line by line and extract its values. The line skips the header row, so that the following line for name, email, grade in reader: splits subsequent rows at each comma, and stores the resulting values in the strings , and for the current contact. If the values in your CSV file contain whitespaces on either or both sides, you can remove them using the method. You can put personalized content in a message by using to fill in curly-bracket placeholders. For example, \"hi {name}, you {result} your assignment\".format(name=\"John\", result=\"passed\") will give you \"hi John, you passed your assignment\" . As of Python 3.6, string formatting can be done more elegantly using f-strings, but these require the placeholders to be defined before the f-string itself. In order to define the email message at the beginning of the script, and fill in placeholders for each contact when looping over the CSV file, the older method is used. With this in mind, you can set up a general message body, with placeholders that can be tailored to individuals. The following code example lets you send personalized emails to multiple contacts. It loops over a CSV file with for each contact, as in the example above. The general message is defined in the beginning of the script, and for each contact in the CSV file its and placeholders are filled in, and a personalized email is sent out through a secure connection with the Gmail server, as you saw before:\n\nThere are multiple libraries designed to make sending emails easier, such as Envelopes, Flanker and Yagmail. Yagmail is designed to work specifically with Gmail, and it greatly simplifies the process of sending emails through a friendly API, as you can see in the code example below: \"Hello there from Yagmail\" This code example sends an email with a PDF attachment in a fraction of the lines needed for our example using and . When setting up Yagmail, you can add your Gmail validations to the keyring of your OS, as described in the documentation. If you don’t do this, Yagmail will prompt you to enter your password when required and store it in the keyring automatically.\n\nIf you plan to send a large volume of emails, want to see email statistics, and want to ensure reliable delivery, it may be worth looking into transactional email services. Although all of the following services have paid plans for sending large volumes of emails, they also come with a free plan so you can try them out. Some of these free plans are valid indefinitely and may be sufficient for your email needs. Below is an overview of the free plans for some of the major transactional email services. Clicking on the provider name will take you to the pricing section of their website. 40,000 emails for your first 30 days, then 100/day You can run a Google search to see which provider best fits your needs, or just try out a few of the free plans to see which API you like working with most."
    },
    {
        "link": "https://mailtrap.io/blog/python-send-html-email",
        "document": "For developers, especially those harnessing the power of Python, sending HTML emails can be a game-changer.\n\nIn this ‘Python send HTML email’ guide, we aim to demystify the process for junior developers.\n\nTo skip the setup process and jump straight to sending emails with SMTP, [click here].\n\nThe native libraries that allow you to craft and send HTML emails effortlessly are the and modules.\n\nThe module is a part of Python’s standard library, making it readily available for all Python installations. It empowers you to establish connections with SMTP servers and send emails using the SMTP protocol.\n• First, you establish a connection to the SMTP server of your choice, like Mailtrap’s SMTP email server.\n• You provide your SMTP server credentials (username and password) and any necessary security settings (TLS/SSL).\n• Then, you create an email message using the module.\n• Finally, you send the email using the established SMTP connection.\n\nThe module, another built-in Python library, is used for managing email messages. It allows you to create structured emails with various components such as subject, sender, recipient, and most importantly, the email’s content, including HTML content.\n• You create an object and set its attributes like , , and .\n• For the HTML content, you add an HTML email body part to the email message.\n• Attachments, inline images, and alternative plain text content can also be added as needed.\n• The module helps ensure that your email conforms to email standards.\n\nTogether, these two modules provide the fundamental building blocks for sending HTML emails directly from Python, making it accessible to developers of all levels of experience.\n\nAlso, we’ll add the MIME message type, handled by the module since it can combine HTML and CSS and plain text.\n\nNote: It’s advisable to have the HTML and plain text versions of an email separate, then merge them using the instance. This way, you ensure that the text version of the email gets displayed in case there’s an issue with the HTML version.\n\nThis script establishes a connection to the Mailtrap SMTP server using the provided credentials. After crafting the email with both plain text and HTML content, it sends the email.\n\nAlways remember to replace the credentials with your actual username and password.\n\nNote: is the default username for all Mailtrap Sending SMTP users, but the password is unique to each user.\n\nYou’ve already got the exemplary script. Now, we’ll break it down and walk you through the code step by step.\n\nThese modules provide tools for working with SMTP (Simple Mail Transfer Protocol) and for constructing email messages.\n\nThese are the SMTP server details. The login and password are generated by Mailtrap for each Mailtrap user.\n\nHere, the sender and receiver email addresses are defined. An “alternative” MIMEMultipart message is created, which means the email client will try to render the last part first (in this case, HTML), and if it can’t, it will fall back to the earlier parts (here, plain text).\n\nThis is where the plain text (fallback) version of your email goes.\n\n5. The HTML version of the email\n\nThe HTML version – check the full script above for the complete snippet.\n\n6. Attaching the content to the email\n\nBoth the plain text and HTML parts are converted to objects. These are then attached to the message, making the email multipart.\n\nThis section actually sends the email. An SMTP connection to the server is opened, the server is logged into with the provided credentials, and the email is sent using the method. The email message is converted to a string format using .\n\nAnd that’s it, this simple statement confirms your email has been sent via Mailtrap’s SMTP server. Remember always to use the correct SMTP server credentials, be it Mailtrap or other providers, and tailor the email content to your needs.\n\nSending emails to multiple recipients is a common task, especially when disseminating information like newsletters, announcements, or updates. The native Python modules make this task easy and efficient.\n\nThe field in the object accepts a list of email addresses. If you provide multiple email addresses in this list, the email will be sent to each of these recipients.\n\nWhen sending emails, sometimes you want to include recipients in the Carbon Copy (CC) or Blind Carbon Copy (BCC) fields.\n\nThe former is used to send a copy to interested parties who are not the primary audience, while the latter is for recipients who shouldn’t see the other email addresses the email is sent to.\n\nTo send emails with CC and BCC in Python:\n\nReminder: In the context of the , the BCC recipients won’t see the email addresses of the other BCC recipients, and the primary recipients won’t see any of the BCC email addresses.\n\nHowever, if you’re sending in bulk, to dozens or hundreds of recipients, Python saves you a lot of headaches if you use loops.\n\n\n\nFor example, one option is to create a database, formatted in .csv, and save that file in the same folder as your Python sending script. I’ll cover this example here as it’s the closest to what you may encounter in a production scenario. Of course, we assume you already created and saved the recipients’ .csv file.\n\nThe exemplary script below sends an order confirmation email to multiple recipients whose names and email addresses are stored in a file. The script uses the module to send the emails and the module to read the contacts from the CSV file.\n\nHere’s the code breakdown so you can better understand the flow:\n\nThe csv module is used for reading from and writing to CSV files. And the smtplib is used for sending emails using SMTP.\n\nLike before, this part of the script handles SMTP server details, the sender email address, and the corresponding credentials.\n\nThis is a string template for the email. It uses placeholders , , and that will be replaced with actual values for each recipient.\n\nHere, a connection to the SMTP server gets established and it logs into the server with the provided credentials.\n\nThe script reads the file. The line is used to skip the header row of the CSV file, assuming the first row contains column names and not actual data.\n\nFor each name and email pair in the CSV file, the following actions are performed:\n• The template is filled using the method with the current name, email, and sender values.\n• The email is sent to the current email address using .\n• A print statement indicates to the console that the email has been sent to the current name.\n\nTo recap, the script allows for batch sending of personalized emails. It’s particularly useful for situations like order confirmations, event invitations, and other scenarios where you might want to send a similar message to multiple recipients, but with some personalized details.\n\n\n\nPro Tip: If you need to validate email addresses before sending emails, click the link to check our detailed tutorial.\n\nSending attachments via email using Python is a fairly common task, especially when automating certain processes, such as sending reports or invoices. Attachments can be of various types – from simple text files and documents to images and compressed files.\n\nTo be exact, you can attach .txt, rich text, text files, images, audio files, and applications. You only need to use the right class, for example:\n\nHere’s the modified version of the script to include the attachments.\n\nThe script shows how to attach a binary file (in this case, a PDF) to an email. The process involves reading the binary content of the file, wrapping it in a MIME object with the appropriate headers, encoding it with base64, and finally attaching it to the email message.\n\nHere’s the breakdown of the steps, focusing on attaching the image:\n\nNote that we included the following, on top of the existing modules:\n• – provide access to the base64 encoder which we use for encoding the attachment.\n• – acts as the base for creating MIME objects of a specific content type.\n\nThe line’s function is pretty self-explanatory, only make sure that the file names match.\n• Open the file and create the attachment\n\nHere, the file is opened in binary read mode and its content is read. The MIME attachment is then created as a binary file with the content type . This content type is a general binary file MIME type and is used here to represent the PDF.\n\nThe MIME attachment (which is the PDF content) is then encoded using base64 encoding, which ensures secure data transfer as text, without any corruptions in the PDF contents.\n\nThe header is added to indicate that the MIME object is an attachment. It also specifies the filename for the attachment. This ensures that when the recipient opens the email, they will see the file presented as an attachment named “yourBP.pdf”.\n• Attaching the file to the email\n\nThe attachment is added to the overall email . The entire message, including its text and the attachment, is then converted to a string using . This string representation is what’s sent through the SMTP server.\n• Relevance is key: Only attach files that are relevant to the content of your email. Unnecessary attachments can be confusing for the recipient.\n• File naming conventions: Adopt clear and descriptive file names. This helps the recipient understand the content without opening it. For example, instead of naming a file , consider a more descriptive name like .\n• Compress large files: To ensure the efficient sending and downloading of files, use compression tools to reduce the size of larger attachments. Tools like `zip` or `rar` can be invaluable.\n\nNote: If you’re an Apple user, it’s best to opt for the native compression/”zipping” option. Two-finger tap or right-click on a file or folder, then choose “Compress “file_name””.\n• File type considerations: Always ensure that the file type you’re sending is commonly used and can be easily accessed by the recipient. It might be frustrating for them if they need to download special software just to view your attachment.\n\nThe rule of thumb is to stick to widely recognized file formats, such as `.pdf`, `.docx`, or `.xlsx`, when sending documents. This ensures maximum compatibility with the recipient’s software.\n\nTip: Mailtrap doesn’t have any limitations for attachment file types.\n• Alert the recipient: If you’re sending a particularly large file or multiple attachments, it’s a good practice to notify the recipient in the body of the email. This gives them a heads-up and ensures they check all the attachments.\n• Scan for malware: Always ensure that the files you’re attaching are free from malware or viruses. This not only protects the recipient but also your reputation.\n• Limit the number: Avoid sending too many attachments in a single email. If you have multiple files, consider combining them into a single compressed file or sharing a cloud storage link where the recipient can access them.\n• Test before sending: Especially when working with important emails or a new system, send a test email to yourself or a colleague first. Ensure that the attachments come through correctly and can be opened without issues.\n\nNote: Later in the article, you’ll find a tutorial on how to test emails with Mailtrap and check mobile compatibility, HTML and CSS, and get a spam score.\n\nWhen you send marketing emails, newsletters, or any communication that demands user attention, images play an indispensable role. They add aesthetic appeal and can convey complex ideas quickly.\n\nKeep in mind that images are still regarded as attachments, even if they’re a part of the email body. There are three ways, or three methods, to embed the image:\n• CID attachments (which get embedded with a MIME object)\n• Base64 images (which is the so-called inline embedding)\n\nIn this section, we’ll explore the CID attachments and the Base64 images. Then, we’ll just touch upon linking images from an external resource.\n\nThe script below features a MIME multipart message, containing the MIMEImage component. Here’s the full script.\n\nCheck the code breakdown, we’ll only focus on MIME components and embedded images.\n\nThe class creates the MIME message object specific to the image attachments.\n• The HTML email with the embedded image\n\nThis section defines the HTML content of the email. The tag features the attribute value of the . The “cid” stands for Content ID and is a way to reference attachments embedded within the email. In this instance, the image with the content ID will be displayed wherever the tag appears in the HTML.\n• Attaching the HTML to the message:\n\nThe snippet constructs a MIMEText object from the HTML string and attaches it to the main email message.\n\nHere, the script does the following:\n• It opens the image file in binary reading mode .\n• A object named is created from the binary content of the image.\n• The Content ID header is added to the object. This Content ID corresponds to the used in the HTML content. This association allows the email client to understand where to display the embedded image.\n• Finally, the object is attached to the main email message.\n\nThe refactored script below demonstrates an alternative way of embedding images in emails with Base64 encoding. This method involves directly embedding the Base64 encoded string of an image within the HTML content of the email.\n\nMore importantly, the email becomes self-contained without the need for external image references or Content IDs (as in the previous method). It’s an effective way to ensure images are displayed in most email clients without relying on external servers.\n\nHowever, it might increase the size of the email, especially for larger images. With Base64 encoding, you may expect a data size increase of up to 33%.\n\nCheck the code breakdown, again we’re focusing only on embedding images:\n\nThe line imports the base64 module, which provides functions to encode and decode data using the Base64 encoding scheme.\n\nHere, the following actions take place:\n• The script opens the image file in binary reading mode .\n• The content of the image file is read and then encoded using . This function returns a bytes-like object.\n• The method is applied to convert the bytes-like object into a UTF-8 encoded string representation of the Base64 encoded image. This string representation is stored in the variable.\n\nThe encoded Base64 string basically gets embedded directly into HTML and here’s how:\n• The attribute of the tag is set to a Data URL. This URL starts with the prefix , followed by the Base64 encoded string of the image (represented by in the f-string).\n• Data URLs allow you to embed data directly into web documents, thereby avoiding external image references. It’s especially useful for smaller images, ensuring they get displayed even if the recipient is offline or their email client blocks external loads.\n\nIf your image is hosted on a remote server, it’s generally recommended to link it directly:\n\nHowever, this means the email client must fetch the image from the server, which may or may not happen based on the client’s settings. Honestly, more secure apps would typically block the request.\n\nAnyway, always ensure you have permission to link directly to an image on a remote server before using this method.\n\nWhile many image formats exist, the most commonly supported formats in email clients are JPEG and PNG. Both are well-suited for emails due to their wide support and compression capabilities.\n• JPEG (.jpeg): Best suited for photographs or images with gradients.\n• PNG (.png): Ideal for images with transparency, logos, or text.\n\nTip on HEIC: Apple’s image format, offers great compression advantages. However, it’s not universally supported across all email clients. It might be best to convert HEIC images to JPEG or PNG before embedding them in emails.\n\nIf you’re using Mailtrap Email Sending via API, you can leverage Mailtrap Email Templates and upload the images you want to embed directly to our platform.\n\nMailtrap templates use the Hanlebars syntax, so it’s possible to add logical operators to automate and customize the templates. As for the image limitations, we support the following:\n\nEmbedding images can make your emails quite “heavy”, leading to slow load times and possible delivery issues. Here are a few tips to avoid that:\n• Resize images: Ensure your image dimensions are no larger than they need to be.\n• Compress Images: Use tools like TinyPNG or Compressor.io to reduce file size without compromising on quality.\n• Avoid embedding large images: If an image is too large, consider linking to it instead of embedding it. Or you may send it as a compressed attachment.\n\nPython snippet for image compression (using the library)\n\nNow, the best method could probably be, to stay within the Python environment and leverage the Pillow library to optimize image size. Here’s how to do it:\n\nNow, you can use the following snippet to compress images:\n\nAdjust the parameter as needed. Lower values will result in higher compression but might decrease image quality.\n\nNo doubt, images can immensely boost the impact of your emails. Only ensure you’re using the right formats, optimize appropriately, and respect permissions when sourcing from external servers.\n\nPreviously, we mentioned that the max size of an embedded image within a Mailtrap email template is 2 MB. Here we discuss the size of the entire email.\n\nThe max size of an entire email, attachments included, is 10 MB (10240 KB) across all plans, Free plan included. Upon request, users can get the limit extended up to 30 MB (30720 KB).\n\nAs a general guideline, please ensure that your total email size, including all attachments, doesn’t go beyond the set limit. Exceeding this limit could result in your email not being sent or delivered as expected.\n\nEmail Application Programming Interfaces (APIs) offer a more scalable, efficient, and often simpler way to send emails, as opposed to traditional SMTP setups.\n\nFor this tutorial, we will delve into the Mailtrap Python SDK, as it offers a simplified interface to send, receive, and test emails; all while interacting with Mailtrap’s API.\n\nMailtrap-python on GitHub is the official repository for Mailtrap’s Python SDK, and Mailtrap’s API Documentation provides in-depth details on how to harness the full power of this tool.\n\nTo get started, you’ll need to first install the SDK.\n\nNow, here’s a basic example to send an email with minimal resource usage.\n\nRemember to replace and with your actual Mailtrap API token. And you can find the full usage example on our GitHub page.\n\nIf you want to use templates with Mailtrap, here’s how to create the mail object and send.\n\nThe beauty of Mailtrap’s Python SDK is that it allows for a multitude of customizations and configurations. You can add attachments, utilize CC/BCC, and get the following:\n• Simplicity: Using Mailtrap’s Python SDK, you can avoid setting up SMTP configurations and reduce the boilerplate code that’s typically required when sending emails.\n• Testability: Mailtrap offers a safe environment to test and view your emails before sending them to actual users, avoiding potential mishaps.\n• Scalability: If you’re building applications that require sending a large volume of emails, using an API is often a better solution than SMTP due to its inherent capability to handle bulk requests.\n• Store credentials securely: Never hard-code your API token or credentials. Use environment variables or secret management tools.\n• Error handling: Always incorporate error handling when working with APIs to gracefully manage any unforeseen issues.\n• Monitor usage: Keep an eye on your API usage to ensure you’re not hitting any rate limits or overusing your allowed quota. Mailtrap’s documentation provides detailed information on limits and quotas.\n\nSending HTML emails without proper testing can lead to formatting issues, broken links, and a poor user experience. This section highlights the significance of email testing and provides strategies for thorough testing.\n• Consistency: Ensure that your email appears consistently across different email clients (Gmail, Outlook, Apple Mail, etc.) and devices (desktop, mobile).\n• Mobile responsiveness: A significant portion of email opens happens on mobile devices. Test to make sure your emails are mobile-friendly and display correctly on various screen sizes.\n• Broken links and images: Test for broken links and images to prevent users from encountering missing or inaccessible content.\n• Spam avoidance: Properly formatted emails are less likely to be flagged as spam. Testing helps maintain a good sender reputation.\n• User experience: Ultimately, testing ensures a positive user experience and can improve click-through rates and engagement.\n\nMailtrap Email Testing provides a comprehensive solution for testing HTML emails. It allows you to:\n\nMailtrap gives you two options to test your emails, a simple integration with SMTP (we give you access to a fake SMTP), or you can fully automate testing flows with the corresponding API.\n\nThe following sections assume you’re already a Mailtrap Email Testing user. If not, you can sign up here.\n\nImportant Note: You don’t need to add and verify a domain to use Mailtrap Email Testing.\n• Select Email Testing and you’ll see that we already created an empty testing inbox for you, labeled My Inbox.\n• Click on the inbox, and select Python smtplib under the Integrations tab. We also offer ready-made code snippets for Django and Flask-Mail.\n\n\n\nBenefit – using the lib, you don’t need to copy-paste your credentials.\n• Run the code and your test email should appear under My Inbox in no time.\n• You can rename your inbox by clicking on the pencil icon under Action.\n• For security reasons, we keep your SMTP/POP3 credentials hidden. And we suggest you do the same. Clicking Shows Credentials reveals them.\n• By default, our exemplary scripts use port 2525. But, depending on your system and environment the port could be blocked by a firewall. If that’s the case, switch to port 587.\n\nMailtrap testing API can return calls as JSON objects and it uses REST protocol. Also, it’s compatible with most programming languages.\n\n\n\nSupported HTTP requests:\n• GET – get a resource or list of resources\n\nAnd here’s how to get started:\n• Grab your API token, then proceed to send HTTP requests\n• Use one of the following methods to send the authenticated request:\n• Send a HTTP header , where is your API token.\n• Send a HTTP header , where is your API token.\n• Our YouTube tutorial on testing in Python\n\nWe hope your journey through Python HTML email landscape has been enlightening. We delved into various methods, from native Python libraries to the simplicity of Mailtrap’s Python SDK.\n\nAnd, by now, you should have mastered SMTP, handling multiple recipients, image embedding, and attachments. Beyond that, we also shed a light at the heart of email success: comprehensive testing.\n\nThe keys to successful delivery are in ensuring emails render consistently, embracing mobile responsiveness, and gracefully dancing across email clients.\n\nWith this wisdom in your arsenal, you’re poised not just to send emails but to weave engaging narratives that resonate deeply with your recipients."
    },
    {
        "link": "https://stackoverflow.com/questions/3362600/how-to-send-email-attachments",
        "document": "I am having problems understanding how to email an attachment using Python. I have successfully emailed simple messages with the smtplib . Could someone please explain how to send an attachment in an email. I know there are other posts online but as a Python beginner I find them hard to understand.\n\nBecause there are many answers here for Python 3, but none which show how to use the overhauled library from Python 3.6, here is a quick copy+paste from the current examples documentation. (I have abridged it somewhat to remove frills like guessing the correct MIME type.) Modern code which targets Python >3.5 should no longer use the API (including the various , , etc classes) or the even older mumbo jumbo. from email.message import EmailMessage import smtplib from pathlib import Path msg = EmailMessage() msg[\"Subject\"] = \"Our family reunion\" msg[\"From\"] = \"me <[email protected]>\" msg[\"To\"] = \"recipient <[email protected]>\" # definitely don't mess with the .preamble msg.set_content(\"Hello, victim! Look at these pictures\") picpath = Path(\"path/to/attachment.png\") with picpath.open(\"rb\") as fp: msg.add_attachment( fp.read(), maintype=\"image\", subtype=\"png\", filename=picpath.name) # Notice how smtplib now includes a send_message() method with smtplib.SMTP(\"localhost\") as s: s.send_message(msg) The modern API is now quite a bit more versatile and logical than the older version of the library. There are still a few kinks around the presentation in the documentation (it's not obvious how to change the of an attachment, for example; and the discussion of the module is probably too obscure for most newcomers) and fundamentally, you still need to have some sort of idea of what the MIME structure should look like (though the library now finally takes care of a lot of the nitty-gritty around that). Perhaps see What are the \"parts\" in a multipart email? for a brief introduction. Using as your SMTP server obviously only works if you actually have an SMTP server running on your local computer. Properly getting email off your system is a fairly complex separate question. For simple requirements, probably use your existing email account and your provider's email server (search for examples of using port 587 with Google, Yahoo, or whatever you have - what exactly works depends somewhat on the provider; some will only support port 465, or legacy port 25 which is however now by and large impossible to use on public-facing servers because of spam filtering).\n\nNone of the currently given answers here will work correctly with non-ASCII symbols in filenames with clients like GMail, Outlook 2016, and others that don't support RFC 2231 (e.g., see here). The Python 3 code below is adapted from some other stackoverflow answers (sorry, didn't save the origin links) and odoo/openerp code for Python 2.7 (see ir_mail_server.py). It works correctly with GMail and others, and also uses SSL. import smtplib, ssl from os.path import basename from email.mime.base import MIMEBase from mimetypes import guess_type from email.encoders import encode_base64 from email.mime.multipart import MIMEMultipart from email.mime.text import MIMEText from email.utils import COMMASPACE, formatdate from email.charset import Charset def try_coerce_ascii(string_utf8): \"\"\"Attempts to decode the given utf8-encoded string as ASCII after coercing it to UTF-8, then return the confirmed 7-bit ASCII string. If the process fails (because the string contains non-ASCII characters) returns ``None``. \"\"\" try: string_utf8.encode('ascii') except UnicodeEncodeError: return return string_utf8 def encode_header_param(param_text): \"\"\"Returns an appropriate RFC 2047 encoded representation of the given header parameter value, suitable for direct assignation as the param value (e.g. via Message.set_param() or Message.add_header()) RFC 2822 assumes that headers contain only 7-bit characters, so we ensure it is the case, using RFC 2047 encoding when needed. :param param_text: unicode or utf-8 encoded string with header value :rtype: string :return: if ``param_text`` represents a plain ASCII string, return the same 7-bit string, otherwise returns an ASCII string containing the RFC2047 encoded text. \"\"\" if not param_text: return \"\" param_text_ascii = try_coerce_ascii(param_text) return param_text_ascii if param_text_ascii\\ else Charset('utf8').header_encode(param_text) smtp_server = '<someserver.com>' smtp_port = 465 # Default port for SSL sender_email = '<[email protected]>' sender_password = '<PASSWORD>' receiver_emails = ['<[email protected]>', '<[email protected]>'] subject = 'Test message' message = \"\"\"\\ Hello! This is a test message with attachments. This message is sent from Python.\"\"\" files = ['<path1>/файл1.pdf', '<path2>/файл2.png'] # Create a secure SSL context context = ssl.create_default_context() msg = MIMEMultipart() msg['From'] = sender_email msg['To'] = COMMASPACE.join(receiver_emails) msg['Date'] = formatdate(localtime=True) msg['Subject'] = subject msg.attach(MIMEText(message)) for f in files: mimetype, _ = guess_type(f) mimetype = mimetype.split('/', 1) with open(f, \"rb\") as fil: part = MIMEBase(mimetype[0], mimetype[1]) part.set_payload(fil.read()) encode_base64(part) filename_rfc2047 = encode_header_param(basename(f)) # The default RFC 2231 encoding of Message.add_header() works in Thunderbird but not GMail # so we fix it by using RFC 2047 encoding for the filename instead. part.set_param('name', filename_rfc2047) part.add_header('Content-Disposition', 'attachment', filename=filename_rfc2047) msg.attach(part) with smtplib.SMTP_SSL(smtp_server, smtp_port, context=context) as server: server.login(sender_email, sender_password) server.sendmail(sender_email, receiver_emails, msg.as_string())\n\nHad a bit of a hussle in getting my script to send generic attachments but after a bit of work doing research and skimming through articles on this post, I finally came up with the following # to query: import sys import ast from datetime import datetime import smtplib import mimetypes from email.mime.application import MIMEApplication from email.mime.multipart import MIMEMultipart from email import encoders from email.message import Message from email.mime.audio import MIMEAudio from email.mime.base import MIMEBase from email.mime.image import MIMEImage from email.mime.text import MIMEText from dotenv import load_dotenv, dotenv_values load_dotenv() # load environment variables from .env ''' sample .env file # .env file SECRET_KEY=\"gnhfpsjxxxxxxxx\" DOMAIN=\"GMAIL\" TOP_LEVEL_DOMAIN=\"COM\" EMAIL=\"CHESERExxxxxx@${DOMAIN}.${TOP_LEVEL_DOMAIN}\" TO_ADDRESS = (\"[email protected]\",\"[email protected]\")#didn't use this in the code but you can load recipients from here ''' import smtplib tls_port = 587 ssl_port = 465 smtp_server_domain_names = {'GMAIL': ('smtp.gmail.com', tls_port, ssl_port), 'OUTLOOK': ('smtp-mail.outlook.com', tls_port, ssl_port), 'YAHOO': ('smtp.mail.yahoo.com', tls_port, ssl_port), 'AT&T': ('smtp.mail.att.net', tls_port, ssl_port), } # todo: Ability to choose mail server provider # auto read in from the dictionary the respective mail server address and the tls and ssl ports class Bimail: def __init__(self, subject, recipients): self.subject = subject self.recipients = recipients self.htmlbody = '' self.mail_username = 'will be loaded from .env file' self.mail_password = 'loaded from .env file as well' self.attachments = [] # Creating an smtp object # todo: if gmail passed in use gmail's dictionary values def setup_mail_client(self, domain_key_to_use=\"GMAIL\", email_servers_domains_dict=smtp_server_domain_names): \"\"\" :param report_pdf: :type to_address: str \"\"\" smtpObj = None encryption_status = True config = dotenv_values(\".env\") # check if the domain_key exists from within the available email-servers-domains dict file passed in # else throw an error # read environment file to get the Domain to be used if f\"{domain_key_to_use}\" in email_servers_domains_dict.keys(): # if the key is found do the following # 1.extract the domain,tls,ssl ports from email_servers dict for use in program try: values_tuple = email_servers_domains_dict.get(f\"{domain_key_to_use}\") ssl_port = values_tuple[2] tls_port = values_tuple[1] smtp_server = values_tuple[0] smtpObj = smtplib.SMTP(smtp_server, tls_port) print(f\"Success connect with tls on {tls_port}\") print('Awaiting for connection encryption via startttls()') encryption_status = False except: print(f\"Failed connection via tls on port {tls_port}\") try: smtpObj = smtplib.SMTP_SSL(smtp_server, ssl_port) print(f\"Success connect with ssl on {ssl_port}\") encryption_status = True except: print(f\"Failed connection via ssl on port {ssl_port}\") finally: print(\"Within Finally block\") if not smtpObj: print(\"Failed!!! no Internet connection\") else: # if connection channel is unencrypted via the use of tls encrypt it if not encryption_status: status = smtpObj.starttls() if status[0] == 220: print(\"Successfully Encrypted tls channel\") print(\"Successfully Connected!!!! Requesting Login\") # Loading .env file values to config variable #load Login Creds from ENV File self.mail_username = f'{config.get(\"EMAIL\")}' self.mail_password = f'{cofig.get(\"SECRET_KEY\")}' status = smtpObj.login(self.mail_usernam,self.mail_password) if status[0] == 235: print(\"Successfully Authenticated User to xxx account\") success = self.send(smtpObj, f'{config.get(\"EMAIL\")}') if not bool(success): print(f\"Success in Sending Mail to {success}\") print(\"Disconnecting from Server INstance\") quit_result = smtpObj.quit() else: print(f\"Failed to Post {success}!!!\") print(f\"Quiting anyway !!!\") quit_result = smtpObj.quit() else: print(\"Application Specific Password is Required\") else: print(\"World\") def send(self,smtpObj,from_address): msg = MIMEMultipart('alternative') msg['From'] = from_address msg['Subject'] = self.subject msg['To'] = \", \".join(self.recipients) # to must be array of the form ['[email protected]'] msg.preamble = \"preamble goes here\" # check if there are attachments if yes, add them if self.attachments: self.attach(msg) # add html body after attachments msg.attach(MIMEText(self.htmlbody, 'html')) # send print(f\"Attempting Email send to the following addresses {self.recipients}\") result = smtpObj.sendmail(from_address, self.recipients,msg.as_string()) return result def htmladd(self, html): self.htmlbody = self.htmlbody + '<p></p>' + html def attach(self, msg): for f in self.attachments: ctype, encoding = mimetypes.guess_type(f) if ctype is None or encoding is not None: ctype = \"application/octet-stream\" maintype, subtype = ctype.split(\"/\", 1) if maintype == \"text\": fp = open(f) # Note: we should handle calculating the charset attachment = MIMEText(fp.read(), _subtype=subtype) fp.close() elif maintype == \"image\": fp = open(f, \"rb\") attachment = MIMEImage(fp.read(), _subtype=subtype) fp.close() elif maintype == \"ppt\": fp = open(f, \"rb\") attachment = MIMEApplication(fp.read(), _subtype=subtype) fp.close() elif maintype == \"audio\": fp = open(f, \"rb\") attachment = MIMEAudio(fp.read(), _subtype=subtype) fp.close() else: fp = open(f, \"rb\") attachment = MIMEBase(maintype, subtype) attachment.set_payload(fp.read()) fp.close() encoders.encode_base64(attachment) attachment.add_header(\"Content-Disposition\", \"attachment\", filename=f) attachment.add_header('Content-ID', '<{}>'.format(f)) msg.attach(attachment) def addattach(self, files): self.attachments = self.attachments + files # example below if __name__ == '__main__': # subject and recipients mymail = Bimail('Sales email ' + datetime.now().strftime('%Y/%m/%d'), ['[email protected]', '[email protected]']) # start html body. Here we add a greeting. mymail.htmladd('Good morning, find the daily summary below.') # Further things added to body are separated by a paragraph, so you do not need to worry about newlines for new sentences # here we add a line of text and an html table previously stored in the variable mymail.htmladd('Daily sales') mymail.addattach(['htmlsalestable.xlsx']) # another table name + table mymail.htmladd('Daily bestsellers') mymail.addattach(['htmlbestsellertable.xlsx']) # add image chart title mymail.htmladd('Weekly sales chart') # attach image chart mymail.addattach(['saleschartweekly.png']) # refer to image chart in html mymail.htmladd('<img src=\"cid:saleschartweekly.png\"/>') # attach another file mymail.addattach(['MailSend.py']) # send! mymail.setup_mail_client( domain_key_to_use=\"GMAIL\",email_servers_domains_dict=smtp_server_domain_names)"
    },
    {
        "link": "https://sendlayer.com/blog/how-to-send-an-email-with-python",
        "document": "Editorial Note: We may earn a commission when you visit links on our website.\n\nSimple Mail Transmission Protocol (SMTP) is a service email providers use to send emails online. Transactional email services like SendLayer provide an SMTP server (smtp.sendlayer.net) that can be used to send emails through third-party software or programmatically.\n\nHow to Send an Email With Python\n\nIn this section, I’ll show you the 2 ways to send emails in Python.\n\nBelow are some requirements you’ll need to meet to follow along with this guide:\n• Python installed on your machine. I’m using Python version 3.x and I recommend using it as well. Download the latest Python version 3 here\n• A SendLayer account. You can get started with the trial account that lets you send up to 200 emails for free\n\nAfter creating your SendLayer account, make sure to authorize your domain. This step is essential to improve your site’s email deliverability. With that, you’re all set up and ready to send your first email in Python.\n\nHow to Send an Email With SMTP in Python\n\nPython’s library allows you to send emails using an SMTP server. I’ll use SendLayer’s SMTP server in this guide.\n\nHowever, the steps are similar for the Gmail SMTP server or any other SMTP server you intend to use.\n\nTo get started with SendLayer, you’ll need to access the login credentials for your SMTP account.\n\nFor this, log in to your SendLayer account and select the Settings sidebar menu. Then select the SMTP Credentials tab.\n\nYou’ll see the SMTP credentials required to use SendLayer’s SMTP server. The Host and Port number are the same for all users. However, the Username and Password details are unique to your SendLayer account.\n\nYou can leave this browser tab open to access the SMTP server details easily.\n\nAfter you’ve gotten the SMTP credentials, you’re ready to start sending emails in your Python app. To do so, create a new Python script or open an existing file in your project.\n\nThe first step is to import the library.\n\nNext, I’ll create an SMTP instance using the library we just imported.\n\nThe server variable is where we establish the connection between SendLayer and the Python script. The 2 arguments we specified in the function correspond to the SMTP Host and Port number SendLayer provides.\n\nAfter initiating the connection, we’ll need to secure it through TLS (Transport Layer Security). This protocol encrypts the connection between your script and SendLayer’s SMTP server.\n\nNext, we’ll authenticate the connection using the SMTP login details. Recall that I asked you to keep the browser tab with your SendLayer SMTP details open. You’ll need the username and password now.\n\nEnsure you replace username and password in the snippet above with your actual SMTP login credentials.\n\nThe final step is where we send the actual email using the function. This function accepts 3 arguments: sender’s email, recipient’s email, and email message.\n\nPutting it all together:\n\nI added a print statement to the code that’ll notify us when running the code if the email was sent successfully.\n\nTo test the code, open a terminal window and run the command below\n\nemail_script.py should correspond to the file name where you added the script. After running the script, you should receive an email in the recipient’s inbox.\n\nThe implementation above works great if you only intend to send plain text emails. However, modern emails include HTML content like bolded text, images, buttons, links, etc.\n\nTo send such emails, you’ll need to use the HTML syntax within the email message. Fortunately, Python’s library lets you format emails to support HTML syntax.\n\nIn the snippet above, we’re importing the and classes from the library. The class allows us to specify the different components of an email like the subject, sender address, recipient address, etc.\n\nWe use the method to specify the format for the email message. It accepts 2 arguments: message and format.\n\nThe message is the actual HTML message you intend to send, corresponding to the html_message variable in the code above. The format we specified is “html”. You can use “plain” if you’d like to send a plain text message.\n\nWhen you run the snippet above, it should send the email message with the email subject and HTML content properly formatted.\n\nPython’s email library supports sending emails to multiple recipients by default. Once you specify the recipient email addresses in a list, the method will auto-detect each email address and send the mail to the recipients.\n\nThe only drawback to this approach is that emails are sent as a whole. This essentially means the process will complete when the script has looped through the list of recipients. It might also take a while if you have a large list of recipients.\n\nHere’s the snippet for this implementation.\n\nIn the code above, I’ve created a list with each recipient’s email and stored the value in the receiver_emails variable.\n\nNext, I combined the list into a single string and separated each email address with a comma. This step is essential to ensure the recipient header in the email message is populated with all the email recipients.\n\nThe function will loop through the list and send the email to each recipient.\n\nYou can also add attachment files to your emails before sending them out. For this, we’ll need the class and the function from the library. I’ve gone ahead to add the import statement below to your code.\n\nHere is the full code snippet to handle attachment files in email messages.\n\nIn the snippet above, we use the class to specify the attachment type. Setting it to means it’s a generic file and works for all file formats. Email clients will read it as an attachment file.\n\nAttachment files need to be encoded in base64 to ensure it is properly transmitted. The line handles that.\n\nNext, we’re including the attachment file in the email header so email clients know to treat it as an attachment using the function.\n\nFinally, we add the attachment to the message so it’s included in the mail using the function.\n\nWhen you test the implementation, you should see the file attached to the email message.\n\nSending emails through SMTP works well for smaller projects. However, it is less secure and slower when compared to using an API-based email provider. Using an API-based service is also much faster especially when you need to send bulk emails.\n\nFortunately, platforms like SendLayer provide API endpoints you can use to send single and bulk emails programmatically. I’ll show you how to set up a program that uses the SendLayer email API to send emails.\n\nTo get started, open your terminal and run the command below to install requests (if not installed already).\n\nAfter installing the library, create a new Python file (you can use any name), just make sure to use the .py file extension. For this tutorial, I’ve named mine as .\n\nNow, open the file you just created and add the following import statement.\n\nThe requests library is used to send requests to an API endpoint. For instance, sending a post request to the email endpoint will trigger the email-sending event.\n\nSince most API requests are sent in JSON format, we’ll use the library we imported to translate the request into a format Python understands.\n\nTo send an email using SendLayer API, you’ll need 3 parameters:\n• URL: This is the API endpoint for sending emails. For SendLayer, this endpoint is available at\n• Headers: This is where you’ll define the format for the request and also authenticate your connection\n• Payload: This contains the actual JSON requests with details for sending an email like the sender and recipient email address.\n\nLet’s proceed to use the API endpoint to send an email. For this, copy and paste the code snippet below. I’ll explain what each line does afterward.\n\nIn the snippet above, we’ve defined a function that accepts one parameter, . The payload variable contains the JSON request with the email message.\n\nWithin the function, we specify the and variable. The url variable is SendLayer’s endpoint for sending emails. In the block, we define the Authorization and Content-Type. You’ll need to replace with your actual API key.\n\nTo get your API key, log in to your SendLayer account. Once you’re logged in, click the Settings menu and select the API Keys tab.\n\nThen click the copy icon next to Default API key to copy it.\n\nThe line of code is where we send the actual post request. The post function accepts 3 parameters; url, headers, and data. The data contains details about the email message. This is usually in JSON format, but we’re using to translate it to a Python command.\n\nThe return statement for the function is response.text. Which will print a message in the console about our email status.\n\nIn the payload variable, I’ve specified the JSON format for the email I intend to send. You’ll need to update the name and email address in the “From” field to match your sender email.\n\nAlso, update the name and email in the “To” field to match the recipient’s name and email.\n\nTo run this code, open a terminal window and run the command below.\n\nYou should see a message similar to the one below logged in the terminal.\n\nWhen you open the email inbox of the recipient, you’ll see the email message we just sent out.\n\nWith SendLayer’s API, you can send emails to multiple recipients from your Python script. To do so, you’ll just need to add to the objects in the “To” list in the JSON payload. Here is an example:\n\nUsing the “CC” and “BCC” Fields\n\nSendLayer also lets you add more recipients using the Cc and Bcc feature email servers support. To use this, simply add the “CC” and “BCC” fields to the JSON payload. Within each field, add the recipients’ email address object which should be similar to the objects in the “To” field. Here is an example snippet:\n\nSendLayer’s email API supports adding attachments to email messages. To attach files to your emails, you’ll need to encode them to base64, which is a format email services understand. Here’s how to attach files using SendLayer API:\n\nAfter that, I’ll create a function to handle decoding the attachment files.\n\nThe function above accepts one parameter, which is the file path. Within the function, we’re reading the file and then using the base64 library to encode it.\n\nAfter adding the function, update the payload field to include the “Attachments” field as seen in the snippet below.\n\nThe “Content” field contains the base64 string of the attachment file. We get the decoded value from the function. Make sure to update the function’s argument with the path to your attachment file.\n\nYou can add multiple attachment files to the list. Simply create a new key-value pair within the “Attachments” list.\n\nIn the code above, I only included the payload variable. The complete snippet should also contain the function.\n\nWhen you run the script, both attachments should be included in the email message.\n\nBest Practices For Sending Emails Using Python\n\nIf the project you’re working on is an enterprise application, there are security considerations to keep in mind. Below, I’ll share some tips to optimize your Python application.\n\nDetails such as API keys, SMTP username and password should be personal and not shared with the general public. If your codebase is public, it’ll be easy for attackers to access sensitive details.\n\nHere’s how to use environment variables to store server details in Python:\n\nFirst, create a file in your project’s root directory. Inside this file, you’ll need to store the server details as variables:\n\nThe next step is to install the library for Python. To do so, run the command below in your terminal window:\n\nOnce you’ve installed the library, you’re ready to load the .env file to your main project file. Here’s how to do it:\n\nIn the code above, we’re importing the built-in module and the library we just installed. After that update the send email function to read the values from the environment variable we created.\n\nThe rest of the code should remain unchanged.\n\nOne drawback to our current implementation is that there is no way to know the exact cause if an email isn’t sent to the recipient(s).\n\nTo account for such issues, we need to implement an error-handling mechanism to know why emails fail to deliver. I’ll use the try-except syntax in Python to implement the checks.\n\nIn the code snippet above, I added the try and except block to catch errors as they occur. Within the try block, we’re checking to see if the status code for the request is 200 (which indicates the request was successful).\n\nOtherwise, we want to print out a response to let the user know their email hasn’t been delivered. Here is an example of an error you might encounter:\n\nThe error above indicates your email failed due to an invalid API key. If you encounter this error make sure to replace the API key placeholder with your actual SendLayer API key.\n\nThese are answers to some of the top questions we see on how to send emails using Python."
    },
    {
        "link": "https://python.readthedocs.io/fr/hack-in-language/library/email-examples.html",
        "document": "Here are a few examples of how to use the package to read, write, and send simple email messages, as well as more complex MIME messages.\n\nFirst, let’s see how to create and send a simple text message:\n\nAnd parsing RFC822 headers can easily be done by the parse(filename) or parsestr(message_as_string) methods of the Parser() class:\n\nHere’s an example of how to send a MIME message containing a bunch of family pictures that may be residing in a directory:\n\nHere’s an example of how to send the entire contents of a directory as an email message:\n\n\"\"\"Send the contents of a directory as a MIME message.\"\"\" Send the contents of a directory as a MIME message. Unless the -o option is given, the email is sent by forwarding to your local \"\"\"Mail the contents of the specified directory, files in the directory are sent, and we don't recurse to \"\"\"Print the composed message to FILE instead of sending the message to the SMTP server.\"\"\" 'The value of the From: header (required)' 'A To: header value (at least one required)' 'You will not see this in a MIME-aware mail reader. # Guess the content type based on the file's extension. Encoding # will be ignored, although we should check for simple things like # No guess could be made, or the file is encoded (compressed), so\n\nHere’s an example of how to unpack a MIME message like the one above, into a directory of files:\n\nHere’s an example of how to create an HTML message with an alternative plain text version:\n\n# Create the body of the message (a plain-text and an HTML version). Here is the <a href=\"https://www.python.org\">link</a> you wanted. # Record the MIME types of both parts - text/plain and text/html. # According to RFC 2046, the last part of a multipart message, in this case # the HTML message, is best and preferred. # and message to send - here it is sent as one string.\n\nHere is a reworking of the last example using the provisional API. To make things a bit more interesting, we include a related image in the html part, and we save a copy of what we are going to send to disk, as well as sending it. This example also shows how easy it is to include non-ASCII, and simplifies the sending of the message using the method of the module. \"Ayons asperges pour le déjeuner\" # Add the html version. This converts the message into a multipart/alternative # container, with the original text message as the first part and the new html # note that we needed to peel the <> off the msgid for use in the html. # Now add the related image to the html part. # Make a local copy of what we are going to send. If we were instead sent the message from the last example, here is one way we could process it: # An imaginary module that would make this work and be safe. # In a real program you'd get the filename from the arguments. # Now the header items can be accessed as a dictionary, and any non-ASCII will # If we want to print a priview of the message content, we can extract whatever # the least formatted payload is and print the first three lines. Of course, # if the message has no plain text part printing the first three lines of html # is probably useless, but this is just a conceptual example. # We can extract the richest alternative in order to display it: # again strip the <> to go from email form of cid to html form. # The magic_html_parser has to rewrite the href=\"cid:....\" attributes to # point to the filenames in partfiles. It also has to do a safety-sanitize # of the html. It could be written using html.parser. # Of course, there are lots of email messages that could break this simple # minded program, but it will handle the most common ones. Up to the prompt, the output from the above is: To: Penelope Pussycat <\"penelope@example.com\">, Fabrette Pussycat <\"fabrette@example.com\"> From: Pepé Le Pew <pepe@example.com> Subject: Ayons asperges pour le déjeuner Salut! Cela ressemble à un excellent recipie[1] déjeuner."
    }
]