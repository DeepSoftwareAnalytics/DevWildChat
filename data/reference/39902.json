[
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/core/extensions/workers",
        "document": "There are numerous reasons for creating long-running services such as:\n\nBackground service processing usually doesn't involve a user interface (UI), but UIs can be built around them. In the early days with .NET Framework, Windows developers could create Windows Services for these purposes. Now with .NET, you can use the BackgroundService, which is an implementation of IHostedService, or implement your own.\n\nWith .NET, you're no longer restricted to Windows. You can develop cross-platform background services. Hosted services are logging, configuration, and dependency injection (DI) ready. They're a part of the extensions suite of libraries, meaning they're fundamental to all .NET workloads that work with the generic host.\n\nMany terms are mistakenly used synonymously. This section defines some of these terms to make their intent in this article more apparent.\n• Hosted Service: Implementations of IHostedService, or the IHostedService itself.\n• Windows Service: The Windows Service infrastructure, originally .NET Framework-centric but now accessible via .NET.\n\nThe Worker Service template is available in the .NET CLI and Visual Studio. For more information, see .NET CLI, - template. The template consists of a and class.\n• Calls AddHostedService to register the as a hosted service.\n• Builds an IHost from the builder.\n• Calls on the instance, which runs the app.\n\nThe Worker template doesn't enable server garbage collection (GC) by default, as there are numerous factors that play a role in determining its necessity. All of the scenarios that require long-running services should consider performance implications of this default. To enable server GC, add the node to the project file:\n\nFor more information regarding performance considerations, see Server GC. For more information on configuring server GC, see Server GC configuration examples.\n\nAs for the , the template provides a simple implementation.\n\nThe preceding class is a subclass of BackgroundService, which implements IHostedService. The BackgroundService is an and requires the subclass to implement BackgroundService.ExecuteAsync(CancellationToken). In the template implementation, the loops once per second, logging the current date and time until the process is signaled to cancel.\n\nThe Worker template relies on the following project file :\n\nFor more information, see .NET project SDKs.\n\nAn app based on the Worker template uses the SDK and has an explicit package reference to the Microsoft.Extensions.Hosting package.\n\nWith most modern .NET workloads, containers are a viable option. When creating a long-running service from the Worker template in Visual Studio, you can opt in to Docker support. Doing so creates a Dockerfile that containerizes your .NET app. A Dockerfile is a set of instructions to build an image. For .NET apps, the Dockerfile usually sits in the root of the directory next to a solution file.\n• Setting the base image from as the alias .\n• Setting the alias from the image.\n• Copying the contents and publishing the .NET app:\n• The app is published using the command.\n• Relayering the .NET SDK image from (the alias).\n• Copying the published build output from the /publish.\n• Defining the entry point, which delegates to .\n\nWhen you target Docker as a deployment strategy for your .NET Worker Service, there are a few considerations in the project file:\n\nIn the preceding project file, the element specifies as its target. To target Windows containers, use instead. The NuGet package is automatically added as a package reference when Docker support is selected from the template.\n\nFor more information on Docker with .NET, see Tutorial: Containerize a .NET app. For more information on deploying to Azure, see Tutorial: Deploy a Worker Service to Azure.\n\nThese two methods serve as lifecycle methods - they're called during host start and stop events respectively.\n\nIn most common scenarios, you don't need to explicitly signal the completion of a hosted service. When the host starts the services, they're designed to run until the host is stopped. In some scenarios, however, you may need to signal the completion of the entire host application when the service completes. To signal the completion, consider the following class:\n\nIn the preceding code, the method doesn't loop, and when it's complete it calls IHostApplicationLifetime.StopApplication().\n\nFor more information, see:\n• BackgroundService subclass tutorials:\n• Use scoped services within a in .NET"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/core/extensions/windows-service",
        "document": ".NET Framework developers are probably familiar with Windows Service apps. Before .NET Core and .NET 5+, developers who relied on .NET Framework could create Windows Services to perform background tasks or execute long-running processes. This functionality is still available and you can create Worker Services that run as a Windows Service.\n\nIn this tutorial, you'll learn how to:\n• The .NET 8.0 SDK or later\n\nTo create a new Worker Service project with Visual Studio, you'd select File > New > Project.... From the Create a new project dialog search for \"Worker Service\", and select Worker Service template. If you'd rather use the .NET CLI, open your favorite terminal in a working directory. Run the command, and replace the with your desired project name.\n\nFor more information on the .NET CLI new worker service project command, see dotnet new worker.\n\nTo interop with native Windows Services from .NET IHostedService implementations, you'll need to install the NuGet package.\n\nTo install this from Visual Studio, use the Manage NuGet Packages... dialog. Search for \"Microsoft.Extensions.Hosting.WindowsServices\", and install it. If you'd rather use the .NET CLI, run the command:\n\nFor more information on the .NET CLI add package command, see dotnet add package.\n\nAfter successfully adding the packages, your project file should now contain the following package references:\n\nThis worker project makes use of C#'s nullable reference types. To enable them for the entire project, update the project file accordingly:\n\nThe preceding project file changes add the node. For more information, see Setting the nullable context.\n\nAdd a new class to the project named JokeService.cs, and replace its contents with the following C# code:\n\nThe preceding joke service source code exposes a single piece of functionality, the method. This is a returning method that represents a random programming joke. The class-scoped field is used to store the list of jokes. A random joke is selected from the list and returned.\n\nReplace the existing from the template with the following C# code, and rename the file to WindowsBackgroundService.cs:\n\nIn the preceding code, the is injected along with an . Both are made available to the class as fields. In the method, the joke service requests a joke and writes it to the logger. In this case, the logger is implemented by the Windows Event Log - Microsoft.Extensions.Logging.EventLog.EventLogLoggerProvider. Logs are written to, and available for viewing in the Event Viewer.\n\nReplace the template Program.cs file contents with the following C# code:\n\nThe extension method configures the app to work as a Windows Service. The service name is set to . The hosted service is registered for dependency injection.\n\nFor more information on registering services, see Dependency injection in .NET.\n\nTo create the .NET Worker Service app as a Windows Service, it's recommended that you publish the app as a single file executable. It's less error-prone to have a self-contained executable, as there aren't any dependent files lying around the file system. But you may choose a different publishing modality, which is perfectly acceptable, so long as you create an *.exe file that can be targeted by the Windows Service Control Manager.\n\nThe preceding highlighted lines of the project file define the following behaviors:\n• : Specify the target platform CPU of 64-bit.\n\nTo publish the app from Visual Studio, you can create a publish profile that is persisted. The publish profile is XML-based and has the .pubxml file extension. Visual Studio uses this profile to publish the app implicitly, whereas if you're using the .NET CLI, you must explicitly specify the publish profile for it to be used.\n\nRight-click on the project in the Solution Explorer, and select Publish. Then, select Add a publish profile to create a profile. From the Publish dialog, select Folder as your Target.\n\nLeave the default Location, and then select Finish. Once the profile is created, select Show all settings, and verify your Profile settings.\n\nEnsure that the following settings are specified:\n\nFinally, select Publish. The app is compiled, and the resulting .exe file is published to the /publish output directory.\n\nAlternatively, you could use the .NET CLI to publish the app:\n\nFor more information, see .\n\nIf you're unfamiliar with using PowerShell and you'd rather create an installer for your service, see Create a Windows Service installer. Otherwise, to create the Windows Service, use the native Windows Service Control Manager's (sc.exe) create command. Run PowerShell as an Administrator.\n\nFor more information, see sc.exe create.\n\nAfter the service is created, you can optionally configure it. If you're fine with the service defaults, skip to the Verify service functionality section.\n\nWindows Services provide recovery configuration options. You can query the current configuration using the (where is your services' name) command to read the current recovery configuration values:\n\nThe command will output the recovery configuration, which is the default values—since they've not yet been configured.\n\nTo configure recovery, use the where is the name of your service:\n\nAfter it's been successfully configured, you can query the values once again using the command:\n\nYou will see the configured restart values.\n\nWith .NET 6, new hosting exception-handling behaviors have been added to .NET. The BackgroundServiceExceptionBehavior enum was added to the namespace, and is used to specify the behavior of the service when an exception is thrown. The following table lists the available options:\n\nThe default behavior before .NET 6 is , which resulted in zombie processes (a running process that didn't do anything). With .NET 6, the default behavior is , which results in the host being stopped when an exception is thrown. But it stops cleanly, meaning that the Windows Service management system will not restart the service. To correctly allow the service to be restarted, you can call Environment.Exit with a non-zero exit code. Consider the following highlighted block:\n\nTo see the app created as a Windows Service, open Services. Select the Windows key (or + ), and search from \"Services\". From the Services app, you should be able to find your service by its name.\n\nTo verify that the service is functioning as expected, you need to:\n\nTo start the Windows Service, use the command:\n\nYou'll see output similar to the following:\n\nThe service Status will transition out of to Running.\n\nTo view logs, open the Event Viewer. Select the Windows key (or + ), and search for . Select the Event Viewer (Local) > Windows Logs > Application node. You should see a Warning level entry with a Source matching the apps namespace. Double-click the entry, or right-click and select Event Properties to view the details.\n\nAfter seeing logs in the Event Log, you should stop the service. It's designed to log a random joke once per minute. This is intentional behavior but is not practical for production services.\n\nTo stop the Windows Service, use the command:\n\nYou'll see output similar to the following:\n\nThe service Status will transition from to Stopped.\n\nTo delete the Windows Service, use the native Windows Service Control Manager's (sc.exe) delete command. Run PowerShell as an Administrator.\n\nFor more information, see sc.exe delete."
    },
    {
        "link": "https://telerik.com/blogs/getting-started-worker-services",
        "document": "Learn what Worker Services are and where they are commonly used, and then we’ll create a Worker Service project in .NET 6 from scratch to see one in practice.\n\nIn many situations, you need to perform background tasks such as status checks and cleaning up old data. To make these tasks easier, we can create a Worker Service that will run at a time interval and do the workloads it was configured for.\n\nLearn in this post what Worker Services are and how to implement them in .NET 6.\n\nWorker Services are a type of application that can be configured to run in the background according to the pre-defined execution interval, which can be short-term or long-term.\n\nA Worker Service project in .NET is built using a template that provides some useful resources, such as the host that is responsible for maintaining the application’s lifespan. In addition, the host also provides functions such as registration, dependency injection and configuration.\n\nPreviously called Windows Service, it was restricted to Windows only. But with the creation of Worker Services, this limitation no longer exists—you can develop cross-platform background services.\n\nWhere Can We Use Worker Services?\n\nThe use of Worker Services is very common, as it allows the scheduling of tasks so we don’t have to worry about manually notifying a service, we can create a worker to work for us, just informing us of its beginning and end of execution.\n\nBelow are some scenarios where using workers is the best option:\n• Reacting to changes to an entity\n\nThese are just a few examples of using workers, but there are many other scenarios where we can use workers to automate processes.\n\nNext, we will create a Worker Service in .NET 6 from scratch. This worker will run every 30 seconds and, when it starts, it will fetch user data from an external API and check if these users exist in the local database. If they do not exist, they will be inserted; if they already exist, it will only display a log that no new records were found to be added. All processing will be displayed through logs, in the beginning, middle and end.\n\nYou can access the complete source code of the project at this link.\n\nYou need to add the project dependencies—either directly in the project code “UserEqualizerWorkerService.csproj” or by downloading NuGet Packages:\n• Type “worker” in the search bar, and choose the option “C# Worker Service”\n• Name the project (“UserEqualizerWorkerService” is suggested)\n\nIn this tutorial, fake data from a public API will be used. The official website is Json Place Holder.\n\nNext, let’s create two main entities—the entity responsible for receiving data from the API (PlaceHolderUser) and the entity that will represent the database table (User), which we will create later.\n\nSo, create a new folder called “Models” and inside, create a new folder “PlaceHolder.” Inside that, add the class below:\n\nNow inside the “Models” folder add the class below:\n\nThe context class will be used to communicate with the database through Entity Framework Core features.\n\nSo, create a new folder called “Data” and inside it create the class below:\n\nNext, let’s create the class that will fetch the list of users in the fake API. So inside the “Data” folder, create a new folder called “Api” and inside it create the class below:\n\nThe service class will contain the worker’s business rules. It will access the API layer, get the users in the external API, check if these users already exist in the database and if they don’t, they will be added and so both places will be equalized.\n\nSo, create a new folder called “Services” and inside a new folder “v1” and inside it add the class below:\n\nIn the Program.cs archive, above setting “services.AddHostedService();” add the following code:\n\nFor the PlaceHolderClient class, a BaseAddress is created that receives the URL from the external JsonPlaceHolder API. So when we invoke the users get method in the PlaceHolderClient class, we just pass the end of the URL, in this case “/users”.\n\nFinally, replace the contents of the “Worker.cs” file with the following code:\n\nThe code above executes the method of the service class that we just created. If an error occurs in the processing, an error message will be logged; otherwise, a success message.\n\nThe “await Task.Delay(30000, stoppingToken)” method is used to set the timeout for each worker execution. The expected value is in milliseconds, so 30000 milliseconds is equivalent to half a minute, which means our worker will run every 30 seconds. This value is configurable and will depend on each scenario.\n\nBefore running the application and seeing how it works in practice, we need to create the database with EF Core commands.\n\nTo run the EF Core commands, the .NET CLI tools must be installed. Otherwise, the commands will result in an error.\n\nThe first command will create a migration called InitialModel and the second will have EF create a database and schema from the migration.\n\nMore information about Migrations is available in Microsoft’s official documentation.\n\nYou can run the commands below in a project root terminal.\n\nAlternatively, run the following commands from the Package Manager Console in Visual Studio:\n\nIf you followed all the steps above, the worker is ready to run.\n\nOn the first run, the worker will fetch the list of users from the external API and check if these users exist in the database. As the database is still empty, they will be inserted, equalizing the two environments.\n\nThe image below shows the runtime logs from start to finish.\n\nOn the second run, the worker will check if the users already exist and then just log a message that there were no new users to add.\n\nWorker Services are a great tool for automating processes—after all, they can do the work without the need for a trigger. Just set a break time, and it will do everything else itself.\n\nIn this article, we saw an introduction to Worker Services and developed a working application using the Worker Service template available in .NET 6, which uses very common approaches in everyday life such as recording in a database and requests to an external API. If you want to delve deeper into Worker Services, I suggest reading the official Microsoft documentation on Workers."
    },
    {
        "link": "https://medium.com/@leventozturk/net-6-worker-service-a29ba610edff",
        "document": "In today’s article, I want to introduce you to the Worker Service feature that came with .NET 6 and briefly explain what you can do. Let’s get started!\n\nWith the release of .NET 6, Microsoft introduced the Worker Service feature, which offers a lightweight and efficient way to build long-running background services. In this article, we will dive into the capabilities and usage of Worker Service, highlighting its advantages over traditional Windows Services. We will explore the key concepts, methods, and scenarios where Worker Service shines to illustrate its usage.\n\nWorker Service and Its Use Cases\n\nWorker Service is a versatile tool suitable for various scenarios where you need to perform background tasks or process data continuously. Let’s look at a few common use cases:\n\nWorker Service brings significant improvements over traditional Windows Services, such as: Simplicity and lightweight: Worker Service simplifies the development and deployment process by providing a more lightweight and modern framework. Cross-platform support: Worker Service works seamlessly on Windows, Linux, and macOS, making it an ideal choice for multi-platform development. You can write your Worker Service once and run it on various operating systems.\n\nWorker Service follows a pattern where the execution logic is written within a background worker class inheriting from the base class. Let's explore the methods:\n• : This method contains the main execution logic of the Worker Service. It is an asynchronus method where you can write the code for processing tasks.\n• and : These methods handle the service startup and gently shutdown, allowing you to perform any necessary intialization or cleanup operations.\n\nThe lifetime of Worker Service is set as Singleton. Therefore, if you register a Transient or Scoped service to this service, you will get an error. There is a Microsoft article for you to solve this error.\n\nTo summarize briefly, an instance is obtained in the IServiceScope object using the “using block” and the instance of the requested service is obtained using the method. Like this:\n\nTry-catch block can be used to catch and log errors. You can take action against all errors you may encounter by using an exception middleware for errors you will receive in the services you call in Worker Service.\n\nYou can integrate Worker Service with the Quartz library for advanced job scheduling capabilities, including running jobs at specific times of the day. Here is an example of using Quartz within a worker service for such a scenario:\n\nYou can check the Cron Triggers page of the Quartz library to learn more about these schedules.\n\nThat’s all I have to say in this article. What you can do with worker service can vary a lot depending on your needs and imagination. Ijust wanted to help you open this door. Thank you for reading."
    },
    {
        "link": "https://adnanrafiq.com/blog/complete-guide-to-hosted-or-background-or-worker-services-in-dot-net-using-csharp",
        "document": "The word Host will repeatedly appear in the post so let's briefly understand what it means?\n\nThe Host is a container which offers rich built-in services such as Dependency Injection, Configuration, Logging, Host Services and others. The NET 6 offers Generic DefaultHost which can be configured to handle the activities as per your use case. Two major variations of the Host are:\n\nThink of it as Airbnb Host who keeps the property ready to serve when the guests arrive. The property offers a different set of services and allows you to bring your own services. The lifetime of such services depends upon the contract, which the Host controls.\n\nA service that performs the work in the background mostly does not offer an interface to interact. In technical terms, any reference type object which implements the interface is a background/hosted/worker service.\n\nTerms such as Worker, Windows Service, and Background Task refer to HostedService based on context. In Windows Server, Widows Service is how you deploy a Hosted Service. Background Task or Hosted service runs as part of .NET Web Host, and it runs in the same operating system process.\n\nThere are two flavors of Hosted Service and abstract BackgroundService calls from ; let's explore these 3 things below below:\n\nis an abstract class, and implements . The encapsulates the implementation of , , creation of and disposal of resources. In other words, it is an excellent example of the Template Method Pattern.\n\nThe ExecuteAsync is an abstract method which will be called when the hosted service starts with the CancellationToken, which offers us to complete our work when Token cancellation is not requested. The cancellation can happen if you press ctrl + c or if the Host decides to stop the Hosted Services gracefully.\n\nThe completion of method means that the service has finished its work.\n\n So if the requirement is to poll continuously, then use the infinite loop until token is cancelled, for example, processing the messages from the queue as they arrive.\n\nWorker Process is an independent deployable .NET package. You can create worker process using .NET CLI command with default template. You will find the following code in .\n\nadds the Hosted Service to the collection of the Host Services as Singleton. Since it implements IHostedService interface, the Host knows how to start it and gracefully shutdown if required.\n\nYou will find the following code in .\n\nThe inherits from which is abstract class, and implements . We have already explored about BackgroundService above. Notice the infinite while loop until token is cancelled, we can keep doing the work. The worker is useful in the following use cases but not limited to:\n\nASP.NET hosted service implements the interface. It is different from the worker process only where it resides in memory, and it's part of the ASP.NET webserver process, which means it can access the memory of the process. Sharing the same process memory makes it very powerful because it can manipulate objects in the memory space.\n\nThe ASP.NET Hosted Service is useful in the following use cases but not limited to:\n• Listening to messages from the queue.\n\nObservability is about telling how service is performing the given task from the outside. Logs are an excellent way to make a running process observable, offers extension points to achieve it.\n\nResiliency is about making the service tolerant to failure and recovery from failure. Configuring the HostOptions related to the Hosted Service allows it.\n\nThe Host provides service which allows consumers to listen to changes in lifetime of the Hosted Services and stop the hosted service programmatically. You can inject into the Hosted Service constructor and register a callback function to listen to those events and take appropriate action such as logging. An example of how to log these events in the Hosted Service is below.\n\nDefault graceful stop time is 5 seconds. If the Hosted Service requires more than 5 seconds to complete the in-progress work, then you can extend it by setting the ShutdownTimeout value.\n\nIf an unhandled exception occurs in the Hosted Service implementation, it will stop the Host, which might not be desirable, depending on your context. You can override it by setting the BackgroundServiceExceptionBehavior value.\n\nadds a Singleton Instance of Worker to the default .NET DI Container which means any scoped service injected into the constructor of Worker will also be Singleton.\n\nIf your use case involves using a scoped type instance of any object, you will have to access the Instance using IServiceProvider. An example is below.\n\nIf the Host contains multiple hosted services, it will start those services serially in order they are registered, but stops will happen in reverse order serially. It can be essential to control the gracefully shut time behavior & how these services will stop so that business operation does not end up inconsistent.\n\nConsider, a hosted service is writing to a channel, and another hosted service is reading from that channel. If writer service is registered first, then it will stop last. It means the writer service may have written some data to channel, while there is no reader to read it. So when using multiple hosted services using shared memory data, consider the order of their registration.\n\n Let's explore a quick example below:\n\nThe Hosted Service exceptions can stop the Host, which is not desirable in ASP.NET. I encourage you to handle exceptions and unwrap the so you can diagnose using logs.\n\nHow .NET WebHost start hosted service can be seen in source code on GitHub. ASP.NET Core uses few hosted services. Below are few examples to peak your curiosity.\n\nThe .NET is a cross-platform, open-source developer platform. Thus Hosted Service can be deployed as a Windows Service on Windows Server, for other Operating System's you can use Docker.\n\nI am running an experiment to make few bucks and take it more seriously. If you curious follow the link? Would you Buy It, NO?\n\nI would love to hear your feedback, feel free to share it on Twitter."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/core/extensions/windows-service",
        "document": ".NET Framework developers are probably familiar with Windows Service apps. Before .NET Core and .NET 5+, developers who relied on .NET Framework could create Windows Services to perform background tasks or execute long-running processes. This functionality is still available and you can create Worker Services that run as a Windows Service.\n\nIn this tutorial, you'll learn how to:\n• The .NET 8.0 SDK or later\n\nTo create a new Worker Service project with Visual Studio, you'd select File > New > Project.... From the Create a new project dialog search for \"Worker Service\", and select Worker Service template. If you'd rather use the .NET CLI, open your favorite terminal in a working directory. Run the command, and replace the with your desired project name.\n\nFor more information on the .NET CLI new worker service project command, see dotnet new worker.\n\nTo interop with native Windows Services from .NET IHostedService implementations, you'll need to install the NuGet package.\n\nTo install this from Visual Studio, use the Manage NuGet Packages... dialog. Search for \"Microsoft.Extensions.Hosting.WindowsServices\", and install it. If you'd rather use the .NET CLI, run the command:\n\nFor more information on the .NET CLI add package command, see dotnet add package.\n\nAfter successfully adding the packages, your project file should now contain the following package references:\n\nThis worker project makes use of C#'s nullable reference types. To enable them for the entire project, update the project file accordingly:\n\nThe preceding project file changes add the node. For more information, see Setting the nullable context.\n\nAdd a new class to the project named JokeService.cs, and replace its contents with the following C# code:\n\nThe preceding joke service source code exposes a single piece of functionality, the method. This is a returning method that represents a random programming joke. The class-scoped field is used to store the list of jokes. A random joke is selected from the list and returned.\n\nReplace the existing from the template with the following C# code, and rename the file to WindowsBackgroundService.cs:\n\nIn the preceding code, the is injected along with an . Both are made available to the class as fields. In the method, the joke service requests a joke and writes it to the logger. In this case, the logger is implemented by the Windows Event Log - Microsoft.Extensions.Logging.EventLog.EventLogLoggerProvider. Logs are written to, and available for viewing in the Event Viewer.\n\nReplace the template Program.cs file contents with the following C# code:\n\nThe extension method configures the app to work as a Windows Service. The service name is set to . The hosted service is registered for dependency injection.\n\nFor more information on registering services, see Dependency injection in .NET.\n\nTo create the .NET Worker Service app as a Windows Service, it's recommended that you publish the app as a single file executable. It's less error-prone to have a self-contained executable, as there aren't any dependent files lying around the file system. But you may choose a different publishing modality, which is perfectly acceptable, so long as you create an *.exe file that can be targeted by the Windows Service Control Manager.\n\nThe preceding highlighted lines of the project file define the following behaviors:\n• : Specify the target platform CPU of 64-bit.\n\nTo publish the app from Visual Studio, you can create a publish profile that is persisted. The publish profile is XML-based and has the .pubxml file extension. Visual Studio uses this profile to publish the app implicitly, whereas if you're using the .NET CLI, you must explicitly specify the publish profile for it to be used.\n\nRight-click on the project in the Solution Explorer, and select Publish. Then, select Add a publish profile to create a profile. From the Publish dialog, select Folder as your Target.\n\nLeave the default Location, and then select Finish. Once the profile is created, select Show all settings, and verify your Profile settings.\n\nEnsure that the following settings are specified:\n\nFinally, select Publish. The app is compiled, and the resulting .exe file is published to the /publish output directory.\n\nAlternatively, you could use the .NET CLI to publish the app:\n\nFor more information, see .\n\nIf you're unfamiliar with using PowerShell and you'd rather create an installer for your service, see Create a Windows Service installer. Otherwise, to create the Windows Service, use the native Windows Service Control Manager's (sc.exe) create command. Run PowerShell as an Administrator.\n\nFor more information, see sc.exe create.\n\nAfter the service is created, you can optionally configure it. If you're fine with the service defaults, skip to the Verify service functionality section.\n\nWindows Services provide recovery configuration options. You can query the current configuration using the (where is your services' name) command to read the current recovery configuration values:\n\nThe command will output the recovery configuration, which is the default values—since they've not yet been configured.\n\nTo configure recovery, use the where is the name of your service:\n\nAfter it's been successfully configured, you can query the values once again using the command:\n\nYou will see the configured restart values.\n\nWith .NET 6, new hosting exception-handling behaviors have been added to .NET. The BackgroundServiceExceptionBehavior enum was added to the namespace, and is used to specify the behavior of the service when an exception is thrown. The following table lists the available options:\n\nThe default behavior before .NET 6 is , which resulted in zombie processes (a running process that didn't do anything). With .NET 6, the default behavior is , which results in the host being stopped when an exception is thrown. But it stops cleanly, meaning that the Windows Service management system will not restart the service. To correctly allow the service to be restarted, you can call Environment.Exit with a non-zero exit code. Consider the following highlighted block:\n\nTo see the app created as a Windows Service, open Services. Select the Windows key (or + ), and search from \"Services\". From the Services app, you should be able to find your service by its name.\n\nTo verify that the service is functioning as expected, you need to:\n\nTo start the Windows Service, use the command:\n\nYou'll see output similar to the following:\n\nThe service Status will transition out of to Running.\n\nTo view logs, open the Event Viewer. Select the Windows key (or + ), and search for . Select the Event Viewer (Local) > Windows Logs > Application node. You should see a Warning level entry with a Source matching the apps namespace. Double-click the entry, or right-click and select Event Properties to view the details.\n\nAfter seeing logs in the Event Log, you should stop the service. It's designed to log a random joke once per minute. This is intentional behavior but is not practical for production services.\n\nTo stop the Windows Service, use the command:\n\nYou'll see output similar to the following:\n\nThe service Status will transition from to Stopped.\n\nTo delete the Windows Service, use the native Windows Service Control Manager's (sc.exe) delete command. Run PowerShell as an Administrator.\n\nFor more information, see sc.exe delete."
    },
    {
        "link": "https://learn.microsoft.com/en-us/answers/questions/665861/implement-windows-service-in-net-6-0",
        "document": "An object-oriented and type-safe programming language that has its roots in the C family of languages and includes support for component-oriented programming."
    },
    {
        "link": "https://csharp.christiannagel.com/2022/03/22/windowsservice-2",
        "document": "Windows services are programs that are automatically started when the system starts up, or when the user logs in. They run in the background and can run with a different account than the logged-in user. .NET makes it easy to create Windows services or Linux daemons as shown in this article.\n\nInstead of creating Windows services and Linux daemons, nowadays you might think about using Docker instead. Docker orchestrators can be used to monitor and scale containers. Before creating a Windows service, you might think about this alternative. However, there are still many scenarios where Windows services are of great use.\n\nWhat are some of the scenarios where Windows services are used? Looking at the services running with Windows, (start the Services app), services to update applications and the operating system (e.g. Windows Update, Microsoft Edge Update Service, Mozilla Maintenance Service, Google Update Service, AdobeUpdateService), services to store credentials for users and applications (Credential Manager), services to offer geolocation information for applications (Geolocation Service), malware checkers (Microsoft Defender Antivirus Service), services to deliver sensor data (Sensor Service), and many more. Not every of these services is implemented as a separate application – some of the services use the same executable. Looking at the properties of a service you can check the path for the executable including its command-line arguments. Many services that are part of Windows make use of the svchost.exe, the Geolocation service invokes this with the -k netsvcs -p options.\n\nServices can be configured to automatically start when the operating system starts up (startup type Automatic). The Automatic Delayed start option allows the user to login before the service is started. Delayed started services are started after the Automatic started service. With the Manual configuration, the service starts up based on an event – e.g. a domain is joined, a firewall port is opened, a group policy is changed, or a custom event based on Event Tracing for Windows (ETW) is fired.\n\nLet’s start creating a Windows service by creating a background worker. With .NET 6, a background worker can be created using Visual Studio or the dotnet CLI command dotnet new worker.\n\nThe top-level statements created with this application use the class. The method contains functionality to setup the dependency injection container, configuration, and logging. The dependency injection container managed by the class is configured by invoking the method . In the generated code, the extension method is used to register a background class that implements the interface . This interface is indirectly implemented by the class by deriving from the base class . The interface defines the methods and . Adding a hosted service, invoking the method of the host starts the host and in turn invokes the startup of the .\n\nThe class derives from the class . implements the interface and defines the abstract method . This abstract method is called by the method in the . is defined by the interface. With the implementation of the class, uses an endless loop (until cancellation is requested) and writes a log message once a second.\n\nThe main functionality for the class is creating the dependency injection container, configuration, and logging. Using , configuration is read from the configuration files appsettings.json, appsettings.{env.EnvironmentName}.json, environmental variables, and the command line.\n\nLogging configuration is read from the section Logging within the configuration settings. Using the worker template, the configuration file appsettings.json defines logging based on the log level. The default configuration is set to Information:\n\nIf the application runs on a Windows system, the method also adds logging to the Windows event log and sets a filter provider to only log warnings and more critical issues to this provider.\n\nRunning the application, log information is written to the console. The worker writes a message every second.\n\nTo build a Windows Service, you just need to add the NuGet package Microsoft.Extensions.Hosting.WindowsServices, and add the method invocation to the fluent API:\n\nTo see information level logging in the Windows event log, the filter is explicitly applied with the method used with the host builder. The method configures the source name the same as the application name. This information is overwritten configuring the . In addition to setting the property of the , the is set which creates a separate category for logging shown in the Event Viewer.\n\nAfter building the application, the new Windows Service can be published using dotnet publish (or by using Visual Studio):\n\nTo control Windows Services, the sc command can be used. Creating a new Windows Service is done using sc create passing the name of the service and the binPath parameter referencing the executable. This command requires administrator rights:\n\nThe status of the service can be queried using the Services MMC, or with the command line sc query:\n\nAfter the service is created, it is stopped and need to be started:\n\nTo stop and delete the service, the sc stop and sc delete commands can be used.\n\nAfter starting the service, log information can be seen with the Windows Event Viewer. Because the property was set, there’s a separate category with Application and Services Logs:\n\nWith a Windows Service, it’s possible to pass command-line arguments with the service configuration. To read the arguments, the class can be used as shown in the following code snippet.\n\nWhen creating the service using sc create, pay attention to leave a blank after the binPath option. You can supply the parameters within the quotes:\n\nWhat about hosting Kestrel as a Windows Service? There’s not a lot difference using the package Microsoft.Extensions.Hosting.WindowsServices – in principle just the API UseWindowsService needs to be invoked. Let’s get into details using the .NET 6 class.\n\nA Web API project can be created using dotnet new webapi. This template creates an API returning random weather information. With the option –use-minimal-apis, controllers are not used, and the complete functionality of the API can be defined with top-level statements. The parameter –no-https specifies to create an implementation with HTTP. Using HTTPS, it’s necessary to create and configure a certificate that’s used by the account running the service. Depending on the scenario how you use this Windows service, HTTP can be ok.\n\nThe method is an extension method for . With .NET 6, and are used instead of the and classes. Of course, you can also change the code to the old .NET 5 version. offers an abstraction layer of the class and makes it easier to configure ASP.NET Core middleware. With .NET 5, the class has been used. Instead of using the class now everything can be done with top-level statements. The Minimal API makes use of C# 10 features and adds some APIs, e.g. a new overload of the method. Using the class, the functionality of the can be accessed using the property. This property returns a instance which implements the interface . Here you can use the extension method like before. The extension method configures the content root path to for the Windows service. Because the method already needs this directory, this directory needs to be specified with the as shown. To specify a log category with the Windows event logs, the are configured as before with the console application:\n\nThe Kestrel server can be configured accessing the property of the , invoking the method . With the sample application, the Kestrel server is configured using appsettings.json:\n\nNow the service can be build, published, and configured as a Windows Service in the same way as mentioned before using the worker application. Opening a browser to reference the configured port with the controller route WeatherForecast returns JSON information from the API service:\n\nWhat about running this application on Linux? The method checks if it’s running on Windows as a Windows service, and returns if this is not the case. With this you can run the application on the Linux system as well. To create a Linux daemon, you can add the NuGet package Microsoft.Extensions.Hosting.Systemd, and invoke the method . What’s different is the configuration of systemd. To use systemd with WSL-2, you can use Distrod to run your Ubuntu environment. See a link below for Distrod.\n\nStarting with .NET 3, the class was introduced which abstracts configuration for logging, dependency injecction, and configuration in one place. Extension methods make it easy to offer more features. With this, using the NuGet package Microsoft.Extensions.Hosting.WindowsServices just one API method is required to create a Windows Service. This way, background functionalty based on the worker template, but also hosting a Kestrel server for offering ASP.NET Core Web applications and services is an easy task.\n\nIf you like this article, it would be great if you buy a coffee:"
    },
    {
        "link": "https://reddit.com/r/dotnet/comments/yeyc1g/creating_a_windows_service_in_net_60",
        "document": ".NET Community, if you are using C#, VB.NET, F#, or anything running with .NET... you are at the right place!"
    },
    {
        "link": "https://stackoverflow.com/questions/70905867/how-do-you-install-a-net-6-windows-service-worker-service-using-a-visual-stud",
        "document": "I Have a Worker Service written in c# that needs to be installed as a Windows Service (configured by calling the method).\n\nThis guide specifies how to create an installer for a .NET 6 application, but this installer only copies the app's files.\n\nHow can I install the service contained in the executable?"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/framework/windows-services/how-to-debug-windows-service-applications",
        "document": "A service must be run from within the context of the Services Control Manager rather than from within Visual Studio. For this reason, debugging a service is not as straightforward as debugging other Visual Studio application types. To debug a service, you must start the service and then attach a debugger to the process in which it is running. You can then debug your application by using all of the standard debugging functionality of Visual Studio.\n\nYou can attach the debugger only to a running service. The attachment process interrupts the current functioning of your service; it doesn't actually stop or pause the service's processing. That is, if your service is running when you begin debugging, it is still technically in the Started state as you debug it, but its processing has been suspended.\n\nAfter attaching to the process, you can set breakpoints and use these to debug your code. Once you exit the dialog box you use to attach to the process, you are effectively in debug mode. You can use the Services Control Manager to start, stop, pause and continue your service, thus hitting the breakpoints you've set. You can later remove this dummy service after debugging is successful.\n\nThis article covers debugging a service that's running on the local computer, but you can also debug Windows Services that are running on a remote computer. See Remote Debugging.\n\nTo get meaningful information for debugging, the Visual Studio debugger needs to find symbol files for the binaries that are being debugged. If you are debugging a service that you built in Visual Studio, the symbol files (.pdb files) are in the same folder as the executable or library, and the debugger loads them automatically. If you are debugging a service that you didn't build, you should first find symbols for the service and make sure they can be found by the debugger. See Specify Symbol (.pdb) and Source Files in the Visual Studio Debugger. If you're debugging a system process or want to have symbols for system calls in your services, you should add the Microsoft Symbol Servers. See Debugging Symbols.\n• None Build your service in the Debug configuration.\n• None Install your service. For more information, see How to: Install and Uninstall Services.\n• None Start your service, either from Services Control Manager, Server Explorer, or from code. For more information, see How to: Start Services.\n• None Start Visual Studio with administrative credentials so you can attach to system processes.\n• None (Optional) On the Visual Studio menu bar, choose Tools, Options. In the Options dialog box, choose Debugging, Symbols, select the Microsoft Symbol Servers check box, and then choose the OK button.\n• None On the menu bar, choose Attach to Process from the Debug or Tools menu. (Keyboard: Ctrl+Alt+P)\n• None Select the Show processes from all users check box.\n• None In the Available Processes section, choose the process for your service, and then choose Attach. The process will have the same name as the executable file for your service.\n• None Choose the appropriate options, and then choose OK to close the dialog box. You are now in debug mode.\n• None Set any breakpoints you want to use in your code.\n• None Access the Services Control Manager and manipulate your service, sending stop, pause, and continue commands to hit your breakpoints. For more information about running the Services Control Manager, see How to: Start Services. Also, see Troubleshooting: Debugging Windows Services.\n\nAttaching to the service's process allows you to debug most, but not all, the code for that service. For example, because the service has already been started, you cannot debug the code in the service's OnStart method or the code in the method that is used to load the service this way. One way to work around this limitation is to create a temporary second service in your service application that exists only to aid in debugging. You can install both services, and then start this dummy service to load the service process. Once the temporary service has started the process, you can use the Debug menu in Visual Studio to attach to the service process.\n\nTry adding calls to the Sleep method to delay action until you're able to attach to the process.\n\nTry changing the program to a regular console application. To do this, rewrite the method as follows so it can run both as a Windows Service and as a console application, depending on how it's started.\n\nHow to: Run a Windows Service as a console application\n• None Add a method to your service that runs the OnStart and OnStop methods:\n• None Rewrite the method as follows: static void Main(string[] args) { if (Environment.UserInteractive) { MyNewService service1 = new MyNewService(args); service1.TestStartupAndStop(args); } else { // Put the body of your old Main method here. } }\n• None In the Application tab of the project's properties, set the Output type to Console Application.\n• None To run the program as a Windows Service again, install it and start it as usual for a Windows Service. It's not necessary to reverse these changes.\n\nIn some cases, such as when you want to debug an issue that occurs only on system startup, you have to use the Windows debugger. Download the Windows Driver Kit (WDK) and see How to debug Windows Services.\n• How to: Install and Uninstall Services"
    },
    {
        "link": "https://stackoverflow.com/questions/125964/easier-way-to-debug-a-windows-service",
        "document": "Is there an easier way to step through the code than to start the service through the Windows Service Control Manager and then attaching the debugger to the thread? It's kind of cumbersome and I'm wondering if there is a more straightforward approach.\n\nIf I want to quickly debug the service, I just drop in a in there. When that line is reached, it will drop me back to VS. Don't forget to remove that line when you are done. UPDATE: As an alternative to pragmas, you can also use attribute. On your , just call this method: There, the code will only be enabled during Debug builds. While you're at it, it might be useful to create a separate Build Configuration for service debugging.\n\nI also think having a separate \"version\" for normal execution and as a service is the way to go, but is it really required to dedicate a separate command line switch for that purpose? public static int Main(string[] args) { if (!Environment.UserInteractive) { // Startup as service. } else { // Startup as application } } That would have the \"benefit\", that you can just start your app via doubleclick (OK, if you really need that) and that you can just hit in Visual Studio (without the need to modify the project settings to include that Option). Technically, the checks if the Flag is set for the current window station, but is there any other reason where it would return , apart from being run as a (non-interactive) service?\n\nSometimes it is important to analyze what's going on during the start up of the service. Attaching to the process does not help here, because you are not quick enough to attach the debugger while the service is starting up. The short answer is, I am using the following 4 lines of code to do this: This sets a longer timeout for the startup of the service, note that it just allows the service to take more time for startup (it is not actually waiting, but it is giving the service a grace time before it is regarded unresponsive by the system). These are inserted into the method of the service as follows: protected override void OnStart(string[] args) { #if DEBUG base.RequestAdditionalTime(600000); // 10 minutes timeout for startup Debugger.Launch(); // launch and attach debugger #endif MyInitOnstart(); // my individual initialization code for the service // allow the base class to perform any work it needs to do base.OnStart(args); } For those who haven't done it before, I have included detailed hints below, because you can easily get stuck. The following hints refer to Windows 7x64 and Visual Studio 2010 Team Edition, but should be valid for other (newer) environments, too. Important: Deploy the service in \"manual\" mode (using either the utility from the VS command prompt or run a service installer project you have prepared). Open Visual Studio before you start the service and load the solution containing the service's source code - set up additional breakpoints as you require them in Visual Studio - then start the service via the Service Control Panel. Because of the code, this will cause a dialog \"An unhandled Microsoft .NET Framework exception occured in Servicename.exe.\" to appear. Click as shown in the screenshot:\n\n Afterwards, Windows UAC might prompt you to enter admin credentials. Enter them and proceed with : After that, the well known Visual Studio Just-In-Time Debugger window appears. It asks you if you want to debug using the delected debugger. Before you click , select that you don't want to open a new instance (2nd option) - a new instance would not be helpful here, because the source code wouldn't be displayed. So you select the Visual Studio instance you've opened earlier instead: \n\n After you have clicked , after a while Visual Studio will show the yellow arrow right in the line where the statement is and you are able to debug your code (method , which contains your initialization). Pressing continues execution immediately, until the next breakpoint you have prepared is reached. Hint: To keep the service running, select Debug -> Detach all. This allows you to run a client communicating with the service after it started up correctly and you're finished debugging the startup code. If you press + (stop debugging), this will terminate the service. Instead of doing this, you should use the Service Control Panel to stop it.\n• None If you build a Release, then the debug code is automatically removed and the service runs normally.\n• None I am using , which starts and attaches a debugger. I have tested as well, which did not work, because there is no debugger attached on start up of the service yet (causing the \"Error 1067: The process terminated unexpectedly.\").\n• None sets a longer timeout for the startup of the service (it is not delaying the code itself, but will immediately continue with the statement). Otherwise the default timeout for starting the service is too short and starting the service fails if you don't call quickly enough from the debugger. Practically, a timeout of 10 minutes avoids that you see the message \"the service did not respond...\" immediately after the debugger is started.\n• None Once you get used to it, this method is very easy because it just requires you to add 4 lines to an existing service code, allowing you quickly to gain control and debug.\n\nThis YouTube video by Fabio Scopel explains how to debug a Windows service quite nicely... the actual method of doing it starts at 4:45 in the video... Here is the code explained in the video... in your Program.cs file, add the stuff for the Debug section... namespace YourNamespace { static class Program { /// <summary> /// The main entry point for the application. /// </summary> static void Main() { #if DEBUG Service1 myService = new Service1(); myService.OnDebug(); System.Threading.Thread.Sleep(System.Threading.Timeout.Infinite); #else ServiceBase[] ServicesToRun; ServicesToRun = new ServiceBase[] { new Service1() }; ServiceBase.Run(ServicesToRun); #endif } } } In your Service1.cs file, add the OnDebug() method... public Service1() { InitializeComponent(); } public void OnDebug() { OnStart(null); } protected override void OnStart(string[] args) { // your code to do something } protected override void OnStop() { } Basically you have to create a that calls the as it's protected and not accessible outside. The program is added with preprocessor with . Visual Studio defines if project is compiled in Debug mode.This will allow the debug section(below) to execute when the condition is true And it will run just like a console application, once things go OK you can change the mode and the regular section will trigger the logic\n\nThis approach is by far the easiest: I leave my original answer below for posterity. My services tend to have a class that encapsulates a Timer as I want the service to check at regular intervals whether there is any work for it to do. We new up the class and call StartEventLoop() during the service start-up. (This class could easily be used from a console app too.) The nice side-effect of this design is that the arguments with which you set up the Timer can be used to have a delay before the service actually starts working, so that you have time to attach a debugger manually. p.s. How to attach the debugger manually to a running process...? using System; using System.Threading; using System.Configuration; public class ServiceEventHandler { Timer _timer; public ServiceEventHandler() { // get configuration etc. _timer = new Timer( new TimerCallback(EventTimerCallback) , null , Timeout.Infinite , Timeout.Infinite); } private void EventTimerCallback(object state) { // do something } public void StartEventLoop() { // wait a minute, then run every 30 minutes _timer.Change(TimeSpan.Parse(\"00:01:00\"), TimeSpan.Parse(\"00:30:00\"); } } Also I used to do the following (already mentioned in previous answers but with the conditional compiler [#if] flags to help avoid it firing in a Release build). I stopped doing it this way because sometimes we'd forget to build in Release and have a debugger break in an app running on a client demo (embarrasing!).\n\nI like to be able to debug every aspect of my service, including any initialization in OnStart(), while still executing it with full service behavior within the framework of the SCM... no \"console\" or \"app\" mode. I do this by creating a second service, in the same project, to use for debugging. The debug service, when started as usual (i.e. in the services MMC plugin), creates the service host process. This gives you a process to attach the debugger to even though you haven't started your real service yet. After attaching the debugger to the process, start your real service and you can break into it anywhere in the service lifecycle, including OnStart(). Because it requires very minimal code intrusion, the debug service can easily be included in your service setup project, and is easily removed from your production release by commenting out a single line of code and deleting a single project installer. 1) Assuming you are implementing , also create . Add both to the array in like so: /// <summary> /// The main entry point for the application. /// </summary> static void Main() { ServiceBase[] ServicesToRun; ServicesToRun = new ServiceBase[] { new MyService(), new MyServiceDebug() }; ServiceBase.Run(ServicesToRun); } 2) Add the real service AND the debug service to the project installer for the service project: Both services (real and debug) get included when you add the service project output to the setup project for the service. After installation, both services will appear in the service.msc MMC plugin. 4) In Visual Studio, attach the debugger to the process started by the debug service."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/core/extensions/windows-service",
        "document": ".NET Framework developers are probably familiar with Windows Service apps. Before .NET Core and .NET 5+, developers who relied on .NET Framework could create Windows Services to perform background tasks or execute long-running processes. This functionality is still available and you can create Worker Services that run as a Windows Service.\n\nIn this tutorial, you'll learn how to:\n• The .NET 8.0 SDK or later\n\nTo create a new Worker Service project with Visual Studio, you'd select File > New > Project.... From the Create a new project dialog search for \"Worker Service\", and select Worker Service template. If you'd rather use the .NET CLI, open your favorite terminal in a working directory. Run the command, and replace the with your desired project name.\n\nFor more information on the .NET CLI new worker service project command, see dotnet new worker.\n\nTo interop with native Windows Services from .NET IHostedService implementations, you'll need to install the NuGet package.\n\nTo install this from Visual Studio, use the Manage NuGet Packages... dialog. Search for \"Microsoft.Extensions.Hosting.WindowsServices\", and install it. If you'd rather use the .NET CLI, run the command:\n\nFor more information on the .NET CLI add package command, see dotnet add package.\n\nAfter successfully adding the packages, your project file should now contain the following package references:\n\nThis worker project makes use of C#'s nullable reference types. To enable them for the entire project, update the project file accordingly:\n\nThe preceding project file changes add the node. For more information, see Setting the nullable context.\n\nAdd a new class to the project named JokeService.cs, and replace its contents with the following C# code:\n\nThe preceding joke service source code exposes a single piece of functionality, the method. This is a returning method that represents a random programming joke. The class-scoped field is used to store the list of jokes. A random joke is selected from the list and returned.\n\nReplace the existing from the template with the following C# code, and rename the file to WindowsBackgroundService.cs:\n\nIn the preceding code, the is injected along with an . Both are made available to the class as fields. In the method, the joke service requests a joke and writes it to the logger. In this case, the logger is implemented by the Windows Event Log - Microsoft.Extensions.Logging.EventLog.EventLogLoggerProvider. Logs are written to, and available for viewing in the Event Viewer.\n\nReplace the template Program.cs file contents with the following C# code:\n\nThe extension method configures the app to work as a Windows Service. The service name is set to . The hosted service is registered for dependency injection.\n\nFor more information on registering services, see Dependency injection in .NET.\n\nTo create the .NET Worker Service app as a Windows Service, it's recommended that you publish the app as a single file executable. It's less error-prone to have a self-contained executable, as there aren't any dependent files lying around the file system. But you may choose a different publishing modality, which is perfectly acceptable, so long as you create an *.exe file that can be targeted by the Windows Service Control Manager.\n\nThe preceding highlighted lines of the project file define the following behaviors:\n• : Specify the target platform CPU of 64-bit.\n\nTo publish the app from Visual Studio, you can create a publish profile that is persisted. The publish profile is XML-based and has the .pubxml file extension. Visual Studio uses this profile to publish the app implicitly, whereas if you're using the .NET CLI, you must explicitly specify the publish profile for it to be used.\n\nRight-click on the project in the Solution Explorer, and select Publish. Then, select Add a publish profile to create a profile. From the Publish dialog, select Folder as your Target.\n\nLeave the default Location, and then select Finish. Once the profile is created, select Show all settings, and verify your Profile settings.\n\nEnsure that the following settings are specified:\n\nFinally, select Publish. The app is compiled, and the resulting .exe file is published to the /publish output directory.\n\nAlternatively, you could use the .NET CLI to publish the app:\n\nFor more information, see .\n\nIf you're unfamiliar with using PowerShell and you'd rather create an installer for your service, see Create a Windows Service installer. Otherwise, to create the Windows Service, use the native Windows Service Control Manager's (sc.exe) create command. Run PowerShell as an Administrator.\n\nFor more information, see sc.exe create.\n\nAfter the service is created, you can optionally configure it. If you're fine with the service defaults, skip to the Verify service functionality section.\n\nWindows Services provide recovery configuration options. You can query the current configuration using the (where is your services' name) command to read the current recovery configuration values:\n\nThe command will output the recovery configuration, which is the default values—since they've not yet been configured.\n\nTo configure recovery, use the where is the name of your service:\n\nAfter it's been successfully configured, you can query the values once again using the command:\n\nYou will see the configured restart values.\n\nWith .NET 6, new hosting exception-handling behaviors have been added to .NET. The BackgroundServiceExceptionBehavior enum was added to the namespace, and is used to specify the behavior of the service when an exception is thrown. The following table lists the available options:\n\nThe default behavior before .NET 6 is , which resulted in zombie processes (a running process that didn't do anything). With .NET 6, the default behavior is , which results in the host being stopped when an exception is thrown. But it stops cleanly, meaning that the Windows Service management system will not restart the service. To correctly allow the service to be restarted, you can call Environment.Exit with a non-zero exit code. Consider the following highlighted block:\n\nTo see the app created as a Windows Service, open Services. Select the Windows key (or + ), and search from \"Services\". From the Services app, you should be able to find your service by its name.\n\nTo verify that the service is functioning as expected, you need to:\n\nTo start the Windows Service, use the command:\n\nYou'll see output similar to the following:\n\nThe service Status will transition out of to Running.\n\nTo view logs, open the Event Viewer. Select the Windows key (or + ), and search for . Select the Event Viewer (Local) > Windows Logs > Application node. You should see a Warning level entry with a Source matching the apps namespace. Double-click the entry, or right-click and select Event Properties to view the details.\n\nAfter seeing logs in the Event Log, you should stop the service. It's designed to log a random joke once per minute. This is intentional behavior but is not practical for production services.\n\nTo stop the Windows Service, use the command:\n\nYou'll see output similar to the following:\n\nThe service Status will transition from to Stopped.\n\nTo delete the Windows Service, use the native Windows Service Control Manager's (sc.exe) delete command. Run PowerShell as an Administrator.\n\nFor more information, see sc.exe delete."
    },
    {
        "link": "https://stackoverflow.com/questions/2280496/what-are-the-best-practices-when-running-a-process-as-a-windows-service",
        "document": "For critical error reporting, you are constrained to using the standard Service settings (in the properties of the installed service), or doing something yourself. This could be as simple a log file that logs unexpected errors (by using AppDomain.UnhandledException to catch and log them), using the Windows event log to log similar info, or having another process watch the service for errors (ie. the service stopping) and alerting someone.\n\nMicrosoft has an article entitled \"Introduction to Windows Service Applications\" that is a good general introduction to making services in .Net.\n\nSome other things about developing Windows services from my experience:\n• A Windows service is allowed about 30 seconds to start. After that, Windows will report it as not having started correctly. This means that you need to ensure that your method of the service kicks off a new thread to run the service and then returns.\n• Don't expect any user interaction (ie. message boxes, confirmations) because the service runs \"headless\" (ie. without a UI), so you cannot expect a user to interact with it.\n• Check the account that the service will run as to ensure that you are not running it as a user with unnecessarily high security privileges.\n• Make extensive use of logging (eg. log4net) so that you can see what the service is doing during runtime, as well as being able to diagnose any errors (by logging stack traces).\n• Make sure you use the correct version of InstallUtil (ie. 32 or 64 bit) to install the service with. Even better, let the service install itself using the ManagedInstallerClass.InstallHelper."
    },
    {
        "link": "https://jason-ge.medium.com/how-to-debug-windows-service-application-c3a0619dd801",
        "document": "Debugging Windows service application can be very tricky. Some articles suggested to use VisualStudio to attach to the Windows service thread. But you have to first install the service locally and start it using Service Control Manager. It is quite cumbersome to do so.\n\nIn this article, we will discuss an easier way to debug Windows service. Assume we have a Notification service application:\n\nThe class Notifier.cs is where all the service functions defined. We can add 3 new public functions into this class.\n\nIn Program.cs file, we can add following code snippet:\n\nIf you start service in VisualStudio, it would not be able to accept console input since it is service application. We first need to change the project output type to “Console Application”\n\nNow we can start the service application as console application. You can use the keyboard to start/stop/shutdown the service. You can put breakpoints inside your code and now you can debug your Windows service application!\n\nJust remember you need to change your project output type back to “Windows Application” before release it to production.\n\nIf you don’t like to change the project output type, you can directly call the StartService() function and put the main thread to sleep forever as following code snippet.\n\nYou can find the demo Windows service application at here in Github."
    }
]