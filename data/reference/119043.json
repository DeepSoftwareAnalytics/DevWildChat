[
    {
        "link": "https://ansys.com/training-center/course-catalog/structures/introduction-to-ansys-mechanical-apdl",
        "document": ""
    },
    {
        "link": "https://help.autodesk.com/view/ACMPAN/2024/ENU?guid=HELIUS-PFA-ANSYS-TUT4-CREATE-GEOM",
        "document": ""
    },
    {
        "link": "https://reddit.com/r/ANSYS/comments/1bl1q74/create_a_geometry",
        "document": "Hi, I have just downloaded Ansys for a University project and I don't even know where to start. I planned to watch some tutorials on the Ansys yt page to start off but I don't know if they are enough. The project doesn't have to be that much complicated (I wanted to do a 90's F1 front wing) and my professor told me to use Ansys Workbench and Mechanical. Any tips?"
    },
    {
        "link": "https://designgyan.com/srp457/assets/images/papers/DesignGyan1135429Ansys%20Work%20Bench%20Meshing%20Guidelines.pdf",
        "document": ""
    },
    {
        "link": "https://mm.bme.hu/~gyebro/files/fea/ansys/ansys_13_element_reference.pdf",
        "document": "> endobj 18667 0 obj << /Title (~8Q\\rm8��⏇��5��d��%�o�) /Border [0 0 0 []] /Parent 18663 0 R /Dest [173 0 R /XYZ 64.8 749.88 0] /Prev 18671 0 R >> endobj 18666 0 obj << /Dest [175 0 R /XYZ 64.8 749.88 0] /Last 18672 0 R /Parent 18661 0 R /First 18673 0 R /Prev 18663 0 R /Count -5 /Next 18674 0 R /Title (@-`�No) /Border [0 0 0 []] >> endobj 18673 0 obj << /Title ( �\\)ԟ�ݠ��Ff�[�w9A��rV) /Border [0 0 0 []] /Parent 18666 0 R /Dest [175 0 R /XYZ 64.8 688.761 0] /Next 18675 0 R >> endobj 18675 0 obj << /Dest [175 0 R /XYZ 64.8 313.116 0] /Last 18676 0 R /Parent 18666 0 R /First 18676 0 R /Prev 18673 0 R /Count -1 /Next 18677 0 R /Title (��\n\n��J\\\\u^�L�Q�) /Border [0 0 0 []] >> endobj 18676 0 obj << /Title (����F�������\n\n��W?F\\f) /Border [0 0 0 []] /Parent 18675 0 R /Dest [176 0 R /XYZ 32.4 749.88 0] >> endobj 18677 0 obj << /Title (Q��n\\)�Ir�0�,5F5�) /Border [0 0 0 []] /Parent 18666 0 R /Dest [176 0 R /XYZ 32.4 307.08 0] /Next 18678 0 R /Prev 18675 0 R >> endobj 18678 0 obj << /Title (�2̠��$m>n�7��c�?V7�I���a�y\\t �\\b�) /Border [0 0 0 []] /Parent 18666 0 R /Dest [177 0 R /XYZ 64.8 522.694 0] /Next 18672 0 R /Prev 18677 0 R >> endobj 18672 0 obj << /Title (�5W��L-�����Y��}��&WB�2M) /Border [0 0 0 []] /Parent 18666 0 R /Dest [178 0 R /XYZ 32.4 749.88 0] /Prev 18678 0 R >> endobj 18674 0 obj << /Dest [179 0 R /XYZ 64.8 749.88 0] /Last 18679 0 R /Parent 18661 0 R /First 18680 0 R /Prev 18666 0 R /Count -5 /Next 18681 0 R /Title (��# �) /Border [0 0 0 []] >> endobj 18680 0 obj << /Title (��rY�|/h,B}�����ѦAl��0a) /Border [0 0 0 []] /Parent 18674 0 R /Dest [179 0 R /XYZ 64.8 688.761 0] /Next 18682 0 R >> endobj 18682 0 obj << /Dest [179 0 R /XYZ 64.8 470.246 0] /Last 18683 0 R /Parent 18674 0 R /First 18683 0 R /Prev 18680 0 R /Count -1 /Next 18684 0 R /Title (Y4�9h^��\\\\��\\)��) /Border [0 0 0 []] >> endobj 18683 0 obj << /Title (rԉ�+� %���93�) /Border [0 0 0 []] /Parent 18682 0 R /Dest [179 0 R /XYZ 64.8 317.501 0] >> endobj 18684 0 obj << /Title (->M�gZ}�/�\\f�r�) /Border [0 0 0 []] /Parent 18674 0 R /Dest [180 0 R /XYZ 32.4 559.8 0] /Next 18685 0 R /Prev 18682 0 R >> endobj 18685 0 obj << /Title (�ԙ���3�����L�\\rC�\\f�bg��L��x�'�) /Border [0 0 0 []] /Parent 18674 0 R /Dest [181 0 R /XYZ 64.8 434.925 0] /Next 18679 0 R /Prev 18684 0 R >> endobj 18679 0 obj << /Title (��~����'p�\\(��W��r���+�\\b) /Border [0 0 0 []] /Parent 18674 0 R /Dest [181 0 R /XYZ 64.8 290.025 0] /Prev 18685 0 R >> endobj 18681 0 obj << /Dest [183 0 R /XYZ 64.8 749.88 0] /Last 18686 0 R /Parent 18661 0 R /First 18687 0 R /Prev 18674 0 R /Count -5 /Next 18688 0 R /Title (muӺY�) /Border [0 0 0 []] >> endobj 18687 0 obj << /Title (X'`m�����տ���Q_��K�s\n\n) /Border [0 0 0 []] /Parent 18681 0 R /Dest [183 0 R /XYZ 64.8 688.761 0] /Next 18689 0 R >> endobj 18689 0 obj << /Dest [183 0 R /XYZ 64.8 365.154 0] /Last 18690 0 R /Parent 18681 0 R /First 18690 0 R /Prev 18687 0 R /Count -1 /Next 18691 0 R /Title (C���L�Ă��po��) /Border [0 0 0 []] >> endobj 18690 0 obj << /Title (��m����>A��/�ş+i^) /Border [0 0 0 []] /Parent 18689 0 R /Dest [184 0 R /XYZ 32.4 403.38 0] >> endobj 18691 0 obj << /Title (��q\"{�Ц���BUu;��) /Border [0 0 0 []] /Parent 18681 0 R /Dest [186 0 R /XYZ 32.4 373.68 0] /Next 18692 0 R /Prev 18689 0 R >> endobj 18692 0 obj << /Title (\\\\��$,��5K�d��=@��4y�.k}F��}*���\\f) /Border [0 0 0 []] /Parent 18681 0 R /Dest [190 0 R /XYZ 32.4 205.479 0] /Next 18686 0 R /Prev 18691 0 R >> endobj 18686 0 obj << /Title (yY�N2�7�Ԡ���J,�&1h��*��F) /Border [0 0 0 []] /Parent 18681 0 R /Dest [191 0 R /XYZ 64.8 305.803 0] /Prev 18692 0 R >> endobj 18688 0 obj << /Dest [193 0 R /XYZ 64.8 749.88 0] /Last 18693 0 R /Parent 18661 0 R /First 18694 0 R /Prev 18681 0 R /Count -5 /Next 18695 0 R /Title (�D����) /Border [0 0 0 []] >> endobj 18694 0 obj << /Title (��U��/� �2��\\thU.�6�a\n\n}|��) /Border [0 0 0 []] /Parent 18688 0 R /Dest [193 0 R /XYZ 64.8 688.761 0] /Next 18696 0 R >> endobj 18696 0 obj << /Dest [193 0 R /XYZ 64.8 338.595 0] /Last 18697 0 R /Parent 18688 0 R /First 18697 0 R /Prev 18694 0 R /Count -1 /Next 18698 0 R /Title ( ��ˆH��|\n\n 2#\"�+) /Border [0 0 0 []] >> endobj 18697 0 obj << /Title (�ƃf�\\)��v��w����������) /Border [0 0 0 []] /Parent 18696 0 R /Dest [194 0 R /XYZ 32.4 502.529 0] >> endobj 18698 0 obj << /Title (�y��x@��!�y��\\)]5) /Border [0 0 0 []] /Parent 18688 0 R /Dest [196 0 R /XYZ 32.4 633.195 0] /Next 18699 0 R /Prev 18696 0 R >> endobj 18699 0 obj << /Title (����y9/=���_Ml\"+v_#ZP��������R���) /Border [0 0 0 []] /Parent 18688 0 R /Dest [197 0 R /XYZ 64.8 280.35 0] /Next 18693 0 R /Prev 18698 0 R >> endobj 18693 0 obj << /Title (�.[�Q��I > endobj 18695 0 obj << /Dest [199 0 R /XYZ 64.8 749.88 0] /Last 18700 0 R /Parent 18661 0 R /First 18701 0 R /Prev 18688 0 R /Count -5 /Next 18702 0 R /Title (8��9�u) /Border [0 0 0 []] >> endobj 18701 0 obj << /Title (�\\([��N���^�`�]�n��˯�:7�J) /Border [0 0 0 []] /Parent 18695 0 R /Dest [199 0 R /XYZ 64.8 688.761 0] /Next 18703 0 R >> endobj 18703 0 obj << /Dest [199 0 R /XYZ 64.8 463.436 0] /Last 18704 0 R /Parent 18695 0 R /First 18704 0 R /Prev 18701 0 R /Count -1 /Next 18705 0 R /Title (�8\\fy2vӓؤ����-) /Border [0 0 0 []] >> endobj 18704 0 obj << /Title (3j��Av��ե��\\\\�:���m) /Border [0 0 0 []] /Parent 18703 0 R /Dest [199 0 R /XYZ 64.8 259.007 0] >> endobj 18705 0 obj << /Title (x�a��dr�o��,e�/9��) /Border [0 0 0 []] /Parent 18695 0 R /Dest [201 0 R /XYZ 64.8 749.88 0] /Next 18706 0 R /Prev 18703 0 R >> endobj 18706 0 obj << /Title (�cq��q�ƒ@ʣ�0Z�9�����W�\\fX��ɝ���) /Border [0 0 0 []] /Parent 18695 0 R /Dest [201 0 R /XYZ 64.8 700.02 0] /Next 18700 0 R /Prev 18705 0 R >> endobj 18700 0 obj << /Title (�YY;S�g*�!_�fV�ꔩI��3�) /Border [0 0 0 []] /Parent 18695 0 R /Dest [201 0 R /XYZ 64.8 569.97 0] /Prev 18706 0 R >> endobj 18702 0 obj << /Dest [203 0 R /XYZ 64.8 749.88 0] /Last 18707 0 R /Parent 18661 0 R /First 18708 0 R /Prev 18695 0 R /Count -5 /Next 18709 0 R /Title (��m�G�G) /Border [0 0 0 []] >> endobj 18708 0 obj << /Title (�t�|l�s��֋��M�[���ۚ�`t�) /Border [0 0 0 []] /Parent 18702 0 R /Dest [203 0 R /XYZ 64.8 688.761 0] /Next 18710 0 R >> endobj 18710 0 obj << /Dest [203 0 R /XYZ 64.8 279.059 0] /Last 18711 0 R /Parent 18702 0 R /First 18711 0 R /Prev 18708 0 R /Count -1 /Next 18712 0 R /Title (|a�ɽTZz\n\n����) /Border [0 0 0 []] >> endobj 18711 0 obj << /Title (z��`QT�������$#�a�) /Border [0 0 0 []] /Parent 18710 0 R /Dest [204 0 R /XYZ 32.4 555.84 0] >> endobj 18712 0 obj << /Title (����ʽ��ye�@']'.b ) /Border [0 0 0 []] /Parent 18702 0 R /Dest [205 0 R /XYZ 64.8 201.42 0] /Next 18713 0 R /Prev 18710 0 R >> endobj 18713 0 obj << /Title (@C����+�b9A��$�\\\\���=ݽh �=��2��U) /Border [0 0 0 []] /Parent 18702 0 R /Dest [209 0 R /XYZ 64.8 726.12 0] /Next 18707 0 R /Prev 18712 0 R >> endobj 18707 0 obj << /Title (d�?$����\n\n?%�Le��_,�`��h�8) /Border [0 0 0 []] /Parent 18702 0 R /Dest [209 0 R /XYZ 64.8 481.23 0] /Prev 18713 0 R >> endobj 18709 0 obj << /Dest [211 0 R /XYZ 64.8 749.88 0] /Last 18714 0 R /Parent 18661 0 R /First 18715 0 R /Prev 18702 0 R /Count -5 /Next 18716 0 R /Title (����C�~) /Border [0 0 0 []] >> endobj 18715 0 obj << /Title (ڝ\\\\p�+k�t5E�Ѓn��V?�\\(��) /Border [0 0 0 []] /Parent 18709 0 R /Dest [211 0 R /XYZ 64.8 688.761 0] /Next 18717 0 R >> endobj 18717 0 obj << /Dest [211 0 R /XYZ 64.8 469.112 0] /Last 18718 0 R /Parent 18709 0 R /First 18718 0 R /Prev 18715 0 R /Count -1 /Next 18719 0 R /Title (u��J�t��&���VZؓ�\\\\) /Border [0 0 0 []] >> endobj 18718 0 obj << /Title (�=椝�x�Îb�l+:/U�) /Border [0 0 0 []] /Parent 18717 0 R /Dest [212 0 R /XYZ 32.4 678.675 0] >> endobj 18719 0 obj << /Title (���ѦB��\\bX�~w\\(�\\b�) /Border [0 0 0 []] /Parent 18709 0 R /Dest [213 0 R /XYZ 64.8 603.36 0] /Next 18720 0 R /Prev 18717 0 R >> endobj 18720 0 obj << /Title (���ʘ�3�U|�-������\"}=k54#\\f�L��3�@V�) /Border [0 0 0 []] /Parent 18709 0 R /Dest [214 0 R /XYZ 32.4 203.596 0] /Next 18714 0 R /Prev 18719 0 R >> endobj 18714 0 obj << /Title (�,�\\by�9z~�O��������|h7<�) /Border [0 0 0 []] /Parent 18709 0 R /Dest [215 0 R /XYZ 64.8 672.66 0] /Prev 18720 0 R >> endobj 18716 0 obj << /Dest [217 0 R /XYZ 64.8 749.88 0] /Last 18721 0 R /Parent 18661 0 R /First 18722 0 R /Prev 18709 0 R /Count -5 /Next 18723 0 R /Title (�e�Q��|) /Border [0 0 0 []] >> endobj 18722 0 obj << /Title (����3��٥�2Øc�ϓ�J4) /Border [0 0 0 []] /Parent 18716 0 R /Dest [217 0 R /XYZ 64.8 688.761 0] /Next 18724 0 R >> endobj 18724 0 obj << /Dest [217 0 R /XYZ 64.8 418.948 0] /Last 18725 0 R /Parent 18716 0 R /First 18725 0 R /Prev 18722 0 R /Count -1 /Next 18726 0 R /Title (�,��v?\\b�ެ@�e����) /Border [0 0 0 []] >> endobj 18725 0 obj << /Title (񏮼�i�ƹ��Oƪe�I) /Border [0 0 0 []] /Parent 18724 0 R /Dest [217 0 R /XYZ 64.8 208.708 0] >> endobj 18726 0 obj << /Title (���ۻ0r�|荑s���[�) /Border [0 0 0 []] /Parent 18716 0 R /Dest [218 0 R /XYZ 32.4 416.25 0] /Next 18727 0 R /Prev 18724 0 R >> endobj 18727 0 obj << /Title (�g��4\\f�� �`h����2��@�@�`�f�� > endobj 18721 0 obj << /Title (�U���\\tBCX_BF\n\n��H$4dI\\\\�DL�) /Border [0 0 0 []] /Parent 18716 0 R /Dest [221 0 R /XYZ 64.8 331.83 0] /Prev 18727 0 R >> endobj 18723 0 obj << /Dest [223 0 R /XYZ 64.8 749.88 0] /Last 18728 0 R /Parent 18661 0 R /First 18729 0 R /Prev 18716 0 R /Count -5 /Next 18730 0 R /Title (�#o�) /Border [0 0 0 []] >> endobj 18729 0 obj << /Title (N���\\r�����97u��TzkPm��a\\)@) /Border [0 0 0 []] /Parent 18723 0 R /Dest [223 0 R /XYZ 64.8 688.761 0] /Next 18731 0 R >> endobj 18731 0 obj << /Dest [223 0 R /XYZ 64.8 311.771 0] /Last 18732 0 R /Parent 18723 0 R /First 18732 0 R /Prev 18729 0 R /Count -1 /Next 18733 0 R /Title (�\\t�U��q�HGIz���^�K) /Border [0 0 0 []] >> endobj 18732 0 obj << /Title (oL�\\)g[\\r��ъ'6;c8ŭ) /Border [0 0 0 []] /Parent 18731 0 R /Dest [224 0 R /XYZ 32.4 369.72 0] >> endobj 18733 0 obj << /Title (�4�3p��I\\)IS#c_рEO) /Border [0 0 0 []] /Parent 18723 0 R /Dest [225 0 R /XYZ 64.8 275.67 0] /Next 18734 0 R /Prev 18731 0 R >> endobj 18734 0 obj << /Title (�6���Vޔ�c9jD�����l��5^tOC��۳��g�) /Border [0 0 0 []] /Parent 18723 0 R /Dest [227 0 R /XYZ 64.8 593.73 0] /Next 18728 0 R /Prev 18733 0 R >> endobj 18728 0 obj << /Title ([C����\\(����ǜ�gZ�by��tI�͝) /Border [0 0 0 []] /Parent 18723 0 R /Dest [227 0 R /XYZ 64.8 351.81 0] /Prev 18734 0 R >> endobj 18730 0 obj << /Dest [229 0 R /XYZ 64.8 749.88 0] /Last 18735 0 R /Parent 18661 0 R /First 18736 0 R /Prev 18723 0 R /Count -5 /Next 18737 0 R /Title (����R��) /Border [0 0 0 []] >> endobj 18736 0 obj << /Title (�\\t�M=u��{��B��@|1���f) /Border [0 0 0 []] /Parent 18730 0 R /Dest [229 0 R /XYZ 64.8 688.761 0] /Next 18738 0 R >> endobj 18738 0 obj << /Dest [230 0 R /XYZ 32.4 749.88 0] /Last 18739 0 R /Parent 18730 0 R /First 18739 0 R /Prev 18736 0 R /Count -1 /Next 18740 0 R /Title (�\\b[ 6k�z�&��s]) /Border [0 0 0 []] >> endobj 18739 0 obj << /Title (���_����p���Ad��-k) /Border [0 0 0 []] /Parent 18738 0 R /Dest [230 0 R /XYZ 32.4 217.774 0] >> endobj 18740 0 obj << /Title (����� > endobj 18741 0 obj << /Title (�Ʀd�F�;�\\b��**�C8�J�\\bD:�-�z^�) /Border [0 0 0 []] /Parent 18730 0 R /Dest [233 0 R /XYZ 64.8 461.205 0] /Next 18735 0 R /Prev 18740 0 R >> endobj 18735 0 obj << /Title (��7u�\\f���3��[PKQ����-G�=) /Border [0 0 0 []] /Parent 18730 0 R /Dest [234 0 R /XYZ 32.4 749.88 0] /Prev 18741 0 R >> endobj 18737 0 obj << /Dest [235 0 R /XYZ 64.8 749.88 0] /Last 18742 0 R /Parent 18661 0 R /First 18743 0 R /Prev 18730 0 R /Count -5 /Next 18744 0 R /Title (pЍC\\r�) /Border [0 0 0 []] >> endobj 18743 0 obj << /Title (�w�^� �����0XSK�'����) /Border [0 0 0 []] /Parent 18737 0 R /Dest [235 0 R /XYZ 64.8 688.761 0] /Next 18745 0 R >> endobj 18745 0 obj << /Dest [235 0 R /XYZ 64.8 450.34 0] /Last 18746 0 R /Parent 18737 0 R /First 18746 0 R /Prev 18743 0 R /Count -1 /Next 18747 0 R /Title (cI�?��Vr\\(�.\\r�h��) /Border [0 0 0 []] >> endobj 18746 0 obj << /Title (�5�4g%�D=4ZD�05[��) /Border [0 0 0 []] /Parent 18745 0 R /Dest [236 0 R /XYZ 32.4 573.68 0] >> endobj 18747 0 obj << /Title ( �V�g?��/�c���.QQ�) /Border [0 0 0 []] /Parent 18737 0 R /Dest [237 0 R /XYZ 64.8 682.003 0] /Next 18748 0 R /Prev 18745 0 R >> endobj 18748 0 obj << /Title (��ft�>�9���@+���*g��Qɪv\\r���%) /Border [0 0 0 []] /Parent 18737 0 R /Dest [238 0 R /XYZ 32.4 508.32 0] /Next 18742 0 R /Prev 18747 0 R >> endobj 18742 0 obj << /Title (�tј��g������1�S�d��!d��9) /Border [0 0 0 []] /Parent 18737 0 R /Dest [238 0 R /XYZ 32.4 406.98 0] /Prev 18748 0 R >> endobj 18744 0 obj << /Dest [239 0 R /XYZ 64.8 749.88 0] /Last 18749 0 R /Parent 18661 0 R /First 18750 0 R /Prev 18737 0 R /Count -5 /Next 18751 0 R /Title (����q) /Border [0 0 0 []] >> endobj 18750 0 obj << /Title (0�,��D��kW?g���9�\\b�5��) /Border [0 0 0 []] /Parent 18744 0 R /Dest [239 0 R /XYZ 64.8 688.761 0] /Next 18752 0 R >> endobj 18752 0 obj << /Dest [239 0 R /XYZ 64.8 377.584 0] /Last 18753 0 R /Parent 18744 0 R /First 18753 0 R /Prev 18750 0 R /Count -1 /Next 18754 0 R /Title (�B���,އ��u� �) /Border [0 0 0 []] >> endobj 18753 0 obj << /Title (���t�K��&"
    },
    {
        "link": "https://mm.bme.hu/~gyebro/files/ans_help_v182/ans_cmd/Hlp_C_CmdTOC.html",
        "document": "- Forms the absolute value of a variable. - Specifies the linear acceleration of the global Cartesian reference frame for the analysis. - Deletes nodes and area elements associated with selected areas. - Performs solutions and writes flexible body information to a modal neutral file ( ) for use in an ADAMS analysis. - Specifies the acceleration spectrum computation constants for the analysis of shock resistance of shipboard structures. - Lists keypoints of an area that lie on a parametric degeneracy. - Computes the aero-damping and stiffness coefficients and writes them to an APDL array. - Specifies the element size to be meshed onto areas. - Generates a fillet at the intersection of two areas. - Lists the current data in the database. - Generates surface elements overlaid on the surface of existing solid elements and assigns the extra node as the closest fluid element node. - Finds the intersection of an area with a volume. - Produces an animated sequence of contour values through substeps. - Saves or resumes an animation sequence to or from a file. - Produces an animated sequence of particle flow in a flowing fluid or a charged particle traveling in an electric or magnetic field. - Rotates the display about an axis. - Produces an animated sequence of time-harmonic results or complex mode shapes. - Produces an animated sequence of an isosurface. - Performs animation of results over multiple results files in an explicit dynamic structural analysis or fluid flow analysis with remeshing. - Produces an animated sequence of the time-harmonic pressure variation of an engine-order excitation in a cyclic harmonic analysis. - Specifies averaged nodal data to be stored from the results file in the solution coordinate system. - Creates an AQWA-LINE input file from the current Mechanical APDL model. - Creates an ASAS input file from the current ANSYS model. - Generates an area, offset from a given area. - Reads data from the results file and appends it to the database. - Controls termination of the solution when the arc-length method is used. - Refines the mesh around specified areas. - Generates an area in which to create a new mesh for rezoning. - Reverses the normal of an area, regardless of its connectivity or mesh status. - Generates cylindrical areas by rotating a line pattern about an axis. - Generates a scaled set of areas from a pattern of areas. - Generates areas from an area pattern by symmetry reflection. - Subtracts the intersection of the working plane from areas (divides areas). - Specifies the output type for an acoustic scattering analysis. - Prompts the user to input a parameter value. - Generates an area by \"skinning\" a surface through guiding lines. - Selects those areas containing the selected lines. - Selects those areas contained in the selected volumes. - Reassigns a file name to an ANSYS file identifier. - Generates an area using the shape of an existing area. - Calculates and prints geometry statistics of the selected areas. - Transfers a pattern of areas to another coordinate system. - Resets the focus and distance specifications to \"automatically calculated.\" - Specifies whether to use automatic time stepping or load stepping. - Specifies how principal and vector sums are to be calculated. - Specifies how results data will be averaged when PowerGraphics is enabled. - Labels the X and Y axes on graph displays.\n\n- Reactivates an element (for the birth and death capability). - Assigns mesh smoothing to explicit dynamic elements that use the ALE formulation. - Creates a part assembly to be used in an explicit dynamic analysis. - Creates a box shaped volume to be used in a contact definition for explicit dynamics. - Specifies additional contact parameters for a given contact definition in an explicit dynamic analysis. - Defines various types of constraints for an explicit dynamic analysis. - Constrains two rigid bodies to act as one in an explicit dynamics analysis. - Specifies whether to use subcycling in an explicit dynamics analysis. - Specifies mass scaling and scale factor of computed time step for an explicit dynamics analysis. - Defines mass weighted (Alpha) or stiffness weighted (Beta) damping for an explicit dynamics model. - Deletes or deactivates/reactivates contact surface specifications in an explicit dynamic analysis. - Activates initialization to a prescribed geometry or dynamic relaxation for the explicit analysis. - Allows plotting of explicit dynamics forces and other load symbols. - Displays only the common lines (“edges”) of an object. - Specifies the hourglass coefficient for an explicit dynamics analysis. - Specifies the time-history output interval for an explicit dynamics analysis. - Specifies number of integration points for explicit shell and beam output. - Defines inertia for rigid parts in an explicit dynamics analysis. - Defines a local coordinate system for use in explicit dynamics analysis. - Allows smoothing of noisy data for explicit dynamics analyses and provides a graphical representation of the data. - Specifies the type of output for an explicit dynamics analysis. - Applies initial velocities to parts or part assemblies in an explicit dynamic analysis. - Switches a part from deformable to rigid or from rigid to deformable in an explicit dynamic analysis. - Defines inertia properties for a new rigid body that is created when a deformable part is switched to rigid in an explicit dynamic analysis. - Specifies the output interval for an explicit dynamic analysis. - Specifies small penetration checking for contact entities in an explicit dynamic analysis. - Specifies status (new or restart) of an explicit dynamics analysis. - Applies initial velocities to nodes or node components in an explicit dynamic analysis. - Defines a massless spotweld or generalized weld for use in an explicit dynamic analysis. - Extrudes 2-D plane elements into 3-D solids during a 2-D to 3-D analysis. - Specifies the number of facets per element edge for PowerGraphics displays. - Deactivates an element (for the birth and death capability). - Specifies degrees of freedom to be coupled for end release and applies section constraints to elbow elements. - Lists the elements and their attributes. - Calculates the relative error in an electrostatic or electromagnetic field analysis. - Forces the writing of all the element matrices to File.EMAT. - Calculates the electromotive force (emf), or voltage drop along a predefined path. - Specifies emissivity as a material property for the Radiation Matrix method. - Adds more nodes to the just-defined element. - Specifies the system of units for magnetic field problems. - Defines an element by its number and node connectivity. - Specifies degrees of freedom to be decoupled for end release. - Specifies the total energies to be stored. - Specifies that the screen is to be erased before each display. - Refines the mesh around specified elements. - Specifies the element range to be read from a file. - Displays elements with shapes determined from the real constants, section definition, or other inputs. - Selects those elements associated with the selected areas. - Selects those elements associated with the selected lines. - Selects those elements attached to the selected nodes. - Selects elements associated with the selected volumes. - Specifies element data to be stored from the results file. - Generates elements overlaid on the free faces of selected nodes. - Fills a table of element values for further processing. - Changes element types to their corresponding types. - Control the element technologies used in element formulation (for applicable elements). - Stops the run and returns control to the system. - Specifies the options for the Mechanical APDL to ANSYS CFX profile file transfer. - Allows the creation of a larger graphic display than represented by the actual finite element analysis model. - Specifies an expansion pass of an analysis. - Exports a matrix to a file in the specified format. - Exports Mechanical APDL interface data on selected nodes to an ANSYS CFX Profile file. - Specifies the solution to be expanded for mode-superposition analyses or substructure analyses. - Controls options relating to the generation of volume elements from area elements. - Specifies the interface data unit labels to be written to the profile file from Mechanical APDL to ANSYS CFX transfer.\n\n- Forms an element table item by adding two existing items. - Transfers solid model loads and boundary conditions to the FE model. - Defines local coordinate systems at joint element nodes and other data for joint elements. - Sets the default section library path for the command. - Specifies locks on the components of relative motion in a joint element. - Plots the geometry of a beam, pipe, shell, or reinforcing section to scale. - Specifies stops on the components of relative motion in a joint element. - Defines the excitation direction for response spectrum and PSD analyses. - Lists the DOF solution of a superelement after the use pass. - Allows graphics data to be stored in the local terminal memory. - Performs a symmetry operation on a superelement within the use pass. - Defines the data set to be read from the results file. - Updates or defines the real constant table for squeeze film elements. - Forms an element table item by exponentiating and multiplying. - Allows safety factor or margin of safety calculations to be made. - Lists the surface loads for the specified area. - Calculates the safety factor or margin of safety. - Specifies that surface loads are to be accumulated. - Specifies surface loads on lines of an area. - Sets flexibility factors for the currently defined pipe element section. - Transfer the solid model surface loads to the finite element model. - Defines the type of surface shading used with Z-buffering. - Specifies the device and other parameters for graphics displays. - Creates or deletes a shell-solid interface to be used in shell-to-solid assemblies. - Summarizes the section properties for all defined sections in the current session. - Finds the smallest of three variables. - Forms an element table item from the maximum of two other items. - Controls the display of solid model boundary condition symbols and labels. - Specifies \"Body loads on the solid model\" as the subsequent status topic. - Specifies \"Constraints on the solid model\" as the subsequent status topic. - Specifies \"Forces on the solid model\" as the subsequent status topic. - Forms an element table item from the minimum of two other items. - Allows smoothing of noisy data and provides a graphical representation of the data. - Specifies \"Surface loads on the solid model\" as the subsequent status topic. - Forms an element table item by multiplying two other items. - Specifies solution summary data per substep to be stored. - Sorts the values of the specified vector. - Defines a space node for radiation using the Radiation Matrix method. - Defines a space node for radiation using the Radiosity method. - Defines a free-space ambient temperature for radiation using the Radiosity method. for multi-point spectrum analysis. - Defines the frequency points for the input spectrum tables vs.for multi-point spectrum analysis. - Creates a spherical volume anywhere on the working plane. - Displays the selected areas and a faceted view of their underlying surfaces - Calculates the state-space matrices and writes them to the SPM file. - Selects the spectrum type and other spectrum options. - Turns on a dashed tolerance curve for the subsequent curve plots. - Specifies the square root of sum of squares mode combination method. - Selects and displays small lines in the model. - Calculates and prints the sum of element table items. - Activates stabilization for all elements that support nonlinear stabilization. - Lists the status of items for the run. - Stores data in the database for the defined variables. - Reads results for the selected portions of the model. - Create new result data by operating on two existing result data sets on a given surface. - Delete geometry information as well as any mapped results for specified surface. - Perform operations on a mapped item and store result in a scalar parameter. - Moves surface geometry and mapped results to an array parameter. - Sets the type of summation to be used in the following load case operations. - Plot result data on all selected surfaces or on a specified surface. - Read a set of surface definitions and result items from a file and make them the current set. - Create new result data by operating on two existing result vectors on a given surface. - Defines spectrum values to be associated with frequency points. - Adds more surfaces to an existing spot weld set. - Specifies whether the excitation frequency is synchronous or asynchronous with the rotational velocity of a structure. - Passes a command string and arguments to the operating system.\n\n- Applies the absolute value function to array parameters. - Deletes nodes and volume elements associated with selected volumes. - Specifies the number of columns in matrix operations. - Forms element table items from the cross product of two vectors. - Allows array parameter results to add to existing results. - Specifies the velocity spectrum computation constants for the analysis of shock resistance of shipboard structures. - Lists keypoints of a volume that lie on a parametric degeneracy. - Forms an element table item from the dot product of two vectors. - Generates volumes by dragging an area pattern along a path. - Allows numerical array parameters to be graphically edited. - Specifies options for the view factor file and calculates view factors. - Retrieves values and stores them into an array parameter. - Defines the viewing direction for the display. - Improves the quality of the tetrahedral elements in the selected volume(s). - Forms an array parameter by interpolation of a table. - Specifies the number of rows to be used in array parameter operations. - Generates a scaled set of volumes from a pattern of volumes. - Reads data and produces an array parameter vector or matrix. - Generates cylindrical volumes by rotating an area pattern about an axis. - Subtracts intersection of the working plane from volumes (divides volumes). - Selects those volumes containing the selected areas. - Lists the current specifications for the array parameters. - Calculates and prints geometry statistics of the selected volumes. - Fills an existing unmeshed volume with elements by sweeping the mesh from an adjacent area through the volume. - Transfers a pattern of volumes to another coordinate system. - Specifies the viewing procedure used to determine the form factors for the Radiation Matrix method."
    },
    {
        "link": "https://mm.bme.hu/~gyebro/files/vem/ansys_13_command_reference.pdf",
        "document": ""
    },
    {
        "link": "https://padtinc.com/2013/08/29/20-apdl-commands-every-ansys-mechanical-user-should-know",
        "document": "Editors note: For over ten years, this article has been PADT’s most popular post. This shows how powerful the APDL language is and how building Ansys Mechanical on top of MAPDL was a good move. We have recently updated it a bit, and added some additional links at the bottom that you should check out, including an interview with John Swanson, the man who invented APDL. – 7/20/2022\n\nOne of the most powerful things about ANSYS Mechanical is the fact that it creates an input file of APDL commands that is sent to ANSYS Mechanical APDL (MAPDL) to solve. This is awesome because you, as a user, have complete and full access to the huge breadth and depth available in the MAPDL program. MAPDL is a good old-fashioned command-driven program that takes in text commands one line at a time and executes them. So to access all those features, you just need to enter in the commands you want.\n\nFor many older users, this is not a problem because we grew up using the text commands. But new users did not get the chance to be exposed to the power of APDL (ANSYS Parametric Design Language), so getting access to those advanced capabilities can be tough.\n\nIn fact, I was in a room next to one of our support engineers while they were showing a customer how to change the elements that the solver would solve (Mechanical defaults to the most common formulation, but you can change them to whatever still makes sense) and the user had to admit he had never really used or even seen APDL commands before.\n\nSo, as a way to get ANSYS Mechanical users out there started down the road of loving APDL commands, we got together and came up with a list of 20 APDL commands that every user should know. Well, actually, it is more than 20 because we grouped some of them together. We are not going to give too much detail on their usage, the APDL help is fantastic, and it explains everything.\n\nAlso, note that we are not getting into how to script with APDL. It is a truly parametric command language in that you can replace most values in commands with parameters. It also has control logic, functions, and other capabilities that you find in most scripting languages. We will focus on the actual commands you use to do things in the program here. If you want to learn more about how to program with APDL, you can purchase a copy of our “Introduction to the ANSYS Parametric Design Language” book. (another plug)\n\nAPDL was developed back in the day of punch cards. It was much easier to use than the other programs out there because the commands you entered didn’t have to be formatted in columns. Instead, arguments for commands are separated by commas. Therefore, instead of defining a Node in your model as:\n\n(note that the location of that decimal point is critical). You create a line as:\n\nTrust me, that was a big deal. But what you need to know now is that all APDL commands start with a keyword and are followed by arguments. The arguments are explained in the Command Reference in the help. So the entry for creating a node looks like this:\n\nThe documentation is very consistent and you will quickly get the hang of how to get what you need out of it. The layout is explained in the help: // Command Reference // 3. Command Dictionary\n\nAnother key thing to know about commands in MAPDL is that most entities you create (not loads and boundary conditions) have an ID number. You refer to entities by their ID number. This is a key concept that gets lost if you grew up using GUI’s. So if you want to make a coordinate system and use it, you define an ID for it and then refer to that ID. Same thing goes for element definitions (Element Types), material properties, etc… Remember this, it hangs up a lot of newer users.\n\nTo use MAPDL commands, you simply enter each command on a line in a command object that you place in your model tree. We did a seminar on this very subject about two years ago that you can watch here.\n\nThe idea of entity selection is fundamental to APDL. Above, we point out that all entities have an ID. You can interact with each entity by specifying its ID. But when you have a lot of them, like nodes and elements, it would be a pain. So APDL deals with this by letting you select entities of a given type and making them “selected” or “unselected” Then, when you execute commands, instead of specifying an ID, you can specify “ALL” and all of the selected entities are used for that command.\n\nSometimes we refer to entities as being selected, and sometimes we refer to them as “active.” The basic concept is that any entity in ANSYS Mechanical APDL can be one of two states: active/selected or inactive/unselected. inactive/unselected entities are not used by whatever command you might be executing.\n\nIf you want to see all of the APDL commands that ANSYS Mechanical writes out, simply select the setup branch of your model tree and choose Tools->Write Input File. You can view it in a text editor.\n\nOne last important note before we go through our list of commands: the old GUI for MAPDL can be used to modify or create models as well as ANSYS Mechanical. Every action you take in the old GUI is converted into a command and stored in the jobname.log file. Many users will carry out the actions they want in an interactive session, then save the commands they need from the log file.\n\nWait, one more thing: Right now, you need these commands. But at every release, more and more of the solver is exposed in ANSYS Mechanical GUI, and we end up using less and less APDL scripts. So before you write a script, make sure that ANSYS Mechanical can’t already do what you want.\n\nAn exclamation point is a comment in APDL. Any characters to the right of one are ignored by the program. Use them often and add great comments to help you and others remember what the heck you were trying to do.\n\nThe MAPDL program consists of a collection of 10 processors (there were more, but they have been undocumented.) Commands only work in some processors, and most only in one. If you enter in a preprocessor command when you are in the postprocessor, you will get an error.\n\nWhen you create a command object in your ANSYS Mechanical model, it will be executed in either the Pre processor, the Solution processor, or in the Post processor. Depending on where in the model tree you insert the command object. If you need to go into another processor, you can, you simply issue the proper command to change processors. JUST REMEMBER TO GO BACK TO THE PROCESSOR YOU STARTED IN when you are done with your commands.\n\n/PREP7 – goes to the pre processor. Use this to change elements, create things, or modify your mesh in any way.\n\n/SOLU – goes to the solution processor. Most of the time, you will start there, so you most often will use this command if you went into /PREP7 and need to get back. Modify loads, boundary conditions, and solver settings in this processor.\n\n/POST1 – goes to the post processor. This is where you can play with your results, make your own plots, and do some very sophisticated post-processing.\n\nFINISH – goes to the begin level. You will need to go there if you are going to play with file names.\n\nYou only really need to know these commands if you will be making your own elements… but one of those things everyone should know because the assignment of element attributes is fundamental to the way APDL works…. so read on even if you don’t need to make your own elements.\n\nEvery element in your model is assigned properties that define the element. When you define an element, instead of specifying all of its properties for each element, you create definitions and give them numbers, then assign the number to each element. The simplest example are material properties. You define a set of material properties, give it a number, then assign that number to all the elements in your model that you want to solve with those properties.\n\nBut you do not specify the ID’s when you create the elements. That would be a pain. Instead, you make the ID for each property type “active” and every element you create will be assigned the active ID’s.\n\nThe commands are self-explanatory: Type sets the Element Type, MAT sets the material ID, REAL set the real constant number, and SECNUM sets the active section number.\n\nSo, if you do the following:\n\nThe MAPDL solver supports hundreds of elements. ANSYS Mechanical picks the best element for whatever simulation you want to do from a general sense. But that may not be the best for your model. In such cases, you can redefine the element definition that ANSYS Mechanical used.\n\nNote: The new element must have the same topology. You can’t change a 4 noded shell into an 8 noded hex. But if the node ordering is the same (the topology) then you can make that change using the ET command.\n\nIf you define a real constant, element type, or material ID in APDL and you want to change a bunch of elements to those new ID’s, you use EMODIF. This is the fastest way to change an element’s definition.\n\nProbably the most commonly needed APDL command for ANSYS Mechanical users are the basic material property commands. Linear properties are defined with MP command for a polynomial vs. temperature or MPDATA and MPTEMP for a piece-wise linear temperature response. Nonlinear material properties are defined with the TB, TBDATA, and TBTEMP commands.\n\nIt is always a good idea to stick your material definitions in a text file so you 1) have a record of what you used, and 2) can reuse the material model on other simulation jobs.\n\nIf you define an elements formulation with options on the ET command and the material properties on the material commands, where do you specify other stuff like shell thickness, contact parameters, or hourglass stiffness? You put them in real constants. If you are new to the MAPDL solver, the idea of Real constants is a bit hard to get used to.\n\nThe official explanation is:\n\nIt really is a place to put stuff that has no other place. R creates a real constant, and RMODIF can be used to change them.\n\nAs mentioned, selection logic is a huge part of how MAPDL works. You never want to work on each object you want to view, change, load, etc… Instead, you want to place entities of a given type into an “active” group and then operate on all “active” entities. (you can group them and give them names as well, see CM-CMSEL-CMDELE below to learn about components)\n\nWhen accessing MAPDL from ANSYS Mechanical, you are most often working with either nodes or elements. NSEL and ESEL are used to manage what nodes and elements are active. These commands have a lot of options, so review the help.\n\nYou often select nodes and then need the elements attached to those nodes. Or you select elements, and you need the nodes on those elements. NSLE and ESLN do that. NSLE selects all of the nodes on the currently active elements and ESLN does the opposite.\n\nA very common mistake for people writing little scripts in APDL for ANSYS Mechanical is they use selection logic to select things that they want to operate on, and then they don’t remember to reselect all the nodes and elements. If you issue an NSEL and get, say the nodes on the top of your part that you want to apply a load to. If you just stop there, the solver will generate errors because those will be the only active nodes in the model.\n\nALLSEL fixes this. It simply makes everything active. It is a good idea to just stick it at the end of your scripts if you do any selecting.\n\nIf you use ANSYS Mechanical, you should be very familiar with the concept of Named Selections. These are groups of entities (nodes, elements, surfaces, edges, vertices) that you have put into a group so you can scope based on them rather than selecting each time. In ANSYS MAPDL, these are called components, and commands that work with them start with CM.\n\nAny named selection you create for geometry in ANSYS Mechanical gets turned into a nodal component – all of the nodes that touch the geometry in the Named Selection get thrown into the component. You can also create your own node or element Named Selections, and those also get created as components in MAPDL.\n\nYou can use CM to create your own components in your APDL scripts. You give it a name and operate away. You can also select components with the CMSEL command.\n\nThis is the single most awesomely useful command in APDL. It is a way to interrogate your model to find out all sorts of useful information: number of nodes, largest Z value for node position, if a node is selected, loads on a node, result information, etc…\n\nCheck out the help on the command. If you ever find yourself writing a script and going, “if I only knew blah de blah blah about my model…” then you probably need to use *get.\n\nCoordinate systems are very important in ANSYS Mechanical and ANSYS MAPDL. In most cases, you should create any coordinate systems you need in ANSYS Mechanical. They will be available to you in ANSYS MAPDL, but by default, ANSYS Mechanical assigns a default ID. To use a coordinate system in MAPDL you should specify the coordinate system number in the details for a given coordinate system by changing “Coordinate System” from “Program Defined” to “Manual” and then specifying a number for “Coordinate System ID”\n\nIf you need to make a coordinate system in your APDL script, use the LOCAL command.\n\nWhen you want to use a coordinate system, use CSYS to make a given coordinate system active.\n\nNote: Coordinate system 0 is the global Cartesian system. If you change the active coordinate system, make sure you set it back to the global system with CSYS,0\n\nRSYS is like CSYS but for results. If you want to plot or list result information in a coordinate system other than the global Cartesian, use RSYS to make the coordinate system you want active.\n\nOne thing to be very aware of is that each node in a model has a rotation associated with it. By default, the UX, UY, and UZ degrees of freedom are oriented with the global Cartesian coordinate system. In ANSYS Mechanical, when you specify a load or a boundary condition as normal or tangent to a surface, the program actually rotates all of those nodes, so a degree of freedom is normal to that surface.\n\nIf you need to do that yourself because you want to apply a load or boundary condition in a certain direction besides the global Cartesian, use NROTATE. You basically select the nodes you want to rotate, specify the active coordinate system with CSYS, then issue NROTATE,ALL to rotate them.\n\nBe careful, though. You don’t want to screw with any rotations that ANSYS Mechanical specified.\n\nThe most common boundary condition is displacement, even for temperature. To specify those in an ANSYS MAPDL script, use the D command. Most people use nodal selection or components to apply displacements to multiple nodes.\n\nIn its simplest form, you apply a single value for displacement to one node in one degree of freedom. But you can specify multiple nodes, multiple degrees of freedom, and more powerfully, the value for deflection can be a table. Learn about tables here.\n\nThe F command is the same as the D command, except it defines forces instead of displacement. Know, it, use it.\n\nIf you need to apply a pressure load, you use either SF to apply to nodes or SFE to apply to elements. It works a lot like the D and F commands.\n\nWhen the ANSYS MAPDL solver is solving away, it writes bits and pieces of information to a file called jobename.out, where jobname is the name of your solver job. Sometimes you may want to write out specific information, say list the stresses for all the currently selected nodes, to a file. use /OUTPUT,filename to redirect output to a file. When you are done, specify /OUTPUT with no options, and it will go back to the standard output.\n\nANSYS MAPDL has some very sophisticated plotting capabilities. There are a ton of commands and options used to set up and create a plot, but the most important is /SHOW,png. This tells ANSYS MAPDL that all plots from now on will be written in PNG format to a file. Read all about how to use this command, and how to control your plots, here.\n\nThe ANSYS MAPDL solver solves for a lot of values. The more complex the element you are using, the more the number of values you can store. But how do you get access to the more obscure ones? ETABLE. Issue 38 of The Focus from 2005 goes into some of the things you can do with ETABLE.\n\nWhere to go From Here\n\nThis is certainly not the definitive list. Ask 20 ANSYS MAPDL users what APDL commands all ANSYS Mechanical users should know, and you might get five or six in common. But based on the support calls we get and the scripts we write, these 20 are the most common that we use.\n\nCommand help is your friend here. Use it a lot.\n\nThe other thing you should do is open up ANSYS MAPDL interactively and play with these commands. See what happens when you execute them.\n\nAlso, if you are interested in how APDL came about, please listen to our interview with the founder of the company that became Ansys, the primary author of the solver in Ansys Mechanical APDL, and the man who created these APDL commands – John Swanson. None of this content and PADT itself would not exist without the vision he had.\n\nLearn more about APDL commands with PADT’s definitive guide: Introduction to the ANSYS Parametric Design Language"
    },
    {
        "link": "https://faculty.up.edu/lulay/ME304/CommonANSYS-APDLCommands.pdf",
        "document": ""
    },
    {
        "link": "https://dieter-wilhelm.github.io/apdl-mode/doc/A-M_APDL_reference.html",
        "document": "Called `parameter' in the Ansys manual. All numeric values are stored as double precision values. Not defined variables are assigned a tiny value near zero. The interpreter is not case sensitive :TODO except in strings?\n• Parameters must begin with a letter or an underscore\n\nThe following text is the respective Ansys solver/interpreter output.\n\nShould not begin with an underscore This convention is used in nameing variables in Ansys supplied macros and the GUI.\n• Variable names with a trailing underscore These are hidden from the `*status' command output and can be deleted as a group with `*del'.\n• Must contain only letters, numbers and underscores\n\nthe Ansys interpreter output looks like this:\n• Must contain no more than 32 characters"
    }
]