[
    {
        "link": "https://freecodecamp.org/news/javascript-debounce-example",
        "document": "In JavaScript, a debounce function makes sure that your code is only triggered once per user input. Search box suggestions, text-field auto-saves, and eliminating double-button clicks are all use cases for debounce.\n\nIn this tutorial, we'll learn how to create a debounce function in JavaScript.\n\nThe term debounce comes from electronics. When you‚Äôre pressing a button, let‚Äôs say on your TV remote, the signal travels to the microchip of the remote so quickly that before you manage to release the button, it bounces, and the microchip registers your ‚Äúclick‚Äù multiple times.\n\nTo mitigate this, once a signal from the button is received, the microchip stops processing signals from the button for a few microseconds while it‚Äôs physically impossible for you to press it again.\n\nIn JavaScript, the use case is similar. We want to trigger a function, but only once per use case.\n\nLet's say that we want to show suggestions for a search query, but only after a visitor has finished typing it.\n\nOr we want to save changes on a form, but only when the user is not actively working on those changes, as every \"save\" costs us a database trip.\n\nAnd my favorite‚Äîsome people got really used to Windows 95 and now double click everything üòÅ.\n\nThis is a simple implementation of the debounce function (CodePen here):\n\nIt can be used on an input:\n\nAnd on other elements like a simple JS function.\n\nSo what‚Äôs happening here? The is a special function that handles two tasks:\n‚Ä¢ Scheduling your function to be triggered at a specific time\n\nLet‚Äôs explain how this works in the first use case with text input.\n\nWhen a visitor writes the first letter and releases the key, the first resets the timer with . At this point, the step is not necessary as there is nothing scheduled yet. Then it schedules the provided function‚Äî ‚Äîto be invoked in 300 ms.\n\nBut let's say that the visitor keeps writing, so each key release triggers the again. Every invocation needs to reset the timer, or, in other words, cancel the previous plans with , and reschedule it for a new time‚Äî300 ms in the future. This goes on as long as the visitor keeps hitting the keys under 300 ms.\n\nThe last schedule won‚Äôt get cleared, so the will finally be called.\n\nThe other way around‚Äîhow to ignore subsequent events\n\nThat‚Äôs good for triggering auto-save or displaying suggestions. But what about the use case with multiple clicks of a single button? We don‚Äôt want to wait for the last click, but rather register the first one and ignore the rest (CodePen here).\n\nHere we trigger the function on the first call caused by the first button click. We schedule the timer destruction for 300 ms. Every subsequent button click within that timeframe will already have the timer defined and will only push the destruction 300 ms to the future.\n\nIn this article, I showed you how to implement a debounce function in JavaScript and use it to, well, debounce events triggered by website elements.\n\nHowever, you don‚Äôt need to use your own implementation of debounce in your projects if you don‚Äôt want to. Widely used JS libraries already contain its implementation. Here are a few examples:"
    },
    {
        "link": "https://stackoverflow.com/questions/75988682/debounce-in-javascript",
        "document": "I am currently learning debounce in Javascript and I came across two ways of writing debounce functions that works the same. One is a lot simpler like regular function, the other one is the complicated one that everyone seems to use.\n\nWhat is the difference between these two ways of debouncing if they both gives the same result? PS: I am surprised that I have never seen anyone use the 'version 2', ofcourse something must me wrong. Could anybody explain the differences please?"
    },
    {
        "link": "https://medium.com/@griffinmichl/implementing-debounce-in-javascript-eab51a12311e",
        "document": "I am generally pretty comfortable with `this`-binding in javascript, but today I managed to confuse myself for a few minutes. I was implementing a simple debounce function for fun and found myself lost in a web of `this`.\n\nDebouncing makes it so a function can only be executed after a certain amount of time since it was last invoked. For example, ‚Äúonly execute this function if it has been 1000 milliseconds since it was last invoked.‚Äù\n\nA common use case for debouncing is in search bars. We don‚Äôt want to make expensive http requests while the user is still typing their query, so we debounce the requesting function and only invoke it once the user has stopped typing.\n\nHere was my first attempt at implementing debounce.\n\nAt first glance, this seems to work as expected.\n\nAfter taking a look at underscore‚Äôs implementation of the same function, I realized that I had made a critical oversight. Namely, what happens when a debounced function is used as a method on an object?\n\nThat‚Äôs not right! Let‚Äôs figure out what‚Äôs going on here.\n\nWhen I invoke `func` inside setTimeout, it is a free function invocation. Free function invocations in javascript have `this` bound to the global scope. However, we want `this` to be bound to the context in which it was invoked (ie. the object amy).\n\nMy first attempt to solve this bug was to get the context when the debounced function is invoked and bind that to the original function via apply.\n\n`amy.speak` still yields ‚ÄòMy name is undefined‚Äô. The problem now is the lexical-`this` binding of arrow functions. With normal javascript functions, `this` is bound when the function is called. With arrow functions, `this` is bound to the context in which the function is originally created.\n\nThis is an awesome feature, usually. In conforms more to our intuition about how `this` should behave. But we cannot forget about `this` just because we have arrow functions, and this is a perfect example of why.\n\n`this` is still bound to the global scope in my updated function.\n\nWhen I call `debounce` on `sayHello`, the creation context is the global scope, since debounce is a free-function invokation. Therefore, the arrow function returned from debounce is also bound to the global scope.\n\nWe specifically want `this` to be set at call-time, so an arrow function is the wrong tool entirely. By switching from an arrow function to a traditional anonymous function, we obtain a fully working solution.\n\nThe moral of the story is that arrow functions don‚Äôt absolve you from thinking hard about `this`-binding. In fact, it is more important than ever to have a strong grasp of how `this` behaves in javascript. If I had done the following, no fancy work inside my debounce function could have saved me. `sayHello` would be inextricably bound to the global scope.\n\nKeep this advice this in mind when using 3rd-party libraries as well. D3 and Mocha come to mind as libraries that can behave unexpectedly if you pass arrow functions as callbacks.\n\nArrow functions are great, but you need to know how they work, when to use them, and when to avoid them."
    },
    {
        "link": "https://geeksforgeeks.org/debouncing-in-javascript",
        "document": "In JavaScript, debouncing is a technique used to ensure that a function is not called too frequently. It is commonly used in scenarios where events are triggered rapidly, such as typing in an input field or resizing a window. Without debouncing, functions might be executed many times in quick succession, causing performance issues or unwanted behaviour.\n\nWhat is Debouncing in JavaScript?\n\nDebouncing in JavaScript can be defined as the technique that is used to limit the number of times a function gets executed. Debouncing is useful when the event is frequently being triggered in a short interval of time like typing, scrolling, and resizing.\n‚Ä¢ Limit Function Calls: During frequent events like typing, resizing, or scrolling debouncing prevents the frequent function calls.\n‚Ä¢ Delays Execution: After the specific delay only the function is executed, ensuring no rapid consecutive calls.\n\nIn this example\n‚Ä¢ debounce() function: It is the higher order function that takes (delay) and function(func) as the arguments. It returns a new function that will wait for the specified delay before calling the original function.\n‚Ä¢ clearTimeout(): It is used to clear any previous set timeout so that if the event is triggered repeatedly the function call does not happen too quickly.\n‚Ä¢ setTimeout(): This method is used to set the timeout after clearing the previous timeouts.\n‚Ä¢ Search function: It is the placeholder for the function we want to debounce.\n\nIn JavaScript the debouncing function works when the event is being triggered. The Debounce wait for the specific period to run the function, it doesn‚Äôt run the function immediately. If before the wait time is over, the event is triggered again then the previous function call is canceled and it resets the timer. Once the timer completes without any further event triggers, the function is executed. This ensures that the function is executed only after the event stops occurring for a specific period.\n\nUse Cases for Debouncing in JavaScript\n\nThe use cases of the debouncing in javaScript are mentioned below:\n‚Ä¢ Search Input Field: In the search bar, the user types characters one after another due to which for each key press an API request is triggered. Debouncing makes sure that the API request is only sent when the user has finished typing.\n‚Ä¢ Window Resizing: When we resize the window browser, in a short interval of time the resize event gets fired multiple times. Debouncing can be used in handling this event.\n‚Ä¢ Scroll Events: When the user scrolls the webpage the scroll event is triggered multiple times per second. By debouncing the event, the scroll handler function is executed only after the user has stopped scrolling for a specific duration.\n‚Ä¢ Form Validation: If in real-time we are validating a form as the user types, debouncing can be used to ensure that for every keystroke the validation function is not repeatedly triggered.\n‚Ä¢ Improved Performance: Debouncing helps in optimizing the performance by reducing the number of times of function execution, especially when we are handling frequent events like type. This reduces unnecessary resource usage.\n‚Ä¢ Better User Experience: When the events are rapidly triggered then also the application remains responsive with debouncing.\n‚Ä¢ Prevents Redundant API Calls: Debouncing ensures that the API requests are only sent when the user stops interacting with the page for a specific time. This helps the server from crashing with repeated requests.\n\nDebouncing and Throttling both are used for limiting the function calls during an event, but they both work in different ways:\n‚Ä¢ Debouncing: In Debouncing the function is called only when the event stops occurring for a specific time.\n‚Ä¢ Throttling: In throttling at regular intervals the function is called (every 100ms), even if the event has occurred multiple times during that duration.\n\nExecutes a function only after a specified delay with no further events during that time. Executes a function at regular intervals, no matter how frequently the event occurs. After the event stops firing for a set time. At fixed intervals, regardless of the event frequency. Delays the function call until the event stops. Limits the function call to a specific interval, regardless of continuous events. The function is called once after the event stops firing for a defined time. The function is called every X milliseconds, even if the event triggers more frequently.\n\nWhen to Use Debouncing\n\nWe can use the debouncing in the following conditions:\n‚Ä¢ None When we are dealing with operations like API calls then we can prevent unnecessary network requests to optimize the performance.\n‚Ä¢ None We can prevent the lags or delays due to repeated function execution to improve the user experience.\n‚Ä¢ None We can limit the function calls triggered by frequent user actions such as typing, and crolling.\n\nWhat is debouncing in JavaScript?\n\nWhen should I use debouncing in JavaScript?\n\nHow is debouncing different from throttling?\n\nCan debouncing improve the performance of a web application?\n\nHow do I debounce an API call in JavaScript?"
    },
    {
        "link": "https://greatfrontend.com/questions/javascript/debounce",
        "document": "Debounce, along with throttle, are among the most common front end interview questions; it's the front end equivalent of inverting a binary tree. Hence you should make sure that you are very familiar with the question.\n\nGiven that there's a duration before the function can be invoked, we know that we will need a timer, and is the first thing that comes to mind.\n\nWe will also need to return a function which wraps around the callback function parameter. This function needs to do a few things:\n‚Ä¢ It invokes the callback function only after a delay of . This is performed using . Since we might need to clear the timer if the debounced function is called again while there's a pending invocation, we need to retain a reference to a , which is the returned value of .\n‚Ä¢ If the function is called again while there's a pending invocation, we should cancel existing timers and schedule a new timer for the delayed invocation with the full duration. We can cancel the timer via .\n\n2) Calls the callback function with the right parameters\n\nDebounced functions are used like the original functions, so we should forward the value of and function arguments when invoking the original callback functions.\n\nYou may be tempted to use but will be lost if callback functions are invoked that way. Hence we have use / which allows us to specify as the first argument.\n\nThe main pitfall in this question is invoking the callback function with the correct , the value of when the debounced function was called. Since the callback function will be invoked in a timeout, we need to ensure that the first argument to / is the right value. There are two ways to achieve this:\n‚Ä¢ Use another variable to keep a reference to and access via that variable from within the callback. This is the traditional way of preserving before arrow functions existed.\n‚Ä¢ Use an arrow function to declare the callback where the value within it has lexical scope. The value of within arrow functions is bound to the context in which the function is created, not to the environment in which the function is called.\n\nAlso, we should not implement the returned function using an arrow function for reasons mentioned above. The value of the returned function needs to be dynamically determined when executed.\n\nRead this article for a more in-depth explanation.\n\nis a forgiving function and passing an invalid ID to silently does nothing; no exception is thrown. Hence we don't have to check for before using ."
    },
    {
        "link": "https://dev.to/jeetvora331/throttling-in-javascript-easiest-explanation-1081",
        "document": "Throttling is a technique that limits how often a function can be called in a given period of time. It is useful for improving the performance and responsiveness of web pages that have event listeners that trigger heavy or expensive operations, such as animations, scrolling, resizing, fetching data, etc.\n\nFor example, if you have a function that fetches some data from an API every time the user scrolls the page, you might want to throttle it so that it only makes one request every second, instead of making hundreds of requests as the user scrolls. This way, you can avoid overloading the server or the browser with unnecessary requests and reduce the bandwidth consumption.\n\nHow to Implement Throttling in JavaScript?\n\nThere are several ways to implement throttling in JavaScript. One common approach is to use a timer function such as or difference of time method (old method) to wrap the function being throttled. The timer function can be used to enforce a delay between calls to the throttled function, allowing it to be called only once within the specified time period.\n\nPictorial Representation\n\n Here you can see that once the function is executed successfully it starts a blocking delay timer which blocks all the clicks. Once the delay is expired it accepts the clicks and executes the function.\n\nHere‚Äôs an example of how to implement a throttle function using :\n\nIn this example, we define a function that takes a and a delay as arguments. The function returns a new function that wraps the with a logic that uses to create a timer. The timer ensures that the callback is only called once within the period. If the returned function is called again before the timer expires, it does nothing.\n\nWe then define a function that simulates an API call with a random delay. We use the function to create a function that has a delay of 5000 ms. We add an event listener to the window scroll event that calls the function.\n\nIf you run this code and scroll the page, you will see that the function is only called once every 5 second, regardless of how fast or slow you scroll.\n\nThrottling can improve the performance and user experience of web pages by reducing the number of unnecessary or redundant operations. It can also prevent some issues such as:\n‚Ä¢ Overloading the server or the browser with too many requests or calculations\n‚Ä¢ Exceeding the rate limits or quotas of APIs or services\n‚Ä¢ Wasting bandwidth or resources on operations that are not visible or relevant to the user\n\nNon Tech Example of throttling:\n\nChanging speed of Fan\n\n When changing speed of fan, it takes few seconds to reach at the desired speed. Thus before changing the speed again, we need to wait for few seconds so the fan reaches at a steady state.\n\nWhen to Use Throttling?\n\nThrottling is suitable for scenarios where you want to limit how often a function can be called, but you don‚Äôt want to miss any calls. For example, you might want to use throttling for:\n‚Ä¢ Fetching data from an API or a database when the user scrolls, resizes, or types\n‚Ä¢ Updating or animating elements on the page when the user scrolls, resizes, or moves the mouse\n‚Ä¢ Logging or tracking user actions or events when they occur frequently\n\nThrottling is a technique that limits how often a function can be called in a given period of time. It is useful for improving the performance and responsiveness of web pages that have event listeners that trigger heavy or expensive operations. Throttling can be implemented in JavaScript using timer functions such as setTimeout or setInterval. Throttling is suitable for scenarios where you want to limit how often a function can be called, but you don‚Äôt want to miss any calls.\n\nI hope you found this blog helpful and learned something new about throttling in JavaScript. You can check out my article on Debouncing in JavaScirpt Here.\n\nIf you have any questions or feedback, please feel free to leave a comment below. Thanks for reading! üòä"
    },
    {
        "link": "https://geeksforgeeks.org/javascript-throttling",
        "document": "Throttling is a technique used to limit the number of times a function can be executed in a given time frame. It‚Äôs extremely useful when dealing with performance-heavy operations, such as resizing the window or scrolling events, where repeated triggers can lead to performance issues.\n\nIn this example\n‚Ä¢ None The throttle function takes a function (fn) and a delay (delay) as parameters.\n‚Ä¢ None It keeps track of the last execution time using lastTime.\n‚Ä¢ None When the function is called, it checks if the time difference from the last execution is greater than or equal to the delay.\n‚Ä¢ None If so, it executes the function and updates lastTime.\n\nCertain user interactions, like scrolling or window resizing, trigger events multiple times per second. Executing event handlers at such a high frequency can lead to performance issues, including:\n\nBy throttling a function, we can ensure it executes at a controlled rate, reducing resource consumption and improving responsiveness.\n\nThrottling works by restricting the execution of a function so that it runs at most once every predefined period, even if the event is triggered multiple times within that interval.\n‚Ä¢ None A function is triggered multiple times due to an event (e.g., scroll, resize).\n‚Ä¢ None Throttling ensures that the function executes only once within the defined interval.\n‚Ä¢ None Any additional triggers during the interval are ignored until the next cycle starts.\n‚Ä¢ None Once the interval is over, the function can execute again if triggered.\n\nA simple way to implement throttling is by using setTimeout. The function execution is delayed and only runs after the specified time interval has passed.\n\nAnother approach is to use Date.now() to keep track of the last execution time and determine when the function should be called again.\n\nBoth throttling and debouncing are techniques for controlling function execution, but they serve different purposes:\n\nThrottling is commonly used in cases where frequent execution of a function can cause performance issues."
    },
    {
        "link": "https://medium.com/@techsuneel99/throttling-in-javascript-3765384c1523",
        "document": "Throttling is a crucial technique in JavaScript for optimizing performance and managing resource utilization. It‚Äôs particularly useful when dealing with events that can fire at a high frequency, such as scrolling, resizing, or user input. In this article, we‚Äôll explore the concept of throttling, its benefits, and how to implement it in JavaScript with various use cases and examples.\n\nThrottling is a technique that limits the rate at which a function can be called. It ensures that a function is executed at most once in a specified time interval, regardless of how many times it‚Äôs invoked. This is particularly useful for performance-intensive operations or when you want to control the rate of API calls.\n\nYou can check these resources for Coding interview Preparation\n‚Ä¢ When a throttled function is called, it checks if enough time has passed since its last execution.\n‚Ä¢ If the time threshold has not been met, the function call is ignored.\n‚Ä¢ If the time threshold has been met, the function is executed and the timer is reset.\n‚Ä¢ Performance Optimization: Reduces the number of executions for resource-intensive‚Ä¶"
    },
    {
        "link": "https://linkedin.com/pulse/implementing-throttle-function-javascript-laurence-svekis--rchac",
        "document": "In web development, we often encounter scenarios where a function needs to be executed repeatedly in response to events like scrolling, resizing, or mouse movements. However, triggering the function too frequently can lead to performance issues, such as slowing down the browser. This is where throttling comes in handy.\n\nThrottling is a technique that ensures a function is called at most once within a specified time frame, regardless of how many times the event is triggered. This can be particularly useful for handling high-frequency events without overwhelming the browser.\n‚Ä¢ Function Declaration:The throttle function takes two arguments: fn (the function to be throttled) and limit (the time frame in milliseconds within which fn can only be called once).\n‚Ä¢ Tracking the Last Call:Inside the throttle function, we declare a variable lastCall, initially set to 0. This variable will keep track of the timestamp of the last function call.\n‚Ä¢ Returning a New Function:The throttle function returns a new function that wraps the original fn function. This returned function can accept any number of arguments (...args), which are then passed to fn when it‚Äôs called.\n‚Ä¢ Conditional Execution:Inside the returned function, we get the current time using Date.now().We check if the difference between now and lastCall is greater than or equal to limit. If it is, we update lastCall to now and execute the original fn function with the provided arguments.\n‚Ä¢ onScroll Function:This function logs the current time to the console whenever the user scrolls the window.\n‚Ä¢ Throttle Application:We use the throttle function to ensure that onScroll is called at most once every second (1000 milliseconds) while the user is scrolling. Even if the user scrolls rapidly, onScroll will only be executed once per second, preventing the browser from being overwhelmed by too many function calls.\n\nThrottling is particularly useful for optimizing performance in scenarios where events are triggered frequently. For example, it helps:\n‚Ä¢ Reduce the number of function executions during scroll or resize events.\n‚Ä¢ Improve the responsiveness of your web application.\n‚Ä¢ Prevent the browser from being bogged down by unnecessary processing.\n\nThe throttle function is a powerful tool in the web developer‚Äôs toolkit. By controlling the rate at which a function is executed, it helps maintain optimal performance, especially during high-frequency events. Whether you‚Äôre building a smooth scrolling experience or optimizing resource-intensive tasks, throttling can make a significant difference in the performance and user experience of your web application."
    },
    {
        "link": "https://syncfusion.com/blogs/post/javascript-debounce-vs-throttle",
        "document": "Performance is one of the most crucial aspects of modern web applications. As developers, we follow various techniques to enhance application performance and provide a better user experience. For example, debouncing and throttling are two simple, yet powerful techniques we can use in JavaScript applications to improve performance.\n\nIn this article, I will introduce debouncing and throttling in JavaScript, compare them, and discuss why we need to use them.\n\nWhy do we need to debounce and throttle?\n\nUsually, developers have the freedom to decide when to call a function. But sometimes, they have to hand over control to users. For example, event triggers are widely used in applications to trigger functions based on events like key presses, button clicks, and mouse movements. In such situations, users can trigger those events far more than required and cause significant performance issues in the application.\n\nFor example, consider a search bar where we need to display a suggestion list as the user types. We can implement this using an event listener to bring data from the backend on each key press. However, it will negatively impact application performance, since it will make an API call each time the user presses a key.\n\nThe following code shows an example of this scenario. It will make 10 API calls if we type the word JavaScript.\n\n // index.html\n\nYou can find a working example of this code in StackBlitz.\n\nAs you can see, there is a significant number of unnecessary API calls in the previous example. In such situations, we can use debouncing and throttling to reduce the number of API calls triggered by the user event and improve the application performance without any drag on the user experience.\n\nSo, let‚Äôs see these two techniques and how we can implement them.\n\nThe concept of debouncing is pretty straightforward. It delays the function invocation by a defined period of time to avoid unnecessary invocations. So, the function will only be invoked if no event is triggered within that time. If the user triggers a new event during that time, the time will be reset.\n\nLet‚Äôs consider the previous example again. The issue with the scenario was unnecessary API calls. So, if we define a debounce function with a delay of one second, it will hold back the API call until one second passes without any user events. If the user presses a key within that second, the debounce function will reset the delay and wait for another second to make the API call.\n\nWe can easily implement a debounce function using the setTimeout() and clearTimeout() functions. It should also take a callback function and the delay as input parameters.\n\nAs you can see, the debounce function acts as a wrapper for the callback function and ensures that it will be invoked after the delay. In this case, the default delay is 1,000 milliseconds.\n\nLet‚Äôs now modify the search bar example code with a debounce function.\n\nAlthough the user has typed the word JavaScript, only a single API call has been invoked. So, debouncing has blocked nine unnecessary API calls from the previous example. You can find a working example of this code in StackBlitz.\n\nThrottle is another technique to minimize unnecessary function invocations when using event listeners. However, throttle works a bit differently from debouncing. Instead of delaying, it invokes the callback function at regular intervals as long as the event trigger is active.\n\nFor example, assume we have defined the delay as one second in a throttle function. First, it will invoke the callback function immediately. Then, it will use the delay time as the waiting time and invoke the callback function every second until the event trigger becomes inactive.\n\nWe can implement a throttle function using the setTimeout() function and a flag variable. It should take a callback function and the delay as input parameters.\n\nIn debouncing, we implemented the debounce function as a wrapper of the callback function, since we delay the callback function invocation. But in throttle implementation, we immediately invoke the callback function if the shouldWait flag is false. Then, the setTimeout() function is used to update the flag value based on the delay we define.\n\nThe following code shows the initial search bar example optimized with a throttle function.\n\nAs you can see, only three API calls were made in this example when I typed the word JavaScript. The first call is the initial call, and the other two were made after 5 and 10 key presses, respectively. So, the throttle function has reduced seven unnecessary API calls. You can find a working example of this code in StackBlitz.\n\nDebounce monitors the time delay between user actions and only executes the callback function if the delay exceeds the time delay defined by the developer. So, continuous user actions can significantly delay the callback function‚Äôs execution if we use debounce.\n\nOn the other hand, throttle uses the time delay to execute the callback function at regular intervals until the event trigger is active. So, it does not delay the callback function execution for a significant period like debounce.\n\nWhen to use what\n\nI explained both debounce and throttle using a search bar example with key press events. However, there are some specific scenarios where we should use one or the other of these techniques:\n‚Ä¢ Debounce is most suitable for control events like typing or button clicks.\n‚Ä¢ Throttle is most suitable for continuous user events like resizing and scrolling.\n\nThis article discussed how we could use debounce and throttle to handle user events and minimize unnecessary function executions in JavaScript applications. Ultimately, these two techniques can significantly improve your application‚Äôs performance since they can avoid many unnecessary API calls, DB queries, and so on. So, give them a try when implementing event triggers on your next application.\n\nThank you for reading!\n\nSyncfusion‚Äôs Essential JS 2 is the only suite you will ever need to build an app. It contains over 65 high-performance, lightweight, modular, and responsive UI components in a single package. Download a free trial to evaluate the controls today.\n\nIf you have any questions or comments, you can contact us through our support forums, support portal, or feedback portal. We are always happy to assist you!\n‚Ä¢ JavaScript Debugging with VS Code and Chrome\n‚Ä¢ JavaScript String Manipulation Techniques Every Developer Should Know"
    }
]