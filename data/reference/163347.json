[
    {
        "link": "https://x6.antv.vision",
        "document": ""
    },
    {
        "link": "https://github.com/antvis/G6",
        "document": "G6 is a graph visualization engine. It provides basic capabilities for graph visualization and analysis such as drawing, layout, analysis, interaction, animation, themes, and plugins. With G6, users can quickly build their own graph visualization and analysis applications, making relational data simple, transparent, and meaningful.\n\nG6, as a professional graph visualization engine, boasts the following features:\n• Rich Elements: It comes with a variety of built-in node, edge, and Combo UI elements with extensive style configurations, supports data callbacks, and has a flexible mechanism for extending custom elements.\n• Controllable Interactions: It includes more than 10 built-in interaction behaviors and offers a rich array of events, facilitating the expansion of custom interactive behaviors.\n• High-Performance Layout: The engine features more than 10 common graph layouts, some of which leverage GPU and Rust parallel computing for enhanced performance, and it supports custom layout development.\n• Convenient Plugins: Optimized built-in plugin functionality and performance, with flexible extensibility, making it easier to implement customized business capabilities.\n• Multiple Theme and Palettes: Provides two sets of built-in themes, light and dark, that integrate over 20 popular community color palettes based on the AntV new color scheme.\n• Multi-Environment Rendering: Harnessing the power of G, it supports rendering in Canvas, SVG, and WebGL, as well as server-side rendering with Node.js; it also offers plugin packages that provide powerful 3D rendering and spatial interactions based on WebGL.\n• React Ecosystem: By utilizing the React front-end ecosystem, it supports React nodes, significantly enriching the presentational styles of G6 nodes.\n\nG6 is usually installed via a package manager such as npm or Yarn.\n\nThe object then can be imported from G6.\n\nAll goes well, you can get the following lovely graph!\n• Graphin: A simple React wrapper based on G6, as well as an SDK for developing graph visualization applications.\n\nFor more ecosystem open-source projects, contributions are welcome. Please feel free to submit a PR for inclusion.\n• Issue Reporting: If you encounter any issues with G6 during use, please feel free to submit an issue, along with the minimal sample code that can reproduce the problem.\n• Contribution Guide: Information on how to get involved in the development and contribution to G6.\n• Ideas Discussion: Discuss your ideas on GitHub Discussions or in the DingTalk group."
    },
    {
        "link": "https://g6.antv.vision/en/api/reference/g6/canvas",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/2142535/how-to-clear-the-canvas-for-redrawing",
        "document": "I need to clear the canvas for redrawing other images; this can go on for a while so I don't think drawing a new rectangle every time will be the most efficient option.\n\nAfter experimenting with composite operations and drawing images on the canvas I'm now trying to remove images and compositing. How do I do this?\n\nThis is the fastest and most descriptive way to clear the entire canvas. Do not use: Resetting resets all canvas state (e.g. transformations, lineWidth, strokeStyle, etc.), it is very slow (compared to clearRect), it doesn't work in all browsers, and it doesn't describe what you are actually trying to do. If you have modified the transformation matrix (e.g. using , , or ) then will likely not clear the entire visible portion of the canvas. The solution? Reset the transformation matrix prior to clearing the canvas: // Store the current transformation matrix context.save(); // Use the identity matrix while clearing the canvas context.setTransform(1, 0, 0, 1, 0, 0); context.clearRect(0, 0, canvas.width, canvas.height); // Restore the transform context.restore(); Edit: I've just done some profiling and (in Chrome) it is about 10% faster to clear a 300x150 (default size) canvas without resetting the transform. As the size of your canvas increases this difference drops. That is already relatively insignificant, but in most cases you will be drawing considerably more than you are clearing and I believe this performance difference be irrelevant. 100000 iterations averaged 10 times: 1885ms to clear 2112ms to reset and clear\n\nOthers have already done an excellent job answering the question but if a simple method on the context object would be useful to you (it was to me), this is the implementation I use based on answers here: window.onload = function () { var canvas = document.getElementById('canvasId'); var context = canvas.getContext('2d'); // do some drawing context.clear(); // do some more drawing context.setTransform(-1, 0, 0, 1, 200, 200); // do some drawing with the new transform context.clear(true); // draw more, still using the preserved transform };\n\nThis is 2018 and still there is no native method to completely clear canvas for redrawing. does not clear the canvas completely. Non-fill type drawings are not cleared out (eg. ) 1.To completely clear canvas irrespective of how you draw: Cons: Unnecessary if you are already using beginPath before drawing anything I was wondering why a native solution does not exist. Actually, is considered as the single line solution because most users do before drawing any new path. Though beginPath is only to be used while drawing lines and not closed path like This is the reason why the accepted answer did not solve my problem and I ended up wasting hours trying different hacks. Curse you mozilla\n\nThere is now a method which will not only clear the canvas buffer but also completely reset all the properties of the context (styles etc.), reset its transformation matrix, clear its current sub-path, clear its states stack (the one controlled by and ), and remove all the clipping regions. context.reset(); // now 'context' is clear as new Basically, it has the same effects as , except that it's more idiomatic. However it seems that in current Chromium's implementation it's as slow as , it also does generate a new buffer instead of simply clearing the previous one (resulting in more memory garbage). Another caveat is that it's currently only supported in Chromium browsers. Though to polyfill it you can go the Chrome way\n\nThis is a Free hand drawing Canvas with a Clear Canvas Button.\n\n See this live example of a canvas which you can draw on and also when required clear it for redrawing is used to delete the prersent canvas and is used to again draw the initial canvas which was clean and had no drawings on it. var canvas = document.getElementById(\"canvas\"), ctx = canvas.getContext(\"2d\"), painting = false, lastX = 0, lastY = 0, lineThickness = 1; canvas.width=canvas.height = 250; ctx.fillRect(0, 0, 250, 250); canvas.onmousedown = function(e) { painting = true; ctx.fillStyle = \"#ffffff\"; lastX = e.pageX - this.offsetLeft; lastY = e.pageY - this.offsetTop; }; canvas.onmouseup = function(e){ painting = false; } canvas.onmousemove = function(e) { if (painting) { mouseX = e.pageX - this.offsetLeft; mouseY = e.pageY - this.offsetTop; // find all points between var x1 = mouseX, x2 = lastX, y1 = mouseY, y2 = lastY; var steep = (Math.abs(y2 - y1) > Math.abs(x2 - x1)); if (steep){ var x = x1; x1 = y1; y1 = x; var y = y2; y2 = x2; x2 = y; } if (x1 > x2) { var x = x1; x1 = x2; x2 = x; var y = y1; y1 = y2; y2 = y; } var dx = x2 - x1, dy = Math.abs(y2 - y1), error = 0, de = dy / dx, yStep = -1, y = y1; if (y1 < y2) { yStep = 1; } lineThickness = 4; for (var x = x1; x < x2; x++) { if (steep) { ctx.fillRect(y, x, lineThickness , lineThickness ); } else { ctx.fillRect(x, y, lineThickness , lineThickness ); } error += de; if (error >= 0.5) { y += yStep; error -= 1.0; } } lastX = mouseX; lastY = mouseY; } } var button=document.getElementById(\"clear\"); button.onclick=function clearcanvas(){ canvas=document.getElementById(\"canvas\"), ctx = canvas.getContext('2d'); ctx.clearRect(0, 0, 250, 250); canvas.width=canvas.height = 250; ctx.fillRect(0, 0, 250, 250);}\n\nIf you do not use transformations this would do the thing: I usually fill the full canvas with a rect of background color If transformations are applied — you can and do some school math to clear the canvas in the applied transform space. It is not so complicated, but I spent some time yesterday with paper when I needed to transform the mouse position to the local space of each drawn element (for collision check): a, b, c, d, e, f — is the canvas matrix data, X, Y — mouse position, and x, y — position in local space You would need to do it for all 4 corners (0,0), (w,0), (w,h), (0,h), then get min/max of all results x, and y, then or for rect with arguments: (minX, minY, maxX-minX, maxY-minY) I do not think it would be optimal in the performance term way. Actually, I thought that the most performant way would be to of an empty canvas and put it back by the method, but performance tests show that this is not the case. An optimal way to clear if transformations are applied is: Here is a jsperf link with all options that I've tried."
    },
    {
        "link": "https://cdnjs.com/libraries/antv-x6/2.5.5",
        "document": "JavaScript diagramming library that uses SVG and HTML for rendering.\n\nYou can contribute on GitHub to help make cdnjs sustainable! Or, donate $5 to cdnjs via Open Collective or Patreon."
    },
    {
        "link": "https://stackoverflow.com/questions/2142535/how-to-clear-the-canvas-for-redrawing",
        "document": "I need to clear the canvas for redrawing other images; this can go on for a while so I don't think drawing a new rectangle every time will be the most efficient option.\n\nAfter experimenting with composite operations and drawing images on the canvas I'm now trying to remove images and compositing. How do I do this?\n\nThis is the fastest and most descriptive way to clear the entire canvas. Do not use: Resetting resets all canvas state (e.g. transformations, lineWidth, strokeStyle, etc.), it is very slow (compared to clearRect), it doesn't work in all browsers, and it doesn't describe what you are actually trying to do. If you have modified the transformation matrix (e.g. using , , or ) then will likely not clear the entire visible portion of the canvas. The solution? Reset the transformation matrix prior to clearing the canvas: // Store the current transformation matrix context.save(); // Use the identity matrix while clearing the canvas context.setTransform(1, 0, 0, 1, 0, 0); context.clearRect(0, 0, canvas.width, canvas.height); // Restore the transform context.restore(); Edit: I've just done some profiling and (in Chrome) it is about 10% faster to clear a 300x150 (default size) canvas without resetting the transform. As the size of your canvas increases this difference drops. That is already relatively insignificant, but in most cases you will be drawing considerably more than you are clearing and I believe this performance difference be irrelevant. 100000 iterations averaged 10 times: 1885ms to clear 2112ms to reset and clear\n\nOthers have already done an excellent job answering the question but if a simple method on the context object would be useful to you (it was to me), this is the implementation I use based on answers here: window.onload = function () { var canvas = document.getElementById('canvasId'); var context = canvas.getContext('2d'); // do some drawing context.clear(); // do some more drawing context.setTransform(-1, 0, 0, 1, 200, 200); // do some drawing with the new transform context.clear(true); // draw more, still using the preserved transform };\n\nThis is 2018 and still there is no native method to completely clear canvas for redrawing. does not clear the canvas completely. Non-fill type drawings are not cleared out (eg. ) 1.To completely clear canvas irrespective of how you draw: Cons: Unnecessary if you are already using beginPath before drawing anything I was wondering why a native solution does not exist. Actually, is considered as the single line solution because most users do before drawing any new path. Though beginPath is only to be used while drawing lines and not closed path like This is the reason why the accepted answer did not solve my problem and I ended up wasting hours trying different hacks. Curse you mozilla\n\nThere is now a method which will not only clear the canvas buffer but also completely reset all the properties of the context (styles etc.), reset its transformation matrix, clear its current sub-path, clear its states stack (the one controlled by and ), and remove all the clipping regions. context.reset(); // now 'context' is clear as new Basically, it has the same effects as , except that it's more idiomatic. However it seems that in current Chromium's implementation it's as slow as , it also does generate a new buffer instead of simply clearing the previous one (resulting in more memory garbage). Another caveat is that it's currently only supported in Chromium browsers. Though to polyfill it you can go the Chrome way\n\nThis is a Free hand drawing Canvas with a Clear Canvas Button.\n\n See this live example of a canvas which you can draw on and also when required clear it for redrawing is used to delete the prersent canvas and is used to again draw the initial canvas which was clean and had no drawings on it. var canvas = document.getElementById(\"canvas\"), ctx = canvas.getContext(\"2d\"), painting = false, lastX = 0, lastY = 0, lineThickness = 1; canvas.width=canvas.height = 250; ctx.fillRect(0, 0, 250, 250); canvas.onmousedown = function(e) { painting = true; ctx.fillStyle = \"#ffffff\"; lastX = e.pageX - this.offsetLeft; lastY = e.pageY - this.offsetTop; }; canvas.onmouseup = function(e){ painting = false; } canvas.onmousemove = function(e) { if (painting) { mouseX = e.pageX - this.offsetLeft; mouseY = e.pageY - this.offsetTop; // find all points between var x1 = mouseX, x2 = lastX, y1 = mouseY, y2 = lastY; var steep = (Math.abs(y2 - y1) > Math.abs(x2 - x1)); if (steep){ var x = x1; x1 = y1; y1 = x; var y = y2; y2 = x2; x2 = y; } if (x1 > x2) { var x = x1; x1 = x2; x2 = x; var y = y1; y1 = y2; y2 = y; } var dx = x2 - x1, dy = Math.abs(y2 - y1), error = 0, de = dy / dx, yStep = -1, y = y1; if (y1 < y2) { yStep = 1; } lineThickness = 4; for (var x = x1; x < x2; x++) { if (steep) { ctx.fillRect(y, x, lineThickness , lineThickness ); } else { ctx.fillRect(x, y, lineThickness , lineThickness ); } error += de; if (error >= 0.5) { y += yStep; error -= 1.0; } } lastX = mouseX; lastY = mouseY; } } var button=document.getElementById(\"clear\"); button.onclick=function clearcanvas(){ canvas=document.getElementById(\"canvas\"), ctx = canvas.getContext('2d'); ctx.clearRect(0, 0, 250, 250); canvas.width=canvas.height = 250; ctx.fillRect(0, 0, 250, 250);}\n\nIf you do not use transformations this would do the thing: I usually fill the full canvas with a rect of background color If transformations are applied — you can and do some school math to clear the canvas in the applied transform space. It is not so complicated, but I spent some time yesterday with paper when I needed to transform the mouse position to the local space of each drawn element (for collision check): a, b, c, d, e, f — is the canvas matrix data, X, Y — mouse position, and x, y — position in local space You would need to do it for all 4 corners (0,0), (w,0), (w,h), (0,h), then get min/max of all results x, and y, then or for rect with arguments: (minX, minY, maxX-minX, maxY-minY) I do not think it would be optimal in the performance term way. Actually, I thought that the most performant way would be to of an empty canvas and put it back by the method, but performance tests show that this is not the case. An optimal way to clear if transformations are applied is: Here is a jsperf link with all options that I've tried."
    },
    {
        "link": "https://github.com/antvis/X6/blob/master/README.en-us.md",
        "document": "JavaScript diagramming library that uses SVG and HTML for rendering\n• 🌱 Easy-to-customize: based on well known SVG/HTML/CSS or React/Vue/Angular to custom nodes and edges\n• 🚀 Out-of-the-box: built-in 10+ plugins, such as selection, dnd, redo/undo, snapline, minimap, etc.\n• 🧲 Data-driven: base on MVC architecture, you can focus on data logic and business logic\n• 💯 Highly-event-driven: you can react on any event that happens inside the graph\n\n$ pnpm install enter the specified project development and debugging packages/x6 pnpm run build:watch start example to see the effect examples/x6-example-features pnpm run start\n\nTo become a contributor, please follow our contributing guide. If you are an active contributor, you can apply to be a outside collaborator.\n\nThe scripts and documentation in this project are released under the MIT License."
    },
    {
        "link": "https://github.com/antvis/X6/issues/11",
        "document": "To see all available qualifiers, see our documentation .\n\nSaved searches Use saved searches to filter your results more quickly\n\nWe read every piece of feedback, and take your input very seriously.\n\nYou signed in with another tab or window. Reload to refresh your session.\n\nYou signed out in another tab or window. Reload to refresh your session.\n\nYou switched accounts on another tab or window. Reload to refresh your session."
    },
    {
        "link": "https://l7.antv.vision/en/api/scene",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/67108651/antv-g6-and-react-how-to-update-graph",
        "document": "I have a graph and need to update it after clicking on the button. But it creates a new canvas every time.\n\nWhat am I doing wrong?"
    }
]