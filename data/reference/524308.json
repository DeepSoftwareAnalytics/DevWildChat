[
    {
        "link": "https://docs.unity3d.com/2023.2/Documentation/Manual/Coroutines.html",
        "document": "A coroutine allows you to spread tasks across several frames. In Unity, a coroutine is a method that can pause execution and return control to Unity but then continue where it left off on the following frame.\n\nIn most situations, when you call a method, it runs to completion and then returns control to the calling method, plus any optional return values. This means that any action that takes place within a method must happen within a single frame update.\n\nIn situations where you would like to use a method call to contain a procedural animation or a sequence of events over time, you can use a coroutine.\n\nHowever, it’s important to remember that coroutines aren’t threads. Synchronous operations that run within a coroutine still execute on the main thread. If you want to reduce the amount of CPU time spent on the main thread, it’s just as important to avoid blocking operations in coroutines as in any other script code. If you want to use multi-threaded code within Unity, consider the C# Job System.\n\nIt’s best to use coroutines if you need to deal with long asynchronous operations, such as waiting for HTTP transfers, asset loads, or file I/O to complete.\n\nAs an example, consider the task of gradually reducing an object’s alpha (opacity) value until it becomes invisible:\n\nIn this example, the Fade method doesn’t have the effect you might expect. To make the fading visible, you must reduce the alpha of the fade over a sequence of frames to display the intermediate values that Unity renders. However, this example method executes in its entirety within a single frame update. The intermediate values are never displayed, and the object disappears instantly.\n\nTo work around this situation, you could add code to the function that executes the fade on a frame-by-frame basis. However, it can be more convenient to use a coroutine for this kind of task.\n\nIn C#, you declare a coroutine like this:\n\nA coroutine is a method that you declare with an IEnumerator return type and with a yield return statement included somewhere in the body. The line is the point where execution pauses and resumes in the following frame. To set a coroutine running, you need to use the StartCoroutine function:\n\nThe loop counter in the Fade function maintains its correct value over the lifetime of the coroutine, and any variable or parameter is preserved between statements.\n\nBy default, Unity resumes a coroutine on the frame after a statement. If you want to introduce a time delay, use WaitForSeconds:\n\nYou can use to spread an effect over a period of time, and you can use it as an alternative to including the tasks in the method. Unity calls the method several times per second, so if you don’t need a task to be repeated quite so often, you can put it in a coroutine to get a regular update but not every single frame.\n\nFor example, you can might have an alarm in your application that warns the player if an enemy is nearby with the following code:\n\nIf there are a lot of enemies then calling this function every frame might introduce a significant overhead. However, you could use a coroutine to call it every tenth of a second:\n\nThis reduces the number of checks that Unity carries out without any noticeable effect on gameplay.\n\nTo stop a coroutine, use StopCoroutine and StopAllCoroutines. A coroutine also stops if you’ve set SetActive to to disable the GameObjectThe fundamental object in Unity scenes, which can represent characters, props, scenery, cameras, waypoints, and more. A GameObject’s functionality is defined by the Components attached to it. More info\n\nSee in Glossary the coroutine is attached to. Calling (where is a instance) immediately triggers OnDisable and Unity processes the coroutine, effectively stopping it. Finally, is invoked at the end of the frame.\n\nNote: If you’ve disabled a by setting enabled to , Unity doesn’t stop coroutines.\n\nCoroutines execute differently from other script code. Most script code in Unity appears within a performance trace in a single location, beneath a specific callback invocation. However, the CPU code of coroutines always appears in two places in a trace.\n\nAll the initial code in a coroutine, from the start of the coroutine method until the first statement, appears in the trace whenever Unity starts a coroutine. The initial code most often appears whenever the StartCoroutine method is called. Coroutines that Unity callbacks generate (such as callbacks that return an ) first appear within their respective Unity callback.\n\nThe rest of a coroutine’s code (from the first time it resumes until it finishes executing) appears within the line that’s inside Unity’s main loop.\n\nThis happens because of the way that Unity executes coroutines. The C# compiler auto generates an instance of a class that backs coroutines. Unity then uses this object to track the state of the coroutine across multiple invocations of a single method. Because local-scope variables within the coroutine must persist across calls, Unity hoists the local-scope variables into the generated class, which remain allocated on the heap during the coroutine. This object also tracks the internal state of the coroutine: it remembers at which point in the code the coroutine must resume after yielding.\n\nBecause of this, the memory pressure that happens when a coroutine starts is equal to a fixed overhead allocation plus the size of its local-scope variables.\n\nThe code which starts a coroutine constructs and invokes an object, and then Unity’s invokes it again whenever the coroutine’s condition is satisfied. Because coroutines usually start outside of other coroutines, this splits their execution overhead between the call and .\n\nYou can use the Unity ProfilerA window that helps you to optimize your game. It shows how much time is spent in the various areas of your game. For example, it can report the percentage of time spent rendering, animating, or in your game logic. More info\n\nSee in Glossary to inspect and understand where Unity executes coroutines in your application. To do this, profile your application with Deep Profiling enabled, which profiles every part of your script code and records all function calls. You can then use the CPU Usage Profiler module to investigate the coroutines in your application.\n\nIt’s best practice to condense a series of operations down to the fewest number of individual coroutines possible. Nested coroutines are useful for code clarity and maintenance, but they impose a higher memory overhead because the coroutine tracks objects.\n\nIf a coroutine runs every frame and doesn’t on long-running operations, it’s more performant to replace it with an or callback. This is useful if you have long-running or infinitely looping coroutines."
    },
    {
        "link": "https://docs.unity3d.com/6000.0/Documentation/Manual/coroutines.html",
        "document": "A coroutine allows you to spread tasks across several frames. A coroutine is a method that can pause execution and return control to Unity but then continue where it left off on the following frame.\n\nIn most situations, when you call a method, it runs to completion and then returns control to the calling method, plus any optional return values. This means that any action that takes place within a method must happen within a single frame update.\n\nIn situations where you want to use a method call to contain a procedural animation or a sequence of events over time, you can use a coroutine.\n\nNote: It’s important to remember that coroutines aren’t threads. Synchronous operations that run within a coroutine still execute on the main thread. If you want to reduce the amount of CPU time spent on the main thread, it’s just as important to avoid blocking operations in coroutines as in any other script code. If you want to use multi-threaded code in Unity, your options are:\n• The .NET async and await and Unity’s custom support\n\nIt’s best to use coroutines if you need to deal with long asynchronous operations, such as waiting for HTTP transfers, asset loads, or file I/O to complete.\n\nAs an example, consider the task of gradually reducing an object’s alpha (opacity) value until it becomes invisible:\n\nIn this example, the Fade method doesn’t have the effect you might expect. To make the fading visible, you must reduce the alpha of the fade over a sequence of frames to display the intermediate values that Unity renders. However, this example method executes entirely within a single frame update. The intermediate values are never displayed, and the object disappears instantly.\n\nTo work around this situation, you could add code to the function that executes the fade on a frame-by-frame basis. However, it can be more convenient to use a coroutine for this kind of task.\n\nIn C#, you declare a coroutine like this:\n\nA coroutine is a method that you declare with an IEnumerator return type and with a yield return statement included somewhere in the body. The line is the point where execution pauses and resumes in the following frame. To set a coroutine running, you need to use the StartCoroutine function:\n\nThe loop counter in the function maintains its correct value over the lifetime of the coroutine, and any variable or parameter is preserved between statements.\n\nBy default, Unity resumes a coroutine on the frame after a statement. If you want to introduce a time delay, use WaitForSeconds:\n\nYou can use to spread an effect over a period of time, and you can use it as an alternative to including the tasks in the method. Unity calls the method several times per second, so if you don’t need a task to be repeated quite so often, you can put it in a coroutine to get a regular update but not every single frame.\n\nFor example, you might have an alarm in your application that warns the player if an enemy is nearby with the following code:\n\nIf there are a lot of enemies then calling this function every frame might introduce a significant overhead. However, you could use a coroutine to call it every tenth of a second:\n\nThis reduces the number of checks that Unity carries out without any noticeable effect on gameplay.\n\nTo stop a coroutine, use StopCoroutine and StopAllCoroutines. A coroutine also stops if you’ve set SetActive to to disable the GameObjectThe fundamental object in Unity scenes, which can represent characters, props, scenery, cameras, waypoints, and more. A GameObject’s functionality is defined by the Components attached to it. More info\n\nSee in Glossary the coroutine is attached to. Calling (where is a instance) immediately triggers OnDisable and Unity processes the coroutine, effectively stopping it. Finally, is invoked at the end of the frame.\n\nNote: If you’ve disabled a by setting enabled to , Unity doesn’t stop coroutines.\n\nCoroutines execute differently from other script code. Most script code in Unity appears within a performance trace in a single location, beneath a specific callback invocation. However, the CPU code of coroutines always appears in two places in a trace.\n\nAll the initial code in a coroutine, from the start of the coroutine method until the first statement, appears in the trace whenever Unity starts a coroutine. The initial code most often appears whenever the StartCoroutine method is called. Coroutines that Unity callbacks generate (such as callbacks that return an ) first appear within their respective Unity callback.\n\nThe rest of a coroutine’s code (from the first time it resumes until it finishes executing) appears within the line inside Unity’s main loop.\n\nThis happens because of the way that Unity executes coroutines. The C# compiler auto-generates an instance of a class that backs coroutines. Unity then uses this object to track the state of the coroutine across multiple invocations of a single method. Because local-scope variables within the coroutine must persist across calls, Unity hoists the local-scope variables into the generated class, which remain allocated on the heap during the coroutine. This object also tracks the internal state of the coroutine: it remembers at which point in the code the coroutine must resume after yielding.\n\nBecause of this, the memory pressure that happens when a coroutine starts is equal to a fixed overhead allocation plus the size of its local-scope variables.\n\nThe code that starts a coroutine constructs and invokes an object, and then Unity’s invokes it again whenever the coroutine’s condition is satisfied. Because coroutines usually start outside of other coroutines, this splits their execution overhead between the call and .\n\nYou can use the Unity ProfilerA window that helps you to optimize your game. It shows how much time is spent in the various areas of your game. For example, it can report the percentage of time spent rendering, animating, or in your game logic. More info\n\nSee in Glossary to inspect and understand where Unity executes coroutines in your application. To do this, profile your application with Deep Profiling enabled, which profiles every part of your script code and records all function calls. You can then use the CPU Usage Profiler module to investigate the coroutines in your application.\n\nIt’s best practice to condense a series of operations down to the fewest number of individual coroutines possible. Nested coroutines are useful for code clarity and maintenance, but they impose a higher memory overhead because the coroutine tracks objects.\n\nIf a coroutine runs every frame and doesn’t on long-running operations, it’s more performant to replace it with an or callback. This is useful if you have long-running or infinitely looping coroutines."
    },
    {
        "link": "https://discussions.unity.com/t/how-to-wait-for-an-animation-to-finish/731662",
        "document": ""
    },
    {
        "link": "https://discussions.unity.com/t/wait-for-animation-to-finish-and-do-something/237534",
        "document": ""
    },
    {
        "link": "https://docs.unity.cn/2021.1/Documentation/Manual/Coroutines.html",
        "document": "When you call a function, it runs to completion before returning. This effectively means that any action taking place in a function must happen within a single frame update; a function call can’t be used to contain a procedural animation or a sequence of events over time. As an example, consider the task of gradually reducing an object’s alpha (opacity) value until it becomes completely invisible.\n\nAs it stands, the Fade function will not have the effect you might expect. In order for the fading to be visible, the alpha must be reduced over a sequence of frames to show the intermediate values being rendered. However, the function will execute in its entirety within a single frame update. The intermediate values will never be seen and the object will disappear instantly.\n\nIt is possible to handle situations like this by adding code to the Update function that executes the fade on a frame-by-frame basis. However, it is often more convenient to use a coroutine for this kind of task.\n\nA coroutine is like a function that has the ability to pause execution and return control to Unity but then to continue where it left off on the following frame. In C#, a coroutine is declared like this:\n\nIt is essentially a function declared with a return type of IEnumerator and with the yield return statement included somewhere in the body. The yield return null line is the point at which execution will pause and be resumed the following frame. To set a coroutine running, you need to use the StartCoroutine function:\n\nYou will notice that the loop counter in the Fade function maintains its correct value over the lifetime of the coroutine. In fact any variable or parameter will be correctly preserved between yields.\n\nBy default, a coroutine is resumed on the frame after it yields but it is also possible to introduce a time delay using WaitForSeconds:\n\nThis can be used as a way to spread an effect over a period of time, but it is also a useful optimization. Many tasks in a game need to be carried out periodically and the most obvious way to do this is to include them in the Update function. However, this function will typically be called many times per second. When a task doesn’t need to be repeated quite so frequently, you can put it in a coroutine to get an update regularly but not every single frame. An example of this might be an alarm that warns the player if an enemy is nearby. The code might look something like this:\n\nIf there are a lot of enemies then calling this function every frame might introduce a significant overhead. However, you could use a coroutine to call it every tenth of a second:\n\nThis would greatly reduce the number of checks carried out without any noticeable effect on gameplay.\n\nNote: You can stop a Coroutine with StopCoroutine and StopAllCoroutines. The coroutine also stops when the GameObjectThe fundamental object in Unity scenes, which can represent characters, props, scenery, cameras, waypoints, and more. A GameObject’s functionality is defined by the Components attached to it. More info\n\nSee in Glossary it is attached to is disabled with SetActive(false). Take note that the coroutine does not continue if the GameObject is re-enabled. Calling (where is a MonoBehaviour instance) immediately triggers and the coroutine is processed, effectively stopping it. Finally, is invoked at the end of the frame.\n\nCoroutines are not stopped when disabling a MonoBehaviour by setting enabled to false on a MonoBehaviour instance."
    },
    {
        "link": "https://discussions.unity.com/t/best-practice-to-perform-an-action-in-time-with-an-animation/183450",
        "document": ""
    },
    {
        "link": "https://michaelbitzos.com/devblog/programmatic-animation-using-coroutines",
        "document": ""
    },
    {
        "link": "https://medium.com/@lemapp09/beginning-game-development-coroutines-for-game-animations-and-effects-9aeaa2555de1",
        "document": "Unity3D’s coroutine system is not only powerful for managing game logic and sequences but also shines in controlling animations and visual effects. By using coroutines, developers can create more dynamic, responsive, and code-controlled animations, offering an alternative or a complement to Unity’s traditional animation systems. This approach is particularly useful for event-driven animations, smooth transitions, and complex animation sequences that depend on game logic.\n\nCoroutines provide a flexible framework for animation control, allowing for precise timing, sequencing, and synchronization with game events. Unlike fixed animation timelines, coroutines enable runtime adjustments, making them ideal for dynamic game scenarios.\n\nIn this example, a coroutine iterates through an array of sprites, updating the component to display each frame, thus creating a simple animation.\n\nLinear interpolation (Lerp) operations are a staple in smooth transitions and animations. Coroutines are an excellent way to perform these operations over time, such as moving an object smoothly between two points.\n\nThis coroutine smoothly transitions an object’s position from a starting point to a target location over a specified duration, utilizing the function for smooth interpolation.\n\nCoroutines excel in scenarios where animations or effects need to be triggered by specific game events, such as a character taking damage or a power-up being activated.\n\nThis coroutine temporarily changes the sprite’s color to indicate damage, creating a visual feedback effect for the player.\n\nCoroutines offer a powerful and flexible toolset for controlling game animations and effects in Unity3D. Whether it’s for smoothly interpolating values, sequencing complex animations, or reacting to game events, coroutines can enhance the visual fidelity and interactivity of your game, providing a richer experience for the players."
    },
    {
        "link": "https://docs.unity3d.com/6000.0/Documentation/Manual/coroutines.html",
        "document": "A coroutine allows you to spread tasks across several frames. A coroutine is a method that can pause execution and return control to Unity but then continue where it left off on the following frame.\n\nIn most situations, when you call a method, it runs to completion and then returns control to the calling method, plus any optional return values. This means that any action that takes place within a method must happen within a single frame update.\n\nIn situations where you want to use a method call to contain a procedural animation or a sequence of events over time, you can use a coroutine.\n\nNote: It’s important to remember that coroutines aren’t threads. Synchronous operations that run within a coroutine still execute on the main thread. If you want to reduce the amount of CPU time spent on the main thread, it’s just as important to avoid blocking operations in coroutines as in any other script code. If you want to use multi-threaded code in Unity, your options are:\n• The .NET async and await and Unity’s custom support\n\nIt’s best to use coroutines if you need to deal with long asynchronous operations, such as waiting for HTTP transfers, asset loads, or file I/O to complete.\n\nAs an example, consider the task of gradually reducing an object’s alpha (opacity) value until it becomes invisible:\n\nIn this example, the Fade method doesn’t have the effect you might expect. To make the fading visible, you must reduce the alpha of the fade over a sequence of frames to display the intermediate values that Unity renders. However, this example method executes entirely within a single frame update. The intermediate values are never displayed, and the object disappears instantly.\n\nTo work around this situation, you could add code to the function that executes the fade on a frame-by-frame basis. However, it can be more convenient to use a coroutine for this kind of task.\n\nIn C#, you declare a coroutine like this:\n\nA coroutine is a method that you declare with an IEnumerator return type and with a yield return statement included somewhere in the body. The line is the point where execution pauses and resumes in the following frame. To set a coroutine running, you need to use the StartCoroutine function:\n\nThe loop counter in the function maintains its correct value over the lifetime of the coroutine, and any variable or parameter is preserved between statements.\n\nBy default, Unity resumes a coroutine on the frame after a statement. If you want to introduce a time delay, use WaitForSeconds:\n\nYou can use to spread an effect over a period of time, and you can use it as an alternative to including the tasks in the method. Unity calls the method several times per second, so if you don’t need a task to be repeated quite so often, you can put it in a coroutine to get a regular update but not every single frame.\n\nFor example, you might have an alarm in your application that warns the player if an enemy is nearby with the following code:\n\nIf there are a lot of enemies then calling this function every frame might introduce a significant overhead. However, you could use a coroutine to call it every tenth of a second:\n\nThis reduces the number of checks that Unity carries out without any noticeable effect on gameplay.\n\nTo stop a coroutine, use StopCoroutine and StopAllCoroutines. A coroutine also stops if you’ve set SetActive to to disable the GameObjectThe fundamental object in Unity scenes, which can represent characters, props, scenery, cameras, waypoints, and more. A GameObject’s functionality is defined by the Components attached to it. More info\n\nSee in Glossary the coroutine is attached to. Calling (where is a instance) immediately triggers OnDisable and Unity processes the coroutine, effectively stopping it. Finally, is invoked at the end of the frame.\n\nNote: If you’ve disabled a by setting enabled to , Unity doesn’t stop coroutines.\n\nCoroutines execute differently from other script code. Most script code in Unity appears within a performance trace in a single location, beneath a specific callback invocation. However, the CPU code of coroutines always appears in two places in a trace.\n\nAll the initial code in a coroutine, from the start of the coroutine method until the first statement, appears in the trace whenever Unity starts a coroutine. The initial code most often appears whenever the StartCoroutine method is called. Coroutines that Unity callbacks generate (such as callbacks that return an ) first appear within their respective Unity callback.\n\nThe rest of a coroutine’s code (from the first time it resumes until it finishes executing) appears within the line inside Unity’s main loop.\n\nThis happens because of the way that Unity executes coroutines. The C# compiler auto-generates an instance of a class that backs coroutines. Unity then uses this object to track the state of the coroutine across multiple invocations of a single method. Because local-scope variables within the coroutine must persist across calls, Unity hoists the local-scope variables into the generated class, which remain allocated on the heap during the coroutine. This object also tracks the internal state of the coroutine: it remembers at which point in the code the coroutine must resume after yielding.\n\nBecause of this, the memory pressure that happens when a coroutine starts is equal to a fixed overhead allocation plus the size of its local-scope variables.\n\nThe code that starts a coroutine constructs and invokes an object, and then Unity’s invokes it again whenever the coroutine’s condition is satisfied. Because coroutines usually start outside of other coroutines, this splits their execution overhead between the call and .\n\nYou can use the Unity ProfilerA window that helps you to optimize your game. It shows how much time is spent in the various areas of your game. For example, it can report the percentage of time spent rendering, animating, or in your game logic. More info\n\nSee in Glossary to inspect and understand where Unity executes coroutines in your application. To do this, profile your application with Deep Profiling enabled, which profiles every part of your script code and records all function calls. You can then use the CPU Usage Profiler module to investigate the coroutines in your application.\n\nIt’s best practice to condense a series of operations down to the fewest number of individual coroutines possible. Nested coroutines are useful for code clarity and maintenance, but they impose a higher memory overhead because the coroutine tracks objects.\n\nIf a coroutine runs every frame and doesn’t on long-running operations, it’s more performant to replace it with an or callback. This is useful if you have long-running or infinitely looping coroutines."
    },
    {
        "link": "https://reddit.com/r/Unity3D/comments/128z4pr/discussion_is_it_a_good_practice_to_just_avoid",
        "document": "I wondering if people have seen Unity's Coroutines used in a professional project. I've only seen it used in personal projects, and from my experience, they cause many problems.\n\nI've never liked Coroutines, because:\n• They are (misleadingly) inefficient; they create a lot of unnecessary overhead. For example: the example Unity provides (in the link above) shows them using \"yield\" inside a loop, but when you use \"yield return\" inside a loop, Unity has to create a new IEnumerator object for each iteration of the loop. This can be inefficient if the loop runs for a large number of iterations, because it can create a lot of garbage that needs to be collected by the garbage collector.\n• Anything they do can instead be rewritten in an Update method, with only one or more variables, or sometimes less. And I've always found that code to be so much more satisfying and maintainable. For example, again: in that same example where Unity is using coroutine to fade out an object, you could also just do \"renderer.material.color -= fadeRate * Time.deltaTime\" in Update... that's actually fewer lines of code (also, yes: min at 0 & disable the GO when it reaches 0... but their example code doesn't do that either).\n• They're less friendly than alternatives when it comes to stopping & being a part of a state machine (which, in a game, most things are ultimately state machines). If there is any chance you will need to stop a Coroutine because something happens, then you need to store it and then call StopCoroutine later - which can be complicated. Back to the same example: let's say there is a non-zero chance that the object will stop fading for whatever reason, or reverse fading out and actually fade back in. Then they are better off not using Corotuines and instead creating a simple script (that does what I've described in #2 in Update), with a bool \"fadeIn\" (false for fadingOut), which effectively handles the state machine. I'm sure you can imagine what else the script needs; like the script self-disabling at alpha == 0 or 1. That's a lot easier to create and will be less buggy.\n\nBut am I wrong? Do many Unity Pros not have this opinion?"
    }
]