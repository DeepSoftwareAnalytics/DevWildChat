[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/substring",
        "document": "The method of values returns the part of this string from the start index up to and excluding the end index, or to the end of the string if no end index is supplied.\n\nextracts characters from up to but not including . In particular:\n• If is omitted, extracts characters to the end of the string.\n• If is equal to , returns an empty string.\n• If is greater than , then the effect of is as if the two arguments were swapped; see example below. Any argument value that is less than or greater than is treated as if it were and , respectively. Any argument value that is is treated as if it were .\n\nThe following example uses the method and property to extract the last characters of a particular string. This method may be easier to remember, given that you don't need to know the starting and ending indices as you would in the above examples. const text = \"Mozilla\"; // Takes 4 last characters of string console.log(text.substring(text.length - 4)); // prints \"illa\" // Takes 5 last characters of string console.log(text.substring(text.length - 5)); // prints \"zilla\"\n\nThe difference between substring() and substr() There are subtle differences between the and methods, so you should be careful not to get them confused.\n• The two parameters of are and , while for , they are and .\n• 's index will wrap to the end of the string if it is negative, while will clamp it to .\n• Negative lengths in are treated as zero, while will swap the two indexes if is less than . Furthermore, is considered a legacy feature in ECMAScript, so it is best to avoid using it if possible.\n\nThe and methods are almost identical, but there are a couple of subtle differences between the two, especially in the way negative arguments are dealt with. The method swaps its two arguments if is greater than , meaning that a string is still returned. The method returns an empty string if this is the case. If either or both of the arguments are negative or , the method treats them as if they were . also treats arguments as , but when it is given negative values it counts backwards from the end of the string to find the indexes. See the page for more examples with negative numbers.\n\nThe following example replaces a substring within a string. It will replace both individual characters and substrings. The function call at the end of the example creates a string from the original string . // Replaces oldS with newS in the string fullS function replaceString(oldS, newS, fullS) { for (let i = 0; i < fullS.length; ++i) { if (fullS.substring(i, i + oldS.length) === oldS) { fullS = fullS.substring(0, i) + newS + fullS.substring(i + oldS.length, fullS.length); } } return fullS; } replaceString(\"World\", \"Web\", \"Brave New World\"); Note that this can result in an infinite loop if is itself a substring of — for example, if you attempted to replace with here. A better method for replacing strings is as follows: The code above serves as an example for substring operations. If you need to replace substrings, most of the time you will want to use ."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/substr",
        "document": "Deprecated: This feature is no longer recommended. Though some browsers might still support it, it may have already been removed from the relevant web standards, may be in the process of being dropped, or may only be kept for compatibility purposes. Avoid using it, and update existing code if possible; see the compatibility table at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time.\n\nThe method of values returns a portion of this string, starting at the specified index and extending for a given number of characters afterwards.\n\nNote: is not part of the main ECMAScript specification — it's defined in Annex B: Additional ECMAScript Features for Web Browsers, which is normative optional for non-browser runtimes. Therefore, people are advised to use the standard and methods instead to make their code maximally cross-platform friendly. The page has some comparisons between the three methods."
    },
    {
        "link": "https://w3schools.com/jsref/jsref_substring.asp",
        "document": "The method extracts characters, between two indices (positions), from a string, and returns the substring.\n\nThe method extracts characters from start to end (exclusive).\n\nThe method does not change the original string.\n\nIf start is greater than end, arguments are swapped: (4, 1) = (1, 4).\n\nStart or end values less than 0, are treated as 0.\n\nIt is supported in all browsers:"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
        "document": "Strings can be created as primitives, from string literals, or as objects, using the constructor: const string1 = \"A string primitive\"; const string2 = 'Also a string primitive'; const string3 = `Yet another string primitive`; String primitives and string objects share many behaviors, but have other important differences and caveats. See \"String primitives and String objects\" below. String literals can be specified using single or double quotes, which are treated identically, or using the backtick character . This last form specifies a template literal: with this form you can interpolate expressions. For more information on the syntax of string literals, see lexical grammar.\n\nThere are two ways to access an individual character in a string. The first is the method: The other way is to treat the string as an array-like object, where individual characters correspond to a numerical index: When using bracket notation for character access, attempting to delete or assign a value to these properties will not succeed. The properties involved are neither writable nor configurable. (See for more information.)\n\nUse the less-than and greater-than operators to compare strings: const a = \"a\"; const b = \"b\"; if (a < b) { // true console.log(`${a} is less than ${b}`); } else if (a > b) { console.log(`${a} is greater than ${b}`); } else { console.log(`${a} and ${b} are equal.`); } Note that all comparison operators, including and , compare strings case-sensitively. A common way to compare strings case-insensitively is to convert both to the same case (upper or lower) before comparing them. The choice of whether to transform by or is mostly arbitrary, and neither one is fully robust when extending beyond the Latin alphabet. For example, the German lowercase letter and are both transformed to by , while the Turkish letter would be falsely reported as unequal to by unless specifically using . const areEqualInUpperCase = (str1, str2) => str1.toUpperCase() === str2.toUpperCase(); const areEqualInLowerCase = (str1, str2) => str1.toLowerCase() === str2.toLowerCase(); areEqualInUpperCase(\"ß\", \"ss\"); // true; should be false areEqualInLowerCase(\"ı\", \"I\"); // false; should be true A locale-aware and robust solution for testing case-insensitive equality is to use the API or the string's method — they share the same interface — with the option set to or . The method enables string comparison in a similar fashion as — it allows sorting strings in a locale-aware manner.\n\nNote that JavaScript distinguishes between objects and primitive string values. (The same is true of and .) String literals (denoted by double or single quotes) and strings returned from calls in a non-constructor context (that is, called without using the keyword) are primitive strings. In contexts where a method is to be invoked on a primitive string or a property lookup occurs, JavaScript will automatically wrap the string primitive and call the method or perform the property lookup on the wrapper object instead. const strPrim = \"foo\"; // A literal is a string primitive const strPrim2 = String(1); // Coerced into the string primitive \"1\" const strPrim3 = String(true); // Coerced into the string primitive \"true\" const strObj = new String(strPrim); // String with new returns a string wrapper object. console.log(typeof strPrim); // \"string\" console.log(typeof strPrim2); // \"string\" console.log(typeof strPrim3); // \"string\" console.log(typeof strObj); // \"object\" Warning: You should rarely find yourself using as a constructor. String primitives and objects also give different results when using . Primitives passed to are treated as source code; objects are treated as all other objects are, by returning the object. For example: const s1 = \"2 + 2\"; // creates a string primitive const s2 = new String(\"2 + 2\"); // creates a String object console.log(eval(s1)); // returns the number 4 console.log(eval(s2)); // returns the string \"2 + 2\" For these reasons, the code may break when it encounters objects when it expects a primitive string instead, although generally, authors need not worry about the distinction. A object can always be converted to its primitive counterpart with the method.\n\nStrings are represented fundamentally as sequences of UTF-16 code units. In UTF-16 encoding, every code unit is exact 16 bits long. This means there are a maximum of 216, or 65536 possible characters representable as single UTF-16 code units. This character set is called the basic multilingual plane (BMP), and includes the most common characters like the Latin, Greek, Cyrillic alphabets, as well as many East Asian characters. Each code unit can be written in a string with followed by exactly four hex digits. However, the entire Unicode character set is much, much bigger than 65536. The extra characters are stored in UTF-16 as surrogate pairs, which are pairs of 16-bit code units that represent a single character. To avoid ambiguity, the two parts of the pair must be between and , and these code units are not used to encode single-code-unit characters. (More precisely, leading surrogates, also called high-surrogate code units, have values between and , inclusive, while trailing surrogates, also called low-surrogate code units, have values between and , inclusive.) Each Unicode character, comprised of one or two UTF-16 code units, is also called a Unicode code point. Each Unicode code point can be written in a string with where represents 1–6 hex digits. A \"lone surrogate\" is a 16-bit code unit satisfying one of the descriptions below:\n• It is in the range – , inclusive (i.e. is a leading surrogate), but it is the last code unit in the string, or the next code unit is not a trailing surrogate.\n• It is in the range – , inclusive (i.e. is a trailing surrogate), but it is the first code unit in the string, or the previous code unit is not a leading surrogate. Lone surrogates do not represent any Unicode character. Although most JavaScript built-in methods handle them correctly because they all work based on UTF-16 code units, lone surrogates are often not valid values when interacting with other systems — for example, will throw a for lone surrogates, because URI encoding uses UTF-8 encoding, which does not have any encoding for lone surrogates. Strings not containing any lone surrogates are called well-formed strings, and are safe to be used with functions that do not deal with UTF-16 (such as or ). You can check if a string is well-formed with the method, or sanitize lone surrogates with the method. On top of Unicode characters, there are certain sequences of Unicode characters that should be treated as one visual unit, known as a grapheme cluster. The most common case is emojis: many emojis that have a range of variations are actually formed by multiple emojis, usually joined by the <ZWJ> ( ) character. You must be careful which level of characters you are iterating on. For example, will split by UTF-16 code units and will separate surrogate pairs. String indexes also refer to the index of each UTF-16 code unit. On the other hand, iterates by Unicode code points. Iterating through grapheme clusters will require some custom code. \"😄\".split(\"\"); // ['\\ud83d', '\\ude04']; splits into two lone surrogates // \"Backhand Index Pointing Right: Dark Skin Tone\" [...\"👉🏿\"]; // ['👉', '🏿'] // splits into the basic \"Backhand Index Pointing Right\" emoji and // the \"Dark skin tone\" emoji // \"Family: Man, Boy\" [...\"👨‍👦\"]; // [ '👨', '‍', '👦' ] // splits into the \"Man\" and \"Boy\" emoji, joined by a ZWJ // The United Nations flag [...\"🇺🇳\"]; // [ '🇺', '🇳' ] // splits into two \"region indicator\" letters \"U\" and \"N\". // All flag emojis are formed by joining two region indicator letters\n\nReturns the character (exactly one UTF-16 code unit) at the specified . Accepts negative integers, which count back from the last string character. Returns the character (exactly one UTF-16 code unit) at the specified . Returns a number that is the UTF-16 code unit value at the given . Returns a nonnegative integer Number that is the code point value of the UTF-16 encoded code point starting at the specified . Combines the text of two (or more) strings and returns a new string. Determines whether a string ends with the characters of the string . Determines whether the calling string contains . Returns the index within this string of the first occurrence of , or if not found. Returns a boolean indicating whether this string contains any lone surrogates. Returns the index within this string of the last occurrence of , or if not found. Returns a number indicating whether the reference string comes before, after, or is equivalent to the given string in sort order. Used to match regular expression against a string. Returns an iterator of all 's matches. Returns the Unicode Normalization Form of the calling string value. Pads the current string from the end with a given string and returns a new string of the length . Pads the current string from the start with a given string and returns a new string of the length . Returns a string consisting of the elements of the object repeated times. Used to replace occurrences of using . may be a string or Regular Expression, and may be a string or function. Used to replace all occurrences of using . may be a string or Regular Expression, and may be a string or function. Search for a match between a regular expression and the calling string. Extracts a section of a string and returns a new string. Returns an array of strings populated by splitting the calling string at occurrences of the substring . Determines whether the calling string begins with the characters of string . Returns a portion of the string, starting at the specified index and extending for a given number of characters afterwards. Returns a new string containing characters of the calling string from (or between) the specified index (or indices). The characters within a string are converted to lowercase while respecting the current locale. For most languages, this will return the same as . The characters within a string are converted to uppercase while respecting the current locale. For most languages, this will return the same as . Returns the calling string value converted to lowercase. Returns a string representing the specified object. Overrides the method. Returns the calling string value converted to uppercase. Returns a string where all lone surrogates of this string are replaced with the Unicode replacement character U+FFFD. Trims whitespace from the beginning and end of the string. Trims whitespace from the end of the string. Trims whitespace from the beginning of the string. Returns the primitive value of the specified object. Overrides the method. Returns a new iterator object that iterates over the code points of a String value, returning each code point as a String value."
    },
    {
        "link": "https://w3schools.com/jsref/jsref_obj_string.asp",
        "document": "A string can be any text inside double or single quotes:\n\nThe first character is in position 0, the second in 1, and so on.\n\nFor a tutorial about Strings, read our JavaScript String Tutorial.\n\nNormally, strings like \"John Doe\", cannot have methods or properties because they are not objects.\n\nBut with JavaScript, methods and properties are also available to strings, because JavaScript treats strings as objects when executing methods and properties.\n\nThese are not standard methods, and may not work as expected."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/substring",
        "document": "The method of values returns the part of this string from the start index up to and excluding the end index, or to the end of the string if no end index is supplied.\n\nextracts characters from up to but not including . In particular:\n• If is omitted, extracts characters to the end of the string.\n• If is equal to , returns an empty string.\n• If is greater than , then the effect of is as if the two arguments were swapped; see example below. Any argument value that is less than or greater than is treated as if it were and , respectively. Any argument value that is is treated as if it were .\n\nThe following example uses the method and property to extract the last characters of a particular string. This method may be easier to remember, given that you don't need to know the starting and ending indices as you would in the above examples. const text = \"Mozilla\"; // Takes 4 last characters of string console.log(text.substring(text.length - 4)); // prints \"illa\" // Takes 5 last characters of string console.log(text.substring(text.length - 5)); // prints \"zilla\"\n\nThe difference between substring() and substr() There are subtle differences between the and methods, so you should be careful not to get them confused.\n• The two parameters of are and , while for , they are and .\n• 's index will wrap to the end of the string if it is negative, while will clamp it to .\n• Negative lengths in are treated as zero, while will swap the two indexes if is less than . Furthermore, is considered a legacy feature in ECMAScript, so it is best to avoid using it if possible.\n\nThe and methods are almost identical, but there are a couple of subtle differences between the two, especially in the way negative arguments are dealt with. The method swaps its two arguments if is greater than , meaning that a string is still returned. The method returns an empty string if this is the case. If either or both of the arguments are negative or , the method treats them as if they were . also treats arguments as , but when it is given negative values it counts backwards from the end of the string to find the indexes. See the page for more examples with negative numbers.\n\nThe following example replaces a substring within a string. It will replace both individual characters and substrings. The function call at the end of the example creates a string from the original string . // Replaces oldS with newS in the string fullS function replaceString(oldS, newS, fullS) { for (let i = 0; i < fullS.length; ++i) { if (fullS.substring(i, i + oldS.length) === oldS) { fullS = fullS.substring(0, i) + newS + fullS.substring(i + oldS.length, fullS.length); } } return fullS; } replaceString(\"World\", \"Web\", \"Brave New World\"); Note that this can result in an infinite loop if is itself a substring of — for example, if you attempted to replace with here. A better method for replacing strings is as follows: The code above serves as an example for substring operations. If you need to replace substrings, most of the time you will want to use ."
    },
    {
        "link": "https://bito.ai/blog/how-to-use-the-javascript-substring-method",
        "document": "As a JavaScript developer, you’ll often find yourself working with strings. Whether you’re parsing user input, processing data, or manipulating text, strings are an essential part of any JavaScript application.\n\nOne of the most common operations you’ll perform on strings is extracting a substring, or a portion of a string. In this article, we’ll explore the JavaScript substring method, which is a powerful tool for working with strings.\n\nWhat is the substring method in JavaScript?\n\nThe substring method is a built-in function in JavaScript that allows you to extract a portion of a string. It takes two arguments: the starting index and the ending index of the substring. The starting index is inclusive, while the ending index is exclusive, which means that the character at the ending index is not included in the substring.\n\nThe syntax of the substring method is as follows:\n\nLet’s look at some examples to understand how the substring method works.\n\nSuppose we have a string called text that contains the phrase “JavaScript is awesome”. We want to extract the substring “JavaScript” from this string. We can use the substring method as follows:\n\nIn this example, we pass the starting index of the substring as 0, which is the first character of the string. We pass the ending index as 10, which is the index of the last character of the substring, plus 1. The substring method returns the portion of the string between the starting index and the ending index, which is “JavaScript”.\n\nExample 2: Extracting a substring from a string using negative indexes\n\nWe can also use negative indexes to extract a substring from a string. Negative indexes count from the end of the string, with -1 being the last character. Let’s take the same example as before and extract the substring “awesome” using negative indexes:\n\nIn this example, we pass the starting index as 11, which is the index of the first character of the substring. We pass the ending index as -1, which means we want to extract all the characters from the starting index to the end of the string. The substring method returns the portion of the string between the starting index and the ending index, which is “awesome”.\n\nIf the starting index is greater than the ending index, the substring method swaps the indexes. If either index is negative or greater than the length of the string, the method treats it as 0. Let’s see an example:\n\nIn this example, we pass the starting index as 10 and the ending index as 5. Since the starting index is greater than the ending index, the substring method swaps the indexes, making the starting index 5 and the ending index 10. The substring method then returns the portion of the string between the starting index and the ending index, which is “JavaS”.\n\nHere are some benefits of using the JavaScript substring method that can make your code more efficient and effective:\n• Simplifies string manipulation: The substring method makes it easy to manipulate strings in JavaScript. By using this method, you can extract specific parts of a string or modify it without changing the original string.\n• Saves time and effort: Using the substring method can save you a lot of time and effort in writing complex string manipulation code. Instead of writing custom code for each string manipulation task, you can simply use the substring method to extract or modify the desired substring.\n• Increases code readability: The substring method can make your code more readable and understandable. By using this method, you can avoid using complex regular expressions or custom string manipulation code that can be difficult to understand and maintain.\n• Improves performance: The substring method is an efficient way to extract or modify substrings from a string. It is much faster than other string manipulation techniques like regular expressions and custom code\n\nWhile the JavaScript Substring method is a powerful tool for manipulating strings, it does have some limitations that developers should be aware of. Here are a few limitations of the substring method:\n• Limited functionality with negative indexes: Unlike some other string methods like slice and substr, the substring method does not support negative indexes. This means that you cannot use negative values for the start or end parameters. This can be a limitation in certain use cases where negative indexes would be useful.\n• Inability to modify original string: The substring method returns a new string rather than modifying the original string. This can be a limitation if you need to modify the original string in place.\n• Limited support for Unicode characters: The substring method does not work well with Unicode characters, which can cause issues if your strings contain non-ASCII characters. In such cases, it is often better to use the more powerful and flexible string methods available in the ECMAScript Internationalization API.\n• Limited functionality with regular expressions: The substring method cannot accept regular expressions as arguments. This means that it cannot be used to match patterns within a string or perform advanced string manipulation.\n\nTips for Using the JavaScript Substring Method\n\nHere are some tips for using the JavaScript substring method effectively:\n• Remember that the substring method is case-sensitive: When specifying the start and end indexes of a substring, keep in mind that the method is case-sensitive. This means that ‘A’ and ‘a’ are considered different characters and will have different index values.\n• Be mindful of negative index values: When using negative index values with the substring method, remember that they count from the end of the string. For example, a start index of -1 will select the last character of the string.\n• Use the length property to avoid index errors: To avoid index errors when specifying the end index of a substring, use the length property of the string. This will ensure that the end index does not exceed the length of the string.\n• Combine with other string methods: The substring method can be combined with other string methods, such as indexOf or replace, to achieve more complex string manipulations.\n• Test your code thoroughly: As with any code, it’s important to thoroughly test your implementation of the substring method to ensure that it is working as expected.\n\nBy following these tips, you can use the JavaScript substring method to its fullest potential and avoid common pitfalls.\n\nThe JavaScript substring method is a powerful tool for manipulating strings of text. It allows you to extract substrings from larger strings by specifying two indices—the index of the first character and the index of the last character.\n\nWhile it’s a useful tool, there are a few things to keep in mind when using it, such as case sensitivity and correct syntax. If you find that it’s not suitable for your needs, there are alternatives available for manipulating strings."
    },
    {
        "link": "https://w3schools.com/jsref/jsref_substring.asp",
        "document": "The method extracts characters, between two indices (positions), from a string, and returns the substring.\n\nThe method extracts characters from start to end (exclusive).\n\nThe method does not change the original string.\n\nIf start is greater than end, arguments are swapped: (4, 1) = (1, 4).\n\nStart or end values less than 0, are treated as 0.\n\nIt is supported in all browsers:"
    },
    {
        "link": "https://stackoverflow.com/questions/14867835/get-substring-between-two-characters-using-javascript",
        "document": "I am trying to extract a string from within a larger string where it get everything in between a : and a ;\n\n@Babasaheb Gosavi Answer is perfect if you have one occurrence of the substrings (\":\" and \";\"). but once you have multiple occurrences, it might get little bit tricky. The best solution I have came up with to work on multiple projects is using four methods inside an object.\n• First method: is to actually get a substring from between two strings (however it will find only one result).\n• Second method: will remove the (would-be) most recently found result with the substrings after and before it.\n• Third method: will do the above two methods recursively on a string.\n• Fourth method: will apply the third method and return the result. So enough talking, let's see the code: var getFromBetween = { results:[], string:\"\", getFromBetween:function (sub1,sub2) { if(this.string.indexOf(sub1) < 0 || this.string.indexOf(sub2) < 0) return false; var SP = this.string.indexOf(sub1)+sub1.length; var string1 = this.string.substr(0,SP); var string2 = this.string.substr(SP); var TP = string1.length + string2.indexOf(sub2); return this.string.substring(SP,TP); }, removeFromBetween:function (sub1,sub2) { if(this.string.indexOf(sub1) < 0 || this.string.indexOf(sub2) < 0) return false; var removal = sub1+this.getFromBetween(sub1,sub2)+sub2; this.string = this.string.replace(removal,\"\"); }, getAllResults:function (sub1,sub2) { // first check to see if we do have both substrings if(this.string.indexOf(sub1) < 0 || this.string.indexOf(sub2) < 0) return; // find one result var result = this.getFromBetween(sub1,sub2); // push it to the results array this.results.push(result); // remove the most recently found one from the string this.removeFromBetween(sub1,sub2); // if there's more substrings if(this.string.indexOf(sub1) > -1 && this.string.indexOf(sub2) > -1) { this.getAllResults(sub1,sub2); } else return; }, get:function (string,sub1,sub2) { this.results = []; this.string = string; this.getAllResults(sub1,sub2); return this.results; } }; How to use? var str = 'this is the haystack {{{0}}} {{{1}}} {{{2}}} {{{3}}} {{{4}}} some text {{{5}}} end of haystack'; var result = getFromBetween.get(str,\"{{{\",\"}}}\"); console.log(result); // returns: [0,1,2,3,4,5]\n\nYou can use a higher order function to return a 'compiled' version of your extractor, that way it's faster. With regexes, and compiling the regex once in a closure, Javascript's match will return all matches. This leaves us with only having to remove what we used as our markers (ie: ) and we can use string length for this with slice. Compile once and use multiple times... const stringExtractor = extract(['{','}']); const stuffIneed = stringExtractor('this {is} some {text} that can be {extracted} with a {reusable} function'); // Outputs: [ 'is', 'text', 'extracted', 'reusable' ] const stuffIneed = extract(['{','}'])('this {is} some {text} that can be {extracted} with a {reusable} function'); // Outputs: [ 'is', 'text', 'extracted', 'reusable' ] Also look at Javascript's function but using a function for the replacement argument (You would do that if for example you were doing a mini template engine (string interpolation) ... lodash.get could also be helpful then to get the values you want to replace with ? ... My answer is too long but it might help someone!\n\nA small function I made that can grab the string between, and can (optionally) skip a number of matched words to grab a specific index. Also, setting to will use the beginning of the string, and setting to will use the end of the string. set to the position of the text you want to use, will use the first occurrence of does the same thing as , but for , and will use the first occurrence of only after , occurrences of before are ignored.\n\nNote that the function will return everything after if is not found after . It also expects there's only one occurrence of of start and end, and if there are multiple - it will only consider the first. /** * Extracts a string from `source` that is placed between `start` and `end`. The function * considers only one instance of start and before, or the first instance and does not support * multiple occurences otherwise. If end string is not found, it will return everything after * `start` to the end of the string. */ export function stringBetween(source, start, end) { if (source.indexOf(start) === -1) { return null; } const sourceSplitByStartString = source.split(start); // Note: If start string is the very first occurence in source string, the result will be an // array where the first item is an empty string and the next item is of interest. if ( sourceSplitByStartString.length === 1 || sourceSplitByStartString[1] === '' ) { // It means that start is either the entire string or is at the very end of the string, so there // is not anything between return ''; } const afterStart = sourceSplitByStartString[1]; // If the after separator is not found, return everything after the start separator to the end // of the string if (afterStart.indexOf(end) === -1) { return afterStart; } const afterStartSplitByEnd = afterStart.split(end); if (afterStartSplitByEnd[0] === '') { return ''; } return afterStartSplitByEnd[0]; } import { stringBetween } from './string'; describe('string utlities', () => { describe('stringBetween', () => { it('Extracts a substring between 2 other substrings', () => { const sample1 = stringBetween('Black cat climbed the tree fast.', 'cat ', ' the tree'); expect(sample1).toBe('climbed'); const sample2 = stringBetween('Black cat climbed the tree fast.', 'Black ', ' fast.'); expect(sample2).toBe('cat climbed the tree'); }); it('extracts everything after start if end is not found', () => { const sample2 = stringBetween('Black cat climbed the tree fast.', 'Black ', 'not-there'); expect(sample2).toBe('cat climbed the tree fast.'); }); it('returns empty string if start string occurs at the end', () => { const sample = stringBetween('Black cat climbed the tree fast.', 'fast.', 'climbed'); expect(sample).toBe(''); }); it('returns empty string if start string is the entire string', () => { const sample = stringBetween('Black cat', 'Black cat', 'climbed'); expect(sample).toBe(''); }); it('returns empty string if there is not anything between start and end', () => { const sample = stringBetween('Black cat climbed the tree fast.', 'climbed ', 'the tree'); expect(sample).toBe(''); }); it('returns null if start string does not exist in the source string', () => { const sample = stringBetween('Black cat climbed the tree fast.', 'not-there ', 'the tree'); expect(sample).toBe(null); }); }); });"
    },
    {
        "link": "https://w3schools.com/js/js_string_methods.asp",
        "document": "The property returns the length of a string:\n\nThere are 4 methods for extracting string characters:\n• Using property access [] like in arrays\n\nThe method returns the character at a specified index (position) in a string:\n\nThe method returns the code of the character at a specified index in a string:\n\nThe method returns a UTF-16 code (an integer between 0 and 65535).\n\nThe method returns the character at a specified index (position) in a string.\n\nThe method is supported in all modern browsers since March 2022:\n\nJavaScript 2022 (ES2022) is supported in all modern browsers since March 2023:\n\nThere are 3 methods for extracting a part of a string:\n\nextracts a part of a string and returns the extracted part in a new string.\n\nThe method takes 2 parameters: start position, and end position (end not included).\n\nThe difference is that start and end values less than 0 are treated as 0 in .\n\nIf you omit the second parameter, will slice out the rest of the string.\n\nThe difference is that the second parameter specifies the length of the extracted part.\n\nIf you omit the second parameter, will slice out the rest of the string.\n\nIf the first parameter is negative, the position counts from the end of the string.\n\nA string is converted to upper case with :\n\nA string is converted to lower case with :\n\njoins two or more strings:\n\nThe method can be used instead of the plus operator. These two lines do the same:\n\nThe method removes whitespace from both sides of a string:\n\nThe method works like , but removes whitespace only from the start of a string.\n\nJavaScript String is supported in all modern browsers since January 2020:\n\nThe method works like , but removes whitespace only from the end of a string.\n\nJavaScript String is supported in all modern browsers since January 2020:\n\nECMAScript 2017 added two new string methods to JavaScript: and to support padding at the beginning and at the end of a string.\n\nThe method pads a string from the start.\n\nIt pads a string with another string (multiple times) until it reaches a given length.\n\nES2017 is supported in all modern browsers since September 2017:\n\nis not supported in Internet Explorer.\n\nThe method pads a string from the end.\n\nIt pads a string with another string (multiple times) until it reaches a given length.\n\nES2017 is supported in all modern browsers since September 2017:\n\nis not supported in Internet Explorer.\n\nThe method returns a string with a number of copies of a string.\n\nThe method does not change the original string.\n\nES6 is fully supported in all modern browsers since June 2017:\n\nis not supported in Internet Explorer.\n\nThe method replaces a specified value with another value in a string:\n\nBy default, the method replaces only the first match:\n\nBy default, the method is case sensitive. Writing MICROSOFT (with upper-case) will not work:\n\nTo replace case insensitive, use a regular expression with an flag (insensitive):\n\nTo replace all matches, use a regular expression with a flag (global match):\n\nThe method allows you to specify a regular expression instead of a string to be replaced.\n\nIf the parameter is a regular expression, the global flag (g) must be set, otherwise a TypeError is thrown.\n\nA string can be converted to an array with the method:\n\nIf the separator is omitted, the returned array will contain the whole string in index [0].\n\nIf the separator is \"\", the returned array will be an array of single characters:"
    }
]