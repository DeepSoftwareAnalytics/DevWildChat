[
    {
        "link": "https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Scanner.html",
        "document": "\n• Returns a stream of delimiter-separated tokens from this scanner. The stream contains the same tokens that would be returned, starting from this scanner's current state, by calling the method repeatedly until the method returns false. The resulting stream is sequential and ordered. All stream elements are non-null. Scanning starts upon initiation of the terminal stream operation, using the current state of this scanner. Subsequent calls to any methods on this scanner other than and may return undefined results or may cause undefined effects on the returned stream. The returned stream's source is fail-fast and will, on a best-effort basis, throw a if any such calls are detected during stream pipeline execution. After stream pipeline execution completes, this scanner is left in an indeterminate state and cannot be reused. If this scanner contains a resource that must be released, this scanner should be closed, either by calling its method, or by closing the returned stream. Closing the stream will close the underlying scanner. is thrown if the scanner has been closed when this method is called, or if this scanner is closed during stream pipeline execution. This method might block waiting for more input. For example, the following code will create a list of comma-delimited tokens from a string: The resulting list would contain , , the empty string, and . - if this scanner is closed\n• and then Returns a stream of match results from this scanner. The stream contains the same results in the same order that would be returned by callingand then successively as long as finds matches. The resulting stream is sequential and ordered. All stream elements are non-null. Scanning starts upon initiation of the terminal stream operation, using the current state of this scanner. Subsequent calls to any methods on this scanner other than and may return undefined results or may cause undefined effects on the returned stream. The returned stream's source is fail-fast and will, on a best-effort basis, throw a if any such calls are detected during stream pipeline execution. After stream pipeline execution completes, this scanner is left in an indeterminate state and cannot be reused. If this scanner contains a resource that must be released, this scanner should be closed, either by calling its method, or by closing the returned stream. Closing the stream will close the underlying scanner. is thrown if the scanner has been closed when this method is called, or if this scanner is closed during stream pipeline execution. As with the methods, this method might block waiting for additional input, and it might buffer an unbounded amount of input searching for a match. For example, the following code will read a file and return a list of all sequences of characters consisting of seven or more Latin capital letters: - the pattern to be matched - if this scanner is closed"
    },
    {
        "link": "https://docs.oracle.com/en/java/javase/17/docs/api//java.base/java/util/Scanner.html",
        "document": "\n• Returns a stream of delimiter-separated tokens from this scanner. The stream contains the same tokens that would be returned, starting from this scanner's current state, by calling the method repeatedly until the method returns false. The resulting stream is sequential and ordered. All stream elements are non-null. Scanning starts upon initiation of the terminal stream operation, using the current state of this scanner. Subsequent calls to any methods on this scanner other than and may return undefined results or may cause undefined effects on the returned stream. The returned stream's source is fail-fast and will, on a best-effort basis, throw a if any such calls are detected during stream pipeline execution. After stream pipeline execution completes, this scanner is left in an indeterminate state and cannot be reused. If this scanner contains a resource that must be released, this scanner should be closed, either by calling its method, or by closing the returned stream. Closing the stream will close the underlying scanner. is thrown if the scanner has been closed when this method is called, or if this scanner is closed during stream pipeline execution. This method might block waiting for more input. For example, the following code will create a list of comma-delimited tokens from a string: The resulting list would contain , , the empty string, and . - if this scanner is closed\n• and then Returns a stream of match results from this scanner. The stream contains the same results in the same order that would be returned by callingand then successively as long as finds matches. The resulting stream is sequential and ordered. All stream elements are non-null. Scanning starts upon initiation of the terminal stream operation, using the current state of this scanner. Subsequent calls to any methods on this scanner other than and may return undefined results or may cause undefined effects on the returned stream. The returned stream's source is fail-fast and will, on a best-effort basis, throw a if any such calls are detected during stream pipeline execution. After stream pipeline execution completes, this scanner is left in an indeterminate state and cannot be reused. If this scanner contains a resource that must be released, this scanner should be closed, either by calling its method, or by closing the returned stream. Closing the stream will close the underlying scanner. is thrown if the scanner has been closed when this method is called, or if this scanner is closed during stream pipeline execution. As with the methods, this method might block waiting for additional input, and it might buffer an unbounded amount of input searching for a match. For example, the following code will read a file and return a list of all sequences of characters consisting of seven or more Latin capital letters: - the pattern to be matched - if this scanner is closed"
    },
    {
        "link": "https://download.java.net/java/early_access/panama/docs/api/java.base/java/util/class-use/Scanner.html",
        "document": "Report a bug or suggest an enhancement\n\n For further API reference and developer documentation see the Java SE Documentation, which contains more detailed, developer-targeted descriptions with conceptual overviews, definitions of terms, workarounds, and working code examples. Other versions.\n\n Java is a trademark or registered trademark of Oracle and/or its affiliates in the US and other countries.\n\n Copyright © 1993, 2022, Oracle and/or its affiliates, 500 Oracle Parkway, Redwood Shores, CA 94065 USA.\n\nAll rights reserved. Use is subject to license terms and the documentation redistribution policy. \n\nDRAFT 19-panama+1-13"
    },
    {
        "link": "https://devdocs.io/openjdk~17",
        "document": ""
    },
    {
        "link": "https://igm.univ-mlv.fr/~juge/javadoc-19/java.base/java/util/Scanner.html",
        "document": "\n• Returns a stream of delimiter-separated tokens from this scanner. The stream contains the same tokens that would be returned, starting from this scanner's current state, by calling the method repeatedly until the method returns false. The resulting stream is sequential and ordered. All stream elements are non-null. Scanning starts upon initiation of the terminal stream operation, using the current state of this scanner. Subsequent calls to any methods on this scanner other than and may return undefined results or may cause undefined effects on the returned stream. The returned stream's source is fail-fast and will, on a best-effort basis, throw a if any such calls are detected during stream pipeline execution. After stream pipeline execution completes, this scanner is left in an indeterminate state and cannot be reused. If this scanner contains a resource that must be released, this scanner should be closed, either by calling its method, or by closing the returned stream. Closing the stream will close the underlying scanner. is thrown if the scanner has been closed when this method is called, or if this scanner is closed during stream pipeline execution. This method might block waiting for more input. For example, the following code will create a list of comma-delimited tokens from a string: The resulting list would contain , , the empty string, and . - if this scanner is closed\n• and then Returns a stream of match results from this scanner. The stream contains the same results in the same order that would be returned by callingand then successively as long as finds matches. The resulting stream is sequential and ordered. All stream elements are non-null. Scanning starts upon initiation of the terminal stream operation, using the current state of this scanner. Subsequent calls to any methods on this scanner other than and may return undefined results or may cause undefined effects on the returned stream. The returned stream's source is fail-fast and will, on a best-effort basis, throw a if any such calls are detected during stream pipeline execution. After stream pipeline execution completes, this scanner is left in an indeterminate state and cannot be reused. If this scanner contains a resource that must be released, this scanner should be closed, either by calling its method, or by closing the returned stream. Closing the stream will close the underlying scanner. is thrown if the scanner has been closed when this method is called, or if this scanner is closed during stream pipeline execution. As with the methods, this method might block waiting for additional input, and it might buffer an unbounded amount of input searching for a match. For example, the following code will read a file and return a list of all sequences of characters consisting of seven or more Latin capital letters: - the pattern to be matched - if this scanner is closed"
    },
    {
        "link": "https://nextgenbootcamp.com/blog/java-exception-handling-best-practices-for-error-management",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/7304067/using-exceptions-to-validate-inputs",
        "document": "I am trying to check whether the value passed by an user is valid constant or not. Here is the code I have written.\n\nNow, in above code if the String passed is not withing the listed enum then it throws which is obvious.\n\nBut my question is: Is this the proper way to validate? As we are using Java's exception mechanism to validate.\n\nCan someone suggest a better idea or what I have coded above itself is the best option ?\n\nAnother case which I wanted to discuss:\n\nSo is this a good idea ? Or there should be our own parsing mechanism?"
    },
    {
        "link": "https://medium.com/@AlexanderObregon/effective-error-handling-in-java-strategies-and-best-practices-b64226c9970b",
        "document": "Error handling is a critical aspect of software development, especially in a robust and strongly-typed language like Java. Proper error and exception handling ensures that your application can gracefully handle unexpected situations, maintaining its stability and providing a better user experience. In this post, we will take a look at some strategies and best practices for effective error handling in Java.\n\nJava exceptions are broadly classified into two categories: checked and unchecked exceptions. Understanding the distinction and appropriate use of these exceptions is crucial for effective error handling.\n• Definition: Checked exceptions are exceptions that are checked at compile-time. They represent conditions that a reasonable application might want to catch.\n• Handling Strategy: These exceptions must be either caught using try-catch blocks or declared in the method signature using the keyword.\n• Best Practice: Use checked exceptions for recoverable conditions and where the caller can take meaningful action.\n• Definition: Unchecked exceptions are not checked at compile time. They include runtime exceptions and errors.\n• Handling Strategy: Generally, these exceptions indicate programming errors and are not expected to be caught under normal circumstances.\n• Best Practice: Use unchecked exceptions to indicate programming errors, such as logic errors or incorrect API usage.\n\nBest Practices for Using Exceptions\n\nException handling, if done improperly, can lead to code that is difficult to maintain and debug. Following best practices ensures that exceptions serve their intended purpose without causing additional issues.\n\nUse Exceptions for Exceptional Conditions Only\n• Rationale: Exceptions should not be used for regular control flow but for circumstances that are unexpected and outside the normal operation of the program.\n• Example: Do not use exceptions for flow control like exiting loops.\n• Rationale: Catching too generic an exception, such as or , can often hide bugs.\n• Best Approach: Catch specific exceptions to handle known error conditions and let the rest propagate.\n• Rationale: Documenting the exceptions your methods can throw helps other developers understand the error conditions they must handle.\n• Implementation: Use the tag in JavaDoc to document each exception that a method can throw.\n• Strategy: Understand when to use unchecked versus checked exceptions. Checked exceptions should be used for conditions from which the caller can reasonably be expected to recover.\n\nDo Not Suppress or Ignore Exceptions\n• Rationale: Ignoring exceptions, often seen with empty catch blocks, can lead to subtle bugs that are hard to trace.\n• Best Practice: If you choose not to handle an exception, at least log it to provide a trail for debugging.\n• Concept: Java’s exception hierarchy is designed to categorize exceptions in a meaningful way.\n• Implementation: Leverage this hierarchy in your application to create more manageable and maintainable error handling structures.\n• is the root class of Java's exception hierarchy.\n• and are two subclasses of .\n\nUnderstanding and utilizing this hierarchy allows for more precise and effective error handling, making your Java application more robust and user-friendly.\n\nException handling in Java is not just about catching and throwing exceptions but also about using them effectively to make your application robust and maintainable. Here we delve deeper into various techniques and best practices.\n\nThe try-catch-finally construct is fundamental to exception handling in Java, providing a clear structure for managing exceptions.\n• Usage: Encloses code that might throw an exception.\n• Best Practice: Keep the code within try blocks minimal and specific to operations that might throw exceptions to avoid catching unintended exceptions.\n• Usage: Catches and handles specific exceptions thrown within the try block.\n• Best Practice: Always catch the most specific exception first, followed by more general exceptions, to handle specific cases appropriately.\n• Usage: Executes code after the try and catch blocks, regardless of whether an exception was thrown.\n• Common Use: Ideal for resource cleanup, like closing file streams or database connections.\n• Best Practice: Ensure the finally block does not throw an exception itself, which could potentially obscure exceptions thrown in the try block.\n• Concept: In Java, exceptions propagate up the call stack until they are caught in a catch block.\n• Handling Strategy: Allow exceptions to propagate to a level where they can be handled meaningfully.\n• Best Practice: Do not catch exceptions early if the catching block cannot handle them effectively.\n\nJava 7 introduced the multi-catch feature, which allows catching multiple exceptions in a single catch block, reducing code duplication.\n• Usage: Sometimes you may want to catch an exception to log it or perform some action, then rethrow it.\n• Best Practice: When rethrowing exceptions, consider wrapping them in a new exception, especially if the context of the original exception might not be clear to the caller.\n\nJava 7 introduced the try-with-resources statement, which simplifies the management of resources like streams, connections, and files.\n\nIn this example, the will be automatically closed when the try block is exited, either normally or due to an exception.\n• Issue: In a try-catch-finally block, if both the try and finally blocks throw exceptions, the one from the finally block hides the one from the try block.\n• Solution: Be cautious when writing code in the finally block that can throw exceptions.\n\nIn Java, custom exceptions are not just a means of signaling error conditions but also a powerful tool for communicating specific issues and enhancing code readability. Creating your own exceptions can greatly improve the maintainability and clarity of your code, especially in larger applications or libraries.\n\nThe Role of Custom Exceptions in Java\n\nCustom exceptions serve a crucial role in distinguishing between different types of errors in your application. They are particularly useful when standard Java exceptions do not adequately describe the problem. For instance, if you’re building a financial application, having a could provide more context and clarity than a generic .\n\nWhen and How to Create Custom Exceptions\n\nCreating a custom exception is appropriate when you need to represent a specific error condition that is not adequately covered by existing Java exceptions. The process of creating a custom exception is straightforward yet powerful. Typically, you would extend either for checked exceptions or for unchecked exceptions, depending on the nature of the error you're dealing with.\n\nA custom exception should provide constructors that are found in other exceptions. This usually includes constructors that accept just a message, as well as those that accept both a message and a cause. By doing this, your custom exception fits well within the standard exception framework of Java.\n\nAn Example of a Custom Exception\n\nConsider an application that processes user data. You might encounter a situation where user data is incomplete or invalid. In such a case, a could be a meaningful addition to your exception handling strategy.\n\nThis exception can then be used in your code to specifically handle errors related to user data, making your code more readable and maintainable.\n\nThe Benefits of Using Custom Exceptions\n\nUsing custom exceptions has several advantages:\n• Improved Readability: Custom exceptions make your code more readable and self-documenting. When someone else (or you, in the future) reads your code, they can immediately understand the kind of error being handled.\n• Enhanced Maintainability: With custom exceptions, it’s easier to pinpoint issues and make updates. If a particular type of error requires a different handling strategy, you only need to update the code in one place.\n• Better Error Tracking: Custom exceptions can make logging and monitoring more effective. Specific error types can be tracked and logged, providing clearer insights into the application’s behavior.\n\nCustom exceptions, when used thoughtfully, can significantly enhance the robustness and clarity of your Java application. They enable you to communicate specific problems more effectively, leading to code that is not only easier to manage but also more intuitive to anyone who works with it.\n\nIn Java development, logging and diagnosing exceptions is as crucial as handling them. Effective logging can transform the chaotic process of diagnosing issues into a structured and manageable task. This section delves into the strategies and considerations for logging exceptions and diagnosing problems in Java applications.\n\nException logging is much more than just recording an error message. It’s about capturing the context and the sequence of events that led to the exception. This information is invaluable when diagnosing issues, especially in complex applications where reproducing the problem can be challenging.\n\nWhen an exception occurs, understanding the state of the application at that point can be vital in diagnosing the issue. This means logging not just the exception itself, but also key variables and system state information. However, it’s important to balance this need against the risks of logging sensitive information. For example, while it might be helpful to log user IDs or transaction IDs, you should avoid logging sensitive personal data or credentials.\n\nA stack trace is a report of the active stack frames at a certain point in time during the execution of a program. When an exception is thrown, Java automatically produces a stack trace that can be incredibly helpful for debugging. Always include the stack trace when logging exceptions. It not only shows where the exception occurred but also the sequence of method calls that led to it.\n\nJava’s logging frameworks typically offer different levels such as DEBUG, INFO, WARN, ERROR, and FATAL. Choosing the right level for logging exceptions is crucial. For instance, use ERROR for serious issues that need immediate attention and WARN for situations that are not ideal but don’t necessarily stop the application from functioning.\n\nOnce logged, exception information becomes a primary tool for diagnosing issues. Effective diagnosis involves piecing together information from various logs to form a coherent picture of what went wrong.\n\nStart by identifying the first occurrence of the issue. Look for patterns or commonalities in the logged exceptions. Are they all coming from the same part of the application? Do they involve similar user actions or data inputs? Such analysis can quickly point you towards the root cause of the problem.\n\nIn modern applications, especially those that are distributed and cloud-based, the volume of logs can be enormous. Using tools for log aggregation and analysis can be immensely helpful. These tools can help you search through large volumes of log data, set up alerts based on log patterns, and even visualize log data to identify trends and anomalies.\n\nException logging and diagnosis in Java are about much more than just recording errors. It’s about creating a rich, contextual narrative that helps you understand not just what went wrong, but why. By carefully capturing context, respecting the importance of stack traces, choosing the appropriate logging levels, and systematically analyzing the logs, you can turn your logs into a powerful tool for maintaining and improving your Java applications.\n\nEffective error handling in Java is key to building robust and reliable applications. By understanding and utilizing Java’s exception handling mechanisms, adhering to best practices, and using custom exceptions and logging wisely, developers can significantly enhance the stability and maintainability of their applications. Remember, good error handling not only addresses the symptoms but also helps in diagnosing the root cause of issues."
    },
    {
        "link": "https://stackoverflow.com/questions/45783777/java-console-input-handling",
        "document": "This is my first question here, I hope it's not too based on opinions. I've searched on the internet for quite a while now, but couldn't find a similar question.\n\n I need to write a Java program that reads commands from the console, validates the input, gets the parameters and passes them on to a different class.\n\n There are some restrictions on what I can do and use (university).\n• Only the packages java.util, java.lang and java.io are allowed\n• Each method can only be 80 lines long\n• Each line can only be 120 characters long\n• I am not allowed to use System.exit / Runtime.exit\n• The Terminal class is used to handle user input. will read a line from the console, like\n\nI have a fully working program - however my solution will not be accepted because of the way I handle console inputs ( method too long). I'm doing it like this:\n• None The main class has the main method and an \"interaction loop\" where console inputs are handled. The main method calls the interaction loop in a while loop, with a boolean \"quit\" as a guardian.\n• None The interaction loop handles console input. I need to check for 16 different commands - each with their own types of parameters. I chose to work with Patterns and Matchers, because I can use the groups for convenience. Now the problems start - I have never learned how to correctly handle user inputs. What I have done here is, for each possible command, create a new Matcher, see if the input matches, if it does then do whatever needs to be done for this input. private static runInteractionLoop() { Matcher m; String query = Terminal.readLine; m = Pattern.compile(\"sliding-window (\\\\d+) (-?\\\\d+(?:\\\\.\\\\d+)?;)*(-?\\\\d+(?:\\\\.\\\\d+)?)\").matcher(query); if (m.matches()) { xyz.doSth(Integer.parseInt(m.group(1)), ......); ... return; } m = Pattern.compile(\"record ([a-z]+) (-?\\\\d+(?:\\\\.\\\\d+)?)\").matcher(query); if (m.matches()) { xyz.doSthElse(m.group(1), Double.parseDouble(m.group(2))); return; } ... if (query.equals(\"quit\")) { quit = true; return; } Terminal.printError(\"invalid input\"); }\n\nAs you can see, doing this 16 times stretches out the method to more than 80 lines (5 lines per input max). It's also obviously very inefficient and to be honest, I'm quite ashamed to be posting this here (crap code). I just don't know how to do this correctly, using only java.util and having some way to quickly get the parameters (e.g. the Matcher groups here).\n\n\n\n Any ideas? I would be very grateful for suggestions. Thanks.\n\nEDIT/UPDATE:\n\n I have made the decision to split the verification into two methods - one for each half of the commands. Looks ugly, but passes the Uni's checkstyle requirements. However, I'd still be more than happy if someone shows me a better solution to my problem - for the future (because I obviously have no idea how to make this prettier, shorter and/or more efficient)."
    },
    {
        "link": "https://cse.unl.edu/~scooper/securecoding/ExceptionsLab.pdf",
        "document": ""
    }
]