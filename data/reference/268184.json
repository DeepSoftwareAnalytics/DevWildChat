[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/CSS/transition",
        "document": "The property value is specified as one of the following:\n• The special value , which specifies that no transitions will occur on this element. This is the default value.\n• One or more single-property transitions, separated by commas.\n\nEach single-property transition describes the transition that should be applied to a single property or all properties. It includes:\n• zero or one value representing the property or properties to which the transition should apply. This can be set as:\n• The special value , which specifies that the transition will be applied to all properties that change as the element changes state.\n• No value, in which case a value of will be inferred and the specified transition will still apply to all changing properties.\n• zero or one value representing the easing function to use\n• zero, one, or two values. The first value that can be parsed as a time is assigned to the , and the second value that can be parsed as a time is assigned to .\n• zero or one value declaring whether to start transitions for properties whose animation behavior is discrete. The value, if present, is either the keyword or the keyword .\n\nIf you specify as the transition property for one single-property transition, but then specify subsequent single-property transitions with values, those subsequent transitions will override the first one. For example:\n\nIn this case, all the properties that change as the element changes state will transition with a duration of 200ms except for , which will take 400ms to transition.\n\nSee how things are handled when lists of property values aren't the same length. In short, extra transition descriptions beyond the number of properties actually being animated are ignored."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_transitions/Using_CSS_transitions",
        "document": "CSS transitions provide a way to control animation speed when changing CSS properties. Instead of having property changes take effect immediately, you can cause the changes in a property to take place over a period of time. For example, if you change the color of an element from white to black, usually the change is instantaneous. With CSS transitions enabled, changes occur at time intervals that follow an acceleration curve, all of which can be customized. Animations that involve transitioning between two states are often called implicit transitions as the states in between the start and final states are implicitly defined by the browser. CSS transitions let you decide which properties to animate (by listing them explicitly), when the animation will start (by setting a delay), how long the transition will last (by setting a duration), and how the transition will run (by defining an easing function, e.g., linearly or quick at the beginning, slow at the end).\n\nWhich CSS properties can be transitioned? The Web author can define which property has to be animated and in which way. This allows the creation of complex transitions. However, some properties are not animatable as it doesn't make sense to animate them. Note: The value is often a very complex case. The specification recommends not animating from and to . Some user agents, like those based on Gecko, implement this requirement and others, like those based on WebKit, are less strict. Using animations with may lead to unpredictable results, depending on the browser and its version, and should be avoided.\n\nCSS Transitions are controlled using the shorthand property. This is the best way to configure transitions, as it makes it easier to avoid out of sync parameters, which can be very frustrating to have to spend lots of time debugging in CSS. You can control the individual components of the transition with the following sub-properties: Specifies the name or names of the CSS properties to which transitions should be applied. Only properties listed here are animated during transitions; changes to all other properties occur instantaneously as usual. Specifies the duration over which transitions should occur. You can specify a single duration that applies to all properties during the transition, or multiple values to allow each property to transition over a different period of time. Specifies a function to define how intermediate values for properties are computed. Easing functions determine how intermediate values of the transition are calculated. Most easing functions can be specified by providing the graph of the corresponding function, as defined by four points defining a cubic bezier. You can also choose easing from Easing functions cheat sheet. Defines how long to wait between the time a property is changed and the transition actually begins. The shorthand CSS syntax is written as follows:\n\nWhen property value lists are of different lengths If any property's list of values is shorter than the others, its values are repeated to make them match. For example: This is treated as if it were: Similarly, if any property's value list is longer than that for , it's truncated, so if you have the following CSS: This gets interpreted as:\n\nA common use of CSS is to highlight items in a menu as the user hovers the mouse cursor over them. It's easy to use transitions to make the effect even more attractive. First, we set up the menu using HTML: Then we build the CSS to implement the look and feel of our menu: This CSS establishes the look of the menu, with the background and text colors both changing when the element is in its and states:\n\nThis example demonstrates how and can be transitioned. This behavior is useful for creating entry/exit animations where you want to for example remove a container from the DOM with , but have it fade out with rather than disappearing immediately. Supporting browsers transition and with a variation on the discrete animation type. This generally means that properties will flip between two values 50% through animating between the two. There is an exception, however, which is when animating to/from or . In this case, the browser will flip between the two values so that the transitioned content is shown for the entire animation duration.\n• When animating from to (or another visible value), the value will flip to at of the animation duration so it is visible throughout.\n• When animating from (or another visible value) to , the value will flip to at of the animation duration so it is visible throughout. When transitioning these properties needs to be set on the transitions. This effectively enables / transitions. When transitioning , is needed to provide a set of starting values for properties set on an element that you want to transition from when the element receives its first style update. This is needed to avoid unexpected behavior. By default, CSS transitions are not triggered on elements' first style updates when they first appear in the DOM, which includes when changes from to another state. animations do not need starting values specified in a block. This is because doesn't hide an element from the DOM like does: it just skips rendering the element's content. The HTML contains two elements with a in between that we will animate from to . <p> Click anywhere on the screen or press any key to toggle the <code><div></code> between hidden and showing. </p> <div> This is a <code><div></code> element that transitions between <code>display: none; opacity: 0</code> and <code>display: block; opacity: 1</code>. Neat, huh? </div> <p> This is another paragraph to show that <code>display: none;</code> is being applied and removed on the above <code><div> </code>. If only its <code>opacity</code> was being changed, it would always take up the space in the DOM. </p> html { height: 100vh; } div { font-size: 1.6rem; padding: 20px; border: 3px solid red; border-radius: 20px; width: 480px; display: none; opacity: 0; transition: opacity 1s, display 1s allow-discrete; /* Equivalent to transition: all 1s allow-discrete; */ } .showing { opacity: 1; display: block; } @starting-style { .showing { opacity: 0; } } Note the block used to specify the starting style for the transition, and the inclusion of the property in the transitions list, with set on it. Finally, we include a bit of JavaScript to set up event listeners to trigger the transition (via the class). The code renders as follows:"
    },
    {
        "link": "https://w3schools.com/HOWTO/howto_css_transition_hover.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://web.dev/learn/css/transitions",
        "document": "Chrome is back at Google I/O on May 20-21! Register now\n\nStay organized with collections Save and categorize content based on your preferences.\n\nWhen interacting with a website, you might notice that many elements have state. For example, dropdowns can be in opened or closed states. Buttons might change color when focused or hovered. Modals appear and disappear.\n\nBy default, CSS switches the style of these states instantly.\n\nUsing CSS transitions, we can interpolate between the initial state and the target state of the element. The transition between the two enhances the user experience by providing visual direction, support, and hints about the cause and effect of the interaction.\n\nTo use transitions in CSS, you can use the various transition properties or the shorthand property.\n\nThe property specifies which style(s) to transition.\n\nThe accepts one or more CSS property names in a comma-separated list.\n\nOptionally, you may use to indicate that every property should transition.\n\nThe property is used to define the length of time that a transition will take to complete.\n\naccepts time units, either in seconds ( ) or milliseconds ( ) and defaults to .\n\nUse the property to vary the speed of a CSS transition over the course of the .\n\nBy default, CSS will transition your elements at a constant speed ( ). Linear transitions can end up looking somewhat artificial, though: in real life, objects have weight and can't stop and start instantly. Easing into or out of a transition can make your transitions more lively and natural.\n\nOur module on CSS Animation has a good overview of timing functions.\n\nYou can use DevTools to experiment with different timing functions in real-time.\n\nUse the property to specify the time at which a transition will start. If is not specified, transitions will start instantly because the default value is . This property accepts a time unit, for example seconds ( ) or milliseconds ( ).\n\nThis property is useful for staggering transitions, achieved by setting a longer for each subsequent element in a group.\n\nis also useful for debugging. Setting the delay to a negative value can start a transition further into the timeline.\n\nLike most CSS properties, there is a shorthand version. combines , , , and .\n\nWhat can and can't transition?\n\nWhen writing CSS, you can specify which properties should have animated transitions. See this MDN list of animatable CSS properties.\n\nIn general, it's only possible to transition elements that can have a \"middle state\" between their start and final states. For example, it's impossible to add transitions for , because it's unclear what the \"middle state\" between and should look like. On the other hand, it is possible to add transitions for because its unit is a length that can be interpolated between.\n\nHere are some common properties you can transition.\n\nThe CSS property is commonly transitioned because it is a GPU-accelerated property that results in smoother animation that also consumes less battery. This property lets you arbitrarily scale, rotate, translate, or skew an element.\n\nCheck out the section on transforms in our Functions module.\n\nBefore, during, and after interaction, color can be a great indicator of state. For example, a button might change color if it's being hovered. This color change can provide feedback to the user that the button is clickable.\n\nThe , , and properties are just a few places where color can be transitioned upon interaction.\n\nCheck out our module on color.\n\nShadows are often transitioned to indicate elevation change, like from user focus.\n\nCheck out our module on shadows.\n\nis a powerful CSS property that lets you add graphic effects on the fly. Transitioning between different states can create some pretty impressive results.\n\nCheck out our module on filters.\n\nYour CSS must include a change of state and an event that triggers that state change for CSS transitions to activate. A typical example of such a trigger is the pseudo-class. This pseudo-class matches when the user hovers over an element with their cursor.\n\nBelow is a list of some pseudo-classes and events that can trigger state changes in your elements.\n• : matches if the cursor is over the element.\n• : matches if the element is focused.\n• : matches if the element or any of its descendants are focused.\n• : matches when the current URL's fragment matches the element's id.\n• : matches when the element is being activated (typically when the mouse is pressed over it).\n• change from JavaScript: when an element's CSS changes via JavaScript, CSS will transition eligible properties that have changed.\n\nDifferent transitions for enter or exit\n\nBy setting different properties on hover/focus, it's possible to create some interesting effects.\n\nCSS transitions are not for everyone. For some people, transitions and animations can cause motion sickness or discomfort. Thankfully, CSS has a media feature called that detects if a user has indicated a preference for less motion from their device.\n\nCheck out our blog post prefers-reduced-motion: Sometimes less movement is more for more information on this media feature.\n\nWhen working with CSS transitions, you may encounter performance issues if you add transitions for certain CSS properties. For example, when properties such as or change, they push content around on the rest of the page. This forces CSS to calculate new positions for every affected element for each frame of the transition. When possible, we recommend using properties like and instead.\n\nCheck out our guide on high-performance CSS animations for a deep-dive on this topic."
    },
    {
        "link": "https://joshwcomeau.com/animation/css-transitions",
        "document": "The world of web animations has become a sprawling jungle of tools and technologies. Libraries like GSAP and Framer Motion and React Spring have sprung up to help us add motion to the DOM.\n\nThe most fundamental and critical piece, though, is the humble CSS transition. It's the first animation tool that most front-end devs learn, and it's a workhorse. Even the most grizzled, weathered animation veterans still reach for this tool often.\n\nThere's a surprising amount of depth to this topic. In this tutorial, we'll dig in and learn a bit more about CSS transitions, and how we can use them to create lush, polished animations.\n\nThe main ingredient we need to create an animation is some CSS that changes.\n\nHere's an example of a button that moves on hover, without animating:\n\nThis snippet uses the pseudoclass to specify an additional CSS declaration when the user's mouse rests atop our button, similar to an event in JavaScript.\n\nTo shift the element up, we use . While we could have used for this, is a better tool for the job. We'll see why later.\n\nBy default, changes in CSS happen instantaneously. In the blink of an eye, our button has teleported to a new position! This is incongruous with the natural world, where things happen gradually.\n\nWe can instruct the browser to interpolate from one state to another with the aptly-named property:\n\ncan take a number of values, but only two are required:\n• None The name of the property we wish to animate\n• None The duration of the animation\n\nIf you plan on animating multiple properties, you can pass it a comma-separated list:\n\nWhen we tell an element to transition from one position to another, the browser needs to work out what each \"intermediary\" frame should look like.\n\nFor example: let's say that we're moving an element from left to right, over a 1-second duration. A smooth animation should run at 60fps Frames Per Second, the number of times the element is redrawn in a second , which means we'll need to come up with 60 individual positions between the start and end.\n\nLet's start by having them be evenly-spaced:\n\nTo clarify what's going on here: each faded circle represents a moment in time. As the circle moves from left to right, these are the frames that were shown to the user. It's like a flipbook.\n\nIn this animation, we're using a linear timing function. This means that the element moves at a constant pace; our circle moves by the same amount each frame.\n\nThere are several timing functions available to us in CSS. We can specify which one we want to use with the property:\n\nOr, we can pass it directly to the shorthand property:\n\nis rarely the best choice — after all, pretty much nothing in the real world moves this way Maybe 3D printers come the closest? But if someone told us we danced like a 3D printer, we'd probably be offended. So we shouldn't aspire to this. . Good animations mimic the natural world, so we should pick something more organic!\n\ncomes charging in like a wild bull, but it runs out of energy. By the end, it's pootering along like a sleepy turtle.\n\nTry scrubbing with the timeline; notice how drastic the movement is in the first few frames, and how subtle it becomes towards the end.\n\nIf we were to graph the displacement of the element over time, it'd look something like this:\n\nWhen would you use ? It's most commonly used when something is entering from off-screen (eg. a modal appearing). It produces the effect that something came hustling in from far away, and settles in front of the user.\n\n, unsurprisingly, is the opposite of . It starts slow and speeds up:\n\nAs we saw, is useful for things that enter into view from offscreen. , naturally, is useful for the opposite: moving something beyond the bounds of the viewport.\n\nThis combo is useful when something is entering and exiting the viewport, like a modal. We'll look at how to mix and match timing functions shortly.\n\nNote that is pretty much exclusively useful for animations that end with the element offscreen or invisible; otherwise, the sudden stop can be jarring.\n\nNext up, . It's the combination of the previous two timing functions:\n\nThis timing function is symmetrical. It has an equal amount of acceleration and deceleration.\n\nI find this curve most useful for anything that happens in a loop (eg. an element fading in and out, over and over).\n\nIt's a big step-up over , but before you go slapping it on everything, let's look at one more option.\n\nIf I had a bone to pick with the CSS language authors when it comes to transitions, it's that is poorly named. It isn't descriptive at all; literally all timing functions are eases of one sort or another!\n\nThat nitpick aside, is awesome. Unlike , it isn't symmetrical; it features a brief ramp-up, and a lot of deceleration.\n\nis the default value — if you don't specify a timing function, gets used. Honestly, this feels right to me. is a great option in most cases. If an element moves, and isn't entering or exiting the viewport, is usually a good choice.\n\nIf the provided built-in options don't suit your needs, you can define your own custom easing curve, using the cubic bézier timing function!\n\nAll of the values we've seen so far are really just presets for this function. It takes 4 numbers, representing 2 control points.\n\nBézier curves are really nifty, but they're beyond the scope of this tutorial. I'll be writing more about them soon though!\n\nIn the meantime, you can start creating your own Bézier timing functions using this wonderful helper from Lea Verou (opens in new tab):\n\nOnce you come up with an animation curve you're satisfied with, click “Copy” at the top and paste it into your CSS!\n\nYou can also pick from this extended set of timing functions (opens in new tab). Though beware: a few of the more outlandish options won't work in CSS.\n\nWhen starting out with custom Bézier curves, it can be hard to come up with a curve that feels natural. With some practice, however, this is an incredibly expressive tool.\n\nEarlier, we mentioned that animations ought to run at 60fps. When we do the math, though, we realize that this means the browser only has 16.6 milliseconds to paint each frame. That's really not much time at all; for reference, it takes us about 100ms-300ms to blink!\n\nIf our animation is too computationally expensive, it'll appear janky and stuttery. Frames will get dropped, as the device can't keep up.\n\nExperience this for yourself by tweaking the new \"Frames per second\" control:\n\nIn practice, poor performance will often take the form of variable framerates, so this isn't a perfect simulation.\n\nAnimation performance is a surprisingly deep and interesting area, well beyond the scope of this introductory tutorial. But let's cover the absolutely-critical, need-to-know bits:\n• None Some CSS properties are wayyy more expensive to animate than others. For example, is a very expensive property because it affects layout. When an element's height shrinks, it causes a chain reaction; all of its siblings will also need to move up, to fill the space!\n• None Other properties, like , are somewhat expensive to animate. They don't affect layout, but they do require a fresh coat of paint on every frame, which isn't cheap.\n• None Two properties — and — are very cheap to animate. If an animation currently tweaks a property like or , it can be greatly improved by moving it to (though it isn't always possible to achieve the exact same effect).\n• None Be sure to test your animations on the lowest-end device that your site/app targets. Your development machine is likely many times faster than it.\n\nIf you're interested in learning more about animation performance, I gave a talk on this subject at React Rally. It goes deep into this topic:\n\nDepending on your browser and OS, you may have noticed a curious little imperfection in some of the earlier examples:\n\nPay close attention to the letters. Notice how they appear to glitch slightly at the start and end of the transition, as if everything was locking into place?\n\nThis happens because of a hand-off between the computer's CPU and GPU. Let me explain.\n\nWhen we animate an element using and , the browser will sometimes try to optimize this animation. Instead of rasterizing the pixels on every frame, it transfers everything to the GPU as a texture. GPUs are very good at doing these kinds of texture-based transformations, and as a result, we get a very slick, very performant animation. This is known as “hardware acceleration”.\n\nHere's the problem: GPUs and CPUs render things slightly differently. When the CPU hands it to the GPU, and vice versa, you get a snap of things shifting slightly.\n\nWe can fix this problem by adding the following CSS property:\n\nis a property that allows us to hint to the browser that we're going to animate the selected element, and that it should optimize for this case.\n\nIn practice, what this means is that the browser will let the GPU handle this element all the time. No more handing-off between CPU and GPU, no more telltale “snapping into place”.\n\nlets us be intentional about which elements should be hardware-accelerated. Browsers have their own inscrutable logic around this stuff, and I'd rather not leave it up to chance.\n\nThere's another benefit to hardware acceleration: we can take advantage of sub-pixel rendering.\n\nCheck out these two boxes. They shift down when you hover/focus them. One of them is hardware-accelerated, and the other one isn't.\n\nIt's maybe a bit subtle, depending on your device and your display, but one box moves much more smoothly than the other.\n\nProperties like can't sub-pixel-render, which means they need to round to the nearest pixel, creating a stepped, janky effect. , meanwhile, can smoothly shift between pixels, thanks to the GPU's anti-aliasing trickery.\n\nLet's take another look at our rising “Hello World” button.\n\nAs it stands, we have a \"symmetrical\" transition — the enter animation is the same as the exit animation:\n• None When the mouse hovers over the element, it shifts up by 10 pixels over 250ms\n• None When the mouse moves away, the element shifts down by 10 pixels over 250ms\n\nA cute little detail is to give each action its own transition settings. For hover animations, I like to make the enter animation quick and snappy, while the exit animation can be a bit more relaxed and lethargic:\n\nAnother common example is modals. It can be useful for modals to enter with an animation, and to exit with a quicker animation:\n\nThis is a small detail, but it speaks to a much larger idea.\n\nI believe most developers think in terms of states: for example, you might look at this situation and say that we have a “hover” state and a default state. Instead, what if we thought in terms of actions? We animate based on what the user is doing, thinking in terms of events, not states. We have a mouse-enter animation and a mouse-leave animation.\n\nTobias Ahlin shows how this idea can create next-level semantically-meaningful animations in his blog post, Meaningfun Motion with Action-Driven Animation (opens in new tab).\n\nWell, we've come pretty far in our quest to become proficient with CSS transitions, but there are a couple final details to go over. Let's talk about transition delays.\n\nI believe that just about everyone has had this frustrating experience before:\n\nAs a developer, you can probably work out why this happens: the dropdown only stays open while being hovered! As we move the mouse diagonally to select a child, our cursor dips out-of-bounds, and the menu closes.\n\nThis problem can be solved in a rather elegant way without needing to reach for JS. We can use !\n\nallows us to keep things status-quo for a brief interval. In this case, when the user moves their mouse outside , nothing happens for 300ms. If their mouse re-enters the element within that 300ms window, the transition never takes place.\n\nAfter 300ms elapses, the kicks in normally, and the dropdown fades out over 400ms.\n\nWhen an element is moved up or down on hover, we need to be very careful we don't accidentally introduce a \"doom flicker\":\n\nYou may have noticed a similar effect on some of the demos on this page!\n\nThe trouble occurs when the mouse is near the element's boundary. The hover effect takes the element out from under the mouse, which causes it to fall back down under the mouse, which causes the hover effect to trigger again… many times a second.\n\nHow do we solve for this? The trick is to separate the trigger from the effect. Here's a quick example:\n\nOur now has a new child, . This span houses all of the cosmetic styles (background color, font stuff, etc).\n\nWhen we mouse over the plain-jane button, it causes the child to peek out above. The button, however, is stationary.\n\nTry uncommenting the to see exactly what's going on!\n\nWhen I see a well-crafted animation on the web, I react with delight and glee. People are different, though, and some folks have a very different reaction: nausea and malaise.\n\nI've written before about respecting “prefers-reduced-motion”, an OS-level setting users can toggle to express a preference for less motion. Let's apply those lessons here, by disabling animations for folks who request it:\n\nThis small tweak means that animations will resolve immediately for users who have gone into their system preferences and toggled a checkbox.\n\nAs front-end developers, we have a certain responsibility to ensure that our products aren't causing harm. This is a quick step we can perform to make our sites/apps friendlier and safer.\n\nCSS transitions are fundamental, but that doesn't mean they're easy. There's a surprising amount of depth to them; even in this long-winded blog post, I've had to cut some stuff out to keep it manageable!\n\nWeb animations are more important than most developers realize. A single transition here or there won't make or break an experience, but it adds up. In aggregate, well-executed animations can have a surprisingly profound effect on the overall user experience.\n\nTransitions can make an app feel \"real\". They can offer feedback, and communicate in a more-visceral way than copy alone. They can teach people how to use your products. They can spark joy.\n\nSo, I have a confession to make: this tutorial was plucked straight from my CSS course, CSS for JavaScript Developers (opens in new tab). If you found this tutorial helpful, you should know that this is only the tip of the iceberg!\n\nMy course is designed to give you confidence with CSS. We explore how the language really works, building up a mental model you can use to solve any layout/UI challenge.\n\nIt's not like any other course you've taken. It's built on the same tech stack as this blog, and so there's lots of rich interactive content, but there are also bite-sized videos, tons of exercises, and real-world-inspired projects where you can test your knowledge. There are even some mini-games!\n\nLearn more and see if you'd benefit from it at https://css-for-js.dev:\n\nFinally, no interactive lesson is complete without a Sandbox Mode! Play with all the previous settings (and a couple new ones!) and create some generative art with this open-ended widget:"
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Element/mouseleave_event",
        "document": "This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015 .\n\nThe event is fired at an when the cursor of a pointing device (usually a mouse) is moved out of it.\n\nand are similar but differ in that does not bubble and does. This means that is fired when the pointer has exited the element and all of its descendants, whereas is fired when the pointer leaves the element or leaves one of the element's descendants, because of bubbling (even if the pointer is still within the element). Other than that, leave and out events for the same situation are dispatched at the same time, if appropriate.\n\nThe and events will not be triggered when the element is replaced or removed from the DOM.\n\nNote that \"moving out of an element\" refers to the element's position in the DOM tree, not to its visual position. For example, if two sibling elements are positioned so one is placed inside the other, then moving from the outer element into the inner element will trigger on the outer element, even though the pointer is still in the bounds of the outer element."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Element/mouseenter_event",
        "document": "The event is fired at an when a pointing device (usually a mouse) is initially moved so that its hotspot is within the element at which the event was fired. Note that \"moving into an element\" refers to the element's position in the DOM tree, not to its visual position. For example, if a child element is positioned so it is placed outside its parent, then moving into the child element will trigger on the parent element, even though the pointer is still outside the bounds of the parent element.\n\nThis interface also inherits properties of its parents, and . Returns if the key was down when the mouse event was fired. The button number that was pressed (if applicable) when the mouse event was fired. The buttons being pressed (if any) when the mouse event was fired. The X coordinate of the mouse pointer in viewport coordinates. The Y coordinate of the mouse pointer in viewport coordinates. Returns if the key was down when the mouse event was fired. Returns the horizontal coordinate of the event relative to the current layer. Returns the vertical coordinate of the event relative to the current layer. Returns if the key was down when the mouse event was fired. The X coordinate of the mouse pointer relative to the position of the last event. The Y coordinate of the mouse pointer relative to the position of the last event. The X coordinate of the mouse pointer relative to the position of the padding edge of the target node. The Y coordinate of the mouse pointer relative to the position of the padding edge of the target node. The X coordinate of the mouse pointer relative to the whole document. The Y coordinate of the mouse pointer relative to the whole document. The secondary target for the event, if there is one. The X coordinate of the mouse pointer in screen coordinates. The Y coordinate of the mouse pointer in screen coordinates. Returns if the key was down when the mouse event was fired. The type of device that generated the event (one of the constants). This lets you, for example, determine whether a mouse event was generated by an actual mouse or by a touch event (which might affect the degree of accuracy with which you interpret the coordinates associated with the event). The amount of pressure applied when clicking.\n\nThough similar to , differs in that it doesn't bubble and it isn't sent to any descendants when the pointer is moved from one of its descendants' physical space to its own physical space. Other than that, enter and over events for the same situation are dispatched at the same time, if appropriate.\n\nThis describes the mouseenter events received by each of four concentric divs with no padding or margin, so the events all happen at the same time: One event is sent to each element of the hierarchy when entering them. Here 4 events are sent to the four elements of the hierarchy when the pointer reaches the text.\n\nA single event is sent to the deepest element of the DOM tree, then it bubbles up the hierarchy until it is canceled by a handler or reaches the root. With deep hierarchies, the number of events sent can be quite huge and cause significant performance problems. In such cases, it is better to listen for events. Combined with the corresponding (which is fired at the element when the mouse exits its content area), the event acts in a very similar way to the CSS pseudo-class."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent",
        "document": "This interface also inherits properties of its parents, and .\n\nReturns if the key was down when the mouse event was fired.\n\nThe button number that was pressed or released (if applicable) when the mouse event was fired.\n\nThe buttons being pressed (if any) when the mouse event was fired.\n\nReturns if the key was down when the mouse event was fired.\n\nReturns if the key was down when the mouse event was fired.\n\nThe X coordinate of the mouse pointer relative to the position of the last event.\n\nThe Y coordinate of the mouse pointer relative to the position of the last event.\n\nThe X coordinate of the mouse pointer relative to the position of the padding edge of the target node.\n\nThe Y coordinate of the mouse pointer relative to the position of the padding edge of the target node.\n\nThe secondary target for the event, if there is one.\n\nReturns if the key was down when the mouse event was fired.\n\nThe type of device that generated the event (one of the constants). This lets you, for example, determine whether a mouse event was generated by an actual mouse or by a touch event (which might affect the degree of accuracy with which you interpret the coordinates associated with the event)."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Element/mouseout_event",
        "document": "This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015 .\n\nThe event is fired at an when a pointing device (usually a mouse) is used to move the cursor so that it is no longer contained within the element or one of its children.\n\nis also delivered to an element if the cursor enters a child element, because the child element obscures the visible area of the element.\n\nIf the target element has child elements, and events fire as the mouse moves over the boundaries of these elements too, not just the target element itself. Usually, and events' behavior is more sensible, because they are not affected by moving into child elements."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Pointer_events",
        "document": "Much of today's web content assumes the user's pointing device will be a mouse. However, since many devices support other types of pointing input devices, such as pen/stylus and touch surfaces, extensions to the existing pointing device event models are needed. Pointer events address that need. Pointer events are DOM events that are fired for a pointing device. They are designed to create a single DOM event model to handle pointing input devices such as a mouse, pen/stylus or touch (such as one or more fingers). The pointer is a hardware-agnostic device that can target a specific set of screen coordinates. Having a single event model for pointers can simplify creating websites and applications and provide a good user experience regardless of the user's hardware. However, for scenarios when device-specific handling is desired, pointer events defines a property to inspect the device type which produced the event. The events needed to handle generic pointer input are analogous to mouse events ( / , / , etc.). Consequently, pointer event types are intentionally similar to mouse event types. Additionally, a pointer event contains the usual properties present in mouse events (client coordinates, target element, button states, etc.) in addition to new properties for other forms of input: pressure, contact geometry, tilt, etc. In fact, the interface inherits all of the properties, thus facilitating the migration of content from mouse events to pointer events.\n\nThe interface extends the interface and has the following properties. Represents the angle between a transducer (a pointer or stylus) axis and the X-Y plane of a device screen. Represents the angle between the Y-Z plane and the plane containing both the transducer (a pointer or stylus) axis and the Y axis. A unique identifier for the pointing device generating the . A unique identifier for the pointer causing the event. The width (magnitude on the X axis), in CSS pixels, of the contact geometry of the pointer. the height (magnitude on the Y axis), in CSS pixels, of the contact geometry of the pointer. the normalized pressure of the pointer input in the range of to , where and represent the minimum and maximum pressure the hardware is capable of detecting, respectively. The normalized tangential pressure of the pointer input (also known as barrel pressure or cylinder stress) in the range to , where is the neutral position of the control. The plane angle (in degrees, in the range of to ) between the Y–Z plane and the plane containing both the pointer (e.g. pen stylus) axis and the Y axis. the plane angle (in degrees, in the range of to ) between the X–Z plane and the plane containing both the pointer (e.g. pen stylus) axis and the X axis. The clockwise rotation of the pointer (e.g. pen stylus) around its major axis in degrees, with a value in the range to . Indicates the device type that caused the event (mouse, pen, touch, etc.). Indicates if the pointer represents the primary pointer of this pointer type.\n\nPointer events have ten event types, seven of which have similar semantics to their mouse event counterparts ( , , , , , , and ). Below is a short description of each event type. Fired when a pointer is moved into an element's hit test boundaries. Fired when a pointer is moved into the hit test boundaries of an element or one of its descendants, including as a result of a event from a device that does not support hover (see ). Fired when a pointer changes coordinates. This event is also used if the change in pointer state cannot be reported by other events. Fired when a pointer is no longer active buttons state. A browser fires this event if it concludes the pointer will no longer be able to generate events (for example, if the related device is deactivated, or the browser decided to interpret the interaction as a pan/zoom instead). For information on how to control this behavior, see the section on the CSS property below. Fired for several reasons including: pointer is moved out of the hit test boundaries of an element; firing the pointerup event for a device that does not support hover (see ); after firing the event (see ); when a pen stylus leaves the hover range detectable by the digitizer. Fired when a pointer is moved out of the hit test boundaries of an element. For pen devices, this event is fired when the stylus leaves the hover range detectable by the digitizer. Fired when a pointer changes any properties that don't fire or events. Fired after pointer capture is released for a pointer.\n\nIn some scenarios there may be multiple pointers (for example a device with both a touchscreen and a mouse), or a pointer that supports multiple contact points (for example a touchscreen that supports multiple finger touches). The application can use the property to identify a master pointer among the set of active pointers for each pointer type. If an application only wants to support a primary pointer, it can ignore all pointer events that are not primary. A mouse has only one pointer, so it will always be the primary pointer. For touch input, a pointer is considered primary if the user touched the screen when there were no other active touches. For pen and stylus input, a pointer is considered primary if the user's pen initially contacted the screen when there were no other active pens contacting the screen.\n\nSome pointer devices (such as mouse and pen) support multiple buttons, and the button presses can be chorded (i.e. pressing an additional button while another button on the pointer device is already pressed). To determine the state of button presses, pointer events uses the and properties of the interface (that inherits from). The following table provides the values of and for the various device button states. Neither buttons nor touch/pen contact changed since last event Mouse move with no buttons pressed, Pen moved while hovering with no buttons pressed Note: The property indicates a change in the state of the button. However, as in the case of touch, when multiple events occur with one event, all of them have the same value.\n\nPointer capture allows events for a particular pointer event to be re-targeted to a particular element instead of the normal hit test at a pointer's location. This can be used to ensure that an element continues to receive pointer events even if the pointer device's contact moves off the element (for example by scrolling or panning). Pointer capture will cause the target to capture all subsequent pointer events as if they were occurring over the capturing target. Accordingly, , , , and will not fire as long as this capture is set. For touchscreen browsers that allow direct manipulation, an implicit pointer capture will be called on the element when a event triggers. The capture can be released manually by calling on the target element, or it will be implicitly released after a or event. Note: If you need to move an element in the DOM, then make sure to call after DOM movements so that will not lose track of it. E.g., if you need to use to move an element somewhere else, then make sure to call on it only after the call to . The following example shows pointer capture being set on an element. The following example shows a pointer capture being released (when a event occurs. The browser does this automatically when a or event occurs. function downHandler(ev) { const el = document.getElementById(\"target\"); // Element \"target\" will receive/capture further events el.setPointerCapture(ev.pointerId); } function cancelHandler(ev) { const el = document.getElementById(\"target\"); // Release the pointer capture el.releasePointerCapture(ev.pointerId); } function init() { const el = document.getElementById(\"target\"); // Register pointerdown and pointercancel handlers el.onpointerdown = downHandler; el.onpointercancel = cancelHandler; } document.addEventListener(\"DOMContentLoaded\", init);\n\nThe CSS property is used to specify whether or not the browser should apply its default (native) touch behavior (such as zooming or panning) to a region. This property may be applied to all elements except: non-replaced inline elements, table rows, row groups, table columns, and column groups. A value of means the browser is free to apply its default touch behavior (to the specified region) and the value of disables the browser's default touch behavior for the region. The values and , mean that touches that begin on the specified region are only for horizontal and vertical scrolling, respectively. The value means the browser may consider touches that begin on the element are only for scrolling and zooming. In the following example, the browser's default touch behavior is disabled for the element. In the following example, default touch behavior is disabled for some elements. In the following example, when the element is touched, it will only pan in the horizontal direction."
    }
]