[
    {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html",
        "document": "A regular expression, specified as a string, must first be compiled into an instance of this class. The resulting pattern can then be used to create a object that can match arbitrary character sequences against the regular expression. All of the state involved in performing a match resides in the matcher, so many matchers can share the same pattern.\n\nA method is defined by this class as a convenience for when a regular expression is used just once. This method compiles an expression and matches an input sequence against it in a single invocation. The statement\n\nis equivalent to the three statements above, though for repeated matches it is less efficient since it does not allow the compiled pattern to be reused.\n\nInstances of this class are immutable and are safe for use by multiple concurrent threads. Instances of the class are not safe for such use.\n\nThe backslash character ( ) serves to introduce escaped constructs, as defined in the table above, as well as to quote characters that otherwise would be interpreted as unescaped constructs. Thus the expression matches a single backslash and matches a left brace.\n\nIt is an error to use a backslash prior to any alphabetic character that does not denote an escaped construct; these are reserved for future extensions to the regular-expression language. A backslash may be used prior to a non-alphabetic character regardless of whether that character is part of an unescaped construct.\n\nBackslashes within string literals in Java source code are interpreted as required by as either Unicode escapes (section 3.3) or other character escapes (section 3.10.6) It is therefore necessary to double backslashes in string literals that represent regular expressions to protect them from interpretation by the Java bytecode compiler. The string literal , for example, matches a single backspace character when interpreted as a regular expression, while matches a word boundary. The string literal is illegal and leads to a compile-time error; in order to match the string the string literal must be used.\n\nCharacter classes may appear within other character classes, and may be composed by the union operator (implicit) and the intersection operator ( ). The union operator denotes a class that contains every character that is in at least one of its operand classes. The intersection operator denotes a class that contains every character that is in both of its operand classes.\n\nThe precedence of character-class operators is as follows, from highest to lowest:\n\nNote that a different set of metacharacters are in effect inside a character class than outside a character class. For instance, the regular expression loses its special meaning inside a character class, while the expression becomes a range forming metacharacter.\n\nA line terminator is a one- or two-character sequence that marks the end of a line of the input character sequence. The following are recognized as line terminators:\n\nIf mode is activated, then the only line terminators recognized are newline characters.\n\nThe regular expression matches any character except a line terminator unless the flag is specified.\n\nBy default, the regular expressions and ignore line terminators and only match at the beginning and the end, respectively, of the entire input sequence. If mode is activated then matches at the beginning of input and after any line terminator except at the end of input. When in mode matches just before a line terminator or the end of the input sequence.\n\nCapturing groups are numbered by counting their opening parentheses from left to right. In the expression , for example, there are four such groups:\n\nGroup zero always stands for the entire expression.\n\nCapturing groups are so named because, during a match, each subsequence of the input sequence that matches such a group is saved. The captured subsequence may be used later in the expression, via a back reference, and may also be retrieved from the matcher once the match operation is complete.\n\nA capturing group can also be assigned a \"name\", a , and then be back-referenced later by the \"name\". Group names are composed of the following characters. The first character must be a .\n• The uppercase letters through ( through ),\n• The lowercase letters through ( through ),\n• The digits through ( through ),\n\nA is still numbered as described in Group number.\n\nThe captured input associated with a group is always the subsequence that the group most recently matched. If a group is evaluated a second time because of quantification then its previously-captured value, if any, will be retained if the second evaluation fails. Matching the string against the expression , for example, leaves group two set to . All captured input is discarded at the beginning of each match.\n\nGroups beginning with are either pure, non-capturing groups that do not capture text and do not count towards the group total, or named-capturing group.\n\nThis class is in conformance with Level 1 of Unicode Technical Standard #18: Unicode Regular Expression, plus RL2.1 Canonical Equivalents.\n\nUnicode escape sequences such as in Java source code are processed as described in section 3.3 of . Such escape sequences are also implemented directly by the regular-expression parser so that Unicode escapes can be used in expressions that are read from files or from the keyboard. Thus the strings and , while not equal, compile into the same pattern, which matches the character with hexadecimal value .\n\nA Unicode character can also be represented in a regular-expression by using its Hex notation(hexadecimal code point value) directly as described in construct , for example a supplementary character U+2011F can be specified as , instead of two consecutive Unicode escape sequences of the surrogate pair .\n\nUnicode scripts, blocks, categories and binary properties are written with the and constructs as in Perl. prop matches if the input has the property prop, while prop does not match if the input has that property.\n\nScripts, blocks, categories and binary properties can be used both inside and outside of a character class.\n\nScripts are specified either with the prefix , as in , or by using the keyword (or its short form )as in or .\n\nThe script names supported by are the valid script names accepted and defined by .\n\nBlocks are specified with the prefix , as in , or by using the keyword (or its short form ) as in or .\n\nThe block names supported by are the valid block names accepted and defined by .\n\nCategories may be specified with the optional prefix : Both and denote the category of Unicode letters. Same as scripts and blocks, categories can also be specified by using the keyword (or its short form ) as in or .\n\nThe supported categories are those of The Unicode Standard in the version specified by the class. The category names are those defined in the Standard, both normative and informative.\n\nBinary properties are specified with the prefix , as in . The supported binary properties by are\n\nThe following Predefined Character classes and POSIX character classes are in conformance with the recommendation of Annex C: Compatibility Properties of Unicode Regular Expression , when flag is specified.\n\nCategories that behave like the java.lang.Character boolean ismethodname methods (except for the deprecated ones) are available through the same prop syntax where the specified property has the name .\n\nThe engine performs traditional NFA-based matching with ordered alternation as occurs in Perl 5.\n\nPerl constructs not supported by this class:\n• None The backreference constructs, n for the nthcapturing group and name for named-capturing group.\n• None The named character construct, name for a Unicode character by its name.\n\nConstructs supported by this class but not by Perl:\n• None Character-class union and intersection as described above.\n• None In Perl, through are always interpreted as back references; a backslash-escaped number greater than is treated as a back reference if at least that many subexpressions exist, otherwise it is interpreted, if possible, as an octal escape. In this class octal escapes must always begin with a zero. In this class, through are always interpreted as back references, and a larger number is accepted as a back reference if at least that many subexpressions exist at that point in the regular expression, otherwise the parser will drop digits until the number is smaller or equal to the existing number of groups or it is one digit.\n• None Perl uses the flag to request a match that resumes where the last match left off. This functionality is provided implicitly by the class: Repeated invocations of the method will resume where the last match left off, unless the matcher is reset.\n• None In Perl, embedded flags at the top level of an expression affect the whole expression. In this class, embedded flags always take effect at the point at which they appear, whether they are at the top level or within a group; in the latter case, flags are restored at the end of the group just as in Perl.\n\nFor a more precise description of the behavior of regular expression constructs, please see Mastering Regular Expressions, 3nd Edition, Jeffrey E. F. Friedl, O'Reilly and Associates, 2006."
    },
    {
        "link": "https://baeldung.com/regular-expressions-java",
        "document": "In this tutorial, we’ll discuss the Java Regex API, and how we can use regular expressions in the Java programming language.\n\nIn the world of regular expressions, there are many different flavors to choose from, such as grep, Perl, Python, PHP, awk, and much more.\n\nThis means that a regular expression that works in one programming language, may not work in another. The regular expression syntax in Java is most similar to that found in Perl.\n\nTo use regular expressions in Java, we don’t need any special setup. The JDK contains a special package, java.util.regex, totally dedicated to regex operations. We only need to import it into our code.\n\nMoreover, the java.lang.String class also has inbuilt regex support that we commonly use in our code.\n\nThe java.util.regex package consists of three classes: Pattern, Matcher, and PatternSyntaxException:\n• Pattern object is a compiled regex. The Pattern class provides no public constructors. To create a pattern, we must first invoke one of its public static compile methods, which will then return a Pattern object. These methods accept a regular expression as the first argument.\n• Matcher object interprets the pattern and performs match operations against an input String. It also defines no public constructors. We obtain a Matcher object by invoking the matcher method on a Pattern object.\n• PatternSyntaxException object is an unchecked exception that indicates a syntax error in a regular expression pattern.\n\nWe’ll explore these classes in detail; however, we must first understand how to construct a regex in Java.\n\nIf we’re already familiar with regex from a different environment, we may find certain differences, but they’re minimal.\n\nLet’s start with the simplest use case for a regex. As we noted earlier, when we apply a regex to a String, it may match zero or more times.\n\nThe most basic form of pattern matching supported by the java.util.regex API is the match of a String literal. For example, if the regular expression is foo and the input String is foo, the match will succeed because the Strings are identical:\n\nWe’ll first create a Pattern object by calling its static compile method and passing it a pattern we want to use.\n\nThen we’ll create a Matcher object be calling the Pattern object’s matcher method and passing it the text we want to check for matches.\n\nFinally, we’ll call the method find in the Matcher object.\n\nThe find method keeps advancing through the input text and returns true for every match, so we can use it to find the match count as well:\n\nSince we’ll be running more tests, we can abstract the logic for finding the number of matches in a method called runTest:\n\nWhen we get 0 matches, the test should fail; otherwise, it should pass.\n\nMeta characters affect the way a pattern is matched; in a way, they add logic to the search pattern. The Java API supports several meta characters, the most straightforward being the dot “.”, which matches any character:\n\nLet’s consider the previous example, where the regex foo matched the text foo, as well as foofoo, two times. If we use the dot meta character in the regex, we won’t get two matches in the second case:\n\nNotice the dot after the foo in the regex. The matcher matches every text that’s preceded by foo, since the last dot part means any character after. So after finding the first foo, the rest is seen as any character. That’s why there’s only a single match.\n\nThe API supports several other meta characters, <([{\\^-=$!|]})?*+.>, which we’ll explore further in this article.\n\nBrowsing through the official Pattern class specification, we’ll discover summaries of supported regex constructs. Under character classes, we have about 6 constructs.\n\nWe construct this as [abc]. This matches any of the elements in the set:\n\nIf they all appear in the text, it’ll match each element separately with no regard to the order:\n\nThey can also be alternated as part of a String. In the following example, when we create different words by alternating the first letter with each element of the set, they’re all matched:\n\nThe above set is negated by adding a caret as the first element:\n\nWe can define a class that specifies the range that the matched text should fall within by using a hyphen(-). Likewise, we can also negate a range.\n\nA union character class is the result of combining two or more character classes:\n\nThe above test will only match six out of the nine integers because the union set skips 4, 5, and 6.\n\nSimilar to the union class, this class results from picking common elements between two or more sets. To apply intersection, we use the &&:\n\nWe’ll get four matches because the intersection of the two sets has only four elements.\n\nWe can use subtraction to negate one or more character classes. For example, we can match a set of odd decimal numbers:\n\nOnly 1, 3, 5, 7, 9 will be matched.\n\nThe Java regex API also accepts predefined character classes. Some of the above character classes can be expressed in shorter form, although this makes the code less intuitive. One special aspect of the Java version of this regex is the escape character.\n\nAs we’ll see, most characters will start with a backslash, which has a special meaning in Java. For these to be compiled by the Pattern class, the leading backslash must be escaped, i.e. \\d becomes \\\\d.\n\nThe Java regex API also allows us to use quantifiers. These enable us to further tweak the match’s behavior by specifying the number of occurrences to match against.\n\nTo match a text zero or one time, we use the ? quantifier:\n\nAlternatively, we can use the brace syntax, which is also supported by the Java regex API:\n\nThis example introduces the concept of zero-length matches. It so happens that if a quantifier’s threshold for matching is zero, it always matches everything in the text, including an empty String at the end of every input. This means that even if the input is empty, it’ll return one zero-length match.\n\nThis explains why we get three matches in the above example, despite having a String of length two. The third match is zero-length empty String.\n\nTo match a text zero or limitless times, we us the * quantifier, which is similar to ?:\n\nThe quantifier with a difference is +, which has a matching threshold of one. If the required String doesn’t occur at all, there will be no match, not even a zero-length String:\n\nAs in Perl and other languages, we can use the brace syntax to match a given text a number of times:\n\nIn the above example, we get two matches, since a match occurs only if a appears three times in a row. However, in the next test, we won’t get a match because the text only appears two times in a row:\n\nWhen we use a range in the brace, the match will be greedy, matching from the higher end of the range:\n\nHere we specified at least two occurrences, but not exceeding three, so we get a single match where the matcher sees a single aaa and a lone a, which can’t be matched.\n\nHowever, the API allows us to specify a lazy or reluctant approach such that the matcher can start from the lower end of the range, matching two occurrences as aa and aa:\n\nThe API also allows us to treat multiple characters as a single unit through capturing groups. It will attach numbers to the capturing groups, and allow back referencing using these numbers.\n\nIn this section, we’ll see a few examples of how to use capturing groups in the Java regex API.\n\nLet’s use a capturing group that matches only when an input text contains two digits next to each other:\n\nThe number attached to the above match is 1, using a back reference to tell the matcher that we want to match another occurrence of the matched portion of the text. This way, instead of having two separate matches for the input:\n\nWe can have one match, but propagating the same regex match to span the entire length of the input using back referencing:\n\nWe would have to repeat the regex without back referencing to achieve the same result:\n\nSimilarly, for any other number of repetitions, back referencing can make the matcher see the input as a single match:\n\nBut if we change even the last digit, the match will fail:\n\nIt’s important not to forget the escape backslashes, which are crucial in Java syntax.\n\nThe Java regex API also supports boundary matching. If we care about where exactly in the input text the match should occur, then this is what we’re looking for. With the previous examples, all we cared about was whether or not a match was found.\n\nTo match only when the required regex is true at the beginning of the text, we use the caret ^.\n\nThis test will pass, since the text dog can be found at the beginning:\n\nThe following test will fail:\n\nTo match only when the required regex is true at the end of the text, we use the dollar character $. We’ll find a match in the following case:\n\nAnd we won’t find a match here:\n\nIf we want a match only when the required text is found at a word boundary, we use the \\\\b regex at the beginning and end of the regex:\n\nThe empty string at the beginning of a line is also a word boundary:\n\nThese tests pass because the beginning of a String, as well as the space between one text and another, marks a word boundary. However, the following test shows the opposite:\n\nTwo-word characters appearing in a row doesn’t mark a word boundary, but we can make it pass by changing the end of the regex to look for a non-word boundary:\n\nPreviously, we only created Pattern objects in a basic way. However, this class has another variant of the compile method that accepts a set of flags alongside the regex argument, which affects the way we match the pattern.\n\nThese flags are simply abstracted integer values. Let’s overload the runTest method in the test class, so that it can take a flag as the third argument:\n\nIn this section, we’ll look at the different supported flags and how to use them.\n\nThis flag enables canonical equivalence. When specified, two characters will be considered to match if, and only if, their full canonical decompositions match.\n\nConsider the accented Unicode character é. Its composite code point is u00E9. However, Unicode also has a separate code point for its component characters e, u0065, and the acute accent, u0301. In this case, composite character u is indistinguishable from the two character sequence u u\n\nBy default, matching doesn’t take canonical equivalence into account:\n\nBut if we add the flag, then the test will pass:\n\nThis flag enables matching regardless of case. By default, matching takes case into account:\n\nSo using this flag, we can change the default behavior:\n\nWe can also use the equivalent, embedded flag expression to achieve the same result:\n\nThe Java API allows us to include comments using # in the regex. This can help in documenting complex regex that may not be immediately obvious to another programmer.\n\nThe comments flag makes the matcher ignore any white space or comments in the regex, and only consider the pattern. In the default matching mode, the following test would fail:\n\nThis is because the matcher will look for the entire regex in the input text, including the spaces and the # character. But when we use the flag, it’ll ignore the extra spaces, and all text starting with # will be seen as a comment to be ignored for each line:\n\nThere’s also an alternative embedded flag expression for this:\n\nBy default, when we use the dot “.” expression in regex, we’re matching every character in the input String until we encounter a new line character.\n\nUsing this flag, the match will include the line terminator as well. We’ll understand this better with the following examples. These examples will be a little different. Since we want to assert against the matched String, we’ll use matcher‘s group method, which returns the previous match.\n\nFirst, let’s see the default behavior:\n\nAs we can see, only the first part of the input before the line terminator is matched.\n\nNow in dotall mode, the entire text, including the line terminator, will be matched:\n\nWe can also use an embedded flag expression to enable dotall mode:\n\nWhen in this mode, the matcher gives no special meaning to any meta characters, escape characters, or regex syntax. Without this flag, the matcher will match the following regex against any input String:\n\nThis is the default behavior we’ve seen in all the examples. However, with this flag, we won’t find a match, since the matcher will be looking for (.*) instead of interpreting it:\n\nNow if we add the required string, the test will pass:\n\nBy default, the ^ and $ meta characters match absolutely at the beginning and end, respectively, of the entire input String. The matcher disregards any line terminators:\n\nThis match will fail because the matcher searches for dog at the end of the entire String, but the dog is present at the end of the first line of the string.\n\nHowever, with the flag, the same test will pass, since the matcher now takes into account line terminators. So the String dog is found just before the line terminates, meaning success:\n\nIn this section, we’ll learn about the useful methods of the Matcher class. We’ll group them according to functionality for clarity.\n\nIndex methods provide useful index values that show us precisely where to find the match in the input String. In the following test, we’ll confirm the start and end indices of the match for dog in the input String:\n\nStudy methods go through the input String and return a boolean indicating whether or not the pattern was found. Commonly used are the matches and lookingAt methods.\n\nThe matches and lookingAt methods both attempt to match an input sequence against a pattern. The difference is that matches requires the entire input sequence to be matched, while lookingAt doesn’t.\n\nBoth methods start at the beginning of the input String :\n\nThe matches method will return true in a case like this:\n\nReplacement methods are useful to replace text in an input string. The common ones are replaceFirst and replaceAll.\n\nThe replaceFirst and replaceAll methods replace the text that matches a given regular expression. As their names indicates, replaceFirst replaces the first occurrence, and replaceAll replaces all occurrences:\n\nThe replaceAll method allows us to substitute all matches with the same replacement. If we want to replace matches on a case by basis, we’d need a token replacement technique.\n\nIn this article, we learned how to use regular expressions in Java. We also explored the most important features of the java.util.regex package."
    },
    {
        "link": "https://jrebel.com/blog/java-regular-expressions-cheat-sheet",
        "document": ""
    },
    {
        "link": "https://geeksforgeeks.org/regular-expressions-in-java",
        "document": "In Java, Regular Expressions or Regex (in short) in Java is an API for defining String patterns that can be used for searching, manipulating, and editing a string in Java. Email validation and passwords are a few areas of strings where Regex is widely used to define the constraints. Regular Expressions in Java are provided under java.util.regex package.\n\nThis consists of 3 classes and 1 interface. The java.util.regex package primarily consists of the following three classes as depicted below in tabular format as follows:\n\nMore understanding can be interpreted from the image provided below as follows:\n\nThis class is a compilation of regular expressions that can be used to define various types of patterns, providing no public constructors. This can be created by invoking the compile() method which accepts a regular expression as the first argument, thus returning a pattern after execution.\n\nIt is used to compile the given regular expression into a pattern. It is used to compile the given regular expression into a pattern with the given flags. It is used to return this pattern’s match flags. It is used to create a matcher that will match the given input against this pattern. It is used to compile the given regular expression and attempts to match the given input against it. It is used to return the regular expression from which this pattern was compiled. It is used to return a literal pattern String for the specified String. It is used to split the given input sequence around matches of this pattern. It is used to split the given input sequence around matches of this pattern. The limit parameter controls the number of times the pattern is applied. It is used to return the string representation of this pattern.\n\nThis object is used to perform match operations for an input string in Java, thus interpreting the previously explained patterns. This too defines no public constructors. This can be implemented by invoking a matcher() on any pattern object.\n\nIt is mainly used for searching multiple occurrences of the regular expressions in the text. It is used for searching occurrences of the regular expressions in the text starting from the given index. It is used for getting the start index of a match that is being found using find() method. It is used for getting the end index of a match that is being found using find() method. It returns the index of the character next to the last matching character. It is used to find the total number of the matched subsequence. It is used to find the matched subsequence. It is used to test whether the regular expression matches the pattern.\n\nLet us do discuss a few sample programs as we did for the Pattern class. Here we will be discussing a few Java programs that demonstrate the workings of compile(), find(), start(), end(), and split() in order to get a better understanding of the Matcher class.\n\nBelow is the implementation of the above topic:\n\nBelow is the implementation of Regex Metacharacters:\n\nBelow is the implementation of the Java Regex Finder:\n\nLastly, let us do discuss some of the important observations as retrieved from the above article\n• None We create a pattern object by calling Pattern.compile(), there is no constructor. compile() is a static method in the Pattern class.\n• None Like above, we create a Matcher object using matcher() on objects of the Pattern class.\n• None Pattern.matches() is also a static method that is used to check if a given text as a whole matches the pattern or not.\n• None find() is used to find multiple occurrences of patterns in the text.\n• None We can split a text based on a delimiter pattern using the split() method\n\nQ1. What are regular expressions in Java?\n\nQ2. What is a simple example of regular expression in Java?"
    },
    {
        "link": "https://stackoverflow.com/questions/20217551/check-if-a-string-matches-specific-regular-expression",
        "document": "Here's the briefest way to code the regex:\n\nThis allows each part to be optional, but the negative look ahead for end-of-input at the start means there must be something there.\n\nNote how with java you don't have to code the start ( ) and end ( ) of input, because must match the whole string, so start and end are implied.\n\nHowever, this is just a rudimentary regex, because will pass. The regex for a valid format would be:\n\nThis restricts the hours and minutes to , allowing an optional leading zero for values in the range ."
    },
    {
        "link": "https://stackoverflow.com/questions/3802192/regexp-java-for-password-validation",
        "document": "All the previously given answers use the same (correct) technique to use a separate lookahead for each requirement. But they contain a couple of inefficiencies and a potentially massive bug, depending on the back end that will actually use the password.\n\nI'll start with the regex from the accepted answer:\n\nFirst of all, since Java supports and I prefer to use those to make sure the entire string is validated, independently of . This doesn't affect performance, but avoids mistakes when regexes are recycled.\n\nChecking that the password does not contain whitespace and checking its minimum length can be done in a single pass by using the all at once by putting variable quantifier on the shorthand that limits the allowed characters:\n\nIf the provided password does contain a space, all the checks will be done, only to have the final check fail on the space. This can be avoided by replacing all the dots with :\n\nThe dot should only be used if you really want to allow any character. Otherwise, use a (negated) character class to limit your regex to only those characters that are really permitted. Though it makes little difference in this case, not using the dot when something else is more appropriate is a very good habit. I see far too many cases of catastrophic backtracking because the developer was too lazy to use something more appropriate than the dot.\n\nSince there's a good chance the initial tests will find an appropriate character in the first half of the password, a lazy quantifier can be more efficient:\n\nBut now for the really important issue: none of the answers mentions the fact that the original question seems to be written by somebody who thinks in ASCII. But in Java strings are Unicode. Are non-ASCII characters allowed in passwords? If they are, are only ASCII spaces disallowed, or should all Unicode whitespace be excluded.\n\nBy default matches only ASCII whitespace, so its inverse matches all Unicode characters (whitespace or not) and all non-whitespace ASCII characters. If Unicode characters are allowed but Unicode spaces are not, the flag can be specified to make exclude Unicode whitespace. If Unicode characters are not allowed, then can be used instead of to match all ASCII characters that are not a space or a control character.\n\nWhich brings us to the next potential issue: do we want to allow control characters? The first step in writing a proper regex is to exactly specify what you want to match and what you don't. The only 100% technically correct answer is that the password specification in the question is ambiguous because it does not state whether certain ranges of characters like control characters or non-ASCII characters are permitted or not."
    },
    {
        "link": "https://geeksforgeeks.org/how-to-validate-a-password-using-regular-expressions-in-java",
        "document": "Given a password, the task is to validate the password with the help of Regular Expression. A password is considered valid if all the following constraints are satisfied:\n• It contains at least 8 characters and at most 20 characters.\n• It contains at least one digit.\n• It contains at least one upper case alphabet.\n• It contains at least one lower case alphabet.\n• It contains at least one special character which includes !@#$%&*()-+=^.\n• It doesn’t contain any white space.\n\nInput: Str = “Geeks@portal20” Output: True. Explanation: This password satisfies all constraints mentioned above. Input: Str = “Geeksforgeeks” Output: False. Explanation: It contains upper case and lower case alphabet but doesn’t contains any digits, and special characters. Input: Str = “Geeks@ portal9” Output: False. Explanation: It contains upper case alphabet, lower case alphabet, special characters, digits along with white space which is not valid. Input: Str = “12345” Output: False. Explanation: It contains only digits but doesn’t contains upper case alphabet, lower case alphabet, special characters, and 8 characters.\n\nApproach: This problem can be solved by using Regular Expression.\n• Create a regular expression to check the password is valid or not as mentioned below:\n• where:\n• (?=.*[0-9]) represents a digit must occur at least once.\n• (?=.*[a-z]) represents a lower case alphabet must occur at least once.\n• (?=.*[A-Z]) represents an upper case alphabet that must occur at least once.\n• (?=.*[@#$%^&-+=()] represents a special character that must occur at least once.\n• .{8, 20} represents at least 8 characters and at most 20 characters.\n• $ represents the end of the string.\n• Match the given string with the Regex. In java, this can be done using Pattern.matcher().\n• Return true if the string matches with the given regex, else return false.\n\nBelow is the implementation of the above approach:\n\nTime complexity : O(n) where n is the length of the password string. This is because the program uses the matcher() method which performs a linear search through the input string to find a match with the regular expression.\n\nSpace complexity : O(1) as the program only uses a constant amount of additional memory to store the regular expression and the Matcher and Pattern objects."
    },
    {
        "link": "https://stackoverflow.com/questions/32512746/java-creating-a-complex-regular-expression-for-password-validation",
        "document": "I have a regular expression right now that enforces a requirement on a password in my Java application.\n\nI want to now modify this expression so it reflects this policy:\n\nat least 7 characters contains characters in three or more of the following character classes:\n\nand the character at the beginning or end do not count towards its character class.\n\nIs this too complex for a regular expression? If not, how can I modify my existing to adhere to the new one?\n\nHere is my current:"
    },
    {
        "link": "https://baeldung.com/java-regex-password-validation",
        "document": "Regarding cybersecurity, password validation is essential in protecting users’ accounts. Moreover, using regular expressions (regex) in Java provides a powerful and dynamic way of imposing specific standards for password complexity.\n\nIn this tutorial, we’ll delve into utilizing the regex for Java-based password validation processes.\n\nBefore we get into the code, we’ll establish what makes a strong password. An ideal password should:\n• Have eight characters or more\n• Use at least one lowercase letter\n• Consists of at least one digit\n• Need to have one special symbol (i.e., @, #, $, %, etc.)\n\nRegular expressions, or regex, are useful tools in Java that allow searching, matching, and transforming strings based on certain patterns. In the same context, regex adopts a more static approach for password validation that operates with the help of predefined regular expressions.\n\nThe following Java regular expression encapsulates the specified requirements:\n• (?=.*[a-z]): makes sure that there is at least one small letter\n• (?=.*[A-Z]): needs at least one capital letter\n• (?=.*\\\\d): requires at least one digit\n• (?=.*[@#$%^&+=]): provides a guarantee of at least one special symbol\n• .{8,20}: imposes the minimum length of 8 characters and the maximum length of 20 characters\n\nHere, we characterize the regExpn regular expression, which specifies certain rules for a password. Besides, we compile the regExpn regular expression into a pattern using Pattern.compile() method and then create a matcher for the given password through the pattern.matcher() method.\n\nLastly, we utilize the matcher.matches() method to determine if the password meets the regExpn regular expression.\n\nThis approach presents a dynamic password verification method that enables the creation of a pattern based on different attributes. This technique involves an arbitrary pattern, including a minimum/maximum length, special symbols, and other elements.\n\nHere, we first ensure that the password doesn’t equal null before carrying on with validation. Then, the method determines validation criteria through individual strings, stipulating such issues as the presence of one digit, one lower case symbol, and an upper case letter with optionally special characters.\n\nMoreover, we use the MIN_MAX_CHAR string to establish the password’s minimum and maximum length limits, using defined standards MIN_LENGTH and MAX_LENGTH. Afterward, the composite PATTERN string concatenates all the indicated prerequisites to develop a dynamic validation pattern.\n\nFinally, we utilize the assertTrue(password.matches(PATTERN)) method to verify the password’s compliance with the dynamically created pattern. If exceptions occur during validation, the test is considered failed; details of the exception are printed for debugging purposes.\n\nThis approach provides the flexibility to set password validation rules by changing parameters, which makes it appropriate for different validators.\n\nIn summary, Java regular expressions are a reliable mechanism for performing text validation and manipulation, particularly when it involves the application of strong password security.\n\nHence, in this article, we give a concise step-by-step guide for constructing an appropriate regular expression to validate passwords, providing the foundation for alteration that can increase safety during user account creation.\n\nAs always, the complete code samples for this article can be found over on GitHub."
    },
    {
        "link": "https://uibakery.io/regex-library/password",
        "document": "Password regular expression can be used to verify that a password provided is strong enough to provide better protection against bot brute force attacks. This method, however, does not guarantee that a password will have enough entropy to be completely safe.\n\nEnter a text in the input above to see the result\n\nEnter a text in the input above to see the result\n\nEnter a text in the input above to see the result\n\nWhile this regex validation is better than nothing, in situations when additional security is needed you should also check the password entered for a set of commonly used passwords like:\n\nOne good list can be found here."
    }
]