[
    {
        "link": "https://developer.servicenow.com/dev.do#!/learn/learning-plans/xanadu/new_to_servicenow/app_store_learnv2_scripting_xanadu_gliderecord",
        "document": "The GlideRecord class is the way to interact with the ServiceNow database from a script. See the GlideRecord API reference for a complete list of methods.\n\nGlideRecord interactions start with a database query. The generalized strategy is:\n• Create a GlideRecord object for the table of interest.\n• Apply script logic to the records returned in the GlideRecord object.\n\nHere is what the generalized strategy looks like in pseudo-code:\n\nUse the addQuery() method to add query conditions. The addQuery operators are:\n• Strings: =, !=, STARTSWITH, ENDSWITH, CONTAINS, DOES NOT CONTAIN, IN, NOT IN, INSTANCEOF\n\nThe addQuery() method is typically passed three arguments: field name, operator, and value. In some scripts you will see only two arguments: field name and value. When the addQuery() method is used without an operator, the operation is assumed to be =.\n\nWhen there are multiple queries, each additional clause is treated as an AND.\n\nQueries with no query conditions return all records from a table.\n\nIf a malformed query executes in runtime, all records from the table are returned. For more strict query control you can enable the glide.invalid_query.returns_no_rows property which returns no records for invalid queries.\n\nThere are several strategies for iterating through returned records.\n\nThe next() method and a while loop iterates through all returned records to process script logic:\n\nThe next() method and an if processes only the first record returned.\n\nUse the updateMultiple() method to update all records in a GlideRecord. To ensure expected results with the updateMultiple() method, set field values with the the setValue() method rather than direct assignment.\n\nThe GlideRecord API has a method for counting the number of records returned by a query: getRowCount(). Do not use the getRowCount() method on a production instance as there could be a negative performance impact on the database. To determine the number of rows returned by a query on a production instance, use GlideAggregate.\n\nAs already discussed, if there are multiple conditions in query, the conditions are ANDed. To use ORs or create technically complex queries, use encoded queries. The code for using an encoded query looks like this:\n\nThe trick to making this work is to know the encoded query syntax. The syntax is not documented so let ServiceNow build the encoded query for you. In the main ServiceNow browser window, use the All menu to open the list for the table of interest. If there is no module to open the list, type <table_name>.list in the Filter field.\n\nUse the Filter to build the query condition.\n\n\n\nClick the Run button to execute the query. Right-click the breadcrumbs and select the Copy query menu item. Where you click in the breadcrumbs matters. The copied query includes the condition you right-clicked on and all conditions to the left. To copy the entire query, right-click the condition farthest to the right.\n\n\n\nReturn to the script and paste the encoded query into the addEncodedQuery() method. Be sure to enclose the encoded query in \"\" or ''."
    },
    {
        "link": "https://developer.servicenow.com/dev.do#!/learn/courses/xanadu/app_store_learnv2_scripting_xanadu_scripting_in_servicenow/app_store_learnv2_scripting_xanadu_server_side_scripting/app_store_learnv2_scripting_xanadu_gliderecord",
        "document": "The GlideRecord class is the way to interact with the ServiceNow database from a script. See the GlideRecord API reference for a complete list of methods.\n\nGlideRecord interactions start with a database query. The generalized strategy is:\n• Create a GlideRecord object for the table of interest.\n• Apply script logic to the records returned in the GlideRecord object.\n\nHere is what the generalized strategy looks like in pseudo-code:\n\nUse the addQuery() method to add query conditions. The addQuery operators are:\n• Strings: =, !=, STARTSWITH, ENDSWITH, CONTAINS, DOES NOT CONTAIN, IN, NOT IN, INSTANCEOF\n\nThe addQuery() method is typically passed three arguments: field name, operator, and value. In some scripts you will see only two arguments: field name and value. When the addQuery() method is used without an operator, the operation is assumed to be =.\n\nWhen there are multiple queries, each additional clause is treated as an AND.\n\nQueries with no query conditions return all records from a table.\n\nIf a malformed query executes in runtime, all records from the table are returned. For more strict query control you can enable the glide.invalid_query.returns_no_rows property which returns no records for invalid queries.\n\nThere are several strategies for iterating through returned records.\n\nThe next() method and a while loop iterates through all returned records to process script logic:\n\nThe next() method and an if processes only the first record returned.\n\nUse the updateMultiple() method to update all records in a GlideRecord. To ensure expected results with the updateMultiple() method, set field values with the the setValue() method rather than direct assignment.\n\nThe GlideRecord API has a method for counting the number of records returned by a query: getRowCount(). Do not use the getRowCount() method on a production instance as there could be a negative performance impact on the database. To determine the number of rows returned by a query on a production instance, use GlideAggregate.\n\nAs already discussed, if there are multiple conditions in query, the conditions are ANDed. To use ORs or create technically complex queries, use encoded queries. The code for using an encoded query looks like this:\n\nThe trick to making this work is to know the encoded query syntax. The syntax is not documented so let ServiceNow build the encoded query for you. In the main ServiceNow browser window, use the All menu to open the list for the table of interest. If there is no module to open the list, type <table_name>.list in the Filter field.\n\nUse the Filter to build the query condition.\n\n\n\nClick the Run button to execute the query. Right-click the breadcrumbs and select the Copy query menu item. Where you click in the breadcrumbs matters. The copied query includes the condition you right-clicked on and all conditions to the left. To copy the entire query, right-click the condition farthest to the right.\n\n\n\nReturn to the script and paste the encoded query into the addEncodedQuery() method. Be sure to enclose the encoded query in \"\" or ''."
    },
    {
        "link": "https://servicenow.com/community/developer-forum/update-gliderecord-on-query/m-p/1639583",
        "document": "You can get to the query that is being run by accessing current.getEncodedQuery(). From that you could create a GlideRecord query of your own and try to get the individual records that are being returned. You should also be able to look at the encoded query and see if the fields you want to check are being explicitly searched for. The only thing that worries me here, is I don't know if the query business rule is triggered from a GlideRecord query. If it is, then you may get yourself into an infinite loop."
    },
    {
        "link": "https://servicenowguru.com/scripting/gliderecord-query-cheat-sheet",
        "document": "I doubt if there’s a single concept in Service-now that is more valuable to understand than how to use GlideRecord methods to query, insert, update, and delete records in your system. These methods have a wide variety of uses and are found at the heart of many of the business rules, UI actions, and scheduled job scripts that are essential to tie together your organization’s processes in your Service-now instance.\n\nWhile the content of this post isn’t new information (additional examples can be found on the Service-now wiki), my aim is to provide a single page of information containing some common examples of these methods as a reference. This is an excellent page to keep bookmarked!\n\n\n\n‘Get’ Query Shortcut (used to get a single GlideRecord) Can also be used in Client scripts and UI policies IF YOU ARE GETTING A RECORD BY SYS_ID. The ‘get’ method is a great way to return a single record when you know the sys_id of that record. var gr = new GlideRecord('incident'); gr.get(sys_id_of_record_here); //Do something with the record returned if(gr.category == 'software'){ gs.log('Category is ' + gr.category); } You can also query for a specific field/value pair. The ‘get’ method returns the first record in the result set. //Find the first active incident record var gr = new GlideRecord('incident'); if(gr.get('active', true)){ //Do something with the record returned gs.log('Category is ' + gr.category); }\n\n\n\n The standard ‘addQuery’ parameter acts like an ‘and’ condition in your query. This example shows how you can add ‘or’ conditions to your query. //Find all incidents with a priority of 1 or 2 var gr = new GlideRecord('incident'); var grOR = gr.addQuery('priority', 1); grOR.addOrCondition('priority', 2); gr.query(); while (gr.next()) { //Do something with the records returned if(gr.category == 'software'){ gs.log('Category is ' + gr.category); } } The standard ‘addQuery’ parameter acts like an ‘and’ condition in your query. This example shows how you can add ‘or’ conditions to your query. Note that you can also chain your ‘OR’ condition as well, which is usually simpler //Find all incidents with a priority of 1 or 2 var gr = new GlideRecord('incident'); gr.addQuery('priority', 1).addOrCondition('priority', 2); gr.query();\n\nCANNOT be used in Client scripts and UI policies! Use ‘addQuery(YOURENCODEDQUERYHERE)’ instead. An alternative to a standard query is to use an encoded query to create your query string instead of using ‘addQuery’ and ‘addOrCondition’ statements. An easy way to identify the encoded query string to use is to create a filter or a module with the query parameters you want to use, and then hover over the link or breadcrumb and look at the URL. The part of the URL after ‘sysparm_query=’ is the encoded query for that link.\n\n So if I had a URL that looked like this…\n\n https://demo.service-now.com/incident_list.do?sysparm_query=active=true^category=software^ORcategory=hardware My encoded query string would be this…\n\n active=true^category=software^ORcategory=hardware I could build that encoded query string and use it in a query like this… //Find all active incidents where the category is software or hardware var gr = new GlideRecord('incident'); var strQuery = 'active=true'; strQuery = strQuery + '^category=software'; strQuery = strQuery + '^ORcategory=hardware'; gr.addEncodedQuery(strQuery); gr.query();\n\n\n\n The chooseWindow(first,last) method lets you set the first and last row number that you want to retrieve and is typical for chunking-type operations. The rows for any given query result are numbered 0..(n-1), where there are n rows. The first parameter is the row number of the first result you’ll get. The second parameter is the number of the row after the last row to be returned. In the example below, the parameters (10, 20) will cause 10 rows to be returned: rows 10..19, inclusive. //Find the last 10 incidents created var gr = new GlideRecord('incident'); gr.orderByDesc('sys_created_on'); gr.chooseWindow(10, 20); gr.query(); The chooseWindow(first,last) method lets you set the first and last row number that you want to retrieve and is typical for chunking-type operations. The rows for any given query result are numbered 0..(n-1), where there are n rows. The first parameter is the row number of the first result you’ll get. The second parameter is the number of the row after the last row to be returned. In the example below, the parameters (10, 20) will cause 10 rows to be returned: rows 10..19, inclusive.\n\n\n\n ‘setForceUpdate’ is used to update records without having to change a value on that record to get the update to execute. ‘setForceUpdate’ is particularly useful in situations where you need to force the recalculation of a calculated field for all records in a table or when you need to run business rules against all records in a table but don’t want to have to change a value on the records.\n\n This method is often used with ‘setWorkflow’ and ‘autoSysFields’ as shown below. //Force an update to all User records without changing field values var gr = new GlideRecord('sys_user'); gr.query(); while (gr.next()) { gr.setWorkflow(false); //Do not run business rules gr.autoSysFields(false); //Do not update system fields gr.setForceUpdate(true); //Force the update gr.update(); } ‘setForceUpdate’ is used to update records without having to change a value on that record to get the update to execute. ‘setForceUpdate’ is particularly useful in situations where you need to force the recalculation of a calculated field for all records in a table or when you need to run business rules against all records in a table but don’t want to have to change a value on the records.This method is often used with ‘setWorkflow’ and ‘autoSysFields’ as shown below.\n\n\n\n The following operators can be used in addition to the standard field/value query searching shown above… Field value must be equal to the value supplied. Field must be greater than the value supplied. Field must be less than the value supplied. Field must be equal to or greater than the value supplied. Field must be equal to or less than the value supplied. Field must not equal the value supplied. Field must start with the value supplied. The example shown on the right will get all records where the short_description field starts with the text 'Error'. Field must end with the value supplied. The example shown on the right will get all records where the short_description field ends with text 'Error'. Field must contain the value supplied anywhere in the field. The example shown on the right will get all records where the short_description field contains the text 'Error' anywhere in the field. DOES NOT CONTAIN Field must not contain the value supplied anywhere in the field. The example shown on the right will get all records where the short_description field does not contain the text 'Error' anywhere in the field. addQuery('short_description', 'DOES NOT CONTAIN', 'Error'); Field must contain the value supplied anywhere in the string provided. Retrieves only records of a specified class for tables which are extended. For example, to search for configuration items (cmdb_ci table) you many want to retrieve all configuration items that are have are classified as computers. The code uses the INSTANCEOF operator to query for those records. The following operators can be used in addition to the standard field/value query searching shown above…"
    },
    {
        "link": "https://servicenow.com/docs/bundle/yokohama-api-reference/page/app-store/dev_portal/API_reference/GlideRecord/concept/c_GlideRecordAPI.html",
        "document": ""
    },
    {
        "link": "https://servicenow.com/community/in-other-news/performance-considerations-when-using-gliderecord/ba-p/2271956",
        "document": "If you are a developer and working for a customer that uses ServiceNow platform, you will probably have to deal sooner or later with scripting in ServiceNow and therefore touch GlideRecord.\n\nIf that's the case keep in mind the following performance considerations when using GlideRecord:\n\n1. Always try to add a filter in a GlideRecord query, especially one based on an indexed field. Don't bring back a full table via GlideRecord if it's not really needed, as it causes overhead and can take time.\n\nExample 1 (this would benefit from an index on incident.`active` field):\n\nExample 2 (this would benefit from an index on `sys_created_on` field):\n\n2. While adding filters in GlideRecord queries is good, avoid creating filters which are too complex.\n\nRather than creating a series of addQuery() and addOrCondition() calls to obtain a result, use addEncodedQuery(). This will make the query easier to create and maintain.\n\nCreate a query string by generating encoded query strings through a filter and using that string with addEncodedQuery.\n\nAs an example, if I want all incidents that are active, created after a certain date with a certain state and a particular approval value I go in the instance at incidents module, expand \"All\" filter and add all my conditions then click \"Run\". Then right click on the link, \"Copy query\" and I get my encoded query:\n\n3. Limit number of returned records when querying very large tables.\n\nFor example, this:\n\nmight work fine if you have only a few thousands active incidents, but if you have 1000000 active incidents, the query() method has to retrieve all those records and this can take time.\n\nIn cases like this, using the setLimit() method is indicated.\n\n4. Make sure fields used in filters exist, otherwise your GlideRecord will retrieve the full table (it's like doing a SQL query without a WHERE clause).\n\nFor example, if I query 'incident' table using a filter for a field ('myfield' in this case) that doesn't exists I get full incident table back:\n\nThe log might also show (depending on the result set size) a warning like:\n\nQuery that got us here is: TABLENAME = incident ENCODED_QUERY = myfield=test\n\nAnother option is to use Glide property \" \" (thanks to kalai for pointing it out) which controls how an invalid GlideRecord query is handled. Full description of the property here:\n\nA quick example from our wiki for above property:\n\nBesides the available options presented above, thanks to our community, treycarroll went a step further and created an extension to GlideRecord that will throw an exception if you pass a bad column name or operator. I find this very useful and you can read his post here:\n\nExtension to GlideRecord: addQuery2, Throws an exception if you pass a bad column name or bad opera...\n\n5. Don't increment variables in while loops for counting purposes when you can use GlideAggregate. Again, filtering based on indexed fields is very important.\n\nYou can also use GlideRecord.getRowCount() method if besides counting you need to process the returned records.\n\nBETTER PERFORMANCE (when you need to do processing on the returned records):\n\n- example using getRowCount() method of GlideRecord:\n\n6. Don't overkill your script with logging statements (gs.log). While during testing phase adding more logging statements helps debugging, on a production instance this could add overhead (be aware for each gs.log we have to insert a row in syslog table and write a log line in the application localhost_log as well)."
    },
    {
        "link": "https://servicenow.com/community/developer-articles/performance-best-practices-for-server-side-coding-in-servicenow/ta-p/2324426",
        "document": "This guide is written by the ServiceNow Technical Support Performance team (All Articles). We are a global group of experts that help our customers with performance issues. If you have questions about the content of this article we will try to answer them here. However, if you have urgent questions or specific issues, please see the list of resources on our profile page: ServiceNowPerformanceGTS\n\nThe goal of this article is to address some common types of scripting issues that can cause performance problems. While ServiceNow has many low-code or no-code development options, any implementation will still require the writing of some code. Coding in ServiceNow obviously provides a great deal of power to enable rich features and to delight your customers. However, it also has the potential to cause serious issues if not properly designed.\n• Spawning too much work, too quickly\n• Using synchronous methods on the server when a transaction is waiting for a response\n• Not limiting number of returned records when querying very large tables\n• Running out of memory due to storing dot-walked GlideElement fields\n• Infinite or Very Large Loops and Recursion\n• Use GlideRecord.get(field, value) not GlideRecord.get(value)\n\nA few notes about server-side scripting in ServiceNow\n\nServiceNow almost exclusively uses JavaScript as the scripting language for our back-end API's. As of Nov 30, 2023 Vancouver is the current release of ServiceNow. At this time, ServiceNow supports 3 different versions of Javascript, depending on the script context: ECMAScript 2021 (ES12), ES5 Standards, and Compatibility. To see details about the latest script environment see the product documentation [Doc Site] JavaScript modes.\n\nOn top of JavaScript, ServiceNow leverages a variety of frameworks and libraries (Angular, Prototype) as well as a variety of proprietary scripting contexts and API's, each with their own list of available context variables and implications to performance. This guide will mostly be covering what could be described as the most common scripting scenarios in ServiceNow; the (scoped) [Developer Portal] Server Custom Scope or (legacy) [Developer Portal] Server Global API's. These API's are available from most \"script\" type fields in ServiceNow. We will not get too in-depth into any specific contexts. The developer site has detailed information about the various API's, libraries and frameworks leveraged in different parts of ServiceNow ([Developer Portal] APIs, libraries, and supplemental materials)\n\nFor more technical best practices, see [Developer Portal] Scripting Technical Best Practices.\n\nMany of these concepts are not original, and certainly not unique to ServiceNow, but they have been selected because they have been observed to be the areas where ServiceNow customers run into the most trouble. Ok, let's dig in!\n\nThis is #1 for a reason! Failure to correctly validate null/undefined variables is the most common cause of impactful scripting failures that we experience in ServiceNow code. When an invalid variable is used in GlideRecord the system potentially brings back way more rows than people were expecting and can result in performance degradation, data corruption or data loss.\n\nThere are two main flavors of this issue:\n• When someone uses GlideRecord.addQuery(goodFieldName, ) we treat this as goodFieldName=NULL\n• When someone uses GlideRecord.addQuery( , goodCondition) we return the entire table!\n\nGlideRecord is ServiceNow's main API. It allows access to the database via script.\n\n[Doc Site] ServiceNow Server Script Debugger - Feature addition: [Developer Portal] Debugging Console available with in Paris!\n• Check for all values before using them ([Developer Portal] coding best practice)\n\nTo avoid unpredictable results and warning messages, verify that variables and fields have a value before using them. Consider the following code:\n\nAny additional statements which use the variable table may throw warning messages in the system log if the value is undefined. This can happen if the cmdb_ci field is empty or if the installed_on field in the CI is empty. The following code demonstrates a better way to verify that the table variable has a value before using it\n\nJSUtil.notNil() - [Developer Portal] True if the item exists and is not empty.\n• Change the behavior through a property change\n\nThe property, \"glide.invalid_query.returns_no_rows\" changes the behavior of the case of addQuery(badFieldName, goodCondition) to return no results in very efficient fashion by adding 1=0 to the conditions. You might need to add this property to your instance to make it work. Set the value to true to get the behavior change.\n• Use the new GlideQuery API (Available in Paris)\n\n- There is a new feature that is currently being used (primarily internally) that helps developers write better/safer ServiceNow Glide code.\n\n- GlideQuery effectively sits on top of GlideRecord and provides additional error checking/improved syntax. As a result, for well written queries, we wouldn’t expect to see any difference in performance between the two classes as the same GlideRecord() queries should be run in both cases. During performance testing, the product team has documented some single digit millisecond performance overhead that we assume is due to the additional logic added by GlideQuery before it calls GlideRecord.\n\nSee [Doc Site] GlideQuery - Scoped, Global for official ServiceNow documentation\n\nLarge arrays or objects can cause many specific failure points including the following:\n• Parsing or looping through the large array/object might just take a really long time\n• Parsing or looping through the large array/object might cause excessive server level CPU\n• UI might freeze in the browser\n• Large HTTP Request payload size might be slow if transferred over the network\n• Might run the ServiceNow Java Virtual Machine low on memory\n\nThe most common problem listed above is the last one; running the JVM low on memory. The Java Virtual Machine in which ServiceNow runs has 2GB of memory total (heap space). At any given time, 20% to 80% of memory might be in use. Large implementations of ServiceNow can often stay above 60% memory-in-use for much of their business day. This means there is less available memory at any given time and developers will need to be more careful to avoid creating memory scarcity. GC floor above 80% is generally considered dangerously high.\n\nThis all begs the question, how much memory can I safely use in my code? How big is too big? As a very rough frame of reference, an array with 160,000 sys_id's will take a little under 10MB in memory or 0.5% of total memory in the system. Now suppose you have all 16 of your semaphores doing that process and 8% of total memory is locked up. That's probably a very safe number for any size customer.\n\nAs far as we are aware, there is no testing framework for ensuring efficient memory usage. One idea that we've had - but never tried - is to write a gs.sleep() statement at the very end of whatever script we want to test for memory. Then check memory before, during and after executing the script by looking at /stats.do. The part that says \"Free percentage: 58.0\" tells you how much available memory you have at any given time. If you did this on a sub-prod with little else running at the same time you ought to be able to get a pretty good idea of how much memory is being retained by your code.\n\nThere is an interesting thread in StackOverflow about how to test object sizes: [Stack Overflow] memory - JavaScript object size - Stack Overflow\n\nSome more ways to avoid out-of-memory are listed further down in this article:\n\n#5 Limit number of returned records when querying very large tables\n\n#6 Running out of memory due storing dot-walked GlideRecord fields in arrays\n\n#8 Infinite or Very Large Loops and Recursion\n\nThere are many potential ways that you could avoid excessive memory due to large arrays or objects. One way (perhaps less well known and perhaps less useful) is to de-reference unneeded objects after they are used. Javascript will attempt to Garbage clean any variable that is not accessible from root. If you have a very long script that builds multiple large arrays, it might be worth it to de-reference any arrays as soon as they are no longer needed.\n\nHere is a script example demonstrating how Javascript handles de-referencing and garbage collection.\n\n#3 Avoid Spawning too much work, too quickly\n\nThis issue can manifest in many ways and it would be impossible to define what is \"too much\" or \"too quickly\" in every context in this simple community article. However, it is still an important topic and therefore we will attempt to address it by giving an analogy and then providing some simple examples from Service Portal that demonstrate the rule.\n\nHere's an analogy: You might think of too much work/too quickly as a \"pipe problem\", where you are trying to get particles through a pipe without clogging the pipe. If the particles are big then you can get fewer of them through the pipe at the same time, if the particles are smaller then you can get more through the pipe, but you must watch out for how many you send at the same time. Ultimately you must figure out the following things:\n• How big is my pipe?\n• How big are the particles?\n• How many particles will I be sending at once?\n• What is the current available capacity of my pipe?\n\nOnce you answer these questions it is a matter of designing your solution to stay well within the available capacity of the pipe.\n\nHere is a list of some common areas where folks run into the \"too much work, too quickly\" issue:\n• Asynchronous Business Rules (see [Community] Performance considerations when using ASYNC Business Rules, also of note: Discovery Sensors run on Asynchronous Business Rules)\n• Text Search (aka Zing, this feature allows multi-threading on the app layer, putting it at higher risk for overloading the database)\n• Anything that automatically loads in the UI e.g.\n• ServicePortal header/footer that query the Task or CMDB tables\n• Scripted ServicePortal menu widgets that query the Task or CMDB tables\n\nContextual Search automatically fires off an AJAX call to the server whenever someone enters characters in a text box. On the server side a text search operation looks for any matching results for the text that was entered in the text box and returns those results. In order to do that, each text search query is multi-threaded at the app layer, meaning that a single text search operation can trigger up to 5 database queries at once. If a few users all do this at once, the database can quickly come under heavy load, especially if the text search implementation is not well tuned. Most database servers in ServiceNow's farm (as of July 31, 2020) have between 32 and 48 CPU's and if enough users are executing contextual search at the same time, the \"pipe\" of the database server can get clogged. To avoid this, if you are implementing Contextual Search on a frequently accessed page, like in your ServicePortal Service Catalog, you should reduce the frequency that Contextual Search will fire and improve the execution time of the search operations.\n\nSee [KB0813266] Tuning Contextual Search (CXS) for details on optimizing Contextual Search.\n\nRecord Watchers are a type of messaging trigger in ServiceNow's backend that allow a publish/subscribe model that is server-driven. When the platform registers a change to a record that meets the conditions of a Record Watcher, all subscribers are \"notified\" of the change. The more broadly a Record Watcher is defined, the more frequently it will trigger notifications. Each notification causes a transaction between the client and server of any user who is subscribed. Further, if a broadly defined Record Watcher appears on many pages then you could have the makings of a potential transaction storm.\n\nFor example, suppose that you build a Record Watcher that looks for any changes to a shopping cart (sc_cart) and you put this Record Watcher in your Service Catalog header. See the problem? We didn't say only the current user's shopping cart! What if 100 users all decide to put something in their carts at the same time? This is not that far fetched. It is based on actual customer scenarios where, for example, a catalog item was advertised during a company-wide meeting. The result is that each user will get reload from every other user. Thus they will all experience 100 refreshes to their UI. That means 100 users with 100 refreshes, so a total of 10,000 transactions suddenly sent to ServiceNow all at once. This will certainly cause some performance degradation to each individual user who is on the Service Catalog, but it could also overload system resources, thus causing system-wide performance degradation.\n\nMake sure record watchers adhere to the recommendations in KB0639111 and all queries should adhere to the recommendations in the following community article about performance best practice for efficient query filters: [Community] Performance Best Practice for Efficient Queries - Top 10 Practices\n\nAlso see [Community] Are your auto-refreshing widgets causing instance slowdowns?\n\n\n\n#4 Correctly use asynchronous methods on the server when a transaction is waiting for a response\n\nDuring the course of handling an end user transaction, server-side JavaScript can be used for many things such as executing business logic or even interacting with an external endpoint. What is important, however, is to make sure that this code is executed in a manner which is as optimal as possible since the end user is waiting for a response.\n\nThe platform allows execution of code both synchronously (do it right now and wait for the results) and asynchronously (do it at some point in the future, generally within the next few seconds, and don't wait). When writing code that is triggered via a transaction, think about whether that transaction actually needs the results of the code in order to complete. If it doesn't, then you are probably better off executing your code asynchronously outside of the transaction. This gives best transactional performance, and if the transaction is triggered via a user, keeps your users happy.\n\nFor example let's say you need to trigger some business logic when data is modified in a particular table - the obvious way with which to do this is via a business rule - what is less obvious, however, is how/when the business rule should run. In short there are three options:\n• Before - execute the rule before the original table is modified (synchronous)\n• After - execute the rule after the original table is modified (synchronous)\n• Async - execute asynchronously outside of the triggering transaction (asynchronous)\n\nIf the business rule must execute and complete within the context of the triggering transaction (i.e. everything should be atomic or remaining processing performed by the transaction depends on the results of the business rule) then it makes sense to use before or after. The drawback, however, is that these are synchronous and therefore run within the context of the triggering transaction, meaning that the transaction takes longer to execute (especially if your code is slow). If its OK for the business rule to execute outside of the triggering transaction (for example once the transaction has completed) use Async - the platform will automatically execute the code via a scheduled job on a background worker thread meaning your users don't have to wait. (see [Community] Performance considerations when using ASYNC Business Rules)\n\nAs a second example, let's consider that a transaction needs to interact with an external endpoint via REST. Again, if the transaction needs data from the endpoint before it can complete (for example the transaction is a search request which pulls results from somewhere outside of ServiceNow) then the communication has to be performed synchronously. Network communications are, however, inherently slow, meaning that the triggering transaction will likely take much longer to execute. This is especially true if the endpoint has some kind of issue, meaning it is unexpectedly slow or doesn't respond at all. If the interaction is 'fire and forget' or even if you need to process results but can do this outside of the context of the triggering transaction, then asynchronous communications are a much better solution. Asynchronous REST can be triggered via the RESTMessageV2().executeAsync() method.\n\nHowever, be VERY careful to understand the implications of using executeAsync() as it does incur performance overhead due to using the scheduled job queue and becomes synchronous if used together with waitForResponse(), completely defeating the purpose!!\n• The call to executeAsync() creates a record in the ecc_queue table with queue of 'output' - if necessary a specific topic and MID server/cluster can be specified\n• If a MID is provided then a MID server will pick up the ecc_queue record and execute the REST request - alternatively if no MID server is specified the ecc_queue record will be executed via a scheduled job on a background worker thread\n• Regardless of the method of execution the results of the REST request will be written to an ecc_queue record with queue of 'input' and the same topic as the 'outbound' record\n\nIf nothing needs to be done with the results of the REST request processing can stop there. If, however, you want to use the results (for example to update data/drive other business logic or even implement some kind of retry mechanism) you can configure a business rule on ecc_queue which looks for records where \"queue = 'input' and topic = '[a suitable topic]' and state = 'ready'\" to handle this.\n\nSee the article below for a complete explanation of performance implications of working with RESTMessageV2 and SOAPMessageV2 methods.:\n\n[KB0694711] Outbound REST Web Services RESTMessageV2 and SOAPMessageV2 execute() vs executeAsync() B...\n\nFundamentally the less synchronous processing you can perform, the faster transactions will complete. This has a whole range of benefits:\n• Better spreading of work across semaphore pools and background worker threads\n\nNOTE: You might be wondering about why we have not included a note about synchronous vs. asynchronous AJAX. Technically the method that controls synchronous AJAX is on the browser and therefore is better suited for a client-side article. However, there is an excellent article by Mark Roethof (Community MVP) published here: Go for GlideAjax (with getXMLAnswer)!\n\n#5 Limit the number of returned records when querying very large tables.\n\nFor example, the following code might work fine if you have only a few thousands active incidents:\n\nBut if you have 1,000,000 active incidents, the query() method has to retrieve all those records and this can take time.\n\nIn cases like this, using the setLimit() method is essential.\n\nIn other cases you might just want to check whether any there are any records at all that match a certain query. For example:\n\nThis is even worse - note that the above code does nothing with the results of the query - instead of iterating over them it simply tests whether any results were returned. The query() method, however, will cause details of all matching records to be streamed from the database to the application node; which can:\n\nTo avoid this, use setLimit(1) so that at most a single record will be returned (if there are matches) or no records will be returned (if there are no matches):\n\nAnother case that this can happen is when someone uses the [Developer Portal] GlideRecord.get() method. The purpose of this method is to return one matching record given some query criteria that is assumed to result in a unique match. One might assume that the platform is optimized to handle cases where the get() method is used against a data set that returns more than one result, but you would be wrong.\n\nFor example, consider the following script:\n\nThe output of the script will be something like this (but a different \"sys_id\"):\n\nGreat, it returned one result, right? Yeah, it returned one result, but two queries were needed to get that one result - known internally as a two-pass method. The first query actually queried and returned the sys_id of every single matching value from the database and stored them in a temporary flat file on the operating system and then the second query returned the first 100 matching records by sys_id and arbitrarily populated your GlideRecord with the first matching record. That is not very efficient. Turning on \"System Diagnostics > Debug SQL (Detailed)\" would result in something like the following:\n\nIt would be much better to GlideRecord.query() with a setLimit(1) clause unless you were absolutely convinced that your query could not possibly match more than one record.\n\n#6 Avoid running out of memory due to storing dot-walked GlideElement fields\n\nOne issue that happens often is when someone stores an object reference in an array when they really only need to store a primitive data type. They might do this unintentionally or they might not realize the impact it is having.\n\nFor example, the following code stores a GlideElement object when only a simple String type is needed.\n\nA GlideElement object type is actually a Java datatype that has been exposed to Javascript through the GlideRecord API. GlideElement is many times larger than a simple 32 character String sys_id - it is in the range of 10's of kilobytes for each. By contrast, ServiceNow Javascript stores Strings as UTF-16, so a good estimate for size of a string would be the total character length x 2 bytes. Since each sys_id has 32 characters in it, the storage size would be a meager 64 bytes.\n\nUsing the GlideRecord.getValue(String) method is a good way to avoid using complex data types since it will return the simple Javascript String values instead of complex Java objects.\n\nN.B. You might notice that we have used _next() instead of next() in some of our code examples, while this isn't a performance best practice, it is a way to avoid a conflict is the given table has a field name called \"next\". There are not many tables with a field name \"next\", so this is a very rare edge case.\n\nIn ServiceNow the general naming convention is to use a meaningful two or three word variable name in camel case, starting with a lowercase letter. Here are some examples:\n\nparentCI - for the Configuration Item (CI) that is the parent of another CI.\n\nresolvedIncidents - could be a GlideRecord query of all incidents in the \"Resolved\" state\n\nstandardSchedule - could mean the 8-5 workday schedule excluding holidays\n\nloopCount - use this instead of \"i\" to run a loop\n\nUsing unique variable names has many advantages\n• It makes code manageable. Suppose you have an error message that says \"variable gr is not defined\". How are you going to figure out what script that comes from? Try a global search on \"gr\" - you will find hundreds of unrelated results. (Yes, we know, many of those results are out-of-box code - we are working on it!)\n• It makes code easy to understand. This is not just for your benefit. Be nice to the next developer who comes along - they might be able to figure out where you live.\n• It helps avoid your variables being stomped on by other scripts - in Javascript if you call down into another function, the variables that are local to your current closure will be accessible from the function that is being called. This is perhaps the most insidious side effect of using common variable names. When your variable is stomped on by another script it is hard to troubleshoot because suddenly your \"i\" variable goes from 100 to 7 without any explanation. Rename common variables like \"gr\", \"ga\", \"i\" to more unique names. Commonly used variable names have a tendency to get stomped on by variables in other scopes.\n\nReferences\n\n[Community - non ServiceNow] code snippets variable and function naming\n\n[Developer Portal] Scripting Technical Best Practices\n\n[ServiceNow KB] KB0713029 Best Practice: Why using 'gr' as a GlideRecord variable name in custom scr...\n\n#8 Avoid Infinite or Very Large Loops and Recursion\n\nThis can happen a lot in the CMDB or task tables when you want to use the parent/child relationships to check the whole ancestry of a record. When doing this type of operation you run the risk of getting into a very deep or infinite loop - record A has child B has child C has child A (uh oh!). Lots has been written about how to avoid this type of thing, so we won't go into depth in this article. Here are some ideas:\n• Make some type of counter that will not let the recursion go beyond a certain number of layers deep\n• Make a max size check that will not let any array get above a certain size\n• Keep a list of items that have already been seen, breaking when recursion is detected\n\nBe careful while implementing that last safety measure above though, as you might end up creating a huge memory object and end up worse than when you started. For example, suppose are trying to avoid infinite recursion by keeping a list of items that have already been seen. If that list gets too big then you could run the instance out of memory. So, make sure that list is optimized to have a small memory footprint and put a limit on how big that list can grow.\n\nOne scripting pattern that can cause slowness is getting aggregate information on large data sets. There are a number of ways to accomplish this task and you should consider which is the best for your use case.\n\nFor very large data sets or frequently accessed operations, you should always use a pre-aggregated method. There are various features in ServiceNow that support pre-aggregated approaches. The most obvious one and the most powerful is [Doc Site] Performance Analytics. By storing aggregated values in a separate data structure, you can avoid the expensive overhead of executing real-time aggregations over and over.\n\nIn terms of simple JavaScript coding for lightweight or infrequent aggregations you can use the GlideAggregate method.\n\nDanger: By default these methods result in grouped and sorted queries - sometimes it does this even when you only want one result, like when using MAX. Watch out for cases where you don't need to group or sort and use the setGroup(false) or setOrder(false) methods appropriately.\n\nAdditional references:\n\n[KB0745198] How to get the Top 10 values from a table using the GlideAggregate function\n\n[KB0852541] How to get the MIN, MAX, AVG and SUM values from a table using the GlideAggregate functi...\n\nIf you only want the count, then do not use getRowCount(). Use GlideAggregate COUNT option instead. The reason you shouldn't use GlideRecord.getRowCount() if you only want count is that it will require a query that will stream every single matching result before it can do the count. However, if your code needs to check the count and it also needs to loop through all the GlideRecord results, then this is the way to go.\n\nNOTE: Under the covers, GlideRecord works on a 2-pass query method.\n\nThe only case where you might want to use this method is if, for some reason, it is more efficient to loop through a set of matching results and count only those results that match certain criteria. For example, perhaps the query to get the counts of different assignment groups that match a specific filter (e.g. u_my_field > 20) is really slow and you want to avoid the slow query by looping through all the results and applying the filter with code.\n\n#10 Use GlideRecord.get(name, value) not GlideRecord.get(value)\n\nThe GlideRecord.get method has two documented method signatures. It can be called with one argument, \"value\", or with two arguments, \"name\" and \"value\". However, in the backend, there is really only one method that accepts two arguments, \"name\" and \"value\".\n\nIt works like this:\n• If you call GlideRecord.get with one argument what really happens in the backend is that we trigger a two argument method, but the second argument, \"value\", is undefined and the first argument, \"name\", contains what the user intended to be the \"value\".\n• If the 2nd argument, \"value\" is undefined\n• Set \"value\" to what is in the \"name\" argument\n• If \"value\" is null or an empty string then exit the GlideRecord.get method without running a query\n• Do a one-pass query (i.e. single query looking up by sys_id) and, if found, return that result\n• If no result was found based on searching by \"sys_id\", continue on below\n• Do a two-pass query for \"name\" and \"value\"\n• If we got here by passing two arguments then \"value\" might still be null or empty string, so it could be impacted by issue number 1 from this article.\n• If we got here by passing one argument, then at this point \"name\" will be \"sys_id\" and so this two-pass query is basically redundant.\n• Also, remember from earlier in this article, a two-pass query includes two queries, one to bring back the sys_id's of all matching records and one to bring back all the other columns for the first batch of X matching records.\n• If we didn't find anything yet, and GlideRecord.get was called with single argument, and \"value\" is not a 32 character alphanumeric (i.e. does not match the constraints of a sys_id), then do another two-pass query and assume that \"name\" should be the display field of the table. For example, for the Incident table, this would run a query for any record where the \"number\" field equals \"value\".\n\nAs you can see, calling the one argument GlideRecord.get method can trigger a lot of queries that you might not intend. To avoid these unintended queries, use the two argument version of GlideRecord.get and validate that you are passing a valid \"name\" and \"value\".\n\nFinally, as mentioned earlier in this article, using GlideRecord.get initiates a two-pass query, potentially returning all matching records. If you only want to return a single record, you should be using GlideRecord.setLimit(1) with GlideRecord.query().\n\nWhenever you dot-walk beyond the first level on a GlideRecord, in the backend, the database needs query the referenced record and return all the fields to populate a new GlideRecord object. This additional query adds overhead to system processing and should be avoided if possible.\n\nOne way to avoid this extra query is to use the getValue() method on reference fields when you want to use the sys_id of the referenced record. For example, consider the following code:\n\nThe code is trying to push the sys_id of an Assignment Group record into a property of an object. It is doing this by doing a 2nd level dot walk through the u_assignment_group field (a reference field pointing to the sys_user_group table) to get the sys_id field. This triggers a query against the sys_user_group query for every execution of the enclosing while loop. However, this is unnecessary because the value of a reference field is the sys_id of the record to which it is pointing. The value they are looking for was already fetched during the GlideRecord.next() operation and is stored in the CategoryMatcher object. The code can be refactored as follows to avoid the extra query:\n\nBut what if you need to do a 2nd level dot-walk and the field you need is not a sys_id? Good news! In the Washington DC release we added a new method to GlideRecord called addExtraField(). This method was introduced to pre-fetch dot-walked fields to avoid additional post-query lookups. See a video explaining how it works by Robert \"The Duke\" Fedoruk here: https://www.servicenow.com/community/developer-blog/quot-addextrafield-quot-amazing-performance-impr...\n\nNOTE: Some of the content in this Community article was taken directly from Sergiu's excellent blog post (with permission, of course), [Community] Performance considerations when using GlideRecord"
    },
    {
        "link": "https://servicenow.com/community/developer-articles/gliderecord-hints-tips-common-issues-and-good-practices/ta-p/2323766",
        "document": "GlideRecord is one of, if not the most, powerful tool at your disposal as a developer in ServiceNow and understanding the basics of using and interacting with it is more or less a prerequisite when dealing with advanced requirements. There are certainly tons of articles and posts covering this topic but none that seem to contain all of the tricks I've picked up over the years, so I thought I'd take some time and put together my own.\n\nI'll start off with an obvious, yet pervasive bad habit to break and that is always using:\n\nAs I mentioned, there are tons upon tons of posts and articles with sample scripts and the vast majority of them use this exact same format. This is fine for an example - it makes sense, helps reinforce what you are demonstrating and keeps samples somewhat consistent, but as a practice within your instance it's a bad idea. While it is true, as long as a variable name is unique within a script there is no technical reason you can't use gr, it is always a best-practice to keep variable names descriptive and meaningful. As a compromise I suggest at least appending a table name or record prefix to remind you what you are looking at. For example:\n\n*Bonus Hint, if you copy some sample code into a script field within ServiceNow, double-click on one instance of gr (to highlight it) and click ctrl + ; you will invoke replace-all. Hit enter, type your new variable name, and you should replace all instances at once. I do this in a separate (blank, new) record from the one where I want to use the copied script to void any accidental replacements).\n\nWhen you can, go get'em!\n\nWhenever you have the sys_id of a specific record that you need to query for, you can skip a lot of the hassle by just using .get()\n\nFor example, if you have a reference field on a form named config_item that reference cmdb_ci and need to return attributes in a script you can use this:\n\nOk - you've probably seen that before, at least somewhere. Did you know, however, that .get() can be used in more ways than just with a sys_id? That's right! This function will actually accept two parameters.\n\nThe first parameter is the name of the field that you want to search and the second parameter is the value to search for and behaves somewhat differently based on whether the value you pass is unique.\n\nFor example, for an incident where you have the number, you can use something like this:\n\nIn this case .get() will behave exactly as before, returning one record.\n\nIf, however, you use something like this:\n\ngr_incident will contain a result set of all incidents with a category of software. In this case, you can use .next() to cycle through results.\n\nThis means that, if you have a query with just one argument where field = value, you can use .get() as shorthand instead of .addQuery() and .query().\n\nHave you ever been in a situation like this; you need to query all of the incidents assigned to a particular group, where you only have the group name and the value changes dynamically? I see situations like this arise often and many solutions would have you first take the name of the group, use GlideRecord to lookup the sys_id, and then query the incident table for any records where assignment_group = the sys_id.\n\nThat certainly works, but what isn't entirely obvious is that it's not necessary to perform that first lookup. Instead you can Dot Walk directly in the query on incident, like this:\n\nGlideFilter.checkRecord() - you little match-maker you!\n\nOk, while not \"technically\" part of GlideRecord itself, this little utility can be an enormous time-saver. GlideFilter basically gives you a way to check if a particular record in a GlideRecord query matches the condition (query) that you provide. So, how does this help?\n\nLet's say you want to look at all P1 incidents that have been open for more than an hour and take some action to escalate them (send a notification), but let's say that you want to take some additional action if the assignment group is a certain value and even more drastic action if the user is flagged as a VIP. You could break that down into three queries, going from broad to more specific, taking action - or you could consolidate them, using GlideFilter.\n\nThis can really help to optimize code!\n\nGlideFilter can can be used in pretty much any situation where you want to take a list of records and then check to see if a specific record matches additional criteria. I didn't really know about or understand this option for years, but once I figured it out I've yet to find an end to uses for it!\n\nThe difference between \"gr.sys_id\" and \"gr.getValue('sys_id')\"\n\nOn the surface, both of these seem to return the same result, which can make it frustrating when you seem to \"suddenly\" encounter an issue where you run a query to gather data from multiple records, but only seem to be getting data from one record. To add insult to injury, it seems to be the last record in the query set. By the way, while I'm using sys_id as an example, this applies to any any field on a GlideRecord.\n\nThe difference between these two lines is that \"gr.sys_id\" is a pointer and gr.getValue('sys_id') is a result.\n\nIf you were to iterate through a query, pushing \"gr.sys_id\" to an array, the end result would be an array with multiple entries of the same sys_id - the last one processed through your loop. Think of \"gr.sys_id\" as a bookmark, it opens the same page every time, but the content is whatever was last loaded to the server.\n\nUsing \"gr.getValue('sys_id')\" on the other hand is like taking a snap-shot of a web page and saving it offline. Even if they update the site ten seconds later, the copy you saved remains intact and accessible the way it was.\n\nFor many situation you will find no impact or difference between using .sys_id or .getValue('sys_id), but recognizing when you can use one vs. the other can be challenging and frustrating. I would therefore recommend using .getValue() as a habit because, in my experience, it always works.\n\nAs a bonus, using .getValue() comes with the added advantage of allowing you to dynamically pass the name of the field you want the value of, instead of hard-coding it. Just assign the name of the field to a string and pass the string as the argument for .getValue(). This is particularly useful when creating GlideAjax functions as it allows you to be more flexible in what you are able to return, using the same framework without having to write specific functions.\n\nOh wait, here it is! Ever had a situation where you want to easily construct a link directly to a record out of your GlideRecord set? Well, you can!\n\nA few uncommonly used features that can come in handy\n\nEvery so often I come across a feature that is useful, interesting, or that I just find preferable. I personally prefer anything that saves a few key strokes when I'm coding so:\n\nHonestly, if one were so inclined, you could write a decent sized book on the subject of GlideRecord and all of its nuances and vagaries but, that's all for now! Hopefully you gleaned something useful, cool or neat from my eclectic ramblings!\n\nIf you found this article helpful or useful, please be kind and click appropriately. If you found it really useful, you could always use the 3-dot menu to bookmark it for later!"
    },
    {
        "link": "https://qualityclouds.com/documentation/qcr/rules-for-servicenow/qualityclouds-servicenow-coding-best-practice-rules",
        "document": "What will you see?"
    },
    {
        "link": "https://servicehub.ucdavis.edu/servicehub?id=ucd_kb_article&sys_id=ccfd924f1bc5b9144690ea04604bcb02",
        "document": ""
    }
]