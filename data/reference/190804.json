[
    {
        "link": "https://threejs.org/docs/examples/en/loaders/GLTFLoader.html",
        "document": "A loader for `glTF 2.0` resources. \n\n\n\n [link:https://www.khronos.org/gltf glTF] (GL Transmission Format) is an [link:https://github.com/KhronosGroup/glTF/tree/master/specification/2.0 open format specification] for efficient delivery and loading of 3D content. Assets may be provided either in JSON (.gltf) or binary (.glb) format. External files store textures (.jpg, .png) and additional binary data (.bin). A glTF asset may deliver one or more scenes, including meshes, materials, textures, skins, skeletons, morph targets, animations, lights, and/or cameras.\n\n[name] uses [page:ImageBitmapLoader] whenever possible. Be advised that image bitmaps are not automatically GC-collected when they are no longer referenced, and they require special handling during the disposal process. More information in the [link:https://threejs.org/docs/#manual/en/introduction/How-to-dispose-of-objects How to dispose of objects] guide.\n\n[name] is an add-on, and must be imported explicitly. See [link:#manual/introduction/Installation Installation / Addons].\n\nThe following glTF 2.0 extension is supported by an external user plugin\n\n1You can also manually process the extension after loading in your application. See [link:https://threejs.org/examples/#webgl_loader_gltf_variants Three.js glTF materials variants example].\n\nWhen loading textures externally (e.g., using [page:TextureLoader]) and applying them to a glTF model, textures must be configured. Textures referenced from the glTF model are configured automatically by GLTFLoader.\n\nMetadata from unknown extensions is preserved as ‚Äú.userData.gltfExtensions‚Äù on Object3D, Scene, and Material instances, or attached to the response ‚Äúgltf‚Äù object. Example:\n\n[page:LoadingManager manager] ‚Äî The [page:LoadingManager loadingManager] for the loader to use. Default is [page:LoadingManager THREE.DefaultLoadingManager].\n\nSee the base [page:Loader] class for common properties.\n\nSee the base [page:Loader] class for common methods.\n\n[page:String url] ‚Äî A string containing the path/URL of the `.gltf` or `.glb` file.\n\n [page:Function onLoad] ‚Äî A function to be called after the loading is successfully completed. The function receives the loaded JSON response returned from [page:Function parse].\n\n [page:Function onProgress] ‚Äî (optional) A function to be called while the loading is in progress. The argument will be the XMLHttpRequest instance, that contains .[page:Integer total] and .[page:Integer loaded] bytes. If the server does not set the Content-Length header; .[page:Integer total] will be 0.\n\n [page:Function onError] ‚Äî (optional) A function to be called if an error occurs during loading. The function receives error as an argument.\n\n\n\nBegin loading from url and call the callback function with the parsed response content.\n\n[page:DRACOLoader dracoLoader] ‚Äî Instance of DRACOLoader, to be used for decoding assets compressed with the KHR_draco_mesh_compression extension.\n\nRefer to this [link:https://github.com/mrdoob/three.js/tree/dev/examples/jsm/libs/draco#readme readme] for the details of Draco and its decoder.\n\n[page:KTX2Loader ktx2Loader] ‚Äî Instance of KTX2Loader, to be used for loading KTX2 compressed textures.\n\n[page:ArrayBuffer data] ‚Äî glTF asset to parse, as an `ArrayBuffer`, `JSON` string or object.\n\n [page:String path] ‚Äî The base path from which to find subsequent glTF resources such as textures and .bin data files.\n\n [page:Function onLoad] ‚Äî A function to be called when parse completes.\n\n [page:Function onError] ‚Äî (optional) A function to be called if an error occurs during parsing. The function receives error as an argument.\n\n\n\nParse a glTF-based `ArrayBuffer`, `JSON` string or object and fire [page:Function onLoad] callback when complete. The argument to [page:Function onLoad] will be an [page:Object] that contains loaded parts: .[page:Group scene], .[page:Array scenes], .[page:Array cameras], .[page:Array animations], and .[page:Object asset]."
    },
    {
        "link": "https://threejs.org/docs/manual/en/introduction/Loading-3D-models.html",
        "document": "3D models are available in hundreds of file formats, each with different purposes, assorted features, and varying complexity. Although three.js provides many loaders, choosing the right format and workflow will save time and frustration later on. Some formats are difficult to work with, inefficient for realtime experiences, or simply not fully supported at this time.\n\nThis guide provides a workflow recommended for most users, and suggestions for what to try if things don't go as expected.\n\nIf you're new to running a local server, begin with [link:#manual/introduction/Installation installation] first. Many common errors viewing 3D models can be avoided by hosting files correctly.\n\nWhere possible, we recommend using glTF (GL Transmission Format). Both .GLB and .GLTF versions of the format are well supported. Because glTF is focused on runtime asset delivery, it is compact to transmit and fast to load. Features include meshes, materials, textures, skins, skeletons, morph targets, animations, lights, and cameras.\n\nPublic-domain glTF files are available on sites like Sketchfab, or various tools include glTF export:\n\nIf your preferred tools do not support glTF, consider requesting glTF export from the authors, or posting on the glTF roadmap thread.\n\nWhen glTF is not an option, popular formats such as FBX, OBJ, or COLLADA are also available and regularly maintained.\n\nOnly a few loaders (e.g. [page:ObjectLoader]) are included by default with three.js ‚Äî others should be added to your app individually.\n\nOnce you've imported a loader, you're ready to add a model to your scene. Syntax varies among different loaders ‚Äî when using another format, check the examples and documentation for that loader. For glTF, usage with global scripts would be:\n\nSee [page:GLTFLoader GLTFLoader documentation] for further details.\n\nYou've spent hours modeling an artisanal masterpiece, you load it into the webpage, and ‚Äî oh no! üò≠ It's distorted, miscolored, or missing entirely. Start with these troubleshooting steps:\n‚Ä¢ Check the JavaScript console for errors, and make sure you've used an `onError` callback when calling `.load()` to log the result.\n‚Ä¢ View the model in another application. For glTF, drag-and-drop viewers are available for three.js and babylon.js. If the model appears correctly in one or more applications, file a bug against three.js. If the model cannot be shown in any application, we strongly encourage filing a bug with the application used to create the model.\n‚Ä¢ Try scaling the model up or down by a factor of 1000. Many models are scaled differently, and large models may not appear if the camera is inside the model.\n‚Ä¢ Try to add and position a light source. The model may be hidden in the dark.\n‚Ä¢ Look for failed texture requests in the network tab, like `\"C:\\\\Path\\To\\Model\\texture.jpg\"`. Use paths relative to your model instead, such as `images/texture.jpg` ‚Äî this may require editing the model file in a text editor.\n\nAsking for help\n\nIf you've gone through the troubleshooting process above and your model still isn't working, the right approach to asking for help will get you to a solution faster. Post a question on the three.js forum and, whenever possible, include your model (or a simpler model with the same problem) in any formats you have available. Include enough information for someone else to reproduce the issue quickly ‚Äî ideally, a live demo."
    },
    {
        "link": "https://threejs.org/docs#examples/en/loaders/GLTFLoader.load",
        "document": ""
    },
    {
        "link": "https://discoverthreejs.com/book/first-steps/load-models",
        "document": "In the last chapter, we created a simple toy train model using some of the built-in three.js geometries, and it quickly became clear that it would be hard to build anything complex or organic using just these. To create beautiful 3D models, a sophisticated modeling program is required. You can use three.js to build any kind of 3D application, however, building a modeling app from scratch would be a huge amount of work. A much simpler solution is to use an existing program and export your work for use in three.js‚Ä¶ or, cheat, and download any of the millions of amazing models and other scene assets that are available for free in many places around the web.\n\nIn this chapter, we‚Äôll show you how to load some models that were created in Blender, an open-source 3D graphics application that can be used for modeling, scene building, material creation, animation authoring, and more. Once you have created a model in Blender, you can export your work using a 3D format such as glTF, then use the plugin to bring the model into three.js.\n\nThe Best Way to Send 3D Assets Over the Web: glTF\n\nThere have been many attempts at creating a standard 3D asset exchange format over the last thirty years or so. FBX, OBJ (Wavefront) and DAE (Collada) formats were the most popular of these until recently, although they all have problems that prevented their widespread adoption. For example, OBJ doesn‚Äôt support animation, FBX is a closed format that belongs to Autodesk, and the Collada spec is overly complex, resulting in large files that are difficult to load.\n\nHowever, recently, a newcomer called glTF has become the de facto standard format for exchanging 3D assets on the web. glTF (GL Transmission Format), sometimes referred to as the JPEG of 3D, was created by the Kronos Group, the same people who are in charge of WebGL, OpenGL, and a whole host of other graphics APIs. Originally released in 2017, glTF is now the best format for exchanging 3D assets on the web, and in many other fields. In this book, we‚Äôll always use glTF, and if possible, you should do the same. It‚Äôs designed for sharing models on the web, so the file size is as small as possible and your models will load quickly.\n\nHowever, since glTF is relatively new, your favorite application might not have an exporter yet. In that case, you can convert your models to glTF before using them, or use another loader such as the or . All three.js loaders work the same way, so if you do need to use another loader, everything from this chapter will still apply, with only minor differences.\n\nglTF files can contain models, animations, geometries, materials, lights, cameras, or even entire scenes. This means you can create an entire scene in an external program then load it into three.js.\n\nglTF files come in standard and binary form. These have different extensions:\n‚Ä¢ Standard .gltf files are uncompressed and may come with an extra .bin data file.\n‚Ä¢ Binary .glb files include all data in one single file.\n\nBoth standard and binary glTF files may contain textures embedded in the file or may reference external textures. Since binary .glb files are considerably smaller, it‚Äôs best to use this type. On the other hand, uncompressed .gltf are easily readable in a text editor, so they may be useful for debugging purposes.\n\nThere are lots of free glTF models available on the three.js repo, and amongst these are three simple and beautiful models of a parrot, a flamingo, and a stork, created by the talented people at mirada.com. These three models are low poly, meaning they‚Äôll run on even the most low-power of mobile devices, and they are even animated.\n\nYou can find these three files in the editor, in the assets/models/ folder. In this chapter, we‚Äôll load Parrot.glb, Flamingo.glb, and Stork.glb and then add the bird-shaped meshes each file contains to our scene. In the next chapter, we‚Äôll show you how to play the flying animation that is included with each bird.\n\nIf you‚Äôre working locally rather than using the inline code editor, you‚Äôll need to set up a webserver. Otherwise, due to browser security restrictions, you won‚Äôt be able to load these files from your hard drive.\n\nTo load glTF files, first, you need to add the plugin to your app. This works the same way as adding the plugin. You can find the loader in examples/jsm/loaders/GLTFLoader.js on the repo, and we have also included this file in the editor. Go ahead and locate the file now.\n\nImporting and creating an instance of the loader works like this:\n\nYou can use one instance of the loader to load any number of glTF files.\n\nAll three.js loaders have two methods for loading files: the old callback-based method, and the newer Promise based method. Again, refer to chapter A.5 where we cover the difference between these two approaches in detail. Promises allow us to use async functions, which in turn results in much cleaner code, so throughout this book, we will always use .\n\nSet Up Main.js and World.js to Handle Async/Await\n\nThe keyword means ‚Äúwait here until the model has loaded‚Äù. If you have previously dealt with loading models using callbacks or Promises, then will seem almost magical in its simplicity. However, we need to make a few adjustments to our code before we can use it since we can only use inside a function that has been marked as :\n\nAnother issue is that we cannot mark a constructor as async. A common solution to this is to create a separate method.\n\nThis way, the constructor can handle the synchronous setup of the class, as usual, and then the init method will take over for asynchronous setup. We will use this approach, so we need to create a new method.\n\nGo ahead and add an empty method to World now, and make sure you mark it . Splitting the setup into synchronous and asynchronous stages like this gives us full control over the setup of our app. In the synchronous stage, we will create everything that doesn‚Äôt rely on loaded assets, and in the asynchronous stage, we‚Äôll create everything that does.\n\nOver in main.js, first, we must also mark the main function as async. This is required so that we can call the async method.\n\nNow we can call both stages of setting up the World app. First, the synchronous constructor, as usual, then the new method to handle asynchronous tasks.\n\nNo method of loading files is complete unless we can also handle any errors that occur. Errors can be as simple as a typo in the file name, or something more complex like a network error. Fortunately, with async functions, error handling is also simple. At the bottom of main.js, replace this line:\n\nNow any errors will be logged to the console. In a real app, you might want to do more sophisticated error handling, such as displaying a message to the user to let them know that something went wrong. However, while we are in development mode, the most important thing is that all errors are logged to the console where we can see them.\n\nNow everything is set up and we can go ahead and load our first model. Open (or create) the components/birds/birds.js module. Start by importing the , then create an async function. Inside the function, create an instance of the loader, and finally, export the function at the bottom of the file:\n\nThe structure of this new module should be familiar to you since it‚Äôs the same as nearly every other component we have created so far. The only difference is the keyword.\n\nOver in World, update the list of imports:\n\nNow, we‚Äôre ready to load the Parrot.glb file using . Once you have done so, log the loaded data to the console:\n\nNext, call the in :\n\nWe need to take a deeper look at the data we have just loaded before we can add the model to our scene, so for now we‚Äôve simply logged the data to the console. Open up the browser console (press F12). You should see the word Squaaawk! followed by an Object containing the loaded data. This Object contains meshes, animations, cameras, and other data from the file:\n‚Ä¢ is an array of animation clips. Here, there‚Äôs a flying animation. We‚Äôll make use of this in the next chapter.\n‚Ä¢ contains metadata showing this glTF file was created using the Blender exporter.\n‚Ä¢ is an array of cameras. This file doesn‚Äôt contain any cameras, so the array is empty.\n‚Ä¢ contains technical details about the .\n‚Ä¢ is a containing any meshes from the file. This is where we‚Äôll find the parrot model.\n‚Ä¢ : The glTF format supports storing multiple scenes in a single file. In practice, this feature is rarely used.\n\nis a standard property that every JavaScript object has, you can ignore that.\n\nUsually, all you need is , , and (not !) and you can safely ignore everything else.\n\nExtracting data from a glTF file usually follows a predictable pattern, especially if the file contains a single animated model, as these three files do. This means we can create a function and then run it on each of the three files. We‚Äôll do this in a separate module. Open or create the birds/setupModel.js module, and create the function, following the now-familiar pattern:\n\nThe idea of this function is that we can pass in the loaded data and get back the bird model, ready to be added to the scene. Next, import this new module into birds.js, then pass in the loaded data. Finally, return the results for use within World.\n\nExtract the Mesh from the Loaded Data\n\nAt this point, we have the unprocessed loaded data within the function. The next step is to extract the model, and then do any processing to prepare it for use. The amount of work we need to do here depends on the model, and what we want to do with it. Here, all we need to do is extract the mesh, but in the next chapter, we‚Äôll have a bit more work to do as we connect the animation clip to the mesh.\n\nLook at the loaded data in the console again, and expand the . This a , and any meshes that are in the file will be children of the group. These can be accessed using the array. If you look inside there, you‚Äôll see that has only one object inside it, so that must be our parrot model.\n\nUsing this knowledge, we can finish the function:\n\nNote A: if you click the toggle to complete the scene in the editor, then view the array in the console, it will be empty. This is because, by the time you look at it, the mesh has already been removed and added to the scene.\n\nNote B: you could also just add the to your scene since it‚Äôs a group. That would add an additional node to your scene graph but everything will still work. However, it‚Äôs best practice to keep your scene graph as simple as possible, since every node means additional calculations are required to render the scene.\n\nAdd the Mesh to the Scene\n\nOver in World, now returns the parrot mesh and you can add it to the scene:\n\nLoad the Other Two Birds\n\nYou can use a single instance of the to load any number of files. When performing multiple asynchronous operations with async functions, you should (in most cases) use . We go into the reason for this in more detail in the appendix, but here‚Äôs the short version.\n\nFirst, here‚Äôs the obvious way of loading the other two files:\n\nThere‚Äôs a problem with this approach. As we stated above, means wait here until the file has loaded. This means the app will wait until the parrot has fully loaded, then start to load the flamingo, wait until that has fully loaded, and finally start to load the stork. Using this approach, loading will take nearly three times longer than it should.\n\nInstead, we want all three files to load at the same time, and the simplest way of doing this is to use .\n\nThen we can process each file‚Äôs loaded data using the function. Once we do that, here‚Äôs our (nearly complete) function:\n\nOver in World, you now have all three models. Add them to your scene:\n\nJust like visiting the zoo!\n\nIt is possible for models loaded from a glTF file to have a position already specified, but that‚Äôs not the case here, so all three models start at the point $(0,0,0)$, all jumbled together on top of each other. We‚Äôll adjust the position of each bird to make it look like they are flying in formation:\n\nThe birds.js module is now complete. Here‚Äôs the final code:\n\nCenter the Camera on the Parrot\n\nThe very last thing we‚Äôll do is adjust the target. Currently, this is in its default position, the center of the scene. Now that we have moved the birds into formation, this ends up being somewhere around the tail of the parrot. It would look better if the camera focused on the center of the bird rather than its tail. We can easily set this up by copying the into . However, to do so, we need to access within , so first, let‚Äôs convert it to a module-scoped variable.\n\nNow, the controls are accessible from and we can move the target to the center of the parrot.\n\nNext up, we‚Äôll introduce the three.js animation system and show you how to play the animation clips that were loaded alongside the bird models."
    },
    {
        "link": "https://discourse.threejs.org/t/how-to-load-a-3d-model/14758",
        "document": "Hello reader,\n\n I am new to this three.js and I am using it in my final year project, I‚Äôve learnt about scene, camera, renderer etc. I have loaded an geometryBox, but I am failing to load 3D Object of GLTF format, I have seen https://www.youtube.com/watch?v=1TeMXIWRrqE&t=190s this video, and have done exact same thing but this isn‚Äôt working, please help.\n\n your help will be highly appreciated.\n\n warm regards.\n\nYou can compare with the very simple example from the\n\n Collection of examples from discourse.threejs.org .\n\nEverything works fine if I move the textures in a directory: That‚Äôs because the assets refers to textures like so: . In your project folder however, the textures are in the same directory like all other files which is obviously wrong.\n\nI have made the textures directory but still getting this following error: Error: THREE.GLTFLoader: Failed to load buffer ‚Äúscene.bin‚Äù.\n\n at Object.onError (GLTFLoader.js:1724)\n\n at XMLHttpRequest. (three.module.js:35840)\n\nThank you so much guys for your help! I figured out the error, I converted gltf file into glb and it loaded!"
    },
    {
        "link": "https://threejs.org/docs/api/en/materials/ShaderMaterial.html",
        "document": "A material rendered with custom shaders. A shader is a small program written in [link:https://www.khronos.org/files/opengles_shading_language.pdf GLSL] that runs on the GPU. You may want to use a custom shader if you need to:\n‚Ä¢ implement an effect not included with any of the built-in [page:Material materials]\n‚Ä¢ combine many objects into a single [page:BufferGeometry] in order to improve performance\n‚Ä¢ A `ShaderMaterial` will only be rendered properly by [page:WebGLRenderer], since the GLSL code in the [link:https://en.wikipedia.org/wiki/Shader#Vertex_shaders vertexShader] and [link:https://en.wikipedia.org/wiki/Shader#Pixel_shaders fragmentShader] properties must be compiled and run on the GPU using WebGL.\n‚Ä¢ As of THREE r72, directly assigning attributes in a ShaderMaterial is no longer supported. A [page:BufferGeometry] instance must be used instead, using [page:BufferAttribute] instances to define custom attributes.\n‚Ä¢ As of THREE r77, [page:WebGLRenderTarget] or [page:WebGLCubeRenderTarget] instances are no longer supposed to be used as uniforms. Their [page:Texture texture] property must be used instead.\n‚Ä¢ Built in attributes and uniforms are passed to the shaders along with your code. If you don't want the [page:WebGLProgram] to add anything to your shader code, you can use [page:RawShaderMaterial] instead of this class.\n‚Ä¢ You can use the directive #pragma unroll_loop_start and #pragma unroll_loop_end in order to unroll a `for` loop in GLSL by the shader preprocessor. The directive has to be placed right above the loop. The loop formatting has to correspond to a defined standard.\n‚Ä¢ The loop has to be [link:https://en.wikipedia.org/wiki/Normalized_loop normalized].\n‚Ä¢ The loop variable has to be *i*.\n‚Ä¢ The value `UNROLLED_LOOP_INDEX` will be replaced with the explicitly value of *i* for the given iteration and can be used in preprocessor statements.\n\nYou can specify two different types of shaders for each material:\n‚Ä¢ The vertex shader runs first; it receives `attributes`, calculates / manipulates the position of each individual vertex, and passes additional data (`varying`s) to the fragment shader.\n‚Ä¢ The fragment ( or pixel ) shader runs second; it sets the color of each individual \"fragment\" (pixel) rendered to the screen. There are three types of variables in shaders: uniforms, attributes, and varyings:\n‚Ä¢ `Uniforms` are variables that have the same value for all vertices - lighting, fog, and shadow maps are examples of data that would be stored in uniforms. Uniforms can be accessed by both the vertex shader and the fragment shader.\n‚Ä¢ `Attributes` are variables associated with each vertex---for instance, the vertex position, face normal, and vertex color are all examples of data that would be stored in attributes. Attributes can `only` be accessed within the vertex shader.\n‚Ä¢ `Varyings` are variables that are passed from the vertex shader to the fragment shader. For each fragment, the value of each varying will be smoothly interpolated from the values of adjacent vertices. Note that `within` the shader itself, uniforms and attributes act like constants; you can only modify their values by passing different values to the buffers from your JavaScript code.\n\nThe [page:WebGLRenderer] provides many attributes and uniforms to shaders by default; definitions of these variables are prepended to your `fragmentShader` and `vertexShader` code by the [page:WebGLProgram] when the shader is compiled; you don't need to declare them yourself. See [page:WebGLProgram] for details of these variables. Some of these uniforms or attributes (e.g. those pertaining lighting, fog, etc.) require properties to be set on the material in order for [page:WebGLRenderer] to copy the appropriate values to the GPU - make sure to set these flags if you want to use these features in your own shader. If you don't want [page:WebGLProgram] to add anything to your shader code, you can use [page:RawShaderMaterial] instead of this class.\n\nBoth custom attributes and uniforms must be declared in your GLSL shader code (within `vertexShader` and/or `fragmentShader`). Custom uniforms must be defined in `both` the `uniforms` property of your `ShaderMaterial`, whereas any custom attributes must be defined via [page:BufferAttribute] instances. Note that `varying`s only need to be declared within the shader code (not within the material). To declare a custom attribute, please reference the [page:BufferGeometry] page for an overview, and the [page:BufferAttribute] page for a detailed look at the `BufferAttribute` API. When creating your attributes, each typed array that you create to hold your attribute's data must be a multiple of your data type's size. For example, if your attribute is a [page:Vector3 THREE.Vector3] type, and you have 3000 vertices in your [page:BufferGeometry], your typed array value must be created with a length of 3000 * 3, or 9000 (one value per-component). A table of each data type's size is shown below for reference: Note that attribute buffers are `not` refreshed automatically when their values change. To update custom attributes, set the `needsUpdate` flag to true on the [page:BufferAttribute] of the geometry (see [page:BufferGeometry] for further details). To declare a custom [page:Uniform], use the `uniforms` property: uniforms: { time: { value: 1.0 }, resolution: { value: new THREE.Vector2() } } You're recommended to update custom [page:Uniform] values depending on [page:Object3D object] and [page:Camera camera] in [page:Object3D.onBeforeRender] because [page:Material] can be shared among [page:Mesh meshes], [page:Matrix4 matrixWorld] of [page:Scene] and [page:Camera] are updated in [page:WebGLRenderer.render], and some effects render a [page:Scene scene] with their own private [page:Camera cameras].\n\n[page:Object parameters] - (optional) an object with one or more properties defining the material's appearance. Any property of the material (including any property inherited from [page:Material]) can be passed in here.\n\nSee the base [page:Material] class for common properties.\n\nDefines whether this material supports clipping; true to let the renderer pass the clippingPlanes uniform. Default is false.\n\nWhen the rendered geometry doesn't include these attributes but the material does, these default values will be passed to the shaders. This avoids errors when buffer data is missing.\n\nDefines custom constants using `#define` directives within the GLSL code for both the vertex shader and the fragment shader; each key/value pair yields another directive: yields the lines in the GLSL code.\n\nAn object with the following properties: this.extensions = { clipCullDistance: false, // set to use vertex shader clipping multiDraw: false // set to use vertex shader multi_draw / enable gl_DrawID };\n\nDefine whether the material color is affected by global fog settings; true to pass fog uniforms to the shader. Default is false.\n\nFragment shader GLSL code. This is the actual code for the shader. In the example above, the `vertexShader` and `fragmentShader` code is extracted from the DOM; it could be passed as a string directly or loaded via AJAX instead.\n\nDefines the GLSL version of custom shader code. Valid values are `THREE.GLSL1` or `THREE.GLSL3`. Default is `null`.\n\nIf set, this calls [link:https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bindAttribLocation gl.bindAttribLocation] to bind a generic vertex index to an attribute variable. Default is undefined.\n\nRead-only flag to check if a given object is of type [name].\n\nDefines whether this material uses lighting; true to pass uniform data related to lighting to this shader. Default is false.\n\nControls wireframe thickness. Default is `1`.\n\n\n\n Due to limitations of the [link:https://www.khronos.org/registry/OpenGL/specs/gl/glspec46.core.pdf OpenGL Core Profile] with the [page:WebGLRenderer WebGL] renderer on most platforms linewidth will always be `1` regardless of the set value.\n\nDefine whether the material is rendered with flat shading. Default is false.\n\nAn object of the form: specifying the uniforms to be passed to the shader code; keys are uniform names, values are definitions of the form where `value` is the value of the uniform. Names must match the name of the uniform, as defined in the GLSL code. Note that uniforms are refreshed on every frame, so updating the value of the uniform will immediately update the value available to the GLSL code.\n\nCan be used to force a uniform update while changing uniforms in [page:Object3D.onBeforeRender](). Default is `false`.\n\nDefines whether vertex coloring is used. Default is `false`.\n\nVertex shader GLSL code. This is the actual code for the shader. In the example above, the `vertexShader` and `fragmentShader` code is extracted from the DOM; it could be passed as a string directly or loaded via AJAX instead.\n\nRender geometry as wireframe (using GL_LINES instead of GL_TRIANGLES). Default is false (i.e. render as flat polygons).\n\nControls wireframe thickness. Default is `1`.\n\n\n\n Due to limitations of the [link:https://www.khronos.org/registry/OpenGL/specs/gl/glspec46.core.pdf OpenGL Core Profile] with the [page:WebGLRenderer WebGL] renderer on most platforms linewidth will always be `1` regardless of the set value.\n\nSee the base [page:Material] class for common methods.\n\nGenerates a shallow copy of this material. Note that the vertexShader and fragmentShader are copied `by reference`, as are the definitions of the `attributes`; this means that clones of the material will share the same compiled [page:WebGLProgram]. However, the `uniforms` are copied `by value`, which allows you to have different sets of uniforms for different copies of the material."
    },
    {
        "link": "https://threejs.org/docs",
        "document": ""
    },
    {
        "link": "https://github.com/FarazzShaikh/THREE-CustomShaderMaterial",
        "document": "These demos are real, you can click them! They contains full code, too. More demos here! üì¶\n\nCustom Shader Material (CSM) lets you extend Three.js' material library with your own Vertex and Fragment shaders. It Supports both Vanilla and React!\n\nCSM provides the following output variables, all of them are optional but you MUST use these variables like you would use standard GLSL output variables to see results.\n\nCSM infers prop types based on the prop. However, if this does not work for what ever reason, you can pass your base material type as a generic to .\n\nYou can define any custom overrides you'd like using the prop. The prop is used as shown below.\n\n: : : ... \"<KEYWORD>\": { // The keyword you will assign to in your custom shader \"TO_REPLACE\": // The chunk you'd like to replace. \"REPLACED_WITH\" // The chunk you'd like put in place of ` `\n\nCSM allows you to extend other CSM instances. Values set in the first shader will affect the next.\n‚Ä¢ MUST be a non-projected vector. i.e., no need to multiply or with it. If you require projection, use .\n‚Ä¢ Instancing must be handled manually when using by multiplying in into your projection math.\n‚Ä¢ When extending already extended material, variables, uniforms, attributes, varyings and functions are NOT scoped to the material they are defined in. Thus, you WILL get redefinition errors if you do not manually scope these identifiers.\n‚Ä¢ Extending of other materials that use may or may not work depending on if the default are mangled.\n‚Ä¢ When using an instance of CSM as the baseMaterial, or chining multiple CSM instances, or when extending any material that uses the injection order is as follows: Where A was the first in the chain.\n‚Ä¢ Cache key calculation takes into account base material's cache key. Useful for propagating changes across multiple chained CSM instances.\n‚Ä¢ If you find yourself lost in a patchMap, it's often simpler to just make a with the necessary .\n\nWith v6, CSM's initialization cost is now negligible ü•≥ Still, a couple important notes about performance:\n‚Ä¢ Changing these props will rebuild the material\n‚Ä¢ CSM uses ThreeJS's default shader program caching system. Materials with the same cache key, will use the the same shader program.\n‚Ä¢ and are the same, and will use the same cached shader program. The default cache key is such: You can provide your own cache key function via the prop."
    },
    {
        "link": "https://dustinpfister.github.io/2023/01/13/threejs-shader-material",
        "document": "The Shader material in threejs is one way to go about getting started with custom shaders in threejs, the other general option would be to look into the raw shader material. The main difference between the two has to do with built-in uniforms and attributes when it comes to the starting state of the GLSL ( openGL Shader Language ) code. For this reason it might be best to start out with the Shader material rather than the raw shader material as there are some built in values that I will not have to worry about setting up myself when it comes to the raw shader material. Yet again it is a bit of a toss up with that as if one wants to learn a thing or two about GLSL alone then the raw material might prove to be a better starting point actually.\n\nIn any case the Shader material is what I am starting with, and that will be the main topic of this post today. Using the shader material alone is simple enough, but what is not so simple is coming up with custom GLSL code to use with this material. However one has to start somewhere so this post will start out with some very simply hello world style examples. Before moving on into one or more real examples when it comes to the topic of custom shaders which can end up getting pretty involved.\n\nThe Shader Material in threejs and what to know first\n\nThis is a post on getting started with making custom GLSL shaders in threejs by way of the THREE.ShaderMaterial class as well as many other core threejs features. This is then not in any way a kind of getting started post with threejs, client side javaScript, and many other skills that are needed before hand. Also on top of the usual set of skills that are needed for doing just about anything with threejs there is one new additional skill that one is going to need to start to scratch the surface with at least. As I mentioned in the opening of this post GLSL is what is used to write the code for these custom shaders. I will then not be getting into great detail about everything that you should know before hand here. However I do as always use this first opening section to outline some things that you might want to read up more on before reading the rest of this post.\n\nStart to learn at least a thing or two about GLSL\n\nIf you want to write custom shaders you will want to learn at least a little GLSL, and getting into every little thing about that may be outside the scope of this post. There is however learning just enough GLSL to start effectively hacking over shaders that have all ready been written though and that is more or less what I am doing in this post.\n\nStill there is the question of what is the Modzilla Developer Network equivalent site for GLSL? That is indeed a good question and thus far I can not say that I have found that. What I have found however is the khronos group pages that have provedn to be somewhat helpful. Much of what I have learned about GLSL though has been mainly just looking at the code that is used in the core of threejs itself as an example of core features of this language by looking at the source code files that compose the THREE.ShaderChunk library as well as just working with this Object in the process of creating a custom shader. Working closely with this object just strikes me as what the THREE.ShaderMaterial is all about anway.\n\nThere is learning a thing or two about the built in materials first of course\n\nIf you are still new to threejs, and also even if you do have a fair amount of experience there is still just sticking with the built in materials and moving on with life. Many of the material options will work just fine for just about all typical use case examples with threejs. It is just that there might be a few situations that call for writing a custom shader though as doing so with with built in materials will have to involve some kind of very complex trickery using canvas textures, so complex that it might be better to ditch that idea and just write a little GLSL code.\n\nBe aware of features that have to do with buffer geometry\n\nThere is a lot to be aware of when it comes to the state of buffer geometry as well of course. Once again this is very much an advanced post on threejs so I assume you know what a position attribute is, as well as many other such attributes both standard, and not so standard. There is not just getting into making custom shaders, but also custom attributes of geometry as well after all. In some cases I might want to create shaders that will make use of a color attribute, or one or more custom attributes that should be parked in the geometry.\n\nSource code examples are also on Github\n\nI also have the source code examples that I am writing about here up on my Github. This is also where I park the source code examples for the many other blog posts that I have wrote on threejs over the years as well.\n\nWhen I was first writing this post I was using r146 of threejs and thus I have followed the style rules I have set with that revision when making these. Threejs is still to this day a very fast moving project, and depending on how wide of a range of devices you want to target the latest is not always the greatest just yet. As of this writing there are a whole lot of code breaking changes up ahead. In any case when it comes to working out issues with code examples on the open web always be mindful of what version is being used on both ends.\n\n1 - Basic, hello world exmaples of THREE.ShaderMaterial in threejs\n\nThere is a lot to take in when it comes to even just simply getting started with the THREE.ShaderMaterial. However this is to be expected as this is without question one of the most, if not the most advanced topics there is when it comes to threejs. I have been working with threejs on and off for years and even I still find this to be a little intense for me, however I started taking a swing or two at it now and then because there is not much that remains when it comes to more ground to cover with threejs for me.\n\nAnyway not just for your sake, but very much for my own sake as well, this will be a collection of very basic, getting started type examples of custom shaders in threejs by way of THREE.ShaderMaterial. This might prove to be an easier alternative to that of the THREE.RawShaderMaterial but that will only help so much of course. Still I have found that if I just want to reproduce the functionally of the THREE.MeshBasicMatreial with just the color option, that is not so hard of a starting point. With that said these examples will just be focusing one various ways to go about doing that which will just result in a solid blob of color for the object rendered in the scene. Everything else should be something that I get to in more advanced sections.\n\n1.1 - Custom Shader hello world with gl_Position and gl_FragColor\n\nTo create an instance of the Shader material I will need to pass an object that contains three properties, unifroms, vertexShader, and fragmentShader. The uniforms property contains a set of values that will be the same for all vertices, for this getting started example I am dealing with just one uniform value that is a diffuse color. Each value of the uniforms object should itself be an object and the value property of this nested object is how to go about setting a value for the uniform value. The vertexShader and fragmentShader properties should both contain string values, and each string value should contain GLSL code for the vertex and fragment shaders that will provide the custom rendering logic.\n\nThe vertex shader runs first and the main job of this shader is to set the value of gl_Position. After the vertex shader there is the fragment shader there is the fragment shader which is what is used to set what the color should be for each pixel location. The main job of this fragment shader then is to set what the color should be for the gl_FragColor value.\n\nSo then the end result of this custom shader is that I have just a solid blob of color in the location of the mesh object that contains a Torus geometry. This is then just a very complex way to go about getting the same effect as just using the basic material and setting the color option to what I want for the solid diffuse color value. However there is of course expanding on this to do somersetting else that can not be done with the basic material, or any other material for that matter. It is just that this seems like a good starting point for me when it comes to getting into doing this sort of thing. However before getting into more advanced examples of this kind of custom material I will want to cover at least a few more options when it comes to just a basic getting started type point for this sort of thing.\n\nAlthough a big part of getting into this sort of thing is to write at least a little custom GLSL code, there are a lot of tools built into the core of threejs to help speed things along when using the THREE.ShaderMaterial class. One feature of threejs that I think I should cover right away that I have found is the THREE.ShaderChunk object. In this shader chunk object there is a meshbasic_vert, and meshbasic_frag properties that as you might guess contains GLSL code for the vertex shader, and fragment shader of the mesh basic material. So then another way to create a Shader material hello world would be to just use those values for the shaders.\n\nThat makes things for more concise, but it also totally defeats the purpose of bothering with the shader material because I could just use the basic material. Again the goal here is to just be aware fo what there is to work with to just get started with this sort of thing, and the THREE.ShaderChunk is just one thing to be aware of. Also in some cases I might want to start with functionality that is not all to different from that of the basic material, phong material, normal material and so forth. It is just that typically I will not want to do something like this, but rather start with the actual code rather than a reference to it as a start point.\n\nSo then in the last basic example I made use of the THREE.ShaderChunk object to create a material that is more or less about the same as the basic material. However I did so by just simply referencing the GLSL code. In this example I am doing the same thing, but now I am passing the GLSL code into the actually code of the example, rather than just referencing what is there. There is more than one way to do this however when it comes to the shader material #include can be used to import segements of GLSL code from the shader chunk library. This way if I just want to include the GLSL code that is baked into the core of threejs for somehting I can just go ahead and do so.\n\nNotice all the include statements that begin with a hashtag, followed by a name for what is some additional GLSL code? This is a way to include one or more parts of the THREE.ShaderChunk object in the GLSL code. So say that I quickly just want to add alpha map functionally to a material of mine. I could go threw the time consuming process of trying how to go about writing something like that from the ground up with GLSL code, but why other with that when I can just include what is baked into threejs to begin with?\n\nThis is still just a very complex way of just reproducing the functionally of the basic material, but the goal here was not to make a custom material to begin with, but rather to just get started with this. With these three examples I am not somewhat ready to start to move on to some real examples in which I am just hacking over and expanding from one of these kinds of start points.\n\n2 - Using Vertex Colors and a Base color to set frac color\n\nIn the basic section of this post I wrote a whole bunch of examples that do more or less the same thing, but in some very different ways. They all had to do with just simply drawing a single color for each pixel that is the same end result of just using the Mesh basic material with the color option. That‚Äôs okay considering that the goal in that section was to just get started, but not create some kind of final product.\n\nHowever in this section though the goal is to create an actual final result by making use of core threejs GLSL code to work with to create the same starting set of features there are to work with in the mesh basic material. Then hack over things a bit from there to create a material the will render a geometry by way of a ratio between a single solid base color, and whatever is going in in terms of any color attribute in the geometry that is used for what is called vertex coloring. For those of you not in the know with this one, vertex coloring is a way to define a color for each vertex in the position attribute of a buffer geometry. It is a nice quick way to have something other than a solid blob of color, that does not require light sources, or textures, but does require a color attribute in the geometry.\n\nThe first thing that I did when making this example is create a geometry using one of the built in geometry constructor functions. Then I would just get a reference to the position attribute of the geometry, and use the count value to know how many items I need for the color attribute that I will create for the geometry. For that I just worked out some quick code to create the color attribute by making an array and pushing values for the red, green, and blue color channels for each vertex. I then confirmed that everything is working okay by making use of the basic material with the vertexColors Boolean set to true. So now the next step is to just get the same result with the shader material by just using the same GLSL code as the basic material, but just commenting out everything that does not have to do with the features that I want.\n\nI really like the process of creating an array of strings for each line of GLSL code as this allows me to comment out lines of code one by one to get a quick idea of what I want to keep, and what might be unneeded bloat for what I want to do. Starting with the example in the basic section that has all the include statements I start to do just that until I have just the core features along that I want working. After that I started to go threw each of those include statements and just took a look at what the GLSL code is for each of them in the THREE.ShaderChunk object. Then I just replaced the includes with the actually GLSL lines, but with one exception which is the common lib.\n\nAfter a while I found what lines are used to add the vertex coloring feature, along with other core features that have to do with just the plain old diffuse color feature, and opacity. So then I ended up with just a few lines as I commented out, and removed lines that have to do with all kinds of features like alpha maps and so forth. Turns out that the mesh basic material is not so basic as there is a whole to to work with still. Anyway once I had just the features that I wanted from the basic feature I found ways to further reduce the complexity even more with this as all I want to do with this example at least is to color each fragment by way of a ratio between vertex coloring and a single uniform base color.\n\nThe end result is then just what I wanted for this example at least. I can set a base color, and a ratio in the form of a THREE.Vector2 object, to set the ratio between the base color and what is going on with vertex coloring as a way to render the geometry.\n\nOne of the first real examples of a custom shader material that I have made thus far is actually a hacked over version of one that I found on line. That is that I just did some quick google work to find a shader that does more or less what I wanted and found something that was close at least. I then hacked over it a lot, removing code that I did not want or need for the simple black and white look that I wanted and ended up with this.\n\nThe code that is was based on was made for a very old revision of threejs ( r57 ), so many of the changes had to do with having to just do things the way that they are done now. I also did not make use of additional shaders that where used in the example, and made a few more changes that allowed for things like thicker lines. Thus far this material works more or less the way that I would like it to, but I still would like to add at least a few more features to this such as transparency.\n\nThat will be it for now at least when it comes to custom shaders in threejs, not because there is not anything more to write about, but indeed very much the opposite. I have a lot more to look into when it comes to this sort of thing myself as there is a great deal more to learn about when it comes to working with the THREE.ShaderChunk library, as well as GLSL itself.\n\nThis was a kind of just getting started type post though, so maybe there is still only so much more to write about in terms of future edits of this post at least. However I am going to want to write additional blog posts on more examples for custom shaders, the shader chunk object, GLSL, and much more. There is just no way to do justice with this in the form of a single blog post, unless it is a real serious long form content piece that just goes on war and peace style maybe."
    },
    {
        "link": "https://stackoverflow.com/questions/55053946/three-js-custom-shader-not-displaying",
        "document": "I'm afraid your codepen is full of mistakes. It seems you are trying to port a shader from shadertoy to , right?\n\nI have removed all errors here but the effect still looks broken: https://codepen.io/anon/pen/XGRVew\n\nAnyway, here are a few things to keep in mind:\n‚Ä¢ You have to assign the textures to the uniforms after you have created the shader pass. Uniforms are cloned for the internal material of . That means textures are cloned, too. The respective flag is not set correctly if you load the texture before the material creation.\n‚Ä¢ As mentioned by @Marquizzo, your texture are blocked for security reasons. I've added some textures from the repo for test purposes.\n‚Ä¢ None The following line of code is not necessary since uv coordinates are provided with the geometry. It's not necessary to compute them on-the-fly like shadertoy does. Just use the varying in the fragment shader.\n‚Ä¢ None For such simple one-pass shaders, it's not necessary to use . Try to use an approach similar to this official example.\n‚Ä¢ You always have to ensure that the example files like or match the version in your code. I've changed this in the codepen in order to remove all deprecation warnings."
    }
]