[
    {
        "link": "https://geeksforgeeks.org/implementing-stack-using-class-templates-in-cpp",
        "document": "The task is to implement some important functions of stack like pop(), push(), display(), topElement(), isEmpty(), isFull() using class template in C++. Stack is a linear data structure that follows a particular order in which the operations are performed. The order may be LIFO(Last In First Out) or FILO(First In Last Out).\n\nThe simple idea is to pass data type as a parameter so that we don’t need to write the same code for different data types. For example, a software company may need sort() for different data types. Rather than writing and maintaining the multiple codes, we can write one sort() and pass data type as a parameter.\n\nC++ adds two new keywords to support templates: ‘template’ and ‘typename’. The second keyword can always be replaced by the keyword ‘class’.\n\nConsider an example of plates stacked over one another in the canteen. The plate which is at the top is the first one to be removed, i.e. the plate which has been placed at the bottommost position remains in the stack for the longest period of time. So, it can be simply seen to follow LIFO(Last In First Out)/FILO(First In Last Out) order.\n\nHere two data types (integer and string) are implemented using a single stack class. First, two objects are taken one is for integer class and the second is for the string class, Elements are inserted in both the classes using push() and isFull() method of stack class. Elements are removed using pop and isEmpty() functions of stack class. Finally, the top element is printed for each class using the top element() function."
    },
    {
        "link": "https://softwareengineering.stackexchange.com/questions/373916/c-preferred-method-of-dealing-with-implementation-for-large-templates",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "http://users.cis.fiu.edu/~weiss/Deltoid/vcstl/templates",
        "document": "Many C++ programs use common data structures like stacks, queues and lists. A program may require a queue of customers and a queue of messages. One could easily implement a queue of customers, then take the existing code and implement a queue of messages. The program grows, and now there is a need for a queue of orders. So just take the queue of messages and convert that to a queue of orders (Copy, paste, find, replace????). Need to make some changes to the queue implementation? Not a very easy task, since the code has been duplicated in many places. Re-inventing source code is not an intelligent approach in an object oriented environment which encourages re-usability. It seems to make more sense to implement a queue that can contain any arbitrary type rather than duplicating code. How does one do that? The answer is to use type parameterization, more commonly referred to as templates.\n\nC++ templates allow one to implement a generic Queue<T> template that has a type parameter T. T can be replaced with actual types, for example, Queue<Customers>, and C++ will generate the class Queue<Customers>. Changing the implementation of the Queue becomes relatively simple. Once the changes are implemented in the template Queue<T>, they are immediately reflected in the classes Queue<Customers>, Queue<Messages>, and Queue<Orders>.\n\nTemplates are very useful when implementing generic constructs like vectors, stacks, lists, queues which can be used with any arbitrary type. C++ templates provide a way to re-use source code as opposed to inheritance and composition which provide a way to re-use object code.\n\nC++ provides two kinds of templates: class templates and function templates. Use function templates to write generic functions that can be used with arbitrary types. For example, one can write searching and sorting routines which can be used with any arbitrary type. The Standard Template Library generic algorithms have been implemented as function templates, and the containers have been implemented as class templates.\n\nA class template definition looks like a regular class definition, except it is prefixed by the keyword template. For example, here is the definition of a class template for a Stack.\n\nT is a type parameter and it can be any type. For example, Stack<Token>, where Token is a user defined class. T does not have to be a class type as implied by the keyword class. For example, Stack<int> and Stack<Message*> are valid instantiations, even though int and Message* are not \"classes\".\n\nImplementing template member functions is somewhat different compared to the regular class member functions. The declarations and definitions of the class template member functions should all be in the same header file. The declarations and definitions need to be in the same header file. Consider the following. \n\n\n\n\n\nWhen compiling B.cpp, the compiler has both the declarations and the definitions available. At this point the compiler does not need to generate any definitions for template classes, since there are no instantiations. When the compiler compiles main.cpp, there are two instantiations: template class B<int> and B<float>. At this point the compiler has the declarations but no definitions!\n\nWhile implementing class template member functions, the definitions are prefixed by the keyword template. Here is the complete implementation of class template Stack:\n\nUsing a class template is easy. Create the required classes by plugging in the actual type for the type parameters. This process is commonly known as \"Instantiating a class\". Here is a sample driver class that uses the Stack class template.\n\nIn the above example we defined a class template Stack. In the driver program we instantiated a Stack of float (FloatStack) and a Stack of int(IntStack). Once the template classes are instantiated you can instantiate objects of that type (for example, fs and is.)\n\nA good programming practice is using typedef while instantiating template classes. Then throughout the program, one can use the typedef name. There are two advantages:\n• typedef's are very useful when \"templates of templates\" come into usage. For example, when instantiating an STL vector of int's, you could use:\n• If the template definition changes, simply change the typedef definition. For example, currently the definition of template class vector requires a second parameter. In a future version, the second parameter may not be required, for example,\n\nImagine how many changes would be required if there was no typedef!\n\nTo perform identical operations for each type of data compactly and conveniently, use function templates. You can write a single function template definition. Based on the argument types provided in calls to the function, the compiler automatically instantiates separate object code functions to handle each type of call appropriately. The STL algorithms are implemented as function templates.\n\nFunction templates are implemented like regular functions, except they are prefixed with the keyword template. Here is a sample with a function template.\n\nUsing function templates is very easy: just use them like regular functions. When the compiler sees an instantiation of the function template, for example: the call max(10, 15) in function main, the compiler generates a function max(int, int). Similarly the compiler generates definitions for max(char, char) and max(float, float) in this case.\n\nWhen the compiler generates a class, function or static data members from a template, it is referred to as template instantiation.\n\nThe compiler generates a class, function or static data members from a template when it sees an implicit instantiation or an explicit instantiation of the template.\n• Consider the following sample. This is an example of implicit instantiation of a class template.\n• Consider the following sample. This sample uses the template class members Z<T>::f() and Z<T>::g(). This time in addition to the generating classes Z<int> and Z<float>, with constructors and destructors, the compiler also generates definitions for Z<int>::f() and Z<float>::g(). The compiler does not generate definitions for functions, nonvirtual member functions, class or member class that does not require instantiation. In this example, the compiler did not generate any definitions for Z<int>::g() and Z<float>::f(), since they were not required.\n• Consider the following sample. This is an example of explicit instantiation of a class template.\n• Consider the following sample. Will the compiler generate any classes in this case? The answer is NO. template <class T> class Z { public: Z() {} ; ~Z() {} ; void f(){} ; void g(){} ; } ; int main() { Z<int>* p_zi ; //instantiation of class Z<int> not required Z<float>* p_zf ; //instantiation of class Z<float> not required return 0 ; } This time the compiler does not generate any definitions! There is no need for any definitions. It is similar to declaring a pointer to an undefined class or struct.\n• Consider the following sample. This is an example of implicit instantiation of a function template. //max returns the maximum of the two elements template <class T> T max(T a, T b) { return a > b ? a : b ; } void main() { int I ; I = max(10, 15) ; //implicit instantiation of max(int, int) char c ; c = max('k', 's') ; //implicit instantiation of max(char, char) } In this case the compiler generates functions max(int, int) and max(char, char). The compiler generates definitions using the template function max.\n• Consider the following sample. This is an example of explicit instantiation of a function template. NOTE: Visual C++ 5.0 does not support this syntax currently. The above sample causes compiler error C1001. In this case the compiler would generate function Test(int). The compiler generates the definition using the template function Test.\n• If an instantiation of a class template is required, and the template declared but not defined, the program is ill-formed. VC5.0 compiler generates error C2079.\n• Instantiating virtual member functions of a class template that does not require instantiation is implementation defined. For example, in the following sample, virtual function X<T>::Test() is not required, VC5.0 generates a definition for X<T>::Test. In this case the compiler generates a definition for X<int>::Test, even if it is not required.\n\nIn some cases it is possible to override the template-generated code by providing special definitions for specific types. This is called template specialization. The following example defines a template class specialization for template class stream.\n\nIn the above example, stream<char> is used as the definition of streams of chars; other streams will be handled by the template class generated from the class template.\n\nYou may want to generate a specialization of the class for just one parameter, for example\n\nA partial specialization matches a given actual template argument list if the template arguments of the partial specialization can be deduced from the actual template argument list.\n\nNOTE: Visual C++ 5.0 does not support template class partial specialization. The above sample causes compiler error C2989: template class has already been defined as a non-template class.\n\nIn some cases it is possible to override the template-generated code by providing special definitions for specific types. This is called template specialization. The following example demonstrates a situation where overriding the template generated code would be necessary:\n\nNot quite the expected results! Why did that happen? The function call max(\"Aladdin\", \"Jasmine\") causes the compiler to generate code for max(char*, char*), which compares the addresses of the strings! To correct special cases like these or to provide more efficient implementations for certain types, one can use template specializations. The above example can be rewritten with specialization as follows:\n• C++ templates allow one to implement a generic Queue<T> template that has a type parameter T. T can be replaced with actual types, for example, Queue<Customers>, and C++ will generate the class Queue<Customers>. For example, Here T is a template parameter, also referred to as type-parameter.\n• C++ allows you to specify a default template parameter, so the definition could now look like: Then a declaration such as would instantiate (at compile time) a 100 element Stack template class named mostRecentSalesFigures of float values; this template class would be of type Stack<float, 100>. Note, C++ also allows non-type template parameters. In this case, template class Stack has an int as a non-type parameter. If you specify a default template parameter for any formal parameter, the rules are the same as for functions and default parameters. Once a default parameter is declared all subsequent parameters must have defaults.\n• Default arguments cannot be specified in a declaration or a definition of a specialization. For example, template <class T, int size> class Stack { } ; //error C2989: 'Stack<int,10>' : template class has already been //defined as a non-template class template <class T, int size = 10> class Stack<int, 10> { } ; int main() { Stack<float,10> si ; return 0 ; }\n• A type-parameter defines its identifier to be a type-name in the scope of the template declaration, and canot be re-declared within its scope (including nested scopes). For example, NOTE: VC++ 5.0 or SP1 compiles this sample without any errors. It does not flag the re-definition of type-parameter as an error.\n• The value of a non-type-parameter cannot be assigned to or have its value changed. For example, template <class T, int size> class Stack { void f() { //error C2105: '++' needs l-value size++ ; //error change of template argument value } } ; int main() { Stack<double,10> si ; return 0 ; }\n• A template-parameter that could be interpreted as either a parameter-declaration or a type-parameter, is taken as a type-parameter. For example, class T {} ; int i ; template <class T, T i> void f(T t) { T t1 = i ; //template arguments T and i ::T t2 = ::i ; //globals T and i } int main() { f('s') ; //C2783 here return 0 ; } NOTE: Compiling the above sample using VC++ 5.0 and SP1 causes compiler error C2783: could not deduce template argument for 'i'. To workaround the problem, replace the call to f('s') with f<char, 's'>('s').\n• A non-type template parameter cannot be of floating type. For example, template <double d> class X ; //error C2079: 'xd' uses //undefined class 'X<1.e66>' //template <double* pd> class X ; //ok //template <double& rd> class X ; //ok int main() { X<1.0> xd ; return 0 ; }\n• Each template class or function generated from a template has its own copies of any static variables or members.\n• Each instantiation of a function template has it's own copy of any static variables defined within the scope of the function. For example, Here X<int> has a static data member s of type int and X<char*> has a static data member s of type char*.\n• Static members are defined as follows.\n• Each instantiation of a function template has it's own copy of the static variable. For example, Here f<int>(int) has a static variable s of type int, and f<char*>(char*) has a static variable s of type char*.\n\nFriendship can be established between a class template and a global function, a member function of another class (possibly a template class), or even an entire class (possible template class). The table below lists the results of declaring different kinds of friends of a class."
    },
    {
        "link": "https://stackoverflow.com/questions/13359217/how-to-document-c-templates-and-template-metafunctions-with-doxygen",
        "document": "Are there any guidelines on how C++ templates and template meta-functions should be documented with Doxygen?\n\nSo far I have seen the following suggestions:\n• used to describe the metafunction.\n\nHow should the 'returned type' for the metafunction be documented?\n\nDoes anyone have any good suggestions or personal preferences for using Doxygen with C++ templates?"
    },
    {
        "link": "https://stackoverflow.com/questions/61949674/implement-template-class-stack",
        "document": "You should include the header, and c++ is a case sensitive programming language, so, it's important to declare your data types (Abstract for this one) according to stantards, and specify the std namespace."
    },
    {
        "link": "https://geeksforgeeks.org/basic-input-output-c",
        "document": "In C++, input and output are performed in the form of a sequence of bytes or more commonly known as streams.\n• Input Stream: If the direction of flow of bytes is from the device (for example, Keyboard) to the main memory then this process is called input.\n• Output Stream: If the direction of flow of bytes is opposite, i.e. from main memory to device (display screen) then this process is called output.\n\nAll of these streams are defined inside the <iostream> header file which contains all the standard input and output tools of C++. The two instances cout and cin of iostream class are used very often for printing outputs and taking inputs respectively. These two are the most basic methods of taking input and printing output in C++.\n\nThe C++ cout is the instance of the ostream class used to produce output on the standard output device which is usually the display screen. The data needed to be displayed on the screen is inserted in the standard output stream (cout) using the insertion operator(<<).\n\nFor example, if we want to print text “GeeksforGeeks” on the display, we can use the cout as shown:\n\nExplanation: In the above program, cout is used to output the text “GeeksforGeeks” to the standard output stream. It works in conjunction with the insertion operator (<<) to send the specified data to the output stream.\n\nWe can also print the variable values using cout.\n\nUnderstanding input and output operations is essential for any C++ programmer. The C++ Course includes comprehensive lessons on basic I/O operations, ensuring you can manage user interaction in your programs.\n\nThe C++ cin statement is the instance of the class istream and is used to read input from the standard input device which is usually a keyboard. The extraction operator (>>) is used along with the object cin for extracting the data from the input stream and store it in some variable in the program.\n\nFor example, if we want to ask user for his/her age, then we can use cin as shown:\n\nExplanation: The above program asks the user to input the age. The object cin is connected to the input device (keyboard). The age entered by the user is extracted from cin using the extraction operator(>>) and the extracted data is then stored in the variable age present on the right side of the extraction operator.\n\nAlso, while taking text as input using cin, we need to remember that cin stops reading input as soon as it encounters a whitespace (space, tab, or newline). This means it only captures the first word or characters until the first whitespace. It is shown in the below example:\n\nThe C++ cerr is the standard error stream that is used to output the errors. This is also an instance of the iostream class. As cerr in C++ is un-buffered so it is used when one needs to display the error message immediately. It does not have any buffer to store the error message and display it later.\n\nThe main difference between cerr and cout comes when you would like to redirect output using “cout” that gets redirected to file if you use “cerr” the error doesn’t get stored in file.(This is what un-buffered means ..It cant store the message)\n\nThis is also an instance of ostream class and used to display errors but unlike cerr the error is first inserted into a buffer and is stored in the buffer until it is not fully filled. or the buffer is not explicitly flushed (using flush()). The error message will be displayed on the screen too."
    },
    {
        "link": "https://cplusplus.com/doc/tutorial/basic_io",
        "document": "std; main () { i; cout << \"Please enter an integer value: \" ; cin >> i; cout << \"The value you entered is \" << i; cout << \" and its double is \" << i*2 << ; 0; }\n\nPlease enter an integer value: 702 The value you entered is 702 and its double is 1404."
    },
    {
        "link": "https://icarus.cs.weber.edu/~dab/cs1410/textbook/1.Basics/io.html",
        "document": "Few programs are useful without the ability to input the data upon which they operate and output those operations' results. Modern computers support input and output through an interactive graphical user interface (GUI). However, older systems were strictly text-based (CLI). For simplicity, we begin our discussion with the text-based I/O system called the console.\n\nThe most basic C++ input and output (I/O) operations are to and from the console. The first console was a teletype machine, which was originally developed for and used to send messages similar to today's e-mail. The Cathode ray tube (CRT) eventually replaced the teletype as a computer's primary output device. Initially, CRTs could display text but not windows or, until much later, graphics.\n\nAlthough the console is not as appealing or intuitive as a GUI, the console remains an important user interface (UI). On modern systems, the console takes one of two forms. The first form is just as it appeared in the pre-GUI days. We often see this console version before the operating system starts the GUI. This version is also the only interface available on some server operating systems (Ubuntu Server, e.g.) that omit the GUI to avoid its overhead. Windows users' systems will see this console if they pres early in the boot process or if the system encounters a problem while shutting down. We'll see the second form when running C++ programs from an IDE. Some IDEs automatically open a text-based window when running a program; other IDEs provide the same text-based I/O operations in a panel displayed in the IDE window itself. Users can also open a console window directly by running one of many console programs: command prompt, power shell, bash (Bourne again shell), etc. This section introduces several C++ features that support console I/O and related concepts.\n\nThe C++ library contains several stream objects through which it can perform console I/O operations. The I/O objects represent data as streams or sequences of bytes (i.e., characters) as they enter or leave the running program. The following figure illustrates the three most common stream objects: , , and . The \"c\" appearing in the name of each object stands for \"console.\" All console objects send data to and receive data from the console. A modern console consists of the keyboard and the screen or the console window when running a GUI. As depicted in the illustration below, input comes from the keyboard through , and \"normal\" output is sent to the screen through . Programs often send error messages or diagnostics to the screen through . C++ uses two output streams so that the user can separate them with console operators and send the two streams to different destinations when desired.\n\nis an instance of a class named , while and are instances of of a class named . C++ saves the three stream objects in a library, and the linker/loader extracts them and incorporates them in programs as needed. Whenever our program needs to use a library feature, the program must describe it, or, more formally, declare it. We typically supply this information by #including a header file at the top of the C++ source code file.\n\n, , and are stream objects, supporting numerous functions. Programs access many of those functions with the dot operator just like the methods in a Java program. However, other functions have a rather unusual syntax that is quite different from Java's. These special functions take one of two forms: operators or manipulators.\n\nC++ has another feature that has no analog in Java: overloaded operators. Operators are, as we will see in greater detail later, just functions, but they are functions that support a novel calling syntax. Most of our initial experience with operators center on the (inserter or output) operator and the (extractor or input) operator. These two operators work in conjunction with , , and to write data out from or read data into a program:\n\nThe example above also uses a manipulator. Manipulators are also special functions designed to work with either the (inserter) or the (extractor) operator. The manipulator (the last character is a lower-case 'L') inserts an end-of-line and flushes the output buffer (i.e., it forces the output stream to send the buffer's contents to the console even if the buffer isn't full). The end-of-line causes the cursor (a symbol indicating where the console will display the next character) to drop down one line and return to the left side of the screen (i.e., console window). The following example demonstrates the manipulator:\n\nSometimes, when writing programs, especially when sending output to the screen, programmers often need to reference characters without a clear, visible representation or characters with special meaning within a program. Both C++ and Java use a special sequence of characters, called an escape sequence, to denote these characters and distinguish them from other programming elements. Each of the escape sequences in the following table begins with , which is called the escape character. Note that different devices may respond differently to a specific escape sequence."
    },
    {
        "link": "https://caiorss.github.io/C-Cpp-Notes/STL_Input_and_output.html",
        "document": "Print a string without any formatting - header: <cstdio> for C++ and <stdio.h> for C.\n• puts - print a line to stdout followed by new line character. The following functions are available in the header <cstdio> for C++, and in the header <stdio.h> for C.\n• snprintf - print to buffer with bound checking - size is the maximum number of characters that can be print to the buffer. null-terminated array of characters (C \"strings\" for short). print the numeric value of any pointer in hexadecimal format. Print using scientific notation only when needed (lower case 'e') Print using scientific notation only when needed (upper case 'E') WARNING: Despite the simplicity, printf is not type-safe and has some potential vulnerabilities: Print float point in standard notation with any precision: Print in scientific notation with any precision: Print with scientific only when needed (for large numbers). Print with scientific only when needed with 4 digits precision: ==>>> C++11 Table printing (First column right aligned) tristor 10.23 voltage regulator 5 volts 1.25 voltage regulator 12V 9.50 IMU sensor 108.23 Pressure transducer 205.90 ==>>> C++17 Table printing (First column left aligned) tristor 10.23 voltage regulator 5 volts 1.25 voltage regulator 12V 9.50 IMU sensor 108.23 Pressure transducer 205.90\n• Stateful\n• The IO classes have internal states such as precision that float point will be printed; base which numbers will be print such as octal (base 8), hexadecimal (base 16) and decimal (default).\n• Without exceptions\n• The C++ IO does not have exceptions, it indicates error through error flags that must be checked by the calling code.\n• iostream - input/output stream base class\n• sstringstream => String stream that can be used for reading and writing. The C++ IO streams are stateful, they have internal states for IO configuration such as IO flags and numerical precision. In the following code, the IO manipulator std::boolalpha enables the IO flag std::ios_base::boolalpha that makes the IO stream print booleans as string instead of '0' or '1'. The flag can be disabled with the IO manipulator std::noboolalpha.\n\nEvery process, has the following standard streams:\n• stderr - Standard error output (file descriptor 2) => encapsulated by global object std::cerr (derived class of std::ostream)\n• Diagnostics, error and logging should use std::cerr as this approach allows separating logging and diagnostics from program output and redirecting or discarding them.\n• Note: Stream redirection is also possible on Windows. Althoug, it is not so usual as in Unix-like operating system due to low usage of terminal application in Windows.\n• Note: A Windows application compiled for GUI subsystem will not display any output stream even if it is run from the terminal.\n• File: stream-redirect.cpp\n• Sample program that solves the equation f(x) = x^3 - a = 0 using newton raphson method.\n• Print all results - the standard streams stdcout (std::cout) and stderr are redirected to console by default. $ ./stream-redirection.bin 125.0 [INFO] Solving equation f(x) = x^3 - a ; for a = 125.0000 Iter x AbsErr RelErr% 0 62.5040 62.4960 99.9872 1 31.2680 31.2360 99.8977 2 15.6979 15.5701 99.1855 3 8.1026 7.5953 93.7396 4 5.0033 3.0993 61.9454 5 4.9984 0.0049 0.0985 6 5.0008 0.0025 0.0492 7 4.9996 0.0012 0.0246 8 5.0002 0.0006 0.0123 9 4.9999 0.0003 0.0062 10 5.0001 0.0002 0.0031 11 5.0000 0.0001 0.0015 12 5.0000 0.0000 0.0008 13 5.0000 0.0000 0.0004 14 5.0000 0.0000 0.0002 15 5.0000 0.0000 0.0001 Cubic root of a = 125 ; is approximately 5 number of iteratios is 16\n• Discard stderr standard error stream by redirecting it to /dev/null. Note: valid for Unix-like OSes (Linux, BSD, OSX, QNX …): $ ./stream-redirect.bin 125.0 2> /dev/null Cubic root of a = 125 ; is approximately 5 number of iteratios is 16\n• Discard stdout - standard output by redirecting it to /dev/null (Unix-like OSes)\n• Discard both stdout and stderr by redirecting them to /dev/null\n• Redirect stdout - standard output stream to a file.\n• Only the stderr is printed, the stdout is redirected to the text file stdout.log $ ./stream-redirect.bin 125.0 > stdout.log [INFO] Solving equation f(x) = x^3 - a ; a = 125.0000 Iter x AbsErr RelErr% 0 62.5040 62.4960 99.9872 1 31.2680 31.2360 99.8977 2 15.6979 15.5701 99.1855 3 8.1026 7.5953 93.7396 4 5.0033 3.0993 61.9454 5 4.9984 0.0049 0.0985 6 5.0008 0.0025 0.0492 7 4.9996 0.0012 0.0246 8 5.0002 0.0006 0.0123 9 4.9999 0.0003 0.0062 10 5.0001 0.0002 0.0031 11 5.0000 0.0001 0.0015 12 5.0000 0.0000 0.0008 13 5.0000 0.0000 0.0004 14 5.0000 0.0000 0.0002 15 5.0000 0.0000 0.0001 $ cat stdout.log Cubic root of a = 125 ; is approximately 5 number of iteratios is 16\n• Redirect stderr (std::cerr) - standard error stream to file.\n• Only the stdout is printed and the stderr is redirect to the text file stderr.log $ ./stream-redirect.bin 125.0 2> stderr.log Cubic root of a = 125 ; is approximately 5 number of iteratios is 16 $ head -n 5 stderr.log [INFO] Solving equation f(x) = x^3 - a ; a = 125.0000 Iter x AbsErr RelErr% 0 62.5040 62.4960 99.9872 1 31.2680 31.2360 99.8977 $ tail -n 5 stderr.log 11 5.0000 0.0001 0.0015 12 5.0000 0.0000 0.0008 13 5.0000 0.0000 0.0004 14 5.0000 0.0000 0.0002 15 5.0000 0.0000 0.0001\n• Redirect both streams to different files: stdcout (std::cout) and stderr (std:cerr)\n• The stdout (std::cout) is redirected to the file stdout.txt and the stderr (std::cerr) is redirected to the file stderr.txt $ ./stream-redirect.bin 125.0 > stdout.txt 2> stderr.txt $ cat stdout.txt Cubic root of a = 125 ; is approximately 5 number of iteratios is 16 $ tail -n 5 stderr.txt 11 5.0000 0.0001 0.0015 12 5.0000 0.0000 0.0008 13 5.0000 0.0000 0.0004 14 5.0000 0.0000 0.0002 15 5.0000 0.0000 0.0001\n• Redirect both streams to the same log file. $ ./stream-redirect.bin 125.0 > log.txt 2>&1 $ cat log.txt [INFO] Solving equation f(x) = x^3 - a ; for a = 125.0000 Iter x AbsErr RelErr% 0 62.5040 62.4960 99.9872 1 31.2680 31.2360 99.8977 2 15.6979 15.5701 99.1855 3 8.1026 7.5953 93.7396 4 5.0033 3.0993 61.9454 5 4.9984 0.0049 0.0985 6 5.0008 0.0025 0.0492 7 4.9996 0.0012 0.0246 8 5.0002 0.0006 0.0123 9 4.9999 0.0003 0.0062 10 5.0001 0.0002 0.0031 11 5.0000 0.0001 0.0015 12 5.0000 0.0000 0.0008 13 5.0000 0.0000 0.0004 14 5.0000 0.0000 0.0002 15 5.0000 0.0000 0.0001 Cubic root of a = 125 ; is approximately 5 number of iteratios is 16 >>> (r.stdout) < > >>> r.stdout b ' Cubic root of a = 125 ; is approximately 5 number of iteratios is 16\n\n' >>> >>> (r.stdout.decode( )) Cubic root of = 125 ; approximately 5 number of iteratios 16 $ ./input-redirection.bin --help Count line numbers of some file. Usage: $ ./input-redirection.bin < file.txt $ cat file.txt | ./input-redirection.bin Count number of line in input stream stdin (std::cin) typed by user:\n• Note: When the user is done, he types CTRL + D to send EOF (End Of File) character to process. $ ./input-redirection.bin [INFO] showLine = false DXY index VIX implied volatility VAR VALUE AT RISK standard deviation commodity prices monte carlo simulations stochastic volatility Finaly user types CTRL + D when he is done to send EOF signal character to process. File has 7 lines Redirect output stream (stdout) of echo program to input stream (stdin) of input-redirection.bin:\n\nReading data from generic Input Stream - read data from file, console and memory ; :: ; ; ; : id 0 , name , price 0.0 , quantity 0 ; = :: ; & ; :: & ; :: & ; * ; , ** argc < 2 ::cout << << << << argv 0 << << << << argv 0 << << << << argv 0 << << ; EXIT_FAILURE; :: = argv 1 ; cmd == = ::stringstream sampleData ; = readInventory ss ; showInventory inventory ; EXIT_SUCCESS; argc == 3 && cmd == :: = argv 2 ; ::cout << << file << ::endl; = readInventoryFromFile file ; showInventory inventory ; EXIT_SUCCESS; cmd == ::cout << \"Type the inventory and then type Ctlr + D when you are done.\" << ::endl; = readInventory ::cin ; ::cout << << ::endl; showInventory inventory ; EXIT_SUCCESS; ::cerr << << ::endl; EXIT_FAILURE; * = R ; & ::cout << ::setprecision 2 << ::fixed; ::cout << ::right << ::setw 5 << << ::right << ::setw 5 << << ::left << ::setw 30 << << ::right << ::setw 10 << << ::right << ::setw 12 << << ::right << ::setw 12 << << ; = 0.0; & : inventory ::cout << ::right << ::setw 5 << item.id << ::right << ::setw 5 << << ::left << ::setw 30 << item.name << ::right << ::setw 10 << item.price << ::right << ::setw 12 << item.quantity << ::right << ::setw 12 << item.quantity * item.price << ; total += item.quantity * item.price; ::cout << << total << ; :: & ; :: ; :: ; :: ; ::getline is, line line == ; sline.clear ; sline.str line ; sline >> currentItem.id >> ::quoted currentItem.name >> currentItem.price >> currentItem.quantity; sline = ::string + line; ::runtime_error error_message ; inventory.push_back currentItem ; inventory; :: & = ::ifstream file ; ifs ::cerr << << ::endl; ::terminate ; readInventory ifs ; $ ./readInventory.bin memory ID Name Price Quantity Value 297 Current sensor 9.60 300 2880.00 871 Pressure transducer 90.00 50 4500.00 751 Temperature SPI sensor 40.25 20 805.00 652 Gyroscope 220.50 45 9922.50 Total inventory value: 18107.50 Read and display inventory data from console (stdin stream), the data is typed by the user and when he is done, he types Ctrl + D sending EOF (End Of File) character to the process: $ ./readInventory.bin console Type the inventory and then type Ctlr + D when you are done. 982 300.0 25 751 45.0 200 231 78.50 35 ---- Inventory Value --------- ID Name Price Quantity Value 982 IMU 6 axis 300.00 25 7500.00 751 Temperature sensor I2C 45.00 200 9000.00 231 Current transducer XYZWK 78.50 35 2747.50 Total inventory value: 19247.50 $ cat inventory1.txt | ./readInventory.bin console Type the inventory and then type Ctlr + D when you are done. ---- Inventory Value --------- ID Name Price Quantity Value 200 diode 3.40 100 340.00 300 blue led 5.10 200 1020.00 100 power supply 5 Volts 20.50 15 307.50 256 battery 12 volts pack 12.50 50 625.00 901 light sensor 60.00 40 2400.00 Total inventory value: 4692.50 $ ./readInventory.bin file inventory1.txt Reading file: inventory1.txt ID Name Price Quantity Value 200 diode 3.40 100 340.00 300 blue led 5.10 200 1020.00 100 power supply 5 Volts 20.50 15 307.50 256 battery 12 volts pack 12.50 50 625.00 901 light sensor 60.00 40 2400.00 Total inventory value: 4692.50\n\nMost Unix-like operating systems such as Linux, Android, BSD Variants, AIX and IRIX use ELF Executable Linkable Format binary file format for their executables and shared libraries (aka shared object). While the following code is specific for ELF files, it can be reused with any other type of binary file if the layout is known.\n• Note: Although Mac OSX is an Unix-like operating system, it does not use ELF file format for its executables, instead it uses Mach-O file format. The most relevant sections for an ELF object-code file are: $ file /bin/bash : ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, for GNU/Linux 3.2.0, [sha1]=01497fbe04f926fce1493834b3d208f82ab29788, stripped, too many notes (256) The first bytes must be or the sequence of bytes: 0x7f 0x45 0x4c 0x46. $ readelf --sections /bin/bash There are 30 section headers, starting at offset 0x123348: Section Headers: [Nr] Name Type Address Offset Size EntSize Flags Link Info Align [ 0] NULL 0000000000000000 00000000 0000000000000000 0000000000000000 0 0 0 [ 1] .interp PROGBITS 00000000000002a8 000002a8 000000000000001c 0000000000000000 A 0 0 1 [ 2] .note.ABI-tag NOTE 00000000000002c4 000002c4 0000000000000020 0000000000000000 A 0 0 4 [ 3] .note.gnu.propert NOTE 00000000000002e8 000002e8 0000000000000030 0000000000000000 A 0 0 8 [ 4] .note.gnu.build-i NOTE 0000000000000318 00000318 0000000000000024 0000000000000000 A 0 0 4 [ 5] .gnu.hash GNU_HASH 0000000000000340 00000340 00000000000049ac 0000000000000000 A 6 0 8 [ 6] .dynsym DYNSYM 0000000000004cf0 00004cf0 000000000000de18 0000000000000018 A 7 1 8 [ 7] .dynstr STRTAB 0000000000012b08 00012b08 00000000000092be 0000000000000000 A 0 0 1 [ 8] .gnu.version VERSYM 000000000001bdc6 0001bdc6 0000000000001282 0000000000000002 A 6 0 2 [ 9] .gnu.version_r VERNEED 000000000001d048 0001d048 00000000000000b0 0000000000000000 A 7 2 8 [10] .rela.dyn RELA 000000000001d0f8 0001d0f8 000000000000da10 0000000000000018 A 6 0 8 [11] .rela.plt RELA 000000000002ab08 0002ab08 0000000000001470 0000000000000018 AI 6 23 8 [12] .init PROGBITS 000000000002bf78 0002bf78 0000000000000017 0000000000000000 AX 0 0 4 [13] .plt PROGBITS 000000000002bf90 0002bf90 0000000000000db0 0000000000000010 AX 0 0 16 [14] .text PROGBITS 000000000002cd40 0002cd40 00000000000a59e1 0000000000000000 AX 0 0 16 [15] .fini PROGBITS 00000000000d2724 000d2724 0000000000000009 0000000000000000 AX 0 0 4 [16] .rodata PROGBITS 00000000000d2740 000d2740 0000000000018fd8 0000000000000000 A 0 0 32 [17] .eh_frame_hdr PROGBITS 00000000000eb718 000eb718 00000000000042dc 0000000000000000 A 0 0 4 ... ... ... ... ... ... ... ... ... ... ... ... ... ... Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings), I (info), L (link order), O (extra OS processing required), G (group), T (TLS), C (compressed), x (unknown), o (OS specific), E (exclude), l (large), p (processor specific) = :: ::uint8_t ; ::ostream& << :: & , & ; & , & ; :: & , -> ; :: & , , * ; :: , * ; = 1 , = 2 ; = 1 , = 2 ; * = ; = ::ifstream elf_file, :: ::in | :: ::binary ; ifs ::cerr << << ::endl; EXIT_FAILURE; 4, 0x00 ; ifs.read * &elf_header 0 , elf_header.size * ::uint8_t ; ::cout << << elf_header << ::endl; elf_header != ByteArray 0x7f, 0x45, 0x4c, 0x46 ::cerr << << ::endl; ::exit EXIT_FAILURE ; = readbin_at ifs, 0x04 ; printf , ei_class ; = ei_class ; printf , ei_class == 2 ? : ; = readbin_at ifs, 0x05 ; printf , ei_data ; = ei_data ; endianess == ::big_endian printf ; endianess == ::little_endian printf ; = readbin_at ifs, 0x07 ; printf , ei_osabi ; = readbin_at ifs, 0x12 ; printf , ei_machine ; printf , isa_type_database.at ei_machine ; = readbin_at ifs, 0x3C ; printf \" Number of sections of the ELF file = %d \n\n\" , e_shnum ; show_num_at ifs, 0x30, ; show_num_at ifs, 0x36, ; show_num_at ifs, 0x38, ; show_num_at ifs, 0x3A, ; show_num_at ifs, 0x3C, ; ; wordsize == ::word32bits ei_entry = readbin_at ifs, 0x18 ; wordsize == ::word64bits ei_entry = readbin_at ifs, 0x18 ; printf , ei_entry ; 0; ::ostream& << :: & , & & : str ::isprint ch os << ch << ; os << << ::hex << ::setw 2 << ::setfill << ch << << ::dec; os; & , & rhs.size != lhs.size ; ::equal rhs.begin , rhs.end , lhs.begin ; :: & , -> ; offset > 0 is.seekg offset ; is.read * &value , T ; value; :: & , , * = readbin_at is, offset ; printf , name, data ; :: , * isa_type_database = 0x00, , 0x02, , 0x03, , 0x08, , 0x14, , 0x16, , 0x28, , 0x2A, , 0x3E, , 0xB7, , 0xF3, ; $ ./read_elf.bin elf_header = \\0x7f ELF ei_class = 0x2 Executable type (word size): 64 bits ei_data = 0x1 => Processor is LITTLE ENDIAN ei_osabi = 0x0 ei_machine = 0x3E Architecture(ISA): x86-64 Number of sections of the ELF file = 30 => Field [e_hsize] = 0 => Field [e_shentsize] = 56 => Field [e_phnum] = 11 => Field [e_shentsize] = 64 => Field [e_shnum] = 30 Entry point 0x2E4B0 Function for reading data at some offset from a input stream opened in binary mode.\n• The 101 of ELF files on Linux: Understanding and Analysis\n• Analyzing the Linker Map file with a little help from the ELF and the DWARF\n\nxs = [0]( ) xs = [5]( 1 5 4.6 10000 9.8 ) xa = [5]( 1 3 4 5 6 ) words = [5]( hello world C++ new machine ) Operators insertion and extraction for used defined-type This example shows how to overload the operators insertion (<<) and extraction (>>) for an user defined type. Note: those operators are not class methods, they are free functions. Operator insertion (<<) for printing a Product object to an output stream, it means any derived class of std::ostream or std::cout, std::stringstream, std::fstream.\n• Note: This operator is not a method of the class Product, it is just a function of two arguments. Operator extraction (>>) for reading a product object from an input stream, it means, any derived class of the class std::istream such as std::cin, std::fstream, std::sstream and so on. Experiment 4: Read products from console (user types the products) and types Ctrl + D sending EOF (End Of File) character when he is done."
    },
    {
        "link": "https://wscubetech.com/resources/cpp/input-output",
        "document": ""
    }
]