[
    {
        "link": "https://docs.python.org/3/tutorial/datastructures.html",
        "document": "This chapter describes some things you’ve learned about already in more detail, and adds some new things as well.\n\nThe list data type has some more methods. Here are all of the methods of list objects: Add an item to the end of the list. Similar to . Extend the list by appending all the items from the iterable. Similar to . Insert an item at a given position. The first argument is the index of the element before which to insert, so inserts at the front of the list, and is equivalent to . Remove the first item from the list whose value is equal to x. It raises a if there is no such item. Remove the item at the given position in the list, and return it. If no index is specified, removes and returns the last item in the list. It raises an if the list is empty or the index is outside the list range. Remove all items from the list. Similar to . Return zero-based index in the list of the first item whose value is equal to x. Raises a if there is no such item. The optional arguments start and end are interpreted as in the slice notation and are used to limit the search to a particular subsequence of the list. The returned index is computed relative to the beginning of the full sequence rather than the start argument. Return the number of times x appears in the list. Sort the items of the list in place (the arguments can be used for sort customization, see for their explanation). Reverse the elements of the list in place. Return a shallow copy of the list. Similar to . An example that uses most of the list methods: You might have noticed that methods like , or that only modify the list have no return value printed – they return the default . This is a design principle for all mutable data structures in Python. Another thing you might notice is that not all data can be sorted or compared. For instance, doesn’t sort because integers can’t be compared to strings and can’t be compared to other types. Also, there are some types that don’t have a defined ordering relation. For example, isn’t a valid comparison. The list methods make it very easy to use a list as a stack, where the last element added is the first element retrieved (“last-in, first-out”). To add an item to the top of the stack, use . To retrieve an item from the top of the stack, use without an explicit index. For example: It is also possible to use a list as a queue, where the first element added is the first element retrieved (“first-in, first-out”); however, lists are not efficient for this purpose. While appends and pops from the end of list are fast, doing inserts or pops from the beginning of a list is slow (because all of the other elements have to be shifted by one). To implement a queue, use which was designed to have fast appends and pops from both ends. For example: # The first to arrive now leaves # The second to arrive now leaves List comprehensions provide a concise way to create lists. Common applications are to make new lists where each element is the result of some operations applied to each member of another sequence or iterable, or to create a subsequence of those elements that satisfy a certain condition. For example, assume we want to create a list of squares, like: Note that this creates (or overwrites) a variable named that still exists after the loop completes. We can calculate the list of squares without any side effects using: which is more concise and readable. A list comprehension consists of brackets containing an expression followed by a clause, then zero or more or clauses. The result will be a new list resulting from evaluating the expression in the context of the and clauses which follow it. For example, this listcomp combines the elements of two lists if they are not equal: Note how the order of the and statements is the same in both these snippets. If the expression is a tuple (e.g. the in the previous example), it must be parenthesized. # create a new list with the values doubled # apply a function to all the elements # the tuple must be parenthesized, otherwise an error is raised File , line : did you forget parentheses around the comprehension target? # flatten a list using a listcomp with two 'for' List comprehensions can contain complex expressions and nested functions: The initial expression in a list comprehension can be any arbitrary expression, including another list comprehension. Consider the following example of a 3x4 matrix implemented as a list of 3 lists of length 4: The following list comprehension will transpose rows and columns: As we saw in the previous section, the inner list comprehension is evaluated in the context of the that follows it, so this example is equivalent to: which, in turn, is the same as: # the following 3 lines implement the nested listcomp In the real world, you should prefer built-in functions to complex flow statements. The function would do a great job for this use case: See Unpacking Argument Lists for details on the asterisk in this line.\n\nWe saw that lists and strings have many common properties, such as indexing and slicing operations. They are two examples of sequence data types (see Sequence Types — list, tuple, range). Since Python is an evolving language, other sequence data types may be added. There is also another standard sequence data type: the tuple. A tuple consists of a number of values separated by commas, for instance: File , line , in : # but they can contain mutable objects: As you see, on output tuples are always enclosed in parentheses, so that nested tuples are interpreted correctly; they may be input with or without surrounding parentheses, although often parentheses are necessary anyway (if the tuple is part of a larger expression). It is not possible to assign to the individual items of a tuple, however it is possible to create tuples which contain mutable objects, such as lists. Though tuples may seem similar to lists, they are often used in different situations and for different purposes. Tuples are immutable, and usually contain a heterogeneous sequence of elements that are accessed via unpacking (see later in this section) or indexing (or even by attribute in the case of ). Lists are mutable, and their elements are usually homogeneous and are accessed by iterating over the list. A special problem is the construction of tuples containing 0 or 1 items: the syntax has some extra quirks to accommodate these. Empty tuples are constructed by an empty pair of parentheses; a tuple with one item is constructed by following a value with a comma (it is not sufficient to enclose a single value in parentheses). Ugly, but effective. For example: The statement is an example of tuple packing: the values , and are packed together in a tuple. The reverse operation is also possible: This is called, appropriately enough, sequence unpacking and works for any sequence on the right-hand side. Sequence unpacking requires that there are as many variables on the left side of the equals sign as there are elements in the sequence. Note that multiple assignment is really just a combination of tuple packing and sequence unpacking.\n\nPython also includes a data type for sets. A set is an unordered collection with no duplicate elements. Basic uses include membership testing and eliminating duplicate entries. Set objects also support mathematical operations like union, intersection, difference, and symmetric difference. Curly braces or the function can be used to create sets. Note: to create an empty set you have to use , not ; the latter creates an empty dictionary, a data structure that we discuss in the next section. Here is a brief demonstration: # show that duplicates have been removed # Demonstrate set operations on unique letters from two words # letters in a but not in b # letters in a or b or both # letters in both a and b # letters in a or b but not both Similarly to list comprehensions, set comprehensions are also supported:\n\nAnother useful data type built into Python is the dictionary (see Mapping Types — dict). Dictionaries are sometimes found in other languages as “associative memories” or “associative arrays”. Unlike sequences, which are indexed by a range of numbers, dictionaries are indexed by keys, which can be any immutable type; strings and numbers can always be keys. Tuples can be used as keys if they contain only strings, numbers, or tuples; if a tuple contains any mutable object either directly or indirectly, it cannot be used as a key. You can’t use lists as keys, since lists can be modified in place using index assignments, slice assignments, or methods like and . It is best to think of a dictionary as a set of key: value pairs, with the requirement that the keys are unique (within one dictionary). A pair of braces creates an empty dictionary: . Placing a comma-separated list of key:value pairs within the braces adds initial key:value pairs to the dictionary; this is also the way dictionaries are written on output. The main operations on a dictionary are storing a value with some key and extracting the value given the key. It is also possible to delete a key:value pair with . If you store using a key that is already in use, the old value associated with that key is forgotten. It is an error to extract a value using a non-existent key. Performing on a dictionary returns a list of all the keys used in the dictionary, in insertion order (if you want it sorted, just use instead). To check whether a single key is in the dictionary, use the keyword. Here is a small example using a dictionary: The constructor builds dictionaries directly from sequences of key-value pairs: In addition, dict comprehensions can be used to create dictionaries from arbitrary key and value expressions: When the keys are simple strings, it is sometimes easier to specify pairs using keyword arguments:\n\nWhen looping through dictionaries, the key and corresponding value can be retrieved at the same time using the method. When looping through a sequence, the position index and corresponding value can be retrieved at the same time using the function. To loop over two or more sequences at the same time, the entries can be paired with the function. What is your name? It is lancelot. What is your quest? It is the holy grail. What is your favorite color? It is blue. To loop over a sequence in reverse, first specify the sequence in a forward direction and then call the function. To loop over a sequence in sorted order, use the function which returns a new sorted list while leaving the source unaltered. Using on a sequence eliminates duplicate elements. The use of in combination with over a sequence is an idiomatic way to loop over unique elements of the sequence in sorted order. It is sometimes tempting to change a list while you are looping over it; however, it is often simpler and safer to create a new list instead.\n\nThe conditions used in and statements can contain any operators, not just comparisons. The comparison operators and are membership tests that determine whether a value is in (or not in) a container. The operators and compare whether two objects are really the same object. All comparison operators have the same priority, which is lower than that of all numerical operators. Comparisons can be chained. For example, tests whether is less than and moreover equals . Comparisons may be combined using the Boolean operators and , and the outcome of a comparison (or of any other Boolean expression) may be negated with . These have lower priorities than comparison operators; between them, has the highest priority and the lowest, so that A and not B or C is equivalent to (A and (not B)) or C . As always, parentheses can be used to express the desired composition. The Boolean operators and are so-called short-circuit operators: their arguments are evaluated from left to right, and evaluation stops as soon as the outcome is determined. For example, if and are true but is false, A and B and C does not evaluate the expression . When used as a general value and not as a Boolean, the return value of a short-circuit operator is the last evaluated argument. It is possible to assign the result of a comparison or other Boolean expression to a variable. For example, Note that in Python, unlike C, assignment inside expressions must be done explicitly with the walrus operator . This avoids a common class of problems encountered in C programs: typing in an expression when was intended.\n\nSequence objects typically may be compared to other objects with the same sequence type. The comparison uses lexicographical ordering: first the first two items are compared, and if they differ this determines the outcome of the comparison; if they are equal, the next two items are compared, and so on, until either sequence is exhausted. If two items to be compared are themselves sequences of the same type, the lexicographical comparison is carried out recursively. If all items of two sequences compare equal, the sequences are considered equal. If one sequence is an initial sub-sequence of the other, the shorter sequence is the smaller (lesser) one. Lexicographical ordering for strings uses the Unicode code point number to order individual characters. Some examples of comparisons between sequences of the same type: Note that comparing objects of different types with or is legal provided that the objects have appropriate comparison methods. For example, mixed numeric types are compared according to their numeric value, so 0 equals 0.0, etc. Otherwise, rather than providing an arbitrary ordering, the interpreter will raise a exception."
    },
    {
        "link": "https://docs.python.org/3/library/stdtypes.html",
        "document": "The following sections describe the standard types that are built into the interpreter.\n\nThe principal built-in types are numerics, sequences, mappings, classes, instances and exceptions.\n\nSome collection classes are mutable. The methods that add, subtract, or rearrange their members in place, and don’t return a specific item, never return the collection instance itself but .\n\nSome operations are supported by several object types; in particular, practically all objects can be compared for equality, tested for truth value, and converted to a string (with the function or the slightly different function). The latter function is implicitly used when an object is written by the function.\n\nThere are three distinct numeric types: integers, floating-point numbers, and complex numbers. In addition, Booleans are a subtype of integers. Integers have unlimited precision. Floating-point numbers are usually implemented using double in C; information about the precision and internal representation of floating-point numbers for the machine on which your program is running is available in . Complex numbers have a real and imaginary part, which are each a floating-point number. To extract these parts from a complex number z, use and . (The standard library includes the additional numeric types , for rationals, and , for floating-point numbers with user-definable precision.) Numbers are created by numeric literals or as the result of built-in functions and operators. Unadorned integer literals (including hex, octal and binary numbers) yield integers. Numeric literals containing a decimal point or an exponent sign yield floating-point numbers. Appending or to a numeric literal yields an imaginary number (a complex number with a zero real part) which you can add to an integer or float to get a complex number with real and imaginary parts. Python fully supports mixed arithmetic: when a binary arithmetic operator has operands of different numeric types, the operand with the “narrower” type is widened to that of the other, where integer is narrower than floating point, which is narrower than complex. A comparison between numbers of different types behaves as though the exact values of those numbers were being compared. The constructors , , and can be used to produce numbers of a specific type. All numeric types (except complex) support the following operations (for priorities of the operations, see Operator precedence): absolute value or magnitude of x a complex number with real part re, imaginary part im. im defaults to zero. conjugate of the complex number c\n• None Also referred to as integer division. For operands of type , the result has type . For operands of type , the result has type . In general, the result is a whole integer, though the result’s type is not necessarily . The result is always rounded towards minus infinity: is , is , is , and is .\n• None Not for complex numbers. Instead convert to floats using if appropriate.\n• None Conversion from to truncates, discarding the fractional part. See functions and for alternative conversions.\n• None float also accepts the strings “nan” and “inf” with an optional prefix “+” or “-” for Not a Number (NaN) and positive or negative infinity.\n• None Python defines and to be , as is common for programming languages.\n• None The numeric literals accepted include the digits to or any Unicode equivalent (code points with the property). See the Unicode Standard for a complete list of code points with the property. All types ( and ) also include the following operations: x rounded to n digits, rounding half to even. If n is omitted, it defaults to 0. For additional numeric operations see the and modules. Bitwise operations only make sense for integers. The result of bitwise operations is calculated as though carried out in two’s complement with an infinite number of sign bits. The priorities of the binary bitwise operations are all lower than the numeric operations and higher than the comparisons; the unary operation has the same priority as the other unary numeric operations ( and ). This table lists the bitwise operations sorted in ascending priority: bitwise exclusive or of x and y\n• None Negative shift counts are illegal and cause a to be raised.\n• None A left shift by n bits is equivalent to multiplication by .\n• None A right shift by n bits is equivalent to floor division by .\n• None Performing these calculations with at least one extra sign extension bit in a finite two’s complement representation (a working bit-width of or more) is sufficient to get the same result as if there were an infinite number of sign bits. The int type implements the abstract base class. In addition, it provides a few more methods: Return the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros: More precisely, if is nonzero, then is the unique positive integer such that . Equivalently, when is small enough to have a correctly rounded logarithm, then . If is zero, then returns . Return the number of ones in the binary representation of the absolute value of the integer. This is also known as the population count. Example: Return an array of bytes representing an integer. The integer is represented using length bytes, and defaults to 1. An is raised if the integer is not representable with the given number of bytes. The byteorder argument determines the byte order used to represent the integer, and defaults to . If byteorder is , the most significant byte is at the beginning of the byte array. If byteorder is , the most significant byte is at the end of the byte array. The signed argument determines whether two’s complement is used to represent the integer. If signed is and a negative integer is given, an is raised. The default value for signed is . The default values can be used to conveniently turn an integer into a single byte object: However, when using the default arguments, don’t try to convert a value greater than 255 or you’ll get an . \"byteorder must be either 'little' or 'big'\" Changed in version 3.11: Added default argument values for and . Return the integer represented by the given array of bytes. The argument bytes must either be a bytes-like object or an iterable producing bytes. The byteorder argument determines the byte order used to represent the integer, and defaults to . If byteorder is , the most significant byte is at the beginning of the byte array. If byteorder is , the most significant byte is at the end of the byte array. To request the native byte order of the host system, use as the byte order value. The signed argument indicates whether two’s complement is used to represent the integer. \"byteorder must be either 'little' or 'big'\" Changed in version 3.11: Added default argument value for . Return a pair of integers whose ratio is equal to the original integer and has a positive denominator. The integer ratio of integers (whole numbers) is always the integer as the numerator and as the denominator. The float type implements the abstract base class. float also has the following additional methods. Return a pair of integers whose ratio is exactly equal to the original float. The ratio is in lowest terms and has a positive denominator. Raises on infinities and a on NaNs. Return if the float instance is finite with integral value, and otherwise: Two methods support conversion to and from hexadecimal strings. Since Python’s floats are stored internally as binary numbers, converting a float to or from a decimal string usually involves a small rounding error. In contrast, hexadecimal strings allow exact representation and specification of floating-point numbers. This can be useful when debugging, and in numerical work. Return a representation of a floating-point number as a hexadecimal string. For finite floating-point numbers, this representation will always include a leading and a trailing and exponent. Class method to return the float represented by a hexadecimal string s. The string s may have leading and trailing whitespace. Note that is an instance method, while is a class method. where the optional may by either or , and are strings of hexadecimal digits, and is a decimal integer with an optional leading sign. Case is not significant, and there must be at least one hexadecimal digit in either the integer or the fraction. This syntax is similar to the syntax specified in section 6.4.4.2 of the C99 standard, and also to the syntax used in Java 1.5 onwards. In particular, the output of is usable as a hexadecimal floating-point literal in C or Java code, and hexadecimal strings produced by C’s format character or Java’s are accepted by . Note that the exponent is written in decimal rather than hexadecimal, and that it gives the power of 2 by which to multiply the coefficient. For example, the hexadecimal string represents the floating-point number , or : Applying the reverse conversion to gives a different hexadecimal string representing the same number: For numbers and , possibly of different types, it’s a requirement that whenever (see the method documentation for more details). For ease of implementation and efficiency across a variety of numeric types (including , , and ) Python’s hash for numeric types is based on a single mathematical function that’s defined for any rational number, and hence applies to all instances of and , and all finite instances of and . Essentially, this function is given by reduction modulo for a fixed prime . The value of is made available to Python as the attribute of . CPython implementation detail: Currently, the prime used is on machines with 32-bit C longs and on machines with 64-bit C longs. Here are the rules in detail:\n• None If is a nonnegative rational number and is not divisible by , define as , where gives the inverse of modulo .\n• None If is a nonnegative rational number and is divisible by (but is not) then has no inverse modulo and the rule above doesn’t apply; in this case define to be the constant value .\n• None If is a negative rational number define as . If the resulting hash is , replace it with .\n• None The particular values and are used as hash values for positive infinity or negative infinity (respectively).\n• None For a number , the hash values of the real and imaginary parts are combined by computing , reduced modulo so that it lies in . Again, if the result is , it’s replaced with . To clarify the above rules, here’s some example Python code, equivalent to the built-in hash, for computing the hash of a rational number, , or : Assumes m and n are integers, with n positive. # Remove common factors of P. (Unnecessary if m and n already coprime.) # Fermat's Little Theorem: pow(n, P-1, P) is 1, so # pow(n, P-2, P) gives the inverse of n modulo P.\n\nThere are three basic sequence types: lists, tuples, and range objects. Additional sequence types tailored for processing of binary data and text strings are described in dedicated sections. The operations in the following table are supported by most sequence types, both mutable and immutable. The ABC is provided to make it easier to correctly implement these operations on custom sequence types. This table lists the sequence operations sorted in ascending priority. In the table, s and t are sequences of the same type, n, i, j and k are integers and x is an arbitrary object that meets any type and value restrictions imposed by s. The and operations have the same priorities as the comparison operations. The (concatenation) and (repetition) operations have the same priority as the corresponding numeric operations. if an item of s is equal to x, else if an item of s is equal to x, else the concatenation of s and t equivalent to adding s to itself n times slice of s from i to j with step k index of the first occurrence of x in s (at or after index i and before index j) total number of occurrences of x in s Sequences of the same type also support comparisons. In particular, tuples and lists are compared lexicographically by comparing corresponding elements. This means that to compare equal, every element must compare equal and the two sequences must be of the same type and have the same length. (For full details see Comparisons in the language reference.) Forward and reversed iterators over mutable sequences access values using an index. That index will continue to march forward (or backward) even if the underlying sequence is mutated. The iterator terminates only when an or a is encountered (or when the index drops below zero).\n• None While the and operations are used only for simple containment testing in the general case, some specialised sequences (such as , and ) also use them for subsequence testing:\n• None Values of n less than are treated as (which yields an empty sequence of the same type as s). Note that items in the sequence s are not copied; they are referenced multiple times. This often haunts new Python programmers; consider: What has happened is that is a one-element list containing an empty list, so all three elements of are references to this single empty list. Modifying any of the elements of modifies this single list. You can create a list of different lists this way: Further explanation is available in the FAQ entry How do I create a multidimensional list?.\n• None If i or j is negative, the index is relative to the end of sequence s: or is substituted. But note that is still .\n• None The slice of s from i to j is defined as the sequence of items with index k such that . If i or j is greater than , use . If i is omitted or , use . If j is omitted or , use . If i is greater than or equal to j, the slice is empty.\n• None The slice of s from i to j with step k is defined as the sequence of items with index such that . In other words, the indices are , , , and so on, stopping when j is reached (but never including j). When k is positive, i and j are reduced to if they are greater. When k is negative, i and j are reduced to if they are greater. If i or j are omitted or , they become “end” values (which end depends on the sign of k). Note, k cannot be zero. If k is , it is treated like .\n• None Concatenating immutable sequences always results in a new object. This means that building up a sequence by repeated concatenation will have a quadratic runtime cost in the total sequence length. To get a linear runtime cost, you must switch to one of the alternatives below:\n• None if concatenating objects, you can build a list and use at the end or else write to an instance and retrieve its value when complete\n• None if concatenating objects, you can similarly use or , or you can do in-place concatenation with a object. objects are mutable and have an efficient overallocation mechanism\n• None for other types, investigate the relevant class documentation\n• None Some sequence types (such as ) only support item sequences that follow specific patterns, and hence don’t support sequence concatenation or repetition.\n• None raises when x is not found in s. Not all implementations support passing the additional arguments i and j. These arguments allow efficient searching of subsections of the sequence. Passing the extra arguments is roughly equivalent to using , only without copying any data and with the returned index being relative to the start of the sequence rather than the start of the slice. The only operation that immutable sequence types generally implement that is not also implemented by mutable sequence types is support for the built-in. This support allows immutable sequences, such as instances, to be used as keys and stored in and instances. Attempting to hash an immutable sequence that contains unhashable values will result in . The operations in the following table are defined on mutable sequence types. The ABC is provided to make it easier to correctly implement these operations on custom sequence types. In the table s is an instance of a mutable sequence type, t is any iterable object and x is an arbitrary object that meets any type and value restrictions imposed by s (for example, only accepts integers that meet the value restriction ). item i of s is replaced by x slice of s from i to j is replaced by the contents of the iterable t the elements of are replaced by those of t removes the elements of from the list appends x to the end of the sequence (same as ) removes all items from s (same as ) creates a shallow copy of s (same as ) extends s with the contents of t (for the most part the same as ) inserts x into s at the index given by i (same as ) retrieves the item at i and also removes it from s removes the first item from s where is equal to x reverses the items of s in place\n• None If k is not equal to , t must have the same length as the slice it is replacing.\n• None The optional argument i defaults to , so that by default the last item is removed and returned.\n• None raises when x is not found in s.\n• None The method modifies the sequence in place for economy of space when reversing a large sequence. To remind users that it operates by side effect, it does not return the reversed sequence.\n• None and are included for consistency with the interfaces of mutable containers that don’t support slicing operations (such as and ). is not part of the ABC, but most concrete mutable sequence classes provide it.\n• None The value n is an integer, or an object implementing . Zero and negative values of n clear the sequence. Items in the sequence are not copied; they are referenced multiple times, as explained for under Common Sequence Operations. Lists are mutable sequences, typically used to store collections of homogeneous items (where the precise degree of similarity will vary by application). Lists may be constructed in several ways:\n• None Using a pair of square brackets to denote the empty list:\n• None Using the type constructor: or The constructor builds a list whose items are the same and in the same order as iterable’s items. iterable may be either a sequence, a container that supports iteration, or an iterator object. If iterable is already a list, a copy is made and returned, similar to . For example, returns and returns . If no argument is given, the constructor creates a new empty list, . Many other operations also produce lists, including the built-in. Lists implement all of the common and mutable sequence operations. Lists also provide the following additional method: This method sorts the list in place, using only comparisons between items. Exceptions are not suppressed - if any comparison operations fail, the entire sort operation will fail (and the list will likely be left in a partially modified state). accepts two arguments that can only be passed by keyword (keyword-only arguments): key specifies a function of one argument that is used to extract a comparison key from each list element (for example, ). The key corresponding to each item in the list is calculated once and then used for the entire sorting process. The default value of means that list items are sorted directly without calculating a separate key value. The utility is available to convert a 2.x style cmp function to a key function. reverse is a boolean value. If set to , then the list elements are sorted as if each comparison were reversed. This method modifies the sequence in place for economy of space when sorting a large sequence. To remind users that it operates by side effect, it does not return the sorted sequence (use to explicitly request a new sorted list instance). The method is guaranteed to be stable. A sort is stable if it guarantees not to change the relative order of elements that compare equal — this is helpful for sorting in multiple passes (for example, sort by department, then by salary grade). For sorting examples and a brief sorting tutorial, see Sorting Techniques. CPython implementation detail: While a list is being sorted, the effect of attempting to mutate, or even inspect, the list is undefined. The C implementation of Python makes the list appear empty for the duration, and raises if it can detect that the list has been mutated during a sort. Tuples are immutable sequences, typically used to store collections of heterogeneous data (such as the 2-tuples produced by the built-in). Tuples are also used for cases where an immutable sequence of homogeneous data is needed (such as allowing storage in a or instance). Tuples may be constructed in a number of ways:\n• None Using a pair of parentheses to denote the empty tuple:\n• None Using a trailing comma for a singleton tuple: or\n• None Using the built-in: or The constructor builds a tuple whose items are the same and in the same order as iterable’s items. iterable may be either a sequence, a container that supports iteration, or an iterator object. If iterable is already a tuple, it is returned unchanged. For example, returns and returns . If no argument is given, the constructor creates a new empty tuple, . Note that it is actually the comma which makes a tuple, not the parentheses. The parentheses are optional, except in the empty tuple case, or when they are needed to avoid syntactic ambiguity. For example, is a function call with three arguments, while is a function call with a 3-tuple as the sole argument. Tuples implement all of the common sequence operations. For heterogeneous collections of data where access by name is clearer than access by index, may be a more appropriate choice than a simple tuple object. The type represents an immutable sequence of numbers and is commonly used for looping a specific number of times in loops. The arguments to the range constructor must be integers (either built-in or any object that implements the special method). If the step argument is omitted, it defaults to . If the start argument is omitted, it defaults to . If step is zero, is raised. For a positive step, the contents of a range are determined by the formula where and . For a negative step, the contents of the range are still determined by the formula , but the constraints are and . A range object will be empty if does not meet the value constraint. Ranges do support negative indices, but these are interpreted as indexing from the end of the sequence determined by the positive indices. Ranges containing absolute values larger than are permitted but some features (such as ) may raise . Ranges implement all of the common sequence operations except concatenation and repetition (due to the fact that range objects can only represent sequences that follow a strict pattern and repetition and concatenation will usually violate that pattern). The value of the start parameter (or if the parameter was not supplied) The value of the stop parameter The value of the step parameter (or if the parameter was not supplied) The advantage of the type over a regular or is that a object will always take the same (small) amount of memory, no matter the size of the range it represents (as it only stores the , and values, calculating individual items and subranges as needed). Range objects implement the ABC, and provide features such as containment tests, element index lookup, slicing and support for negative indices (see Sequence Types — list, tuple, range): Testing range objects for equality with and compares them as sequences. That is, two range objects are considered equal if they represent the same sequence of values. (Note that two range objects that compare equal might have different , and attributes, for example or .) Changed in version 3.2: Implement the Sequence ABC. Support slicing and negative indices. Test objects for membership in constant time instead of iterating through all items. Changed in version 3.3: Define ‘==’ and ‘!=’ to compare range objects based on the sequence of values they define (instead of comparing based on object identity).\n• None The linspace recipe shows how to implement a lazy version of range suitable for floating-point applications."
    },
    {
        "link": "https://stackoverflow.com/questions/9727673/list-directory-tree-structure-in-python",
        "document": "We usually prefer to just use GNU tree, but we don't always have on every system, and sometimes Python 3 is available. A good answer here could be easily copy-pasted and not make GNU a requirement.\n\n's output looks like this:\n\nI created the above directory structure in my home directory under a directory I call .\n\nI also see other answers here that approach that sort of output, but I think we can do better, with simpler, more modern code and lazily evaluating approaches.\n\nTo begin with, let's use an example that\n• uses the and expressions (that create a generator function)\n• uses comments and some type annotations for extra clarity\n\nWe do need to materialize each directory into a list because we need to know how long it is, but afterwards we throw the list away. For deep and broad recursion this should be lazy enough.\n\nThe above code, with the comments, should be sufficient to fully understand what we're doing here, but feel free to step through it with a debugger to better grock it if you need to.\n\nNow GNU gives us a couple of useful features that I'd like to have with this function:\n• prints the subject directory name first (does so automatically, ours does not)\n• option to limit to just directories,\n\nAlso, when there is a huge tree, it is useful to limit the iteration (e.g. with ) to avoid locking up your interpreter with text, as at some point the output becomes too verbose to be useful. We can make this arbitrarily high by default - say .\n\nSo let's remove the previous comments and fill out this functionality:\n\nAnd now we can get the same sort of output as :\n\nAnd we can restrict to levels:\n\nAnd we can limit the output to directories:\n\nIn retrospect, we could have used for matching. We could also perhaps use for recursive globbing, but that would require a rewrite. We could also use instead of materializing a list of directory contents, but that could have negative tradeoffs and would probably make the code even more complex."
    },
    {
        "link": "https://builtin.com/articles/tree-python",
        "document": "Python has built-in data structures for lists, arrays and dictionaries, but not for tree-like data structures. In LeetCode, questions for “Trees” are limited to binary search trees, and its implementation doesn’t have many functionalities.\n\nThe Python package can construct and export trees to and from Python lists, dictionaries and Pandas DataFrames, integrating seamlessly with existing Python workflows.\n\nTree-like data structures can be used to show hierarchical relationships, such as family trees and organizational charts.\n\nThis article will introduce basic tree concepts, how to construct trees with the Python package, tree traversal, search, modification and export methods. We’ll finish with ways to use trees for to-do list implementation, and extend tree implementation to trie and directed acyclic graph data structures.\n\nWhat Are Trees in Python?\n\nTrees are non-linear data structures that store data hierarchically and are made up of nodes connected by edges. For example, in a family tree, a node would represent a person, and an edge would represent the relationship between two nodes.\n\nThere are a few terminologies that extend to these components:\n• None : A node that doesn’t have any parent, and the entire tree originates from it. In Fig. 1, the root is node\n• None : Nodes that don’t have any child. In Fig. 1, leaf nodes are nodes\n• None : Immediate predecessor of a node. In Fig. 1, node is the parent node of nodes\n• None : Immediate successor of a node. In Fig. 1, Node is the child node of Node\n• None : All predecessors of a node. In Fig. 1, nodes\n• None : All successors of a node. In Fig. 1, nodes\n• None : Nodes that have the same parent. In Fig. 1, node\n• None : Sibling to the left of the node. In Fig. 1, node is the left sibling of node\n• None : Sibling to the right of the node. In Fig. 1, node is the right sibling of node\n• None : Length of the path from node to root. In Fig. 1, the depth of node\n• None : Maximum depth of root to a leaf node. In Fig. 1, the height of the tree is 3.\n\nHow to Setup Bigtree in Python\n\nBigtree is easy to set up: simply run the following command on Terminal.\n\nIf you want to export trees to image, run the following command on Terminal instead.\n\nWithout further ado, let’s dive into implementing trees!\n\nTo construct trees, we must first define the nodes and link the nodes by specifying the parent and children of the node.\n\nFor example, to construct a family tree:\n\nIn the example above, we define Node and to be children of Node with three lines of codes. We can also add attributes, such as the age attribute to nodes. To view the tree structure, we can use the show or method.\n\nWe can also query the root, leaves, parent, children, ancestors, descendants, siblings, , , depth and of the nodes, as covered in the previous section.\n\nThe above method to define every node and edge can be manual and tedious. There are alternative ways to construct trees with lists, dictionaries and Pandas DataFrame.\n\nIf there are no node attributes, the simplest way to construct a tree would be using Python lists and the method.\n\nIf there are node attributes, it’s best to construct a tree with a dictionary or , using and methods respectively.\n\nFor more node attributes and methods and other data structures to tree methods, do refer to the bigtree Documentation.\n\nThere are two types of tree traversal, depth-first search (DFS) and breadth-first search (BFS),\n• None starts at the root and explores each branch to its leaf node before moving to the next branch.\n• None starts at the root and explores every child node, and recursively does so for every node\n\nPre-order traversal is a DFS method that performs three steps recursively:\n\nFor pre-order traversal, it will traverse the tree in Fig. 2 in the order:\n\nPost-order traversal is a depth-first search (DFS) method that performs three steps recursively:\n\nFor post-order traversal, it will traverse the tree in Fig. 3 in the order:\n\nFor level-order traversal, it will traverse the tree in Fig. 3 in the order:\n\nLevel-order group traversal is similar to level-order traversal, with the difference being that each level will be returned as a nested list; denotes the items in depth .\n\nFor level-order group traversal, it will traverse the tree in Fig. 3 in the order:\n\nThere are other traversal algorithms available on , namely:\n• None : Applicable to binary trees and not generic trees.\n• None : Similar to level-order traversal, but in a zig-zag manner across different levels.\n• None : Similar to level-order group traversal, but in a zig-zag manner across different levels.\n\nWe can use tree search methods to get one or multiple nodes that fulfill certain criteria, with methods find for one node and for multiple nodes.\n\nFor generic search methods without defining a lambda function, there are built-in methods:\n• None : Find one node by their full path.\n• None : Find one/multiple children nodes by custom condition, removes the need for searching the whole tree.\n• None : Find one child node by their name.\n\nsupports cases where nodes must be shifted or copied from a location to a destination. For instance, we can shift and reorder nodes in a to-do list implementation.\n\nThere are also other tree modifications methods, such as:\n• None : Make a copy of the node from location to destination, node will exist in two locations.\n• None : Shift node from location to replace node in destination.\n• None : Make a copy of the node from one tree to another tree. The node will exist in two trees.\n• None : Make a copy of the node from one tree and replace node in another tree.\n\nAs mentioned at the start of the article, integrates seamlessly with Python dictionaries and Pandas DataFrame. Trees can be exported to a dictionary, nested dictionary, Pandas DataFrame and more formats.\n\nGiven a tree, we can print the tree to the console using print_tree with the ability to specify the attributes to print and the style of the tree. More customizations are also available in the bigtree Documentation.\n\nFor a generator method, you can use the method instead.\n\nGiven a tree, we can export the tree to a dictionary using with the ability to store all attributes with names as-is or map tree attributes to custom attribute names using a dictionary.\n\nThe original tree can be reconstructed back using the method.\n\nGiven a tree, we can export the tree to a DataFrame using tree_to_dataframe with the ability to store all attributes as columns with names as-is, or map tree attributes to custom column names using a dictionary.\n\nThe original tree can be reconstructed back using the method.\n\nGiven a tree, we can export the tree to an image or other graphics or files using . This uses under the hood, which uses Dot language and can be interfaced with Graphviz.\n\nIn the code snippet above, graph is of data type, which has built-in implementation to write to dot, PNG, SVG file formats, and more. The output is similar to Fig. 3.\n\nThere are other export methods available, including:\n• None : Export to nested dictionary, original tree can be reconstructed back using\n• None : Export to Newick notation, original tree can be reconstructed back using\n\nIf at this point you’re still wondering what you can do with , comes with a built-in to-do list workflow with the ability to import and export from a JSON file.\n\nThis to-do list implementation has three levels — name, list name and item name. You can add lists to or add items to list. For example:\n\nIn the example above:\n\nTrie is a type of k-ary search tree used for storing and searching a specific key from a set, derived from the word reTRIEval. Trie can be used to sort a collection of strings alphabetically or search if a prefix is present for a string.\n\nTo extend with Trie, we can add the leading symbol and trailing symbol to each word, and use tree search methods to find a specific word or subword with . A Trie can be constructed as such:\n\nThe code snippet above results in the image Fig. 4 if exported using the method.\n\nMore on PythonRandom Forest Regression in Python Explained\n\nDirected acyclic graph (DAG) is a graph data structure where each node can have more than one parent. A tree is considered a restricted form of a graph. This results in the following differences:s\n• None : There is no concept of root in DAG since a node can have multiple parents.\n• None : There is no concept of depth in DAG since there is no root node.\n• None : There is no concept of height in DAG since there is no root node.\n\nDAGs are best used to represent workflows as workflows have a certain order (directed), and do not repeat indefinitely, i.e. it doesn’t not have loops (acyclic).\n\nSimilar to trees, DAGs in can be constructed manually, from Python lists, dictionaries or Pandas DataFrames with methods , , and respectively.\n\nThe above code snippet results in the following image:\n\nWith that, I hope you have gained a better understanding of tree structures and how to implement them using the Python package."
    },
    {
        "link": "https://docs.python.org/3/faq/design.html",
        "document": "Why does Python use indentation for grouping of statements?¶ Guido van Rossum believes that using indentation for grouping is extremely elegant and contributes a lot to the clarity of the average Python program. Most people learn to love this feature after a while. Since there are no begin/end brackets there cannot be a disagreement between grouping perceived by the parser and the human reader. Occasionally C programmers will encounter a fragment of code like this: Only the statement is executed if the condition is true, but the indentation leads many to believe otherwise. Even experienced C programmers will sometimes stare at it a long time wondering as to why is being decremented even for . Because there are no begin/end brackets, Python is much less prone to coding-style conflicts. In C there are many different ways to place the braces. After becoming used to reading and writing code using a particular style, it is normal to feel somewhat uneasy when reading (or being required to write) in a different one. Many coding styles place begin/end brackets on a line by themselves. This makes programs considerably longer and wastes valuable screen space, making it harder to get a good overview of a program. Ideally, a function should fit on one screen (say, 20–30 lines). 20 lines of Python can do a lot more work than 20 lines of C. This is not solely due to the lack of begin/end brackets – the lack of declarations and the high-level data types are also responsible – but the indentation-based syntax certainly helps.\n\nWhy are floating-point calculations so inaccurate?¶ Users are often surprised by results like this: and think it is a bug in Python. It’s not. This has little to do with Python, and much more to do with how the underlying platform handles floating-point numbers. The type in CPython uses a C for storage. A object’s value is stored in binary floating-point with a fixed precision (typically 53 bits) and Python uses C operations, which in turn rely on the hardware implementation in the processor, to perform floating-point operations. This means that as far as floating-point operations are concerned, Python behaves like many popular languages including C and Java. Many numbers that can be written easily in decimal notation cannot be expressed exactly in binary floating point. For example, after: the value stored for is a (very good) approximation to the decimal value , but is not exactly equal to it. On a typical machine, the actual stored value is: The typical precision of 53 bits provides Python floats with 15–16 decimal digits of accuracy. For a fuller explanation, please see the floating-point arithmetic chapter in the Python tutorial.\n\nWhy must ‘self’ be used explicitly in method definitions and calls?¶ The idea was borrowed from Modula-3. It turns out to be very useful, for a variety of reasons. First, it’s more obvious that you are using a method or instance attribute instead of a local variable. Reading or makes it absolutely clear that an instance variable or method is used even if you don’t know the class definition by heart. In C++, you can sort of tell by the lack of a local variable declaration (assuming globals are rare or easily recognizable) – but in Python, there are no local variable declarations, so you’d have to look up the class definition to be sure. Some C++ and Java coding standards call for instance attributes to have an prefix, so this explicitness is still useful in those languages, too. Second, it means that no special syntax is necessary if you want to explicitly reference or call the method from a particular class. In C++, if you want to use a method from a base class which is overridden in a derived class, you have to use the operator – in Python you can write . This is particularly useful for methods, and in general in cases where a derived class method wants to extend the base class method of the same name and thus has to call the base class method somehow. Finally, for instance variables it solves a syntactic problem with assignment: since local variables in Python are (by definition!) those variables to which a value is assigned in a function body (and that aren’t explicitly declared global), there has to be some way to tell the interpreter that an assignment was meant to assign to an instance variable instead of to a local variable, and it should preferably be syntactic (for efficiency reasons). C++ does this through declarations, but Python doesn’t have declarations and it would be a pity having to introduce them just for this purpose. Using the explicit solves this nicely. Similarly, for using instance variables, having to write means that references to unqualified names inside a method don’t have to search the instance’s directories. To put it another way, local variables and instance variables live in two different namespaces, and you need to tell Python which namespace to use.\n\nWhy is join() a string method instead of a list or tuple method?¶ Strings became much more like other standard types starting in Python 1.6, when methods were added which give the same functionality that has always been available using the functions of the string module. Most of these new methods have been widely accepted, but the one which appears to make some programmers feel uncomfortable is: There are two common arguments against this usage. The first runs along the lines of: “It looks really ugly using a method of a string literal (string constant)”, to which the answer is that it might, but a string literal is just a fixed value. If the methods are to be allowed on names bound to strings there is no logical reason to make them unavailable on literals. The second objection is typically cast as: “I am really telling a sequence to join its members together with a string constant”. Sadly, you aren’t. For some reason there seems to be much less difficulty with having as a string method, since in that case it is easy to see that is an instruction to a string literal to return the substrings delimited by the given separator (or, by default, arbitrary runs of white space). is a string method because in using it you are telling the separator string to iterate over a sequence of strings and insert itself between adjacent elements. This method can be used with any argument which obeys the rules for sequence objects, including any new classes you might define yourself. Similar methods exist for bytes and bytearray objects.\n\nWhy must dictionary keys be immutable?¶ The hash table implementation of dictionaries uses a hash value calculated from the key value to find the key. If the key were a mutable object, its value could change, and thus its hash could also change. But since whoever changes the key object can’t tell that it was being used as a dictionary key, it can’t move the entry around in the dictionary. Then, when you try to look up the same object in the dictionary it won’t be found because its hash value is different. If you tried to look up the old value it wouldn’t be found either, because the value of the object found in that hash bin would be different. If you want a dictionary indexed with a list, simply convert the list to a tuple first; the function creates a tuple with the same entries as the list . Tuples are immutable and can therefore be used as dictionary keys. Some unacceptable solutions that have been proposed:\n• None Hash lists by their address (object ID). This doesn’t work because if you construct a new list with the same value it won’t be found; e.g.: would raise a exception because the id of the used in the second line differs from that in the first line. In other words, dictionary keys should be compared using , not using .\n• None Make a copy when using a list as a key. This doesn’t work because the list, being a mutable object, could contain a reference to itself, and then the copying code would run into an infinite loop.\n• None Allow lists as keys but tell the user not to modify them. This would allow a class of hard-to-track bugs in programs when you forgot or modified a list by accident. It also invalidates an important invariant of dictionaries: every value in is usable as a key of the dictionary.\n• None Mark lists as read-only once they are used as a dictionary key. The problem is that it’s not just the top-level object that could change its value; you could use a tuple containing a list as a key. Entering anything as a key into a dictionary would require marking all objects reachable from there as read-only – and again, self-referential objects could cause an infinite loop. There is a trick to get around this if you need to, but use it at your own risk: You can wrap a mutable structure inside a class instance which has both a and a method. You must then make sure that the hash value for all such wrapper objects that reside in a dictionary (or other hash based structure), remain fixed while the object is in the dictionary (or other structure). Note that the hash computation is complicated by the possibility that some members of the list may be unhashable and also by the possibility of arithmetic overflow. Furthermore it must always be the case that if (ie ) then (ie, ), regardless of whether the object is in a dictionary or not. If you fail to meet these restrictions dictionaries and other hash based structures will misbehave. In the case of , whenever the wrapper object is in a dictionary the wrapped list must not change to avoid anomalies. Don’t do this unless you are prepared to think hard about the requirements and the consequences of not meeting them correctly. Consider yourself warned.\n\nHow do you specify and enforce an interface spec in Python?¶ An interface specification for a module as provided by languages such as C++ and Java describes the prototypes for the methods and functions of the module. Many feel that compile-time enforcement of interface specifications helps in the construction of large programs. Python 2.6 adds an module that lets you define Abstract Base Classes (ABCs). You can then use and to check whether an instance or a class implements a particular ABC. The module defines a set of useful ABCs such as , , and . For Python, many of the advantages of interface specifications can be obtained by an appropriate test discipline for components. A good test suite for a module can both provide a regression test and serve as a module interface specification and a set of examples. Many Python modules can be run as a script to provide a simple “self test.” Even modules which use complex external interfaces can often be tested in isolation using trivial “stub” emulations of the external interface. The and modules or third-party test frameworks can be used to construct exhaustive test suites that exercise every line of code in a module. An appropriate testing discipline can help build large complex applications in Python as well as having interface specifications would. In fact, it can be better because an interface specification cannot test certain properties of a program. For example, the method is expected to add new elements to the end of some internal list; an interface specification cannot test that your implementation will actually do this correctly, but it’s trivial to check this property in a test suite. Writing test suites is very helpful, and you might want to design your code to make it easily tested. One increasingly popular technique, test-driven development, calls for writing parts of the test suite first, before you write any of the actual code. Of course Python allows you to be sloppy and not write test cases at all."
    },
    {
        "link": "https://geeksforgeeks.org/recursion-on-trees-in-python",
        "document": "In Python, recursion is implemented by defining a function that makes a call to itself within its definition. This process continues until a base case is reached, which is a condition where the function returns a value without making any further recursive calls. Without a base case, the recursion would continue indefinitely, leading to what's known as \"infinite recursion,\" which can cause the program to crash.\n• None Depth-First Search (DFS) is a traversal algorithm that explores as far as possible along each branch before backtracking.\n• None In a recursive implementation, we typically perform a depth-first traversal by recursively visiting the child nodes of each node.\n\nBelow is the implementation of the above code:\n\nTree Height and Depth using Recursion in Python:\n• None The height of a tree is the length of the longest path from the root node to a leaf node.\n• None The depth of a node is the length of the path from the root to that node.\n• None These can be calculated recursively by traversing the tree and keeping track of the depth or height as we go.\n\nBelow is the implementation of the above code:\n• None The size of a tree is the total number of nodes in the tree, including the root node and all its descendants.\n• None This can be calculated recursively by summing up the sizes of the left and right subtrees and adding 1 for the root node.\n\nBelow is the implementation of the above code:\n\nFinding Maximum/Minimum Node in Tree using Recursion in Python\n• None To find the maximum or minimum element in a tree, we can recursively traverse the tree and compare values at each node.\n\nBelow is the implementation of the above code:\n\nCheck for Symmetry in Tree using Recursion in Python:\n• None Checking for symmetry in a tree involves comparing the left and right subtrees of the root recursively.\n• None At each step, we compare corresponding nodes in the left and right subtrees.\n\nBelow is the implementation of the above code:\n\n# Base case: If both nodes are None, they are symmetric # If only one node is None or their values are different, they are not symmetric # Recursively check the symmetry of corresponding nodes in the left and right subtrees # Check the symmetry of the left and right subtrees\n\nPath Finding in Tree using Recursion in Python:\n• None Path finding involves finding a path from the root of the tree to a given node.\n• None We can use recursion to traverse the tree and keep track of the path.\n\nBelow is the implementation of the above code:\n• None The Lowest Common Ancestor (LCA) of two nodes in a binary tree is the lowest node in the tree that has both nodes as descendants.\n• None We can use recursion to find the LCA of two given nodes.\n\nBelow is the implementation of the above code:\n\nMorris Traversal is an in-order tree traversal algorithm that does not use recursion or a stack. Instead, it modifies the tree structure by linking the rightmost node of the left subtree to the current node, allowing traversal without additional space.\n\nBelow is the implementation of the above code:"
    },
    {
        "link": "https://stackoverflow.com/questions/57105003/getting-the-height-of-a-tree-with-a-recursive-function",
        "document": "It seems you got stuck with your recursive function and did not know how to move forward. I have changed it quite considerably to achieve this task in an efficient manner.\n\nIn general, to solve problems like these, the most important thing in terms of efficiency is to have a way of keeping track of where you have been already so that you do not repeat unnecessary work. You also want to make sure that you visit every leaf of the tree, as you do not know which one will be the deepest.\n\nThere is also a use of two functions here that are obviously very related. The first is the driver(1) function and is usually helpful when you have a recursive(2) function and want to call it with a specific set of arguments to start it off. Or when you want to run it in a for loop like I do here.\n\nLet me know if there is something that does not make sense:"
    },
    {
        "link": "https://stackoverflow.com/questions/13322616/how-to-find-the-height-of-a-node-in-binary-tree-recursively",
        "document": "You were given the solution by mata, but I suggest you also look at your code and understand what it is doing:\n\nWhat will this do? it will find the right child, then its right child, and so on. So this checks only one path of the \"rightmost\" leaf.\n\nThis does the same for the left:\n\nThe idea in recursion is that for each subproblem, you solve it using the exact same recipe for all other subproblems. So if you would apply your algorithm only to a subtree or a leaf, it would still work.\n\nAlso, a recursive definition calls itself (although you can implement this with a loop, but that is beyond the scope here)."
    },
    {
        "link": "https://geeksforgeeks.org/maximum-depth-or-height-of-a-binary-tree-with-python",
        "document": "Binary trees are hierarchical data structures that have widespread applications in computer science, from databases to graphics. One essential property of a binary tree is its depth or height. In this article, we'll discuss how to compute the maximum depth (or height) of a binary tree using Python.\n\nWhat is the Maximum Depth or Height?\n\nThe maximum depth or height of a binary tree is the number of edges on the longest path from the root node down to the farthest leaf node. A tree with a single node (only the root) has a height of 0.\n\nRecursive Approach to Find the Maximum Depth of a Binary Tree with Python\n\nHere, we will be using a recursive approach to calculate the maximum depth or height of a binary tree. In this method, we make a recursive call again and again until the base case is reached.\n• None Check if the current node is None. If it is, this means the tree is empty or we've reached the end of a branch.\n• None In such a case, return 0 because an empty tree has a height of 0.\n• None If the current node is not None , calculate the depth of the left right subtrees\n• maxDepth(node.left) to find the depth of the left subtree\n• maxDepth(node.right) to find the depth of the right subtree.\n• max() function to determine the greater depth between the left right subtrees\n• None Add 1 to the maximum depth value to account for the current node's depth.\n\nTo determine the height of a binary tree, we can use a recursive approach. Starting from the root, the height of the tree is the maximum of the heights of its left and right subtrees, plus one (for the root itself).\n\nTime Complexity: Time complexity of above code is O(n) as we visit the each node of a binary search tree once.\n\nSpace Complexity: Space complexity of above code is also O(n) because of recursive call stack and the recursive calls are equal to the total numbers of nodes in a binary tree.\n\nFind the Maximum Depth of a Binary Tree Using Level Order Traversal with Python\n\nTo find the maximum depth of a binary tree using an iterative approach in Python, we typically use a breadth-first search (BFS) strategy. This approach involves traversing the tree level by level and keeping track of the depth as we go. A common way to implement BFS is by using a queue.\n\nStep 1: Firstly we check if the root of the binary tree is \"None\". If it is None, return 0 because an empty tree has a depth of zero.\n\nStep 2: Initialize a queue to store pairs of tree nodes and their corresponding depth levels. Begin with the root node of the tree, assigning it a depth of 1.\n\nStep 3: Create a variable \"max_depth\" and set it to 0. This variable will be used to track the maximum depth of the tree as we iterate through it.\n\nStep 4: While the queue is not empty, repeat the following steps:\n• None Remove the front element from the queue. This element will be a tuple containing a node from the tree (\"current_node\") and its depth (\"depth\").\n• max_depth \" variable with the depth of \"current_node\" if it is greater than the current \"max_depth\"\n• current_node \" has a left child, add this child to the queue with a depth of \"depth + 1\"\n• \"current_node \" has a right child, also add this child to the queue with a depth of \"depth + 1\".\n\nStep 5: Continue the process of removing nodes from the queue, updating the maximum depth, and adding child nodes to the queue until the queue is empty.\n\nStep 6: After the queue is empty, which means all nodes have been processed, the value of \"max_depth\" will represent the maximum depth of the tree."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/height-of-a-tree-data-structure",
        "document": "In this tutorial, we’ll be discussing Binary Trees. We’ll see how to calculate the height of a tree data structure recursively as well as iteratively.\n\nBinary Trees are a data structure in which data is stored in a hierarchical manner rather than linear (as it is done in LinkedList and Arrays). A Binary tree data structure consists of nodes. Each node holds the data along with the reference to the child pointers (left and right). The root of the binary tree is the topmost node. (So opposite of an actual living tree). Following is an illustration of a tree with some nodes. The height of a node is the length of the longest downward path to a leaf from that node. The height of the root is the height of the tree. So, in order to calculate the height of the tree, we need to go through each node of the tree in order to obtain all permutations and combinations. There are two ways to calculate the height of the tree.\n\nRecursion involves calculating the results of the subproblems and returning it back to the parent problem.\n• To calculate the height of the tree recursively, we need to find the height of it’s left subtree and right subtree recursively and add 1 to them (height between the topmost node and its children).\n• Each of these subtrees could have a left and right subtree themselves, hence recursion would apply until the subtrees are NULL. The height of a null tree node is -1.\n• Finally, we’ll compare the heights of the left and right subtree and return the one which is greater.\n\nFollowing illustration shows the number of permutations to calculate the height of the binary tree. Let’s write the Java program to calculate the height of the tree recursively. First of all, we will have a basic implementation of the Tree data structure.\n\nLet’s see the code for finding the height of the tree using recursion.\n\nSo, in the above code, once we reach the bottom-most child node, we add one to the height of the tree and return the result to the previous call. Output: Height of tree is 2 Let’s now do the same thing non-recursively.\n\nTo calculate the height of the tree iteratively, we simply need to calculate the number of levels in the tree.\n• Create a Queue and add the root of the tree to it.\n• Pop the node from the queue and traverse down the queue while adding the child nodes to the queue.\n• In each iteration pop, the latest element added to the queue and add the elements of the next level (of this element) to the queue.\n• Do this until the queue size becomes zero. That would mean that the next level has zero elements.\n\nFollowing is the iterative program to calculate the height of the tree.\n\nThe above code keeps running until the queue isn’t empty. And also, it keeps adding all the elements at the next level while removing the current level items from the queue.\n\nTime Complexity is O(n). Space Complexity is O(1).\n\nYou can checkout complete code and more DS & Algorithm examples from our GitHub Repository."
    }
]