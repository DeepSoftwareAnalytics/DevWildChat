[
    {
        "link": "https://geeksforgeeks.org/iterate-over-characters-of-a-string-in-python",
        "document": "In this article, we will learn how to iterate over the characters of a string in Python. There are several methods to do this, but we will focus on the most efficient one. The simplest way is to use a loop. Let’s explore this approach.\n\nThe simplest way to iterate over the characters in a string is by using a for loop. This method is efficient and easy to understand.\n\nExplanation: for char in s: This line loops through the string s, with char representing each character in s one by one.\n\nIf we need both the character and its index then enumerate() is a great choice. It returns both values in each iteration.\n• enumerate(s) provides both the index i char\n• f before the string allows us to include variables directly within it using curly braces {}\n\nHow do I get both the character and its index in a string?\n\nCan I change characters while iterating over a string?\n\nHow can I store each character as an element in a list?"
    },
    {
        "link": "https://stackoverflow.com/questions/538346/iterating-each-character-in-a-string-using-python",
        "document": "Well you can also do something interesting like this and do your job by using for loop\n\nHowever since range() create a list of the values which is sequence thus you can directly use the name\n\nThis also produces the same result and also looks better and works with any sequence like list, tuple, and dictionary.\n\nWe have used tow Built in Functions ( BIFs in Python Community )\n\n1) range() - range() BIF is used to create indexes Example\n\n2) len() - len() BIF is used to find out the length of given string"
    },
    {
        "link": "https://w3schools.com/python/gloss_python_for_string.asp",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://stackoverflow.com/questions/20968823/how-to-iterate-over-each-string-in-a-list-of-strings-and-operate-on-its-elements",
        "document": "The suggestion that using is the equivalent of using is incorrect. They return the same results, but they are not the same.\n\nUsing actually gives you key/value pairs. Using does not.\n\nLet's check first (working from the example from the original poster):\n\nThis gives us a simple list:\n\n... and the elements in this list serve as the \"indexes\" in our results.\n\nSo let's do the same thing with our version:\n\nThis certainly doesn't give us a list:\n\n...so let's turn it into a list, and see what happens:\n\nIt gives us:\n\n... actually takes the first list (Words), and creates a second, simple list of the range indicated by the length of the first list.\n\nSo we have two simple lists, and we are merely printing one element from each list in order to get our so-called \"key/value\" pairs.\n\nBut they aren't really key/value pairs; they are merely two single elements printed at the same time, from different lists.\n\n... also creates a second list. But that list actually is a list of key/value pairs, and we are asking for each key and value from a single source -- rather than from two lists (like we did above).\n\nSo we print the same results, but the sources are completely different -- and handled completely differently."
    },
    {
        "link": "https://docs.python.org/3/tutorial/controlflow.html",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/59958070/best-practice-when-iterating-through-string-python",
        "document": "When you're iterating through a string with a for each loop, is it better to convert the string to a list and then loop through it? The reason I'm asking is because strings are immutable, so I'm not sure if it becomes inefficient in some way?\n\nThanks for the help."
    },
    {
        "link": "https://nathanrosidi.medium.com/python-string-methods-here-is-how-to-master-them-816fc34ac2db",
        "document": "Explore practical examples, learn how to effectively clean and format strings, and harness the power of Python’s memory model to master string operations.\n\nThe overall idea is that most people feel that Python’s string methods are too technical to understand correctly from the beginning.\n\nHowever, the reality is that all it takes is a bit of interest and some guidance to excel.\n\nI aim to share the steps and some essential facts that might turn anyone into a relatively professional string manipulator.\n\nFirst, I want to introduce you to the concatenation method, which stands for putting sequences of strings one after the other in a non-disconnectable manner. One classic example is the form of welcoming a user with a specific name:\n\nHere is the code.\n\nHere is the output.\n\nIn this case, the + operator is the welcomed, experienced tailor who sews the fragmented string into a pleasant greeting.\n\nAs you’ve discovered, the repetition can double or even spread a single chain. While working on the fabric of the code, you can place a single chain as follows;\n\nHere is the output.\n\nThe * operator can be likened to a chorus that has repeated the string ha three times to form a gleeful expression of laughter. By combining and repeating strings, developers can forcibly handle linguistic creations as they please.\n\nThen, at that delicate and sensitive level, devs can create even deep, intricate, and delicate overall linguistic unions.\n\nThe Art of Accessing Characters and Slicing\n\nAnother layer corresponding to the world of Python strings can be character access and slicing excavation, which are sharp tools for precisely extracting and operating substrings.\n\nAccessing Characters: The Key to Each Element\n\nPython string has its elements. They preserved a location described by an index, with each component having a decimal spot from 0 to the number of components in each.\n\nFurthermore, the following is easy to obtain. All one needs to do is open the bracket and provide the index. Here is the code.\n\nHere is the output.\n\nIn short, the slice defined the first character and snapped the last one, using just two signs to get to it.\n\nSlicing gets a part of a string marking distinguishing points. It is characterized by its [starting point: sorting] syntax. Here’s the code:\n\nHere is the output.\n\nI sliced “Hello, the world” from the above example. You can add a step using colons [start:end:step]. Thus, you can extract more complex and take more complex ones, such as reversing the order of the string or obtaining every second letter.\n\nPython strings are immutable. Therefore, any operation that changes a string results in the creation of a new string. By Python maintaining this behavior, it is highly linked with their memory model to maintain the efficiency and integrity of data:\n\nHere is the output.\n\nEven though it looks like it changed the original, the modified version is an entirely new string in memory. Strings’ immutability is a fundamental factor in most other string manipulation operations in Python and ensures that every string remains consistent and reliable.\n\nAfter learning these methods, you can better understand and work with your textual data and build on these basic principles to develop more advanced string manipulations.\n\nPython string methods open a toolkit for the user to follow a hammer with functionality to quickly and effortlessly perform virtually any action with string data or inquiry.\n\nThe function is built into and already exists in any string object, and you just need to call it and use it to work with strings.\n\nHowever, many methods can be used only by strings.\n\nNevertheless, this is not mockery but “glorification,” thanks to these methods, the user does not need to write much more code.\n\nThe len() function is not a string method but can be used to determine the string’s length. Here is the code.\n\nHere is the output.\n\nThis simple invocation provides the number of characters, including spaces and punctuation, and the primary understanding of the string size.\n\nOn the other hand, case transformations are done instantly with the help of several of them: upper() and lower(), and text normalization is allowed to be ready for comparison, searching, or presentation to the user.\n\nHere is the code:\n\nHere is the output.\n\nThese methods make text data comparable in processing and solve all problems with case-based operations.\n\nAnother vital area where whitespace needs to be managed is cleaning input or preparing data for further processing. Here is the code.\n\nHere is the output.\n\nHere, the strip() family of methods is unmatched in removing every piece of space not wanted. From eliminating the left and suitable spaces with strip() to simply stripping the leading or trailing spaces by using l strip() or rstrip(), respectively, they are vital for clean string data.\n\nQuick Wins: Brief Examples of Each Method\n\nAs you can see, python strings have numerous methods: find(), replace(), startswith(), endswith(), etc. Most of them are used for exceptional cases. Here is the code.\n\nHere is the output.\n\nThis short review shows how expansive the string methods’ toolkit is for a user who wants to work with text data efficiently and expressively.\n\nNow, you are armed and ready to perform numerous string-manipulating operations and begin exploring even more advanced ones.\n\nThe Search and Replace Commandos: Navigating Through Strings\n\nNavigating and manipulating strings accurately is vital in Python, especially if your data is primarily text. Python’s string methods for searching and replacing are like a well-trained search-and-rescue squad, able to quickly locate and alter textual content with tremendous accuracy.\n\nWhen it is necessary to determine the position of a substring in a string, the method find is useful. This method searches the substring from the start and returns the smallest index to this substring or -1 in case of search failure. If it is required to search from the end, you should use the method rfind():\n\nHere is the output.\n\nAll these methods are essential for parsing and processing text, which enables you to navigate strings accurately.\n\nThe Art of Substitution with replace()\n\nBesides, str.replace() is extremely valuable when changing parts of a string. This one finds a defined substring and puts a new one in place. Thus, it simply lets you renovate your text:\n\nHere is the code.\n\nHere is the output.\n\nThis example shows how replace() can transform content. It makes it a staple for text editing and data cleaning.\n\nNow that we have learned these methods, I want to model a practice I will use to perform. For instance, we have a dataset that has not been cleaned or updated for a long time. There will be different capitalization variations and even deprecated terms.\n\nA uniform model of these string data sources that can be analyzed will be feasible through the combination of find(), rfind(), and replace().\n\nHere is the output.\n\nThe above approach smooths out the data, preparing it for general analysis and demonstrating how Python’s string search and replacement equipment can be used properly.\n\nEntering more profoundly into the dispersion category, Python suggests three powerful pieces of equipment: split, join, and format.\n\nThey are perfect for dispersing, joining, and designing strings, so use them to advance the appearance.\n\nIt’s always tough to split something; it is an unwritten rule. However, when it is necessary to start splitting from the end, you will become best friends with it.\n\nFor those who want to split from the end, rsplit() is your ally:\n\nHere is the output.\n\nThe best use case is when you need to tokenize data, which implies splitting one large text into items containing one or several separate pieces of information.\n\nOn the other hand, join() constructs an iterable of strings, such as a list, into one single string with a specified separator threaded through it. It is the adhesive holding disparate strings together. Here is the code.\n\nHere is the output.\n\nThis method is especially beneficial when creating sentences, file paths, or any string that must be certain about how its components combine.\n\nAnother reasonable method is format() because it cautiously embeds variables into a string template. It is a much cleaner option while maintaining the string as a dynamic product of various merging factors. Here is the code.\n\nHere is the output.\n\nformat() allows madness in the form of strings and the sanity of “inserting things,” which makes it fundamental in Python string handling.\n\nAs string manipulation difficulties grow past basic operations, Python’s re-module becomes valuable. Python Regular expressions offer a compact and potent syntax to bridge the gap between what you can find, match, or substitute in a string, allowing you to conduct complicated text processing activities with minimal code.\n\nTapping into the re Module for Advanced Manipulations\n\nThe Python re-module provides tools to perform complex string manipulations using pattern matching. Below is how you may import and use the module for a basic search:\n\nHere is the output.\n\nIt is such a short example; however, it illustrates findall and how you can realize the potential of regular expressions to detect patterns.\n\nRegular expressions are used when you can describe the pattern you need in detail. They can validate emails, scroll logs for specific information, or clean up data. Here is the code.\n\nHere is the output.\n\nThese example cases show how regular expressions are versatile to perform complex string processing tasks pertinent to our day-to-day work. For these reasons, the tool confirms that it is an essential feature for a Python programmer.\n\nBringing It All Together: Examples\n\nNow let’s see one example, which includes Python string methods that we learned, from our platform.\n\nIn this question, the City of Francisco requires that we identify the number of words in each business’ name and exclude special symbols such as ‘&’ from what counts as a word at the end to display the business name and the number of words.\n\nFirst, let’s see a few rows and columns of the dataset.\n\nNow, let’s break down this question into multiple codable pieces;\n• Remove Duplicates: Ensures each business name is unique, preventing repeated word count calculations for the same entity.\n• Clean Business Names: Strips out special characters from business names, leaving only alphabets, numbers, and spaces for accurate word counting.\n• Count Words: Splits the cleaned business names into words based on spaces and counts the total number of words in each name, providing the desired information about word frequency.\n\nNow, let’s do this. Here is the code.\n\nHere are the first few rows of the output.\n\nIn this one, we went deep into Python’s string methods, exploring the intricacies of concatenation, slicing, memory models, and more to master the art of string manipulation.\n\nOne thing that deepens your understanding is doing repetition, like we did in the previous section.\n\nTo do that, try the StrataScratch platform, and check out Python interview questions, that include string methods, and master these methods, by solving questions from interviews of big companies."
    },
    {
        "link": "https://geeksforgeeks.org/python-string",
        "document": "A string is a sequence of characters. Python treats anything inside quotes as a string. This includes letters, numbers, and symbols. Python has no character data type so single character is a string of length 1.\n\nIn this example, s holds the value “GfG” and is defined as a string.\n\nStrings can be created using either single (‘) or double (“) quotes.\n\nIf we need a string to span multiple lines then we can use triple quotes (”’ or “””).\n\nStrings in Python are sequences of characters, so we can access individual characters using indexing. Strings are indexed starting from 0 and -1 from end. This allows us to retrieve specific characters from the string.\n\nNote: Accessing an index out of range will cause an IndexError. Only integers are allowed as indices and using a float or other types will result in a TypeError.\n\nPython allows negative address references to access characters from back of the String, e.g. -1 refers to the last character, -2 refers to the second last character, and so on.\n\nSlicing is a way to extract portion of a string by specifying the start and end indexes. The syntax for slicing is string[start:end], where start starting index and end is stopping index (excluded).\n\nStrings in Python are immutable. This means that they cannot be changed after they are created. If we need to manipulate strings then we can use methods like concatenation, slicing, or formatting to create new strings based on the original.\n\nIn Python, it is not possible to delete individual characters from a string since strings are immutable. However, we can delete an entire string variable using the del keyword.\n\nNote: After deleting the string using del and if we try to access s then it will result in a NameError because the variable no longer exists.\n\nTo update a part of a string we need to create a new string since strings are immutable.\n• For s1, s is sliced from index 1 to end of string and then concatenate “H” to create a new string s1\n• For s2, we can created a new string s2 and used\n\nPython provides a various built-in methods to manipulate strings. Below are some of the most useful methods.\n\nlen(): The len() function returns the total number of characters in a string.\n\nupper() and lower(): upper() method converts all characters to uppercase. lower() method converts all characters to lowercase.\n\nstrip() and replace(): strip() removes leading and trailing whitespace from the string and replace(old, new) replaces all occurrences of a specified substring with another.\n\nTo learn more about string methods, please refer to Python String Methods.\n\nWe can concatenate strings using + operator and repeat them using * operator.\n\nStrings can be combined by using + operator.\n\nWe can repeat a string multiple times using * operator.\n\nPython provides several ways to include variables inside strings.\n\nThe simplest and most preferred way to format strings is by using f-strings.\n\nAnother way to format strings is by using format() method.\n\nThe in keyword checks if a particular substring is present in a string.\n• None Split String into list of Characters in Python\n• None Iterate over characters of strings in Python\n• None Check if two strings are k-anagrams or not\n• None Check if string is rotated by two places\n• None Look and say Pattern"
    },
    {
        "link": "https://digitalocean.com/community/tutorials/how-to-index-and-slice-strings-in-python-3",
        "document": "The Python string data type is a sequence made up of one or more individual characters that could consist of letters, numbers, whitespace characters, or symbols. Because a string is a sequence, it can be accessed in the same ways that other sequence-based data types are, through indexing and slicing.\n\nThis tutorial will guide you through accessing strings through indexing, slicing them through their character sequences, and go over some counting and character location methods.\n\nYou should have Python 3 installed and a programming environment set up on your computer or server. If you don’t have a programming environment set up, you can refer to the installation and setup guides for a local programming environment or for a programming environment on your server appropriate for your operating system (Ubuntu, CentOS, Debian, etc.)\n\nLike the list data type that has items that correspond to an index number, each of a string’s characters also correspond to an index number, starting with the index number 0.\n\nFor the string the index breakdown is like this:\n\nAs you can see, the first starts at index 0, and the string ends at index 11 with the symbol.\n\nWe also notice that the whitespace character between and also corresponds with its own index number. In this case, the index number associated with the whitespace is 5.\n\nThe exclamation point ( ) also has an index number associated with it. Any other symbol or punctuation mark, such as , is also a character and would be associated with its own index number.\n\nThe fact that each character in a Python string has a corresponding index number allows us to access and manipulate strings in the same ways we can with other sequential data types.\n\nBy referencing index numbers, we can isolate one of the characters in a string. We do this by putting the index numbers in square brackets. Let’s declare a string, print it, and call the index number in square brackets:\n\nWhen we refer to a particular index number of a string, Python returns the character that is in that position. Since the letter is at index number 4 of the string , when we print we receive as the output.\n\nIndex numbers allow us to access specific characters within a string.\n\nIf we have a long string and we want to pinpoint an item towards the end, we can also count backwards from the end of the string, starting at the index number .\n\nFor the same string the negative index breakdown is like this:\n\nBy using negative index numbers, we can print out the character , by referring to its position at the -3 index, like so:\n\nUsing negative index numbers can be advantageous for isolating a single character towards the end of a long string.\n\nWe can also call out a range of characters from the string. Say we would like to only print the word . We can do so by creating a slice, which is a sequence of characters within an original string. With slices, we can call multiple character values by creating a range of index numbers separated by a colon :\n\nWhen constructing a slice, as in , the first index number is where the slice starts (inclusive), and the second index number is where the slice ends (exclusive), which is why in our example above the range has to be the index number that would occur after the string ends.\n\nWhen slicing strings, we are creating a substring, which is essentially a string that exists within another string. When we call , we are calling the substring that exists within the string .\n\nIf we want to include either end of a string, we can omit one of the numbers in the syntax. For example, if we want to print the first word of string — “Sammy” — we can do so by typing:\n\nWe did this by omitting the index number before the colon in the slice syntax, and only including the index number after the colon, which refers to the end of the substring.\n\nTo print a substring that starts in the middle of a string and prints to the end, we can do so by including only the index number before the colon, like so:\n\nBy including only the index number before the colon and leaving the second index number out of the syntax, the substring will go from the character of the index number called to the end of the string.\n\nYou can also use negative index numbers to slice a string. As we went through before, negative index numbers of a string start at -1, and count down from there until we reach the beginning of the string. When using negative index numbers, we’ll start with the lower number first as it occurs earlier in the string.\n\nLet’s use two negative index numbers to slice the string :\n\nThe substring “ark” is printed from the string “Sammy Shark!” because the character “a” occurs at the -4 index number position, and the character “k” occurs before the -1 index number position.\n\nString slicing can accept a third parameter in addition to two index numbers. The third parameter specifies the stride, which refers to how many characters to move forward after the first character is retrieved from the string. So far, we have omitted the stride parameter, and Python defaults to the stride of 1, so that every character between two index numbers is retrieved.\n\nLet’s review the example above that prints out the substring “Shark”:\n\nWe can obtain the same results by including a third parameter with a stride of 1:\n\nSo, a stride of 1 will take in every character between two index numbers of a slice. If we omit the stride parameter then Python will default with 1.\n\nIf, instead, we increase the stride, we will see that characters are skipped:\n\nSpecifying the stride of 2 as the last parameter in the Python syntax skips every other character. Let’s review the characters that are highlighted:\n\nNote that the whitespace character at index number 5 is also skipped with a stride of 2 specified.\n\nIf we use a larger number for our stride parameter, we will have a significantly smaller substring:\n\nSpecifying the stride of 4 as the last parameter in the Python syntax prints only every fourth character. Again, let’s look at the characters that are highlighted:\n\nIn this example the whitespace character is skipped as well.\n\nSince we are printing the whole string we can omit the two index numbers and keep the two colons within the syntax to achieve the same result:\n\nOmitting the two index numbers and retaining colons will keep the whole string within range, while adding a final parameter for stride will specify the number of characters to skip.\n\nAdditionally, you can indicate a negative numeric value for the stride, which we can use to print the original string in reverse order if we set the stride to -1:\n\nThe two colons without specified parameters will include all the characters from the original string, a stride of 1 will include every character without skipping, and negating that stride will reverse the order of the characters.\n\nLet’s do this again but with a stride of -2:\n\nIn this example, , we are dealing with the entirety of the original string as no index numbers are included in the parameters, and reversing the string through the negative stride. Additionally, by having a stride of -2 we are skipping every other letter of the reversed string:\n\nThe whitespace character is printed in this example.\n\nBy specifying the third parameter of the Python slice syntax, you are indicating the stride of the substring that you are pulling from the original string.\n\nWhile we are thinking about the relevant index numbers that correspond to characters within strings, it is worth going through some of the methods that count strings or return index numbers. This can be useful for limiting the number of characters we would like to accept within a user-input form, or comparing strings. Like other sequential data types, strings can be counted through several methods.\n\nWe’ll first look at the method which can get the length of any data type that is a sequence, whether ordered or unordered, including strings, lists, tuples, and dictionaries.\n\nLet’s print the length of the string :\n\nThe length of the string “Sammy Shark!” is 12 characters long, including the whitespace character and the exclamation point symbol.\n\nInstead of using a variable, we can also pass a string right into the method:\n\nThe method counts the total number of characters within a string.\n\nIf we want to count the number of times either one particular character or a sequence of characters shows up in a string, we can do so with the method. Let’s work with our string and count the number of times the character “a” appears:\n\nWe can search for another character:\n\nThough the letter “S” is in the string, it is important to keep in mind that each character is case-sensitive. If we want to search for all the letters in a string regardless of case, we can use the method to convert the string to all lower-case first. You can read more about this method in “An Introduction to String Methods in Python 3.”\n\nLet’s try with a sequence of characters:\n\nIn the string , the character sequence that is equivalent to “likes” occurs 3 times in the original string.\n\nWe can also find at what position a character or character sequence occurs in a string. We can do this with the method, and it will return the position of the character based on index number.\n\nWe can check to see where the first “m” occurs in the string :\n\nThe first character “m” occurs at the index position of 2 in the string “Sammy Shark!” We can review the index number positions of the string above.\n\nLet’s check to see where the first “likes” character sequence occurs in the string :\n\nThe first instance of the character sequence “likes” begins at index number position 6, which is where the character of the sequence is positioned.\n\nWhat if we want to see where the second sequence of “likes” begins? We can do that by passing a second parameter to the method that will start at a particular index number. So, instead of starting at the beginning of the string, let’s start after the index number 9:\n\nIn this second example that begins at the index number of 9, the first occurrence of the character sequence “likes” begins at index number 34.\n\nAdditionally, we can specify an end to the range as a third parameter. Like slicing, we can do so by counting backwards using a negative index number:\n\nThis last example searches for the position of the sequence “likes” between the index numbers of 40 and -6. Since the final parameter entered is a negative number it will be counting from the end of the original string.\n\nThe string methods of , , and can be used to determine length, counts of characters or character sequences, and index positions of characters or character sequences within strings.\n\nBeing able to call specific index numbers of strings, or a particular slice of a string gives us greater flexibility when working with this data type. Because strings, like lists and tuples, are a sequence-based data type, it can be accessed through indexing and slicing.\n\nYou can read more about formatting strings and string methods to continue learning about strings."
    },
    {
        "link": "https://programminghistorian.org/en/lessons/manipulating-strings-in-python",
        "document": "Great Open Access tutorials cost money to produce. Join the growing number of people supporting Programming Historian so we can continue to share knowledge free of charge.\n\nThis lesson is a brief introduction to string manipulation techniques in Python. Knowing how to manipulate strings plays a crucial role in most text processing tasks. If you’d like to experiment with the following lessons, you can write and execute short programs as we’ve been doing in previous lessons in the series, or you can open up a Python shell / Terminal to try them out on the command line.\n\nIf you have been exposed to another programming language before, you might have learned that you need to declare or type variables before you can store anything in them. This is not necessary when working with strings in Python. We can create a string simply by putting content wrapped with quotation marks into it with an equal sign (=):\n\nA string is a type of object, one that consists of a series of characters. Python already knows how to deal with a number of general-purpose and powerful representations, including strings. One way to manipulate strings is by using string operators. These operators are represented by symbols that you likely associate with mathematics, such as +, -, *, /, and =. When used with strings, they perform actions that are similar to, but not the same as, their mathematical counterparts.\n\nThis term means to join strings together. The process is known as concatenating strings and it is done using the plus (+) operator. Note that you must be explicit about where you want blank spaces to occur by placing them between single quotation marks also.\n\nIn this example, the string “message1” is given the content “hello world”.\n\nIf you want multiple copies of a string, use the multiplication (*) operator. In this example, string message2a is given the content “hello” times three; string message 2b is given content “world”; then we print both strings.\n\nWhat if you want to add material to the end of a string successively? There is a special operator for that (+=).\n\nIn addition to operators, Python comes pre-installed with dozens of string methods that allow you to do things to strings. Used alone or in combination, these methods can do just about anything you can imagine to strings. The good news is that you can reference a list of String Methods on the Python website, including information on how to use each properly. To make sure that you’ve got a basic grasp of string methods, what follows is a brief overview of some of the more commonly used ones:\n\nYou can determine the number of characters in a string using . Note that the blank space counts as a separate character.\n\nYou can search a string for a substring and your program will return the starting index position of that substring. This is helpful for further processing. Note that indexes are numbered from left to right and that the count starts with position 0, not 1.\n\nIf the substring is not present, the program will return a value of -1.\n\nSometimes it is useful to convert a string to lower case. For example, if we standardize case it makes it easier for the computer to recognize that “Sometimes” and “sometimes” are the same word.\n\nThe opposite effect, raising characters to upper case, can be achieved by changing to .\n\nIf you need to replace a substring throughout a string you can do so with the method.\n\nIf you want to off unwanted parts of a string from the beginning or end you can do so by creating a substring. The same kind of technique also allows you to break a long string into more manageable components.\n\nYou can substitute variables for the integers used in this example.\n\nThis makes it much easier to use this method in conjunction with the method as in the next example, which checks for the letter “d” in the first six characters of “Hello World” and correctly tells us it is not there (-1). This technique is much more useful in longer strings – entire documents for example. Note that the absence of an integer before the colon signifies we want to start at the beginning of the string. We could use the same technique to tell the program to go all the way to the end by putting no integer after the colon. And remember, index positions start counting from 0 rather than 1.\n\nThere are lots more, but the string methods above are a good start. Note that in this last example, we are using square brackets instead of parentheses. This difference in syntax signals an important distinction. In Python, parentheses are usually used to pass an argument to a function. So when we see something like\n\nit means pass the string message7 to the function then send the returned value of that function to the statement to be printed. If a function can be called without an argument, you often have to include a pair of empty parentheses after the function name anyway. We saw an example of that, too:\n\nThis statement tells Python to apply the function to the string message7 and store the returned value in the string message7a.\n\nThe square brackets serve a different purpose. If you think of a string as a sequence of characters, and you want to be able to access the contents of the string by their location within the sequence, then you need some way of giving Python a location within a sequence. That is what the square brackets do: indicate a beginning and ending location within a sequence as we saw when using the method.\n\nWhat do you do when you need to include quotation marks within a string? You don’t want the Python interpreter to get the wrong idea and end the string when it comes across one of these characters. In Python, you can put a backslash (\\) in front of a quotation mark so that it doesn’t terminate the string. These are known as escape sequences.\n\nTwo other escape sequences allow you to print tabs and newlines:\n\nTo follow along with future lessons it is important that you have the right files and programs in your programming-historian directory. At the end of each chapter you can download the programming-historian zip file to make sure you have the correct code. Note we have removed unneeded files from earlier lessons. Your directory may contain more files and that’s ok!"
    }
]