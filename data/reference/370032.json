[
    {
        "link": "https://doc.qt.io/qt-6/qwebsocket.html",
        "document": "Implements a TCP socket that talks the WebSocket protocol. More...\n\nWarning: To generate masks, this implementation of WebSockets uses the reasonably secure QRandomGenerator::global ()->generate() function. For more information about the importance of good masking, see \"Talking to Yourself for Fun and Profit\" by Lin-Shung Huang et al . The best measure against attacks mentioned in the document above, is to use QWebSocket over a secure connection ( wss:// ). In general, always be careful to not have 3rd party script access to a QWebSocket in your application.\n\nNote: Some proxies do not understand certain HTTP headers used during a WebSocket handshake. In that case, non-secure WebSocket connections fail. The best way to mitigate against this problem is to use WebSocket over a secure connection.\n\nQWebSocket only supports version 13 of the WebSocket protocol, as outlined in RFC 6455 .\n\nWebSockets is a web technology providing full-duplex communications channels over a single TCP connection. The WebSocket protocol was standardized by the IETF as RFC 6455 in 2011. QWebSocket can both be used in a client application and server application.\n\nSee also QAbstractSocket, QTcpSocket, and QWebSocket client example.\n\nCreates a new QWebSocket with the given origin, the version of the protocol to use and parent.\n\nThe origin of the client is as specified in RFC 6454. (The origin is not required for non-web browser clients (see RFC 6455)). The origin may not contain new line characters, otherwise the connection will be aborted immediately during the handshake phase.\n\nDestroys the QWebSocket. Closes the socket if it is still open, and releases any used resources.\n\nAborts the current socket and resets the socket. Unlike close(), this function immediately closes the socket, discarding any pending data in the write buffer.\n\nThis signal is emitted when the socket is about to close. Connect this signal if you have operations that need to be performed before the socket closes (e.g., if you have data in a separate buffer that needs to be written to the device).\n\nQWebSocket emits this signal if an alert message was received from a peer. level tells if the alert was fatal or it was a warning. type is the code explaining why the alert was sent. When a textual description of the alert message is available, it is supplied in description.\n\nThis function was introduced in Qt 6.2.\n\nSee also alertSent(), QSsl::AlertLevel, and QSsl::AlertType.\n\nQWebSocket emits this signal if an alert message was sent to a peer. level describes if it was a warning or a fatal error. type gives the code of the alert message. When a textual description of the alert message is available, it is supplied in description.\n\nThis function was introduced in Qt 6.2.\n\nSee also alertReceived(), QSsl::AlertLevel, and QSsl::AlertType.\n\nThis signal is emitted when the server requires authentication. The authenticator object must then be filled in with the required details to allow authentication and continue the connection.\n\nIf you know that the server may require authentication, you can set the username and password on the initial QUrl, using QUrl::setUserName and QUrl::setPassword. QWebSocket will still try to connect once without using the provided credentials.\n\nThis function was introduced in Qt 6.6.\n\nThis signal is emitted whenever a binary frame is received. The frame contains the data and isLastFrame indicates whether this is the last frame of the complete message.\n\nThis signal can be used to process large messages frame by frame, instead of waiting for the complete message to arrive.\n\nThis signal is emitted whenever a binary message is received. The message contains the received bytes.\n\nReturns the number of bytes that are waiting to be written. The bytes are written when control goes back to the event loop or when flush() is called.\n\nThis signal is emitted every time a payload of data has been written to the socket. The bytes argument is set to the number of bytes that were written in this payload.\n\nGracefully closes the socket with the given closeCode and reason.\n\nAny data in the write buffer is flushed before the socket is closed. The closeCode is a QWebSocketProtocol::CloseCode indicating the reason to close, and reason describes the reason of the closure more in detail. All control frames, including the Close frame, are limited to 125 bytes. Since two of these are used for closeCode the maximum length of reason is 123! If reason exceeds this limit it will be truncated.\n\nReturns the code indicating why the socket was closed.\n\nSee also QWebSocketProtocol::CloseCode and closeReason().\n\nReturns the reason why the socket was closed.\n\nEmitted when a connection is successfully established. A connection is successfully established when the socket is connected and the handshake was successful.\n\nSee also open() and disconnected().\n\nIf an application wants to conclude a handshake even after receiving handshakeInterruptedOnError() signal, it must call this function. This call must be done from a slot function attached to the signal. The signal-slot connection must be direct.\n\nThis function was introduced in Qt 6.2.\n\nSee also handshakeInterruptedOnError() and QSslConfiguration::setHandshakeMustInterruptOnError().\n\nEmitted when the socket is disconnected.\n\nSee also close() and connected().\n\nReturns the type of error that last occurred\n\nThis signal is emitted after an error occurred.\n\nThe error parameter describes the type of error that occurred.\n\nQAbstractSocket::SocketError is not a registered metatype, so for queued connections, you will have to register it with Q_DECLARE_METATYPE() and qRegisterMetaType().\n\nThis function was introduced in Qt 6.5.\n\nSee also error() and errorString().\n\nReturns a human-readable description of the last error that occurred\n\nThis function writes as much as possible from the internal write buffer to the underlying network socket, without blocking. If any data was written, this function returns true; otherwise false is returned. Call this function if you need QWebSocket to start sending buffered data immediately. The number of bytes successfully written depends on the operating system. In most cases, you do not need to call this function, because QWebSocket will start sending data automatically once control goes back to the event loop.\n\nQWebSocket emits this signal if a certificate verification error was found and if early error reporting was enabled in QSslConfiguration. An application is expected to inspect the error and decide if it wants to continue the handshake, or abort it and send an alert message to the peer. The signal-slot connection must be direct.\n\nThis function was introduced in Qt 6.2.\n\nSee also continueInterruptedHandshake(), sslErrors(), and QSslConfiguration::setHandshakeMustInterruptOnError().\n\nReturns the handshake options that were used to open this socket.\n\nThis function was introduced in Qt 6.4.\n\nThis slot tells QWebSocket to ignore errors during QWebSocket's handshake phase and continue connecting. If you want to continue with the connection even if errors occur during the handshake phase, then you must call this slot, either from a slot connected to sslErrors(), or before the handshake phase. If you don't call this slot, either in response to errors or before the handshake, the connection will be dropped after the sslErrors() signal has been emitted.\n\nSee also sslErrors(), QSslSocket::ignoreSslErrors(), and QNetworkReply::ignoreSslErrors().\n\nThis is an overloaded function.\n\nThis method tells QWebSocket to ignore the errors given in errors.\n\nNote that you can set the expected certificate in the SSL error: If, for instance, you want to connect to a server that uses a self-signed certificate, consider the following snippet:\n\nMultiple calls to this function will replace the list of errors that were passed in previous calls. You can clear the list of errors you want to ignore by calling this function with an empty list.\n\nReturns if the socket is ready for reading and writing; otherwise returns .\n\nReturns the mask generator that is currently used by this QWebSocket.\n\nReturns the maximum allowed size of an incoming websocket frame.\n\nReturns the maximum allowed size of an incoming websocket message.\n\nReturns the maximum supported size of an incoming websocket frame for this websocket implementation.\n\nReturns the maximum supported size of an incoming websocket message for this websocket implementation.\n\nReturns the maximum supported size of an outgoing websocket frame for this websocket implementation.\n\nOpens a WebSocket connection using the given request.\n\nThe request url will be used to open the WebSocket connection. Headers present in the request will be sent to the server in the upgrade request, together with the ones needed for the websocket handshake.\n\nOpens a WebSocket connection using the given url.\n\nIf the url contains newline characters (\\r\n\n), then the error signal will be emitted with QAbstractSocket::ConnectionRefusedError as error type.\n\nOpens a WebSocket connection using the given request and options.\n\nThe request url will be used to open the WebSocket connection. Headers present in the request will be sent to the server in the upgrade request, together with the ones needed for the websocket handshake.\n\nAdditional options for the WebSocket handshake such as subprotocols can be specified in options.\n\nThis function was introduced in Qt 6.4.\n\nOpens a WebSocket connection using the given url and options.\n\nIf the url contains newline characters (\\r\n\n), then the error signal will be emitted with QAbstractSocket::ConnectionRefusedError as error type.\n\nAdditional options for the WebSocket handshake such as subprotocols can be specified in options.\n\nThis function was introduced in Qt 6.4.\n\nReturns the maximum size of an outgoing websocket frame.\n\nReturns the pause mode of this socket\n\nQWebSocket can emit this signal several times during the SSL handshake, before encryption has been established, to indicate that an error has occurred while establishing the identity of the peer. The error is usually an indication that QWebSocket is unable to securely identify the peer.\n\nThis signal provides you with an early indication when something's wrong. By connecting to this signal, you can manually choose to tear down the connection from inside the connected slot before the handshake has completed. If no action is taken, QWebSocket will proceed to emitting QWebSocket::sslErrors().\n\nThis function was introduced in Qt 6.2.\n\nPings the server to indicate that the connection is still alive. Additional payload can be sent along the ping message.\n\nThe size of the payload cannot be bigger than 125. If it is larger, the payload is clipped to 125 bytes.\n\nEmitted when a pong message is received in reply to a previous ping. elapsedTime contains the roundtrip time in milliseconds and payload contains an optional payload that was sent with the ping.\n\nThis signal is emitted if the SSL/TLS handshake negotiates a PSK ciphersuite, and therefore a PSK authentication is then required.\n\nWhen using PSK, the client must send to the server a valid identity and a valid pre shared key, in order for the SSL handshake to continue. Applications can provide this information in a slot connected to this signal, by filling in the passed authenticator object according to their needs.\n\nSee also QSslPreSharedKeyAuthenticator and QSslSocket::preSharedKeyAuthenticationRequired().\n\nThis signal can be emitted when a proxy that requires authentication is used. The authenticator object can then be filled in with the required details to allow authentication and continue the connection.\n\nSee also QAuthenticator and QNetworkProxy.\n\nReturns the size in bytes of the readbuffer that is used by the socket.\n\nThis signal is emitted when the input (reading) stream is closed in this device. It is emitted as soon as the closing is detected.\n\nReturns the request that was or will be used to open this socket.\n\nReturns the url the socket is connected to or will connect to.\n\nReturns the name of the resource currently accessed.\n\nContinues data transfer on the socket. This method should only be used after the socket has been set to pause upon notifications and a notification has been received. The only notification currently supported is sslErrors(). Calling this method if the socket is not paused results in undefined behavior.\n\nSee also pauseMode() and setPauseMode().\n\nSends the given data over the socket as a binary message and returns the number of bytes actually sent.\n\nSends the given message over the socket as a text message and returns the number of bytes actually sent.\n\nSets the generator to use for creating masks to maskGenerator. The default QWebSocket generator can be reset by supplying a nullptr. The mask generator can be changed at any time, even while the connection is open.\n\nSets the maximum allowed size of an incoming websocket frame to maxAllowedIncomingFrameSize. If an incoming frame exceeds this limit, the peer gets disconnected. The accepted range is between 0 and maxIncomingFrameSize(), default is maxIncomingFrameSize(). The purpose of this function is to avoid exhausting virtual memory.\n\nSets the maximum allowed size of an incoming websocket message to maxAllowedIncomingMessageSize. If an incoming message exceeds this limit, the peer gets disconnected. The accepted range is between 0 and maxIncomingMessageSize(), default is maxIncomingMessageSize(). The purpose of this function is to avoid exhausting virtual memory.\n\nSets the maximum size of an outgoing websocket frame to outgoingFrameSize. The accepted range is between 0 and maxOutgoingFrameSize(), default is 512kB. The purpose of this function is to adapt to the maximum allowed frame size of the receiver.\n\nControls whether to pause upon receiving a notification. The pauseMode parameter specifies the conditions in which the socket should be paused.\n\nThe only notification currently supported is sslErrors(). If set to PauseOnSslErrors, data transfer on the socket will be paused and needs to be enabled explicitly again by calling resume(). By default, this option is set to PauseNever. This option must be called before connecting to the server, otherwise it will result in undefined behavior.\n\nSee also pauseMode() and resume().\n\nSets the size of QWebSocket's internal read buffer to be size bytes.\n\nIf the buffer size is limited to a certain size, QWebSocket won't buffer more than this size of data. Exceptionally, a buffer size of 0 means that the read buffer is unlimited and all incoming data is buffered. This is the default. This option is useful if you only read the data at certain points in time (for example, in a real-time streaming application) or if you want to protect your socket against receiving too much data, which may eventually cause your application to run out of memory.\n\nSets the socket's SSL configuration to be the contents of sslConfiguration.\n\nThis function sets the local certificate, the ciphers, the private key and the CA certificates to those stored in sslConfiguration. It is not possible to set the SSL-state related fields.\n\nReturns the socket's SSL configuration state. The default SSL configuration of a socket is to use the default ciphers, default CA certificates, no local private key or certificate. The SSL configuration also contains fields that can change with time without notice.\n\nQWebSocket emits this signal after the SSL handshake to indicate that one or more errors have occurred while establishing the identity of the peer. The errors are usually an indication that QWebSocket is unable to securely identify the peer. Unless any action is taken, the connection will be dropped after this signal has been emitted. If you want to continue connecting despite the errors that have occurred, you must call QWebSocket::ignoreSslErrors() from inside a slot connected to this signal. If you need to access the error list at a later point, you can call sslErrors() (without arguments).\n\nerrors contains one or more errors that prevent QWebSocket from verifying the identity of the peer.\n\nReturns the current state of the socket.\n\nThis signal is emitted whenever QWebSocket's state changes. The state parameter is the new state.\n\nQAbstractSocket::SocketState is not a registered metatype, so for queued connections, you will have to register it with Q_REGISTER_METATYPE() and qRegisterMetaType().\n\nThis function was introduced in Qt 6.4.\n\nThis signal is emitted whenever a text frame is received. The frame contains the data and isLastFrame indicates whether this is the last frame of the complete message.\n\nThis signal can be used to process large messages frame by frame, instead of waiting for the complete message to arrive.\n\nThis signal is emitted whenever a text message is received. The message contains the received text.\n\nReturns the version the socket is currently using."
    },
    {
        "link": "https://doc.qt.io/qtforpython-5/PySide2/QtWebSockets/QWebSocket.html",
        "document": "WebSockets is a web technology providing full-duplex communications channels over a single TCP connection. The WebSocket protocol was standardized by the IETF as RFC 6455 in 2011. can both be used in a client application and server application. This class was modeled after . currently does not support WebSocket Extensions and WebSocket Subprotocols . only supports version 13 of the WebSocket protocol, as outlined in RFC 6455 . Some proxies do not understand certain HTTP headers used during a WebSocket handshake. In that case, non-secure WebSocket connections fail. The best way to mitigate against this problem is to use WebSocket over a secure connection. To generate masks, this implementation of WebSockets uses the reasonably secure ->generate() function. For more information about the importance of good masking, see “Talking to Yourself for Fun and Profit” by Lin-Shung Huang et al . The best measure against attacks mentioned in the document above, is to use over a secure connection (wss:// ). In general, always be careful to not have 3rd party script access to a in your application.\n\nCreates a new with the given , the of the protocol to use and . The of the client is as specified in RFC 6454 . (The is not required for non-web browser clients (see RFC 6455 )). The may not contain new line characters, otherwise the connection will be aborted immediately during the handshake phase. Currently only V13 ( RFC 6455 ) is supported\n\nGracefully closes the socket with the given and . Any data in the write buffer is flushed before the socket is closed. The is a indicating the reason to close, and describes the reason of the closure more in detail. All control frames, including the Close frame, are limited to 125 bytes. Since two of these are used for the maximum length of is 123! If exceeds this limit it will be truncated.\n\nThis function writes as much as possible from the internal write buffer to the underlying network socket, without blocking. If any data was written, this function returns true; otherwise false is returned. Call this function if you need to start sending buffered data immediately. The number of bytes successfully written depends on the operating system. In most cases, you do not need to call this function, because will start sending data automatically once control goes back to the event loop.\n\nPings the server to indicate that the connection is still alive. Additional can be sent along the ping message. The size of the cannot be bigger than 125. If it is larger, the is clipped to 125 bytes. and handles ping requests internally, which means they automatically send back a pong response to the peer.\n\nSets the size of ‘s internal read buffer to be bytes. If the buffer size is limited to a certain size, won’t buffer more than this size of data. Exceptionally, a buffer size of 0 means that the read buffer is unlimited and all incoming data is buffered. This is the default. This option is useful if you only read the data at certain points in time (for example, in a real-time streaming application) or if you want to protect your socket against receiving too much data, which may eventually cause your application to run out of memory."
    },
    {
        "link": "https://codebrowser.dev/qt5/qtwebsockets/src/websockets/qwebsocket.cpp.html",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/52179802/how-to-properly-use-qwebsocketsendbinarymessage-method-from-a-c-client",
        "document": "There are C++ Qt client & server. Following code works fine and the connection happens between the client and the server:\n\nWhile sending the binary data, the function returns 0 instead of the number of bytes:\n\nNote that, the works as expected.\n\n We also have a Javascript client. That connects & sends the binary message properly. The only addition in that client is below:\n\nBut such provision is not found in or I may have missed it.\n\nQuestion: How to correctly send the binary data over the web connection?\n\nFor those interested, the server [pseudo] code is like below:"
    },
    {
        "link": "https://qt.developpez.com/doc/6.4/qwebsocket",
        "document": "To generate masks, this implementation of WebSockets uses the reasonably secure QRandomGenerator::global ()->generate() function. For more information about the importance of good masking, see \"Talking to Yourself for Fun and Profit\" by Lin-Shung Huang et al . The best measure against attacks mentioned in the document above, is to use QWebSocket over a secure connection (wss://). In general, always be careful to not have 3rd party script access to a QWebSocket in your application.\n\nSome proxies do not understand certain HTTP headers used during a WebSocket handshake. In that case, non-secure WebSocket connections fail. The best way to mitigate against this problem is to use WebSocket over a secure connection.\n\nQWebSocket only supports version 13 of the WebSocket protocol, as outlined in RFC 6455 .\n\nWebSockets is a web technology providing full-duplex communications channels over a single TCP connection. The WebSocket protocol was standardized by the IETF as RFC 6455 in 2011. QWebSocket can both be used in a client application and server application.\n\nThis signal is emitted if the SSL/TLS handshake negotiates a PSK ciphersuite, and therefore a PSK authentication is then required. When using PSK, the client must send to the server a valid identity and a valid pre shared key, in order for the SSL handshake to continue. Applications can provide this information in a slot connected to this signal, by filling in the passed authenticator object according to their needs. Ignoring this signal, or failing to provide the required credentials, will cause the handshake to fail, and therefore the connection to be aborted. The authenticator object is owned by the websocket and must not be deleted by the application. This function was introduced in Qt 5.8."
    },
    {
        "link": "https://doc.qt.io/qt-6/qwebsocket.html",
        "document": "Implements a TCP socket that talks the WebSocket protocol. More...\n\nWarning: To generate masks, this implementation of WebSockets uses the reasonably secure QRandomGenerator::global ()->generate() function. For more information about the importance of good masking, see \"Talking to Yourself for Fun and Profit\" by Lin-Shung Huang et al . The best measure against attacks mentioned in the document above, is to use QWebSocket over a secure connection ( wss:// ). In general, always be careful to not have 3rd party script access to a QWebSocket in your application.\n\nNote: Some proxies do not understand certain HTTP headers used during a WebSocket handshake. In that case, non-secure WebSocket connections fail. The best way to mitigate against this problem is to use WebSocket over a secure connection.\n\nQWebSocket only supports version 13 of the WebSocket protocol, as outlined in RFC 6455 .\n\nWebSockets is a web technology providing full-duplex communications channels over a single TCP connection. The WebSocket protocol was standardized by the IETF as RFC 6455 in 2011. QWebSocket can both be used in a client application and server application.\n\nSee also QAbstractSocket, QTcpSocket, and QWebSocket client example.\n\nCreates a new QWebSocket with the given origin, the version of the protocol to use and parent.\n\nThe origin of the client is as specified in RFC 6454. (The origin is not required for non-web browser clients (see RFC 6455)). The origin may not contain new line characters, otherwise the connection will be aborted immediately during the handshake phase.\n\nDestroys the QWebSocket. Closes the socket if it is still open, and releases any used resources.\n\nAborts the current socket and resets the socket. Unlike close(), this function immediately closes the socket, discarding any pending data in the write buffer.\n\nThis signal is emitted when the socket is about to close. Connect this signal if you have operations that need to be performed before the socket closes (e.g., if you have data in a separate buffer that needs to be written to the device).\n\nQWebSocket emits this signal if an alert message was received from a peer. level tells if the alert was fatal or it was a warning. type is the code explaining why the alert was sent. When a textual description of the alert message is available, it is supplied in description.\n\nThis function was introduced in Qt 6.2.\n\nSee also alertSent(), QSsl::AlertLevel, and QSsl::AlertType.\n\nQWebSocket emits this signal if an alert message was sent to a peer. level describes if it was a warning or a fatal error. type gives the code of the alert message. When a textual description of the alert message is available, it is supplied in description.\n\nThis function was introduced in Qt 6.2.\n\nSee also alertReceived(), QSsl::AlertLevel, and QSsl::AlertType.\n\nThis signal is emitted when the server requires authentication. The authenticator object must then be filled in with the required details to allow authentication and continue the connection.\n\nIf you know that the server may require authentication, you can set the username and password on the initial QUrl, using QUrl::setUserName and QUrl::setPassword. QWebSocket will still try to connect once without using the provided credentials.\n\nThis function was introduced in Qt 6.6.\n\nThis signal is emitted whenever a binary frame is received. The frame contains the data and isLastFrame indicates whether this is the last frame of the complete message.\n\nThis signal can be used to process large messages frame by frame, instead of waiting for the complete message to arrive.\n\nThis signal is emitted whenever a binary message is received. The message contains the received bytes.\n\nReturns the number of bytes that are waiting to be written. The bytes are written when control goes back to the event loop or when flush() is called.\n\nThis signal is emitted every time a payload of data has been written to the socket. The bytes argument is set to the number of bytes that were written in this payload.\n\nGracefully closes the socket with the given closeCode and reason.\n\nAny data in the write buffer is flushed before the socket is closed. The closeCode is a QWebSocketProtocol::CloseCode indicating the reason to close, and reason describes the reason of the closure more in detail. All control frames, including the Close frame, are limited to 125 bytes. Since two of these are used for closeCode the maximum length of reason is 123! If reason exceeds this limit it will be truncated.\n\nReturns the code indicating why the socket was closed.\n\nSee also QWebSocketProtocol::CloseCode and closeReason().\n\nReturns the reason why the socket was closed.\n\nEmitted when a connection is successfully established. A connection is successfully established when the socket is connected and the handshake was successful.\n\nSee also open() and disconnected().\n\nIf an application wants to conclude a handshake even after receiving handshakeInterruptedOnError() signal, it must call this function. This call must be done from a slot function attached to the signal. The signal-slot connection must be direct.\n\nThis function was introduced in Qt 6.2.\n\nSee also handshakeInterruptedOnError() and QSslConfiguration::setHandshakeMustInterruptOnError().\n\nEmitted when the socket is disconnected.\n\nSee also close() and connected().\n\nReturns the type of error that last occurred\n\nThis signal is emitted after an error occurred.\n\nThe error parameter describes the type of error that occurred.\n\nQAbstractSocket::SocketError is not a registered metatype, so for queued connections, you will have to register it with Q_DECLARE_METATYPE() and qRegisterMetaType().\n\nThis function was introduced in Qt 6.5.\n\nSee also error() and errorString().\n\nReturns a human-readable description of the last error that occurred\n\nThis function writes as much as possible from the internal write buffer to the underlying network socket, without blocking. If any data was written, this function returns true; otherwise false is returned. Call this function if you need QWebSocket to start sending buffered data immediately. The number of bytes successfully written depends on the operating system. In most cases, you do not need to call this function, because QWebSocket will start sending data automatically once control goes back to the event loop.\n\nQWebSocket emits this signal if a certificate verification error was found and if early error reporting was enabled in QSslConfiguration. An application is expected to inspect the error and decide if it wants to continue the handshake, or abort it and send an alert message to the peer. The signal-slot connection must be direct.\n\nThis function was introduced in Qt 6.2.\n\nSee also continueInterruptedHandshake(), sslErrors(), and QSslConfiguration::setHandshakeMustInterruptOnError().\n\nReturns the handshake options that were used to open this socket.\n\nThis function was introduced in Qt 6.4.\n\nThis slot tells QWebSocket to ignore errors during QWebSocket's handshake phase and continue connecting. If you want to continue with the connection even if errors occur during the handshake phase, then you must call this slot, either from a slot connected to sslErrors(), or before the handshake phase. If you don't call this slot, either in response to errors or before the handshake, the connection will be dropped after the sslErrors() signal has been emitted.\n\nSee also sslErrors(), QSslSocket::ignoreSslErrors(), and QNetworkReply::ignoreSslErrors().\n\nThis is an overloaded function.\n\nThis method tells QWebSocket to ignore the errors given in errors.\n\nNote that you can set the expected certificate in the SSL error: If, for instance, you want to connect to a server that uses a self-signed certificate, consider the following snippet:\n\nMultiple calls to this function will replace the list of errors that were passed in previous calls. You can clear the list of errors you want to ignore by calling this function with an empty list.\n\nReturns if the socket is ready for reading and writing; otherwise returns .\n\nReturns the mask generator that is currently used by this QWebSocket.\n\nReturns the maximum allowed size of an incoming websocket frame.\n\nReturns the maximum allowed size of an incoming websocket message.\n\nReturns the maximum supported size of an incoming websocket frame for this websocket implementation.\n\nReturns the maximum supported size of an incoming websocket message for this websocket implementation.\n\nReturns the maximum supported size of an outgoing websocket frame for this websocket implementation.\n\nOpens a WebSocket connection using the given request.\n\nThe request url will be used to open the WebSocket connection. Headers present in the request will be sent to the server in the upgrade request, together with the ones needed for the websocket handshake.\n\nOpens a WebSocket connection using the given url.\n\nIf the url contains newline characters (\\r\n\n), then the error signal will be emitted with QAbstractSocket::ConnectionRefusedError as error type.\n\nOpens a WebSocket connection using the given request and options.\n\nThe request url will be used to open the WebSocket connection. Headers present in the request will be sent to the server in the upgrade request, together with the ones needed for the websocket handshake.\n\nAdditional options for the WebSocket handshake such as subprotocols can be specified in options.\n\nThis function was introduced in Qt 6.4.\n\nOpens a WebSocket connection using the given url and options.\n\nIf the url contains newline characters (\\r\n\n), then the error signal will be emitted with QAbstractSocket::ConnectionRefusedError as error type.\n\nAdditional options for the WebSocket handshake such as subprotocols can be specified in options.\n\nThis function was introduced in Qt 6.4.\n\nReturns the maximum size of an outgoing websocket frame.\n\nReturns the pause mode of this socket\n\nQWebSocket can emit this signal several times during the SSL handshake, before encryption has been established, to indicate that an error has occurred while establishing the identity of the peer. The error is usually an indication that QWebSocket is unable to securely identify the peer.\n\nThis signal provides you with an early indication when something's wrong. By connecting to this signal, you can manually choose to tear down the connection from inside the connected slot before the handshake has completed. If no action is taken, QWebSocket will proceed to emitting QWebSocket::sslErrors().\n\nThis function was introduced in Qt 6.2.\n\nPings the server to indicate that the connection is still alive. Additional payload can be sent along the ping message.\n\nThe size of the payload cannot be bigger than 125. If it is larger, the payload is clipped to 125 bytes.\n\nEmitted when a pong message is received in reply to a previous ping. elapsedTime contains the roundtrip time in milliseconds and payload contains an optional payload that was sent with the ping.\n\nThis signal is emitted if the SSL/TLS handshake negotiates a PSK ciphersuite, and therefore a PSK authentication is then required.\n\nWhen using PSK, the client must send to the server a valid identity and a valid pre shared key, in order for the SSL handshake to continue. Applications can provide this information in a slot connected to this signal, by filling in the passed authenticator object according to their needs.\n\nSee also QSslPreSharedKeyAuthenticator and QSslSocket::preSharedKeyAuthenticationRequired().\n\nThis signal can be emitted when a proxy that requires authentication is used. The authenticator object can then be filled in with the required details to allow authentication and continue the connection.\n\nSee also QAuthenticator and QNetworkProxy.\n\nReturns the size in bytes of the readbuffer that is used by the socket.\n\nThis signal is emitted when the input (reading) stream is closed in this device. It is emitted as soon as the closing is detected.\n\nReturns the request that was or will be used to open this socket.\n\nReturns the url the socket is connected to or will connect to.\n\nReturns the name of the resource currently accessed.\n\nContinues data transfer on the socket. This method should only be used after the socket has been set to pause upon notifications and a notification has been received. The only notification currently supported is sslErrors(). Calling this method if the socket is not paused results in undefined behavior.\n\nSee also pauseMode() and setPauseMode().\n\nSends the given data over the socket as a binary message and returns the number of bytes actually sent.\n\nSends the given message over the socket as a text message and returns the number of bytes actually sent.\n\nSets the generator to use for creating masks to maskGenerator. The default QWebSocket generator can be reset by supplying a nullptr. The mask generator can be changed at any time, even while the connection is open.\n\nSets the maximum allowed size of an incoming websocket frame to maxAllowedIncomingFrameSize. If an incoming frame exceeds this limit, the peer gets disconnected. The accepted range is between 0 and maxIncomingFrameSize(), default is maxIncomingFrameSize(). The purpose of this function is to avoid exhausting virtual memory.\n\nSets the maximum allowed size of an incoming websocket message to maxAllowedIncomingMessageSize. If an incoming message exceeds this limit, the peer gets disconnected. The accepted range is between 0 and maxIncomingMessageSize(), default is maxIncomingMessageSize(). The purpose of this function is to avoid exhausting virtual memory.\n\nSets the maximum size of an outgoing websocket frame to outgoingFrameSize. The accepted range is between 0 and maxOutgoingFrameSize(), default is 512kB. The purpose of this function is to adapt to the maximum allowed frame size of the receiver.\n\nControls whether to pause upon receiving a notification. The pauseMode parameter specifies the conditions in which the socket should be paused.\n\nThe only notification currently supported is sslErrors(). If set to PauseOnSslErrors, data transfer on the socket will be paused and needs to be enabled explicitly again by calling resume(). By default, this option is set to PauseNever. This option must be called before connecting to the server, otherwise it will result in undefined behavior.\n\nSee also pauseMode() and resume().\n\nSets the size of QWebSocket's internal read buffer to be size bytes.\n\nIf the buffer size is limited to a certain size, QWebSocket won't buffer more than this size of data. Exceptionally, a buffer size of 0 means that the read buffer is unlimited and all incoming data is buffered. This is the default. This option is useful if you only read the data at certain points in time (for example, in a real-time streaming application) or if you want to protect your socket against receiving too much data, which may eventually cause your application to run out of memory.\n\nSets the socket's SSL configuration to be the contents of sslConfiguration.\n\nThis function sets the local certificate, the ciphers, the private key and the CA certificates to those stored in sslConfiguration. It is not possible to set the SSL-state related fields.\n\nReturns the socket's SSL configuration state. The default SSL configuration of a socket is to use the default ciphers, default CA certificates, no local private key or certificate. The SSL configuration also contains fields that can change with time without notice.\n\nQWebSocket emits this signal after the SSL handshake to indicate that one or more errors have occurred while establishing the identity of the peer. The errors are usually an indication that QWebSocket is unable to securely identify the peer. Unless any action is taken, the connection will be dropped after this signal has been emitted. If you want to continue connecting despite the errors that have occurred, you must call QWebSocket::ignoreSslErrors() from inside a slot connected to this signal. If you need to access the error list at a later point, you can call sslErrors() (without arguments).\n\nerrors contains one or more errors that prevent QWebSocket from verifying the identity of the peer.\n\nReturns the current state of the socket.\n\nThis signal is emitted whenever QWebSocket's state changes. The state parameter is the new state.\n\nQAbstractSocket::SocketState is not a registered metatype, so for queued connections, you will have to register it with Q_REGISTER_METATYPE() and qRegisterMetaType().\n\nThis function was introduced in Qt 6.4.\n\nThis signal is emitted whenever a text frame is received. The frame contains the data and isLastFrame indicates whether this is the last frame of the complete message.\n\nThis signal can be used to process large messages frame by frame, instead of waiting for the complete message to arrive.\n\nThis signal is emitted whenever a text message is received. The message contains the received text.\n\nReturns the version the socket is currently using."
    },
    {
        "link": "https://stackoverflow.com/questions/7816955/websocket-binary-frame-example",
        "document": "Jetty has supported binary frames in WebSockets since at least version 7.5.2. Here is a Jetty example that includes binary frames: https://www.eclipse.org/jetty/documentation/9.4.x/jetty-websocket-api-send-message.html\n\nFrom the server point of view, there is very little difference between sending and receiving binary data, it's just a single opcode change. When sending text, you are limited to UTF-8 encoded data. With binary you don't have that limit.\n\nFrom the browser point of view, if the browser supports binary data (which really only very recent builds of Chrome support) then sending binary data involves sending an arraybuffer or blob using the method on the WebSocket object. Receiving binary data happens automatically if the server sends a binary frame. However, you can select between receiving blobs or arraybuffers by setting the property on your WebSocket object instance."
    },
    {
        "link": "https://forum.qt.io/topic/78020/handle-arraybuffer-received-via-websocket-s-binarymessagereceived-with-qml",
        "document": "I can't find any information getting even close to what I'm looking for - hope someone can be of help.\n\nI'm trying to receive an image sent from C++ as ByteArray via WebSockets in a QML app.\n\nSince there is a newly added (in Qt 5.8) Signal for the WebSocket QML Type that should do just that, I figured I'd use it (see http://doc-snapshots.qt.io/qt5-dev/qml-qtwebsockets-websocket.html#binaryMessageReceived-signal - beware the documentation error, the binaryMessageReceived Signal has an ArrayBuffer as parameter and not a QString, as reported: https://bugreports.qt.io/browse/QTBUG-57906).\n\nHowever, I have no idea how to handle the ArrayBuffer / binary message that is received in order to show it in a QML object (Image ? Canvas ?).\n\nCan anyone explain to me how this can be done ?\n\nThanks for your help !\n\n Daniel"
    },
    {
        "link": "https://felgo.com/doc/qt/qwebsocket",
        "document": "Implements a TCP socket that talks the WebSocket protocol. More...\n\nWarning: To generate masks, this implementation of WebSockets uses the reasonably secure QRandomGenerator::global ()->generate() function. For more information about the importance of good masking, see \"Talking to Yourself for Fun and Profit\" by Lin-Shung Huang et al . The best measure against attacks mentioned in the document above, is to use QWebSocket over a secure connection ( wss:// ). In general, always be careful to not have 3rd party script access to a QWebSocket in your application.\n\nNote: Some proxies do not understand certain HTTP headers used during a WebSocket handshake. In that case, non-secure WebSocket connections fail. The best way to mitigate against this problem is to use WebSocket over a secure connection.\n\nQWebSocket only supports version 13 of the WebSocket protocol, as outlined in RFC 6455 .\n\nWebSockets is a web technology providing full-duplex communications channels over a single TCP connection. The WebSocket protocol was standardized by the IETF as RFC 6455 in 2011. QWebSocket can both be used in a client application and server application.\n\nSee also QAbstractSocket, QTcpSocket, and QWebSocket client example.\n\nCreates a new QWebSocket with the given origin, the version of the protocol to use and parent.\n\nThe origin of the client is as specified in RFC 6454. (The origin is not required for non-web browser clients (see RFC 6455)). The origin may not contain new line characters, otherwise the connection will be aborted immediately during the handshake phase.\n\nThis signal is emitted when the socket is about to close. Connect this signal if you have operations that need to be performed before the socket closes (e.g., if you have data in a separate buffer that needs to be written to the device).\n\nQWebSocket emits this signal if an alert message was received from a peer. level tells if the alert was fatal or it was a warning. type is the code explaining why the alert was sent. When a textual description of the alert message is available, it is supplied in description.\n\nThis function was introduced in Qt 6.2.\n\nSee also alertSent(), QSsl::AlertLevel, and QSsl::AlertType.\n\nQWebSocket emits this signal if an alert message was sent to a peer. level describes if it was a warning or a fatal error. type gives the code of the alert message. When a textual description of the alert message is available, it is supplied in description.\n\nThis function was introduced in Qt 6.2.\n\nSee also alertReceived(), QSsl::AlertLevel, and QSsl::AlertType.\n\nThis signal is emitted whenever a binary frame is received. The frame contains the data and isLastFrame indicates whether this is the last frame of the complete message.\n\nThis signal can be used to process large messages frame by frame, instead of waiting for the complete message to arrive.\n\nThis signal is emitted whenever a binary message is received. The message contains the received bytes.\n\nThis signal is emitted every time a payload of data has been written to the socket. The bytes argument is set to the number of bytes that were written in this payload.\n\nGracefully closes the socket with the given closeCode and reason.\n\nAny data in the write buffer is flushed before the socket is closed. The closeCode is a QWebSocketProtocol::CloseCode indicating the reason to close, and reason describes the reason of the closure more in detail. All control frames, including the Close frame, are limited to 125 bytes. Since two of these are used for closeCode the maximum length of reason is 123! If reason exceeds this limit it will be truncated.\n\nEmitted when a connection is successfully established. A connection is successfully established when the socket is connected and the handshake was successful.\n\nSee also open() and disconnected().\n\nEmitted when the socket is disconnected.\n\nSee also close() and connected().\n\nThis signal is emitted after an error occurred. The error parameter describes the type of error that occurred.\n\nQAbstractSocket::SocketError is not a registered metatype, so for queued connections, you will have to register it with Q_DECLARE_METATYPE() and qRegisterMetaType().\n\nNote: Signal error is overloaded in this class. To connect to this signal by using the function pointer syntax, Qt provides a convenient helper for obtaining the function pointer as shown in this example:\n\nSee also error() and errorString().\n\nQWebSocket emits this signal if a certificate verification error was found and if early error reporting was enabled in QSslConfiguration. An application is expected to inspect the error and decide if it wants to continue the handshake, or abort it and send an alert message to the peer. The signal-slot connection must be direct.\n\nThis function was introduced in Qt 6.2.\n\nSee also continueInterruptedHandshake(), sslErrors(), and QSslConfiguration::setHandshakeMustInterruptOnError().\n\nThis slot tells QWebSocket to ignore errors during QWebSocket's handshake phase and continue connecting. If you want to continue with the connection even if errors occur during the handshake phase, then you must call this slot, either from a slot connected to sslErrors(), or before the handshake phase. If you don't call this slot, either in response to errors or before the handshake, the connection will be dropped after the sslErrors() signal has been emitted.\n\nSee also sslErrors(), QSslSocket::ignoreSslErrors(), and QNetworkReply::ignoreSslErrors().\n\nOpens a WebSocket connection using the given request and options.\n\nThe request url will be used to open the WebSocket connection. Headers present in the request will be sent to the server in the upgrade request, together with the ones needed for the websocket handshake.\n\nAdditional options for the WebSocket handshake such as subprotocols can be specified in options.\n\nThis function was introduced in Qt 6.4.\n\nOpens a WebSocket connection using the given url and options.\n\nIf the url contains newline characters (\\r\n\n), then the error signal will be emitted with QAbstractSocket::ConnectionRefusedError as error type.\n\nAdditional options for the WebSocket handshake such as subprotocols can be specified in options.\n\nThis function was introduced in Qt 6.4.\n\nOpens a WebSocket connection using the given request.\n\nThe request url will be used to open the WebSocket connection. Headers present in the request will be sent to the server in the upgrade request, together with the ones needed for the websocket handshake.\n\nThis function was introduced in Qt 5.6.\n\nOpens a WebSocket connection using the given url.\n\nIf the url contains newline characters (\\r\n\n), then the error signal will be emitted with QAbstractSocket::ConnectionRefusedError as error type.\n\nQWebSocket can emit this signal several times during the SSL handshake, before encryption has been established, to indicate that an error has occurred while establishing the identity of the peer. The error is usually an indication that QWebSocket is unable to securely identify the peer.\n\nThis signal provides you with an early indication when something's wrong. By connecting to this signal, you can manually choose to tear down the connection from inside the connected slot before the handshake has completed. If no action is taken, QWebSocket will proceed to emitting QWebSocket::sslErrors().\n\nThis function was introduced in Qt 6.2.\n\nPings the server to indicate that the connection is still alive. Additional payload can be sent along the ping message.\n\nThe size of the payload cannot be bigger than 125. If it is larger, the payload is clipped to 125 bytes.\n\nEmitted when a pong message is received in reply to a previous ping. elapsedTime contains the roundtrip time in milliseconds and payload contains an optional payload that was sent with the ping.\n\nThis signal is emitted if the SSL/TLS handshake negotiates a PSK ciphersuite, and therefore a PSK authentication is then required.\n\nWhen using PSK, the client must send to the server a valid identity and a valid pre shared key, in order for the SSL handshake to continue. Applications can provide this information in a slot connected to this signal, by filling in the passed authenticator object according to their needs.\n\nThis function was introduced in Qt 5.8.\n\nSee also QSslPreSharedKeyAuthenticator and QSslSocket::preSharedKeyAuthenticationRequired().\n\nThis signal can be emitted when a proxy that requires authentication is used. The authenticator object can then be filled in with the required details to allow authentication and continue the connection.\n\nSee also QAuthenticator and QNetworkProxy.\n\nThis signal is emitted when the input (reading) stream is closed in this device. It is emitted as soon as the closing is detected.\n\nQWebSocket emits this signal after the SSL handshake to indicate that one or more errors have occurred while establishing the identity of the peer. The errors are usually an indication that QWebSocket is unable to securely identify the peer. Unless any action is taken, the connection will be dropped after this signal has been emitted. If you want to continue connecting despite the errors that have occurred, you must call QWebSocket::ignoreSslErrors() from inside a slot connected to this signal. If you need to access the error list at a later point, you can call sslErrors() (without arguments).\n\nerrors contains one or more errors that prevent QWebSocket from verifying the identity of the peer.\n\nThis signal is emitted whenever QWebSocket's state changes. The state parameter is the new state.\n\nQAbstractSocket::SocketState is not a registered metatype, so for queued connections, you will have to register it with Q_REGISTER_METATYPE() and qRegisterMetaType().\n\nThis signal is emitted whenever a text frame is received. The frame contains the data and isLastFrame indicates whether this is the last frame of the complete message.\n\nThis signal can be used to process large messages frame by frame, instead of waiting for the complete message to arrive.\n\nThis signal is emitted whenever a text message is received. The message contains the received text.\n\nDestroys the QWebSocket. Closes the socket if it is still open, and releases any used resources.\n\nAborts the current socket and resets the socket. Unlike close(), this function immediately closes the socket, discarding any pending data in the write buffer.\n\nReturns the number of bytes that are waiting to be written. The bytes are written when control goes back to the event loop or when flush() is called.\n\nThis function was introduced in Qt 5.12.\n\nReturns the code indicating why the socket was closed.\n\nSee also QWebSocketProtocol::CloseCode and closeReason().\n\nReturns the reason why the socket was closed.\n\nIf an application wants to conclude a handshake even after receiving handshakeInterruptedOnError() signal, it must call this function. This call must be done from a slot function attached to the signal. The signal-slot connection must be direct.\n\nThis function was introduced in Qt 6.2.\n\nSee also handshakeInterruptedOnError() and QSslConfiguration::setHandshakeMustInterruptOnError().\n\nReturns the type of error that last occurred\n\nReturns a human-readable description of the last error that occurred\n\nThis function writes as much as possible from the internal write buffer to the underlying network socket, without blocking. If any data was written, this function returns true; otherwise false is returned. Call this function if you need QWebSocket to start sending buffered data immediately. The number of bytes successfully written depends on the operating system. In most cases, you do not need to call this function, because QWebSocket will start sending data automatically once control goes back to the event loop.\n\nReturns the handshake options that were used to open this socket.\n\nThis function was introduced in Qt 6.4.\n\nThis is an overloaded function.\n\nThis method tells QWebSocket to ignore the errors given in errors.\n\nNote that you can set the expected certificate in the SSL error: If, for instance, you want to connect to a server that uses a self-signed certificate, consider the following snippet:\n\nMultiple calls to this function will replace the list of errors that were passed in previous calls. You can clear the list of errors you want to ignore by calling this function with an empty list.\n\nReturns if the socket is ready for reading and writing; otherwise returns .\n\nReturns the mask generator that is currently used by this QWebSocket.\n\nReturns the maximum allowed size of an incoming websocket frame.\n\nThis function was introduced in Qt 5.15.\n\nReturns the maximum allowed size of an incoming websocket message.\n\nThis function was introduced in Qt 5.15.\n\nReturns the maximum supported size of an incoming websocket frame for this websocket implementation.\n\nThis function was introduced in Qt 5.15.\n\nReturns the maximum supported size of an incoming websocket message for this websocket implementation.\n\nThis function was introduced in Qt 5.15.\n\nReturns the maximum supported size of an outgoing websocket frame for this websocket implementation.\n\nThis function was introduced in Qt 5.15.\n\nReturns the maximum size of an outgoing websocket frame.\n\nThis function was introduced in Qt 5.15.\n\nReturns the pause mode of this socket\n\nReturns the size in bytes of the readbuffer that is used by the socket.\n\nReturns the request that was or will be used to open this socket.\n\nThis function was introduced in Qt 5.6.\n\nReturns the url the socket is connected to or will connect to.\n\nReturns the name of the resource currently accessed.\n\nContinues data transfer on the socket. This method should only be used after the socket has been set to pause upon notifications and a notification has been received. The only notification currently supported is sslErrors(). Calling this method if the socket is not paused results in undefined behavior.\n\nSee also pauseMode() and setPauseMode().\n\nSends the given data over the socket as a binary message and returns the number of bytes actually sent.\n\nSends the given message over the socket as a text message and returns the number of bytes actually sent.\n\nSets the generator to use for creating masks to maskGenerator. The default QWebSocket generator can be reset by supplying a nullptr. The mask generator can be changed at any time, even while the connection is open.\n\nSets the maximum allowed size of an incoming websocket frame to maxAllowedIncomingFrameSize. If an incoming frame exceeds this limit, the peer gets disconnected. The accepted range is between 0 and maxIncomingFrameSize(), default is maxIncomingFrameSize(). The purpose of this function is to avoid exhausting virtual memory.\n\nThis function was introduced in Qt 5.15.\n\nSets the maximum allowed size of an incoming websocket message to maxAllowedIncomingMessageSize. If an incoming message exceeds this limit, the peer gets disconnected. The accepted range is between 0 and maxIncomingMessageSize(), default is maxIncomingMessageSize(). The purpose of this function is to avoid exhausting virtual memory.\n\nThis function was introduced in Qt 5.15.\n\nSets the maximum size of an outgoing websocket frame to outgoingFrameSize. The accepted range is between 0 and maxOutgoingFrameSize(), default is 512kB. The purpose of this function is to adapt to the maximum allowed frame size of the receiver.\n\nThis function was introduced in Qt 5.15.\n\nControls whether to pause upon receiving a notification. The pauseMode parameter specifies the conditions in which the socket should be paused.\n\nThe only notification currently supported is sslErrors(). If set to PauseOnSslErrors, data transfer on the socket will be paused and needs to be enabled explicitly again by calling resume(). By default, this option is set to PauseNever. This option must be called before connecting to the server, otherwise it will result in undefined behavior.\n\nSee also pauseMode() and resume().\n\nSets the size of QWebSocket's internal read buffer to be size bytes.\n\nIf the buffer size is limited to a certain size, QWebSocket won't buffer more than this size of data. Exceptionally, a buffer size of 0 means that the read buffer is unlimited and all incoming data is buffered. This is the default. This option is useful if you only read the data at certain points in time (for example, in a real-time streaming application) or if you want to protect your socket against receiving too much data, which may eventually cause your application to run out of memory.\n\nSets the socket's SSL configuration to be the contents of sslConfiguration.\n\nThis function sets the local certificate, the ciphers, the private key and the CA certificates to those stored in sslConfiguration. It is not possible to set the SSL-state related fields.\n\nReturns the socket's SSL configuration state. The default SSL configuration of a socket is to use the default ciphers, default CA certificates, no local private key or certificate. The SSL configuration also contains fields that can change with time without notice.\n\nReturns the current state of the socket.\n\nThis function was introduced in Qt 6.4.\n\nReturns the version the socket is currently using."
    },
    {
        "link": "https://stackoverflow.com/questions/52179802/how-to-properly-use-qwebsocketsendbinarymessage-method-from-a-c-client",
        "document": "There are C++ Qt client & server. Following code works fine and the connection happens between the client and the server:\n\nWhile sending the binary data, the function returns 0 instead of the number of bytes:\n\nNote that, the works as expected.\n\n We also have a Javascript client. That connects & sends the binary message properly. The only addition in that client is below:\n\nBut such provision is not found in or I may have missed it.\n\nQuestion: How to correctly send the binary data over the web connection?\n\nFor those interested, the server [pseudo] code is like below:"
    },
    {
        "link": "https://stackoverflow.com/questions/31683318/websocket-frame-fragmentation-in-an-api",
        "document": "Would exposing a WebSocket fragmentation have any value in a client-side API?\n\nReading the RFC 6455 I became convinced a non-continuation frame doesn't guarantee you anything in terms of its semantics. One shouldn't rely on frame boundaries. It's just too risky. The spec addresses this explicitly:\n\nThus receiving a non-continuation frame of type Binary or Text doesn't mean it's something atomic and meaningful that has been sent from the other side of the channel. Similarly a sequence of continuation frames doesn't mean that coalescing them will yield a meaningful message. And what's even more upsetting, a single non-continuation type frame may be a result of coalescing many other frames.\n\nTo sum up, groups of bytes sent over the WebSocket may be received regrouped pretty much any way, given the byte order is the same (that's of course in absence of extensions).\n\nIf so, then is it useful to introduce this concept at all? Maybe it's better to hide it as a detail of implementation? I wonder if WebSocket users have found it useful in such products like Netty, Jetty, Grizzly, etc. Thanks."
    },
    {
        "link": "https://stackoverflow.com/questions/23880906/websocket-questions-framing-masking",
        "document": "The payload sent from client to server (not server to client) is masked neither for reasons of data integrity nor authenticity, but to prevent rogue scripts from confusing (and potentially attacking) old intermediaries (Web proxies and the like).\n\nAny WebSocket client that conforms to RFC6455 MUST mask client-to-server frames. Nevertheless, some libraries allow you to turn off masking for client, and turn off failing on non-masked client frames (e.g. AutobahnPython).\n\nThe latter can be useful to elimit the CPU overhead associated with masking. It may be acceptable when both endpoints are under your control and either the route between both are fully under your control (e.g. talking WebSocket over loopback or Unix domain sockets or LAN) or you are using TLS, and hence (in most situations) no intermediary will be able to look inside the traffic anyway.\n\nFragmentation works like this: a WebSocket message may be split into multiple WebSocket frames - and also coalesced any time not only by the sender, but also any intermedaries on the way to the receiver. And yes, only the last WebSocket frame of a sequence of frames for a given message will have the bit set."
    },
    {
        "link": "https://openmymind.net/WebSocket-Framing-Masking-Fragmentation-and-More",
        "document": "The above diagram, taken from RFC 6455 The WebSocket Protocol, describes a WebSocket frame.\n\nThe smallest valid full WebSocket message is two bytes, such as this close message sent from the server with no payload: . Yet the longest possible header is 14 bytes, which would represent a message sent from the client to the server with a payload greater then 64KB.\n\nSending \"over9000\" from the client to the server will be 14 bytes with a seemingly random last 12 bytes, something like . Yet that same message sent from the server to the client will always be these exact 10 bytes: .\n\nWhy is the longest possible header longer than the shortest possible message? Why does a message sent from the client to the server look so different than the same message sent from the server to the client? And, are there any other WebSocket oddities?\n\nAs a stream-oriented protocol, TCP has no concept of messages (or framing). It's just a sequence of bytes. If one side uses the function four times, the other side might get those bytes across 1-N calls to , where N will be the total number of bytes sent (i.e. where each read only reads a single byte). Solutions that sit on top of TCP, like WebSockets, have to provide their own framing. One common solution is to length prefix every message. For example, if we wanted to send two messages, and , using a 2-byte length prefix, we'd send: \n\n \n\nand, \n\n .\n\nWebSocket uses the first 7 bits of its 2nd byte to support a variable-length length prefix. When those bits are equal or less than 125, then the length of the payload is this value itself. When the bits equal 126, then the next 2 bytes indicate the length of the payload. When the bits equal 127, the next 8 bytes indicate the length of the payload.\n\nFor example, if we wanted to send \"hello\", then the 2nd byte would contain all the length data needed, namely: . But if we wanted to send a payload that was 300 bytes long, then we'd get which would tell us to look at the next two bytes to get the length of the payload, in this case, they'd be (i.e. 256 + 44).\n\nThe benefit of having this variable length length-prefix is that messages with payloads that are 125 bytes or less only require a single byte. However, messages greater than 125 bytes and less than 64K will require 3 bytes (like the 300 byte example we just saw: ). Larger messages require 9 bytes (with followed by an 8-byte length).\n\nI'd prefer a fixed 4-byte length prefix. I think it's safe to assume that most WebSocket messages are less than 16K, so this would mean most messages would be 1 byte larger. For small message, it would be 3 bytes longer. But a fixed-length length would be easier to deal with and have fewer error cases. I can't help but wonder if that 1 byte is worth those extra if statements and error cases.\n\nFollowing the length portion of our frame is a 4-byte mask. From the specification: \"The masking key needs to be unpredictable; thus, the masking key MUST be derived from a strong source of entropy, and the masking key for a given frame MUST NOT make it simple for a server/proxy to predict the masking key for a subsequent frame\".\n\nMasking is a security feature that's meant to thwart malicious client-side code from having control over the exact sequence of bytes which appear on the wire. Section 10.3 has more details.\n\nThe mask and payload are XOR together before being sent from the client to the server, and thus the server must reverse this. The byte value of \"hello\" (in ASCII/UTF-8) is . But masked with , it becomes: \n\n \n\nor, if you prefer: \n\n\n\nSince the 4-byte mask is sent as part of every client-initiated message, the server just reverses the process to get the unmasked payload ( ).\n\nI have no idea of how important masking is in 2022. Maybe the threat is more serious than ever. Maybe browser security or WebSocket support have changed that WebSocket security should be re-evaluated. I don't know. But if you control the client and the server, and you're not concerned about malicious client-side code (like a desktop app), you could break the cryptographic requirements of the specification, while keeping the WebSocket frame valid, with a mask of . The server could detect this mask and skip the unmasking step. But make sure you know what you're doing - I don't.\n\nA bit more annoying is that ALL messages from the client to the server MUST include a mask and the payloads must be masked (even messages with no payload must include the mask). And all messages from the server to the client MUST NOT be masked. Yet despite these strict requirements, the most-significant bit of our 2nd byte (remember, that length-byte which only used the 7 first bits?) is used to indicate whether or not a mask is present. This seems 100% redundant to me and only serves to introduce error cases.\n\nA WebSocket frame can be one of 6 types: , , , , and . Furthermore, every frame is either a frame or not. The first byte of each frame is used to represent the type of frame (known as the op code) as well as whether or not it's a frame.\n\nWe'll talk more about and next.\n\nThe difference between and is that text must be valid UTF-8. I don't care for this distinction at a protocol level. It's wasted processing. If you care about UTF-8 validity, you'll probably check it again within your application (like when you try to decode the payload as JSON). So, use where possible just to avoid that check (especially on those 2 exabyte messages!).\n\nand are also, in my opinion, unnecessary. Like , it's better to handle this directly in application.\n\nI do like the type though. It has specific requirements around the payload (if a payload is present). Specifically, it requires the first two bytes of the payload to be a close code. It's useful for debugging.\n\nWebSocket has support for frame-fragmentation. One message can be sent across multiple frames. Given that WebSocket support 8-byte length prefixes (or exabyte-sized message), you might be wondering what this is for. I believe it exists for 3 reason, none of which you'll see very often.\n\nThe first case has to do with streaming, where the server doesn't have the full payload, doesn't know the final length, but still wants to send some data. The 2nd case has to do with being able to interrupt a large message with special control frames, such as ping (more on this later). The 3rd, a meta-reason I think, is that proxies are free to fragment messages for whatever reason they want (e.g. having smaller memory buffers), so long as they respect the rules around fragmentation (and every other part of the WebSocket specification).\n\nThe and parts of the first byte are used to control fragmentation. The first fragment will have a or type but will not be set. You'll then get 0 or more frames where is still not set. Finally, you'll get 1 frame with set. The payloads of each frame are concatenated together to form the final message.\n\nI'm not a fan of this feature, at all. It makes the implementation much more difficult. There are a couple rules that make our lives a little easier. Only and frames can be fragmented. Only control frames ( , and ) can be inserted between fragmented frames. In other words, we're only ever dealing with a single fragmented message at a time.\n\nHowever, even these restrictions on fragmentation mean that the life cycle for a frame gets more complicated. We no longer get one frame and pass it to the application. We have to accumulate frames, dealing with interleaved control frames, to create the message. It not only introduces a number of error cases, it makes memory management more complicated (it's hard to deal with fragmentation and interleaving without allocating more memory).\n\nI need to send a shout-out to the open source Autobahn Testsuite project. It has a comprehensive number of test cases that validate the correctness of both client and server implementations. I think it's a model that every protocol should aspire to.\n\nThe shortest possible WebSocket frame of 2-bytes is a server-to-client message with no payload. Since there's no payload, the length is 0, and since it's server-to-client, there's no mask. The longest possible header is 14 bytes for a client-to-server message with a payload larger than 16KB: 8+1 bytes for the length and 4 bytes for the mask (plus the first fin/type byte).\n\n\"over9000\" sent from the client to the server is longer and unpredictable because of the masking. Since the server to client message doesn't have a mask, it's always 4 bytes shorter and won't be random.\n\nI'd love to better understand why specific parts of the protocol were designed the way they were. Why a variable-length length, and does it still make sense? Why both text and binary type? Why fragmentation?\n\nFragmentation in particular doesn't seem useful and, if removed, could still be implemented at the library/application level. I feel the same way about ping and pong. As I look at Slack's network traffic, I notice that they've implemented their own ping and pong logic.\n\nThis article was inspired by a recent Zig WebSocket library that I wrote. It isn't the first WebSocket server that I've written, and thus it isn't the first time that I've had these thoughts. If you want to see what parsing a WebSocket frame looks like, you can jump directly into the code."
    },
    {
        "link": "https://qt.io/product/qt6/qml-book/ch13-networking-web-sockets",
        "document": "The WebSockets module provides an implementation of the WebSockets protocol for WebSockets clients and servers. It mirrors the Qt CPP module. It allows sending a string and binary messages using a full duplex communication channel. A WebSocket is normally established by making an HTTP connection to the server and the server then “upgrades” the connection to a WebSocket connection.\n\nIn Qt/QML you can also simply use the WebSocket and WebSocketServer objects to creates direct WebSocket connection. The WebSocket protocol uses the “ws” URL schema or “wss” for a secure connection.\n\nYou can use the web socket qml module by importing it first.\n\nYou can easily create your own WS server using the C++ part of the Qt WebSocket or use a different WS implementation, which I find very interesting. It is interesting because it allows connecting the amazing rendering quality of QML with the great expanding web application servers. In this example, we will use a Node JS based web socket server using the ws (opens new window) module. For this, you first need to install node js (opens new window). Then, create a folder and install the ws package using the node package manager (npm).\n\nThe code shall create a simple echo server in NodeJS to echo our messages back to our QML client.\n\nThe npm tool downloads and installs the ws package and dependencies into your local folder.\n\nA file will be our server implementation. The server code will create a web socket server on port 3000 and listens to an incoming connection. On an incoming connection, it will send out a greeting and waits for client messages. Each message a client sends on a socket will be sent back to the client.\n\nYou need to get used to the notation of JavaScript and the function callbacks.\n\nOn the client side, we need a list view to display the messages and a TextInput for the user to enter a new chat message.\n\nWe will use a label with white color in the example.\n\nOur chat view is a list view, where the text is appended to a list model. Each entry is displayed using a row of prefix and message label. We use a cell width factor to split the with into 24 columns.\n\nThe chat input is just a simple text input wrapped with a colored border.\n\nWhen the web socket receives a message it appends the message to the chat view. Same applies for a status change. Also when the user enters a chat message a copy is appended to the chat view on the client side and the message is sent to the server.\n\nYou need first run the server and then the client. There is no retry connection mechanism in our simple client.\n\nWhen entering text and pressing enter you should see something like this."
    },
    {
        "link": "https://github.com/oven-sh/bun/issues/3742",
        "document": "What version of Bun is running?\n\nWhat platform is your computer?\n\nWhat steps can reproduce the bug?\n• Build the bun-oriented bundle: . This uses the native implementation in Bun.\n• Build the node-oriented bundle: . This uses the nodejs library.\n• Test the bun-oriented script: . You can see received binary messages logged into the console. But if you're lucky, you'll also see an error thrown: If no errors are thrown, and rerun for several times. This error is thrown from the script when the received binary message is not what we expected (with wrong starting bytes).\n• Test the node-oriented script: . No errors observed, everything works fine no matter how many times I run it.\n\nWhat is the expected behavior?\n\nI expect the bun-oriented script to work without errors thrown and be consistent with the node-oriented script.\n\nWhat do you see instead?\n\nI did some further tests and I think the malformed binary messages received are actually continuation payloads. However AFAIK the continuation frames should be handled correctly by the API internally."
    }
]