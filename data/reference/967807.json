[
    {
        "link": "https://stackoverflow.com/questions/39519246/make-xmlhttprequest-post-using-json",
        "document": "How can I make an AJAX POST request sending JSON data using vanilla JS.\n\nI understand the content-type is url form encoded and it doesn't support nested JSONs.\n\nIs there any way I can make such a POST request using nested JSON in plain old JS. I've tried the various serialize methods found here on SO but they all flatten my JSON into one format."
    },
    {
        "link": "http://w3schools.com/Js/js_json_http.asp",
        "document": "A common use of JSON is to read data from a web server, and display the data in a web page.\n\nThis chapter will teach you, in 4 easy steps, how to read JSON data, using XMLHttp.\n\nThis example reads a menu from myTutorials.txt, and displays the menu in a web page:\n\n<div id=\"id01\"></div>\n\n\n\n<script>\n\nvar xmlhttp = new XMLHttpRequest();\n\n var url = \"myTutorials.txt\";\n\n\n\nxmlhttp.onreadystatechange = function() {\n\n if (this.readyState == 4 && this.status == 200) {\n\n var myArr = JSON.parse(this.responseText);\n\n myFunction(myArr);\n\n }\n\n};\n\nxmlhttp.open(\"GET\", url, true);\n\n xmlhttp.send();\n\n\n\nfunction myFunction(arr) {\n\n var out = \"\";\n\n var i;\n\n for(i = 0; i < arr.length; i++) {\n\n out += '<a href=\"' + arr[i].url + '\">' + \n\n arr[i].display + '</a><br>';\n\n }\n\n document.getElementById(\"id01\").innerHTML = out;\n\n}\n\n </script>\n\n Try it Yourself »\n\nUse an array literal to declare an array of objects.\n\nGive each object two properties: display and url.\n\nCreate a function myFunction() that loops the array objects, and display the content as HTML links:\n\n4: Read the text file with an XMLHttpRequest\n\nWrite an XMLHttpRequest to read the text file, and use myFunction() to display the array:"
    },
    {
        "link": "https://attacomsian.com/blog/xhr-json-post-request",
        "document": "In my previous article, we looked at how to make an HTTP POST request using XMLHttpRequest (XHR) in vanilla JavaScript. Since the most common use of XHR is for sending an asynchronous request with JSON payload, it's good to know how to do it.\n\nJSON stands for JavaScript Object Notation and is a popular format for sharing data with the server and displaying the result to the client.\n\nThe following example shows how you can use the XHR to make a JSON POST request in JavaScript:\n\nTake a look at the making HTTP requests using XHR tutorial to learn about all available options.\n\nIf you work with modern browsers only, I'd suggest using the Fetch API instead of XHR. It has clear and concise syntax and also supports promises:\n\n✌️ Like this article? Follow me on Twitter and LinkedIn. You can also subscribe to RSS Feed."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/send",
        "document": "This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015 .\n\nThe method sends the request to the server.\n\nIf the request is asynchronous (which is the default), this method returns as soon as the request is sent and the result is delivered using events. If the request is synchronous, this method doesn't return until the response has arrived.\n\naccepts an optional parameter which lets you specify the request's body; this is primarily used for requests such as . If the request method is or , the parameter is ignored and the request body is set to .\n\nIf no header has been set using the , an header with the type (any type) is sent."
    },
    {
        "link": "https://apidog.com/blog/xmlhttprequest-post",
        "document": "In the world of modern web development, asynchronous data exchange between the client and server is a crucial aspect of building dynamic and responsive applications. One of the fundamental tools that enable this functionality is the XMLHttpRequest object, specifically its POST method. While the XMLHttpRequest API may seem dated in the era of more modern APIs like Fetch and Axios, understanding its core principles is still essential for any JavaScript developer.\n\nThe XMLHttpRequest POST method allows you to send data asynchronously to a server without refreshing the entire web page. This approach enhances the user experience by providing a smoother and more efficient flow of information, ultimately leading to a better overall application performance.\n\n\n\nBefore diving into the code, let's review the basic setup process for an XMLHttpRequest POST request:\n• Define the request method (POST) and the URL endpoint.\n• Set up the request headers, if necessary.\n• Define the function to handle the server response.\n• Send the request with the data payload.\n\nIn the example above, we create a new XMLHttpRequest instance, define the POST method and the URL endpoint, set the appropriate request headers, and handle the server response in the event handler. Finally, we send the request with the data payload in JSON format using the method.\n\n\n\nWhile sending the request is crucial, properly handling the server response is equally important. The event handler allows you to monitor the progression of the request and take appropriate actions based on the and properties.\n\nIn the example above, we check the to ensure the request has completed ( ), and then examine the property to determine the success or failure of the request. A status code of 200 typically indicates a successful response, while other status codes may indicate various error conditions.\n\n\n\nWhile the previous examples focused on sending JSON data, XMLHttpRequest also allows you to send form data seamlessly. This is particularly useful when working with traditional HTML forms or when dealing with file uploads.\n\nIn this example, we create a instance and append the form fields using the method. We can even include file uploads by appending the object from an element. Finally, we send the object directly using the method.\n\nApidog is an all-in-one collaborative API development platform that provides a comprehensive toolkit for designing, debugging, testing, publishing, and mocking APIs. Apidog enables you to automatically create XMLHttpRequest code for making HTTP requests.\n\nHere's the process for using Apidog to generate XMLHttpRequest code:\n\nStep 2: Enter the URL of the API endpoint you want to send a request to,input any headers or query string parameters you wish to include with the request, then click on the \"Design\" to switch to the design interface of Apidog.\n\nStep 4: Copy the generated code and paste it into your project.\n\nApidog offers several advanced features that further enhance its ability to test HTTP requests. These features allow you to customize your requests and handle more complex scenarios effortlessly.\n\nStep 2: Find or manually input the API details for the POST request you want to make.\n\nStep 3: Fill in the required parameters and any data you want to include in the request body.\n\nAs you can see, XMLHttpRequest POST is more than just a technical tool – it's a game-changer that opens up a world of possibilities for web developers. Whether you're building dynamic user interfaces, integrating with powerful APIs, or creating the next generation of immersive web experiences, XMLHttpRequest POST is your secret weapon."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/send",
        "document": "This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015 .\n\nThe method sends the request to the server.\n\nIf the request is asynchronous (which is the default), this method returns as soon as the request is sent and the result is delivered using events. If the request is synchronous, this method doesn't return until the response has arrived.\n\naccepts an optional parameter which lets you specify the request's body; this is primarily used for requests such as . If the request method is or , the parameter is ignored and the request body is set to .\n\nIf no header has been set using the , an header with the type (any type) is sent."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest",
        "document": "This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015 . * Some parts of this feature may have varying levels of support.\n\nNote: This feature is available in Web Workers, except for Service Workers. (XHR) objects are used to interact with servers. You can retrieve data from a URL without having to do a full page refresh. This enables a Web page to update just part of a page without disrupting what the user is doing. Despite its name, can be used to retrieve any type of data, not just XML. If your communication needs to involve receiving event data or message data from a server, consider using server-sent events through the interface. For full-duplex communication, WebSockets may be a better choice.\n\nAborts the request if it has already been sent. Returns all the response headers, separated by CRLF, as a string, or if no response has been received. Returns the string containing the text of the specified header, or if either the response has not yet been received or the header doesn't exist in the response. Overrides the MIME type returned by the server. Sends the request. If the request is asynchronous (which is the default), this method returns as soon as the request is sent. Indicates that you want the request's response to be able to register an attribution source or trigger event. Sets the value of an HTTP request header. You must call after , but before ."
    },
    {
        "link": "https://apidog.com/blog/xmlhttprequest-post",
        "document": "In the world of modern web development, asynchronous data exchange between the client and server is a crucial aspect of building dynamic and responsive applications. One of the fundamental tools that enable this functionality is the XMLHttpRequest object, specifically its POST method. While the XMLHttpRequest API may seem dated in the era of more modern APIs like Fetch and Axios, understanding its core principles is still essential for any JavaScript developer.\n\nThe XMLHttpRequest POST method allows you to send data asynchronously to a server without refreshing the entire web page. This approach enhances the user experience by providing a smoother and more efficient flow of information, ultimately leading to a better overall application performance.\n\n\n\nBefore diving into the code, let's review the basic setup process for an XMLHttpRequest POST request:\n• Define the request method (POST) and the URL endpoint.\n• Set up the request headers, if necessary.\n• Define the function to handle the server response.\n• Send the request with the data payload.\n\nIn the example above, we create a new XMLHttpRequest instance, define the POST method and the URL endpoint, set the appropriate request headers, and handle the server response in the event handler. Finally, we send the request with the data payload in JSON format using the method.\n\n\n\nWhile sending the request is crucial, properly handling the server response is equally important. The event handler allows you to monitor the progression of the request and take appropriate actions based on the and properties.\n\nIn the example above, we check the to ensure the request has completed ( ), and then examine the property to determine the success or failure of the request. A status code of 200 typically indicates a successful response, while other status codes may indicate various error conditions.\n\n\n\nWhile the previous examples focused on sending JSON data, XMLHttpRequest also allows you to send form data seamlessly. This is particularly useful when working with traditional HTML forms or when dealing with file uploads.\n\nIn this example, we create a instance and append the form fields using the method. We can even include file uploads by appending the object from an element. Finally, we send the object directly using the method.\n\nApidog is an all-in-one collaborative API development platform that provides a comprehensive toolkit for designing, debugging, testing, publishing, and mocking APIs. Apidog enables you to automatically create XMLHttpRequest code for making HTTP requests.\n\nHere's the process for using Apidog to generate XMLHttpRequest code:\n\nStep 2: Enter the URL of the API endpoint you want to send a request to,input any headers or query string parameters you wish to include with the request, then click on the \"Design\" to switch to the design interface of Apidog.\n\nStep 4: Copy the generated code and paste it into your project.\n\nApidog offers several advanced features that further enhance its ability to test HTTP requests. These features allow you to customize your requests and handle more complex scenarios effortlessly.\n\nStep 2: Find or manually input the API details for the POST request you want to make.\n\nStep 3: Fill in the required parameters and any data you want to include in the request body.\n\nAs you can see, XMLHttpRequest POST is more than just a technical tool – it's a game-changer that opens up a world of possibilities for web developers. Whether you're building dynamic user interfaces, integrating with powerful APIs, or creating the next generation of immersive web experiences, XMLHttpRequest POST is your secret weapon."
    },
    {
        "link": "https://stackoverflow.com/questions/9713058/send-post-data-using-xmlhttprequest",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/46024439/retrieving-response-payload-elements-from-xmlhttprequest",
        "document": "I'm sending a JSON request (an applicative but the kind of request doesn't matter) to a server with the following function:\n\nI'm actually getting the correct reply in the field. For example, if the credentials are wrong, I get\n\nIf the credentials are OK I get\n\nYet, I can't manage to get the field : or are always . Same if the call is done in asynchroneous mode ( ) or if I don't the reply, ie: .\n\nI finally found a way to get it working, but I don't quite understand why it is so. I actually changed\n\nTo figure this out, I printed which is a . Actually is also a and this is why it has no fields like . Eventually, parsing twice gives an from which I actually can retrieve my data.\n\nIf somebody has a clue about what is happening, I would be interested... I don't know if this is related, but the app server that is sending the JSON is the latest version of Elixir/Phoenix, ie, 1.5/1.3 and JSON encoding/decoding is done with poison."
    },
    {
        "link": "https://stackoverflow.com/questions/8866761/xmlhttprequest-ajax-error",
        "document": "So there might be a few things wrong here.\n\nFirst start by reading how to use because there's a third optional parameter for specifying whether to make an asynchronous request, defaulting to true. That means you're making an asynchronous request and need to specify a callback function before you do the . Here's an example from MDN:\n\nSecond, since you're getting a 101 error, you might use the wrong URL. So make sure that the URL you're making the request with is correct. Also, make sure that your server is capable of serving your file.\n\nYou'll probably have to debug by simplifying/narrowing down where the problem is. So I'd start by making an easy synchronous request so you don't have to worry about the callback function. So here's another example from MDN for making a synchronous request:\n\nAlso, if you're just starting out with Javascript, you could refer to MDN for Javascript API documentation/examples/tutorials."
    },
    {
        "link": "https://one-liner.net/posts/handle-errors-in-xhr-in-javascript",
        "document": ""
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest_API/Using_XMLHttpRequest",
        "document": "This feature is well established and works across many devices and browser versions. It’s been available across browsers since July 2015 . * Some parts of this feature may have varying levels of support.\n\nIn this guide, we'll take a look at how to use to issue HTTP requests in order to exchange data between the website and a server. Examples of both common and more obscure use cases for are included. After the transaction completes, the object will contain useful information such as the response body and the HTTP status of the result.\n\nA request made via can fetch the data in one of two ways, asynchronously or synchronously. The type of request is dictated by the optional argument (the third argument) that is set on the method. If this argument is or not specified, the is processed asynchronously, otherwise the process is handled synchronously. A detailed discussion and demonstrations of these two types of requests can be found on the synchronous and asynchronous requests page. You can't use synchronous requests outside web workers as it freezes the main interface. Note: The constructor isn't limited to only XML documents. It starts with \"XML\" because when it was created the main format that was originally used for asynchronous data exchange was XML.\n\nAlthough is most commonly used to send and receive textual data, it can be used to send and receive binary content. There are several well tested methods for coercing the response of an into sending binary data. These involve utilizing the method on the object and is a workable solution. However, more modern techniques are available, since the attribute now supports a number of additional content types, which makes sending and receiving binary data much easier. For example, consider this snippet, which uses the of to fetch the remote content into a object, which stores the raw binary data. For more examples check out the Sending and Receiving Binary Data page.\n\nprovides the ability to listen to various events that can occur while the request is being processed. This includes periodic progress notifications, error notifications, and so forth. Support for DOM event monitoring of transfers follows the specification for progress events: these events implement the interface. The actual events you can monitor to determine the state of an ongoing transfer are: The amount of data that has been retrieved has changed. The transfer is complete; all data is now in the const req = new XMLHttpRequest(); req.addEventListener(\"progress\", updateProgress); req.addEventListener(\"load\", transferComplete); req.addEventListener(\"error\", transferFailed); req.addEventListener(\"abort\", transferCanceled); req.open(); // … // progress on transfers from the server to the client (downloads) function updateProgress(event) { if (event.lengthComputable) { const percentComplete = (event.loaded / event.total) * 100; // … } else { // Unable to compute progress information since the total size is unknown } } function transferComplete(evt) { console.log(\"The transfer is complete.\"); } function transferFailed(evt) { console.log(\"An error occurred while transferring the file.\"); } function transferCanceled(evt) { console.log(\"The transfer has been canceled by the user.\"); } We add event listeners for the various events that are sent while performing a data transfer using . Note: You need to add the event listeners before calling on the request. Otherwise the events will not fire. The progress event handler, specified by the function in this example, receives the total number of bytes to transfer as well as the number of bytes transferred so far in the event's and fields. However, if the field is false, the total length is not known and will be zero. Progress events exist for both download and upload transfers. The download events are fired on the object itself, as shown in the above sample. The upload events are fired on the object, as shown below: Note: Progress events are not available for the protocol. Progress events come in for every chunk of data received, including the last chunk in cases in which the last packet is received and the connection closed before the progress event is fired. In this case, the progress event is automatically fired when the load event occurs for that packet. This lets you now reliably monitor progress by only watching the \"progress\" event. One can also detect all three load-ending conditions ( , , or ) using the event: req.addEventListener(\"loadend\", loadEnd); function loadEnd(e) { console.log( \"The transfer finished (although we don't know if it succeeded or not).\", ); } Note there is no way to be certain, from the information received by the event, as to which condition caused the operation to terminate; however, you can use this to handle tasks that need to be performed in all end-of-transfer scenarios.\n\nIf you conclude with an XMLHttpRequest receiving and , this means the request was not allowed to be performed. It was . A likely cause for this is when the origin (at the creation of the XMLHttpRequest) has changed when the XMLHttpRequest is subsequently . This case can happen, for example, when one has an XMLHttpRequest that gets fired on an onunload event for a window, the expected XMLHttpRequest is created when the window to be closed is still there, and finally sending the request (in other words, ) when this window has lost its focus and another window gains focus. The most effective way to avoid this problem is to set a listener on the new window's event which is set once the terminated window has its event triggered."
    },
    {
        "link": "https://medium.com/@VaibhavTechDev/mastering-error-handling-in-javascript-best-practices-and-techniques-for-smooth-code-execution-52051f60b4f4",
        "document": "In software development, error handling is a critical part of ensuring that your program runs smoothly and that users have a positive experience. When it comes to JavaScript, error handling can be a bit more complicated due to the dynamic nature of the language. However, there are several best practices you can follow to make sure your JavaScript code handles errors effectively.\n\nBefore you can effectively handle errors in your JavaScript code, it’s essential to understand the types of errors that can occur. The three primary types of errors are syntax errors, runtime errors, and logical errors.\n\nSyntax errors occur when the code you’ve written violates the syntax rules of the language. For example, if you forget to close parenthesis or a quote, you’ll get a syntax error.\n\nRuntime errors occur when your code attempts to do something that’s not possible. For example, if you try to divide by zero or access an undefined variable, you’ll get a runtime error.\n\nLogical errors occur when your code runs without errors, but the result is not what you intended. For example, if you write a function that’s supposed to add two numbers but instead multiplies them, you’ll have a logical error.\n\nOne of the most effective ways to handle errors in JavaScript is to use try-catch blocks. A try-catch block allows you to catch errors that occur in your code and handle them in a way that prevents your program from crashing.\n\nIn this example, the try block contains the code that might throw an error. If an error occurs, the catch block will catch it and allow you to handle it. You can use the object to access information about the error, such as the message and stack trace.\n\nJavaScript has several built-in error objects that you can use to create custom error messages. For example, you can use the object to create a generic error message, or you can use more specific error objects like or to create more informative messages.\n\nIn this example, we’re catching a and checking if the error object is an instance of . If it is, we're logging a more specific error message that includes the error message from the error object.\n\nAssertions are a powerful tool for catching errors during development. An assertion is a statement that you write to check that a specific condition is true. If the condition is false, an error will be thrown.\n\nIn this example, we’re using an assertion to check that is not zero before dividing it by . If is zero, an error will be thrown with the message \"Cannot divide by zero\".\n\nWhen you’re working with asynchronous code in JavaScript, it’s important to handle errors differently. Since asynchronous code runs outside of the normal program flow, you can’t use try-catch blocks to catch errors.\n\nInstead, you’ll need to use callback functions or promises to handle errors asynchronously-\n\nHere are the types of error handling asynchronously -\n\nHandling errors asynchronously is a crucial part of writing robust JavaScript code. When dealing with asynchronous code, errors can occur at any time, and traditional error-handling techniques like try-catch blocks may not be sufficient. In this article, we will explore some techniques for handling errors asynchronously in JavaScript.\n\nCallbacks are a common way of handling asynchronous code in JavaScript. A callback function is a function that is passed as an argument to another function and is called once the asynchronous operation is complete.\n\nHere’s an example of using a callback to handle errors in asynchronous code:\n\nIn this example, is a function that fetches data from a URL using an XMLHttpRequest. The function takes a callback function as an argument, which is called when the operation is complete. If an error occurs, the callback function is called with an error object as the first argument.\n\nPromises are a newer and more powerful way of handling asynchronous code in JavaScript. A Promise is an object that represents the eventual completion (or failure) of an asynchronous operation and allows you to chain operations together.\n\nHere’s an example of using a Promise to handle errors in asynchronous code:\n\nIn this example, returns a Promise object that represents the completion of the asynchronous operation. If the operation is successful, the Promise is resolved with the data as the argument. If an error occurs, the Promise is rejected with an error object as the argument. The the method is used to handle the successful completion of the Promise, and the the method is used to handle any errors that occur.\n\nAsync/await is a newer and more concise way of handling asynchronous code in JavaScript. Async functions return a Promise that resolves to the value returned by the function or rejects with the value thrown by the function.\n\nHere’s an example of using async/await to handle errors in asynchronous code:\n\nIn this example, is an async function that uses the API to fetch data from a URL. If the response is successful, the data."
    },
    {
        "link": "https://javascript.info/xmlhttprequest",
        "document": "is a built-in browser object that allows to make HTTP requests in JavaScript.\n\nDespite having the word “XML” in its name, it can operate on any data, not only in XML format. We can upload/download files, track progress and much more.\n\nRight now, there’s another, more modern method , that somewhat deprecates .\n\nIn modern web-development is used for three reasons:\n• Historical reasons: we need to support existing scripts with .\n• We need to support old browsers, and don’t want polyfills (e.g. to keep scripts tiny).\n• We need something that can’t do yet, e.g. to track upload progress.\n\nDoes that sound familiar? If yes, then all right, go on with . Otherwise, please head on to Fetch.\n\nXMLHttpRequest has two modes of operation: synchronous and asynchronous.\n\nLet’s see the asynchronous first, as it’s used in the majority of cases.\n\nTo do the request, we need 3 steps:\n• The constructor has no arguments.\n• Initialize it, usually right after : This method specifies the main parameters of the request:\n• – the URL to request, a string, can be URL object.\n• – if explicitly set to , then the request is synchronous, we’ll cover that a bit later.\n• , – login and password for basic HTTP auth (if required). Please note that call, contrary to its name, does not open the connection. It only configures the request, but the network activity only starts with the call of .\n• This method opens the connection and sends the request to server. The optional parameter contains the request body. Some request methods like do not have a body. And some of them like use to send the data to the server. We’ll see examples of that later.\n• These three events are the most widely used:\n• – when the request is complete (even if HTTP status is like 400 or 500), and the response is fully downloaded.\n• – when the request couldn’t be made, e.g. network down or invalid URL.\n• – triggers periodically while the response is being downloaded, reports how much has been downloaded. xhr.onload = function() { alert(`Loaded: ${xhr.status} ${xhr.response}`); }; xhr.onerror = function() { // only triggers if the request couldn't be made at all alert(`Network Error`); }; xhr.onprogress = function(event) { // triggers periodically // event.loaded - how many bytes downloaded // event.lengthComputable = true if the server sent Content-Length header // event.total - total number of bytes (if lengthComputable) alert(`Received ${event.loaded} of ${event.total}`); };\n\nHere’s a full example. The code below loads the URL at from the server and prints the progress:\n\nOnce the server has responded, we can receive the result in the following properties:\n\nWe can also specify a timeout using the corresponding property:\n\nIf the request does not succeed within the given time, it gets canceled and event triggers.\n\nWe can use property to set the response format:\n• – get as (for binary data, see chapter ArrayBuffer, binary arrays),\n• – get as (for binary data, see chapter Blob),\n• – get as XML document (can use XPath and other XML methods) or HTML document (based on the MIME type of the received data),\n\nFor example, let’s get the response as JSON:\n\nchanges between states as it progresses. The current state is accessible as .\n\nAll states, as in the specification:\n\nAn object travels them in the order → → → → … → → . State repeats every time a data packet is received over the network.\n\nWe can track them using event:\n\nYou can find listeners in really old code, it’s there for historical reasons, as there was a time when there were no and other events. Nowadays, handlers deprecate it.\n\nWe can terminate the request at any time. The call to does that:\n\nThat triggers event, and becomes .\n\nIf in the method the third parameter is set to , the request is made synchronously.\n\nIn other words, JavaScript execution pauses at and resumes when the response is received. Somewhat like or commands.\n\nHere’s the rewritten example, the 3rd parameter of is :\n\nIt might look good, but synchronous calls are used rarely, because they block in-page JavaScript till the loading is complete. In some browsers it becomes impossible to scroll. If a synchronous call takes too much time, the browser may suggest to close the “hanging” webpage.\n\nMany advanced capabilities of , like requesting from another domain or specifying a timeout, are unavailable for synchronous requests. Also, as you can see, no progress indication.\n\nBecause of all that, synchronous requests are used very sparingly, almost never. We won’t talk about them any more.\n\nallows both to send custom headers and read headers from the response.\n\nThere are 3 methods for HTTP-headers:\n\nTo make a POST request, we can use the built-in FormData object.\n\nWe create it, optionally fill from a form, more fields if needed, and then:\n• to submit the form to the server.\n\nThe form is sent with encoding.\n\nOr, if we like JSON more, then and send as a string.\n\nJust don’t forget to set the header , many server-side frameworks automatically decode JSON with it:\n\nThe method is pretty omnivore. It can send almost any , including and objects.\n\nThe event triggers only on the downloading stage.\n\nThat is: if we something, first uploads our data (the request body), then downloads the response.\n\nIf we’re uploading something big, then we’re surely more interested in tracking the upload progress. But doesn’t help here.\n\nThere’s another object, without methods, exclusively to track upload events: .\n\nIt generates events, similar to , but triggers them solely on uploading:\n• – upload timed out (if property is set).\n• – upload finished with either success or error.\n\ncan make cross-origin requests, using the same CORS policy as fetch.\n\nJust like , it doesn’t send cookies and HTTP-authorization to another origin by default. To enable them, set to :\n\nSee the chapter Fetch: Cross-Origin Requests for details about cross-origin headers.\n\nTypical code of the GET-request with :\n\nThere are actually more events, the modern specification lists them (in the lifecycle order):\n• – a data packet of the response has arrived, the whole response body at the moment is in .\n• – the request was canceled by the call .\n• – connection error has occurred, e.g. wrong domain name. Doesn’t happen for HTTP-errors like 404.\n• – the request was canceled due to timeout (only happens if it was set).\n\nThe , , , and events are mutually exclusive. Only one of them may happen.\n\nThe most used events are load completion ( ), load failure ( ), or we can use a single handler and check the properties of the request object to see what happened.\n\nWe’ve already seen another event: . Historically, it appeared long ago, before the specification settled. Nowadays, there’s no need to use it, we can replace it with newer events, but it can often be found in older scripts.\n\nIf we need to track uploading specifically, then we should listen to same events on object."
    }
]