[
    {
        "link": "https://geeksforgeeks.org/python-oops-concepts",
        "document": "Object Oriented Programming is a fundamental concept in Python, empowering developers to build modular, maintainable, and scalable applications. By understanding the core OOP principles (classes, objects, inheritance, encapsulation, polymorphism, and abstraction), programmers can leverage the full potential of Python OOP capabilities to design elegant and efficient solutions to complex problems.\n\nOOPs is a way of organizing code that uses objects and classes to represent real-world entities and their behavior. In OOPs, object has attributes thing that has specific data and can perform certain actions using methods.\n\nA class is a collection of objects. Classes are blueprints for creating objects. A class defines a set of attributes and methods that the created objects (instances) can have.\n• None Attributes are the variables that belong to a class.\n• None Attributes are always public and can be accessed using the dot (.) operator. Example: Myclass.Myattribute\n\nHere, the class keyword indicates that we are creating a class followed by name of the class (Dog in this case).\n• species: A class attribute shared by all instances of the class.\n• __init__ method: Initializes the name and age attributes when a new object is created.\n\nAn Object is an instance of a Class. It represents a specific implementation of the class and holds its own data.\n• State: It is represented by the attributes and reflects the properties of an object.\n• Behavior: It is represented by the methods of an object and reflects the response of an object to other objects.\n• Identity: It gives a unique name to an object and enables one object to interact with other objects.\n\nCreating an object in Python involves instantiating a class to create a new instance of that class. This process is also referred to as object instantiation.\n• dog1 = Dog(“Buddy”, 3): Creates an object of the Dog class with name as “Buddy” and age as 3.\n• dog1.name: Accesses the instance attribute name of the dog1 object.\n• dog1.species: Accesses the class attribute species of the dog1 object.\n\nself parameter is a reference to the current instance of the class. It allows us to access the attributes and methods of the object.\n• self.name: Refers to the name attribute of the object (dog1) calling the method.\n\n__init__ method is the constructor in Python, automatically called when a new object is created. It initializes the attributes of the class.\n\nIn Python, variables defined in a class can be either class variables or instance variables, and understanding the distinction between them is crucial for object-oriented programming.\n\nThese are the variables that are shared across all instances of a class. It is defined at the class level, outside any methods. All objects of the class share the same value for a class variable unless explicitly overridden in an object.\n\nVariables that are unique to each instance (object) of a class. These are defined within the __init__ method or other instance methods. Each object maintains its own copy of instance variables, independent of other objects.\n• Class Variable (species): Shared by all instances of the class. Changing Dog.species affects all objects, as it’s a property of the class itself.\n• Instance Variables (name, age): Defined in the __init__ method. Unique to each instance (e.g., dog1.name and dog2.name are different).\n• Accessing Variables: Class variables can be accessed via the class name (Dog.species) or an object (dog1.species). Instance variables are accessed via the object (dog1.name).\n• Updating Variables: Changing Dog.species affects all instances. Changing dog1.name only affects dog1 and does not impact dog2.\n\nInheritance allows a class (child class) to acquire properties and methods of another class (parent class). It supports hierarchical classification and promotes code reuse.\n• Multiple Inheritance: A child class inherits from more than one parent class.\n• Multilevel Inheritance: A child class inherits from a parent class, which in turn inherits from another class.\n• Hybrid Inheritance: A combination of two or more types of inheritance.\n• Multiple Inheritance: GoldenRetriever inherits from both Dog and Friendly.\n\nPolymorphism allows methods to have the same name but behave differently based on the object’s context. It can be achieved through method overriding or overloading.\n• Compile-Time Polymorphism : This type of polymorphism is determined during the compilation of the program. It allows methods or operators with the same name to behave differently based on their input parameters or usage. It is commonly referred to as method or operator overloading.\n• Run-Time Polymorphism : This type of polymorphism is determined during the execution of the program. It occurs when a subclass provides a specific implementation for a method already defined in its parent class, commonly known as method overriding.\n• None Demonstrated using method overriding in the Dog class and its subclasses (Labrador and Beagle).\n• None The correct sound method is invoked at runtime based on the actual type of the object in the list.\n• None Python does not natively support method overloading. Instead, we use a single method (add) with default arguments to handle varying numbers of parameters.\n• None Different behaviors (adding two or three numbers) are achieved based on how the method is called.\n\nEncapsulation is the bundling of data (attributes) and methods (functions) within a class, restricting access to some components to control interactions.\n\nA class is an example of encapsulation as it encapsulates all the data that is member functions, variables, etc.\n• Protected Members : Accessible within the class and its subclasses.\n• Private Members : Accessible only within the class.\n• Public Members: Easily accessible, such as name.\n• Protected Members : Used with a single _, such as _breed. Access is discouraged but allowed in subclasses.\n• Private Members: Used with __, such as __age. Access requires\n\nAbstraction hides the internal implementation details while exposing only the necessary functionality. It helps focus on “what to do” rather than “how to do it.”\n• Partial Abstraction: Abstract class contains both abstract and concrete methods.\n• Full Abstraction: Abstract class contains only abstract methods (like interfaces).\n• Why Use It : Abstraction ensures consistency in derived classes by enforcing the implementation of abstract methods.\n\nWhat are the 4 pillars of OOP Python?\n\nIs OOP used in Python?"
    },
    {
        "link": "https://realpython.com/python3-object-oriented-programming",
        "document": "Object-oriented programming (OOP) in Python helps you structure your code by grouping related data and behaviors into objects. You start by defining classes, which act as blueprints, and then create objects from them. OOP simplifies modeling real-world concepts in your programs and enables you to build systems that are more reusable and scalable.\n\nBy the end of this tutorial, you’ll understand that:\n• Object-oriented programming in Python involves creating classes as blueprints for objects. These objects contain data and the methods needed to manipulate that data.\n• The four key concepts of OOP in Python are encapsulation, inheritance, abstraction, and polymorphism.\n• You create an object in Python by instantiating a class, which involves calling the class name followed by parentheses.\n• Class inheritance in Python allows a class to inherit attributes and methods from another class, known as the parent class.\n• You use super() in Python to call a method from the parent class, allowing you to extend or modify inherited behavior.\n\nYou’ll explore how to define classes, instantiate classes to create objects, and leverage inheritance to build robust systems in Python.\n\nWhat Is Object-Oriented Programming in Python? Object-oriented programming is a programming paradigm that provides a means of structuring programs so that properties and behaviors are bundled into individual objects. For example, an object could represent a person with properties like a name, age, and address and behaviors such as walking, talking, breathing, and running. Or it could represent an email with properties like a recipient list, subject, and body and behaviors like adding attachments and sending. Put another way, object-oriented programming is an approach for modeling concrete, real-world things, like cars, as well as relations between things, like companies and employees or students and teachers. OOP models real-world entities as software objects that have some data associated with them and can perform certain operations. OOP also exists in other programming languages and is often described to center around the four pillars, or four tenants of OOP:\n• Encapsulation allows you to bundle data (attributes) and behaviors (methods) within a class to create a cohesive unit. By defining methods to control access to attributes and its modification, encapsulation helps maintain data integrity and promotes modular, secure code.\n• Inheritance enables the creation of hierarchical relationships between classes, allowing a subclass to inherit attributes and methods from a parent class. This promotes code reuse and reduces duplication.\n• Abstraction focuses on hiding implementation details and exposing only the essential functionality of an object. By enforcing a consistent interface, abstraction simplifies interactions with objects, allowing developers to focus on what an object does rather than how it achieves its functionality.\n• Polymorphism allows you to treat objects of different types as instances of the same base type, as long as they implement a common interface or behavior. Python’s duck typing make it especially suited for polymorphism, as it allows you to access attributes and methods on objects without needing to worry about their actual class. In this tutorial you’ll take a practical approach to understanding OOP in Python. But keeping these four concepts of object-oriented programming in mind may help you to remember the information that you gather. The key takeaway is that objects are at the center of object-oriented programming in Python. In other programming paradigms, objects only represent the data. In OOP, they additionally inform the overall structure of the program.\n\nHow Do You Define a Class in Python? In Python, you define a class by using the keyword followed by a name and a colon. Then you use to declare which attributes each instance of the class should have: But what does all of that mean? And why do you even need classes in the first place? Take a step back and consider using built-in, primitive data structures as an alternative. Primitive data structures—like numbers, strings, and lists—are designed to represent straightforward pieces of information, such as the cost of an apple, the name of a poem, or your favorite colors, respectively. What if you want to represent something more complex? For example, you might want to track employees in an organization. You need to store some basic information about each employee, such as their name, age, position, and the year they started working. One way to do this is to represent each employee as a list: There are a number of issues with this approach. First, it can make larger code files more difficult to manage. If you reference several lines away from where you declared the list, will you remember that the element with index is the employee’s name? Second, it can introduce errors if employees don’t have the same number of elements in their respective lists. In the list above, the age is missing, so will return instead of Dr. McCoy’s age. A great way to make this type of code more manageable and more maintainable is to use classes. Classes allow you to create user-defined data structures. Classes define functions called methods, which identify the behaviors and actions that an object created from the class can perform with its data. In this tutorial, you’ll create a class that stores some information about the characteristics and behaviors that an individual dog can have. A class is a blueprint for how to define something. It doesn’t actually contain any data. The class specifies that a name and an age are necessary for defining a dog, but it doesn’t contain the name or age of any specific dog. While the class is the blueprint, an instance is an object that’s built from a class and contains real data. An instance of the class is not a blueprint anymore. It’s an actual dog with a name, like Miles, who’s four years old. Put another way, a class is like a form or questionnaire. An instance is like a form that you’ve filled out with information. Just like many people can fill out the same form with their own unique information, you can create many instances from a single class. You start all class definitions with the keyword, then add the name of the class and a colon. Python will consider any code that you indent below the class definition as part of the class’s body. Here’s an example of a class: The body of the class consists of a single statement: the keyword. Python programmers often use as a placeholder indicating where code will eventually go. It allows you to run this code without Python throwing an error. Note: Python class names are written in CapitalizedWords notation by convention. For example, a class for a specific breed of dog, like the Jack Russell Terrier, would be written as . The class isn’t very interesting right now, so you’ll spruce it up a bit by defining some properties that all objects should have. There are several properties that you can choose from, including name, age, coat color, and breed. To keep the example small in scope, you’ll just use name and age. You define the properties that all objects must have in a method called . Every time you create a new object, sets the initial state of the object by assigning the values of the object’s properties. That is, initializes each new instance of the class. You can give any number of parameters, but the first parameter will always be a variable called . When you create a new class instance, then Python automatically passes the instance to the parameter in so that Python can define the new attributes on the object. Update the class with an method that creates and attributes: Make sure that you indent the method’s signature by four spaces, and the body of the method by eight spaces. This indentation is vitally important. It tells Python that the method belongs to the class. In the body of , there are two statements using the variable:\n• creates an attribute called and assigns the value of the parameter to it.\n• creates an attribute called and assigns the value of the parameter to it. Attributes created in are called instance attributes. An instance attribute’s value is specific to a particular instance of the class. All objects have a name and an age, but the values for the and attributes will vary depending on the instance. On the other hand, class attributes are attributes that have the same value for all class instances. You can define a class attribute by assigning a value to a variable name outside of . For example, the following class has a class attribute called with the value : You define class attributes directly beneath the first line of the class name and indent them by four spaces. You always need to assign them an initial value. When you create an instance of the class, then Python automatically creates and assigns class attributes to their initial values. Use class attributes to define properties that should have the same value for every class instance. Use instance attributes for properties that vary from one instance to another. Now that you have a class, it’s time to create some dogs!\n\nHow Do You Instantiate a Class in Python? Creating a new object from a class is called instantiating a class. You can create a new object by typing the name of the class, followed by opening and closing parentheses: You first create a new class with no attributes or methods, and then you instantiate the class to create a object. In the output above, you can see that you now have a new object at . This funny-looking string of letters and numbers is a memory address that indicates where Python stores the object in your computer’s memory. Note that the address on your screen will be different. Now instantiate the class a second time to create another object: The new instance is located at a different memory address. That’s because it’s an entirely new instance and is completely unique from the first object that you created. To see this another way, type the following: In this code, you create two new objects and assign them to the variables and . When you compare and using the operator, the result is . Even though and are both instances of the class, they represent two distinct objects in memory. Now create a new class with a class attribute called and two instance attributes called and : To instantiate this class, you need to provide values for and . If you don’t, then Python raises a : To pass arguments to the and parameters, put values into the parentheses after the class name: This creates two new instances—one for a four-year-old dog named Miles and one for a nine-year-old dog named Buddy. The class’s method has three parameters, so why are you only passing two arguments to it in the example? When you instantiate the class, Python creates a new instance of and passes it to the first parameter of . This essentially removes the parameter, so you only need to worry about the and parameters. Note: Behind the scenes, Python both creates and initializes a new object when you use this syntax. If you want to dive deeper, then you can read the dedicated tutorial about the Python class constructor. After you create the instances, you can access their instance attributes using dot notation: You can access class attributes the same way: One of the biggest advantages of using classes to organize data is that instances are guaranteed to have the attributes you expect. All instances have , , and attributes, so you can use those attributes with confidence, knowing that they’ll always return a value. Although the attributes are guaranteed to exist, their values can change dynamically: In this example, you change the attribute of the object to . Then you change the attribute of the object to , which is a species of cat. That makes Miles a pretty strange dog, but it’s valid Python! The key takeaway here is that custom objects are mutable by default. An object is mutable if you can alter it dynamically. For example, lists and dictionaries are mutable, but strings and tuples are immutable. Instance methods are functions that you define inside a class and can only call on an instance of that class. Just like , an instance method always takes as its first parameter. Open a new editor window in IDLE and type in the following class: This class has two instance methods:\n• returns a string displaying the name and age of the dog.\n• has one parameter called and returns a string containing the dog’s name and the sound that the dog makes. Save the modified class to a file called and press to run the program. Then open the interactive window and type the following to see your instance methods in action: In the above class, returns a string containing information about the instance . When writing your own classes, it’s a good idea to have a method that returns a string containing useful information about an instance of the class. However, isn’t the most Pythonic way of doing this. When you create a object, you can use to display a string that looks like the list: Go ahead and print the object to see what output you get: When you print , you get a cryptic-looking message telling you that is a object at the memory address . This message isn’t very helpful. You can change what gets printed by defining a special instance method called . In the editor window, change the name of the class’s method to : Save the file and press . Now, when you print , you get a much friendlier output: Methods like and are called dunder methods because they begin and end with double underscores. There are many dunder methods that you can use to customize classes in Python. Understanding dunder methods is an important part of mastering object-oriented programming in Python, but for your first exploration of the topic, you’ll stick with these two dunder methods. Note: Check out When Should You Use vs in Python? to learn more about and its cousin . If you want to reinforce your understanding with a practical exercise, then you can click on the block below and work on solving the challenge:\n• , which stores the name of the car’s color as a string\n• , which stores the number of miles on the car as an integer Then create two objects—a blue car with twenty thousand miles and a red car with thirty thousand miles—and print out their colors and mileage. Your output should look like this: There are multiple ways to solve this challenge. To effectively practice what you’ve learned so far, try to solve the task with the information about classes in Python that you’ve gathered in this section. When you’re done with your own implementation of the challenge, then you can expand the block below to see a possible solution: First, create a class with and instance attributes, and a method to format the display of objects when you pass them to : The and parameters of are assigned to and , which creates the two instance attributes. The method interpolates both instance attributes into an f-string and uses the format specifier to print the mileage grouped by thousands and separated with a comma. Now you can create the two instances: You create the instance by passing the value to the parameter and to the parameter. Similarly, you create with the values and . To print the color and mileage of each object, you can loop over a containing both objects and print each object: Because you’ve defined their string representation in , printing the objects gives you the desired text output. When you’re ready, you can move on to the next section. There, you’ll see how to take your knowledge one step further and create classes from other classes.\n\nHow Do You Inherit From Another Class in Python? Inheritance is the process by which one class takes on the attributes and methods of another. Newly formed classes are called child classes, and the classes that you derive child classes from are called parent classes. You inherit from a parent class by creating a new class and putting the name of the parent class into parentheses: In this minimal example, the child class inherits from the parent class . Because child classes take on the attributes and methods of parent classes, is also without your explicitly defining that. Note: This tutorial is adapted from the chapter “Object-Oriented Programming (OOP)” in Python Basics: A Practical Introduction to Python 3. If you enjoy what you’re reading, then be sure to check out the rest of the book and the learning path. You can also check out the Python Basics: Building Systems With Classes video course to reinforce the skills that you’ll develop in this section of the tutorial. Child classes can override or extend the attributes and methods of parent classes. In other words, child classes inherit all of the parent’s attributes and methods but can also specify attributes and methods that are unique to themselves. Although the analogy isn’t perfect, you can think of object inheritance sort of like genetic inheritance. You may have inherited your hair color from your parents. It’s an attribute that you were born with. But maybe you decide to color your hair purple. Assuming that your parents don’t have purple hair, you’ve just overridden the hair color attribute that you inherited from your parents: If you change the code example like this, then will be . You also inherit, in a sense, your language from your parents. If your parents speak English, then you’ll also speak English. Now imagine you decide to learn a second language, like German. In this case, you’ve extended your attributes because you’ve added an attribute that your parents don’t have: You’ll learn more about how the code above works in the sections below. But before you dive deeper into inheritance in Python, you’ll take a walk to a dog park to better understand why you might want to use inheritance in your own code. Pretend for a moment that you’re at a dog park. There are many dogs of different breeds at the park, all engaging in various dog behaviors. Suppose now that you want to model the dog park with Python classes. The class that you wrote in the previous section can distinguish dogs by name and age but not by breed. You could modify the class in the editor window by adding a attribute: Press to save the file. Now you can model the dog park by creating a bunch of different dogs in the interactive window: Each breed of dog has slightly different behaviors. For example, bulldogs have a low bark that sounds like woof, but dachshunds have a higher-pitched bark that sounds more like yap. Using just the class, you must supply a string for the argument of every time you call it on a instance: Passing a string to every call to is repetitive and inconvenient. Moreover, the attribute should determine the string representing the sound that each instance makes, but here you have to manually pass the correct string to every time you call it. You can simplify the experience of working with the class by creating a child class for each breed of dog. This allows you to extend the functionality that each child class inherits, including specifying a default argument for . In this section, you’ll create a child class for each of the three breeds mentioned above: Jack Russell terrier, dachshund, and bulldog. For reference, here’s the full definition of the class that you’re currently working with: After doing the dog park example in the previous section, you’ve removed again. You’ll now write code to keep track of a dog’s breed using child classes instead. To create a child class, you create a new class with its own name and then put the name of the parent class in parentheses. Add the following to the file to create three new child classes of the class: Press to save and run the file. With the child classes defined, you can now create some dogs of specific breeds in the interactive window: Instances of child classes inherit all of the attributes and methods of the parent class: To determine which class a given object belongs to, you can use the built-in : What if you want to determine if is also an instance of the class? You can do this with the built-in : Notice that takes two arguments, an object and a class. In the example above, checks if is an instance of the class and returns . The , , , and objects are all instances, but isn’t a instance, and isn’t a instance: More generally, all objects created from a child class are instances of the parent class, although they may not be instances of other child classes. Now that you’ve created child classes for some different breeds of dogs, you can give each breed its own sound. Since different breeds of dogs have slightly different barks, you want to provide a default value for the argument of their respective methods. To do this, you need to override in the class definition for each breed. To override a method defined on the parent class, you define a method with the same name on the child class. Here’s what that looks like for the class: Now is defined on the class with the default argument for set to . Update with the new class and press to save and run the file. You can now call on a instance without passing an argument to : Sometimes dogs make different noises, so if Miles gets angry and growls, you can still call with a different sound: One thing to keep in mind about class inheritance is that changes to the parent class automatically propagate to child classes. This occurs as long as the attribute or method being changed isn’t overridden in the child class. For example, in the editor window, change the string returned by in the class: Save the file and press . Now, when you create a new instance named , returns the new string: However, calling on a instance won’t show the new style of output: Sometimes it makes sense to completely override a method from a parent class. But in this case, you don’t want the class to lose any changes that you might make to the formatting of the output string. To do this, you still need to define a method on the child class. But instead of explicitly defining the output string, you need to call the class’s from inside the child class’s using the same arguments that you passed to . You can access the parent class from inside a method of a child class by using : When you call inside , Python searches the parent class, , for a method and calls it with the variable . Update with the new class. Save the file and press so you can test it in the interactive window: Now when you call , you’ll see output reflecting the new formatting in the class. Note: In the above examples, the class hierarchy is very straightforward. The class has a single parent class, . In real-world examples, the class hierarchy can get quite complicated. The function does much more than just search the parent class for a method or an attribute. It traverses the entire class hierarchy for a matching method or attribute. If you aren’t careful, can have surprising results. If you want to check your understanding of the concepts that you learned about in this section with a practical exercise, then you can click on the block below and work on solving the challenge: Start with the following code for your parent class: Create a class that inherits from the class. Give the argument of a default value of . When you’re done with your own implementation of the challenge, then you can expand the block below to see a possible solution: Create a class called that inherits from the class and overrides the method: You give as the default value to the parameter in . Then you use to call the method of the parent class with the same argument passed to as the class’s method. Nice work! In this section, you’ve learned how to override and extend methods from a parent class, and you worked on a small practical example to cement your new skills."
    },
    {
        "link": "https://docs.python.org/3/tutorial/classes.html",
        "document": "Classes provide a means of bundling data and functionality together. Creating a new class creates a new type of object, allowing new instances of that type to be made. Each class instance can have attributes attached to it for maintaining its state. Class instances can also have methods (defined by its class) for modifying its state.\n\nCompared with other programming languages, Python’s class mechanism adds classes with a minimum of new syntax and semantics. It is a mixture of the class mechanisms found in C++ and Modula-3. Python classes provide all the standard features of Object Oriented Programming: the class inheritance mechanism allows multiple base classes, a derived class can override any methods of its base class or classes, and a method can call the method of a base class with the same name. Objects can contain arbitrary amounts and kinds of data. As is true for modules, classes partake of the dynamic nature of Python: they are created at runtime, and can be modified further after creation.\n\nIn C++ terminology, normally class members (including the data members) are public (except see below Private Variables), and all member functions are virtual. As in Modula-3, there are no shorthands for referencing the object’s members from its methods: the method function is declared with an explicit first argument representing the object, which is provided implicitly by the call. As in Smalltalk, classes themselves are objects. This provides semantics for importing and renaming. Unlike C++ and Modula-3, built-in types can be used as base classes for extension by the user. Also, like in C++, most built-in operators with special syntax (arithmetic operators, subscripting etc.) can be redefined for class instances.\n\nBefore introducing classes, I first have to tell you something about Python’s scope rules. Class definitions play some neat tricks with namespaces, and you need to know how scopes and namespaces work to fully understand what’s going on. Incidentally, knowledge about this subject is useful for any advanced Python programmer. A namespace is a mapping from names to objects. Most namespaces are currently implemented as Python dictionaries, but that’s normally not noticeable in any way (except for performance), and it may change in the future. Examples of namespaces are: the set of built-in names (containing functions such as , and built-in exception names); the global names in a module; and the local names in a function invocation. In a sense the set of attributes of an object also form a namespace. The important thing to know about namespaces is that there is absolutely no relation between names in different namespaces; for instance, two different modules may both define a function without confusion — users of the modules must prefix it with the module name. By the way, I use the word attribute for any name following a dot — for example, in the expression , is an attribute of the object . Strictly speaking, references to names in modules are attribute references: in the expression , is a module object and is an attribute of it. In this case there happens to be a straightforward mapping between the module’s attributes and the global names defined in the module: they share the same namespace! Attributes may be read-only or writable. In the latter case, assignment to attributes is possible. Module attributes are writable: you can write . Writable attributes may also be deleted with the statement. For example, will remove the attribute from the object named by . Namespaces are created at different moments and have different lifetimes. The namespace containing the built-in names is created when the Python interpreter starts up, and is never deleted. The global namespace for a module is created when the module definition is read in; normally, module namespaces also last until the interpreter quits. The statements executed by the top-level invocation of the interpreter, either read from a script file or interactively, are considered part of a module called , so they have their own global namespace. (The built-in names actually also live in a module; this is called .) The local namespace for a function is created when the function is called, and deleted when the function returns or raises an exception that is not handled within the function. (Actually, forgetting would be a better way to describe what actually happens.) Of course, recursive invocations each have their own local namespace. A scope is a textual region of a Python program where a namespace is directly accessible. “Directly accessible” here means that an unqualified reference to a name attempts to find the name in the namespace. Although scopes are determined statically, they are used dynamically. At any time during execution, there are 3 or 4 nested scopes whose namespaces are directly accessible:\n• None the innermost scope, which is searched first, contains the local names\n• None the scopes of any enclosing functions, which are searched starting with the nearest enclosing scope, contain non-local, but also non-global names\n• None the next-to-last scope contains the current module’s global names\n• None the outermost scope (searched last) is the namespace containing built-in names If a name is declared global, then all references and assignments go directly to the next-to-last scope containing the module’s global names. To rebind variables found outside of the innermost scope, the statement can be used; if not declared nonlocal, those variables are read-only (an attempt to write to such a variable will simply create a new local variable in the innermost scope, leaving the identically named outer variable unchanged). Usually, the local scope references the local names of the (textually) current function. Outside functions, the local scope references the same namespace as the global scope: the module’s namespace. Class definitions place yet another namespace in the local scope. It is important to realize that scopes are determined textually: the global scope of a function defined in a module is that module’s namespace, no matter from where or by what alias the function is called. On the other hand, the actual search for names is done dynamically, at run time — however, the language definition is evolving towards static name resolution, at “compile” time, so don’t rely on dynamic name resolution! (In fact, local variables are already determined statically.) A special quirk of Python is that – if no or statement is in effect – assignments to names always go into the innermost scope. Assignments do not copy data — they just bind names to objects. The same is true for deletions: the statement removes the binding of from the namespace referenced by the local scope. In fact, all operations that introduce new names use the local scope: in particular, statements and function definitions bind the module or function name in the local scope. The statement can be used to indicate that particular variables live in the global scope and should be rebound there; the statement indicates that particular variables live in an enclosing scope and should be rebound there. This is an example demonstrating how to reference the different scopes and namespaces, and how and affect variable binding: The output of the example code is: After local assignment: test spam After nonlocal assignment: nonlocal spam After global assignment: nonlocal spam In global scope: global spam Note how the local assignment (which is default) didn’t change scope_test's binding of spam. The assignment changed scope_test's binding of spam, and the assignment changed the module-level binding. You can also see that there was no previous binding for spam before the assignment.\n\nA First Look at Classes¶ Classes introduce a little bit of new syntax, three new object types, and some new semantics. The simplest form of class definition looks like this: Class definitions, like function definitions ( statements) must be executed before they have any effect. (You could conceivably place a class definition in a branch of an statement, or inside a function.) In practice, the statements inside a class definition will usually be function definitions, but other statements are allowed, and sometimes useful — we’ll come back to this later. The function definitions inside a class normally have a peculiar form of argument list, dictated by the calling conventions for methods — again, this is explained later. When a class definition is entered, a new namespace is created, and used as the local scope — thus, all assignments to local variables go into this new namespace. In particular, function definitions bind the name of the new function here. When a class definition is left normally (via the end), a class object is created. This is basically a wrapper around the contents of the namespace created by the class definition; we’ll learn more about class objects in the next section. The original local scope (the one in effect just before the class definition was entered) is reinstated, and the class object is bound here to the class name given in the class definition header ( in the example). Class objects support two kinds of operations: attribute references and instantiation. Attribute references use the standard syntax used for all attribute references in Python: . Valid attribute names are all the names that were in the class’s namespace when the class object was created. So, if the class definition looked like this: then and are valid attribute references, returning an integer and a function object, respectively. Class attributes can also be assigned to, so you can change the value of by assignment. is also a valid attribute, returning the docstring belonging to the class: . Class instantiation uses function notation. Just pretend that the class object is a parameterless function that returns a new instance of the class. For example (assuming the above class): creates a new instance of the class and assigns this object to the local variable . The instantiation operation (“calling” a class object) creates an empty object. Many classes like to create objects with instances customized to a specific initial state. Therefore a class may define a special method named , like this: When a class defines an method, class instantiation automatically invokes for the newly created class instance. So in this example, a new, initialized instance can be obtained by: Of course, the method may have arguments for greater flexibility. In that case, arguments given to the class instantiation operator are passed on to . For example, Now what can we do with instance objects? The only operations understood by instance objects are attribute references. There are two kinds of valid attribute names: data attributes and methods. data attributes correspond to “instance variables” in Smalltalk, and to “data members” in C++. Data attributes need not be declared; like local variables, they spring into existence when they are first assigned to. For example, if is the instance of created above, the following piece of code will print the value , without leaving a trace: The other kind of instance attribute reference is a method. A method is a function that “belongs to” an object. Valid method names of an instance object depend on its class. By definition, all attributes of a class that are function objects define corresponding methods of its instances. So in our example, is a valid method reference, since is a function, but is not, since is not. But is not the same thing as — it is a method object, not a function object. Usually, a method is called right after it is bound: In the example, this will return the string . However, it is not necessary to call a method right away: is a method object, and can be stored away and called at a later time. For example: will continue to print until the end of time. What exactly happens when a method is called? You may have noticed that was called without an argument above, even though the function definition for specified an argument. What happened to the argument? Surely Python raises an exception when a function that requires an argument is called without any — even if the argument isn’t actually used… Actually, you may have guessed the answer: the special thing about methods is that the instance object is passed as the first argument of the function. In our example, the call is exactly equivalent to . In general, calling a method with a list of n arguments is equivalent to calling the corresponding function with an argument list that is created by inserting the method’s instance object before the first argument. In general, methods work as follows. When a non-data attribute of an instance is referenced, the instance’s class is searched. If the name denotes a valid class attribute that is a function object, references to both the instance object and the function object are packed into a method object. When the method object is called with an argument list, a new argument list is constructed from the instance object and the argument list, and the function object is called with this new argument list. Generally speaking, instance variables are for data unique to each instance and class variables are for attributes and methods shared by all instances of the class: As discussed in A Word About Names and Objects, shared data can have possibly surprising effects with involving mutable objects such as lists and dictionaries. For example, the tricks list in the following code should not be used as a class variable because just a single list would be shared by all Dog instances: Correct design of the class should use an instance variable instead: # creates a new empty list for each dog\n\nIf the same attribute name occurs in both an instance and in a class, then attribute lookup prioritizes the instance: Data attributes may be referenced by methods as well as by ordinary users (“clients”) of an object. In other words, classes are not usable to implement pure abstract data types. In fact, nothing in Python makes it possible to enforce data hiding — it is all based upon convention. (On the other hand, the Python implementation, written in C, can completely hide implementation details and control access to an object if necessary; this can be used by extensions to Python written in C.) Clients should use data attributes with care — clients may mess up invariants maintained by the methods by stamping on their data attributes. Note that clients may add data attributes of their own to an instance object without affecting the validity of the methods, as long as name conflicts are avoided — again, a naming convention can save a lot of headaches here. There is no shorthand for referencing data attributes (or other methods!) from within methods. I find that this actually increases the readability of methods: there is no chance of confusing local variables and instance variables when glancing through a method. Often, the first argument of a method is called . This is nothing more than a convention: the name has absolutely no special meaning to Python. Note, however, that by not following the convention your code may be less readable to other Python programmers, and it is also conceivable that a class browser program might be written that relies upon such a convention. Any function object that is a class attribute defines a method for instances of that class. It is not necessary that the function definition is textually enclosed in the class definition: assigning a function object to a local variable in the class is also ok. For example: Now , and are all attributes of class that refer to function objects, and consequently they are all methods of instances of — being exactly equivalent to . Note that this practice usually only serves to confuse the reader of a program. Methods may call other methods by using method attributes of the argument: Methods may reference global names in the same way as ordinary functions. The global scope associated with a method is the module containing its definition. (A class is never used as a global scope.) While one rarely encounters a good reason for using global data in a method, there are many legitimate uses of the global scope: for one thing, functions and modules imported into the global scope can be used by methods, as well as functions and classes defined in it. Usually, the class containing the method is itself defined in this global scope, and in the next section we’ll find some good reasons why a method would want to reference its own class. Each value is an object, and therefore has a class (also called its type). It is stored as .\n\nOf course, a language feature would not be worthy of the name “class” without supporting inheritance. The syntax for a derived class definition looks like this: The name must be defined in a namespace accessible from the scope containing the derived class definition. In place of a base class name, other arbitrary expressions are also allowed. This can be useful, for example, when the base class is defined in another module: Execution of a derived class definition proceeds the same as for a base class. When the class object is constructed, the base class is remembered. This is used for resolving attribute references: if a requested attribute is not found in the class, the search proceeds to look in the base class. This rule is applied recursively if the base class itself is derived from some other class. There’s nothing special about instantiation of derived classes: creates a new instance of the class. Method references are resolved as follows: the corresponding class attribute is searched, descending down the chain of base classes if necessary, and the method reference is valid if this yields a function object. Derived classes may override methods of their base classes. Because methods have no special privileges when calling other methods of the same object, a method of a base class that calls another method defined in the same base class may end up calling a method of a derived class that overrides it. (For C++ programmers: all methods in Python are effectively .) An overriding method in a derived class may in fact want to extend rather than simply replace the base class method of the same name. There is a simple way to call the base class method directly: just call . This is occasionally useful to clients as well. (Note that this only works if the base class is accessible as in the global scope.) Python has two built-in functions that work with inheritance:\n• None Use to check an instance’s type: will be only if is or some class derived from .\n• None Use to check class inheritance: is since is a subclass of . However, is since is not a subclass of . Python supports a form of multiple inheritance as well. A class definition with multiple base classes looks like this: For most purposes, in the simplest cases, you can think of the search for attributes inherited from a parent class as depth-first, left-to-right, not searching twice in the same class where there is an overlap in the hierarchy. Thus, if an attribute is not found in , it is searched for in , then (recursively) in the base classes of , and if it was not found there, it was searched for in , and so on. In fact, it is slightly more complex than that; the method resolution order changes dynamically to support cooperative calls to . This approach is known in some other multiple-inheritance languages as call-next-method and is more powerful than the super call found in single-inheritance languages. Dynamic ordering is necessary because all cases of multiple inheritance exhibit one or more diamond relationships (where at least one of the parent classes can be accessed through multiple paths from the bottommost class). For example, all classes inherit from , so any case of multiple inheritance provides more than one path to reach . To keep the base classes from being accessed more than once, the dynamic algorithm linearizes the search order in a way that preserves the left-to-right ordering specified in each class, that calls each parent only once, and that is monotonic (meaning that a class can be subclassed without affecting the precedence order of its parents). Taken together, these properties make it possible to design reliable and extensible classes with multiple inheritance. For more detail, see The Python 2.3 Method Resolution Order.\n\n“Private” instance variables that cannot be accessed except from inside an object don’t exist in Python. However, there is a convention that is followed by most Python code: a name prefixed with an underscore (e.g. ) should be treated as a non-public part of the API (whether it is a function, a method or a data member). It should be considered an implementation detail and subject to change without notice. Since there is a valid use-case for class-private members (namely to avoid name clashes of names with names defined by subclasses), there is limited support for such a mechanism, called name mangling. Any identifier of the form (at least two leading underscores, at most one trailing underscore) is textually replaced with , where is the current class name with leading underscore(s) stripped. This mangling is done without regard to the syntactic position of the identifier, as long as it occurs within the definition of a class. The private name mangling specifications for details and special cases. Name mangling is helpful for letting subclasses override methods without breaking intraclass method calls. For example: # provides new signature for update() # but does not break __init__() The above example would work even if were to introduce a identifier since it is replaced with in the class and in the class respectively. Note that the mangling rules are designed mostly to avoid accidents; it still is possible to access or modify a variable that is considered private. This can even be useful in special circumstances, such as in the debugger. Notice that code passed to or does not consider the classname of the invoking class to be the current class; this is similar to the effect of the statement, the effect of which is likewise restricted to code that is byte-compiled together. The same restriction applies to , and , as well as when referencing directly."
    },
    {
        "link": "https://datacamp.com/tutorial/python-oop-tutorial",
        "document": "Dive into data science using Python and learn how to effectively analyze and visualize your data. No coding experience or skills needed."
    },
    {
        "link": "https://geeksforgeeks.org/introduction-of-object-oriented-programming",
        "document": "As the name suggests, Object-Oriented Programming or OOPs refers to languages that use objects in programming. Object-oriented programming aims to implement real-world entities like inheritance, hiding, polymorphism, etc in programming. The main aim of OOP is to bind together the data and the functions that operate on them so that no other part of the code can access this data except that function.\n\nA class is a user-defined data type. It consists of data members and member functions, which can be accessed and used by creating an instance of that class. It represents the set of properties or methods that are common to all objects of one type. A class is like a blueprint for an object.\n\nFor Example: Consider the Class of Cars. There may be many cars with different names and brands but all of them will share some common properties like all of them will have 4 wheels, Speed Limit, Mileage range, etc. So here, Car is the class, and wheels, speed limits, mileage are their properties.\n\nIt is a basic unit of Object-Oriented Programming and represents the real-life entities. An Object is an instance of a Class. When a class is defined, no memory is allocated but when it is instantiated (i.e. an object is created) memory is allocated. An object has an identity, state, and behavior. Each object contains data and code to manipulate the data. Objects can interact without having to know details of each other’s data or code, it is sufficient to know the type of message accepted and type of response returned by the objects.\n\nFor example “Dog” is a real-life Object, which has some characteristics like color, Breed, Bark, Sleep, and Eats.\n\nData abstraction is one of the most essential and important features of object-oriented programming. Data abstraction refers to providing only essential information about the data to the outside world, hiding the background details or implementation. Consider a real-life example of a man driving a car. The man only knows that pressing the accelerators will increase the speed of the car or applying brakes will stop the car, but he does not know about how on pressing the accelerator the speed is increasing, he does not know about the inner mechanism of the car or the implementation of the accelerator, brakes, etc in the car. This is what abstraction is.\n\nEncapsulation is defined as the wrapping up of data under a single unit. It is the mechanism that binds together code and the data it manipulates. In Encapsulation, the variables or data of a class are hidden from any other class and can be accessed only through any member function of their class in which they are declared. As in encapsulation, the data in a class is hidden from other classes, so it is also known as data-hiding.\n\nConsider a real-life example of encapsulation, in a company, there are different sections like the accounts section, finance section, sales section, etc. The finance section handles all the financial transactions and keeps records of all the data related to finance. Similarly, the sales section handles all the sales-related activities and keeps records of all the sales. Now there may arise a situation when for some reason an official from the finance section needs all the data about sales in a particular month. In this case, he is not allowed to directly access the data of the sales section. He will first have to contact some other officer in the sales section and then request him to give the particular data. This is what encapsulation is. Here the data of the sales section and the employees that can manipulate them are wrapped under a single name “sales section”.\n\nInheritance is an important pillar of OOP(Object-Oriented Programming). The capability of a class to derive properties and characteristics from another class is called Inheritance. When we write a class, we inherit properties from other classes. So when we create a class, we do not need to write all the properties and functions again and again, as these can be inherited from another class that possesses it. Inheritance allows the user to reuse the code whenever possible and reduce its redundancy.\n\nThe word polymorphism means having many forms. In simple words, we can define polymorphism as the ability of a message to be displayed in more than one form. For example, A person at the same time can have different characteristics. Like a man at the same time is a father, a husband, an employee. So the same person posses different behavior in different situations. This is called polymorphism.\n\nIn dynamic binding, the code to be executed in response to the function call is decided at runtime. Dynamic binding means that the code associated with a given procedure call is not known until the time of the call at run time. Dynamic Method Binding One of the main advantages of inheritance is that some derived class D has all the members of its base class B. Once D is not hiding any of the public members of B, then an object of D can represent B in any context where a B could be used. This feature is known as subtype polymorphism.\n\nIt is a form of communication used in object-oriented programming as well as parallel programming. Objects communicate with one another by sending and receiving information to each other. A message for an object is a request for execution of a procedure and therefore will invoke a function in the receiving object that generates the desired results. Message passing involves specifying the name of the object, the name of the function, and the information to be sent.\n\nWhy do we need object-oriented programming\n• To make the development and maintenance of projects more effortless.\n• To provide the feature of data hiding that is good for security concerns.\n• We can solve real-world problems if we are using object-oriented programming.\n• It lets us write generic code: which will work with a range of data, so we don’t have to write basic stuff over and over again."
    },
    {
        "link": "https://medium.com/@ebimsv/mastering-classes-in-python-3-inheritance-and-polymorphism-4158f7664a52",
        "document": "Inheritance is a fundamental concept in object-oriented programming that allows a class to inherit attributes and methods from another class. The class that inherits is called the subclass (or derived class), and the class from which it inherits is called the superclass (or base class).\n• Code Reusability: Inheritance allows us to reuse code by inheriting common functionality from a base class.\n• Modularity: It helps in organizing code into a hierarchy of classes, making it easier to manage and understand.\n• Extensibility: New functionality can be added to existing code with minimal changes.\n\nTo create a subclass, you define a new class and specify the base class in parentheses.\n\nAn abstract method is a method that is declared in an abstract class, but it does not contain any implementation. The purpose of an abstract method is to be overridden by subclasses that provide the specific implementation of that method. The class serves as a base (or parent) class, and it contains an abstract method called , which is defined using the statement. This indicates that the method does not do anything in the class itself; it's just a placeholder.\n\nIn Python, to define an abstract class and enforce abstract methods, you typically use the module, specifically the class and the decorator. Here's how that would look:\n\nUsing the module helps make it clear that is intended to be an abstract class and that is an abstract method.\n\nMethod overriding allows a subclass to provide a specific implementation of a method that is already defined in its superclass. This is useful when the behavior of the method needs to be modified for the subclass.\n\nThe word polymorphism means having many forms. In programming, polymorphism means the same function name (but different signatures) being used for different types. The key difference is the data types and number of arguments used in a function.\n\nExample of inbuilt polymorphic functions in Python:\n\nUser-defined polymorphic functions allow you to write functions that can handle multiple types of data. Here’s a simple example in Python using a function that works with different types:\n• Method Overriding: As seen in the previous section, method overriding allows a subclass to provide a specific implementation of a method that is already defined in its superclass.\n• Method Overloading: Python does not support method overloading by default. However, you can achieve similar functionality by using default arguments or variable-length arguments.\n\nPolymorphism allows us to define methods in the superclass and override them in the subclass. We can then use these methods on objects of different subclasses, allowing for a common interface.\n\nCreate a class with the following requirements:\n• The class should have instance attributes and .\n• Define a method that returns a string with the vehicle details.\n• Create subclasses and that inherit from .\n• Override the method in each subclass to provide specific details.\n• Demonstrate polymorphism by creating a list of different vehicle objects and calling the method on each."
    },
    {
        "link": "https://geeksforgeeks.org/polymorphism-in-python",
        "document": "Polymorphism is a foundational concept in programming that allows entities like functions, methods or operators to behave differently based on the type of data they are handling. Derived from Greek, the term literally means “many forms”.\n\nPython’s dynamic typing and duck typing make it inherently polymorphic. Functions, operators and even built-in objects like loops exhibit polymorphic behavior.\n\nPython determines behavior at runtime, enabling these functions to work across diverse types without explicit type declarations.\n\nDuck typing enables functions to work with any object regardless of its type.\n\nIn Python, operators like + behave polymorphically, performing addition, concatenation or merging based on the data type.\n\nIn OOP, polymorphism allows methods in different classes to share the same name but perform distinct tasks. This is achieved through inheritance and interface design. Polymorphism complements other OOP principles like inheritance (sharing behavior) and encapsulation (hiding complexity) to create robust and modular applications.\n• None The code showcases polymorphism using a parent class Shape and child classes Rectangle and Circle.\n• Parent Class Shape: Contains a generic area method returning “Undefined”, acting as a placeholder for derived classes to override.\n• Child Class Rectangle: Initializes length and width via the __init__ constructor. Overrides the area method to return the rectangle’s area as length * width.\n• Child Class Circle: Initializes radius via the __init__ constructor. Overrides the area method to return the circle’s area as 3.14 * radius^2.\n• Polymorphic Behavior: A list of shape objects (Rectangle and Circle) is created. A for loop iterates through the list, calling the area method on each object. The method executed is determined by the object’s type, showcasing polymorphism.\n• None Found in statically typed languages like Java or C++, where the behavior of a function or operator is resolved during the program’s compilation phase.\n• None and operator overloading, where multiple functions or operators can share the same name but perform different tasks based on the context.\n• None In Python, which is dynamically typed, compile-time polymorphism is not natively supported. Instead, Python uses techniques like dynamic typing and duck typing to achieve similar flexibility.\n• None Occurs when the behavior of a method is determined at runtime based on the type of the object.\n• None In Python, this is achieved through : a child class can redefine a method from its parent class to provide its own specific implementation.\n• None Python’s dynamic nature allows it to excel at runtime polymorphism, enabling flexible and adaptable code.\n\nExplanation: Here, the sound method behaves differently depending on whether the object is a Dog, Cat or Animal and this decision happens at runtime. This dynamic nature makes Python particularly powerful for runtime polymorphism.\n\nInheritance-based polymorphism occurs when a subclass overrides a method from its parent class, providing a specific implementation. This process of re-implementing a method in the child class is known as Method Overriding.\n• Class Animal: Acts as the base (parent) class. Contains a method sound that provides a default behavior, returning “Some generic animal sound”. This serves as a generic representation of the sound method for all animals.\n• Class Dog: Inherits from the Animal class (denoted by class Dog(Animal)). Overrides the sound method to return “Woof Woof!”, a behavior specific to dogs. This demonstrates method overriding, where the subclass modifies the implementation of the parent class’s method.\n• Class Cat: Inherits from the Animal class (denoted by class Cat(Animal)). Overrides the sound method to return “Meow”, a behavior specific to cats. Like Dog, this also demonstrates method overriding.\n\nWhat is method overriding in polymorphism?\n\nHow to achieve polymorphism using class inheritance?\n\nCan polymorphism be achieved with functions in Python?\n\nHow does polymorphism help in writing flexible and maintainable code?\n\nPolymorphism allows you to write more flexible and maintainable code by enabling you to use a single interface to represent different underlying forms (data types). This means you can add new classes with their own implementations without altering the existing code, making it easier to extend and maintain.\n\nWhat is the role of abstract base classes in polymorphism?"
    },
    {
        "link": "https://digitalocean.com/community/tutorials/how-to-apply-polymorphism-to-classes-in-python-3",
        "document": "Polymorphism is the ability to leverage the same interface for different underlying forms such as data types or classes. This permits functions to use entities of different types at different times.\n\nFor object-oriented programming in Python, this means that a particular object belonging to a particular class can be used in the same way as if it were a different object belonging to a different class.\n\nPolymorphism allows for flexibility and loose coupling so that code can be extended and easily maintained over time.\n\nThis tutorial will go through applying polymorphism to classes in Python.\n\nYou should have Python 3 installed and a programming environment set up on your computer or server. If you don’t have a programming environment set up, you can refer to the installation and setup guides for a local programming environment or for a programming environment on your server appropriate for your operating system (Ubuntu, CentOS, Debian, etc.)\n\nPolymorphism is an important feature of class definition in Python that is utilized when you have commonly named methods across classes or subclasses. This allows functions to use objects of any of these polymorphic classes without needing to be aware of distinctions across the classes.\n\nPolymorphism can be carried out through inheritance, with subclasses making use of base class methods or overriding them.\n\nPython’s duck typing, a special case of dynamic typing, uses techniques characteristic of polymorphism, including late binding and dynamic dispatch. The term “duck typing” is derived from a quote of writer James Whitcomb Riley: “When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck.” Appropriated by Italian computer engineer Alex Martelli in a message to the comp.lang.python newsgroup, the use of duck typing is concerned with establishing the suitability of an object for a specific purpose. When using normal typing this suitability is determined by the type of an object alone, but with duck typing the presence of methods and properties are used to determine suitability rather than the actual type of the object in question. That is to say, you check whether the object quacks like a duck and walks like a duck rather than asking whether the object is a duck.\n\nWhen several classes or subclasses have the same method names, but different implementations for these same methods, the classes are polymorphic because they are using a single interface to use with entities of different types. A function will be able to evaluate these polymorphic methods without knowing which classes are invoked.\n\nTo make use of polymorphism, we’re going to create two distinct classes to use with two distinct objects. Each of these distinct classes need to have an interface that is in common so that they can be used polymorphically, so we will give them methods that are distinct but that have the same name.\n\nWe’ll create a class and a class, each of which will define methods for , , and .\n\nIn the code above, both the and class have three methods with the same name in common. However, each of the functionalities of these methods differ for each class.\n\nLet’s instantiate these classes into two objects:\n\nWhen we run the program with the command, we can see that each object behaves as expected:\n\nNow that we have two objects that make use of a common interface, we can use the two objects in the same way regardless of their individual types.\n\nTo show how Python can use each of these different class types in the same way, we can first create a loop that iterates through a tuple of objects. Then we can call the methods without being concerned about which class type each object is. We will only assume that these methods actually exist in each class.\n\nWe have two objects, of the class, and of the class. Our loop iterates through these objects, calling the , , and methods on each.\n\nWhen we run the program, the output will be as follows:\n\nThe loop iterated first through the instantiation of the class, then the object of the class, so we see the methods related to the class first, then the class.\n\nThis shows that Python is using these methods in a way without knowing or caring exactly what class type each of these objects is. That is, using these methods in a polymorphic way.\n\nWe can also create a function that can take any object, allowing for polymorphism.\n\nLet’s create a function called which takes in an object we can call . Though we are using the name , any instantiated object will be able to be called into this function:\n\nNext, we’ll give the function something to do that uses the object we passed to it. In this case we’ll call the methods, each of which is defined in the two classes and :\n\nNext, we’ll create instantiations of both the and classes if we don’t have them already. With those, we can call their action using the same function:\n\nWhen we run the program, the output will be as follows:\n\nEven though we passed a random object ( ) into the function when defining it, we were still able to use it effectively for instantiations of the and classes. The object called the method defined in the class, and the object called the method defined in the class.\n\nBy allowing different objects to leverage functions and methods in similar ways through polymorphism, making use of this Python feature provides greater flexibility and extendability of your object-oriented code."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/understanding-class-inheritance-in-python-3",
        "document": "Object-oriented programming creates reusable patterns of code to curtail redundancy in development projects. One way that object-oriented programming achieves recyclable code is through inheritance, when one subclass can leverage code from another base class.\n\nThis tutorial will go through some of the major aspects of inheritance in Python, including how parent classes and child classes work, how to override methods and attributes, how to use the function, and how to make use of multiple inheritance.\n\nYou should have Python 3 installed and a programming environment set up on your computer or server. If you don’t have a programming environment set up, you can refer to the installation and setup guides for a local programming environment or for a programming environment on your server appropriate for your operating system (Ubuntu, CentOS, Debian, etc.)\n\nInheritance is when a class uses code constructed within another class. If we think of inheritance in terms of biology, we can think of a child inheriting certain traits from their parent. That is, a child can inherit a parent’s height or eye color. Children also may share the same last name with their parents.\n\nClasses called child classes or subclasses inherit methods and variables from parent classes or base classes.\n\nWe can think of a parent class called that has class variables for , , and that the child class will inherit from the .\n\nBecause the subclass is inheriting from the base class, the class can reuse the code of , allowing the programmer to use fewer lines of code and decrease redundancy.\n\nParent or base classes create a pattern out of which child or subclasses can be based on. Parent classes allow us to create child classes through inheritance without having to write the same code over again each time. Any class can be made into a parent class, so they are each fully functional classes in their own right, rather than just templates.\n\nLet’s say we have a general parent class that has and child classes. Many of the methods between personal and business accounts will be similar, such as methods to withdraw and deposit money, so those can belong to the parent class of . The subclass would have methods specific to it, including perhaps a way to collect business records and forms, as well as an variable.\n\nSimilarly, an class may have and methods, and a subclass may include its own specific and methods.\n\nLet’s create a parent class that we will later use to construct types of fish as its subclasses. Each of these fish will have first names and last names in addition to characteristics.\n\nWe’ll create a new file called and start with the constructor method, which we’ll populate with and class variables for each object or subclass.\n\nWe have initialized our variable with the string because we know that most fish will have this as their last name.\n\nLet’s also add some other methods:\n\nWe have added the methods and to the class, so that every subclass will also be able to make use of these methods.\n\nSince most of the fish we’ll be creating are considered to be bony fish (as in they have a skeleton made out of bone) rather than cartilaginous fish (as in they have a skeleton made out of cartilage), we can add a few more attributes to the method:\n\nBuilding a parent class follows the same methodology as building any other class, except we are thinking about what methods the child classes will be able to make use of once we create those.\n\nChild or subclasses are classes that will inherit from the parent class. That means that each child class will be able to make use of the methods and variables of the parent class.\n\nFor example, a child class that subclasses the class will be able to make use of the method declared in without needing to declare it.\n\nWe can think of each child class as being a class of the parent class. That is, if we have a child class called and a parent class called , we can say that a is a , just as a is a .\n\nThe first line of a child class looks a little different than non-child classes as you must pass the parent class into the child class as a parameter:\n\nThe class is a child of the class. We know this because of the inclusion of the word in parentheses.\n\nWith child classes, we can choose to add more methods, override existing parent methods, or accept the default parent methods with the keyword, which we’ll do in this case:\n\nWe can now create a object without having to define any additional methods.\n\nWe have created a object that makes use of each of the methods of the class even though we did not define those methods in the child class. We only needed to pass the value of to the variable because all of the other variables were initialized.\n\nWhen we run the program, we’ll receive the following output:\n\nNext, let’s create another child class that includes its own method. We’ll call this class , and its special method will permit it to live with sea anemone:\n\nNext, let’s create a object to see how this works:\n\nWhen we run the program, we’ll receive the following output:\n\nThe output shows that the object is able to use the methods and as well as its child class method of .\n\nIf we try to use the method in a object, we’ll receive an error:\n\nThis is because the method belongs only to the child class, and not the parent class.\n\nChild classes inherit the methods of the parent class it belongs to, so each child class can make use of those methods within programs.\n\nSo far, we have looked at the child class that made use of the keyword to inherit all of the parent class behaviors, and another child class that inherited all of the parent class behaviors and also created its own unique method that is specific to the child class. Sometimes, however, we will want to make use of some of the parent class behaviors but not all of them. When we change parent class methods we override them.\n\nWhen constructing parent and child classes, it is important to keep program design in mind so that overriding does not produce unnecessary or redundant code.\n\nWe’ll create a child class of the parent class. Because we created the class with the idea that we would be creating primarily bony fish, we’ll have to make adjustments for the class that is instead a cartilaginous fish. In terms of program design, if we had more than one non-bony fish, we would most likely want to make separate classes for each of these two types of fish.\n\nSharks, unlike bony fish, have skeletons made of cartilage instead of bone. They also have eyelids and are unable to swim backwards. Sharks can, however, maneuver themselves backwards by sinking.\n\nIn light of this, we’ll be overriding the constructor method and the method. We don’t need to modify the method since sharks are fish that can swim. Let’s review this child class:\n\nWe have overridden the initialized parameters in the method, so that the variable is now set equal to the string , the variable is now set equal to the string , and the variable is now set to the Boolean value . Each instance of the class can also override these parameters.\n\nThe method now prints a different string than the one in the parent class because sharks are not able to swim backwards in the way that bony fish can.\n\nWe can now create an instance of the child class, which will still make use of the method of the parent class:\n\nWhen we run this code, we’ll receive the following output:\n\nThe child class successfully overrode the and methods of the parent class, while also inheriting the method of the parent class.\n\nWhen there will be a limited number of child classes that are more unique than others, overriding parent class methods can prove to be useful.\n\nWith the function, you can gain access to inherited methods that have been overwritten in a class object.\n\nWhen we use the function, we are calling a parent method into a child method to make use of it. For example, we may want to override one aspect of the parent method with certain functionality, but then call the rest of the original parent method to finish the method.\n\nIn a program that grades students, we may want to have a child class for that inherits from the parent class. In the child class , we may want to override a method of the parent class in order to include functionality to calculate a weighted grade, but still keep the rest of the functionality of the original class. By invoking the function we would be able to achieve this.\n\nThe function is most commonly used within the method because that is where you will most likely need to add some uniqueness to the child class and then complete initialization from the parent.\n\nTo see how this works, let’s modify our child class. Since trout are typically freshwater fish, let’s add a variable to the method and set it equal to the string , but then maintain the rest of the parent class’s variables and parameters:\n\nWe have overridden the method in the child class, providing a different implementation of the that is already defined by its parent class . Within the method of our class we have explicitly invoked the method of the class.\n\nBecause we have overridden the method, we no longer need to pass in as a parameter to , and if we did pass in a parameter, we would reset instead. We will therefore initialize the by calling the variable in our object instance.\n\nNow we can invoke the initialized variables of the parent class and also make use of the unique child variable. Let’s use this in an instance of :\n\nThe output shows that the object of the child class is able to make use of both the child-specific variable while also being able to call the parent variables of , , and .\n\nThe built-in Python function allows us to utilize parent class methods even when overriding certain aspects of those methods in our child classes.\n\nMultiple inheritance is when a class can inherit attributes and methods from more than one parent class. This can allow programs to reduce redundancy, but it can also introduce a certain amount of complexity as well as ambiguity, so it should be done with thought to overall program design.\n\nTo show how multiple inheritance works, let’s create a child class than inherits from a class and a class. We can create a method in each and then use the keyword in the child class:\n\nThe class has a method called that prints one line, and the class has a method called that prints another line. Then we call both classes into the inheritance tuple. This means that is inheriting from two parent classes.\n\nThe object is set as a object, and can use the methods in both parent classes. When we run the program, we’ll see the following output:\n\nThe output shows that methods from both parent classes were effectively used in the child class.\n\nMultiple inheritance allows us to use the code from more than one parent class in a child class. If the same method is defined in multiple parent methods, the child class will use the method of the first parent declared in its tuple list.\n\nThough it can be used effectively, multiple inheritance should be done with care so that our programs do not become ambiguous and difficult for other programmers to understand.\n\nThis tutorial went through constructing parent classes and child classes, overriding parent methods and attributes within child classes, using the function, and allowing for child classes to inherit from multiple parent classes.\n\nInheritance in object-oriented coding can allow for adherence to the DRY (don’t repeat yourself) principle of software development, allowing for more to be done with less code and repetition. Inheritance also compels programmers to think about how they are designing the programs they are creating to ensure that code is effective and clear."
    },
    {
        "link": "https://stackoverflow.com/questions/2129891/classes-methods-and-polymorphism-in-python",
        "document": "I made a module prototype with the aim of building complex timer schedules in python. The class prototypes emulate Timer objects, each with their waiting times, Repeat objects that group Timer and other Repeat objects, and a Schedule class, just for holding a whole construction or Timers and Repeat instances. The construction can be as complex as needed and needs to be flexible.\n\nEach of these three classes has a method, permitting to go through the whole schedule. Whatever the Class, the method either runs a timer, a repeat group for a certain number of iterations, or a schedule.\n\nIs this polymorphism-oriented approach sound or silly? What are other appropriate approaches I should consider to build such a versatile utility that permits to put all building blocks together in as complex a way as desired with simplicity?\n\nHere is the module code:"
    }
]