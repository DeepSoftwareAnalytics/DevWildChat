[
    {
        "link": "https://community.freepbx.org/t/ubuntu-20-04-freepbx-install-and-bad-news-for-php-version-7-4/67879",
        "document": "Download FreePBX Distro The easiest way to install FreePBX is to download and install the FreePBX Distro. This includes everything needed for a fully-functioning FreePBX system, including the operating system. Click on the link below to download..."
    },
    {
        "link": "https://community.freepbx.org/t/php-version-8-support-for-freepbx-16/87444",
        "document": "I upgraded FreePBX successfully from 15 to 16 by following the instruction.(Non Distro - Upgrade to FreePBX 16 - FreePBX OpenSource Project - Documentation)\n\nI noticed PHP 7.4 support is ended, and wondering whether it can be upgraded to version 8 or not.\n\n https://www.php.net/supported-versions.php\n\nIf it is already discussed topic, I apologize! Thank you very much and have a happy new year!"
    },
    {
        "link": "https://community.freepbx.org/t/freepbx-and-php-support/61295",
        "document": "As I understand the announcement of the beta release of FreePBX 15 it still does not support PHP 7.x. Some users sayed that FreePBX 14 runs with PHP 7.0 if no commercial modules are used. This is not true, I cannot run FreePBX 14 on a Debian 9 with PHP 7.0. FreePBX 16 will have support for PHP 7.3 (readed in the announcement of the beta release of FreePBX 15). But FreePBX 15 still is not released. Therefore I assumed that FreePBX 16 is released somewhat in the Year 2021 or 2022. And will it work with PHP 7.0 or need it PHP 7.3? In the meantime I need to have a separate server for FreePBX because modern webs (CMS) do not work anymore with PHP 5.\n\nYou should NOT run any other services on the same system as your PBX. If you are running on Debian you’re not using commercial modules anyway. 15.0 works fine with PHP 7 the general hangup seems to be QA on the 15 backup module. From what I have seen they have been breezing through these issues with the help of the community.\n\nThere is absolutely no rationale for “You should NOT run any other services on the same system as your PBX.” If your using Debian or anything not directly supported, It is not that “you’re not using” it’s that \"you can’t use it (because we rely on a no longer supported obfuscation) and don’t care \" be careful with your use of PHP 7 , many distros now are at 7.3 (current) FreePBX hobbles along with 7.0 in some areas, same areas will fail at +7.1\n\nAlso in this thread some people say that FreePBX 15 runs with PHP 7.x, but in the beta release notes it is very clear that FreePBX 15 only supports PHP 5.6. It seems that is the truth. By the way, commercial modules do not interest me. FreePBX is a very good software and I like to use it. But that it is still based on an outdated PHP version, I find it catasrophic. Also, the claim to be the only application on a server is almost cheeky for me. I have many different applications on the same server and that is not a problem. An additional server in the cloud alone for FreePBX is too expensive for me. FreePBX does not seem to be programmed to coexist with other applications. Very selfish.\n\nI have FreePBX 15 working on Debian 10, PHP 7.3 using the edge track. UCP, XMPP, everything works fine that I have tested out. I recommend you give it a try; test it for yourself. If it’s latest and greatest you want, it’s available. This comment is ridiculous, and your interests are very much in conflict with each other. What do you mean by “support”? Does a version of FreePBX 15 work with PHP 7.3: yes. Is Sangoma going to support that? Probably not yet, but if you want full Sangoma support, the path is clear: install FreePBX Distro with the current stable version of FreePBX on it. Should FreePBX coexist with other software? It’s open source; you can do whatever you want really. But I don’t see any reason Sangoma should support that. Cisco Call Manager used to run on a version of Windows 2003. Should they support a server that runs Call Manager and Minecraft? Absurd. Virtual machines are cheap. Set up one with FreePBX and another with your CMS.\n\nI run several phone servers with FreePBX and am very satisfied. Everyone runs in their own virtual machine with the FreePBX distro. So I know how to go that way. And I do not need the support of Sangoma, it works so well. I’m stumbling now, however, that I should get FreePBX on a server with Debian 9 and PHP 7.0 to work. An additional server will not be granted to me in this case. There are people and companies that save every penny. I opened another thread in which I describe that unfortunately I can not even change the path where the web should be installed. It seems to work, but then there are funny side effects.\n\nAnother version: If it ain’t official, it didn’t happen. BLUF: Working with the team and supporting the team is far more likely to get the team where we want the team to end up than sniping and complaining. Roll up your sleeve and dig it. FreePBX is a lot of things to a lot of people. While it would be wonderful if it just magically worked the myriad ways that people want, the economic model of OSS doesn’t really support that. If one has a problem with the system, one needs to contribute to get it fixed. If someone thinks that Sangoma should be fixing it because they’re “selling” it, they might need to look at the fine print. I, personally, believe that if someone is going to use free software, they need to support it with code. Of course, I’m old school - I started out on OSS with 386BSD 0.8. Even then, though, I needed a CD-ROM driver so I had to write it. I donated it back to the project and was rewarded with my CD working. Same deal here. If someone has a problem, almost all of the code is OSS - dig in and figure something out. We don’t learn without effort. If someone over-promises on a project, it isn’t up to our bosses to fix it by spending more money than we told them they would need to spend. We hate it when someone does it to us, people hate it when we do that to them. There are solutions. If one has a server, it can be virtualized. Implementations can be split across servers. Multiple PHP versions can be installed. The Distro can be used in the old fashioned way. There are different Asterisk Managers. There are no limits to the creative ways that we can solve these problems."
    },
    {
        "link": "https://community.freepbx.org/t/install-error/86309",
        "document": "Moved this to its own topic as the other one was 6 years old and the issue though related is not the same. As bill mentioned you have to use a supported version of PHP. To my knowledge no PHP 8.1 work has been done by the community or staff for FreePBX. The community did most of the work for PHP 7.X. If you want 8.x support you can likely contribute your efforts.\n\nAs with any major version change there is the possibility of backward-incompatibilities. PHP 7.4 → 8.0 has a boat load: PHP: Backward Incompatible Changes - Manual And then a few more for 8.1: PHP: Backward Incompatible Changes - Manual In other words, there should be no expectation that it would work on PHP 8.x. I think the PHP version that goes with the FreePBX version could be spelled out a little clearer in the documentation, though if you read through the install steps, you can see that you are installing PHP 7.4 for FreePBX 16 (ref: Installing FreePBX 16 on Debian 10.9 - FreePBX OpenSource Project - Documentation)\n\nYou are preaching to the choir, Tom. Perhaps our choir and Sangoma’s are attending different churches. The easy thing to do at this point is document what versions work together, as I suggested. The hard thing to do is update FreePBX, which is more rewarding for the long term. First steps that almost anyone with basic code editing experience could do to help advance FreePBX to a supported version of PHP:\n• review all the breaking changes in PHP from 7.4 up through 8.1\n• search through the code ( or the search tools in vscode will do just fine) to find the methods, statements, syntax, etc. that have changed, and update them. Bonus if you can make the changes backward compatible to 7.4."
    },
    {
        "link": "https://sangomakb.atlassian.net/wiki/spaces/FCD/pages?view=compact-list",
        "document": ""
    },
    {
        "link": "https://php.net/manual/en/pdo.query.php",
        "document": "PDO::query — Prepares and executes an SQL statement without placeholders For a query that you need to issue multiple times, you will realize better performance if you prepare a PDOStatement object using PDO::prepare() and issue the statement with multiple calls to PDOStatement::execute(). If you do not fetch all of the data in a result set before issuing your next call to PDO::query(), your call may fail. Call PDOStatement::closeCursor() to release the database resources associated with the PDOStatement object before issuing your next call to PDO::query(). If the contains placeholders, the statement must be prepared and executed separately using PDO::prepare() and PDOStatement::execute() methods. The SQL statement to prepare and execute. If the SQL contains placeholders, PDO::prepare() and PDOStatement::execute() must be used instead. Alternatively, the SQL can be prepared manually before calling PDO::query(), with the data properly formatted using PDO::quote() if the driver supports it. The default fetch mode for the returned PDOStatement. It must be one of the constants. If this argument is passed to the function, the remaining arguments will be treated as though PDOStatement::setFetchMode() was called on the resultant statement object. The subsequent arguments vary depending on the selected fetch mode. Emits an error with level if the attribute is set to . Throws a PDOException if the attribute is set to . Example #1 SQL with no placeholders can be executed using PDO::query() 'SELECT name, color, calories FROM fruit ORDER BY name' The above example will output:\n• None - Execute an SQL statement and return the number of affected rows PDO::exec() - Execute an SQL statement and return the number of affected rows"
    },
    {
        "link": "https://phpdelusions.net/pdo_examples/select",
        "document": "There are several ways to run a SELECT query using PDO, that differ mainly by the presence of parameters, type of parameters, and the result type. I will show examples for the every case so you can choose one that suits you best.\n\nJust make sure you've got a properly configured PDO connection variable that needs in order to run SQL queries with PDO and to inform you of the possible errors.\n\nIf there are no variables going to be used in the query, we can use a conventional method instead of prepare and execute.\n\nThis will give us an object that can be used to fetch the actual rows.\n\nIf a query is supposed to return just a single row, then you can just call method of the variable:\n\nNote that in PHP you can \"chain\" method calls, calling a method of the returned object already, like:\n\nThere are two ways to fetch multiple rows returned by a query. The most traditional way is to use the method within a loop:\n\nThis method could be recommended if rows have to be processed one by one. For example, if such processing is the only action that needs to be taken, or if the data needs to be pre-processed somehow before use.\n\nBut the most preferred way to fetch multiple rows which would to be shown on a web-page is calling the great helper method called . It will put all the rows returned by a query into a PHP array, that later can be used to output the data using a template (which is considered much better than echoing the data right during the fetch process). So the code would be\n\nBut most of time we have to use a variable or two in the query, and in such a case we should use a prepared statement (also called a parameterized query), first preparing a query with parameters (or placeholder marks) and then executing it, sending variables separately.\n\nIn PDO we can use both positional and named placeholders. For simple queries, personally I prefer positional placeholders, I find them less verbose, but it's entirely a matter of taste.\n\nFetching multiple rows from a prepared query would be identical to that from a query without parameters already shown:"
    },
    {
        "link": "https://php.net/manual/en/book.pdo.php",
        "document": "djlopez at gmx dot de ¶ Please note this:\n\n\n\nWon't work:\n\n$sth = $dbh->prepare('SELECT name, colour, calories FROM ? WHERE calories < ?');\n\n\n\nTHIS WORKS!\n\n$sth = $dbh->prepare('SELECT name, colour, calories FROM fruit WHERE calories < ?');\n\n\n\nThe parameter cannot be applied on table names!!\n\nwiserufferto at gmail dot com ¶ This is a little late... but I'm old and slow.......\n\nRegarding Extending PDOStatement and PDO I found that sending the PDOExtended class by reference helps:\n\n In the constructor after parent::__construct() :\n\n$this->setAttribute(\\PDO::ATTR_STATEMENT_CLASS,array('PDOStatementExtended', [&$this]));}\n\n\n\nAnd in \n\nclass PDOStatementExtended extends \\PDOStatement\n\n{\n\n \n\n protected function __construct\n\n (\n\n \\PDO &$PDO,\n\n )\n\npokojny at radlight dot com ¶ I wanted to extend PDO class to store statistics of DB usage, and I faced some problems. I wanted to count number of created statements and number of their executings. So PDOStatement should have link to PDO that created it and stores the statistical info. The problem was that I didn't knew how PDO creates PDOStatement (constructor parameters and so on), so I have created these two classes:\n\n\n\n\n\nClasses have properties with original PDO and PDOStatement objects, which are providing the functionality to PDOp and PDOpStatement.\n\nFrom outside, PDOp and PDOpStatement look like PDO and PDOStatement, but also are providing wanted info.\n\ndougwilbourne at gmail dot com ¶ Now that current versions of MySQL are forcing users to authenticate with caching_sha2_password instead of mysql_native_driver, I wanted to get PDO to send passwords that way. I think the only way to do it is to make the connection over SSL. Setting up your web server and database server for SSL is way beyond the scope of this note, but after you do, remember that you will need to add an options array as the last argument in your PDO connection arguments. At a minimum, you will need to supply the server certificate. In a development environment with a self-signed server certificate, you will also want to bypass verification that your server certificate is 'real'. So your options array would look like this\n\n\n\n$opts = [ PDO::MYSQL_ATTR_SSL_CA => $server_cert_file_path, PDO::MYSQL_ATTR_SSL_VERIFY_SERVER_CERT => false];\n\n\n\nHope it helps!"
    },
    {
        "link": "https://phpdelusions.net/pdo",
        "document": "\n• Getting data out of statement. foreach()\n• Getting data out of statement. fetch()\n• Getting data out of statement. fetchColumn()\n• Getting data out of statement in dozens different formats. fetchAll()\n• Getting rows grouped by some field\n• When emulation mode is turned ON\n• When emulation mode is turned OFF\n\nThere are many tutorials on PDO already, but unfortunately, most of them fail to explain the real benefits of PDO, or even promote rather bad practices. The only two exceptions are phptherightway.com and hashphp.org, but they miss a lot of important information. As a result, half of PDO's features remain in obscurity and are almost never used by PHP developers, who, as a result, are constantly trying to reinvent the wheel which already exists in PDO.\n\nUnlike those, this tutorial is written by someone who has used PDO for many years, dug through it, and answered thousands questions on Stack Overflow (the sole gold PDO badge bearer). Following the mission of this site, this article will disprove various delusions and bad practices, while showing the right way instead.\n\nAlthough this tutorial is based on mysql driver, the information, in general, is applicable for any driver supported.\n\nFirst things first. Why at all?\n\nPDO is a Database Access Abstraction Layer. The abstraction, however, is two-fold: one is widely known but less significant, while another is obscure but of most importance.\n\nEveryone knows that PDO offers unified interface to access many different databases. Although this feature is magnificent by itself, it doesn't make a big deal for the particular application, where only one database backend is used anyway. And, despite some rumors, it is impossible to switch database backends by changing a single line in PDO config - due to different SQL flavors (to do so, one needs to use an averaged query language like DQL). Thus, for the average LAMP developer, this point is rather insignificant, and to them, PDO is just a more complicated version of a familiar function. However, it is not; PDO is much more.\n\nPDO abstracts not only a database API, but also basic operations that otherwise have to be repeated hundreds of times in every application, making your code extremely .\n\nThe real benefits of PDO are:\n• reusability (unified API to access multitude of databases, from SQLite to Oracle)\n\nNote that although PDO is the best out of native db drivers, for a modern web-application consider using an ORM with a Query Builder, or any other higher level abstraction library, with only occasional fallback to vanilla PDO. Good ORMs are Doctrine, Eloquent, RedBean, and Yii::AR. Aura.SQL is a good example of a PDO wrapper with many additional features.\n\nEither way, it's good to know the basic tools first. So, let's begin:\n\nPDO has a fancy connection method called DSN. It's nothing complicated though - instead of one plain and simple list of options, PDO asks you to input different configuration directives in three different places (all examples given for Mysql, for other drivers consult their respective sections in the PHP manual):\n• , , and , as well as less frequently used and go into DSN;\n• and go to constructor;\n• all other options go into options array.\n\nwhere DSN is a semicolon-delimited string, consists of pairs, that begins from the driver name and a colon:\n\nNote that it's important to follow the proper format - no spaces or quotes or other decorations have to be used in DSN, but only parameters, values and delimiters, as shown in the manual.\n\nHere goes an example for mysql:\n\nWith all aforementioned variables properly set, we will have proper PDO instance in the variable.\n• Unlike old functions, which can be used anywhere in the code, instance is stored in a regular variable, which means it can be inaccessible inside functions - so, one has to make it accessible, by means of passing it via function parameters or using more advanced techniques, such as IoC container.\n• The connection has to be made strictly once! There must be no connections inside each function or class constructor. In this case multiple connections will be created, which will eventually kill your database server. Thus, a sole PDO instance has to be created and then used through the whole script execution.\n• It is very important to set charset through DSN - that's the only proper way because it tells PDO which charset is going to be used. Therefore forget about running query manually, either via or . Only if your PHP version is unacceptably outdated (namely below 5.3.6), you have to use query and always turn emulation mode off.\n\nMore details regarding Mysql can be found in the corresponding chapter, Connecting to MySQL\n\nThere are two ways to run a query in PDO. If no variables are going to be used in the query, you can use the PDO::query() method. It will run your query and return a special object of PDOStatement class which can be roughly compared to a resource returned by , especially in the way you can get actual rows from of it:\n\nAlso, the method allows us to use a neat method chaining for SELECT queries, which will be shown below.\n\nThis is the main and the only important reason why you were deprived from your beloved function and thrown into the harsh world of Data Objects: PDO has prepared statements support out of the box. Prepared statement (also called a parameterized query) is the only proper way to run a query, if any variable is going to be used in it. The reason why it is so important is explained in detail in The Hitchhiker's Guide to SQL Injection prevention.\n\nSo, for every query you run, if at least one variable is going to be used, you have to substitute it with a placeholder, then prepare your query, and then execute it, passing variables separately.\n\nLong story short, it is not as hard as it seems. In most cases, you need only two functions - prepare() and execute().\n\nFirst of all, you have to alter your query, adding placeholders in place of variables. Say, a code like this\n\nNote that PDO supports positional ( ) and named ( ) placeholders, the latter always begins from a colon and can be written using letters, digits and underscores only. Also note that no quotes have to be ever used around placeholders.\n\nHaving a query with placeholders, you have to prepare it, using the method. This function will return the same object we were talking about above, but without any data attached to it.\n\nFinally, to get the query executed, you must run method of this object, passing variables in it, in the form of array. And after that, you will be able to get the resulting data out of statement (if applicable):\n\nAs you can see, for the positional placeholders, you have to supply a regular array with values, while for the named placeholders, it has to be an associative array, where keys have to match the placeholder names in the query. You cannot mix positional and named placeholders in the same query.\n\nPlease note that positional placeholders let you write shorter code, but are sensitive to the order of arguments (which have to be exactly the same as the order of the corresponding placeholders in the query). While named placeholders make your code more verbose, they allow random binding order.\n\nAlso note that despite a widespread delusion, no \" \" in the keys is required.\n\nAfter the execution you may start getting your data, using all supported methods, as described down in this article.\n\nMore examples can be found in the respective article.\n\nPassing data into (like shown above) should be considered the default and most convenient method. When this method is used, all values will be bound as strings (save for values, that will be sent to the query as is, i.e. as SQL ), but most of time it's all right and won't cause any problem.\n\nHowever, sometimes it's better to set the data type explicitly. Possible cases are:\n• LIMIT clause (or any other SQL clause that just cannot accept a string operand) if emulation mode is turned ON.\n• complex queries with non-trivial query plan that can be affected by a wrong operand type\n• peculiar column types, like or that require an operand of exact type to be bound (note that in order to bind a BIGINT value with PDO::PARAM_INT you need a mysqlnd-based installation).\n\nIn such a case explicit binding have to be used, for which you have a choice of two functions, bindValue() and bindParam(). The former one has to be preferred, because, unlike it has no side effects to deal with.\n\nIt is very important to understand which query parts you can bind using prepared statements and which you cannot. In fact, the list is overwhelmingly short: only string and numeric literals can be bound. So you can tell that as long as your data can be represented in the query as a numeric or a quoted string literal - it can be bound. For all other cases you cannot use PDO prepared statements at all: neither an identifier, or a comma-separated list, or a part of a quoted string literal or whatever else arbitrary query part cannot be bound using a prepared statement.\n\nWorkarounds for the most frequent use cases can be found in the corresponding part of the article\n\nSometimes you can use prepared statements for the multiple execution of a prepared query. It is slightly faster than performing the same query again and again, as it does query parsing only once. This feature would have been more useful if it was possible to execute a statement prepared in another PHP instance. But alas - it is not. So, you are limited to repeating the same query only within the same instance, which is seldom needed in regular PHP scripts and which is limiting the use of this feature to repeated inserts or updates:\n\nNote that this feature is a bit overrated. Not only it is needed too seldom to talk about, but the performance gain is not that big - query parsing is real fast these times.\n\nNote that you can get this advantage only when emulation mode is turned off.\n\nRunning these queries is not different from SELECT.\n\nJust like it was shown above, what you need is to prepare a query with placeholders and then execute it, sending variables separately. Either for and query the process is essentially the same. The only difference is (as queries do not return any data), that you can use the method chaining and thus call right along with :\n\nHowever, if you want to get the number of affected rows, the code will have to be the same boresome three lines:\n\nMore examples can be found in the respective article.\n\nGetting data out of statement. foreach()\n\nThe most basic and direct way to get multiple rows from a statement would be loop. Thanks to Traversable interface, can be iterated over by using operator:\n\nNote that this method is memory-friendly, as it doesn't load all the resulting rows in the memory but delivers them one by one (though keep in mind this issue).\n\nGetting data out of statement. fetch()\n\nWe have seen this function already, but let's take a closer look. It fetches a single row from database, and moves the internal pointer in the result set, so consequent calls to this function will return all the resulting rows one by one. Which makes this method a rough analogue to but it works in a slightly different way: instead of many separate functions ( , , etc), there is only one, but its behavior can be changed by a parameter. There are many fetch modes in PDO, and we will discuss them later, but here are few for starter:\n• - both of the above\n• allows all three (numeric associative and object) methods without memory overhead.\n\nFrom the above you can tell that this function have to be used in two cases:\n• When only one row is expected - to get that only row. For example, Will give you single row from the statement, in the form of associative array.\n• When we need to process the returned data somehow before use. In this case it have to be run through usual while loop, like one shown above.\n\nAnother useful mode is , which can create an object of particular class\n\nwill produce an array filled with objects of News class, setting class properties from returned values. Note that in this mode\n• for all undefined properties magic method will be called\n• if there is no method in the class, then new property will be created\n• private properties will be filled as well, which is a bit unexpected but quite handy\n\nNote that default mode is , but you can change it using configuration option as shown in the connection example. Thus, once set, it can be omitted most of the time.\n\nStarting from PHP 8.3, it is safe to assume that PDO would return and values with respective types all the time. Say, if we create a table\n\nAnd then query it using PDO, the output will be\n\nBefore that, it only happened when emulation mode was turned off (and mysqlnd used, which is now a standard). Otherwise the familiar behavior was followed - all values returned as strings with only returned as .\n\nIf, for some reason, you don't like this behavior and prefer the old style with strings and NULLs only, then you can use the following configuration option to override it:\n\nNote that for the type, string is always returned, due to nature of this type intended to retain the precise value, unlike deliberately non-precise FLOAT and DOUBLE types.\n\nGetting data out of statement. fetchColumn()\n\nA neat helper function that returns value of the single field of returned row. Very handy when we are selecting only one field:\n\nGetting data out of statement in dozens different formats. fetchAll()\n\nThat's most interesting function, with most astonishing features. Mostly thanks to its existence one can call PDO a wrapper, as this function can automate many operations otherwise performed manually.\n\nreturns an array that consists of all the rows returned by the query. From this fact we can make two conclusions:\n• This function should not be used if many* rows have been selected. In such a case, a conventional while loop should be used to fetch rows one by one instead of getting them all as an array at once.\n\n * \"many\" means more than is suitable to be shown on the average web page.\n• This function is mostly useful in a modern web application that never outputs data right away during fetching, but rather passes it to template.\n\nYou'd be amazed, in how many different formats this function can return data in (and how little an average PHP user knows of them), all controlled by variables. Some of them are:\n\nBy default, this function will return just simple enumerated array consists of all the returned rows. Row formatting constants, such as , , etc can change the row format.\n\nIt is often very handy to get plain one-dimensional array right out of the query, if only one column out of many rows being fetched. Here you go:\n\nAlso extremely useful format, when we need to get the same column, but indexed not by numbers in order but by another field. Here goes constant:\n\nNote that you have to select only two columns for this mode, first of which has to be unique.\n\nSame as above, but getting not one column but full row, yet indexed by an unique field, thanks to constant:\n\nNote that first column selected has to be unique (in this query it is assumed that first column is id, but to be sure better list it explicitly).\n\nGetting rows grouped by some field\n\nwill group rows into a nested array, where indexes will be unique values from the first column, and values will be arrays similar to ones returned by regular . The following code, for example, will separate boys from girls and put them into different arrays:\n\nSo, this is the ideal solution for such a popular demand like \"group events by date\" or \"group goods by category\". Some real life use cases:\n• How to multiple query results in order to reduce the query number?\n\nOf course, there is a for the functional programming fans.\n\nMore modes are coming soon.\n\nAlthough there are several error handling modes in PDO, the only proper one is . So, one ought to always set it this way, either by adding this line after creation of PDO instance,\n\nor as a connection option, as demonstrated in the example above. And this is all you need for the basic error reporting.\n\nTL;DR:\n\n Despite what all other tutorials say, you don't need a operator to report PDO errors. Catch an exception only if you have a handling scenario other than just reporting it. Otherwise just let it bubble up to a site-wide handler (note that you don't have to write one, there is a basic built-in handler in PHP, which is quite good).\n\nThe only exception (pun not intended) is the creation of the PDO instance, which in case of error might reveal the connection credentials (that would be the part of the stack trace). In order to hide them, we can wrap the connection code into a operator and then throw a new that contains only the message but not the credentials.\n\nDespite a widespread delusion, you should never catch errors to report them. A module (like a database layer) should not report its errors. This function has to be delegated to an application-wide handler. All we need is to raise an error (in the form of exception) - which we already did. That's all. Nor should you \"always wrap your PDO operations in a \" like the most popular tutorial from tutsplus recommends. Quite contrary, catching an exception should be rather an exceptional case (pun intended).\n\nIn fact, there is nothing special in PDO exceptions - they are errors all the same. Thus, you have to treat them exactly the same way as other errors. If you had an error handler before, you shouldn't create a dedicated one for PDO. If you didn't care - it's all right too, as PHP is good with basic error handling and will conduct PDO exceptions all right.\n\nException handling is one of the problems with PDO tutorials. Being acquainted with exceptions for the first time when starting with PDO, authors consider exceptions dedicated to this library, and start diligently (but improperly) handling exceptions for PDO only. This is utter nonsense. If one paid no special attention to any exceptions before, they shouldn't have changed their habit for PDO. If one didn't use before, they should keep with that, eventually learning how to use exceptions and when it is suitable to catch them.\n\nSo now you can tell that the PHP manual is wrong, stating that\n\nHowever, there is no such thing as \"the displaying of a back trace\"! What zend engine really does is just convert an uncaught exception into a fatal error. And then this fatal error is treated like any other error - so it will be displayed only if appropriate directive is set. Thus, although you may or you may not catch an exception, it has absolutely nothing to do with displaying sensitive information, because it's a totally different configuration setting in response to this. So, do not catch PDO exceptions to report them. Instead, configure your server properly:\n\nOn a development server just turn displaying errors on:\n\nWhile on a production server turn displaying errors off while logging errors on:\n• keep in mind that there are other errors that shouldn't be revealed to the user as well.\n\nYou may want to catch PDO errors only in two cases:\n• If you are writing a wrapper for PDO, and you want to augment the error info with some additional data, like query string. In this case, catch the exception, gather the required information, and re-throw another Exception.\n• If you have a certain scenario for handling errors in the particular part of code. Some examples are:\n• if the error can be bypassed, you can use try..catch for this. However, do not make it a habit. Empty catch in every aspect works as error suppression operator, and so equally evil it is.\n• if there is an action that has to be taken in case of failure, i.e. transaction rollback.\n• if you are waiting for a particular error to handle. In this case, catch the exception, see if the error is one you're looking for, and then handle this one. Otherwise just throw it again - so it will bubble up to the handler in the usual way.\n\nHowever, in general, no dedicated treatment for PDO exceptions is ever needed. In short, to have PDO errors properly reported:\n• Do not use to report errors.\n• Configure PHP for proper error reporting\n• on a development site, you may want to set\n• of course, has to be set to E_ALL in both cases\n\nAs a result, you will be always notified of all database errors without a single line of extra code! Further reading.\n\nAlthough PDO offers a function for returning the number of rows found by the query, , you scarcely need it. Really.\n\nIf you think it over, you will see that this is a most misused function in the web. Most of time it is used not to count anything, but as a mere flag - just to see if there was any data returned. But for such a case you have the data itself! Just get your data, using either or - and it will serve as such a flag all right! Say, to see if there is any user with such a name, just select a row:\n\nExactly the same thing with getting either a single row or an array with rows:\n\nRemember that here you don't need the count, the actual number of rows, but rather a boolean flag. So you got it.\n\nNot to mention that the second most popular use case for this function should never be used at all. One should never use the to count rows in database! Instead, one has to ask a database to count them, and return the result in a single row:\n\nis the only proper way.\n• if you need to know how many rows in the table, use query.\n• if you need to know whether your query returned any data - check that data.\n• if you still need to know how many rows has been returned by some query (though I hardly can imagine a case), then you can either use or simply call on the array returned by (if applicable).\n\nThus you could tell that the top answer for this question on Stack Overflow is essentially pointless and harmful - a call to could be never substituted with query - their purpose is essentially different, while running an extra query only to get the number of rows returned by other query makes absolutely no sense.\n\nPDO is using the same function for returning both number of rows returned by SELECT statement and number of rows affected by queries - . Thus, to get the number of rows affected, just call this function after performing a query.\n\nAnother frequently asked question is caused by the fact that mysql won't update the row, if new value is the same as old one. Thus number of rows affected could differ from the number of rows matched by the WHERE clause. Sometimes it is required to know this latter number.\n\nAlthough you can tell to return the number of rows matched instead of rows affected by setting option to TRUE, but, as this is a connection-only option and thus you cannot change it's behavior during runtime, you will have to stick to only one mode for the application, which could be not very convenient.\n\nNote that is not guaranteed to work, as it's described in the comment below.\n\nUnfortunately, there is no PDO counterpart for the function which output can be easily parsed and desired number found. This is one of minor PDO drawbacks.\n\nAn auto-generated identifier from a sequence or auto_inclement field in mysql can be obtained from the PDO::lastInsertId function. An answer to a frequently asked question, \"whether this function is safe to use in concurrent environment?\" is positive: yes, it is safe. Being just an interface to MySQL C API mysql_insert_id() function it's perfectly safe.\n\nDespite PDO's overall ease of use, there are some gotchas anyway, and I am going to explain some.\n\nOne of them is using placeholders with SQL clause. At first one would think that such a query will do:\n\nbut soon they will learn that it will produce an error. To understand its nature one has to understand that, like it was said above, a placeholder has to represent a complete data literal only - a string or a number namely. And by no means it can represent either a part of a literal or some arbitrary SQL. So, when working with LIKE, we have to prepare our complete literal first, and then send it to the query the usual way:\n\nJust like it was said above, it is impossible to substitute an arbitrary query part with a placeholder. Any string you bind through a placeholder will be put into query as a literal string. For example, a string will be bound as a is, resulting in\n\nmaking SQL to search for just one value.\n\nTo make it right, one needs separated values, to make a query look like\n\nThus, for the comma-separated values, like for SQL operator, one must create a set of s manually and put them into the query:\n\nIn case there are other placeholders in the query, you could use function to join all the variables into a single array, adding your other variables in the form of arrays, in the order they appear in your query:\n\nIn case you are using named placeholders, the code would be a little more complex, as you have to create a sequence of the named placeholders, e.g. . So the code would be:\n\nLuckily, for the named placeholders we don't have to follow the strict order, so we can merge our arrays in any order.\n\nOn Stack Overflow I've seen overwhelming number of PHP users implementing the most fatal PDO code, thinking that only data values have to be protected. But of course it is not.\n\nUnfortunately, PDO has no placeholder for identifiers (table and field names), so a developer must manually filter them out. Such a filter is often called a \"white list\" (where we only list allowed values) as opposed to a \"black list\" where we list disallowed values. Here is a brief example\n\nthe same approach should be used for the direction, although the code would be a bit simpler\n\nhaving gottent these two variables this way will make them 100% safe\n\nThe same approach must be used every time a table of a field name is going to be used in the query.\n\nAnother problem is related to the SQL clause. When in emulation mode (which is on by default), PDO substitutes placeholders with actual data, instead of sending it separately. And with \"lazy\" binding (using array in ), PDO treats every parameter as a string. As a result, the prepared query becomes which is invalid syntax that causes query to fail.\n\nThere are two solutions:\n\nOne is turning emulation off (as MySQL can sort all placeholders properly). To do so one can run this code:\n\nAnd parameters can be kept in :\n\nAnother way would be to bind these variables explicitly while setting the proper param type:\n\nIn the past, there was one peculiar thing about : it didn't enforce the type casting. Thus, using it on a number that has a string type was causing the aforementioned error:\n\nBut it was fixed in current PHP versions.\n\nTo successfully run a transaction, you have to make sure that error mode is set to exceptions, and learn three canonical methods:\n• to cancel all the changes you made since transaction start.\n\nExceptions are essential for transactions because they can be caught. So in case one of the queries failed, the execution will be stopped and moved straight to the catch block, where the whole transaction will be rolled back.\n\nSo a typical example would be like\n\nPlease note the following important things:\n• PDO error reporting mode should be set to\n• you have catch an , not , as it doesn't matter what particular exception aborted the execution.\n• you should re-throw an exception after rollback, to be notified of the problem the usual way.\n• also make sure that a table engine supports transactions (i.e. for Mysql it should be InnoDB, not MyISAM)\n• there are no Data definition language (DDL) statements that define or modify database schema among queries in your transaction, as such a query will cause an implicit commit\n\nThere is one thing about stored procedures any programmer stumbles upon at first: every stored procedure always returns one extra result set: one (or many) results with actual data and one just empty. Which means if you try to call a procedure and then proceed to another query, then \"Cannot execute queries while other unbuffered queries are active\" error will occur, because you have to clear that extra empty result first. Thus, after calling a stored procedure that is intended to return only one result set, just call once (of course after fetching all the returned data from statement, or it will be discarded):\n\nWhile for the stored procedures returning many result sets the behavior will be the same as with multiple queries execution:\n\nHowever, as you can see here is another trick have to be used: remember that extra result set? It is so essentially empty that even an attempt to fetch from it will produce an error. So, we cannot use just . Instead, we have to check also for empty result. For which purpose is just excellent.\n\nThis feature is one of essential differences between old mysql ext and modern libraries: after calling a stored procedure with there was no way to continue working with the same connection, because there is no function for . One had to close the connection and then open a new one again in order to run other queries after calling a stored procedure.\n\nCalling a stored procedure is a rare case where use is justified, as it's the only way to handle and parameters. The example can be found in the corresponding manual chapter. However, for mysql it doesn't work. You have to resort to an SQL variable and an extra call.\n\nNote that for the different databases the syntax could be different as well. For example, to run a sored procedure against Microsoft SQL server, use the following format\n\nwhere ? marks are placeholders. Note that no braces should be used in the call.\n\nWhen in emulation mode, PDO can run mutiple queries in the same statement, either via query() or . To access the result of consequent queries one has to use :\n\nWithin this loop you'll be able to gather all the related information from the every query, like affected rows, auto-generated id or errors occurred.\n\nIt is important to understand that at the point of PDO will report the error for the first query only. But if error occurred at any of consequent queries, to get that error one has to iterate over results. Despite some ignorant opinions, PDO can not and should not report all the errors at once. Some people just cannot grasp the problem at whole, and don't understand that error message is not the only outcome from the query. There could be a dataset returned, or some metadata like insert id. To get these, one has to iterate over resultsets, one by one. But to be able to throw an error immediately, PDO would have to iterate automatically, and thus discard some results. Which would be a clear nonsense.\n\nUnlike PDO doesn't make an asynchronous call, so you can't \"fire and forget\" - send bulk of queries to mysql and close connection, PHP will wait until last query gets executed.\n\nOne of the most controversial PDO configuration options is . What does it do? PDO can run your queries in two ways:\n• It can use a real or native prepared statement:\n\n When prepare() is called, your query with placeholders gets sent to mysql as is, with all the question marks you put in (in case named placeholders are used, they are substituted with ?s as well), while actual data goes later, when execute() is called.\n• It can use emulated prepared statement, when your query is sent to mysql as proper SQL, with all the data in place, properly formatted. In this case only one roundtrip to database happens, with call. For some drivers (including mysql) emulation mode is turned by default.\n\nBoth methods has their drawbacks and advantages but, and - I have to stress on it - both being equally secure, if used properly. Despite rather appealing tone of the popular article on Stack Overflow, in the end it says that if you are using supported versions of PHP and MySQL properly, you are 100% safe. All you have to do is to set encoding in the DSN, as it shown in the example above, and your emulated prepared statements will be as secure as real ones.\n\nNote that when native mode is used, the data is never appears in the query, which is parsed by the engine as is, with all the placeholders in place. If you're looking into Mysql query log for your prepared query, you have to understand that it's just an artificial query that has been created solely for logging purpose, but not a real one that has been executed.\n\nOther issues with emulation mode as follows:\n\nWhen emulation mode is turned ON\n\none can use a handy feature of named prepared statements - a placeholder with same name could be used any number of times in the same query, while corresponding variable have to be bound only once. For some obscure reason this functionality is disabled when emulation mode is off:\n\nAlso, when emulation is , PDO is able to run multiple queries in one prepared statement.\n\nAlso, as native prepared statements support only certain query types, you can run some queries with prepared statements only when emulation is . The following code will return table names in emulation mode and error otherwise:\n\nWhen emulation mode is turned OFF\n\nOne could bother not with parameter types, as mysql will sort all the types properly. Thus, even string can be bound to LIMIT parameters, as it was noted in the corresponding chapter.\n\nAlso, this mode will allow to use the advantage of single prepare-multiple execute feature.\n\nIt's hard to decide which mode have to be preferred, but for usability sake I would rather turn it , to avoid a hassle with clause. Other issues could be considered negligible in comparison.\n\nRecently all PHP extensions that work with mysql database were updated based on a low-level library called , which replaced old client. Thus some changes in the PDO behavior, mostly described above and one that follows:\n\nThere is one thing called buffered queries. Although you probably didn't notice it, you were using them all the way. Unfortunately, here are bad news for you: unlike old PHP versions, where you were using buffered queries virtually for free, modern versions built upon mysqlnd driver won't let you to do that anymore:\n\nThe whole thing is about a resultset, which stands for all the data found by the query.\n\nWhen your SELECT query gets executed, there are two ways to deliver the results in your script: buffered and unbuffered one. When buffered method is used, all the data returned by the query gets copied in the script's memory at once. While in unbuffered mode a database server feeds the found rows one by one.\n\nSo you can tell that in buffered mode a resultset is always burdening up the memory on the server even if fetching weren't started at all. Which is why it is not advisable to select huge datasets if you don't need all the data from it.\n\nNonetheless, when old libmysql-based clients were used, this problem didn't bother PHP uers too much, because the memory consumed by the resultset didn't count in the the and .\n\nBut with mysqlnd things got changed, and the resultset returned by the buffered query will be count towards both and , no matter which way you choose to get the result:\n\nwhich means that with buffered query the memory is consumed even if you're fetching rows one by one!\n\nSo, keep in mind that if you are selecting a really huge amount of data, always set to .\n\nOf course, there are drawbacks. One is infamous\n\nerror message which means that until you won't retrieve all the selected rows from the unbuffered query, it will be impossible to run any other query against hte same database connection.\n• With unbuffered query you can't use method (which is useless, as we learned above)\n• Moving (seeking) the current resultset internal pointer back and forth (which is useless as well)."
    },
    {
        "link": "https://php.net/manual/en/pdo.prepare.php",
        "document": "Anonymous ¶ To those wondering why adding quotes to around a placeholder is wrong, and why you can't use placeholders for table or column names:\n\n\n\nThere is a common misconception about how the placeholders in prepared statements work: they are not simply substituted in as (escaped) strings, and the resulting SQL executed. Instead, a DBMS asked to \"prepare\" a statement comes up with a complete query plan for how it would execute that query, including which tables and indexes it would use, which will be the same regardless of how you fill in the placeholders.\n\n\n\nThe plan for \"SELECT name FROM my_table WHERE id = :value\" will be the same whatever you substitute for \":value\", but the seemingly similar \"SELECT name FROM :table WHERE id = :value\" cannot be planned, because the DBMS has no idea what table you're actually going to select from.\n\n\n\nEven when using \"emulated prepares\", PDO cannot let you use placeholders anywhere, because it would have to work out what you meant: does \"Select :foo From some_table\" mean \":foo\" is going to be a column reference, or a literal string?\n\n\n\nWhen your query is using a dynamic column reference, you should be explicitly white-listing the columns you know to exist on the table, e.g. using a switch statement with an exception thrown in the default: clause.\n\nSimon Le Pine ¶ Hi All,\n\n\n\nFirst time posting to php.net, a little nervous.\n\n\n\nAfter a bunch of searching I've learned 2 things about prepared statements:\n\n1.) It fails if you enclose in a single quote (')\n\nThis fails: \"SELECT * FROM users WHERE email=':email'\"\n\nThis works: \"SELECT * FROM users WHERE email=:email\"\n\n2.) You cannot search with a prepared statement\n\nThis fails: \"SELECT * FROM users WHERE :search=:email\"\n\nThis succeeds: \"SELECT * FROM users WHERE $search=:email\"\n\n\n\nIn my case I allow the user to enter their username or email, determine which they've entered and set $search to \"username\" or \"email\". As this value is not entered by the user there is no potential for SQL injection and thus safe to use as I have done.\n\n\n\nHope that saves someone else from a lot of searching.\n\nadmin at wdfa dot co dot uk ¶ Note on the SQL injection properties of prepared statements.\n\n\n\nPrepared statements only project you from SQL injection IF you use the bindParam or bindValue option.\n\n\n\nFor example if you have a table called users with two fields, username and email and someone updates their username you might run\n\n\n\nUPDATE `users` SET `user`='$var'\n\n\n\nwhere $var would be the user submitted text. \n\n\n\nNow if you did \n\n \n\nand the user had entered User', email='test for a test the injection would occur and the email would be updated to test as well as the user being updated to User.\n\n\n\nUsing bindParam as follows\n\n \n\nThe sql would be escaped and update the username to User', email='test'\n\nMark Simon ¶ Many students are tempted to add single quotes around string place holders in the SQL statement, since that’s what they normally do around strings in SQL and PHP.\n\n\n\nI have to explain:\n\n\n\nQuotes are not part of the string — they are used to construct a string in the coding language. If you are creating a string literal in SQL or PHP, then it must indeed be quoted. If the string has already been created, and is being passed on, then additional quotes would be wrong at best, and mis-interpreted at worst.\n\n\n\nIn prepared place holders, think of place holders as variables, which, whether they are strings or other values, are always written without quotes.\n\npublic at grik dot net ¶ With PDO_MYSQL you need to remember about the PDO::ATTR_EMULATE_PREPARES option.\n\n\n\nThe default value is TRUE, like\n\n$dbh->setAttribute(PDO::ATTR_EMULATE_PREPARES,true); \n\n\n\nThis means that no prepared statement is created with $dbh->prepare() call. With exec() call PDO replaces the placeholders with values itself and sends MySQL a generic query string.\n\n\n\nThe first consequence is that the call $dbh->prepare('garbage');\n\nreports no error. You will get an SQL error during the $dbh->exec() call.\n\nThe second one is the SQL injection risk in special cases, like using a placeholder for the table name.\n\n\n\nThe reason for emulation is a poor performance of MySQL with prepared statements. Emulation works significantly faster.\n\norrd101 at gmail dot com ¶ Don't just automatically use prepare() for all of your queries.\n\n\n\nIf you are only submitting one query, using PDO::query() with PDO::quote() is much faster (about 3x faster in my test results with MySQL). A prepared query is only faster if you are submitting thousands of identical queries at once (with different data).\n\n\n\nIf you Google for performance comparisons you will find that this is generally consistently the case, or you can write some code and do your own comparison for your particular configuration and query scenario. But generally PDO::query() will always be faster except when submitting a large number of identical queries. Prepared queries do have the advantage of escaping the data for you, so you have to be sure to use quote() when using query().\n\nHayley Watson ¶ It is possible to prepare in advance several statements against a single connection. As long as that connection remains open the statements can be executed and fetched from as often as you like in any order; their \"prepare-execute-fetch\" steps can be interleaved in whichever way is best.\n\n\n\nSo if you're likely to be using several statements often (perhaps within a loop of transactions), you may like to consider preparing all the statements you'll be using up front."
    }
]