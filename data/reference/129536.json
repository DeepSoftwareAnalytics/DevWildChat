[
    {
        "link": "https://github.com/m-clark/Miscellaneous-R-Code/blob/master/ModelFitting/EM%20Examples/EM%20Mixture.R",
        "document": "(t( ) ) could do mu and var via log likelihood here but this is more straightforward\n\n## This example uses Old Faithful geyser eruptions. This is only a univariate mixture for either eruption time or wait time.\n\n## The next will be doing both variables, i.e. multivariate normal. 'Geyser' is supposedly more accurate, though seems to have\n\n## arbitrarily assigned some duration values. See also http://www.geyserstudy.org/geyser.aspx?pGeyserNo=OLDFAITHFUL, but that only has\n\n( c( , ), c( , ), c( , )) note that starts from mean must be in data range or it will break.\n\nnote that the cluster is arbitrary so cluster 1 for one model may be cluster 2 in another\n\n## Some plots; ggtheme available at https://github.com/m-clark/Miscellaneous-R-Code/blob/master/Other/ggtheme.R"
    },
    {
        "link": "https://cran.r-project.org/web/packages/em/vignettes/em_intro.pdf",
        "document": ""
    },
    {
        "link": "https://rdrr.io/cran/rebmix/man/EMMIX.html",
        "document": "Returns as default the EM algorithm output for mixtures of conditionally independent normal, lognormal, Weibull, gamma, Gumbel, binomial, Poisson, Dirac or von Mises component densities. If equals output for mixtures of multivariate normal component densities with unrestricted variance-covariance matrices is returned.\n\nReturns an object of class or .\n\nB. Panic, J. Klemenc, M. Nagode. Improved initialization of the EM algorithm for mixture model parameter estimation. Mathematics, 8(3):373, 2020. \\Sexpr[results=rd]{tools:::Rd_expr_doi(\"10.3390/math8030373\")}."
    },
    {
        "link": "https://people.smp.uq.edu.au/GeoffMcLachlan/mix_soft/EMMIX_R/EMMIX-manual.pdf",
        "document": ""
    },
    {
        "link": "http://cran.nexr.com/web/packages/EMMIXskew/EMMIXskew.pdf",
        "document": ""
    },
    {
        "link": "https://theoreticalecology.wordpress.com/2010/09/17/metropolis-hastings-mcmc-in-r",
        "document": "While there are certainly good software packages out there to do the job for you, notably BUGS or JAGS, but also our own BayesianTools package with general-purpose MCMC samplers, it is instructive to program a simple MCMC yourself. In this post, I give an educational example of the Bayesian equivalent of a linear regression, sampled by an MCMC with Metropolis-Hastings steps, based on an earlier version which I did to together with Tamara Münkemüller. Since first publishing this post, I have made a few small modifications to improve clarity. A similar post on Metropolis-Hastings MCMC algorithms by Darren Wilkinson is also worth looking at. The entire code can be found here, more on analyzing the results of this algorithm can be found in a recent post.\n\nAs a first step, we create some test data that will be used to fit our model. Let’s assume a linear relationship between the predictor and the response variable, so we take a linear model and add some noise.\n\nI balanced x values around zero to “de-correlate” slope and intercept. The result should look something like the figure to the right\n\nThe next step is to specify the statistical model. We already know that the data was created with a linear relationship y = a*x + b between x and y and a normal error model N(0,sd) with standard deviation sd, so let’s use the same model for the fit and see if we can retrieve our original parameter values.\n\nDerive the likelihood function from the model\n\nFor estimating parameters in a Bayesian analysis, we need to derive the likelihood function for the model that we want to fit. The likelihood is the probability (density) with which we would expect the observed data to occur conditional on the parameters of the model that we look at. So, given that our linear model y = b + a*x + N(0,sd) takes the parameters (a, b, sd) as an input, we have to return the probability of obtaining the test data above under this model (this sounds more complicated as it is, as you see in the code, we simply calculate the difference between predictions y = b + a*x and the observed y, and then we have to look up the probability densities (using dnorm) for such deviations to occur.\n\nAs an illustration, the last lines of the code plot the Likelihood for a range of parameter values of the slope parameter a. The result should look something like the plot to the right.\n\nWhy we work with logarithms\n\nYou might have noticed that I return the logarithm of the probabilities in the likelihood function, which is also the reason why I sum the probabilities of all our datapoints (the logarithm of a product equals the sum of the logarithms). Why do we do this? You don’t have to, but it’s strongly advisable because likelihoods, where a lot of small probabilities are multiplied, can get ridiculously small pretty fast (something like 10^-34). At some stage, computer programs are getting into numerical rounding or underflow problems then. So, bottom-line: when you program something with likelihoods, always use logarithms!!!\n\nAs a second step, as always in Bayesian statistics, we have to specify a prior distribution for each parameter. To make it easy, I used uniform distributions and normal distributions for all three parameters. [Some additional information for the “professionals”, skip this when you don’t understand what I’m talking about: while this choice can be considered pretty “uninformative” for the slope and intercept parameters, it is not really uninformative for the standard deviations. An uninformative prior for the latter would usually be scale with 1/sigma (if you want to understand the reason, see here). This stuff is important when you seriously dive into Bayesian statistics, but I didn’t want to make the code more confusing here.]\n\nThe product of prior and likelihood is the actual quantity the MCMC will be working on. This function is called the posterior (or to be exact, it’s called the posterior after it’s normalized, which the MCMC will do for us, but let’s not be picky for the moment). Again, here we work with the sum because we work with logarithms.\n\nNow, here comes the actual Metropolis-Hastings algorithm. One of the most frequent applications of this algorithm (as in this example) is sampling from the posterior density in Bayesian statistics. In principle, however, the algorithm may be used to sample from any integrable function. So, the aim of this algorithm is to jump around in parameter space, but in a way that the probability to be at a point is proportional to the function we sample from (this is usually called the target function). In our case this is the posterior defined above.\n\nThis is achieved by\n• Choosing a new parameter value close to the old value based on some probability density that is called the proposal function\n• Jumping to this new point with a probability p(new)/p(old), where p is the target function, and p>1 means jumping as well\n\nIt’s fun to think about why that works, but for the moment I can assure you it does – when we run this algorithm, distribution of the parameters it visits converges to the target distribution p. So, let’s get this in R:\n\nAgain, working with the logarithms of the posterior might be a bit confusing at first, in particular when you look at the line where the acceptance probability is calculated (probab = exp(posterior(proposal) – posterior(chain[i,]))). To understand why we do this, note that p1/p2 = exp[log(p1)-log(p2)].\n\nThe first steps of the algorithm may be biased by the initial value, and are therefore usually discarded for the further analysis (burn-in time). An interesting output to look at is the acceptance rate: how often was a proposal rejected by the metropolis-hastings acceptance criterion? The acceptance rate can be influenced by the proposal function: generally, the closer the proposals are, the larger the acceptance rate. Very high acceptance rates, however, are usually not beneficial: this means that the algorithms is “staying” at the same point, which results in a suboptimal probing of the parameter space (mixing). It can be shown that acceptance rates between 20% and 30% are optimal for typical applications (more on that here).\n\nFinally, we can plot the results. There are more elegant ways of plotting this which I discuss in another recent post, so check this out, but for the moment I didn’t want to use any packages, so we do it the hard way:\n\nThe resulting plots should look something like the plot below. You see that we retrieve more or less the original parameters that were used to create our data, and you also see that we get a certain area around the highest posterior values that also have some support by the data, which is the Bayesian equivalent of confidence intervals.\n\nFigure: The upper row shows posterior estimates for slope (a), intercept (b) and standard deviation of the error (sd). The lower row shows the Markov Chain of parameter values."
    },
    {
        "link": "https://blog.djnavarro.net/posts/2023-04-12_metropolis-hastings",
        "document": "A note that I wrote for a computer science class I taught all the way back in 2010"
    },
    {
        "link": "https://tommasorigon.github.io/CompStat/slides/un_A1.pdf",
        "document": ""
    },
    {
        "link": "https://rpubs.com/ROARMarketingConcepts/1063733",
        "document": ""
    },
    {
        "link": "https://stats.stackexchange.com/questions/450354/how-to-use-the-mcmc-method-for-multivariate-distributions",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    }
]