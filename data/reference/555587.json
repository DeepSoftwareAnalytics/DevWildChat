[
    {
        "link": "https://stackoverflow.com/questions/18136616/groovy-filter-criteria-on-findall-on-a-list",
        "document": "I trying to build dynamic filters using findAll on a list. I have a variable that needs to be included in the filter only if not null.\n\nBoth of them giving all the records. Is there anyway I can achieve this in one condition without need to write muiltiple queries ?\n\nLooking some like below (this doesn't work though)"
    },
    {
        "link": "https://medium.com/@saumya07013/exploring-the-power-of-groovys-findall-method-in-list-manipulation-5183fbafcff1",
        "document": "In Groovy, the findAll method is a powerful and versatile tool used to filter collections based on specified criteria. It enables developers to write concise and readable code for extracting elements that match certain conditions, thereby enhancing the efficiency and clarity of collection processing.\n\nThe findAll method iterates over each element in a collection, applying a closure (a block of code) that returns a boolean value. Elements for which the closure returns true are included in the resulting collection.\n\nClosure-Based Criteria:\n\nFiltering criteria are defined using closures, allowing for flexible and expressive conditions. Closures can contain any logic needed to determine whether an element should be included.\n\nfindAll can be used with various data structures, including lists, maps, sets, and other iterable collections, providing a consistent way to filter different types of data.\n\nHere is an example demonstrating how to use findAll to filter a list of numbers to find all even numbers:\n\nYou can use findAll to filter a list of objects based on a property:\n\nfindAll can also be used to filter entries in a map:\n\ndef map = [apple: 1, banana: 2, cherry: 3, date: 4]\n\ndef filteredMap = map.findAll { key, value -> value % 2 == 0 }\n\nprintln(filteredMap) // Output: [banana:2, date:4]\n\nBenefits of Using findAll\n\nReadability: The use of closures makes the filtering logic clear and concise, enhancing code readability.\n\nExpressiveness: Groovy’s syntax allows for expressive and flexible filtering criteria.\n\nEfficiency: findAll efficiently processes collections without the need for explicit loops, reducing boilerplate code.\n\nThe Groovy findAll method is a versatile and powerful tool for filtering collections based on specific criteria. By leveraging closures, findAll enables developers to write clean, readable, and efficient code for extracting elements that meet certain conditions. Whether working with lists, maps, or other data structures, findAll provides a consistent and expressive way to handle collection filtering in Groovy."
    },
    {
        "link": "https://stackoverflow.com/questions/27058254/groovy-filtering-array-with-findall-method",
        "document": "I am learning Groovy and I am trying to write an alternative to the following bit of Java code.\n\nWhen that bit of code is run recordIdentifiers should contain 50 items. This is my Groovy equivalent so far.\n\nFor some reason the array contains 100 items after Groovy code is executed. All the examples of findAll() I have come across do simple comparisons when the array is constructed natively in Groovy, but how do you filter a Collection that you receive from a Java class?"
    },
    {
        "link": "https://tutorialspoint.com/groovy/groovy_findall.htm",
        "document": "It finds all values in the receiving object matching the closure condition.\n\nThe condition to be met by the collection element is specified in the closure that must be some Boolean expression.\n\nThe find method returns a list of all values found as per the expression.\n\nFollowing is an example of the usage of this method −\n\nWhen we run the above program, we will get the following result −"
    },
    {
        "link": "https://docs.groovy-lang.org/4.0.24/html/groovy-jdk/java/util/List.html",
        "document": "\n• Modifies this list by inserting all the elements in the specified array into the list at the specified position. Shifts the element currently at that position (if any) and any subsequent elements to the right (increases their indices). The new elements will appear in this list in the order that they occur in the array. The behavior of this operation is undefined if the specified array is modified while the operation is in progress. See also for similar functionality with copy semantics, i.e. which produces a new list after adding the additional items at the specified position but leaves the original list unchanged.\n• Determines if the contents of this list are equal to the contents of the given array in the same order. This returns if either collection is .\n• Compare the contents of two Lists. Order matters. If numbers exist in the Lists, then they are compared as numbers, for example 2 == 2L. If both lists are , the result is true; otherwise if either list is , the result is .\n• Executes the command specified by the given list. The toString() method is called for each item in the list to convert into a resulting String. The first item in the list is the command the others are the parameters.\n• Executes the command specified by the given list, with the environment defined by and under the working directory . The first item in the list is the command; the others are the parameters. The toString() method is called on items in the list to convert them to Strings. - an array of Strings, each member of which has environment variable settings in the format name=value, or if the subprocess should inherit the environment of the current process.\n• Executes the command specified by the given list, with the environment defined by and under the working directory . The first item in the list is the command; the others are the parameters. The toString() method is called on items in the list to convert them to Strings. - a List of Objects (converted to Strings using toString), each member of which has environment variable settings in the format name=value, or if the subprocess should inherit the environment of the current process.\n• Create a List composed of the intersection of a List and an Iterable. Any elements that exist in both iterables are added to the resultant collection. By default, Groovy uses a NumberAwareComparator when determining if an element exists in both collections.\n• Create a List composed of the intersection of a List and an Iterable. Any elements that exist in both iterables are added to the resultant collection.\n• Create a new List composed of the elements of the first List minus every occurrence of elements of the given Iterable.\n• Create a new List composed of the elements of the first List minus every occurrence of the given element to remove.\n• Create a List composed of the elements of the first list minus every occurrence of elements of the given Collection.\n• Create a List composed of the elements of this Iterable, repeated a certain number of times. Note that for non-primitive elements, multiple references to the same instance will be added. Note: if the Iterable happens to not support duplicates, e.g. a Set, then the method will effectively return a Collection with a single copy of the Iterable's items.\n• Creates a new List by inserting all the elements in the specified array to the elements from the original List at the specified index. Shifts the element currently at that index (if any) and any subsequent elements to the right (increasing their indices). The new elements will appear in the resulting List in the order that they occur in the original array. The behavior of this operation is undefined if the list or array operands are modified while the operation is in progress. The original list and array operands remain unchanged. See also for similar functionality with modify semantics, i.e. which performs the changes on the original list itself.\n• Creates a new List by inserting all the elements in the given additions List to the elements from the original List at the specified index. Shifts the element currently at that index (if any) and any subsequent elements to the right (increasing their indices). The new elements will appear in the resulting List in the order that they occur in the original lists. The behavior of this operation is undefined if the original lists are modified while the operation is in progress. The original lists remain unchanged. See also for similar functionality with modify semantics, i.e. which performs the changes on the original list itself.\n• This is similar to pop on a Stack where the first item in the list represents the top of the stack. Note: The behavior of this method changed in Groovy 2.5 to align with Java. If you need the old behavior use 'removeLast'.\n• This is similar to push on a Stack where the first item in the list represents the top of the stack. Note: The behavior of this method changed in Groovy 2.5 to align with Java. If you need the old behavior use 'add'.\n• Using add() and removeLast() is similar to push and pop on a Stack where the last item in the list represents the top of the stack.\n• Reverses the elements in a list. If mutate is true, the original list is modified in place and returned. Otherwise, a new list containing the reversed items is produced.\n• Creates a new list containing the elements of the specified list but in a random order using the specified random instance as the source of randomness.\n• Returns a List containing the items from the List but with duplicates removed. The items in the List are compared by the given Closure condition. For each duplicate, the first member which is returned from the Iterable is retained, but all other ones are removed.\n• Returns a List containing the items from the List but with duplicates removed. The items in the List are compared by the given Comparator. For each duplicate, the first member which is returned from the List is retained, but all other ones are removed.\n• Adds GroovyCollections#transpose(List) as a method on lists. A Transpose Function takes a collection of columns and returns a collection of rows. The first row consists of the first element from each column. Successive rows are constructed similarly.\n• Remove all duplicates from a given List using Groovy's default number-aware comparator. If mutate is true, it works by modifying the original object (and also returning it). If mutate is false, a new collection is returned leaving the original unchanged.\n• A convenience method for making a List unique using a Closure to determine duplicate (equal) items. If mutate is true, it works on the receiver object and returns it. If mutate is false, a new collection is returned.\n• Remove all duplicates from a given List. If mutate is true, it works on the original object (and also returns it). If mutate is false, a new List is returned. The order of members in the List are compared by the given Comparator. For each duplicate, the first member which is returned by the given List's iterator is retained, but all other ones are removed. The given List's original order is preserved.\n• Remove all duplicates from a given List. Works on the original object (and also returns it). The order of members in the List are compared by the given Comparator. For each duplicate, the first member which is returned by the given List's iterator is retained, but all other ones are removed. The given List's original order is preserved.\n• Decorates a list allowing it to grow when called with a non-existent index value. When called with such values, the list is grown in size and a default value is placed in the list by calling a supplied Closure. Null values can be stored in the list.\n• Decorates a list allowing it to grow when called with a non-existent index value. When called with such values, the list is grown in size and a default value is placed in the list by calling a supplied Closure. Subsequent retrieval operations if finding a null value in the list assume it was set as null from an earlier growing operation and again call the Closure to populate the retrieved value; consequently the list can't be used to store null values. How it works: The decorated list intercepts all calls to and . If an index greater than or equal to the current is used, the list will grow automatically up to the specified index. Gaps will be filled by . If a default value should also be used to fill gaps instead of , use . If or are called and a null value is found, it is assumed that the null value was a consequence of an earlier grow list operation and the Closure is called to populate the value."
    },
    {
        "link": "https://stackoverflow.com/questions/35219484/checking-multiple-lists-for-emptiness-in-groovy",
        "document": "Let's say I've got three lists with objects\n\nWhat is the best way to do check whether any of them is not empty and do some action?\n\nSo far I came up with\n\nBut is there a way to omit block at all?"
    },
    {
        "link": "https://stackoverflow.com/questions/15141202/how-to-iterate-over-a-list-in-groovy-and-add-property-for-each-object",
        "document": "I have a list of events like so:\n\nhave a many-to-many relationship with via class modeled after the approach from spring-security-plugin:\n\nI would like to find out whether a is attending an and I can do that by running this:\n\nHow can I do this over all the elements of my list so that in my view layer I can easily find out whether is going to the event?"
    },
    {
        "link": "https://medium.com/@loopednetwork/groovy-finding-objects-in-a-list-by-property-value-3397825f40b7",
        "document": "My streak of coming up with the longest, most awkward titles possible for my posts on Groovy programming remains! Given the recent happenings in the world, I was tempted to make a post on how to call Log4j from Groovy, but instead I figured it would be better to do a post on something I actually needed to do recently.\n\nI found myself trying to use the API for a vendor of ours to determine how much data had been used by each piece of networking equipment that vendor provided over the past hour. The only problem is that the API itself doesn’t provide any data use information for the infrastructure devices; that information is only given in terms of the clients connected to the devices. However, each client also has properties for the unique ID and the hostname of the infrastructure device it’s connected to. My process worked out as follows:\n• Gather a list of every client from the API.\n• Using the device ID that client is connected to, see if that device is already in my device list from step 1.\n• If yes, store the current client ID on the device object.\n• If no, create a new device object which stores the client ID of the current client and add it to the list of devices.\n• Repeat steps 3–5 until the entire list from step 2 has been processed.\n• Go through each device, gathering the data usage for all of the clients connected to it.\n\nThe steps may seem a little odd, but trust me that this order of operations was necessary due to the architecture of the API I was getting the data from.\n\nTo keep myself sane, I made an extremely simple class for each device. I didn’t even need any methods for it, just constructors:\n\nAlong with the ID, hostname, and data use, I also tracked a list of client IDs connected to that device so that later I could easily both get the data for each connected client in one API call and calculate the average amount of data used per connected client.\n\nFor the sake of example, let’s say I had the following two lists:\n\nThe list has each client in the environment stored in it. The list is, at this time, empty. However, each client object has a property for that is the glue mapping what that client is connected to with the devices that will be stored in .\n\nMy real challenge was in step 3 from above where I needed to take my existing list of devices and determine if the device the current client was connected to already exists in or if it needed to be added. The brute force way would be to create a nested loop - not literally nested since it's inside of a closure, but you get the point - checking to see if the property of the current client matched the current device in . That seemed extremely inelegant, though, so I went digging to see if I could find something better.\n\nFortunately for me, I found that lists in Groovy have a method to facilitate this. Note that there are many flavors of this based on if you want to find a whole object, the index of it, a key or value if it's a map, etc. Check out this post if you want to see other examples. In my case, I was able to use the following to iterate through my client list and match up the devices:\n\nThis instantiates a new variable containing the information about the device with a property matching the property of the current client. There are a couple of really nice features with this. First, if there isn't a match, the value of is . Thus, if my value is then I know I need to create a new device object for my list. Second, and even more importantly, if there's a match the value in is not a copy of item from . Rather, it's a reference to that item, meaning that any changes made to will be reflected on the item contained within . I was able to easily shift the new client ID value from onto the property of , and that information will still be stored on the object in because it's the same object."
    },
    {
        "link": "https://groovy-lang.org/objectorientation.html",
        "document": "Groovy classes are very similar to Java classes, and are compatible with Java ones at JVM level. They may have methods, fields and properties (think JavaBeans properties but with less boilerplate). Classes and class members can have the same modifiers (public, protected, private, static, etc.) as in Java with some minor differences at the source level which are explained shortly. The key differences between Groovy classes and their Java counterparts are:\n• Classes or methods with no visibility modifier are automatically public (a special annotation can be used to achieve package private visibility).\n• Fields with no visibility modifier are turned into properties automatically, which results in less verbose code, since explicit getter and setter methods aren’t needed. More on this aspect will be covered in the fields and properties section.\n• Classes do not need to have the same base name as their source file definitions but it is highly recommended in most scenarios (see also the next point about scripts).\n• One source file may contain one or more classes (but if a file contains any code not in a class, it is considered a script). Scripts are just classes with some special conventions and will have the same name as their source file (so don’t include a class definition within a script having the same name as the script source file). The following code presents an example class. class beginning, with the name Normal classes refer to classes which are top level and concrete. This means they can be instantiated without restrictions from any other classes or scripts. This way, they can only be public (even though the keyword may be suppressed). Classes are instantiated by calling their constructors, using the keyword, as in the following snippet. Inner classes are defined within another classes. The enclosing class can use the inner class as usual. On the other side, an inner class can access members of its enclosing class, even if they are private. Classes other than the enclosing class are not allowed to access inner classes. Here is an example: the inner class is instantiated and its method gets called even being private, a field of the enclosing class is accessed by the inner class There are some reasons for using inner classes:\n• They increase encapsulation by hiding the inner class from other classes, which do not need to know about it. This also leads to cleaner packages and workspaces.\n• They provide a good organization, by grouping classes that are used by only one class.\n• They lead to more maintainable codes, since inner classes are near the classes that use them. It is common for an inner class to be an implementation of some interface whose method(s) are needed by the outer class. The code below illustrates this typical usage pattern, here being used with threads. Note that the class is defined only to provide an implementation of the method to class . Anonymous inner classes help to eliminate verbosity in this case. That topic is covered shortly. Groovy 3+ also supports Java syntax for non-static inner class instantiation, for example: The earlier example of an inner class ( ) can be simplified with an anonymous inner class. The same functionality can be achieved with the following code: comparing with the last example of previous section, the was replaced by along with all its implementation the method is invoked normally Thus, there was no need to define a new class to be used just once. Abstract classes represent generic concepts, thus, they cannot be instantiated, being created to be subclassed. Their members include fields/properties and abstract or concrete methods. Abstract methods do not have implementation, and must be implemented by concrete subclasses. abstract classes must be declared with keyword abstract methods must also be declared with keyword Abstract classes are commonly compared to interfaces. There are at least two important differences of choosing one or another. First, while abstract classes may contain fields/properties and concrete methods, interfaces may contain only abstract methods (method signatures). Moreover, one class can implement several interfaces, whereas it can extend just one class, abstract or not. Inheritance in Groovy resembles inheritance in Java. It provides a mechanism for a child class (or subclass) to reuse code or properties from a parent (or super class). Classes related through inheritance form an inheritance hierarchy. Common behavior and members are pushed up the hierarchy to reduce duplication. Specializations occur in child classes. Different forms of inheritance are supported:\n• implementation inheritance where code (methods, fields or properties) from a superclass or from one or more traits is reused by a child class\n• contract inheritance where a class promises to provide particular abstract methods defined in a superclass, or defined in one or more traits or interfaces. Parent classes share visible fields, properties or methods with child classes. A child class may have at most one parent class. The keyword is used immediately prior to giving the superclass type. An interface defines a contract that a class needs to conform to. An interface only defines a list of methods that need to be implemented, but does not define the method’s implementation. an interface needs to be declared using the keyword Methods of an interface are always public. It is an error to use or methods in interfaces: A class implements an interface if it defines the interface in its list or if any of its superclasses does: class SystemGreeter implements Greeter { (1) void greet(String name) { (2) println \"Hello $name\" } } def greeter = new SystemGreeter() assert greeter instanceof Greeter (3) The declares the interface using the keyword Any instance of is also an instance of the interface An interface can extend another interface: the interface extends the interface using the keyword It is worth noting that for a class to be an instance of an interface, it has to be explicit. For example, the following class defines the method as it is declared in the interface, but does not declare in its interfaces: class DefaultGreeter { void greet(String name) { println \"Hello\" } } greeter = new DefaultGreeter() assert !(greeter instanceof Greeter) In other words, Groovy does not define structural typing. It is however possible to make an instance of an object implement an interface at runtime, using the coercion operator: create an instance of that does not implement the interface coerce the instance into a at runtime You can see that there are two distinct objects: one is the source object, a instance, which does not implement the interface. The other is an instance of that delegates to the coerced object. Groovy interfaces do not support default implementation like Java 8 interfaces. If you are looking for something similar (but not equal), traits are close to interfaces, but allow default implementation as well as other important features described in this manual.\n\nConstructors are special methods used to initialize an object with a specific state. As with normal methods, it is possible for a class to declare more than one constructor, so long as each constructor has a unique type signature. If an object doesn’t require any parameters during construction, it may use a no-arg constructor. If no constructors are supplied, an empty no-arg constructor will be provided by the Groovy compiler.\n• positional parameters are used in a similar to how you would use Java constructors\n• named parameters allow you to specify parameter names when invoking the constructor. To create an object by using positional parameters, the respective class needs to declare one or more constructors. In the case of multiple constructors, each must have a unique type signature. The constructors can also be added to the class using the groovy.transform.TupleConstructor annotation. Typically, once at least one constructor is declared, the class can only be instantiated by having one of its constructors called. It is worth noting that, in this case, you can’t normally create the class with named parameters. Groovy does support named parameters so long as the class contains a no-arg constructor or provides a constructor which takes a argument as the first (and potentially only) argument - see the next section for details. There are three forms of using a declared constructor. The first one is the normal Java way, with the keyword. The others rely on coercion of lists into the desired types. In this case, it is possible to coerce with the keyword and by statically typing the variable. class PersonConstructor { String name Integer age PersonConstructor(name, age) { (1) this.name = name this.age = age } } def person1 = new PersonConstructor('Marie', 1) (2) def person2 = ['Marie', 2] as PersonConstructor (3) PersonConstructor person3 = ['Marie', 3] (4) If no (or a no-arg) constructor is declared, it is possible to create objects by passing parameters in the form of a map (property/value pairs). This can be in handy in cases where one wants to allow several combinations of parameters. Otherwise, by using traditional positional parameters it would be necessary to declare all possible constructors. Having a constructor where the first (and perhaps only) argument is a argument is also supported - such a constructor may also be added using the groovy.transform.MapConstructor annotation. class PersonWOConstructor { (1) String name Integer age } def person4 = new PersonWOConstructor() (2) def person5 = new PersonWOConstructor(name: 'Marie') (3) def person6 = new PersonWOConstructor(age: 1) (4) def person7 = new PersonWOConstructor(name: 'Marie', age: 2) (5) No parameters given in the instantiation parameter given in the instantiation parameter given in the instantiation and parameters given in the instantiation It is important to highlight, however, that this approach gives more power to the constructor caller, while imposing an increased responsibility on the caller to get the names and value types correct. Thus, if greater control is desired, declaring constructors using positional parameters might be preferred.\n• While the example above supplied no constructor, you can also supply a no-arg constructor or a constructor where the first argument is a , most typically it’s the only argument.\n• When no (or a no-arg) constructor is declared, Groovy replaces the named constructor call by a call to the no-arg constructor followed by calls to the setter for each supplied named property.\n• When the first argument is a Map, Groovy combines all named parameters into a Map (regardless of ordering) and supplies the map as the first parameter. This can be a good approach if your properties are declared as (since they will be set in the constructor rather than after the fact with setters).\n• You can support both named and positional construction by supply both positional constructors as well as a no-arg or Map constructor.\n• You can support hybrid construction by having a constructor where the first argument is a Map but there are also additional positional parameters. Use this style with caution. Groovy methods are quite similar to other languages. Some peculiarities will be shown in the next subsections. A method is defined with a return type or with the keyword, to make the return type untyped. A method can also receive any number of arguments, which may not have their types explicitly declared. Java modifiers can be used normally, and if no visibility modifier is provided, the method is public. Methods in Groovy always return some value. If no statement is provided, the value evaluated in the last line executed will be returned. For instance, note that none of the following methods uses the keyword. Method with no return type declared and no parameter Method with explicit return type and no parameter Method with a parameter with no type defined Like constructors, normal methods can also be called with named parameters. To support this notation, a convention is used where the first argument to the method is a . In the method body, the parameter values can be accessed as in normal maps ( ). If the method has just a single Map argument, all supplied parameters must be named. Named parameters can be mixed with positional parameters. The same convention applies, in this case, in addition to the argument as the first argument, the method in question will have additional positional arguments as needed. Supplied positional parameters when calling the method must be in order. The named parameters can be in any position. They are grouped into the map and supplied as the first parameter automatically. def foo(Map args, Integer number) { \"${args.name}: ${args.age}, and the number is ${number}\" } foo(name: 'Marie', age: 1, 23) (1) foo(23, name: 'Marie', age: 1) (2) If we don’t have the Map as the first argument, then a Map must be supplied for that argument instead of named parameters. Failure to do so will lead to : def foo(Integer number, Map args) { \"${args.name}: ${args.age}, and the number is ${number}\" } foo(name: 'Marie', age: 1, 23) (1) Method call throws groovy.lang.MissingMethodException: No signature of method: foo() is applicable for argument types: (LinkedHashMap, Integer) values: [[name:Marie, age:1], 23] , because the named argument parameter is not defined as the first argument Above exception can be avoided if we replace named arguments with an explicit argument: def foo(Integer number, Map args) { \"${args.name}: ${args.age}, and the number is ${number}\" } foo(23, [name: 'Marie', age: 1]) (1) Although Groovy allows you to mix named and positional parameters, it can lead to unnecessary confusion. Mix named and positional arguments with caution. Default arguments make parameters optional. If the argument is not supplied, the method assumes a default value. Parameters are dropped from the right, however mandatory parameters are never dropped. def baz(a = 'a', int b, c = 'c', boolean d, e = 'e') { \"$a $b $c $d $e\" } assert baz(42, true) == 'a 42 c true e' assert baz('A', 42, true) == 'A 42 c true e' assert baz('A', 42, 'C', true) == 'A 42 C true e' assert baz('A', 42, 'C', true, 'E') == 'A 42 C true E' The same rule applies to constructors as well as methods. If using , additional configuration options apply. Groovy supports methods with a variable number of arguments. They are defined like this: . Here supports arguments by default, but also an unspecified number of further arguments exceeding . This example defines a method , that can take any number of arguments, including no arguments at all. will return the number of arguments given. Groovy allows as an alternative notation to . That means any method with an array as last parameter is seen by Groovy as a method that can take a variable number of arguments. If a method with varargs is called with as the vararg parameter, then the argument will be and not an array of length one with as the only element. If a varargs method is called with an array as an argument, then the argument will be that array instead of an array of length one containing the given array as the only element. Another important point are varargs in combination with method overloading. In case of method overloading Groovy will select the most specific method. For example if a method takes a varargs argument of type and another method also takes one argument of type , the second method is preferred. Dynamic Groovy supports multiple dispatch (aka multimethods). When calling a method, the actual method invoked is determined dynamically based on the run-time type of methods arguments. First the method name and number of arguments will be considered (including allowance for varargs), and then the type of each argument. Consider the following method definitions: Perhaps as expected, calling with and parameters, invokes our third method definition. Of more interest here is when the types are not known at compile time. Perhaps the arguments are declared to be of type (a list of such objects in our case). Java would determine that the variant would be selected in all cases (unless casts were used) but as can be seen in the following example, Groovy uses the runtime type and will invoke each of our methods once (and normally, no casting is needed): For each of the first two of our three method invocations an exact match of argument types was found. For the third invocation, an exact match of wasn’t found but is still valid and will be selected. Method selection then is about finding the closest fit from valid method candidates which have compatible parameter types. So, is also valid for the first two invocations but is not as close a match as the variants where types exactly match. To determine the closest fit, the runtime has a notion of the distance an actual argument type is away from the declared parameter type and tries to minimise the total distance across all parameters. The following table illustrates some factors which affect the distance calculation. Directly implemented interfaces match more closely than ones from further up the inheritance hierarchy. Given these interface and method definitions: An Object array is preferred over an Object. If two vararg variants are applicable, the one which uses the minimum number of vararg arguments is preferred. def method(String s, Object... vargs) { 'two vargs' } def method(String s, Integer i, Object... vargs) { 'one varg' } assert method('foo', 35, new Date()) == 'one varg' For a primitive argument type, a declared parameter type which is the same or slightly larger is preferred. In the case where two variants have exactly the same distance, this is deemed ambiguous and will cause a runtime exception: Casting can be used to select the desired method: Groovy automatically allows you to treat checked exceptions like unchecked exceptions. This means that you don’t need to declare any checked exceptions that a method may throw as shown in the following example which can throw a if the file isn’t found: Nor will you be required to surround the call to the method in the previous example within a try/catch block - though you are free to do so if you wish. If you wish to declare any exceptions that your code might throw (checked or otherwise) you are free to do so. Adding exceptions won’t change how the code is used from any other Groovy code but can be seen as documentation for the human reader of your code. The exceptions will become part of the method declaration in the bytecode, so if your code might be called from Java, it might be useful to include them. Using an explicit checked exception declaration is illustrated in the following example: A field is a member of a class, interface or trait which stores data. A field defined in a Groovy source file has:\n• one or more optional modifiers ( , , ) A field may be initialized directly at declaration: the private field is initialized with It is possible to omit the type declaration of a field. This is however considered a bad practice and in general it is a good idea to use strong typing for fields: The difference between the two is important if you want to use optional type checking later. It is also important as a way to document the class design. However, in some cases like scripting or if you want to rely on duck typing it may be useful to omit the type. A property is an externally visible feature of a class. Rather than just using a public field to represent such features (which provides a more limited abstraction and would restrict refactoring possibilities), the typical approach in Java is to follow the conventions outlined in the JavaBeans Specification, i.e. represent the property using a combination of a private backing field and getters/setters. Groovy follows these same conventions but provides a simpler way to define the property. You can define a property with:\n• an absent access modifier (no , or )\n• one or more optional modifiers ( , , ) Groovy will then generate the getters/setters appropriately. For example: If a property is declared , no setter is generated: class Person { final String name (1) final int age (2) Person(String name, int age) { this.name = name (3) this.age = age (4) } } assigns the parameter to the field assigns the parameter to the field Properties are accessed by name and will call the getter or setter transparently, unless the code is in the class which defines the property: class Person { String name void name(String name) { this.name = \"Wonder $name\" (1) } String title() { this.name (2) } } def p = new Person() p.name = 'Diana' (3) assert p.name == 'Diana' (4) p.name('Woman') (5) assert p.title() == 'Wonder Woman' (6) will directly access the field because the property is accessed from within the class that defines it similarly a read access is done directly on the field write access to the property is done outside of the class so it will implicitly call read access to the property is done outside of the class so it will implicitly call this will call the method on which performs a direct access to the field this will call the method on which performs a direct read access to the field It is worth noting that this behavior of accessing the backing field directly is done in order to prevent a stack overflow when using the property access syntax within a class that defines the property. It is possible to list the properties of a class thanks to the meta field of an instance: By convention, Groovy will recognize properties even if there is no backing field provided there are getters or setters that follow the Java Beans specification. For example: class PseudoProperties { // a pseudo property \"name\" void setName(String name) {} String getName() {} // a pseudo read-only property \"age\" int getAge() { 42 } // a pseudo write-only property \"groovy\" void setGroovy(boolean groovy) { } } def p = new PseudoProperties() p.name = 'Foo' (1) assert p.age == 42 (2) p.groovy = true (3) writing is allowed because there is a pseudo-property reading is allowed because there is a pseudo-readonly property writing is allowed because there is a pseudo-write-only property This syntactic sugar is at the core of many DSLs written in Groovy. It is generally recommended that the first two letters of a property name are lowercase and for multi-word properties that camel case is used. In those cases, generated getters and setters will have a name formed by capitalizing the property name and adding a or prefix (or optionally \"is\" for a boolean getter). So, would be a getter for a property and a setter for a property. might be the getter method name for a property named . Property names starting with a capital letter would have getters/setters with just the prefix added. So, the property is allowed even though it isn’t following the recommended naming conventions. For this property, the accessor methods would be and . A consequence of this is that you aren’t allowed to have both a and a property, since they would have the same named accessor methods. The JavaBeans specification makes a special case for properties which typically might be acronyms. If the first two letters of a property name are uppercase, no capitalization is performed (or more importantly, no decapitalization is done if generating the property name from the accessor method name). So, would be the getter for a property. Because of the special \"acronym handling\" property naming logic in the JavaBeans specification, the conversion to and from a property name are non-symmetrical. This leads to some strange edge cases. Groovy adopts a naming convention that avoids one ambiguity that might seem a little strange but was popular at the time of Groovy’s design and has remained (so far) for historical reasons. Groovy looks at the second letter of a property name. If that is a capital, the property is deemed to be one of the acronym style properties and no capitalization is done, otherwise normal capitalization is done. Although we never recommend it, it does allow you to have what might seem like \"duplicate named\" properties, e.g. you can have and , or and . The getters would be and , and and respectively. We have already seen that properties are defined by omitting the visibility modifier. In general, any other modifiers, e.g. would be copied across to the field. Two special cases are worth noting:\n• , which we saw earlier is for read-only properties, is copied onto the backing field but also causes no setter to be defined\n• is copied onto the backing field but also causes the accessor methods to be static If you wish to have a modifier like also carried over to the accessor methods, you can write your properties long hand or consider using a split property definition. Annotations, including those associated with AST transforms, are copied on to the backing field for the property. This allows AST transforms which are applicable to fields to be applied to properties, e.g.: Groovy’s property syntax is a convenient shorthand when your class design follows certain conventions which align with common JavaBean practice. If your class doesn’t exactly fit these conventions, you can certainly write the getter, setter and backing field long hand like you would in Java. However, Groovy does provide a split definition capability which still provides a shortened syntax while allowing slight adjustments to the conventions. For a split definition, you write a field and a property with the same name and type. Only one of the field or property may have an initial value. For split properties, annotations on the field remain on the backing field for the property. Annotations on the property part of the definition are copied onto the getter and setter methods. This mechanism allows a number of common variations that property users may wish to use if the standard property definition doesn’t exactly fit their needs. For example, if the backing field should be rather than : Protected backing field for name property instead of normal private one Or, the same example but with a package-private backing field: Package-private backing field for name property instead of normal private one As a final example, we may wish to apply method-related AST transforms, or in general, any annotation to the setters/getters, e.g. to have the accessors be synchronized: Declare name property with annotation for setter/getter The automatic generation of accessor methods doesn’t occur if there is an explicit definition of the getter or setter in the class. This allows you to modify the normal behavior of such a getter or setter if needed. Inherited accessor methods aren’t normally considered but if an inherited accessor method is marked final, that will also cause no generation of an additional accessor method to honor the requirement of no subclassing of such methods.\n\nAn annotation is a kind of special interface dedicated at annotating elements of the code. An annotation is a type which superinterface is the java.lang.annotation.Annotation interface. Annotations are declared in a very similar way to interfaces, using the keyword: An annotation may define members in the form of methods without bodies and an optional default value. The possible member types are limited to:\n• or any array of the above @interface SomeAnnotation { String value() (1) } @interface SomeAnnotation { String value() default 'something' (2) } @interface SomeAnnotation { int step() (3) } @interface SomeAnnotation { Class appliesTo() (4) } @interface SomeAnnotation {} @interface SomeAnnotations { SomeAnnotation[] value() (5) } enum DayOfWeek { mon, tue, wed, thu, fri, sat, sun } @interface Scheduled { DayOfWeek dayOfWeek() (6) } an annotation defining a member of type with a default value of an annotation defining a member of type the primitive type an annotation defining a member which type is an array of another annotation type an annotation defining a member which type is the enumeration type Unlike in the Java language, in Groovy, an annotation can be used to alter the semantics of the language. It is especially true of AST transformations which will generate code based on annotations. An annotation can be applied on various elements of the code: In order to limit the scope where an annotation can be applied, it is necessary to declare it on the annotation definition, using the java.lang.annotation.Target annotation. For example, here is how you would declare that an annotation can be applied to a class or a method: the annotation is meant to annotate an annotation with a scope. will therefore only be allowed on or The list of possible targets is available in the java.lang.annotation.ElementType. Groovy does not support the java.lang.annotation.ElementType#TYPE_PARAMETER and java.lang.annotation.ElementType#TYPE_PARAMETER element types which were introduced in Java 8. When an annotation is used, it is required to set at least all members that do not have a default value. For example: However it is possible to omit in the declaration of the value of an annotation if the member is the only one being set: we can omit the because it has a default value, but needs to be set since is the only mandatory member without a default, we can omit if both and need to be set, it is required to use for the default member The visibility of an annotation depends on its retention policy. The retention policy of an annotation is set using the java.lang.annotation.Retention annotation: so will have a retention The list of possible retention targets and description is available in the java.lang.annotation.RetentionPolicy enumeration. The choice usually depends on whether you want an annotation to be visible at compile time or runtime. An interesting feature of annotations in Groovy is that you can use a closure as an annotation value. Therefore annotations may be used with a wide variety of expressions and still have IDE support. For example, imagine a framework where you want to execute some methods based on environmental constraints like the JDK version or the OS. One could write the following code: For the annotation to accept a as an argument, you only have to declare the as a : To complete the example, let’s write a sample runner that would use that information: class Runner { static <T> T run(Class<T> taskClass) { def tasks = taskClass.newInstance() (1) def params = [jdk: 6, windows: false] (2) tasks.class.declaredMethods.each { m -> (3) if (Modifier.isPublic(m.modifiers) && m.parameterTypes.length == 0) { (4) def onlyIf = m.getAnnotation(OnlyIf) (5) if (onlyIf) { Closure cl = onlyIf.value().newInstance(tasks,tasks) (6) cl.delegate = params (7) if (cl()) { (8) m.invoke(tasks) (9) } } else { m.invoke(tasks) (10) } } } tasks (11) } } create a new instance of the class passed as an argument (the task class) emulate an environment which is JDK 6 and not Windows iterate on all declared methods of the task class if the method is public and takes no-argument try to find the annotation if it is found get the and create a new out of it set the of the closure to our environment variable call the closure, which is the annotation closure. It will return a if it is , call the method if the method is not annotated with , execute the method anyway after that, return the task object Then the runner can be used this way: Meta-annotations, also known as annotation aliases are annotations that are replaced at compile time by other annotations (one meta-annotation is an alias for one or more annotations). Meta-annotations can be used to reduce the size of code involving multiple annotations. Let’s start with a simple example. Imagine you have the and annotations and that you want to annotate a class with both: Given the multiplication of annotations that you could add to the same class, a meta-annotation could help by reducing the two annotations with a single one having the very same semantics. For example, we might want to write this instead: A meta-annotation is declared as a regular annotation but annotated with and the list of annotations it is collecting. In our case, the annotation can be written: Groovy supports both precompiled and source form meta-annotations. This means that your meta-annotation may be precompiled, or you can have it in the same source tree as the one you are currently compiling. INFO: Meta-annotations are a Groovy-only feature. There is no chance for you to annotate a Java class with a meta-annotation and hope it will do the same as in Groovy. Likewise, you cannot write a meta-annotation in Java: both the meta-annotation definition and usage have to be Groovy code. But you can happily collect Java annotations and Groovy annotations within your meta-annotation. When the Groovy compiler encounters a class annotated with a meta-annotation, it replaces it with the collected annotations. So, in our previous example, it will replace with and : The conversion from a meta-annotation to the collected annotations is performed during the semantic analysis compilation phase. In addition to replacing the alias with the collected annotations, a meta-annotation is capable of processing them, including arguments. Meta-annotations can collect annotations which have parameters. To illustrate this, we will imagine two annotations, each of them accepting one argument: And suppose that you want to create a meta-annotation named : By default, when the annotations are replaced, they will get the annotation parameter values as they were defined in the alias. More interesting, the meta-annotation supports overriding specific values: the value provided as a parameter to overrides the one defined in the annotation If two annotations define the same parameter name, the default processor will copy the annotation value to all annotations that accept this parameter: the annotation defines the member of type the annotation also defines the member of type class is annotated with and the value of the annotation on is while the value of the annotation on is then the value of the annotation on is and the value of the annotation on is also In the second case, the meta-annotation value was copied in both and annotations. It is a compile time error if the collected annotations define the same members with incompatible types. For example if on the previous example defined a value of type but defined a value of type . It is however possible to customize the behavior of meta-annotations and describe how collected annotations are expanded. We’ll look at how to do that shortly but first there is an advanced processing option to cover. The annotation supports a parameter which can be used to alter how the default processor handles annotation replacement in the presence of duplicate annotations. INFO: Custom processors (discussed next) may or may not support this parameter. As an example, suppose you create a meta-annotation containing the annotation and then place your meta-annotation on a class that already has an explicit annotation. Should this be an error? Should both annotations be applied? Does one take priority over the other? There is no correct answer. In some scenarios it might be quite appropriate for any of these answers to be correct. So, rather than trying to preempt one correct way to handle the duplicate annotation issue, Groovy lets you write your own custom meta-annotation processors (covered next) and lets you write whatever checking logic you like within AST transforms - which are a frequent target for aggregating. Having said that, by simply setting the , a number of commonly expected scenarios are handled automatically for you within any extra coding. The behavior of the parameter is determined by the enum value chosen and is summarized in the following table. Annotations from the annotation collection will always be inserted. After all transforms have been run, it will be an error if multiple annotations (excluding those with SOURCE retention) exist. Annotations from the collector will be added and any existing annotations with the same name will be removed. Annotations from the collector will be added and any existing annotations with the same name will be removed but any new parameters found within existing annotations will be merged into the added annotation. Annotations from the collector will be ignored if any existing annotations with the same name are found. Annotations from the collector will be ignored if any existing annotations with the same name are found but any new parameters on the collector annotation will be added to existing annotations. A custom annotation processor will let you choose how to expand a meta-annotation into collected annotations. The behaviour of the meta-annotation is, in this case, totally up to you. To do this, you must:\n• declare the processor to be used in the meta-annotation declaration To illustrate this, we are going to explore how the meta-annotation is implemented. is a meta-annotation that expands itself to . The problem is that the default meta annotation processor doesn’t support enums and the annotation value is one. The naive implementation here would not work: Instead, we will define it like this: The first thing you may notice is that our interface is no longer annotated with . The reason for this is that we rely on the parameter instead, that references a class which will generate the annotation. Here is how the custom processor is implemented: @CompileStatic (1) class CompileDynamicProcessor extends AnnotationCollectorTransform { (2) private static final ClassNode CS_NODE = ClassHelper.make(CompileStatic) (3) private static final ClassNode TC_NODE = ClassHelper.make(TypeCheckingMode) (4) List<AnnotationNode> visit(AnnotationNode collector, (5) AnnotationNode aliasAnnotationUsage, (6) AnnotatedNode aliasAnnotated, (7) SourceUnit source) { (8) def node = new AnnotationNode(CS_NODE) (9) def enumRef = new PropertyExpression( new ClassExpression(TC_NODE), \"SKIP\") (10) node.addMember(\"value\", enumRef) (11) Collections.singletonList(node) (12) } } our custom processor is written in Groovy, and for better compilation performance, we use static compilation the custom processor has to extend org.codehaus.groovy.transform.AnnotationCollectorTransform is the node found in the meta-annotation. Usually unused. is the meta-annotation being expanded, here it is is the node being annotated with the meta-annotation is the being compiled we create a new annotation node for we create an expression equivalent to we add that expression to the annotation node, which is now In the example, the method is the only method which has to be overridden. It is meant to return a list of annotation nodes that will be added to the node annotated with the meta-annotation. In this example, we return a single one corresponding to .\n\nSealed classes, interfaces and traits restrict which subclasses can extend/implement them. Prior to sealed classes, class hierarchy designers had two main options:\n• Make a class final to allow no extension.\n• Make the class public and non-final to allow extension by anyone. Sealed classes provide a middle-ground compared to these all or nothing choices. Sealed classes are also more flexible than other tricks previously used to try to achieve a middle-ground. For example, for class hierarchies, access modifiers like protected and package-private give some ability to restrict inheritance hierarchies but often at the expense of flexible use of those hierarchies. Sealed hierarchies provide full inheritance within a known hierarchy of classes, interfaces and traits but disable or only provide controlled inheritance outside the hierarchy. As an example, suppose we want to create a shape hierarchy containing only circles and squares. We also want a shape interface to be able to refer to instances in our hierarchy. We can create the hierarchy as follows: Groovy also supports an alternative annotation syntax. We think the keyword style is nicer but you might choose the annotation style if your editor doesn’t yet have Groovy 4 support. We can have a reference of type which, thanks to the clause, can point to either a or and, since our classes are , we know no additional classes will be added to our hierarchy in the future. At least not without changing the clause and recompiling. In general, we might want to have some parts of our class hierarchy immediately locked down like we have here, where we marked the subclasses as but other times we might want to allow further controlled inheritance. <Click to see the alternate annotations syntax> \n\n In this example, our permitted subclasses for are , , and . is and hence that part of the hierarchy cannot be extended. is implicitly non-sealed and is explicitly marked as . That means our hierarchy is open to any further extension by subclassing, as seen with and . is itself sealed which means that part of the hierarchy can be extended but only in a controlled way (only is permitted). Sealed classes are useful for creating enum-like related classes which need to contain instance specific data. For instance, we might have the following enum: but we now wish to also add weather specific instance data to weather forecasts. We can alter our abstraction as follows: sealed abstract class Weather { } @Immutable(includeNames=true) class Rainy extends Weather { Integer expectedRainfall } @Immutable(includeNames=true) class Sunny extends Weather { Integer expectedTemp } @Immutable(includeNames=true) class Cloudy extends Weather { Integer expectedUV } def forecast = [new Rainy(12), new Sunny(35), new Cloudy(6)] assert forecast.toString() == '[Rainy(expectedRainfall:12), Sunny(expectedTemp:35), Cloudy(expectedUV:6)]' Sealed hierarchies are also useful when specifying Algebraic or Abstract Data Types (ADTs) as shown in the following example: import groovy.transform.* sealed interface Tree<T> {} @Singleton final class Empty implements Tree { String toString() { 'Empty' } } @Canonical final class Node<T> implements Tree<T> { T value Tree<T> left, right } Tree<Integer> tree = new Node<>(42, new Node<>(0, Empty.instance, Empty.instance), Empty.instance) assert tree.toString() == 'Node(42, Node(0, Empty, Empty), Empty)' Sealed hierarchies work well with records as shown in the following example:\n• Java provides no default modifier for subclasses of sealed classes and requires that one of , or be specified. Groovy defaults to non-sealed but you can still use if you wish. We anticipate the style checking tool CodeNarc will eventually have a rule that looks for the presence of so developers wanting that stricter style will be able to use CodeNarc and that rule if they want.\n• Currently, Groovy doesn’t check that all classes mentioned in are available at compile-time and compiled along with the base sealed class. This may change in a future version of Groovy. Groovy supports annotating classes as sealed as well as \"native\" sealed classes. The annotation supports a annotation attribute which can take one of three values (with being the default): Produces a class similar to what Java would do. Produces an error when compiling on JDKs earlier than JDK17. Indicates the class is sealed using the annotation. This mechanism works with the Groovy compiler for JDK8+ but is not recognised by the Java compiler. Produces a native record for JDK17+ and emulates the record otherwise. Whether you use the keyword or the annotation is independent of the mode."
    },
    {
        "link": "https://exalate.com/blog/groovy-scripting",
        "document": "Welcome to this comprehensive Groovy scripting guide! If you are curious to know what Groovy scripting has to offer and how it can be used in real-world scenarios, then you’re in the right place!\n\nWe’ll dive into the world of Groovy and explore its features and capabilities.\n\nWe’ll also focus on the role of Groovy scripts in integrations. And see how it supplements integration solutions like Exalate to perform advanced integrations.\n\nWith a lot of practical examples, you’ll better understand how Groovy scripting can streamline your coding workflows. So let’s get started!\n\nNote: This is a complete handbook, so feel free to jump to the chapter of your choice by using the floating menu on the bottom left of this page.\n\nChapter 1: Get On with Groovy Scripting\n\nI am always curious about expanding my knowledge, whether it’s related to the field I work in or not. And sometimes, I find myself wondering, “What could I learn today that’s completely different from what I already know?”.\n\nIt’s fun to explore new skills and interests, like maybe even taking up swimming! It’s just a thought that pops into my head every so often.\n\nThen, I look around the world of programming. And I’m amazed by the endless opportunities to learn and grow. Programming languages are like fashion trends that come and go at lightning speed. Keeping up with these trends can be challenging, but staying on top of the game is quite important.\n\nLearning the Groovy language has proven to be a wise decision for me. With my prior experience in Java and fondness for the language, it seemed like the perfect choice. Not only is it syntactically similar to Java, but it also reduces the amount of boilerplate code.\n\nGroovy scripting simplifies Java coding, automates recurring tasks, and makes domain-specific language modeling easy. Plus, it supports ad-hoc scripting.\n\nWith Groovy, you get advanced language features like closures, dynamic methods, and the Meta Object Protocol (MOP) on the Java platform (we will learn all of this, be rest assured).\n\nAnd your Java knowledge won’t become obsolete as Groovy builds on it seamlessly.\n\nBut it is wrong to say that Groovy is only a scripting language. While it certainly functions as one, there’s much more to it than meets the eye.\n\nIt can pre-compile into a Java bytecode, integrate into different applications (especially Java-based), be the basis of building a whole new application, and so much more.\n\nGroovy is also used in major projects like Grails, Jenkins, and Gradle.\n\nAs seen it can clearly do much more than just scripting. So labeling Groovy is like trying to fit a square peg into a round hole; it’s simply too versatile to be restricted to a single category.\n\nIt’s safe to say that when you write a program in Groovy, you are writing a special kind of Java program, with all the power of the Java platform at your disposal, including the massive set of available libraries.\n\nThe only hope is that you learn to write concise code as opposed to the verbose Java syntax.\n\nLet’s take a closer look at why Groovy is such an interesting language.\n\nWhat I mean by being friends with Java:\n• Smooth integration with the JVM (Java Virtual Machine), i.e it works as a dynamic scripting language for JVM\n• Implements operator overloading as Java methods, which can be called in Groovy as if they were operators\n• Uses Java features like abstract classes and interfaces seamlessly\n\nCalling Java classes or functions from within Groovy code and also doing so in the opposite direction is easy.\n\nFor instance, you can still use Groovy Date to access all the methods from the java.util.Date class. And you can also easily call within a Java class a Groovy class called ‘MyGroovyClass’ by ensuring MyGroovyClass is on the classpath for your Java application.\n\nA really cool thing about Groovy is that it plays well with Java syntax! So you don’t need to worry about learning a new syntax altogether.\n\nThe seamless interplay of Groovy and Java opens 2 dimensions: using Java to optimize code for runtime performance and using Groovy to optimize code for flexibility and readability.\n\nDynamically typed languages, like Groovy, move type checks, from compile-time to run-time.\n\nType safety includes handling type (data type) mismatch errors in a programming language. Enforcing type safety can happen at compile time or run-time.\n\nFor instance, in languages like Java (that enforce static typing), you must give a data type to every variable you define. Then the code gets compiled, and a type mismatch error occurs if the type assigned to the variable and the value do not match.\n\nSo you cannot assign a String value to a variable you have defined as an integer (int), i.e String str = 123\n\nGroovy allows you to defer specifying the data type of a variable until runtime, providing greater flexibility.\n\n\n\nOf course, this can be disadvantageous since it can cause the entire system to crash, but it’s a fair price to pay for the features and flexibility it offers in return.\n\nAn extension of the above feature is optional typing.\n\nIt means you can leave out mentioning the data types while writing your code. It’s done with the help of the keyword “def”. We will look at this in detail a little later.\n\nIn Groovy scripting, you can leverage all the object-oriented properties and features available in Java.\n\nSo you can create classes, call class methods, set properties, and instantiate class objects in Groovy.\n\nThere are a lot of great features that Groovy scripts offer. Discussing all of them is beyond the scope of this blog post.\n\n\n\nA few amazing ones are:\n• Consider a common example (I know what you are smiling at, my fellow programmers) ?:\n\nIn Groovy, you don’t need a semicolon or a parenthesis. Even System.out.println (in Java) is reduced to println.\n• It doesn’t need to import packages or make it mandatory to specify data types.\n• It supports closures, a really awesome feature we will see in a while.\n• It generates setters and getters automatically at compile time. It’s called a POGO (Plain Old Groovy Object).\n• It’s super easy to work with Lists and Maps in Groovy.\n• It supports operator overloading, albeit makes it easier than Java.\n• It’s exciting to witness an increasing number of developers adopting Groovy lately! It’s gaining a lot of attention and momentum in the industry. Plus, it’s equally corporate-backed and has robust community support.\n\nTalking about the features of Groovy is like asking a chef how many ingredients they have in their pantry. Just like a skilled chef uses a variety of ingredients to create unique and flavorful dishes, programmers can use diverse Groovy features to craft something powerful and efficient. The features blend so well that coding in Groovy soon becomes second nature, not to forget pure fun.\n\nBuilding on the flexibility that Groovy offers, there are different ways in which you can start your journey.\n\nTo run Groovy 2.4, ensure you have a Java Runtime Environment (JRE) for Java versions 6,7, or 8 installed on your computer. It is available for free here.\n\nAfter this, simply set the JAVA_HOME environment variable to point toward the location of your Java installation.\n\nA detailed installation guide for Groovy is available on its official website. It will walk you through all the latest instructions.\n\nNote: You can also refer to Groovy documentation if you prefer so.\n\nOnce you have installed Groovy, you can run it directly as scripts. You can do so via “groovy”, “groovysh”, or “groovyConsole”.\n\nYou can even compile Groovy with “groovyc” or run a compiled Groovy script with Java.\n\nIf you feel adventurous, you can install a Groovy plug-in for your favorite IDE: IntelliJ IDEA plug-in, Netbeans IDE plug-in, Eclipse plug-in, and other editors.\n\nBy now, you might have an idea about how easy it is to work with Groovy. It can be a handy tool. But hey, we all need to be practical as well, right?\n\nSo in the next section, we’re going to check out how to use Groovy scripts in real-world situations.\n\nDepending on your situation and domain, you might want to use the features of Groovy differently.\n\nGroovy for the Plain Old Java Programmer\n\nOne of the most obvious ways to make use of Groovy is by pairing it up with Java programming.\n\nAs someone who has been a Java developer, I empathize with the challenges that arise when trying to introduce a new language to the team, only to face resistance from management who insist on sticking with Java. It’s often the case because Java is widely acclaimed and cherished.\n\nGroovy can be your savior and trusted ally here, allowing you to introduce dynamic behavior on top of your existing Java code while making it concise. So with Groovy, you can open a plethora of use cases and get the ball rolling on new projects.\n\nLet’s consider a simple example here.\n\nI’m sure, as a developer, there must have been countless occasions where you needed to access a file and perform some operations before closing it (or sometimes forget to close it, resulting in some awkward stares from peers).\n\nHere is how you would use Java to achieve this seemingly simple task.\n\nSo the software application that you have been burning the midnight oil for, can be taken up a notch with the features that Groovy offers. And your managers remain happy you haven’t abandoned Java altogether.\n\nIts support for features like functional programming and metaprogramming allows you to write concise and expressive code, at the same time providing seamless integration with Java libraries and frameworks.\n\nAutomate Your Way with Groovy Scripts\n\nGroovy is a perfect language to automate daily, repetitive tasks like extracting data from a data source, processing a batch file, or generating your quarterly sales report.\n\nWith built-in scripting capabilities, you can automate your way forward with Groovy scripting and make your life easier.\n\nIf you are the DevOps or the Agile programmer kind and your daily work is managing a bunch of cards and statuses across different workflows, Groovy can be your genie.\n\nIt can build simple automation for everyday tasks or even pull up continuous integration (CI) and reporting capabilities.\n\nScriptrunner, an add-on app on the Atlassian marketplace, advocates Groovy and its vast capabilities by offering automation for everyday Jira tasks. It helps you create custom-scripted fields, design unique workflows, automate bulk actions, and much more.\n\nGroovy can even help you with your testing needs, both unit and functional testing, so your testers feel right at home.\n\nYou can’t think of standalone applications in a digitally evolving world.\n\nAs a developer, you might have already felt the need for different software applications and programming languages you use to be interoperable with each other.\n\nSo it can play a huge role in a lot of different integrations.\n\nYou might have used APIs and the pain that goes along with making them talk to one another. To make this issue easier, you can use Groovy to integrate with RESTful APIs, SOAP services, and other web services. It is possible because of built-in support for HTTP, JSON, and XML, making it easy to handle and manipulate data.\n\nGroovy features like support for JDBC and SQL make it easy to integrate it with your data sources like MySQL, Oracle, and PostgreSQL. And a cherry on top is that you can use this extracted data to generate reports with Groovy as we saw a while ago.\n\nWe have all struggled with conflicting message formats and structures. Groovy’s dynamic typing gives the flexibility to work with these formats. So you can use it to integrate with middleware technologies like Apache Kafka, RabbitMQ, and Apache Camel.\n\nCloud services have taken the world by storm. You can use Groovy to integrate with various Cloud services and applications like AWS, Azure, and Google Cloud. You can also use it to integrate with other cloud applications like Jira, Azure DevOps, Salesforce, ServiceNow, Zendesk, GitHub, etc.\n\nYou can use Groovy scripting for enterprise integration tasks like ETL, data integration, and application integration. Its support for functional programming and collections, along with the Java libraries and frameworks within its reach, can be a powerful integration tool and resource.\n\nHave these concrete examples opened your minds to the world of Groovy and the value it brings to the table?\n\nYou might have already started thinking of newer ways to implement your next project using Groovy scripting. Or you might ponder about how to use the integration prowess it natively supports.\n\nLet’s dig into this thought a little more.\n\nThroughout this blog post, we will explore an interesting way in which Groovy adapts to diverse scenarios.\n\nWe’ll discuss a solution called Exalate that uses Groovy scripts to synchronize information between different applications.\n\nBefore we discuss how Exalate uses Groovy, let’s briefly understand what Exalate is in the first place.\n\nExalate is an integration solution that aims to provide uni or bi-directional synchronizations between different software applications. It supports integrations for Jira, Salesforce, ServiceNow, Zendesk, GitHub, Azure DevOps, HP ALM, etc.\n\nNow there are many integration solutions available in the market. Then why talk only about Exalate?\n\nExalate is the only integration solution in the market that uses Groovy scripting to set up advanced, tailor-made integrations with multiple dependencies and custom data mappings.\n\nSo it would be intriguing to study how you can use Groovy scripts for synchronizing information across our favorite platforms.\n\nExalate has its reasons for choosing Groovy as the preferred language. Regarding this, I had a conversation with the chief software engineer at Exalate, and this is what he had to say:\n\nExalate supports decentralized integration. It uses Incoming and Outgoing sync processors on both sides that wish to interchange data. These processors allow independent and full control over information exchange.\n\nHow to Set Up Your Development Environment in Exalate\n\nThe Exalate admin console has Outgoing and Incoming sync processors in the form of “Incoming sync” and “Outgoing sync” respectively. These windows are present under the “Rules” tab that is displayed when you configure the connection.\n\nFor instance, if you want to set up a Jira Zendesk integration, you must first install Exalate on both Jira and Zendesk instances. Then create a connection in the Script mode.\n\nYou then need to configure the Outgoing sync script to determine what information to pass to the other side and an Incoming sync script that interprets the information received from the other side. You can choose to add, delete, or edit these sync “Rules” according to your integration use case.\n\nThe Script Mode allows you to generate and optimize scripts using the AI Assist feature — which appears as a tab under both the incoming and outgoing sync rules.\n\nHow does it work?\n\nEnter your sync requirements into the chat box, and AI Assist will generate scripts based on your input, existing configurations, and Exalate’s scripting API.\n\nIt is also important to note that AI is not perfect. So, you need precise and detailed prompts to ensure the best results.\n\nLet’s say you want to sync statuses between Azure DevOps and Salesforce; the prompt could look something like this:\n\n“I want to sync the status of my work item with the status of a Salesforce case.”\n\nAfter a moment, the script will be generated, with suggested changes highlighted in green and red. The green scripts are suggested additions, while the red scripts are suggested deletions.\n\nIf the new snippet works for you, click on “Insert Changes”. Otherwise, you can discard the suggested code. If needed, you can refine your prompt and, once satisfied, publish the changes.\n\nYou must “Publish” the changes and then test the sync upon configuring the scripts.\n\nWhile using Exalate, you’ll come across something called “replica”. You can see it in the image above.\n\nA copy of the original entity transferred to the other side is called a replica. It is a payload containing details of the information exchange.\n\nYou can learn more about Exalate through its Academy tutorials or get hands-on experience with a step-by-step Getting Started guide on its documentation.\n\nChapter 3: Understanding the Fundamentals Before You Start Coding in Groovy – aka Groovy Scripting Basics\n\nEach programming language has its distinct look and feel, but the general structure remains the same. If you are familiar with a few such languages, following this blog will be easy for you. It’ll also help to have some background knowledge of Java.\n\nNevertheless, I will provide the necessary information for each concept we cover, enough for you to get started with the language. But you must be aware of general programming concepts: braces, indentation, operators, parenthesis, comments, statement terminators, and the like.\n\nIf you are eager to learn these concepts, move on to the next chapter.\n\nOf course, you can always revisit any section if you feel like you are struggling.\n\nWe’ll cover a few starters here so you are comfortably settled within the Groovy environment.\n\nLike all programming languages, you can use single-line or multi-line comments in Groovy.\n\nLess is More in Groovy\n\nAs we have already discussed, you can write shorter, more concise, and more expressive code using Groovy scripts.\n• Parentheses, package prefixes, and semicolons are optional in Groovy. However, in certain situations, like in methods with no parameters or constructors, parentheses are a good practice.\n• Using “return” statements is optional in Groovy.\n• Methods and attributes in Groovy are public by default.\n• You can omit mentioning the “throws” clause in the method signature if a checked expression is thrown.\n\nWith this under your belt, let’s study the principle tool we will be using throughout this blog: the println or print statement\n\nYou can use the print or println statement to display the output in Groovy. Classically these methods print the toString value of the object.\n\nIgnore the other lines of code written in the example below. We will study them a little later. You might already know what a class is if you are familiar with Java.\n\nGroovy scripts are files that hold the “.groovy” extension.\n• They can contain any non-specific statements, plain text, class, or method definitions.\n• They can be run from the command line or within a Groovy environment.\n• When a Groovy script is executed, the Groovy interpreter reads the script from top to bottom and executes each statement in turn. If the script contains method definitions or class declarations, these are compiled into bytecode and loaded into the JVM at runtime.\n• They can also import or use external libraries, such as Java libraries or other Groovy scripts to extend their functionality.\n\nNote: You can externalize Groovy scripts in Exalate so you can use (or reuse) them outside the product scope.\n\nYou can use import statements in Groovy to implement some functionality provided by libraries.\n\nBy default, Groovy imports the following libraries, so you don’t need to worry about importing them.\n\nThe most common example of Groovy packages used in Exalate is for transformers. You can use these transformers to convert information from one specific format to another.\n\nFor instance, every application has a different format, Jira – Wiki, Azure DevOps, Salesforce and ServiceNow – HTML and GitHub, and Zendesk – Markdown.\n\nThe following packages can be used to handle these formatting differences:\n\nNote: You can also check for more information on the packages here.\n\nKeywords are special words that are reserved to perform a certain function. So you cannot use them as a variable or function name.\n\nWe will be learning about a few important keywords in the coming sections.\n\nPhew! That was long. I hope you are all set to move further. If not, take a break and come back soon.\n\nThere is only one way to hit the road now, to start coding! So let your fingers groove with Groovy and follow on.\n\nConsider the following statement:\n\nWe have declared a variable called str. It belongs to the data type: String. Its value is: ‘This is a string variable’.\n\nVariables are named memory locations that have a data type. You’ll want to use variables to store some information. You can then use these variables to perform some operations throughout the program.\n• Variables are case-sensitive. So, int x = 5 and int X = 5 are two different variables: x and X.\n• Variable names can include alphabets, numbers, or the underscore sign. It can start with either an alphabet or an underscore, not a number.\n• Variables need to be declared. That is, you must specify the data type of the variable either explicitly or using the “def” keyword (we will cover it soon).\n\nData types denote what kind of data that variable holds: a string, a character, a boolean, an integer, a decimal, etc.\n\nGroovy has several built-in data types. We will quickly look at each of them.\n\nNumbers can be integers (whole numbers) or decimal (floating point) values.\n\nThe following table summarizes the data types and the range of values under each category.\n\nNote: You cannot assign a higher value like 45552 to a short data type since it will be out of its range. For instance, short s = 45552. Try it yourself and see the result!\n\nStrings are used to give some text value to variables. It can be either a single character (char) or a block of text (String).\n\nStrings can be enclosed in single, double, or triple quotes. Strings enclosed in triple quotes can span across multiple lines.\n\nStrings are formed out of single characters placed in a sequence. So you can access individual characters one at a time. The index position of the first character is 0, and the last character is one less than the length of the string.\n\nString interpolation allows you to include variables or expressions (like 5+5) within a string. You can include variables or expressions with dynamic content without concatenating strings and variables manually.\n\nWhenever an expression is given within ${expression} in a string literal (double quotes), it works as a placeholder. When the code is executed, the expression is evaluated and replaced by the actual value.\n\nFor instance, if the expression says hello ${age}, the aim is to replace age with the actual value. Likewise, if there is an expression like ${5+5}, it will be replaced with the actual answer 10 at run-time. String interpolation aims to achieve this.\n\nNote: String interpolation works only for strings in double quotes. Single and triple quotes aren’t valid candidates for it.\n\nSuppose you want to synchronize comments from one system to another and have a specific requirement for this sync. You want to mention the original author of the comment from the source side and send it to the destination instance. You also want to sync the comment creation time.\n\nThe Groovy script used in Exalate for this use case would be\n\nBoolean is a special data type. You can assign only 2 values to Boolean variables: true or false. It is mostly used in conditional statements to check whether a value is true or false. You can use it like a regular data type and assign it to variables, methods, or any other field.\n\nI have been harping about how Groovy scripting is so versatile. Here’s a good one.\n\nThere are 2 ways to declare (or define) variables (or methods) in Groovy.\n\nThe first one is the traditional Java-based static approach, where it is mandatory to assign a data type to a variable name.\n\nThe second one, the Groovy way, says that assigning a data type is optional.\n\nSo, how do you do that? By using the “def” keyword.\n\nLet’s understand it with the help of an example. We have defined 2 variables def X = 6 and def str = “Hello World” and assigned a numeric value and a text value to both of them respectively. Note here that we didn’t explicitly state the data type and simply used the keyword “def”.\n\nOptional typing is the idea of deferring the knowledge of data type until you run the program. So in programming lingo, (data) type checking will happen at run-time instead of compile-time.\n\nThis is achieved using the keyword “def”.\n\nThe keyword “def” can also be used with methods, where it is not mandatory to mention the data types for parameters.\n\nWhen a variable is declared using “def”, Groovy infers the type of the variable based on the value that is assigned to it.\n\nUsing the keyword def doesn’t imply that a data type doesn’t exist; it’s just a Groovy equivalent to an Object in Java.\n\nNote: Groovy can blow your mind away by allowing static type-checking using the @TypeChecked annotation.\n\nNote: You can use optional typing with Exalate scripting just like you would in Groovy.\n\nOperators in a programming language allow you to manipulate data. They help perform some kind of operation on integers, strings, or booleans.\n\nIn Groovy, you can perform normal math operations like:\n• Subtraction (-): Subtracts one number from the other\n\nAnd then there is a power operator “**”.\n\nThe power operator has two parts: the base and the exponent, like in math. The result will depend on the value of the operands (base and exponent) and the data type they belong to.\n\nPlus, you also can use the usual postfix and prefix operators: ++ (increment) and – – (decrement) within expressions in Groovy.\n\nFor instance, x++ uses a postfix operator. It means that the value of ‘x’ is first used in the expression, and then incremented afterward.\n\nA prefix operator, ++x means that the value of ‘x’ is first incremented, and then used in the expression.\n\nYou can refer to the example shown below.\n\nYou can also use the Unary operator in Groovy. A unary operator operates on a single operand, i.e it takes a single input and produces a single output. They are used to modify the value of a variable or perform a specific operation on it.\n\nRelational operators are used for comparing two variables, values, or objects. So the two values can be equal, greater than, smaller than, or not equal to.\n\nIt returns a boolean value (true or false) based on the comparison made.\n\nHere is an example to demonstrate some of the operators.\n\nLogical operators are used to evaluate boolean values and return a boolean result. Groovy supports 3 logical operators:\n• Logical AND (&&): returns true if both operands are true, false otherwise\n• Logical OR (||): returns true if at least one operand is true, false otherwise\n• Logical NOT (!): returns the opposite boolean value as that of the operand\n\nBitwise operators are operators that perform operations on the binary representation of integer values.\n\nBitwise operators are used for int, byte, short, long, or BigInteger. If you use bitwise operators with an int and a long, then the result will be long, between a BigInteger and a long, then the result will be a BigInteger.\n\nIn short, the result will always be the largest numerical data type.\n\nThere are four bitwise operators that Groovy supports:\n• AND operator (&): returns a value where each bit is set to 1 only if both operands have a corresponding bit set to 1 (e.g: x&y)\n• OR operator (|): returns a value where each bit is set to 1 only if either operand has a corresponding bit set to 1 (e.g: x|y)\n• XOR (exclusive or) operator (^): returns a value where each bit is set to 1 only if exactly one of the operands has a corresponding bit set to 1 (e.g: x^y)\n• Negation operator (~): returns a value where each bit is flipped from 1 to 0 or from 0 to 1 (e.g ~x)\n• Left shift operator (<<): shifts the bits of the first operand to the left by a number of positions specified by the second operand (e.g: x << 2)\n• Right shift operator (>>): shifts the bits of the first operand to the right by a number of positions specified by the second operand (e.g: x >> 2)\n• Right shift unsigned (>>>): shifts the bits of the first operand to the right by a number of positions specified by the second operand, filling the leftmost bits with 0’s instead of preserving the sign bit like the regular right shift operator (>>)\n\nBitwise operators are typically used while working with low-level binary data, such as when implementing networking protocols or device drivers. They can also be used in other contexts when optimizing certain algorithms or data structures.\n\nNote: You can learn more about Bitwise operators here.\n\nThe range operator is used to create a sequence of values that have a starting and an ending point. It is represented by two dots (..) and can be used to create a range of integers, characters, and other data types.\n\nRange operators can be used in conjunction with other Groovy scripting data structures like lists, arrays, or collections. It can be useful when working with large data sets or when generating sequences of values.\n\nBefore we learn about the safe navigation operator, let’s see what a dot(.) operator is.\n\nLike Java, Groovy also uses the dot (.) operator to access the class members and functions.\n\nIn the example shown below, we have declared a class called Company that has a name and address. To access a class variable (or method) we create an object of the class. Then use the dot operator after the name of the object followed by the variable (or method) name.\n\nSo if the object is def acme = new Company(), we access the name as acme.name.\n\nNow, what happens when you execute the code below?\n\nIt throws a NullPointerException, a classic pain in the neck situation. Sometimes this exception can make your entire system crash.\n\nThe safe navigation operator was born out of the need to avoid the NullPointerException.\n\nInstead of a single dot, it has a question mark followed by a dot(?.). If the first argument or operand is null the entire expression will be null. It won’t throw an exception but just return the value null, not breaking anything in the process.\n\nAnother reason the safe navigation operator is so popular is that it can simplify your code.\n\nConsider the example shown below.\n\nNote: We will learn more about the if loop in a while.\n\nAs we saw in this section, the Safe Navigation operator (?.) is used to avoid the NullPointerException.\n\nExalate uses this operator in a simple yet innovative way.\n\nFor instance, you want to access the email property of a user while syncing the reporter from a Jira instance.\n\nWe can use the operator in the following manner.\n\nThe above line ensures that if the email address of the reporter isn’t found, then the Safe Navigation operator would return a null value instead of throwing an exception.\n\nMany of us have grown up listening to Elvis. Let’s read about the Elvis operator in Groovy now.\n\nLet’s start with the following example:\n\nThe Elvis operator (?:) is a shorthand operator that allows you to simplify null checks in your code. It’s often referred to as “ternary operator for null safety”.\n\nAs seen in the example above, if value1 is not null then it simply picks it up and assigns it to the result. If the value1 is null then pick value2 and assign it to the result. So you can assign a sensible default value in case one of the values is null.\n\nThe Elvis operator can also be used in method calls or as a part of complex expressions. It is useful to write a more concise and readable code that handles null values elegantly.\n\nWe saw how the Elvis operator allows you to simplify null checks in your code and assign sensible default values in case the code encounters a null value.\n\nSay, you want to assign a default value when syncing some information from Jira to Zendesk. In Jira, the description for the ticket is optional, while in Zendesk, it’s mandatory.\n\nSo your Incoming sync script in the Zendesk instance would look like this.\n\nThe above script ensures that if an issue doesn’t have a description in Jira, “No description provided” will be auto-filled as the fallback description in Zendesk.\n\nNow that your mind is operated enough on Groovy, let’s take you for a loop ride.\n\nGroovy supports all the control flow structures that Java offers. So you can use the if-else, for, while, do-while, and switch statements.\n\nControl flow structures alter the flow of the program. So instead of statements executing sequentially, they run in an order specified by the control statement.\n\nIf, If/else or Nested If Statement\n\nThe ‘if’ statement evaluates a condition, and if the result is ‘true’ then statements preceding the truth (if statement) are executed, otherwise, the statements preceding the false (else statement) are executed.\n\nYou can skip the ‘else’ statement and only use the ‘if’ condition.\n\nYou can even use nested ‘if’ loops in Groovy.\n\nYou can also use a short-hand way of writing a long if-else statement by using the ternary operator.\n\nIf the condition is true, then expression1 is executed, otherwise expression2.\n\nUsing the If Statement in Exalate Scripting\n\nThe use of the ‘If’ statement in Exalate can be varied because you can do a variety of things based on the values received from the other side or modify the values you want to send to the other side the way you want.\n\nSuppose in Jira, you want to create an issue in a particular project. You also want to create an issue of a particular issue type based on the value of a field present in the replica.\n\nYou can use the following code:\n\nA switch statement allows a program to perform different actions based on the value of a variable or an expression.\n\nIt provides a way to test the value of an expression against multiple cases and execute different blocks of code depending on which case matches the value. The expression being evaluated is compared against each of the cases, and when a match is found, the code block associated with that case is executed.\n\nThe switch statement is often used as an alternative to a series of if-else statements, particularly when there are multiple conditions to check.\n\nThe variable or expression you need to evaluate must be given in the round brackets after the keyword switch. For the cases, use the keyword ‘case’ followed by the actual value you want to test, and finally a colon (:). Use the break statement after every case. The entire switch block is enclosed within curly braces {}.\n\nA variable day is defined and you switch on the value of the day, i.e. Tuesday. The second case turns true when the value of the variable day matches “Tuesday”.\n\nSo the output of the second case is printed and then the “break” statement is executed.\n\nGroovy supports ‘for’ loops where you can iterate over a sequence of values, such as a range of numbers or a list of items. You can use ‘for’ loops with arrays, collections, Maps, etc.\n\nThe actual condition for which you need to run the for loop is given in round brackets. For instance, in the second example shown below, print the value of ‘i’ 5 times. The condition to check whether the value of ‘i’ has reached 5 and incrementing (or decrementing) the value after each iteration of the ‘for’ loop is given within the round brackets. The actual statements that need to be executed within the ‘for’ loop are mentioned in curly brackets {}.\n\nUsing For Loop in Exalate Scripting\n\nYou can use the “for” loop with Exalate.\n\nIf you want to store some information from a user-defined field in the description field of an issue in Jira, you can do so as follows:\n\nNote: For loops are not always the most elegant solution to use. There are other methods like .each(), .find(), and .collect(), that we’ll see in a while which serve the same purpose and are a better option.\n\nThe ‘while’ statement will execute a block of code repeatedly till a condition is true. The condition is evaluated at the beginning of each iteration of the loop. If it is true the code inside the loop is executed. This repeats until the condition remains true.\n\nThe condition is given inside round brackets after the keyword ‘while’. The entire loop is then enclosed within curly brackets {}.\n\nIn the example shown below, the condition checks the value of “i”. It prints this value till “i” becomes equal to 5. For every iteration, the value of “i” is incremented.\n\nThe ‘do-while’ statement is a variation of the while statement, where the condition is evaluated after the first iteration of the loop, ensuring the block is executed at least once.\n\nThereon, for every iteration, the code in the ‘do-while’ block is executed until the condition remains true.\n\nIf you’re familiar with Java, you might already know most object-oriented programming concepts like classes, objects, interfaces, etc.\n\nGroovy is a full-fledged object-oriented programming language; everything is an object.\n\nYou can create classes in Groovy like you can in Java.\n\nA class is like a blueprint that defines the structure and behavior of objects. It has a set of properties (or attributes) and methods (or functions).\n\nProperties hold the data within the class, and the methods are operations you perform on that data.\n\nIn the following example, we have defined a class called Student that has a few properties: name, age, and grade. It has a method called sayHello to print the students’ information. We create an instance (object) of the class called “student” (class names are case sensitive, so “student” is different from the class “Student”) and give values to its properties.\n\nThen we call the sayHello method to print those values. As seen, you can access individual properties and methods of the class with the dot(.) operator.\n\nYou can control the visibility, that is, which methods and properties are accessible outside of the scope they are defined in through the usual access modifiers: public, private, and protected.\n\nBy default, properties, and methods are public, but you can use other access modifiers to change the visibility.\n\nYou can also create constructors for the classes you define. Constructors are methods used to initialize the objects of a class. A constructor has the same name as that of the class.\n\nPlain Old Groovy Object (POGO) is a simple class in Groovy where you don’t need to define setter and getter methods (constructors) since Groovy will automatically generate them for you.\n\nGroovy supports inheritance, where the child class inherits properties and methods from the parent class. An inherited class is defined by the keyword: “extends”.\n\nYou can also create interfaces in Groovy. An interface acts like a contract that the class must adhere to. Interfaces only consist of a list of methods for which no implementation (method body) is provided. The class that “implements (a keyword)” an interface must provide the method body, i.e, the implementation. Interface methods can be public and abstract. The properties of the interface can be public, static, and final.\n\nYou can also create abstract classes or methods in Groovy scripting. It is similar to interfaces but can contain method implementation. You cannot create an object of an abstract class. They can be created by using the “abstract” keyword.\n\nYou must provide an implementation for the abstract methods if you create a class that inherits the abstract class.\n\nAt the heart of Exalate is a replica that works as a payload to pass information between two applications. The replica itself is an object, and everything within it is also an object.\n\nSo, let’s consider the example of “status” in a Jira issue. When you say , you’re using the same object-oriented concepts we discussed earlier. We use the dot (.) operator to access the name property of the status object.\n\nGroovy closures are an interesting concept. Closures are anonymous blocks of code performing some function. They are defined within curly brackets: {}. A closure can contain multiple statements.\n\nYou can assign them to a variable and call it a function (or method) with a return value or you can even use them as arguments to a function. The block of code gets passed around and executed at a later time, more like a “function-on-the-go”.\n\nGroovy closures are a powerful way to write flexible or reusable code; they also save you a lot of time and make the code concise.\n\nYou can see a lot of use for closures in Groovy data structures.\n\nThat brings us to our next chapter: Groovy data structures.\n\nPerhaps, the most common and popular way of using Groovy Closures in Exalate is when you want to manage the comment visibility between different applications.\n\nIn Jira Service Management, you can create comments as internal or public. And you want to filter and send only public comments from Jira to the destination instance.\n\nYou can do so using the following code snippet:\n\nWe have seen data types like int, long, short, etc. These are called primitive data types.\n\nData structures are collections of these primitive data types in a list, an array, or a map format. We’ll look at them one by one.\n\nGroovy Lists allow you to store a collection of data. You can think of a List as a sequence of items, like your grocery or to-do list.\n\nTo create a List in Groovy scripts, enclose it within square brackets [] and separate the items within the list with a comma (,).\n\nLists are a one-dimensional data structure. The items in a List can be primitive data types, or they can be object references.\n\nAs we saw, Lists are sequences of items. So to perform some operations on Lists you can iterate over the list items one-by-one through indices.\n\nThe first item has an index of 0 and refers to the first item in the list.\n\nThere are a lot of other operations you can perform on Lists. They allow you to read, add, remove items from the list, and do much more.\n\nWe’ll see a few of them.\n\nThe each() method helps you iterate over all the items in the List and perform some operation on them. It’s a convenient way to apply the same operation to every item on the List.\n\nThe .find() method allows you to search for a specific item in a list based on a condition you specify. It helps you find the first item within the list.\n\nThe findAll() method works in the same way as the find() method. The only difference is that the findAll() method returns all the items that match the criteria instead of only the first item.\n\nContinuing the above example.\n\nThe .collect() is used to manipulate the list and return the manipulated list. It transforms the list into something else.\n\nIn the example shown below, we create a new list by multiplying all items in the old list by 2.\n\nA few more list methods are:\n\nOne of the most common examples of Lists in Exalate scripting could be when syncing sprints in Jira.\n\nMaps represent an unordered collection of items in the format of a key:value pair. The keys and values are separated using colons and each key/value pair is separated by commas. The entire set of keys and values are enclosed in square brackets.\n\nThe key works like an index to search for the value. They are also called associative arrays or dictionaries in some programming languages.\n\nLike Lists, there are methods you can use to manipulate the items in maps.\n\nThe .each() method is used to iterate over maps and perform a specific operation on each of its key-value pairs.\n\nThis method can be used to search for a key-value pair in a map that matches a given value based on a condition. The find() method returns the first key-value pair in the map that matches the given condition, or null if a match isn’t found.\n\nThe findAll() method is used to search for all the key-value pairs in a map that matches a given value based on a condition. The findAll() method returns a new map that contains all the key-value pairs in the original map that match the given condition.\n\nA few more map methods are\n\nThere are a lot of use cases for Maps in Exalate. You can map issue types, priorities, statuses, etc between two systems and perform some sync operations on them.\n\nAn array is a fixed-size collection of items of the same data type. So you can create an array of integers, long or strings.\n\nYou must use square brackets [] to create an array, just like with lists. The only difference is that the data type declaration is compulsory in arrays. You can also create arrays with the new keyword.\n\nYou can use the functions we discussed, such as collect, findAll, each, inject, and more, with arrays as well.\n\nGroovy supports regular expressions through the use of the java.util.regex package. This package allows you to create, manipulate and search for regular expressions through inbuilt classes and methods.\n\nA regular expression is a pattern that defines a set or subset of strings. You can use regular expressions in a variety of ways for different purposes. For instance, find all instances of a particular word, phrase, or pattern in a large block of text, extract data from strings, and even replace a certain block of text with another block.\n\nRegular expressions in Groovy can be denoted with a /…/, where the dots represent the pattern. For instance, the regular expression /world/ matches the string “world” wherever it occurs.\n\nTo search for a regular expression within a string, you can use the =~ operator.\n\nYou can also use the ==~ operator to match a regular expression against a string and return true or false.\n\nYou can use various special characters in regular expressions to create and match complex patterns. The most common ones are\n\nYou can use certain characters to match another set of characters. For instance, [aeiou] matches any vowel whereas [a-z] matches any lowercase character.\n\nYou can also include grouping or alternation of characters. To group, use parentheses and to alter use the pipe (|) character. For instance, the regular expression /(hello | world)/ matches either “hello” or “world”.\n\nConsider an example where you want to search for all the strings that match the pattern of an email address.\n\nGroovy supports a lot of inbuilt methods to work with regular expressions, such as find, findAll, replaceAll, split, etc.\n\nRegular expressions can be complex and difficult to read, so it’s important to use them with caution. They can also be computationally expensive, so make sure you consider their performance in performance-intensive code or while dealing with large strings.\n\nPhew! That’s a lot of coding we already learned.\n\nBut during this coding journey, have you yet encountered an error message that left you puzzled already?\n\nThe next step is to learn exception handling in Groovy scripting; so you don’t crash your program right away (hopefully never, fingers crossed).\n\nRegular expressions allow you fine-grained control over matching patterns within strings.\n\nThis can be particularly useful when you need to send information between two applications based on specific sub-string or pattern matches.\n\nOne example of regular expressions (Regex) in Exalate is when you want to sync only selected comments that match a filter.\n\nLet’s say you only want to send those comments that include the word ‘[SEND]’ in the comment text. Any other comments should not be sent.\n\nPrograms crash all the time, and the only way for it to recover is to handle exceptions gracefully.\n\nExceptions are errors or events that occur during the execution of a program causing it to behave in unexpected ways. These exceptions can occur due to various reasons, such as file i/o errors, invalid input, wrong program logic, network errors, etc.\n\nGroovy supports “try-catch” blocks to handle exceptions. The “try” block includes the code that might throw an exception, and the “catch” block contains the code to handle the exception.\n\nWhen an exception occurs in the try block, the code execution stops in that block and the program jumps to execute the code in the “catch” block.\n\nAn example of a try-catch block:\n\nAs seen in the example, the try block attempts to divide a number by 0, resulting in an ArithmeticException. The catch block catches the exception and prints out the required message. The “finally” block is optional and is executed regardless of whether the exception occurs or not.\n\nYou can have multiple catch blocks to catch different types of exceptions.\n\nIn addition to the general try-and-catch block, you can also throw your own exceptions using the “throw” keyword. It allows you to create custom exceptions and handle them in a manner you deem fit.\n\nException handling is important for any programming language to write more reliable and robust code.\n\nThe Groovy programming language is loaded with awesome features that are super handy for test-driven development. Yeah, it’s true!\n\nWhen it comes to writing tests and making sure your code is rock solid, Groovy has got your back. It offers a bunch of cool features and state-of-the-art testing libraries and frameworks that have proven to be valuable in the world of test-driven development.\n\nOne such feature is the “assert” keyword.\n\nAn assertion (or an assert statement) is a nifty tool that lets you test your assumptions about your program. Let’s say you’re working on a method to calculate the ability of an individual to vote. With assertions, you can make sure the age of the person is always greater than 18.\n\nBasically, you create an assertion with a statement that should be true when it is executed. If the statement turns out to be false, the system will throw an error your way. By double-checking that the statement is true, the assert keyword gives you that extra confidence that your program is error-free and behaving just as you expect it to.\n\nHere’s the cool part: writing assertions while you’re coding is like a superpower to finding and fixing bugs.\n\nSo how do you use the assert keyword in Groovy?\n\nThere are two forms in which you can use the assert keyword.\n\nThe first form is:\n\nWhere Expression1 is just a fancy term for a Boolean expression. When your program hits this assertion, it checks if Expression1 is true. If the expression is true, it continues executing the next statement in the program and doesn’t print anything. If it’s false, then an AssertionError is thrown.\n\nAnd the second form of the assert statement is:\n\nWhere Expression1 is still our older Boolean expression and Expression2 is something that actually has a value. It can’t be something like a void method call. Bummer!\n\nBut here’s where it gets interesting. You can use this second form of the assert statement to display a super cool detailed message for the AssertionError. To do this, the program will grab the value of Expression2 and use it as an error message. That way, you’ll get more details about what went wrong in your assertion. Pretty handy, right?\n\nConsider the following code:\n\nIf the age isn’t above 18, you’d be thrown a pretty direct error message as to why your assertion failed.\n\nThe detailed message is all about capturing and sharing the details of the assertion failure. It can help you diagnose and fix the error that made the assertion go kaput. It isn’t catered toward regular users but is to be viewed alongside your stack trace and the source code. So you don’t have to worry about making it more understandable for the general public.\n\nJSON stands for JavaScript Object Notation and is a lightweight format for storing and transporting data.\n\nIt’s a popular way to represent data in a human-readable format. It consists of data in the form of key-value pairs, as we saw with Groovy Maps.\n\nJSON formatting in Groovy is extremely useful. It simplifies the handling and manipulation of JSON data. It enhances the capabilities of Groovy when working with JSON-based technologies and facilitates data exchange, configuration management, testing, and more.\n\nIn Groovy, you can work with JSON easily because it has in-built support for handling JSON data.\n\nIf you have your data handy, Groovy can convert it into JSON using the JsonBuilder class. You can start using this class by creating its object and using its methods to build your JSON structure.\n\nNote: toPrettyString() is optional here. It’s only used to add some indentation and line breaks to make the JSON more readable.\n\nJsonSlurper is another fantastic class in Groovy that makes working with JSON data a breeze. It allows you to parse JSON strings and convert them into Groovy objects that you can easily manipulate and access.\n\nIn the example above, we create an object of the jsonSlurper class and call the parseText method of that class. We pass the JSON string to the method.\n\nAll you need to do now is to access individual elements of the JSON object using the dot (.) operator. So you can access the name via jsonObject.name.\n\nAnd there you have it!\n\nWith JsonSlurper, you can parse JSON strings and work on the data as Groovy objects. The JsonSlurper class also has a lot of other helpful methods like parse(File file) to parse the JSON data structure given within a file.\n\nWe saw earlier that a replica is the payload passed from one system to another. It contains the data and the metadata in the JSON format.\n\nThere are two replicas per platform: the local replica and the remote replica.\n\nLet me explain how Exalate accesses and works with the replica with an example.\n\nLet’s sync the priority field from ServiceNow to Jira. If you view the replica on the ServiceNow instance, the local replica is the one in ServiceNow, and the remote replica will be the one on the Jira side. Similarly, the replicas will be interchanged if you view them in the Jira instance.\n\nThe replica on the ServiceNow instance looks like this:\n\nThe image shows the hubIssue (aka the replica) with all the incident fields.\n\nNow, our use case is to sync the priority from ServiceNow to Jira.\n\nThe first thing you must do is send the priority information in the “Outgoing sync” in ServiceNow.\n\nThe following incident information is sent from ServiceNow to Jira. You can see the priority being sent too.\n\nNow, if you check the replica details, you can get the priority information in tag.\n\nAccordingly, the “Incoming sync” will be used to get the priority details in Jira.\n\nHere, we have mapped the priorities in ServiceNow to the priorities in Jira. After that, the issue priority in Jira is assigned based on the mapping.\n\nYou can create a host of networked applications using the powerful set of networking features that Groovy supports.\n\nNetworking in Groovy is built on top of Java’s networking APIs. So if you are familiar with Java’s networking concepts, this one should be easy for you.\n\nSome of the key features of Groovy networking include:\n• Support for HTTP/ HTTPS client: Groovy provides an HTTP(s) client library making it easy to request and receive responses. This library supports both HTTP and HTTPS and allows you to set cookies, headers, and other parameters.\n• Socket programming: You can create and manage sockets easily with Groovy. Sockets are endpoints for communication between two systems over a network. You can create both client and server-side sockets and use them to send and receive data.\n• URL processing: You can use a rich set of classes to work with URLs. You can create and manipulate URLs, parse query parameters, and extract information from the URL.\n• Email handling: You can use the JavaMail API to send email messages using SMTP, POP3, and IMAP protocols.\n\nGroovy provides you with powerful networking features that make it easy to create and work with networked applications and get your job done.\n\nSince Exalate supports Groovy-based scripts to extract, transform, and exchange information between multiple platforms, it can use Groovy’s networking features in many ways.\n\nSome common examples of HTTP client requests for information exchange are:\n• How to make any Jira Cloud REST API calls with the Jira Cloud HTTP client.\n• REST APIs used by Exalate to access ServiceNow.\n• How to use REST APIs for monitoring purposes.\n• How to sync Tempo worklogs using external scripts in Jira Cloud.\n• How to perform multiple consecutive operations in one synchronization with the store(issue) function in Exalate.\n\nThe store(issue) function is handy for peculiar use cases. One example is, where the Jira workflow configuration does not let you make changes to an issue when it is closed. To make changes, you must open the issue first. The store(issue) function will check the issue status and, depending on the status execute different sets of actions.\n• Making an HTTPS call to an external service\n\nFor instance, you need to map the GitHub user ID to a Jira email address and vice versa. You need to keep the mapping in an external service that provides endpoints that you can call via an HTTPS link.\n\nYou can also perform URL Processing using external scripts in the Jira cloud.\n\nSo are you ready to explore the infinite possibilities with Groovy scripting and be amazed at what you can achieve?\n\nWhether you are a seasoned developer or just getting started, there’ll always be something Groovy has to offer.\n\nChapter 15: Best Practices and Tips for Groovy Scripting Development\n• Like we haven’t stressed enough the flexibility that Groovy offers. Use some cool features it supports like closures, dynamic typing, a safe navigation operator, and other in-built methods like find(), each(), etc. Use them fully and wisely to get the best out of Groovy.\n• Groovy allows operator overloading, for +,-,*,/, and %. This can be used to create domain-specific languages (DSLs).\n• Groovy supports the @Delegate annotation that allows you to delegate method calls to another object. This can be useful to create adapters or for providing a simpler interface to complex objects.\n• Groovy allows you to modify the behavior of objects at run-time using metaprogramming. You can use it to create dynamic DSLs or for adding some other behavior to objects at run-time.\n\nWe have been working with the Groovy console for quite some time now. It’s a fantastic tool to quickly test out code snippets and a perfect way to play around with Groovy and learn more about the language. You’ll love how easy it is to use. Give it a try and see for yourself.\n\n1. Transformers – Converting HTML to Wiki and Others\n\nThe most common example of Groovy scripts in Exalate can be for transformers. These transformers can convert information from one specific format to another, such that it is understood by the destination instance.\n\nFor instance, every application has a different format, Jira – Wiki, Azure DevOps, Salesforce and ServiceNow – HTML and GitHub, and Zendesk – Markdown. Transformers help convert the HTML format to Wiki, the Markdown format to Wiki, or the Wiki format to HTML.\n\nFollowing are the different transformers that can be implemented via Exalate scripting:\n\nIt’s common knowledge that team members often tag (or mention) each other in comments for various reasons.\n\nYou can use Exalate scripts to sync user mentions in comments between systems like Jira, Azure DevOps, Salesforce, etc.\n\nThe following scripts would do the magic.\n\nNote: The only pre-requisite for this use case is that the user property (like email IDs) should be the same in both systems.\n\nThe details of what happens behind the scenes in this use case can be found here.\n\nYou can also sync user mentions from Jira Cloud comments to Salesforce chatter feed.\n\nAnother common requirement is to handle rich-text and inline images and sync them correctly over to the destination instance.\n\nWe’ll consider Jira and Azure DevOps for this use case as well.\n\nYou can use the following code.\n\nAgile and project management systems like Jira and Azure DevOps often have entities that have a parent-child relationship with one another. The relationship can also have multiple levels of hierarchy.\n\nWe’ll discuss two examples of how Exalate maintains a parent-child relationship.\n\nThe relationship in Azure DevOps is Epic → Feature → Task. The same needs to be mirrored as Story → Task → Bug in Jira on-premise. You can see behind the scenes of this use case in this community post.\n\nAnother use case is for Jira Cloud and Azure DevOps.\n\nWe can create issue links to other issues in Jira and define some kind of relationship between them. The use case revolves around picking up the issueLinks and their relationships from Jira Cloud and transferring them over to Azure DevOps with the help of mapping.\n\nThere is often a need to connect multiple customer tickets to a single development issue. There are different ways to achieve this using Exalate.\n\nHere, we’ll use the httpClient method to sync multiple Zendesk tickets to a single Jira issue.\n\nYou can sync custom fields created in Insights using Exalate.\n\nIn the following example, we’ll sync an Assets custom Insight field in Jira on-premise. You can implement the same for Jira Cloud as well, but the code for that is a little different.\n\nNote: Both the incoming and outgoing sync scripts work for Jira on-premise only. \n\nYou can also sync multiple Insight custom fields with Exalate\n\nFinally, we are at the end!\n\nI hope you’ve enjoyed this journey through the world of Groovy and discovered just how amazing this language can be. From its ‘beauty with brevity’ syntax to its versatile features, Groovy scripting is truly a language like no other.\n\nWhether you’re building web applications, automating your daily tasks, or just tinkering around, Groovy scripting has something to offer for everyone. Amaze yourself and see what you can accomplish.\n\nTill then, feel the groove and code your heart out!\n• The Comprehensive Guide to iPaaS (Integration Platform as a Service)\n• The Definitive Guide to Cross-Company Integrations for IT Professionals"
    }
]