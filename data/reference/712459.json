[
    {
        "link": "https://wiki.libsdl.org/SDL2/SDL_CreateTexture",
        "document": ""
    },
    {
        "link": "https://lazyfoo.net/tutorials/SDL/07_texture_loading_and_rendering/index.php",
        "document": "A major new addition to SDL 2 is the texture rendering API. This gives you fast, flexible hardware based rendering. In this tutorial we'll be using this new rendering technique. A major new addition to SDL 2 is the texture rendering API. This gives you fast, flexible hardware based rendering. In this tutorial we'll be using this new rendering technique.\n\n\n\n \n\n As you can also see we have a new image loading routine with loadTexture and a globally declared texture we're going to load. Textures in SDL have their own data type intuitively called an SDL_Texture . When we deal with SDL textures you need an SDL_Renderer to render it to the screen which is why we declare a global renderer named \"gRenderer\".As you can also see we have a new image loading routine with loadTexture and a globally declared texture we're going to load.\n\n\n\n \n\n After creating the renderer, we want to initialize the rendering color using After we create our window, we have to create a renderer for our window so we can render textures on it. Fortunately this is easily done with a call to SDL_CreateRenderer After creating the renderer, we want to initialize the rendering color using SDL_SetRenderDrawColor . This controls what color is used for various rendering operations.\n\nOur texture loading function looks largely the same as before only now instead of converting the loaded surface to the display format, we create a texture from the loaded surface using SDL_CreateTextureFromSurface . Like before, this function creates a new texture from an existing surface which means like before we have to free the loaded surface and then return the loaded texture.\n\n\n\n \n\n In our clean up function, we have to remember to deallocate our textures using Since texture loading is abstracted with our image loading function, the loadMedia() function works pretty much the same as before.In our clean up function, we have to remember to deallocate our textures using SDL_DestroyTexture\n\n\n\n \n\n With the screen cleared, we render the texture with \n\n \n\n Now, there is a new API call called IMG_LoadTexture. It's not in the official documentation as of this writing but you can find it in the SDL_image header files. It allows you to load a texture without having to create a temporary surface. The reason I haven't gone back and updated the tutorial to use this method is because I don't want to go back an update 40+ tutorials. Even though it is undocumented, it works just fine.\n\n \n\n I recommend giving it a try. Also, get used to having to deal with undocumented code because often times in the professional game development world, documentation is a luxury. In the main loop after the event loop, we call SDL_RenderClear . This function fills the screen with the color that was last set with SDL_SetRenderDrawColor.With the screen cleared, we render the texture with SDL_RenderCopy . With the texture rendered, we still have to update the screen, but since we're not using SDL_Surfaces to render we can't use SDL_UpdateWindowSurface. Instead we have to use SDL_RenderPresent Now, there is a new API call called IMG_LoadTexture. It's not in the official documentation as of this writing but you can find it in the SDL_image header files. It allows you to load a texture without having to create a temporary surface. The reason I haven't gone back and updated the tutorial to use this method is because I don't want to go back an update 40+ tutorials. Even though it is undocumented, it works just fine.I recommend giving it a try. Also, get used to having to deal with undocumented code because often times in the professional game development world, documentation is a luxury."
    },
    {
        "link": "https://stackoverflow.com/questions/50517863/render-texture-on-top-of-texture-created-from-surface-with-sdl2",
        "document": "I want to load a png into a texture and then draw another text texture on top of it. I'm doing something like this:\n\nI'm basing the code on this answer. The comment says that won't work in case the texture is loaded from a surface, and indeed it doesn't. The text appears behind the background image, instead of on top of it. I know the text is rendered, because it is visible if I set the blend mode to , but that's not what I want.\n\nI thought of trying to change the access of the bg texture to , in case that's the problem, but I can't figure out a way to do that for textures created from surfaces.\n\nAny other way to render text on a texture loaded from a PNG file? Performance isn't too important because this will happen only once on application startup."
    },
    {
        "link": "https://stackoverflow.com/questions/54207047/sdl-render-to-a-new-texture",
        "document": "I'm trying to draw the map for each frame over and over again, because I'm moving the map, according to the player's movement to achieve illusion that the camera follows the player.\n\nSo basically, if the player moves, I'm moving all the blocks ( those two , player movement and update blocks positions , are handled in a separate thread ) and rendering the map texture over again , in the main thread.\n\nAlthough, it is really not efficient to draw all the blocks each frame, and it lags the window rendering, so what I want to do is to make another thread, that will create a blank texture that the blocks could be rendered there.\n\nThe question is : Is it possible to do so without a renderer ? to draw all the blocks to a new texture without actually stuck the main renderer that draws the window and prevent it from going over all the blocks each frame ?\n\nThis is the code that goes throgh the map blocks and drawing them to a new texture :\n\nThis is the code that draws textures to the window :"
    },
    {
        "link": "http://thenumb.at/cpp-course/sdl2/05/05.html",
        "document": "As mentioned in the last lesson, textures are the GPU rendering equivalent of surfaces. Hence, textures are almost always created from surfaces, using the function SDL_CreateTextureFromSurface(). This function more or less does what you'd expect—the parameters are the rendering context and a surface to create the texture from. As with other creation functions, it will return NULL on failure.\n\nWhen creating textures in this manner, the data will be copied to the texture, allowing you to free the surface used for loading the image.\n\nYou can also create blank textures with the function SDL_CreateTexture(). This function takes the rendering context, pixel format, width, and height of the texture to create.\n\nThis isn't useful for rendering images, but is necessary to edit pixel data or to render to a texture.\n\nSDL provides several texture properties that affect how they are rendered. These settings mirror the rendering options from the last lesson.\n\nThe function SDL_QueryTexture() is used to retrieve the basic settings of a texture, including the format, access, width, and height.\n\nTextures may include alpha data, but SDL also provides a whole-texture alpha setting. Changing this value will simply cause the entire texture to fade in or out. The functions SDL_GetTextureAlphaMod() and SDL_SetTextureAlphaMod() are used for this purpose.\n\nThe blend mode can modified per texture with the functions SDL_GetTextureBlendMode() and SDL_SetTextureBlendMode(). These functions operate using the SDL_BlendMode structure, which can include no blending, alpha blending (default), additive blending, and modulated blending.\n\nAgain as with drawing, a color modifier can be set per texture. As you'd expect, the functions SDL_GetTextureColorMod() and SDL_SetTextureColorMod() are used for this purpose. Note that the color modifier does not include alpha—you have to get and set alpha separately.\n\nActually drawing textures to the screen is very similar to blitting surfaces, except that you have a few more options. SDL_RenderCopy() is the direct parallel: it takes the rendering context, texture, source rectangle, and destination rectangle.\n\nThe function SDL_RenderCopyEx() (Ex = Extended) provides a few more rendering options. These include a rotation around a point and a vertical/horizontal flip. These are simply passed as parameters. Note that the rotation angle is in degrees, but most math functions/libraries use radians.\n\nAs with surfaces, you can directly edit the pixel data of textures. However, it's rather more complicated than simply accessing the \"pixels\" member.\n\nCreating a texture from a surface uses the default SDL_TextureAccess value SDL_TEXTUREACCESS_STATIC, meaning the texture cannot be changed. If you plan to directly edit the pixel data of a texture, you must use SDL_TEXTUREACCESS_STREAMING instead. This flag tells SDL that the texture may be changed by external code.\n\nHowever, that's not all you have to do. To access the pixel data of a texture, you must use the function SDL_LockTexture(). This function tells SDL to stop any other access to the texture until the user is done with it. The parameters include the region of the texture to edit, a pointer that will be set to the pixel data, and an integer that will be set to the pixel pitch. The \"pitch\" is simply the length (in bytes) of one horizontal line of pixels—the size of the first dimension, you could say. Note that the pixel data is for write only—it is not guaranteed to contain the previous correct values.\n\nThe pixel format specified at texture creation dictates the format of the pixel data. It's pretty straightforward: ...RGBA8888 means first red, then green, then blue, then alpha, and each value is eight bits (one byte). ...RGB444 means first red, then green, then blue, no alpha, and four bits per value.\n\nFinally, once you have finished writing to the texture, you must call SDL_UnlockTexture() to apply your changes and signal SDL that it can use the texture again.\n\nWhile technically, you can do any texture modification you'd like by editing pixel data, it is often much more convenient to render directly to a texture. Essentially, this means using the full rendering API, but instead of drawing to the screen, drawing to a texture.\n\nA texture must be created with the access SDL_TEXTUREACCESS_TARGET to enable rendering to texture. Other than this, the texture is used the same as normal. The function SDL_SetRenderTarget() is used to change between rendering to textures or to the screen. The parameters are quite simple: the rendering context and either a texture to render to or NULL to render to the screen.\n\nNote that you should not call SDL_RenderPresent() when rendering to a texture.\n\nFinally, as with surfaces, textures must be freed when your program shuts down (or they are no longer in use). This is simply done with the function SDL_DestroyTexture()."
    },
    {
        "link": "https://gamedev.stackexchange.com/questions/121421/how-to-use-the-sdl-viewport-properly",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://stackoverflow.com/questions/59913756/c-sdl2-how-to-render-rects-into-multiple-viewports",
        "document": "As I saw, you are drawing a rect at 10, 10 of 100x100 two times, this coordinates doesn't take account of the viewport coordinates. And in a way, if you want to do this by changing the viewport clipping is not relevant... just draw the square where you want.\n\nUPDATE: I tried multiples viewports. Here is a working example. You can choose between the renderer (with viewports) or the classic way."
    },
    {
        "link": "https://wiki.libsdl.org/SDL2/SDL_RenderSetViewport",
        "document": "Set the drawing area for rendering on the current target.\n\nWhen the window is resized, the viewport is reset to fill the entire new window size."
    },
    {
        "link": "https://stackoverflow.com/questions/77938700/sdl2-c-im-confused-about-centering-the-viewport-in-sdl2",
        "document": "When trying to center my renderer's viewport, it seems like adding half of the difference between the window-size and viewport-size to the viewport's x and y coords isn't correct. Instead you need to divide this difference by 3? I'm so confused on this and hope someone has some clarification.\n\nThe goal is to render a 4:3 viewport on a 16:9 window.\n\nAside of this, the viewport's aspect ratio starts skewing completely when I resize the window around manually.\n\nExample of skewed viewport after resizing window\n\nRegarding the funky centering, I tried looking around on the internet on why SDL2 does this, to obviously no avail.\n\nAnd about the skewing, I tried applying a couple of changes to the calculations and looked if the numbers I got were actually correct, and they were.\n\nI was expecting something to change with these adaptations but all I could do was break it some more or change nothing."
    },
    {
        "link": "https://dev.to/noah11012/using-sdl2-viewports-dgn",
        "document": "Using SDL2 in C (and with C++, too)\n\nWhen rendering a scene or world not everything will be inside the boundaries of the window. Only a partial region can be rendered and displayed to the user at a time. In SDL (and generally in GC) this region is also known as the viewport. Anything within the viewport is rendered and everything outside is ignored. Many games have a character that can move and perform operations within in a world. Depending on where the character moves, the viewport must move with it to keep the character in focus.\n\nAs an example to demonstrate viewports in SDL, we will have a program that can zoom and move around in a world that is basically an image of a house and tree.\n\nIn previous posts, we have the class that handles window events, updating entities and lastly rendering. However, unlike in the previous installments, we will have an extra method named . This method handles the user zoom when the event is detected.\n\nBecause I decided on using transparency for the image's background, I had to use the SDL2 image extension library for opening PNG images. In the constructor, the image library is initialized and the image we will use is loaded into memory.\n\nIn past articles when using an image, we loaded the image's pixel data into an , converted it into an , and finally, queried for the texture's width and height. We do the first two here, but not the last. takes care of what part of the image gets rendered onto the screen.\n\nNow finally, I can show the method that makes all the magic happens:\n\nThis merely manipulates the viewports location and dimensions. In the method, we set the viewport and render.\n\nOf course, you can move about and zoom in and out.\n\nNothing is explicitly scheduled for the next post, but you can think it as a surprise."
    }
]