[
    {
        "link": "https://en.cppreference.com/w/cpp/numeric/math/tgamma",
        "document": "If no errors occur, the value of the gamma function of num, that is \\(\\Gamma(\\mathtt{num}) = \\displaystyle\\int_0^\\infty\\!\\! t^{\\mathtt{num}-1} e^{-t}\\, dt\\)∫∞\n\n0tnum-1\n\n e-t dt, is returned.\n\nIf a domain error occurs, an implementation-defined value (NaN where supported) is returned.\n\nIf a pole error occurs, ±HUGE_VAL, , or is returned.\n\nIf a range error due to overflow occurs, ±HUGE_VAL, , or is returned.\n\nIf a range error due to underflow occurs, the correct value (after rounding) is returned.\n\nErrors are reported as specified in math_errhandling.\n\nIf num is zero or is an integer less than zero, a pole error or a domain error may occur.\n• If the argument is ±0, ±∞ is returned and is raised.\n• If the argument is a negative integer, NaN is returned and is raised.\n• If the argument is -∞, NaN is returned and is raised.\n• If the argument is +∞, +∞ is returned.\n• If the argument is NaN, NaN is returned.\n\nIf num is a natural number, std::tgamma(num) is the factorial of num - 1. Many implementations calculate the exact integer-domain factorial if the argument is a sufficiently small integer.\n\nFor IEEE-compatible type double, overflow happens if 0 < num && num < 1 / DBL_MAX or if num > 171.7.\n\nPOSIX requires that a pole error occurs if the argument is zero, but a domain error occurs when the argument is a negative integer. It also specifies that in future, domain errors may be replaced by pole errors for negative integer arguments (in which case the return value in those cases would change from NaN to ±∞).\n\nThere is a non-standard function named in various implementations, but its definition is inconsistent. For example, glibc and 4.2BSD version of executes , but 4.4BSD version of executes .\n\nThe additional overloads are not required to be provided exactly as (A). They only need to be sufficient to ensure that for their argument num of integer type, std::tgamma(num) has the same effect as std::tgamma(static_cast<double>(num))."
    },
    {
        "link": "https://programiz.com/cpp-programming/library-function/cmath/sin",
        "document": "This function is defined in <cmath> header file.\n\nsin() prototype (As of C++ 11 standard)\n\nThe sin() function returns the value in the range of [-1, 1]. The returned value is either in , , or .\n\nNote: To learn more about float and double in C++, visit C++ float and double.\n\nExample 1: How sin() works in C++?\n\nWhen you run the program, the output will be:\n\nWhen you run the program, the output will be:"
    },
    {
        "link": "https://w3schools.com/cpp/cpp_ref_math.asp",
        "document": "The library has many functions that allow you to perform mathematical tasks on numbers.\n\nA list of all math functions can be found in the table below:\n\nLearn more about math in our C++ Math Tutorial."
    },
    {
        "link": "https://cplusplus.com/reference/cmath",
        "document": ""
    },
    {
        "link": "https://en.cppreference.com/w/cpp/numeric/math",
        "document": "next representable floating-point value towards the given value"
    },
    {
        "link": "https://stackoverflow.com/questions/28362197/using-float-double-as-a-loop-variable",
        "document": "You have three problems here (two related), all of which are probably contributing.\n\nThe first is that floating point comparisons are generally unwise since, while you may think you have , it may in fact be .\n\nThe second is that inaccuracies build up over time. Every time you add a number like that you think is , the error accumulates.\n\nWith the values you're using, these errors are likely to stay small but you should be aware of them anyway. If you start processing lots of numbers, you'll find out about the problems pretty quickly.\n\nThe final, and unrelated, problem is that is integer division, and it will give you an integer result, instead of .\n\nYou can fix that final problem by ensuring one of the values is a float:\n\nBut that's not going to fix the first two, which will bite you at some point.\n\nTo fix that, you would be better off sticking with integers (for this simple case anyway) and converting to floating point at the latest possible instance:\n\nwhich gives you:"
    },
    {
        "link": "https://stackoverflow.com/questions/24665459/best-practices-for-floating-point-arithmetics",
        "document": "I was performing addition and subtraction on an input of decimals that are precise to the second decimal place. I tried to improve accuracy by converting them to integers through multiplying 100, but achieved opposite effects.\n\nConsider the following code and output:\n\nOnce and for all, what are some of the best practices regarding floating-point arithmetics? Is it at all feasible to first convert the to an using some variant of the code above, and then casting it back?"
    },
    {
        "link": "https://wiki.sei.cmu.edu/confluence/display/c/FLP30-C.+Do+not+use+floating-point+variables+as+loop+counters",
        "document": "Because floating-point numbers represent real numbers, it is often mistakenly assumed that they can represent any simple fraction exactly. Floating-point numbers are subject to representational limitations just as integers are, and binary floating-point numbers cannot represent all real numbers exactly, even if they can be represented in a small number of decimal digits.\n\nIn addition, because floating-point numbers can represent large values, it is often mistakenly assumed that they can represent all significant digits of those values. To gain a large dynamic range, floating-point numbers maintain a fixed number of precision bits (also called the significand) and an exponent, which limit the number of significant digits they can represent.\n\nDifferent implementations have different precision limitations, and to keep code portable, floating-point variables must not be used as the loop induction variable. See Goldberg's work for an introduction to this topic [Goldberg 1991].\n\nFor the purpose of this rule, a loop counter is an induction variable that is used as an operand of a comparison expression that is used as the controlling expression of a , , or loop. An induction variable is a variable that gets increased or decreased by a fixed amount on every iteration of a loop [Aho 1986]. Furthermore, the change to the variable must occur directly in the loop body (rather than inside a function executed within the loop).\n\nIn this noncompliant code example, a floating-point variable is used as a loop counter. The decimal number is a repeating fraction in binary and cannot be exactly represented as a binary floating-point number. Depending on the implementation, the loop may iterate 9 or 10 times.\n\nFor example, when compiled with GCC or Microsoft Visual Studio 2013 and executed on an x86 processor, the loop is evaluated only nine times.\n\nIn this compliant solution, the loop counter is an integer from which the floating-point value is derived:\n\nIn this noncompliant code example, a floating-point loop counter is incremented by an amount that is too small to change its value given its precision:\n\nOn many implementations, this produces an infinite loop.\n\nIn this compliant solution, the loop counter is an integer from which the floating-point value is derived. The variable is assigned a computed value to reduce compounded rounding errors that are present in the noncompliant code example.\n\nThe use of floating-point variables as loop counters can result in unexpected behavior .\n\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website."
    },
    {
        "link": "https://quora.com/What-is-the-best-way-to-tackle-floating-point-precision-issues-in-C",
        "document": "Something went wrong. Wait a moment and try again."
    },
    {
        "link": "https://codeql.github.com/codeql-query-help/cpp/cpp-loop-variable-float",
        "document": "Click to see the query in the CodeQL repository\n\nThis rule finds variables being used as loop counter. values are prone to rounding and truncation. In particular, very large and very small float values are prone to rounding errors and could lead to unexpected loop behavior.\n\nUse an integral variable instead of a float variable for the loop counter.\n\n//may never terminate, as rounding errors //cancel out the addition of 1.0 once\n• None MISRA C++ Rule 6-5-1, Guidelines for the use of the C++ language in critical systems. The Motor Industry Software Reliability Associate, 2008.\n• None FLP30-C. Do not use floating-point variables as loop counters"
    },
    {
        "link": "https://en.cppreference.com/w/cpp/numeric/math/abs",
        "document": "Computes the absolute value of the integer number num. The behavior is undefined if the result cannot be represented by the return type.\n\nIf is called with an unsigned integral argument that cannot be converted to int by integral promotion, the program is ill-formed.\n\nThe absolute value of num (i.e. ), if it is representable.\n\nIn 2's complement systems, the absolute value of the most-negative value is out of range, e.g. for 32-bit 2's complement type int, INT_MIN is -2147483648, but the would-be result 2147483648 is greater than INT_MAX, which is 2147483647.\n\nThe following behavior-changing defect reports were applied retroactively to previously published C++ standards."
    },
    {
        "link": "https://en.cppreference.com/w/cpp/numeric/math/fabs",
        "document": "Computes the absolute value of the floating-point value . The library provides overloads of and for all cv-unqualified floating-point types as the type of the parameter .\n\nFor integral arguments, the integral overloads of are likely better matches. If is called with an unsigned integral argument that cannot be converted to int by integral promotion, the program is ill-formed.\n\nIf successful, returns the absolute value of arg ( ). The value returned is exact and does not depend on any rounding modes.\n\nThis function is not subject to any of the error conditions specified in math_errhandling.\n• If the argument is ±0, +0 is returned.\n• If the argument is ±∞, +∞ is returned.\n• If the argument is NaN, NaN is returned.\n\nThe additional overloads are not required to be provided exactly as (A). They only need to be sufficient to ensure that for their argument num of integer type, std::fabs(num) has the same effect as std::fabs(static_cast<double>(num)).\n\nThe following behavior-changing defect reports were applied retroactively to previously published C++ standards."
    },
    {
        "link": "https://stackoverflow.com/questions/2878076/what-is-different-about-c-math-h-abs-compared-to-my-abs",
        "document": "I am currently writing some glsl like vector math classes in C++, and I just implemented an function like this:\n\nI compared its speed to the default C++ from like this:\n\nNow the default abs takes about 25ms while mine takes 60. I guess there is some low level optimisation going on. Does anybody know how works internally? The performance difference is nothing dramatic, but I am just curious!"
    },
    {
        "link": "https://geeksforgeeks.org/abs-labs-llabs-functions-cc",
        "document": "The std::abs(), std::labs() and std::llabs() in C++ are built-in functions that are used to find the absolute value of any number that is given as the argument. Absolute value is the value of a number without any sign. These functions are defined inside the <cmath> header file.\n\nIn this article, we will learn how to use std::abs(), std::labs() and std::llabs() in C++.\n\nThe std::abs() in C++ is used to find the absolute value of given number. The value returned by std::abs() function is of type int.\n• num: Number whose absolute value we have to find.\n• None Returns the absolute value of given number as integer.\n\nProblem with Absolute Values in C++\n\nIn C++, integer type ranges from INT_MIN = 2147483647 (considering 32-bit compiler) to INT_MAX = 2147483647. As we can see, converting the INT_MIN to its absolute value will result in a value larger than the max value of the int type. So, it will be returned to its 2’s complement. This happens with every integer type whether it’s a long int or a long long int. So, it is recommended to check for this case when determining the absolute values for ints.\n\nThe std::labs() in C++ is also used to find the absolute value of given number similar to abs() function but it returns the absolute value as long int as compared to int for abs() function.\n• num: Number whose absolute value we have to find.\n• None Returns the absolute value of given number as long integer.\n\nThe std::llabs() in C++ does the same as abs() and labs() function. It returns the absolute value of given number but in the form of long long integer.\n• num: Number whose absolute value we have to find.\n• None Returns the absolute value of given number as long long integer."
    },
    {
        "link": "https://stackoverflow.com/questions/21392627/abs-vs-stdabs-what-does-the-reference-say",
        "document": "Beware, I am talking about , not\n\nAccording to the cplusplus.com website, is supposed to behave differently for the h C version, if you include\n\nHere is an extract from the this page (which deals with , not ):\n\nI have been bitten by this when porting a program to a new platform, since different compilers and standard libraries implementation differ here.\n\nHere is my sample program:\n\nAnd here is the result under MSVC 2010:\n• No compilation warning is emitted under MSVC 2010, and the program will compile even if you do not include neither math.h nor : it seems like and are always included whatever you do\n• The program output is: (seemingly correct according to the reference)\n\nNow here is the result under OSX:\n• No compilation warning is emitted, even with the flag (the double to int cast is not signaled)! The result is the same if you replace by . The inclusion of or is not required for the compilation.\n\nAnd finally the result under Linux:\n• The program will not compile if is not included (at last, one compiler that does not include automatically). No compilation warning is emitted for the double -> int cast.\n\nNo clear winner here. I know that an obvious answer is \"prefer to \", but I wonder:\n• Is the cplusplus.com website right here when it says that should automatically provide double version outside of the namespace?\n• Are all compiler and their standard libraries wrong here except MSVC (although it includes silently)?"
    }
]