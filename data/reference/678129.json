[
    {
        "link": "https://stackoverflow.com/questions/11516657/c-structure-initialization",
        "document": "Is it possible to initialize structs in C++ as indicated below:\n\nThe links here and here mention that it is possible to use this style only in C. If so why is this not possible in C++? Is there any underlying technical reason why it is not implemented in C++, or is it bad practice to use this style. I like using this way of initializing because my struct is big and this style gives me clear readability of what value is assigned to which member.\n\nPlease share with me if there are other ways through which we can achieve the same readability.\n\nI have referred the following links before posting this question:\n• Static structure initialization with tags in C++"
    },
    {
        "link": "https://stackoverflow.com/questions/6181715/convenient-c-struct-initialisation",
        "document": "I'm trying to find a convenient way to initialise 'pod' C++ structs. Now, consider the following struct:\n\nIf I want to conveniently initialise this in C (!), I could simply write:\n\nNote that I want to explicitly avoid the following notation, because it strikes me as being made to break my neck if I change anything in the struct in the future:\n\nTo achieve the same (or at least similar) in C++ as in the example, I would have to implement an annoying constructor:\n\nWhich feels redundant and unnecessary. Also, it is pretty much as bad as the example, as it does not explicitly state which value goes to which member.\n\nSo, my question is basically how I can achieve something similar to or better in C++? Alternatively, I would be okay with an explanation why I should not want to do this (i.e. why my mental paradigm is bad).\n\nBy convenient, I mean also maintainable and non-redundant."
    },
    {
        "link": "https://en.cppreference.com/w/c/language/struct_initialization",
        "document": "When initializing an object of struct or union type, the initializer must be a non-empty,(until C23) brace-enclosed, comma-separated list of initializers for the members:\n\nwhere the designator is a sequence (whitespace-separated or adjacent) of individual member designators of the form member and array designators of the form index .\n\nAll members that are not initialized explicitly are empty-initialized.\n\nWhen initializing a union, the initializer list must have only one member, which initializes the first member of the union unless a designated initializer is used(since C99).\n\nWhen initializing a struct, the first initializer in the list initializes the first declared member (unless a designator is specified)(since C99), and all subsequent initializers without designators (since C99)initialize the struct members declared after the one initialized by the previous expression.\n\nIt's an error to provide more initializers than members.\n\nIf the members of the struct or union are arrays, structs, or unions, the corresponding initializers in the brace-enclosed list of initializers are any initializers that are valid for those members, except that their braces may be omitted as follows:\n\nIf the nested initializer begins with an opening brace, the entire nested initializer up to its closing brace initializes the corresponding member object. Each left opening brace establishes a new current object. The members of the current object are initialized in their natural order, unless designators are used(since C99): array elements in subscript order, struct members in declaration order, only the first declared member of any union. The subobjects within the current object that are not explicitly initialized by the closing brace are empty-initialized.\n\nIf the nested initializer does not begin with an opening brace, only enough initializers from the list are taken to account for the elements or members of the member array, struct or union; any remaining initializers are left to initialize the next struct member:\n\nWhen designators are nested, the designators for the members follow the designators for the enclosing structs/unions/arrays. Within any nested bracketed initializer list, the outermost designator refers to the current object and selects the subobject to be initialized within the current object only. example ex2 // current object is ex2, designators are for members of example . . , , , , . example ex3 , . // changes current object to the union ex.in_u , . // this designator refers to the member of in_u If any subobject is explicitly initialized twice (which may happen when designators are used), the initializer that appears later in the list is the one used (the earlier initializer may not be evaluated): n s , // this may be printed or skipped . Although any non-initialized subobjects are initialized implicitly, implicit initialization of a subobject never overrides explicit initialization of the same subobject if it appeared earlier in the initializer list (choose clang to observe the correct output): k l a T i T t S T x . , . , . , . main S l , . x, . . , . . , l. . // .t.l = 41 would zero out l.t.k implicitly However, when an initializer begins with a left open brace, its current object is fully re-initialized and any prior explicit initializers for any of its subobjects are ignored: fred s n fred x , , . fred y , , // current object is now the entire y[0] object .\n\nThe initializer list may have a trailing comma, which is ignored.\n\nEvery expression in the initializer list must be a constant expression when initializing aggregates of any storage duration. As with all other initialization, every expression in the initializer list must be a constant expression when initializing aggregates of static or thread-local(since C11) storage duration: The order of evaluation of the subexpressions in any initializer is indeterminately sequenced (but not in C++ since C++11): n x,y p n , n // n is incremented twice in arbitrary order // p equal {1,2} and {2,1} are both valid"
    },
    {
        "link": "https://w3schools.com/cpp/cpp_structs.asp",
        "document": "Structures (also called structs) are a way to group several related variables into one place. Each variable in the structure is known as a member of the structure.\n\nUnlike an array, a structure can contain many different data types (int, string, bool, etc.).\n\nTo create a structure, use the keyword and declare each of its members inside curly braces.\n\nAfter the declaration, specify the name of the structure variable (myStructure in the example below):\n\nTo access members of a structure, use the dot syntax ( ):\n\nYou can use a comma ( ) to use one structure in many variables:\n\nThis example shows how to use a structure in two different variables:\n\nBy giving a name to the structure, you can treat it as a data type. This means that you can create variables with this structure anywhere in the program at any time.\n\nTo create a named structure, put the name of the structure right after the keyword:\n\nTo declare a variable that uses the structure, use the name of the structure as the data type of the variable:\n\nUse one structure to represent two cars: // Declare a structure named \"car\"\n\n struct car {\n\n string brand;\n\n string model;\n\n int year;\n\n };\n\n \n\n int main() {\n\n // Create a car structure and store it in myCar1;\n\n car myCar1; \n\n myCar1.brand = \"BMW\";\n\n myCar1.model = \"X5\";\n\n myCar1.year = 1999;\n\n \n\n // Create another car structure and store it in myCar2;\n\n car myCar2;\n\n myCar2.brand = \"Ford\";\n\n myCar2.model = \"Mustang\";\n\n myCar2.year = 1969;\n\n \n\n // Print the structure members\n\n cout << myCar1.brand << \" \" << myCar1.model << \" \" << myCar1.year << \"\n\n\";\n\n cout << myCar2.brand << \" \" << myCar2.model << \" \" << myCar2.year << \"\n\n\";\n\n \n\n return 0;\n\n } Try it Yourself »"
    },
    {
        "link": "https://geeksforgeeks.org/structures-in-cpp",
        "document": "C++ Structures are user defined data types which are used to store group of items of different data types. A structure creates a data type that can be used to group items of possibly different types into a single type.\n\nBefore using structure, we have to first define the structure. The struct keyword is used to define a structure as shown:\n\nwhere structure name is name and mem1, mem2 and mem3 are the items it groups. They are also called its members or fields.\n\nThe above is also called Structure Definition. It is not allocated any memory and cannot be used in the program directly. We have to create its variables to use it.\n\nOnce the structure is defined, its variable can be created in a similar way as basic data type variables.\n\nwhere struct_name is the name of the structure and var_name is the name of the variable.\n\nA variable can also be declared with the definition of the structure:\n\nStructure members cannot be initialized with declaration. For example, the following C++ program fails in compilation.\n\nStructure members can be initialized to values provided in the curly braces ‘{}’. For example,\n\nThe values provided in the curly braces {} are sequentially assigned to the members of the structure. In the above example, 0 is assigned to member x, and 1 is assigned to member y.\n\nSince C++ 20, we can also use Designated Initializers to initialize the structure members.\n\nStructure members are accessed using dot operator (.) as shown:\n\nwhere var_name is structure variable and member_name is the name of the structure member. A new value to this member can also be assigned using assignment operator.\n\nThe new value should be of the same type to avoid type mismatch error.\n\nIn C structures, functions were not allowed inside the structure but in C++, we can declare the function inside the structure. They are called member functions while the variables are called data members. C++ structure is way more similar to C++ classes as compared to C structures.\n\nC++ structures also support other class components such as constructor, destructor, access specifiers, etc.\n\nThe size of a structure is determined by the sum of the sizes of its individual data members, with additional padding added by the compiler to ensure proper memory alignment.\n\nIdeally, the size should be the size of all data members i.e. sizeof(char) + 2 * sizeof(int) = 1 + 8 = 9 bytes. But the size comes out to be 12 bytes. This is due to the mentioned structure padding.\n\nIn C++, typedef is used to create an alias for an existing variable. Similarly, with structures, typedef creates an alias for the original name of the structure.\n\nNested structure in C++ refers to a structure that is defined inside another structure. Just as structure members are declared within a structure, one structure can be declared as a member inside another structure.\n\nNotice how there are one more curly braces added in the initialization. This is to initialize the inner structure.\n\nThe inner structure can also be defined directly inside the outer structure even without naming the structure and just by creating a variable name.\n\nIn C++, a pointer to a structure is also known as a structure pointer. It is a pointer that holds the address of the memory location where the structure is stored. The normal way to access structure members is to first dereference the pointer and then use dot operator, but C++ provides –> arrow operator to directly access structure members using pointer to it.\n\nSelf-referential structures are those structures that contains the pointer to the same type as a member. For example,\n\nSuch kind of structures are used in data structures such as linked list, trees, etc.\n\nStructures work similarly like other variables with functions. We can pass a structure to a function or return a structure from a function, just like with other variables. Additionally, we can pass a structure either by value or by reference. However, the recommended approach is to pass a structure by reference, as making a copy of a structure is a costly operation.\n\nStructures are also used return multiple values from the function. Refer to the article to know more – Structure with Functions\n\nBit fields in structures allows us to define the number of bits that a particular data member will occupy. Basically, it specifies the manual size of the structure member in bits. It is useful in memory critical applications such as embedded systems.\n\nIn C++, a structure works similarly to a class, but there are some key differences in between of them. The important difference is how implementation details are handled.\n\nHow is a structure different from a class in C++?\n\nCan a structure have functions in C++?\n\nCan we assign one structure variable to another in C++?\n\nWhat is a structure tag in C++?\n\nHow do you access members of a structure in C++?"
    },
    {
        "link": "https://cplusplus.com/doc/tutorial/basic_io",
        "document": "std; main () { i; cout << \"Please enter an integer value: \" ; cin >> i; cout << \"The value you entered is \" << i; cout << \" and its double is \" << i*2 << ; 0; }\n\nPlease enter an integer value: 702 The value you entered is 702 and its double is 1404."
    },
    {
        "link": "https://en.cppreference.com/w/cpp/io",
        "document": "C++ includes the following input/output libraries: an OOP-style stream-based I/O library, print-based family of functions(since C++23), and the standard set of C-style I/O functions.\n\nThe stream-based input/output library is organized around abstract input/output devices. These abstract devices allow the same code to handle input/output to files, memory streams, or custom adaptor devices that perform arbitrary operations (e.g. compression) on the fly.\n\nMost of the classes are templated, so they can be adapted to any basic character type. Separate typedefs are provided for the most common basic character types (char and wchar_t). The classes are organized into the following hierarchy:\n\nThe following typedefs for common character types are provided in namespace :\n\nThe stream-based I/O library uses I/O manipulators (e.g. std::boolalpha, std::hex, etc.) to control how streams behave.\n\nThe following auxiliary types are defined:\n\nThe following typedef names for std::fpos<std::mbstate_t> are provided:\n\nThe Unicode-aware print-family functions that perform formatted I/O on text that is already formatted. They bring all the performance benefits of std::format, are locale-independent by default, reduce global state, avoid allocating a temporary std::string object and calling operator<<, and in general make formatting more efficient compared to iostreams and stdio.\n\nThe following print-like functions are provided:\n\nC++ also includes the input/output functions defined by C, such as std::fopen, std::getc, etc."
    },
    {
        "link": "https://cplusplus.com/reference/string/string",
        "document": ""
    },
    {
        "link": "https://devdocs.io/cpp",
        "document": ""
    },
    {
        "link": "https://geeksforgeeks.org/basic-input-output-c",
        "document": "In C++, input and output are performed in the form of a sequence of bytes or more commonly known as streams.\n• Input Stream: If the direction of flow of bytes is from the device (for example, Keyboard) to the main memory then this process is called input.\n• Output Stream: If the direction of flow of bytes is opposite, i.e. from main memory to device (display screen) then this process is called output.\n\nAll of these streams are defined inside the <iostream> header file which contains all the standard input and output tools of C++. The two instances cout and cin of iostream class are used very often for printing outputs and taking inputs respectively. These two are the most basic methods of taking input and printing output in C++.\n\nThe C++ cout is the instance of the ostream class used to produce output on the standard output device which is usually the display screen. The data needed to be displayed on the screen is inserted in the standard output stream (cout) using the insertion operator(<<).\n\nFor example, if we want to print text “GeeksforGeeks” on the display, we can use the cout as shown:\n\nExplanation: In the above program, cout is used to output the text “GeeksforGeeks” to the standard output stream. It works in conjunction with the insertion operator (<<) to send the specified data to the output stream.\n\nWe can also print the variable values using cout.\n\nUnderstanding input and output operations is essential for any C++ programmer. The C++ Course includes comprehensive lessons on basic I/O operations, ensuring you can manage user interaction in your programs.\n\nThe C++ cin statement is the instance of the class istream and is used to read input from the standard input device which is usually a keyboard. The extraction operator (>>) is used along with the object cin for extracting the data from the input stream and store it in some variable in the program.\n\nFor example, if we want to ask user for his/her age, then we can use cin as shown:\n\nExplanation: The above program asks the user to input the age. The object cin is connected to the input device (keyboard). The age entered by the user is extracted from cin using the extraction operator(>>) and the extracted data is then stored in the variable age present on the right side of the extraction operator.\n\nAlso, while taking text as input using cin, we need to remember that cin stops reading input as soon as it encounters a whitespace (space, tab, or newline). This means it only captures the first word or characters until the first whitespace. It is shown in the below example:\n\nThe C++ cerr is the standard error stream that is used to output the errors. This is also an instance of the iostream class. As cerr in C++ is un-buffered so it is used when one needs to display the error message immediately. It does not have any buffer to store the error message and display it later.\n\nThe main difference between cerr and cout comes when you would like to redirect output using “cout” that gets redirected to file if you use “cerr” the error doesn’t get stored in file.(This is what un-buffered means ..It cant store the message)\n\nThis is also an instance of ostream class and used to display errors but unlike cerr the error is first inserted into a buffer and is stored in the buffer until it is not fully filled. or the buffer is not explicitly flushed (using flush()). The error message will be displayed on the screen too."
    }
]