[
    {
        "link": "https://docs.python.org/3/tutorial/controlflow.html",
        "document": ""
    },
    {
        "link": "https://realpython.com/python-for-loop",
        "document": "Python’s loop allows you to iterate over the items in a collection, such as lists, tuples, strings, and dictionaries. The loop syntax declares a loop variable that takes each item from the collection in each iteration. This loop is ideal for repeatedly executing a block of code on each item in the collection. You can also tweak loops further with features like , , and .\n\nBy the end of this tutorial, you’ll understand that:\n• Python’s loop iterates over items in a data collection, allowing you to execute code for each item.\n• To iterate from to , you use the construct.\n• To repeat code a number of times without processing the data of an iterable, use the construct.\n• To do index-based iteration, you can use for index, value in enumerate(iterable): to access both index and item.\n\nIn this tutorial, you’ll gain practical knowledge of using loops to traverse various collections and learn Pythonic looping techniques. Additionally, you’ll learn how to handle exceptions and how to use asynchronous iterations to make your Python code more robust and efficient.\n\nGetting Started With the Python Loop In programming, loops are control flow statements that allow you to repeat a given set of operations a number of times. In practice, you’ll find two main types of loops:\n• loops are mostly used to iterate a known number of times, which is common when you’re processing data collections with a specific number of data items.\n• loops are commonly used to iterate an unknown number of times, which is useful when the number of iterations depends on a given condition. Python has both of these loops and in this tutorial, you’ll learn about loops. In Python, you’ll generally use loops when you need to iterate over the items in a data collection. This type of loop lets you traverse different data collections and run a specific group of statements on or with each item in the input collection. In Python, loops are compound statements with a header and a code block that runs a predefined number of times. The basic syntax of a loop is shown below: In this syntax, is the loop variable. In each iteration, this variable takes the value of the current item in , which represents the data collection you need to iterate over. The loop body can consist of one or more statements that must be indented properly. Here’s a more detailed breakdown of this syntax:\n• is the keyword that initiates the loop header.\n• is a variable that holds the current item in the input iterable.\n• is a keyword that connects the loop variable with the iterable.\n• is a data collection that can be iterated over.\n• consists of one or more statements to execute in each iteration. Here’s a quick example of how you can use a loop to iterate over a list: In this example, is the loop variable, while the list is the target collection. Each time through the loop, takes on a successive item from . In this loop, the body consists of a call to that displays the value on the screen. This loop runs once for each item in the target iterable. The way the code above is written is the Pythonic way to write it. However, what’s an iterable anyway? In Python, an iterable is an object—often a data collection—that can be iterated over. Common examples of iterables in Python include lists, tuples, strings, dictionaries, and sets, which are all built-in data types. You can also have custom classes that support iteration. Note: Python has both iterables and iterators. Iterables support the iterable protocol consisting of the special method. Similarly, iterators support the iterator protocol that’s based on the and special methods. Both iterables and iterators can be iterated over. All iterators are iterables, but not all iterables are iterators. Python iterators play a fundamental role in loops because they drive the iteration process. A deeper discussion on iterables and iterators is beyond the scope of this tutorial. However, to learn more about them, check out the Iterators and Iterables in Python: Run Efficient Iterations tutorial. You can also have a loop with multiple loop variables: In this loop, you have two loop variables, and . Note that to use this syntax, you just need to provide a tuple of loop variables. Also, you can have as many loop variables as you need as long as you have the correct number of items to unpack into them. You’ll also find this pattern useful when iterating over dictionary items or when you need to do parallel iteration. Sometimes, the input iterable may be empty. In that case, the loop will run its header once but won’t execute its body: In this example, the target iterable is an empty list. The loop checks whether the iterable has items. If that’s the case, then the loop runs once for each item. If the iterable has no items, then the loop body doesn’t run, and the program’s execution flow jumps onto the statement after the loop. Now that you know the basic syntax of loops, it’s time to dive into some practical examples. In the following section, you’ll learn how to use loops with the most common built-in data collections in Python.\n\nWhen writing Python code, you’ll often need to iterate over built-in data types such as lists, tuples, strings, numeric ranges, dictionaries, and sets. All of them support iteration, and you can feed them into a loop. In the next sections, you’ll learn how to tackle this requirement in a Pythonic way. When it comes to iterating over sequence data types like lists, tuples, strings, and ranges, the iteration happens in the same order that the items appear in the sequence. Consider the following example where you iterate over the numbers in a list: In this example, the iteration goes through the list in the definition order, starting with and ending with . Note that to iterate over a sequence in Python, you don’t need to be aware of the index of each item as in other languages where loops often rely on indices. Often, you use plural nouns to name lists. This naming practice allows you to use singular nouns as the loop variable, making your code descriptive and readable. Note: To learn more about using lists, check out Python’s Data Type: A Deep Dive With Examples. You’ll note the same behavior with other built-in sequences: In these examples, you iterate over a tuple, string, and numeric range. Again, the loop traverses the sequence in the order of definition. Note: For more information about tuples, strings, and ranges, you can check out the following tutorials: Tuples are often used to represent rows of data. In the example above, the tuple holds data about a person. You can iterate over each field using a readable loop. When it comes to iterating over string objects, the loop lets you process the string on a character-by-character basis. Finally, iterating over a numeric range is sometimes a requirement, especially when you need to iterate a given number of times and need control over the consecutive index. When traversing dictionaries with a loop, you’ll find that you can iterate over the keys, values, and items of the dictionary at hand. Note: To learn more about dictionary iteration, check out the How to Iterate Through a Dictionary in Python tutorial. You’ll have two different ways to iterate over the keys of a dictionary. You can either use: The following examples show how to use these two approaches: In these examples, you first iterate over the keys of a dictionary using the dictionary directly in the loop header. In the second loop, you use the method to iterate over the keys. While both approaches are equivalent, the first one is more commonly used, whereas the second might be more readable and explicit. In both loops, you can access the dictionary values using the keys: To access the values in this type of iteration, you can use the original dictionary and a key lookup operation, as shown in the highlighted line. You can use the method to feed the loop when you need to iterate over the values of a dictionary: The method lets you traverse the values in the target dictionary. In this example, you iterate over team names one by one. Note that when you use the method, you can’t access the dictionary keys. Finally, iterating over both keys and values in a Python dictionary is a common requirement. In this case, the recommended and most Pythonic approach is to use the method in a loop like the following: When iterating over keys and values this way, you typically use a tuple of loop variables. The first variable will get the key, while the second will get the associated value. In this example, you have the and variables, which make the code clear and readable. When it comes to iterating over sets, you only have to keep in mind that sets are unordered data types. This means that looping in order isn’t guaranteed: As you can see, the loop goes through the elements of your set in a different order than they were inserted. So, you can’t rely on the order of the elements when traversing sets in Python.\n\nThe Python loop has some advanced features that make it flexible and powerful. These features can be helpful when you need to fine-tune the loop to meet specific execution flows. These features include the and statements and the clause, which you’ll learn about in the following sections. You’ll also learn that loops can be nested inside one another. This feature can be pretty useful in situations where you need to iterate over nested data structures like lists of lists. The statement immediately exits the loop and jumps to the first statement after the loop. For example, say that you want to write a loop to determine whether a number is in a list. To avoid unnecessary work, the loop should terminate once it finds the target value. You can do this with the statement: In this example, the statement jumps out of the loop as soon as the target number is found. The remaining values, and , aren’t processed. You can think of the statement as a way to short-circuit the loop execution once you’ve gotten the desired result. It’s important to note that it makes little sense to have statements outside conditionals. Suppose you include a statement directly in the loop body without wrapping it in a conditional. In that case, the loop will terminate in the first iteration, potentially without running the entire loop body. The statement terminates the current iteration and proceeds to the next one. For example, if you have a list of numbers and only want to process the even ones, you can use a statement to skip the odd numbers: In this example, the code that processes the numbers is only reached if the number is even. Otherwise, the statement skips that code and jumps right into the next iteration. Again, it doesn’t make much sense to have a statement without wrapping it in a conditional. If you do so, the code after the statement will be unreachable and never run. In Python, loops can have an clause at the end. The clause will only run if the loop terminates because of the exhaustion of the input iterable. This feature is useful when you have a statement that can terminate the loop in certain situations. If the loop doesn’t break, then you can run additional code in the clause. To illustrate, say that you want to continue improving the loop that determines whether a number is in a list. You’d like to explicitly inform the user if the number isn’t in the list. You can do this with the clause: The clause won’t run if the loop breaks out with the statement. It only runs if the loop terminates normally, allowing you to inform the user that the target number wasn’t found. It doesn’t make sense to have an clause in a loop that doesn’t have a statement. In that case, placing the block’s content after the loop—without indentation—will work the same and be cleaner. You can also have nested loops. In the example below, you create a multiplication table that shows the products of all combinations of integers up to ten using nested loops. The outer loop iterates over the numbers between and , and the inner loop calculates and prints the products: In this example, you use two nested loops. Together, they create a two-dimensional multiplication table. First, you loop over the numbers from one up to and including ten. These represent the rows in the table, and you can see those numbers at the beginning of each row. In the inner loop, you calculate the products for the current by iterating from the itself up to its tenth multiple. Then, you format each product using the format specifier. This ensures the table is nicely aligned. By setting to an empty string, you skip the newline until the products on the current row are printed. After printing all products for a row, you use without arguments to move to the next row.\n\nWhen people switch from other programming languages to Python, they often write loops like they did in their previous language. This practice makes Python code look odd and hard to read. In the following sections, you’ll explore some looping techniques, practices, and tips that are considered Pythonic. These techniques can make your Python code look clearer, more elegant, and more efficient. Iterating With Indices: The Pythonic Way Sometimes, you need to use the indices of items when you iterate over a sequence with a Python loop. Up to this point, you’ve seen examples where you can access the items but don’t know their corresponding indices. To get both the item and its index, you can end up writing a loop like the one shown in the following example: This loop gets the job done, but it’s not as clean or readable as you’d expect from Python code. Fortunately, there’s a better way—the built-in function: The function takes an iterable as an argument and generates tuples of the form . Note that the loop reads almost like plain English, which makes your code way more Pythonic than the previous version using . Note: To learn more about working with , check out the Python : Simplify Loops That Need Counters tutorial. The function also takes an optional argument called that lets you tweak the initial value. This feature is useful when you need to create counts. Consider the following example that mimics an option menu for a command-line application: In this example, instead of using to produce zero-based indices, you start the count at . From the end user’s perspective, starting the menu at is the natural way to go. Looping Over Several Iterables in Parallel Looping through two or more iterables in parallel may be another common task you encounter in Python programming. To do this, you can use the built-in function, which takes two or more iterables and yields tuples that combine items from each iterable. Note: To learn more about , check out the Using the Python zip() Function for Parallel Iteration tutorial. Consider the following toy example: In this example, you use to create an iterator that produces tuples of the form . In this case, the values are taken from , and the values are taken from . There may be times when you need to iterate over multiple iterables sequentially in a single loop. In such cases, you can use the function from Python’s module. Note: To learn more about the module and the tools it provides, check out the Python By Example tutorial. For example, say that you have several lists of numbers and want to calculate the square of each number in all lists. You can use as follows: This loops over all three lists in sequence and prints the square of each value. You can also use to work through a list of lists. Say that you, again, need to process each value in a sequence and calculate its square: In this example, you use to iterate over the rows of the matrix. To feed the rows into , you use the unpacking operator ( ). Inside the loop, you calculate and print the square of each value. Using , like in this example, essentially flattens the matrix into a single iterable, helping you avoid a nested loop, which can be difficult to read and understand in some contexts. Iteration is all about repeating some fragment of code multiple times. As you’ve learned so far, loops are designed to repeat a given set of actions on the items of an iterable. However, you can also use this type of loop to quickly iterate a specific number of times. This is useful when you need to repeat a bunch of statements, but they don’t operate on the items of an iterable. Here’s a fun example about Penny and Sheldon to illustrate this: This loop runs three times and repeats a series of statements that don’t operate on any iterable. Note that the loop variable is a single underscore character in this example. This variable name communicates that you don’t need to use the loop variable inside the loop. It’s a throwaway variable. With this looping construct that takes advantage of , you have full control over the number of times your code runs. Iterating over the items of an iterable in reverse or sorted order is also a common requirement in programming. To achieve this, you can combine a loop with the built-in or function, respectively. Note: To learn more about and , check out the following tutorials:\n• Reverse Strings in Python: , Slicing, and More\n• How to Use and in Python For example, say that you’re working on a text editor and want to implement a basic Undo option. You can implement it with the function and a loop like the following: In this example, you have a list of hypothetical user actions in a text editor. The actions are stored in a list from oldest to newest. To implement the Undo operation, you need to reverse the actions, which you do with . To iterate in sorted order, say that you have a dictionary that maps student names to their corresponding average grades. You need to create a quick report and want to sort the data from highest to lowest grades. For this, you can do something like the following: The function returns a list of sorted values. In this example, you sort the dictionary by its values in ascending order. To do this, you use a function that takes a two-value tuple as an argument and returns the second item, which has an index of . You also set the argument to so that the function stores the data in reverse order. In this case, this means that the grades are ordered in descending order. The loop iterates over the sorted data and generates a nicely formatted report using an f-string with a custom format specifier.\n\nWhen working with loops in your Python code, you may encounter some issues related to incorrect ways to use this tool. Some of the most common bad practices and incorrect assumptions include:\n• Modifying the loop collection or iterable during iteration\n• Changing the loop variable to affect the underlying collection\n• Ignoring possible exceptions that may occur In the following sections, you’ll explore these pitfalls and how to avoid them in your loops. Python has mutable collections, such as lists and dictionaries, that you can modify in place. You may want to change a list while looping over it. In this situation, you need to distinguish between safe and unsafe changes. For example, say that you have a list of names and want to convert them into uppercase. You may think of doing something like the following: In this example, you only change the existing items in the list without adding or removing any. This operation is safe. However, modifying a mutable iterable like a list while iterating over it always raises a warning. Issues may appear when you add or remove items from a list while iterating over it. To understand why this is best avoided, say that you want to remove all the even numbers from a list. You might write the following code: After running the loop, some even numbers remain, even though you expected the list to be empty. On the first iteration, is removed, and the list shifts left, becoming . The loop then jumps to the next item, skipping and processing instead. Then is removed, and the list shifts again, becoming . The iteration ends before reaching . When you need to resize a list during iteration like in the example above, it’s recommended to create a copy of the list: The slicing operator ( ) with no indices creates a copy of the original list for iteration purposes. The loop traverses the copy while removing values from the original list. In some cases, creating a copy of the input list isn’t enough. Say that on top of removing even numbers, you want to calculate the square of odd numbers. You might modify the previous loop as shown in the following code: This time, you use to generate index-item pairs. Then, you think of using the index to update the value of a given item. However, the code fails with a exception. Creating a copy of the input list isn’t enough in this case. You’d have to make a separate list to store the result: In this new loop implementation, you’re using a new list to store the result. Because of this, you don’t have to remove items anymore. You add the square values to the end of the new list using the method. Python doesn’t allow you to add or remove items from a dictionary while you’re iterating through it: If you try to expand or shrink a dictionary during iteration, you get a exception. Again, you can work around this by creating a copy of the dictionary using the method or by building a new dictionary with the resulting data. Changing the loop variable in the loop body doesn’t have an effect on the original data: In this example, the highlighted line changes the loop variable, . This change doesn’t affect the original data in your list of names. The loop variable is just a temporary reference to the current item in the iterable, and reassigning it doesn’t affect the loop iterable. If an exception occurs in a loop body and isn’t handled, the loop will terminate prematurely, skipping subsequent iterations. This result can generate unexpected issues, especially when you rely on the loop to process data, perform logging, or run cleanup actions in each iteration. As an example, say that you want to process some text files in a loop: : [Errno 2] No such file or directory: 'file1.txt' In this example, none of the files exist in your working directory. The loop tries to process the first file and fails with a exception. Because the exception wasn’t handled properly, the loop terminates in the first iteration, skipping the rest of the files in the list. To avoid this behavior, you need to catch and handle the exception: In this new implementation, the loop catches any exception and prints an error message to the screen. The loop runs entirely without abrupt interruptions."
    },
    {
        "link": "https://geeksforgeeks.org/python-for-loops",
        "document": "Python For Loops are used for iterating over a sequence like lists, tuples, strings, and ranges.\n• None For loop allows you to apply the same operation to every item within loop.\n• None Using For Loop avoid the need of manually managing the index.\n• None For loop can iterate over any iterable object, such as dictionary, list or any custom iterators.\n\nNote: In Python, for loops only implement the collection-based iteration.\n\nThis code uses a for loop to iterate over a string and print each character on a new line. The loop assigns each character to the variable i and continues until all characters in the string have been processed.\n\nUsing range() with For Loop\n\nThe range() function is commonly used with for loops to generate a sequence of numbers. It can take one, two, or three arguments:\n• range(start, stop, step): Generates numbers from start to stop-1, incrementing by step.\n\nLoop control statements change execution from their normal sequence. When execution leaves a scope, all automatic objects that were created in that scope are destroyed. Python supports the following control statements.\n\nPython continue Statement returns the control to the beginning of the loop.\n\nPython break statement brings control out of the loop.\n\nThe pass statement to write empty loops. Pass is also used for empty control statements, functions, and classes.\n\nElse Statement with For Loops\n\nPython also allows us to use the else condition for loops. The else block just after for/while is executed only when the loop is NOT terminated by a break statement.\n\nUsing Enumerate with for loop\n\nIn Python, enumerate() function is used with the for loop to iterate over an iterable while also keeping track of index of each item.\n\nThis code uses nested for loops to iterate over two ranges of numbers (1 to 3 inclusive) and prints the value of i and j for each combination of these two loops. \\\n\nThe inner loop is executed for each value of i in outer loop. The output of this code will print the numbers from 1 to 3 three times, as each value of i is combined with each value of j.\n\nBelow are two Exercise Questions on Python for-loops. We have covered continue statement and range() function in these exercise questions.\n\nWhat is syntax of for loop in Python?\n\nHow to iterate with an index in a for loop in Python?\n\nCan you provide examples of for loops in Python?\n\nSure! Here are some examples of for loops in Python: # Example 1: Iterating over a list fruits = ['apple', 'banana', 'cherry'] for fruit in fruits: print(fruit) # Example 2: Iterating over a string for char in 'Python': print(char) # Example 3: Using enumerate to get index and value for index, num in enumerate([10, 20, 30]): print(f'Index {index}: {num}') # Example 4: Iterating over a dictionary person = {'name': 'John', 'age': 30} for key, value in person.items(): print(f'{key}: {value}')\n\nHow to write a for loop in Python?\n\nHow to use for loops in Python?"
    },
    {
        "link": "https://wiki.python.org/moin/ForLoop",
        "document": "There are two ways to create loops in Python: with the for-loop and the while-loop.\n\nWhen do I use for loops\n\nfor loops are used when you have a block of code which you want to repeat a fixed number of times. The for-loop is always used in combination with an iterable object, like a list or a range. The Python for statement iterates over the members of a sequence in order, executing the block each time. Contrast the for statement with the ''while'' loop, used when a condition needs to be checked each iteration or to repeat a block of code forever. For example:\n\nFor loop from 0 to 2, therefore running 3 times.\n\nWhile loop from 1 to infinity, therefore running forever.\n\nWhen running the above example, you can stop the program by pressing ctrl+c at the same time. As you can see, these loop constructs serve different purposes. The for loop runs for a fixed amount of times, while the while loop runs until the loop condition changes. In this example, the condition is the boolean True which will never change, so it will run forever.\n\nHow do they work?\n\nIf you've done any programming before, you have undoubtedly come across a for loop or an equivalent to it. Many languages have conditions in the syntax of their for loop, such as a relational expression to determine if the loop is done, and an increment expression to determine the next loop value. In Python, this is controlled instead by generating the appropriate sequence. Basically, any object with an iterable method can be used in a for loop. Even strings, despite not having an iterable method - but we'll not get on to that here. Having an iterable method basically means that the data can be presented in list form, where there are multiple values in an orderly fashion. You can define your own iterables by creating an object with next() and iter() methods. This means that you'll rarely be dealing with raw numbers when it comes to for loops in Python - great for just about anyone!\n\nWhen you have a block of code you want to run x number of times, then a block of code within that code which you want to run y number of times, you use what is known as a \"nested loop\". In Python, these are heavily used whenever someone has a list of lists - an iterable object within an iterable object.\n\nLike the while loop, the for loop can be made to exit before the given object is finished. This is done using the break statement, which will immediately drop out of the loop and continue execution at the first statement after the block. You can also have an optional else clause, which will run should the for loop exit cleanly - that is, without breaking.\n\nYour own range generator using yield\n\nThe ''range'' function is seen so often in for statements that you might think range is part of the for syntax. It is not: it is a Python built-in function that returns a sequence following a specific pattern (most often sequential integers), which thus meets the requirement of providing a sequence for the for statement to iterate over. Since for can operate directly on sequences, there is often no need to count. This is a common beginner construct (if they are coming from another language with different loop syntax):\n\nIt can be replaced with this:\n\nConsider to be a flag for possibly non-optimal Python coding.\n\nIf you'd like to learn more, try these links:\n• None Python for loop and while loop tutorial with interactive code examples"
    },
    {
        "link": "https://freecodecamp.org/news/python-for-loop-for-i-in-range-example",
        "document": "Loops are one of the main control structures in any programming language, and Python is no different.\n\nIn this article, we will look at a couple of examples using loops with Python's function.\n\nHere's an Interactive Scrim of a Python For Loop\n\nloops repeat a portion of code for a set of values.\n\nAs discussed in Python's documentation, loops work slightly differently than they do in languages such as JavaScript or C.\n\nA loop sets the iterator variable to each value in a provided list, array, or string and repeats the code in the body of the loop for each value of the iterator variable.\n\nIn the example below, we use a loop to print every number in our array.\n\nWe can include more complex logic in the body of a loop as well. In this example we print the result of a small computation based on the value of our iterator variable.\n\nWhen the values in the array for our loop are sequential, we can use Python's function instead of writing out the contents of our array.\n\nThe function provides a sequence of integers based upon the function's arguments. Additional information can be found in Python's documentation for the function.\n\nThe argument is the first value in the range. If is called with only one argument, then Python assumes .\n\nThe argument is the upper bound of the range. It is important to realize that this upper value is not included in the range.\n\nIn the example below, we have a range starting at the default value of and including integers less than .\n\nIn our next example, we set and again include integers less than .\n\nThe optional value controls the increment between the values in the range. By default, .\n\nIn our final example, we use the range of integers from to and set .\n\nIn this article, we looked at loops in Python and the function.\n\nloops repeat a block of code for all of the values in a list, array, string, or .\n\nWe can use a to simplify writing a loop. The value of the must be specified, but we can also modify the ing value and the between integers in the ."
    },
    {
        "link": "https://geeksforgeeks.org/gfact-50-python-end-parameter-in-print",
        "document": "By default Python‘s print() function ends with a newline. A programmer with C/C++ background may wonder how to print without a newline. Python’s print() function comes with a parameter called ‘end‘. By default, the value of this parameter is ‘\n\n’, i.e. the new line character.\n\nLet’s see one more example to demonstrate the working of the end parameter.\n\nThe print() function uses the sep parameter to separate the arguments and ends after the last argument.\n\nHow to use Python\n\nThe parameter in the function specifies what is printed at the end of the output. By default, it is set to a newline character ( ), which means each call outputs on a new line. You can change this to any other string:\n\nHow to concatenate output from multiple print statements in Python?\n\nparameter be used to format CSV data in Python?\n\nYes, the parameter can help in formatting CSV data. By setting to a comma or other delimiter, you can print CSV-like formatted data: These uses of the parameter can enhance the control you have over output formatting in Python."
    },
    {
        "link": "https://stackoverflow.com/questions/71732369/how-to-use-end-parameter-in-f-string-print-format",
        "document": "You can just use normally after a comma in any print statement. It is a keyword argument (often called a ). It does not matter if your first argument is a string (ie: ), a variable (ie: ) or an f-string (ie: ).\n\nFor what it's worth you can achieve the same thing by calling on an f-string in a single statement."
    },
    {
        "link": "https://lambdatest.com/blog/python-end-parameter",
        "document": "In the world of test automation, two constant challenges stand out: making output well-organized and easy to understand. Developers and testers often strive to present logs, reports, and debug information straightforwardly and efficiently.\n\nAs technology advances and software systems become more complex, efficient and precise testing methodologies have become essential. Test automation is a crucial process. It is like a careful checklist to ensure that the software works well. To provide this, one frequently ignored but handy tool for automation engineers is the Python end parameter.\n\nPython end parameter is a solution to deal with the complex nature of output formatting. Automation engineers use the end parameter to gain precise control over aspects like line endings, string concatenation, and formatting choices.\n\nThis blog will dive deeper into the Python end parameter, moving beyond the basics. We will use real-world examples and practical scenarios to illustrate its importance in the test automation field. By the end of this blog, you will be able to enhance the precision and effectiveness of your test automation scripts.\n\nWhat is the Python end parameter?\n\nThe Python end parameter, a lesser-known feature of the Python print() function, controls each output’s concluding character or string. This parameter is set to a line break by default, represented by the newline character \n\n.\n\nHowever, understanding how to manipulate the end parameter allows automation engineers to gain excellent control over the formatting of their output. This capability proves particularly valuable in test automation, where managing and presenting output in an organized and easily understandable manner is essential.\n\nOverview of test automation and its benefits\n\nTest automation is a foundational element in software development, offering developers and Quality Assurance Engineers (QAEs) the tools to thoroughly evaluate their software solutions’ reliability and efficacy. Its significance extends to accelerating the Software Development Life Cycle (SDLC). It brings a wide range of benefits, such as improving efficiency, boosting reliability, and enhancing the overall quality of the product.\n\nLet us look into some of the benefits of test automation in the Python end parameter.\n• Enhanced Efficiency: It reduces human effort and minimizes the time required to execute tests consistently.\n• Augmented Accuracy: Minimizes the risk of human errors, ensuring more accurate detection of software defects and issues.\n• Regression Testing: Automation ensures that recent changes or modifications do not disrupt previously working features.\n• Scalability: It allows for testing complex software with many test cases, ensuring a comprehensive assessment.\n• Rapid Feedback: It enables developers to identify and fix issues early in the development cycle.\n\nBefore getting started into advanced topics like the Python end parameter, ensure you have a solid knowledge of Python basics.\n\nUnderstanding and leveraging the Python end parameter becomes crucial to further capitalize on the benefits of test automation. By skillfully manipulating line endings and customizing output formats, automation engineers can optimize the creation of well-structured logs, reports, and debugging information. This capability empowers teams to simplify their analysis, troubleshooting, and communication of test results.\n\nUsing the Python end parameter, we aim to provide automation engineers with the insights and skills to enhance their testing procedures, ultimately promoting more effective and efficient software development practices.\n\nIn the following sections, we will explore the Python end parameter in-depth, revealing its practical uses in addressing typical formatting issues encountered in test automation.\n\nIn this section, we will learn more about the workings of the Python print() function, its end parameter, and its purpose with an illustration for better understanding.\n\nUnderstanding the basics of the versatile print() function is essential. In Python, the print() function is a fundamental tool for showing text or values on the console, where program output is displayed. This built-in function handles various input types, from plain strings to complex variables or expressions, and presents them as readable text.\n\nTo understand this, see the example below using the print() statement.\n\nIn these examples, the print() function displays test case information.\n\nStep 1: In the first instance, the text to be printed is directly specified within the print() function.\n\nStep 2: In the second example, the test case name and its status are extracted from a variable that holds text. These variables are then utilized within the print() function.\n\nRunning this code, you will get:\n\nAs we delve into the Python end parameter, we discover a hidden feature within the print() function. This mysterious end parameter lets us control what comes at the end of our printed output. By default, it adds a newline character \n\n, which makes the following result appear on a new line, following the usual formatting.\n\nHow does the Python end parameter affect the output of the print() function?\n\nThe Python end parameter acts as a prompt, significantly influencing the behavior of the print() function. By modifying the value assigned to the Python end parameter, we can redefine the default behavior, which typically entails appending a newline character.\n\nThis customization of the Python end parameter allows us to specify any character or string we desire, effectively determining the concluding element of our printed output. Consequently, this newfound control over formatting and arrangement permits us to fashion our printed output to align with our preferences and requirements.\n\nIllustrating the default behavior of the Python end parameter\n\nTo provide a concrete demonstration of the default behavior exhibited by the Python end parameter, let us delve into a straightforward example. Consider the following lines of code:\n\nUpon executing this code snippet, we witness the following output:\n\nThis output is attributed to the default behavior of the end parameter, which appends a newline character \n\n after each print() statement. Consequently, the two strings are displayed on separate lines, adhering to the conventional formatting conventions.\n\nIt happens because of the default behavior of the Python end parameter, which adds a newline character \n\n at the end of each print() statement. As a result, the two strings are shown on separate lines, following the usual formatting rules.\n\nIn the following sections, we’ll explore how the Python end parameter is practically used, including its role in combining strings and formatting output in test automation scripts.\n\nLet’s explore the Python end parameter in the Python print() function. This minor feature can significantly impact how we format our output. We will look into three default behaviors of the Python end parameter functionality:\n• Changing the default behavior of the Python end parameter\n\nIn the following section, we will discover the Python end parameter behaviors and capabilities and how it can improve our output formatting skills with some examples.\n\nWhether you’re new to Python or an experienced developer, understanding the Python end parameter can be a valuable asset.\n\nChanging the default behavior of the Python end parameter\n\nCustomizing the Python end parameter to achieve different line endings according to our requirements.\n\nWhether you want to print on the same line without a newline character or prefer to separate output with a specific character, the Python end parameter gives you the power to achieve various line endings. This level of control is especially beneficial in scenarios where neatly formatted logs, reports, or data presentations are essential.\n\nFor instance, let’s consider the following code snippet:\n\nIn this example, we have modified the end parameter to (‘ ! ‘ ). On execution of the code snippet, the output will be:\n\nAs you can see, the print() statement doesn’t conclude with the usual newline character \n\n. Instead, it adds the exclamation mark (‘ ! ‘), exactly as instructed by the end parameter. Its customization allows us to manage line endings and craft distinct output styles.\n\nIn the following examples, we’ll explore how to use the Python end parameter to achieve different line endings and enhance the presentation of your output.\n\nConsider the following examples:\n\nIn this example, we have used various characters as line endings for each print() statement.\n\nTo achieve this, we modify the Python end parameter in each print() statement, specifying the desired line ending for each output line.\n\nThe output demonstrates that we have yet to use the typical newline character. Instead, we have introduced custom line endings for each print() statement to achieve this unique output.\n\nLet’s proceed with our examples to see how more can be customized using the Python end parameter.\n\nIn this example, we will be customizing the Python end parameter to create a formatted list of numbers, separating them with colons and spaces, using a space character (‘ ‘) for the first print() statement and a comma followed by a space (‘ , ‘) for subsequent print() statements.\n\nThis approach results in a comma-separated list of numbers with a space following each colon.\n\nThe Python end parameter in the print() function can also be used for string concatenation, allowing us to create custom output formats. By adjusting the Python end parameter, we control how different print() statements are joined together.\n\nLet’s look at the following code snippet:\n\nIn the code below, we have used the Python end parameter to concatenate strings and create a formatted output.\n\nBefore we look into the outcome of the code, let us understand the code in the following steps:\n\nStep 1: In the first print() statement, we use a space character (‘ ‘) as the Python end parameter. It adds a space after the content of the first print() statement.\n\nStep 2: For the second print() statement, we use a comma and a space (‘, ‘) as the Python end parameter. It concatenates the name and adds a comma with a space before the next print() statement.\n\nThis approach allows us to create a well-structured output format with concatenated strings.\n\nThe Python end parameter in test automation can help concatenate relevant information and create meaningful output. Let us learn more about this with some examples.\n\nIn this example, We are trying to print test steps and test status using the Python end parameter\n\nLet us understand what the code is trying to perform here in the following steps:\n\nStep 1: You define test_step and status variables to store information about a test step and its status.\n\nStep 2: The print() function is used multiple times to display this information.\n\nStep 3: For the Step: and Status: labels, the Python end parameter is set to a space character (‘ ‘), so they don’t end with a newline character and stay on the same line.\n\nStep 4: The test_step variable content is printed, followed by a comma and space to separate it from the next part.\n\nStep 5: Finally, the status variable content is printed, which completes the output in the desired format.\n\nIt displays the test step and its status in a clear and structured format on a single line. This enables us to generate detailed and informative logs during test execution.\n\nIn this example, we will display the information about a test case, its result, and an error message in a structured format on a single line, using specific labels and separators.\n\nBefore we jump to the outcome of this code, Let us understand what the code is trying to perform here in the following steps:\n\nStep 1: You define three variables: test_case, result, and error_message to store information about a test case, its result, and an associated error message.\n\nStep 2: The print() function is used multiple times to display this information.\n\nStep 3: The Python end parameter is set to a space (‘ ‘) for the Test Case and Result labels so they don’t end with a newline character and stay on the same line.\n\nStep 4: The test_case variable content is printed, followed by a comma and space to separate it from the next part.\n\nStep 5: The Result label is printed without a newline due to the ‘end’ parameter with a space (‘ ‘).\n\nStep 6: The result variable content is printed, followed by a period and space to separate it from the next part.\n\nStep 7: The Error label is printed without a newline due to the ‘end’ parameter with a space (‘ ‘).\n\nIt can be valuable for generating comprehensive test reports and identifying issues in the automation process.\n\nThe Python end parameter can control the spacing between different outputs besides line endings and string concatenation. By customizing the Python end parameter, we can adjust the spacing to enhance the readability and formatting of the output. Let us understand this with the example below.\n\nIn this example, we have added multiple spaces after the labels by manipulating the Python end parameter.\n\nBefore executing this code snippet, let us understand the working of this code in the following steps:\n\nStep 1: You define two variables, name and duration, to store information about a test case’s name and duration.\n\nStep 2: The print() function is used multiple times to display this information.\n\nStep 3: For the Test Case Name and Duration labels, the end parameter is set to multiple spaces (‘ ‘) to align the output neatly.\n\nStep 4: The name variable content is printed following the Test Case Name label.\n\nStep 5: Similarly, the Test Case Duration label is printed, and the duration variable content is displayed next to it.\n\nIt displays the test case name and duration with specific labels and alignment for a structured and well-formatted output.\n\nControlling spacing using the Python end parameter in test automation scenarios can contribute to more readable and well-structured output. Some examples include:\n• Aligning test step descriptions and their corresponding results to create a well-organized log\n• Formatting test data output to ensure clear differentiation between input values and expected results\n\nBy utilizing the Python end parameter to control spacing, test automation scripts can generate output that is easier to interpret and analyze, facilitating efficient debugging and reporting processes.\n\nUnderstanding the potential of the Python end parameter provides test automation engineers with versatile tools for changing line endings, concatenating strings, and managing spacing. These capabilities make test automation logs, reports, and other outputs more readable, organized, and understandable, aligning them with specific formatting preferences.\n\nLet’s dive into the versatile techniques you can use with Python end parameter to enhance your output formatting.\n\nThe Python print() function offers more than just the Python end parameter. Test automation professionals can unlock advanced functionality and control over their output by understanding how end can be combined with other parameters, such as sep and file.\n\nOne interesting parameter to explore is sep, which determines the separator between multiple items passed to print().\n\nBy default, sep is set to a space character but can be customized to meet specific requirements.\n\nConsider the following example that combines end, sep, and file parameters:\n\nChange the log_test_result() function to save test results in a log file (test.log) instead of displaying them on the console. Improve log entry readability using a pipe character (‘ | ‘) as the separator via the sep parameter.\n\nBefore we jump to the outcome, let us understand the code instructions one by one using the following steps:\n\nStep 1: You define a function called log_test_result that takes two parameters: test_case and result. This function is intended to log test results into a file named test.log.\n\nStep 2: Inside the function, you use a with a statement to open the test.log file in append mode (‘a’). This mode ensures that the file is created if it doesn’t exist or appends data to it if it does.\n\nStep 3: Within the with block, you use the print() function to write text to the file. The text includes the Test case, the value of test_case, the Result, the result value, and the separators specified by the sep parameter (‘ | ‘).\n\nStep 4: After writing the text, the end parameter is set to \n\n to add a newline character, ensuring each log entry appears on a new line in the file.\n\nStep 5: Finally, you provide an example of how to use the log_test_result function. You define a test_case variable with the value Login Test and a result variable with the value Passed.\n\nStep 6: Then, you call the log_test_result function with these values, which logs this test case and results to the test.log file.\n\nThe test.log generated file will show the below content:\n\nThe code logs test case results to the test.log file in a structured format, making it easy to record and review test outcomes. Combining end, sep, and file parameters opens up possibilities for advanced print() usage in test automation.\n\nHere are a few practical examples of the Python end parameter in test automation.\n• Generating HTML Reports\n\n By redirecting the output to an HTML file using the file parameter and customizing end, sep, and HTML tags, it’s possible to create visually appealing and interactive HTML reports that contain clickable links, tables, and other elements.\n• Logging Timestamps\n\n Test automation scripts can log timestamps for each test step or event by incorporating the end parameter and date and time functions. This information can be valuable for debugging and analysis.\n• Creating Custom Output Formats\n\n By combining end, sep, and file parameters with conditional statements and formatting techniques, test automation engineers can generate custom output formats customized to specific needs, such as XML, JSON, or CSV. It allows for seamless integration with other tools and systems.\n\nThe power of the Python end parameter is not limited to the built-in print() function. It can also be integrated into user-defined functions, providing greater control over the output.\n\nLet’s explore an example of how end can be used in a custom function for test automation.\n\nExample: Utilizing the Python end parameter within the custom function.\n\nBefore we jump to the outcome of this code, let’s first understand the purpose of this sequence of instructions.\n\nStep 1: This code defines a function called log_test_step, which takes three parameters: step_number (an integer representing the test step), description (a string describing the step), and result (a string indicating the outcome).\n\nStep 2: Inside log_test_step prints a formatted message including these parameters using f-strings, with a pipe symbol (‘ | ‘) as a separator.\n\nStep 3: Outside the function, an example demonstrates how to use it by setting values for test_step, step_description, and step_result and then calling log_test_step to print a summary of the test step to the console.\n\nThis output displays the step number, description, and result of the test step in a formatted manner. The pipe symbol (‘ | ’) separates the description and the outcome.\n\nExamples of integrating the Python end parameter in custom functions for automation\n\nIntegrating the Python end parameter into custom functions can significantly enhance the flexibility and functionality of test automation scripts.\n\nHere are some extra instances of integrating the Python end parameter.\n\nCustomized Logging Levels\n\n Different logging levels, such as debug, info, or error, can be implemented by incorporating the end parameter in a custom logging function. It allows for selective output based on the desired level of detail, providing more granular control over the logging process.\n\nVerbose Output Control\n\n With the Python end parameter, custom functions can offer an option to toggle verbose output. It allows users to control the amount of information displayed during test execution, balancing detailed feedback and concise output.\n\nFormatting Output for Different Platforms\n\n Custom functions can adapt the output format based on the target platform using the Python end parameter. Whether it’s console, web, or mobile, the flexibility offered by the end allows for seamless formatting adjustments to ensure compatibility and consistency across various environments.\n\nBy integrating the Python end parameter with other print() parameters and custom functions, test automation engineers can leverage advanced techniques to optimize their output, customize it to specific requirements, and enhance the overall effectiveness of their automation efforts.\n\nDiving into the world of parallel Python automation testing. We unlock the potential to expedite our testing efforts by harnessing the power of concurrency.\n\nBy executing multiple test cases concurrently, we can significantly reduce the overall testing time and enhance the efficiency of our test suite.\n\nThis section will demonstrate a test scenario that uses the Python end parameter to log actions inside a Python Selenium automation test. The main idea here is to automate a simple Python Selenium test, and within the automation steps, we will log each user interaction using the Python end parameter. So, we can see the power of the Python end parameter to one kind of use case: logging.\n\nThe demonstration will be done on a cloud-based grid-like LambdaTest.LambdaTest is an AI-powered test orchestration and execution platform that enables you to conduct both manual and automated tests on a large scale, encompassing over 3000 real devices, browsers, and operating system combinations. When conducting Python automation testing with LambdaTest, you can execute your automated tests concurrently across various browser and operating system combinations. This approach helps in minimizing the total test execution time.\n\nTo perform Selenium Python testing on the LambdaTest Selenium grid, you must use capabilities to set up and configure the specific environment in which your test will be executed.\n\nIn this pytest tutorial, we will address and resolve challenges related to this process by demonstrating how to utilize the capabilities effectively for testing purposes in a headless mode. We will also address and resolve challenges associated with configuring test environments.\n\n Effectively demonstrating the utilization of capabilities for testing purposes in two distinct environments:\n\nFor steps 2-4, we will use the Python end parameter to log the user actions inside the test case.\n\nBefore starting to write the code and run the test over LambdaTest, let’s take care of a few things, such as setting up the environment, installing Python, adding capabilities to test scripts, and more.\n\nBefore we start with parallel testing, it’s essential to set up a strong foundation by correctly configuring our testing environment. To ensure a smooth coding experience, follow the steps given below. These steps are essential for maximizing our testing capabilities and productivity.\n\nLet’s explore the necessary actions we need to take before starting on parallel testing.\n\nStep 1: Download and Install Python.\n\n If you still need to install it, install it from the official Python website.\n\nStep 2: Install Selenium and pytest libraries.\n\n Once Python is installed, use the Python package manager, pip, to install Selenium and pytest by running the following command:\n\nStep 3: Download and Install Visual Studio Code.\n\n In this case, we will be using VS Code as our IDE, and you are free to use any preferred IDE of your choice.\n\n Step 4: Configure pytest in Visual Studio Code.\n\n To set up pytest as the test runner in Visual Studio Code, just do the following easy steps:\n\n1. Create a Project Folder: Make a folder for your project, like naming it python-headless-browser.\n\n2. Open the Project Folder in VS Code: Open this new project folder in Visual Studio Code.\n\n3. Access the Command Palette: You can reach the command palette by going to “View” in the menu and choosing “Command Palette.” Or simply press Ctrl+Shift+P (Cmd+Shift+P on macOS).\n\n4. Configure Tests: In the command palette, type Configure Tests and select it from the options.\n\n5. Choose pytest as the Test Runner: When asked, pick pytest as your preferred test runner.\n\n6. Select the Root Directory: Go for the root directory option. It sets up a pytest for your entire project.\n\nBy following these simple steps, you will have pytest all set up as your test runner in Visual Studio Code, making it easier to manage your tests right inside the editor.\n\nIf you’re using the pytest framework for running Python-based automation, check out our blog on pytest tutorial. Run your test suites in parallel across multiple browsers and operating systems for complete test coverage.\n\nSubscribe to the LambdaTest YouTube channel for more videos on Parallel testing and Selenium testing and to enhance your testing experience!\n\nWith your IDE and framework ready, it’s time to configure the LambdaTest settings and specify the necessary capabilities to incorporate into our test script.\n\nTo do so, you need to follow the steps given below.\n\nStep 2: Get your Username and Access Key by going to your Profile avatar from the LambdaTest dashboard and selecting Account Settings from the list of options.\n\nStep 3: Copy your Username and Access Key from the Password and Security tab.\n\nStep 4: Generate Capabilities, which contain details like your desired browser and its various operating systems. Generate your LambdaTest Capabilities Generator as per your requirement.\n\nStep 5: Now that you have both the Username, Access key, and capabilities copied, all you need to do is paste it on your test script.\n\nIn the following section, we will implement parallel testing on the LambdaTest cloud platform.\n\nImplementation of parallel testing on the cloud\n\nWith LambdaTest’s parallel testing feature, you can perform simultaneous tests across various browsers and devices, ensuring comprehensive coverage in less time.\n\nIn this code example, we will explore the process of performing parallel Python Selenium automation testing using the Python end parameter. This technique allows us to run multiple test cases concurrently, improving efficiency and reducing overall testing time.\n\nLet’s dive into the code and understand its various components.\n• The code begins importing the necessary modules and defining the pytest fixture called driver using the pytest.fixture decorator.\n• This fixture is responsible for initializing the Selenium WebDriver for each test case. It takes a parameter request, which represents the test request context.\n• Inside the fixture, we will fetch the environment variables “LT_USERNAME” and “LT_ACCESS_KEY,” containing your LambdaTest credentials.\n• It sets the LambdaTest Selenium Grid URL as “hub.lambdatest.com/wd/hub.” into gridUrl variable.\n• Based on the requested browser parameter (e.g., “chrome-Windows11″ or “firefox-macOSVentura“), it configures the webdriver options, platform, and browser name accordingly.\n• LambdaTest-specific options such as username, accessKey, build, and name are set in lt_options.\n• The webdriver options are assigned to the options variable.\n• The URL for accessing the LambdaTest grid is constructed using the credentials and grid URL.\n• It initializes a WebDriver instance using webdriver.Remote with the constructed URL and options.\n• The WebDriver is yielded to the test case and cleaned up after test execution using the driver. quit() method.\n\nWe define a helper function called log_test_execution. This function logs test execution details to a file named cloudgrid.log. It takes various parameters such as the platform, browser, step number, element, action performed, and additional details.\n\nIt will be explained in more information at the end of this section.\n• It navigates to the LambdaTest Selenium Playground’s simple form demo page.\n• Extracts platform and browser names from the webdriver’s capabilities.\n• The code finds an HTML input element with the ID user-message on the web page using the driver.find_element().\n• The send_keys() method emulates user input by typing “This is an end parameter text!” into the located input field.\n• After sending the keys, the log_test_execution function is called to log execution details. This includes recording the platform, browser, step number, element, action, and action details for later analysis and reporting.\n• The parameters sent to the log_test_execution function are:\n• platform : get from the webdriver capabilities\n• browser : get from the webdriver capabilities\n• step : 1, to represent that this is the first step of the test\n• element : “user-message”, that is the ID of the element\n• action : “send_keys” that is the action done in the element\n• details : “This is an end parameter text!” that is what is typed in the field\n• We proceed to locate an element identified by the ID “showInput” and initiate a click action using the element.click() method. As always, we log these test execution details for documentation.\n• The parameters sent to the log_test_execution function are:\n• platform : get from the webdriver capabilities\n• browser : get from the webdriver capabilities\n• step : 2, to represent that this is the second step of the test\n• element : “showInput” that is the ID of the element\n• action : “click” that is the action done in the element\n• details : “” because the click method does not need any detail, so, we don’t need to log any details\n• To conclude, we find an element labeled message using its ID, and we check if the text displayed matches what we expect. If the check fails, the test is considered unsuccessful. Throughout this process, we continue to log the test execution details for documentation.\n• The parameters sent to the log_test_execution function now are:\n• platform : get from the webdriver capabilities\n• browser : get from the webdriver capabilities\n• step : 3, to represent that this is the third step of the test\n• element : “message”, that is the ID of the element\n• action : “.text ” that is the action done in the element (get the text value of the element)\n• details: “This is an end parameter text!” that is what is expected to have in the element text value\n\nIn summary, this test case illustrates how we interact with web elements, carry out actions, and verify expected outcomes using Selenium. Additionally, it highlights the use of the Python end parameter function to streamline the logging of test execution details.\n\nThis code is the foundation for parallel Python Selenium automation testing, enabling simultaneous execution of multiple test cases and harnessing the benefits of parallel processing.\n\nYou can run the entire code using the below command:\n\nThe cloudgrid.log generated file will show the below content:\n\nInside the log_test_execution function, the details are formatted and appended to the log file using the print function combining end, sep, and file parameters.\n\nThe log_test_execution function has received some parameters:\n• platform : Represents the platform name associated with the test execution. It is used to log the platform information\n• browser : Represents the browser name associated with the test execution. It is used to log the browser information\n• step : Represents the step number or identifier for the action being logged. It provides a reference to the specific action in the test execution flow. It helps the log reader understand the flow considering the step order\n• element : Represents the element involved in the action being logged. It could be an element ID, class name, or any other identifier that helps identify the element in the test execution\n• action : Represents the action performed on the element. It provides information about the specific action being logged, such as click, send_keys, or any other relevant action\n• details : Represents additional details or information related to the action being logged. It could include the value sent in the action or any other relevant information.\n\nLet us see the entire explanation of code flow in a step-by-step process.\n• The code uses the open function to open a file named cloudgrid.log in append mode.\n• It’s crucial to note that the file is opened within a context manager (using the with statement). This ensures that the file is handled correctly and automatically closed after use.\n• To write log details, the code utilizes the print() function. This function is responsible for formatting and adding log entries to the file.\n• The datetime.now() function obtains the current timestamp, representing when the log entry is created. This timestamp is recorded as a Timestamp.\n• The remaining parameters (platform, browser, step, element, action, details) are logged in a well-structured format.\n• The sep parameter, set as ” | “, determines the separator between log elements. In this case, it separates the elements with a vertical bar followed by a space.\n• The end parameter, set as ;\n\n, specifies what comes after each log entry. Here, it appends a semicolon and moves to the next line after writing the log entry.\n• The file=file part designates the file object to which the log entry is written.\n• Because we’ve opened the file within the context manager, the file object references the cloudgrid.log file.\n\nTo summarize, this code efficiently manages log entries by opening the file within a context manager, formatting log details with separators and line endings, and then writing them to the designated log file. This approach ensures clean and organized log entries for later analysis.\n\nWhen adding the Python end parameter into test automation scripts, it’s crucial to follow effective approaches to ensure optimal usage. Consider the following recommendations:\n\nMaintaining a consistent approach throughout the script when working with the end parameter fosters better readability and ensures a predictable output format across various sections of the script. When concatenating strings or formatting output using the end parameter, selecting separators that clearly indicate the intended structure of the output is essential. This contributes to improved comprehensibility of logs, reports, and other output formats. Design print() statements with the end parameter in a reusable manner. Avoid hard-coding values or specific formats that may limit the script’s flexibility. Instead, employ variables or functions to handle formatting, enabling effortless modifications and adaptability. While the end parameter offers customization options, it’s vital to balance between custom formatting and readability. Excessive use of special characters or unconventional formatting should be avoided to prevent convoluted output that hinders interpretation and analysis.\n\nIn test automation, logging plays a crucial role in capturing and tracking test results. The Python end parameter can be harnessed to create structured and informative logs that facilitate analysis and debugging.\n\nTo demonstrate this use case, let’s consider a more sophisticated example:\n\nBefore looking into the outcome of the code, let’s understand the instructions step-by-step.\n\nStep 1: The code defines a function named log_test_result that accepts three parameters:\n• test_case : A string representing the name of a test case.\n• timestamp : A string containing the timestamp when the test was executed.\n• It starts by printing “[LOG]” to indicate this is a log entry.\n• Then, it prints the test case name, result, and timestamp, each separated by a pipe symbol (‘ | ’). This information is included using f-strings for formatting.\n• The end=’ ‘ argument in the print statements specifies that a space should be used to separate the printed items. This keeps the output visually organized.\n\nStep 3: After defining the function, there’s an example of how to use it. There are three variables are created:\n• test_case is assigned the value Login Test, representing the name of a test case.\n• result is set to Passed, indicating that the test has passed successfully.\n• timestamp is set to 2023-06-18 10:23:45, specifying the timestamp when the test was executed.\n\nThe log_test_result function is then called with these variables as arguments to log the test result.\n\nTo summarize, this code defines a function to log test results and demonstrates its usage with an example. The function accepts test case details, result, and a timestamp, then formats and prints a log entry for the test result.\n\nTest reports provide a complete overview of test execution outcomes. The Python end parameter can be leveraged to format the output, making it easier to read and interpret.\n\nConsider the following more sophisticated example, where we demonstrate formatting output for a test report:\n\nBefore we look into the outcome of this code, let’s understand what the code is trying to perform in a step-by-step manner.\n\nStep 1: The code defines a function named generate_test_report that takes a single parameter, test_results, which is expected to be a list of dictionaries containing test case results.\n\nStep 2: Within the generate_test_report function, It prints the test report and a line of dashes to serve as a header. This creates a clear visual separation for the test report.\n\nStep 3: The code utilizes a for loop to iterate through the test_results list, where each item is a dictionary representing a test case result. In the loop, it retrieves each result dictionary.\n• It prints the test case followed by a tab character to indicate the start of a new test case entry.\n• Then, it prints the test case name from the result dictionary.\n• It prints the Status followed by a space to indicate the status of the test case.\n• Finally, it prints the status (e.g., “Passed” or “Failed”) from the result dictionary.\n\nStep 5: After defining the generate_test_report function, there’s an example of how to use it. test_results is a list of dictionaries, each containing a test case name and its status (“Passed” or “Failed”).\n\nIn this example, the generate_test_report() function is designed to receive a list of test results as input. By strategically using the Python end parameter and incorporating tabs, we craft the output with uniform spacing and alignment. Each test case name is neatly presented alongside its associated status, resulting in an aesthetically pleasing and easily comprehensible test report.\n\nThese advanced examples showcase the adaptability of the Python end parameter in logging test outcomes and structuring test reports. By employing customized formatting techniques, automation scripts can yield more refined and complete output, enriching the analysis and reporting capabilities of the automation process.\n\nIn this blog, we have discovered how the end parameter in Python plays a crucial role in controlling output formatting, especially in test automation. It’s a practical tool that allows us to customize how test results, logs, and other information are displayed. By using the Python end parameter effectively, we can improve the clarity and organization of our test automation code.\n\nBy default, the Python end parameter uses a newline character \n\n to move to the next line after printing. However, we can adjust it to fit our specific needs. This is just one example of the many powerful tools available to enhance the effectiveness of our test automation scripts.\n\nIn conclusion, the Python end parameter allows us to personalize the output of our test automation code, making it more readable and organized. By understanding its importance and experimenting with it, we can significantly enhance the presentation of our test results. Embrace the opportunity to explore the end parameter further, unlocking Python’s full potential in test automation."
    },
    {
        "link": "https://codedamn.com/news/python/how-do-python-end-and-sep-parameters-different-in-print",
        "document": "In this article, we’ll look at the Python end and sep parameters in the print function. To see how they can be used to customize the output of the function.\n\nIn Python, the function is a handy tool for printing output to the console. One of the most useful features of the function is the ability to specify the and parameters. Which eventually, gives control to format the output according to your choice.\n\nWhat is the Python end parameter in print()?\n\nThe parameter allows you to specify a string that will be printed after the output of the function. However, the parameter is by default set to a new line character. which means that each call to will print its output on a new line. However, you can customize the parameter to specify a different character or string that you want to print at the end of the output.\n\nHere’s the syntax for using the :\n\nAn example of the use of the parameter to specify a string to be printed after the output:\n\nThis code will print “Namaste, India” on the same line, with a comma separating the two words, as shown in the code.\n\nWhat is the Python sep parameter in print()?\n\nThe parameter allows you to specify a string that will be used to separate the items being printed by the function. By default, the parameter is set to a single space character. which means that the items being printed will be separated by a single space. However, you can also customize the parameter.\n\nHere’s the syntax for using the parameter:\n\nLet’s see an example of the use of the parameter to specify a different string to be used as a separator:\n\nThis code will print “Namaste, India” on the same line, with a comma separating the two words.\n\nWhat is the difference between sep and end in print()?\n\nPython end and sep parameters in the print function mainly differ due to their location. means where they are used in the function. The parameter is used to specify a string that will be printed after the output. However, the parameter is used as a separator between the items that you want to print.\n\nThe and end parameters in the function specifies the separator between the arguments. By default, the separator is a space character. For example, the following code will print “Namaste India” with a space between the two words:\n\nYou can change the separator by specifying the Python end and sep parameters.\n\nFor example, consider the following code:\n\nThis code will print “Namaste, India” on the same line, with a comma separating the two words.\n\nNow consider the following code:\n\nThis code will also print “Namaste, India” on the same line, but with a comma separating the two words.\n\nIn both cases, we are printing “Namaste” and “India” on the same line. but the parameter specifies a comma as the separator between the two words. while the parameter specifies a comma as the string to be printed after the words.\n\nHow to use end and sep parameters in Python’s print() function\n\nLet’s move to see how you can use the Python end and sep parameters in the function:\n\nNow, using both end and sep parameters:\n\nIn summary, You can use sep in the function to specify the separator between the string. while the feature to specify the string that is printed at the end of the line. These parameters can be useful for controlling the formatting of the output in your Python programs.\n\nWhat is the difference between SEP and end in print()?\n\nThe sep parameter in the function specifies the separator between the arguments. Instead, You can use the end parameter to specify a character or a string that will be printed at the end of the line.\n\nWhat is the use of the end parameter in print() used in Python?\n\nThe parameter is used to add a new line character if nothing is specified.\n\nHow does print() different from the input() in Python?\n\nIn Python, is a function that outputs a string, or other data, to the console or an output stream. It takes one or more arguments, which can be variables, expressions, or literal values. If you have not specified any parameters. Then by default, the function adds a newline character at the end of the output string.\n\nThe function, on the other hand, reads a line of text from the console or an input stream and returns it as a string. It can also prompt the user to enter some input by displaying a message.\n\nAlthough, the function waits for the user to enter some text and press the Enter key. It then reads the text and returns it as a string. However, you can use the function to get input from the user and store it in a variable for later use.\n\nSo, is used to output data to the console or an output stream, while is used to read input from the console or an input stream.\n\nWhat is SEP in print Python?\n\nThe parameter in the function specifies the separator between the arguments,\n\nWhat does the end do in the print() statement in python?\n\nYou can use the end parameter to specify the string that will be printed at the end of the line. By default, the end is a new line character."
    },
    {
        "link": "https://stackoverflow.com/questions/66212587/formatting-print-statement-based-on-different-end-argument-values",
        "document": "I am making a UI for termux terminal on android.\n\nThis code below prints the content of the directory.\n\nIt works perfectly fine but the output is not even, ie, irregular spaces between the columns.\n\nI've seen people using format but in my case the end argument value differ on each print.\n\nbut I want perfectly aligned 2 column output.I've tried many things. Is there a short way to do this?\n\nI actually have a solution where I check the longest string and add white spaces for remaining strings but it's not optimal."
    }
]