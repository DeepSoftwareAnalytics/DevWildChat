[
    {
        "link": "https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html",
        "document": ""
    },
    {
        "link": "https://pandas.pydata.org/docs/user_guide/10min.html",
        "document": "This is a short introduction to pandas, geared mainly for new users. You can see more complex recipes in the Cookbook.\n\nCustomarily, we import as follows:\n\nSee the Intro to data structures section. Creating a by passing a NumPy array with a datetime index using and labeled columns: Creating a by passing a dictionary of objects where the keys are the column labels and the values are the column values. The columns of the resulting have different dtypes: If you’re using IPython, tab completion for column names (as well as public attributes) is automatically enabled. Here’s a subset of the attributes that will be completed: As you can see, the columns , , , and are automatically tab completed. and are there as well; the rest of the attributes have been truncated for brevity.\n\nUse and to view the top and bottom rows of the frame respectively: Return a NumPy representation of the underlying data with without the index or column labels: NumPy arrays have one dtype for the entire array while pandas DataFrames have one dtype per column. When you call , pandas will find the NumPy dtype that can hold all of the dtypes in the DataFrame. If the common data type is , will require copying data.\n\nWhile standard Python / NumPy expressions for selecting and setting are intuitive and come in handy for interactive work, for production code, we recommend the optimized pandas data access methods, , , and . See the indexing documentation Indexing and Selecting Data and MultiIndex / Advanced Indexing. For a , passing a single label selects a columns and yields a equivalent to : See more in Selection by Label using or . For label slicing, both endpoints are included: For getting fast access to a scalar (equivalent to the prior method): See more in Selection by Position using or . Select via the position of the passed integers: For getting a value explicitly: For getting fast access to a scalar (equivalent to the prior method): Select rows where is greater than . Selecting values from a where a boolean condition is met: Setting a new column automatically aligns the data by the indexes: The result of the prior setting operations:\n\nFor NumPy data types, represents missing data. It is by default not included in computations. See the Missing Data section. Reindexing allows you to change/add/delete the index on a specified axis. This returns a copy of the data: drops any rows that have missing data: gets the boolean mask where values are :\n\nSee the Basic section on Binary Ops. Calculate the mean value for each column: Calculate the mean value for each row: Operating with another or with a different index or column will align the result with the union of the index or column labels. In addition, pandas automatically broadcasts along the specified dimension and will fill unaligned labels with . and applies a user defined function that reduces or broadcasts its result respectively. See more at Histogramming and Discretization. is equipped with a set of string processing methods in the attribute that make it easy to operate on each element of the array, as in the code snippet below. See more at Vectorized String Methods.\n\nBy “group by” we are referring to a process involving one or more of the following steps:\n• None Splitting the data into groups based on some criteria Grouping by a column label, selecting column labels, and then applying the function to the resulting groups:\n\nSee the sections on Hierarchical Indexing and Reshaping. The method “compresses” a level in the DataFrame’s columns: With a “stacked” DataFrame or Series (having a as the ), the inverse operation of is , which by default unstacks the last level: See the section on Pivot Tables. pivots a specifying the , and\n\npandas can include categorical data in a . For full docs, see the categorical introduction and the API documentation. Rename the categories to more meaningful names: Reorder the categories and simultaneously add the missing categories (methods under return a new by default): Sorting is per order in the categories, not lexical order: Grouping by a categorical column with also shows empty categories:\n\nIf you are attempting to perform a boolean operation on a or you might see an exception like: Traceback (most recent call last) in in : The truth value of a Series is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all(). See Comparisons and Gotchas for an explanation and what to do."
    },
    {
        "link": "https://datacamp.com/tutorial/pandas-tutorial-dataframe-python",
        "document": "Learn to import data into Python from various sources, such as Excel, SQL, SAS and right from the web."
    },
    {
        "link": "https://geeksforgeeks.org/pandas-tutorial",
        "document": "Pandas, which is styled as pandas is an open-source software library designed for the Python programming language, focusing on data manipulation and analysis. It provides data structures like series and DataFrames to effectively easily clean, transform, and analyze large datasets and integrates seamlessly with other Python libraries, such as NumPy and Matplotlib.\n\nIt offers powerful functions for data transformation, aggregation, and visualization, which are important for credible analysis. Created by Wes McKinney in 2008, Pandas has grown to become a cornerstone of data analysis in Python, widely used by data scientists, analysts and researchers worldwide. Pandas revolves around two primary Data structures: Series (1D) for single columns and DataFrame (2D) for tabular data enabling efficient data manipulation.\n\nWhat is Pandas Used for?\n\nWith pandas, you can perform a wide range of data operations, including\n• None Reading and writing data from various file formats like CSV, Excel, and SQL databases.\n• None Cleaning and preparing data by handling missing values and filtering entries.\n\nNow that we know what pandas are and their uses, let’s move towards the tutorial part. In the section below, you will find 8 sections, from basic to advanced, that will help you learn more about pandas.\n\nIn this section, we will explore the fundamentals of Pandas. We will start with an introduction to Pandas, learn how to install it, and get familiar with its core functionalities. Additionally, we will cover how to use Jupyter Notebook, a popular tool for interactive coding. By the end of this section, we will have a solid understanding of how to set up and start working with Pandas for data analysis.\n• None How To Use Jupyter Notebook\n\nA DataFrame is a two-dimensional, size-mutable and potentially heterogeneous tabular data structure with labeled axes (rows and columns)., think of it as a table or a spreadsheet.\n\nA Series is a one-dimensional labeled array capable of holding any data type (integers, strings, floating-point numbers, Python objects, etc.). It’s similar to a column in a spreadsheet or a database table.\n\nPandas offers a variety of functions to read data from and write data to different file formats as given below:\n\nData cleaning is an essential step in data preprocessing to ensure accuracy and consistency. Here are some articles to know more about it:\n\nWe will cover data processing, normalization, manipulation, and analysis, along with techniques for grouping and aggregating data. These concepts will help you efficiently clean, transform, and analyze datasets. By the end of this section, you’ll be equipped with essential Pandas operations to handle real-world data effectively.\n• None Different Types of Joins in Pandas\n\nIn this section, we will explore advanced Pandas functionalities for deeper data analysis and visualization. We will cover techniques for finding correlations, working with time series data, and using Pandas’ built-in plotting functions for effective data visualization. By the end of this section, you’ll have a strong grasp of advanced Pandas operations and how to apply them to real-world datasets.\n\nTest your knowledge of Python’s pandas library with this quiz. It’s designed to help you check your knowledge of key topics like handling data, working with DataFrames, and creating visualizations.\n\nIn this section, we will work on real-world data analysis projects using Pandas and other data science tools. These projects will cover various domains, including food delivery, sports, travel, healthcare, real estate, and retail. By analyzing datasets like Zomato, IPL, Airbnb, COVID-19, and Titanic, we will apply data processing, visualization, and predictive modeling techniques. By the end of this section, you will gain hands-on experience in data analysis and machine learning applications.\n\nWhat is pandas used for in Python?\n\nWhat are the Benifits of Pandas?\n\nWhat are Pandas best used for?\n\nWhat are the basic data structures in Pandas?\n\nWhen to use pandas?\n\nWhat are the disadvantages of Pandas?"
    },
    {
        "link": "https://datacamp.com/tutorial/pandas",
        "document": "Master the basics of data analysis with Python in just four hours. This online course will introduce the Python interface and explore popular packages."
    },
    {
        "link": "https://docs.python.org/3/library/random.html",
        "document": "This module implements pseudo-random number generators for various distributions.\n\nFor integers, there is uniform selection from a range. For sequences, there is uniform selection of a random element, a function to generate a random permutation of a list in-place, and a function for random sampling without replacement.\n\nOn the real line, there are functions to compute uniform, normal (Gaussian), lognormal, negative exponential, gamma, and beta distributions. For generating distributions of angles, the von Mises distribution is available.\n\nAlmost all module functions depend on the basic function , which generates a random float uniformly in the half-open range . Python uses the Mersenne Twister as the core generator. It produces 53-bit precision floats and has a period of 2**19937-1. The underlying implementation in C is both fast and threadsafe. The Mersenne Twister is one of the most extensively tested random number generators in existence. However, being completely deterministic, it is not suitable for all purposes, and is completely unsuitable for cryptographic purposes.\n\nThe functions supplied by this module are actually bound methods of a hidden instance of the class. You can instantiate your own instances of to get generators that don’t share state.\n\nClass can also be subclassed if you want to use a different basic generator of your own devising: see the documentation on that class for more details.\n\nThe module also provides the class which uses the system function to generate random numbers from sources provided by the operating system.\n\nReturn a random element from the non-empty sequence seq. If seq is empty, raises . Return a k sized list of elements chosen from the population with replacement. If the population is empty, raises . If a weights sequence is specified, selections are made according to the relative weights. Alternatively, if a cum_weights sequence is given, the selections are made according to the cumulative weights (perhaps computed using ). For example, the relative weights are equivalent to the cumulative weights . Internally, the relative weights are converted to cumulative weights before making selections, so supplying the cumulative weights saves work. If neither weights nor cum_weights are specified, selections are made with equal probability. If a weights sequence is supplied, it must be the same length as the population sequence. It is a to specify both weights and cum_weights. The weights or cum_weights can use any numeric type that interoperates with the values returned by (that includes integers, floats, and fractions but excludes decimals). Weights are assumed to be non-negative and finite. A is raised if all weights are zero. For a given seed, the function with equal weighting typically produces a different sequence than repeated calls to . The algorithm used by uses floating-point arithmetic for internal consistency and speed. The algorithm used by defaults to integer arithmetic with repeated selections to avoid small biases from round-off error. Changed in version 3.9: Raises a if all weights are zero. To shuffle an immutable sequence and return a new shuffled list, use instead. Note that even for small , the total number of permutations of x can quickly grow larger than the period of most random number generators. This implies that most permutations of a long sequence can never be generated. For example, a sequence of length 2080 is the largest that can fit within the period of the Mersenne Twister random number generator. Return a k length list of unique elements chosen from the population sequence. Used for random sampling without replacement. Returns a new list containing elements from the population while leaving the original population unchanged. The resulting list is in selection order so that all sub-slices will also be valid random samples. This allows raffle winners (the sample) to be partitioned into grand prize and second place winners (the subslices). Members of the population need not be hashable or unique. If the population contains repeats, then each occurrence is a possible selection in the sample. Repeated elements can be specified one at a time or with the optional keyword-only counts parameter. For example, is equivalent to . To choose a sample from a range of integers, use a object as an argument. This is especially fast and space efficient for sampling from a large population: . If the sample size is larger than the population size, a is raised. Changed in version 3.11: The population must be a sequence. Automatic conversion of sets to lists is no longer supported.\n\nThe following functions generate specific real-valued distributions. Function parameters are named after the corresponding variables in the distribution’s equation, as used in common mathematical practice; most of these equations can be found in any statistics text. Return the next random floating-point number in the range Return a random floating-point number N such that for and for . The end-point value may or may not be included in the range depending on floating-point rounding in the expression . Return a random floating-point number N such that and with the specified mode between those bounds. The low and high bounds default to zero and one. The mode argument defaults to the midpoint between the bounds, giving a symmetric distribution. Beta distribution. Conditions on the parameters are and . Returned values range between 0 and 1. Exponential distribution. lambd is 1.0 divided by the desired mean. It should be nonzero. (The parameter would be called “lambda”, but that is a reserved word in Python.) Returned values range from 0 to positive infinity if lambd is positive, and from negative infinity to 0 if lambd is negative. Changed in version 3.12: Added the default value for . Gamma distribution. (Not the gamma function!) The shape and scale parameters, alpha and beta, must have positive values. (Calling conventions vary and some sources define ‘beta’ as the inverse of the scale). Normal distribution, also called the Gaussian distribution. mu is the mean, and sigma is the standard deviation. This is slightly faster than the function defined below. Multithreading note: When two threads call this function simultaneously, it is possible that they will receive the same return value. This can be avoided in three ways. 1) Have each thread use a different instance of the random number generator. 2) Put locks around all calls. 3) Use the slower, but thread-safe function instead. Changed in version 3.11: mu and sigma now have default arguments. Log normal distribution. If you take the natural logarithm of this distribution, you’ll get a normal distribution with mean mu and standard deviation sigma. mu can have any value, and sigma must be greater than zero. Normal distribution. mu is the mean, and sigma is the standard deviation. Changed in version 3.11: mu and sigma now have default arguments. mu is the mean angle, expressed in radians between 0 and 2*pi, and kappa is the concentration parameter, which must be greater than or equal to zero. If kappa is equal to zero, this distribution reduces to a uniform random angle over the range 0 to 2*pi. Weibull distribution. alpha is the scale parameter and beta is the shape parameter.\n\n# Even integer from 0 to 100 inclusive ['four', 'two', 'ace', 'three'] # of 52 playing cards, and determine the proportion of cards # Estimate the probability of getting 5 or more heads from 7 spins # of a biased coin that settles on heads 60% of the time. # Probability of the median of 5 samples being in middle two quartiles Example of statistical bootstrapping using resampling with replacement to estimate a confidence interval for the mean of a sample: Example of a resampling permutation test to determine the statistical significance or p-value of an observed difference between the effects of a drug versus a placebo: # Example from \"Statistics is Easy\" by Dennis Shasha and Manda Wilson 'at least as extreme as the observed difference of leads us to reject the null' 'hypothesis that there is no difference between the drug and the placebo.' Simulation of arrival times and service deliveries for a multiserver queue: # time when each server becomes available Statistics for Hackers a video tutorial by Jake Vanderplas on statistical analysis using just a few fundamental concepts including simulation, sampling, shuffling, and cross-validation. Economics Simulation a simulation of a marketplace by Peter Norvig that shows effective use of many of the tools and distributions provided by this module (gauss, uniform, sample, betavariate, choice, triangular, and randrange). A Concrete Introduction to Probability (using Python) a tutorial by Peter Norvig covering the basics of probability theory, how to write simulations, and how to perform data analysis using Python.\n\nThese recipes show how to efficiently make random selections from the combinatoric iterators in the module: \"Choose r elements with replacement. Order the result to match the iterable.\" # Result will be in set(itertools.combinations_with_replacement(iterable, r)). The default returns multiples of 2⁻⁵³ in the range 0.0 ≤ x < 1.0. All such numbers are evenly spaced and are exactly representable as Python floats. However, many other representable floats in that interval are not possible selections. For example, isn’t an integer multiple of 2⁻⁵³. The following recipe takes a different approach. All floats in the interval are possible selections. The mantissa comes from a uniform distribution of integers in the range 2⁵² ≤ mantissa < 2⁵³. The exponent comes from a geometric distribution where exponents smaller than -53 occur half as often as the next larger exponent. All real valued distributions in the class will use the new method: The recipe is conceptually equivalent to an algorithm that chooses from all the multiples of 2⁻¹⁰⁷⁴ in the range 0.0 ≤ x < 1.0. All such numbers are evenly spaced, but most have to be rounded down to the nearest representable Python float. (The value 2⁻¹⁰⁷⁴ is the smallest positive unnormalized float and is equal to .) Generating Pseudo-random Floating-Point Values a paper by Allen B. Downey describing ways to generate more fine-grained floats than normally generated by ."
    },
    {
        "link": "https://note.nkmk.me/en/python-random-choice-sample-choices",
        "document": "In Python, you can randomly sample elements from a list using the , , and functions from the module. These functions can also be used with strings and tuples.\n\nreturns a single random element, while and return a list of multiple random elements. is for random sampling without replacement, whereas is for random sampling with replacement.\n\nFor information on selecting elements from a list based on specific conditions, refer to the following article.\n\nIf you want to shuffle an entire list or create a list of random numbers, see the following articles.\n\nTuples and strings are also handled similarly to lists. When a string is provided, one character is returned.\n\nAn error is raised if the list, tuple, or string is empty.\n\nrandomly samples multiple elements from a list without replacement, taking a list as the first argument and the number of elements to retrieve as the second.\n\nIf the second argument is set to , a list with one element is returned. If set to , an empty list is returned. If set to a value that exceeds the number of elements of the list, an error is raised.\n\nEven when you pass a tuple or a string as the first argument, a list is returned.\n\nUse or to convert a list into a tuple or a string, respectively.\n• Convert list and tuple to each other in Python\n\nNote that if the original list or tuple contains duplicate elements, the same values may be selected.\n\nIf you want to avoid duplicate values, use to convert lists and tuples to sets, extract unique elements, and then use .\n\nStarting from Python 3.11, directly specifying a set as the first argument to will result in an error. You must explicitly convert the set to a list or a similar data structure, as demonstrated above.\n\nSpecify the number of elements you want with the argument. Since elements are chosen with replacement, can be larger than the number of elements in the original list.\n\nAs is a keyword-only argument, it is necessary to specify it like .\n\nis set to by default. If omitted, a list with one element is returned.\n\nYou can specify the weight (probability) for each element with the argument. The type of the element specified in can be either or . If a weight is set to , the corresponding element is not selected.\n\nCumulative weights can be specified with the argument. in the following code is equivalent to the former in the above code.\n\nBy default, both and are set to , so each element is selected with the same probability.\n\nAn error is raised if the length (number of elements) of or doesn't match that of the original list.\n\nAlso, an error is raised if you specify and simultaneously.\n\nLike the previous functions, also works with tuples and strings, not just lists.\n\nYou can fix the random seed and initialize the random number generator with .\n\nAfter initializing with the same seed, elements are selected in the same way."
    },
    {
        "link": "https://geeksforgeeks.org/python-random-sample-function",
        "document": "sample() is an built-in function of random module in Python that returns a particular length list of items chosen from the sequence i.e. list, tuple, string or set. Used for random sampling without replacement.\n\nSyntax : \n\nParameters:\n\nsequence : Can be a list, tuple, string, or set. \n\nk : An Integer value, it specify the length of a sample. \n\nReturns: k length new list of elements chosen from the sequence.\n\nOutput will be different everytime as it returns a random item.\n\nRaise Exception If the sample size i.e. k is larger than the sequence size, ValueError is raised."
    },
    {
        "link": "https://w3schools.com/python/module_random.asp",
        "document": "Python has a built-in module that you can use to make random numbers.\n\nThe module has a set of methods:"
    },
    {
        "link": "https://pynative.com/python-random-sample",
        "document": "In this lesson, you will learn how to use the function to choose sample/multiple items from a Python list, set, and dictionary. We will also see how to generate a random sample array from a sizeable multidimensional array in Python.\n\nPython’s random module provides a function for random sampling, randomly picking more than one element from the list without repeating elements. It returns a list of unique items chosen randomly from the list, sequence, or set. We call it random sampling without replacement.\n\nIn simple terms, for example, you have a list of 100 names, and you want to choose ten names randomly from it without repeating names, then you must use .\n\nNote: Use the random.choice() function if you want to choose only a single item from the list.\n\nYou’ll learn the following ways to generate random samples in Python\n\nHow to use\n\nIt returns a new list containing the randomly selected items.\n\nThe function takes two arguments, and both are required.\n• : It can be any sequence such as a list, set, and string from which you want to select a k length number.\n• : It is the number of random items you want to select from the sequence. must be less than the size of the specified list.\n• It raises a if you miss any of the required arguments.\n\nrandom sample() example to select multiple items from a list without repetition\n\nIn this example, we will choose three random items from a list.\n\nAs you can see in the output, the function doesn’t repeat the list items. It is also called a random sample without replacement. So use it to generate random samples without repetitions.\n• It doesn’t change the specified sequence or list. It returns a new sampled list containing elements from the specified sequence or list.\n• The specified list or sequence need not be hashable or unique.\n\nImportant Note: If your list contains repeated or duplicate elements, then can pick repeated items because each occurrence is a possible selection in the sample. It chooses the repeated items from the specified list if the unique members are less than a sampling size.\n\nLet’s see the example which demonstrates the same.\n\nUse the random.choices() function to select multiple random items from a sequence with repetition. For example, You have a list of names, and you want to choose random four names from it, and it’s okay for you if one of the names repeats.\n\nA function introduced in Python 3.6. Let see this with an example.\n\nYou can use and to generate the random numbers, but it can repeat the numbers. To create a list of unique random numbers, we need to use the sample() method.\n\nWarp a range() function inside a to create a list of random numbers without duplicates. The range() function generates the sequence f random numbers.\n\nLet’s see a random sample generator to generate 5 sample numbers from 1 to 100.\n\nOn top of it, you can use the to shuffle the list of random integers.\n\nNote: We used the range() with a to generate a list of unique random numbers because it is fast, memory-efficient, and improves the performance for sampling from a large population.\n\nPython set is an unordered collection of unique items. Same as the list, we can select random samples out of a set. Let’s see how to pick 3 random items from a .\n\nPython Dictionary is an unordered collection of unique values stored in (Key-Value) pairs.\n\nThe function requires the to be a sequence or set, and the dictionary is not a sequence. If you try to pass directly you will get TypeError: Population must be a sequence or set .\n\nSo it would be best if you used the to get all the dictionary items in the form of a list and pass it to the along with the sampling size (The number of key-value pairs you want to pick randomly out of dict).\n\nLet’s see the example to select a two samples of key-value pair from the dictionary.\n\nRandom seed to get the same sample list every time\n\nSeed the random generator to get the same sampled list of items every time from the specified list.\n\nPass the same seed value every time to get the same sampled list\n\nNote: To get the same sampled list every time, you need to find the exact seed root number.\n\nMost of the time, we work with 2d or 3d arrays in Python. Let assume you want to pick more than one random row from the multidimensional array. Use the function to pick multiple random rows from the multidimensional array.\n\nThe above all examples are not cryptographically secure. If you are creating samples for any security-sensitive application, then use a cryptographically secure random generator, use the instead of .\n\nRead more on how to generate random data in Python securely using secrets module.\n\nA sample function can raise the following two errors.\n• : If the sample size is larger than the population or sequence (i.e., list or set) size.\n• : If any of the two arguments is missing.\n\nI want to hear from you. What do you think of this article on Python random.sample()? Or maybe I missed one of the usages of . Either way, let me know by leaving a comment below.\n\nAlso, try to solve the following exercise and quiz to have a better understanding of Working with random data in Python."
    }
]