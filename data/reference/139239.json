[
    {
        "link": "https://geeksforgeeks.org/operator-overloading-cpp",
        "document": "in C++, Operator overloading is a compile-time polymorphism. It is an idea of giving special meaning to an existing operator in C++ without changing its original meaning.\n\nIn this article, we will further discuss about operator overloading in C++ with examples and see which operators we can or cannot overload in C++.\n\nC++ has the ability to provide the operators with a special meaning for a data type, this ability is known as operator overloading. Operator overloading is a compile-time polymorphism. For example, we can overload an operator ‘+’ in a class like String so that we can concatenate two strings by just using +. Other example classes where arithmetic operators may be overloaded are Complex Numbers, Fractional Numbers, Big integers, etc.\n\nHere, variables “a” and “b” are of types “int” and “float”, which are built-in data types. Hence the addition operator ‘+’ can easily add the contents of “a” and “b”. This is because the addition operator “+” is predefined to add variables of built-in data type only.\n\n\n\nIn this example, we have 3 variables “a1”, “a2” and “a3” of type “class A”. Here we are trying to add two objects “a1” and “a2”, which are of user-defined type i.e. of type “class A” using the “+” operator. This is not allowed, because the addition operator “+” is predefined to operate only on built-in data types. But here, “class A” is a user-defined type, so the compiler generates an error. This is where the concept of “Operator overloading” comes in.\n\nNow, if the user wants to make the operator “+” add two class objects, the user has to redefine the meaning of the “+” operator such that it adds two class objects. This is done by using the concept of “Operator overloading”. So the main idea behind “Operator overloading” is to use C++ operators with class variables or class objects. Redefining the meaning of operators really does not change their original meaning; instead, they have been given additional meaning along with their existing ones.\n\nExample of Operator Overloading in C++\n\nOperator functions are the same as normal functions. The only differences are, that the name of an operator function is always the operator keyword followed by the symbol of the operator, and operator functions are called when the corresponding operator is used.\n\nCan We Overload All Operators?\n\nAlmost all operators can be overloaded except a few. Following is the list of operators that cannot be overloaded.\n\nOperators that can be Overloaded in C++\n\nBut, among them, there are some operators that cannot be overloaded. They are\n\nWhy can’t the above-stated operators be overloaded?\n\nThis returns the size of the object or datatype entered as the operand. This is evaluated by the compiler and cannot be evaluated during runtime. The proper incrementing of a pointer in an array of objects relies on the sizeof operator implicitly. Altering its meaning using overloading would cause a fundamental part of the language to collapse.\n\nThis provides a CPP program with the ability to recover the actually derived type of the object referred to by a pointer or reference. For this operator, the whole point is to uniquely identify a type. If we want to make a user-defined type ‘look’ like another type, polymorphism can be used but the meaning of the typeid operator must remain unaltered, or else serious issues could arise.\n\nThis helps identify and specify the context to which an identifier refers by specifying a namespace. It is completely evaluated at runtime and works on names rather than values. The operands of scope resolution are note expressions with data types and CPP has no syntax for capturing them if it were overloaded. So it is syntactically impossible to overload this operator.\n\nThe importance and implicit use of class member access operators can be understood through the following example:\n\nThe statement ComplexNumber c3 = c1 + c2; is internally translated as ComplexNumber c3 = c1.operator+ (c2); in order to invoke the operator function. The argument c1 is implicitly passed using the ‘.’ operator. The next statement also makes use of the dot operator to access the member function print and pass c3 as an argument.\n\nBesides, these operators also work on names and not values and there is no provision (syntactically) to overload them.\n\nThe ternary or conditional operator is a shorthand representation of an if-else statement. In the operator, the true/false expressions are only evaluated on the basis of the truth value of the conditional expression.\n\nconditional statement ? expression1 (if statement is TRUE) : expression2 (else)\n\nA function overloading the ternary operator for a class say ABC using the definition\n\nwould not be able to guarantee that only one of the expressions was evaluated. Thus, the ternary operator cannot be overloaded.\n\n1) For operator overloading to work, at least one of the operands must be a user-defined class object.\n\n2) Assignment Operator: Compiler automatically creates a default assignment operator with every class. The default assignment operator does assign all members of the right side to the left side and works fine in most cases (this behavior is the same as the copy constructor). See this for more details.\n\n3) Conversion Operator: We can also write conversion operators that can be used to convert one type to another type.\n\nOverloaded conversion operators must be a member method. Other operators can either be the member method or the global method.\n\n4) Any constructor that can be called with a single argument works as a conversion constructor, which means it can also be used for implicit conversion to the class being constructed."
    },
    {
        "link": "https://en.cppreference.com/w/cpp/language/operators",
        "document": "Customizes the C++ operators for operands of user-defined types.\n\nThe behaviors of non-punctuation operators are described in their own respective pages. Unless otherwise specified, the remaining description in this page does not apply to these functions.\n\nWhen an operator appears in an expression, and at least one of its operands has a class type or an enumeration type, then overload resolution is used to determine the user-defined function to be called among all the functions whose signatures match the following:\n\nOverloaded operators (but not the built-in operators) can be called using function notation:\n• An operator function must have at least one function parameter or implicit object parameter whose type is a class, a reference to a class, an enumeration, or a reference to an enumeration.\n• The operators (scope resolution), (member access), (member access through pointer to member), and (ternary conditional) cannot be overloaded.\n• New operators such as , , or cannot be created.\n• It is not possible to change the precedence, grouping, or number of operands of operators.\n• The overload of operator must either return a raw pointer, or return an object (by reference or by value) for which operator is in turn overloaded.\n• The overloads of operators and lose short-circuit evaluation.\n\nBesides the restrictions above, the language puts no other constraints on what the overloaded operators do, or on the return type (it does not participate in overload resolution), but in general, overloaded operators are expected to behave as similar as possible to the built-in operators: operator+ is expected to add, rather than multiply its arguments, operator= is expected to assign, etc. The related operators are expected to behave similarly (operator+ and operator+= do the same addition-like operation). The return types are limited by the expressions in which the operator is expected to be used: for example, assignment operators return by reference to make it possible to write a = b = c = d, because the built-in operators allow that.\n\nCommonly overloaded operators have the following typical, canonical forms:[1]\n\nThe assignment operator operator= has special properties: see copy assignment and move assignment for details.\n\nThe canonical copy-assignment operator is expected to be safe on self-assignment, and to return the lhs by reference:\n\nIn those situations where copy assignment cannot benefit from resource reuse (it does not manage a heap-allocated array and does not have a (possibly transitive) member that does, such as a member std::vector or std::string), there is a popular convenient shorthand: the copy-and-swap assignment operator, which takes its parameter by value (thus working as both copy- and move-assignment depending on the value category of the argument), swaps with the parameter, and lets the destructor clean it up.\n\nThis form automatically provides strong exception guarantee, but prohibits resource reuse.\n\nThe overloads of and that take a std::istream& or std::ostream& as the left hand argument are known as insertion and extraction operators. Since they take the user-defined type as the right argument ( in ), they must be implemented as non-members.\n\nThese operators are sometimes implemented as friend functions.\n\nWhen a user-defined class overloads the function call operator operator(), it becomes a FunctionObject type.\n\nAn object of such a type can be used in a function call expression:\n\nMany standard library algorithms accept FunctionObjects to customize behavior. There are no particularly notable canonical forms of operator(), but to illustrate the usage:\n\nWhen the postfix increment or decrement operator appears in an expression, the corresponding user-defined function (operator++ or operator--) is called with an integer argument ​0​. Typically, it is declared as T operator++(int) or T operator--(int), where the argument is ignored. The postfix increment and decrement operators are usually implemented in terms of the prefix versions:\n\nAlthough the canonical implementations of the prefix increment and decrement operators return by reference, as with any operator overload, the return type is user-defined; for example the overloads of these operators for std::atomic return by value.\n\nBinary operators are typically implemented as non-members to maintain symmetry (for example, when adding a complex number and an integer, if operator+ is a member function of the complex type, then only complex + integer would compile, and not integer + complex). Since for every binary arithmetic operator there exists a corresponding compound assignment operator, canonical forms of binary operators are implemented in terms of their compound assignments:\n\nStandard library algorithms such as std::sort and containers such as std::set expect operator< to be defined, by default, for the user-provided types, and expect it to implement strict weak ordering (thus satisfying the Compare requirements). An idiomatic way to implement strict weak ordering for a structure is to use lexicographical comparison provided by std::tie:\n\nTypically, once operator< is provided, the other relational operators are implemented in terms of operator<.\n\nLikewise, the inequality operator is typically implemented in terms of operator==:\n\nWhen three-way comparison (such as std::memcmp or std::string::compare) is provided, all six two-way comparison operators may be expressed through that:\n\nUser-defined classes that provide array-like access that allows both reading and writing typically define two overloads for operator[]: const and non-const variants:\n\nIf the value type is known to be a scalar type, the const variant should return by value.\n\nWhere direct access to the elements of the container is not wanted or not possible or distinguishing between lvalue c[i] = v; and rvalue v = c[i]; usage, operator[] may return a proxy. See for example std::bitset::operator[].\n\nUser-defined classes and enumerations that implement the requirements of BitmaskType are required to overload the bitwise arithmetic operators operator&, operator|, operator^, operator~, operator&=, operator|=, and operator^=, and may optionally overload the shift operators operator<< operator>>, operator>>=, and operator<<=. The canonical implementations usually follow the pattern for binary arithmetic operators described above.\n\nThe following operators are rarely overloaded:\n• The address-of operator, . If the unary & is applied to an lvalue of incomplete type and the complete type declares an overloaded , it is unspecified whether the operator has the built-in meaning or the operator function is called. Because this operator may be overloaded, generic libraries use to obtain addresses of objects of user-defined types. The best known example of a canonical overloaded is the Microsoft class . An example of this operator's use in EDSL can be found in boost.spirit.\n• The boolean logic operators, and . Unlike the built-in versions, the overloads cannot implement short-circuit evaluation. Also unlike the built-in versions, they do not sequence their left operand before the right one. In the standard library, these operators are only overloaded for .\n• The comma operator, . Unlike the built-in version, the overloads do not sequence their left operand before the right one. Because this operator may be overloaded, generic libraries use expressions such as instead of to sequence execution of expressions of user-defined types. The boost library uses in boost.assign, boost.spirit, and other libraries. The database access library SOCI also overloads .\n• The member access through pointer to member . There are no specific downsides to overloading this operator, but it is rarely used in practice. It was suggested that it could be part of a smart pointer interface, and in fact is used in that capacity by actors in boost.phoenix. It is more common in EDSLs such as cpp.react.\n\nThe following behavior-changing defect reports were applied retroactively to previously published C++ standards."
    },
    {
        "link": "https://stackoverflow.com/questions/18978832/overloading-operator-for-custom-types-within-class",
        "document": "I have implementated a class for an arbitrary model as the following\n\nFurthermore, I have one custom struct/class, called , which is defined separately.\n\nMy goal is now depending on the typed cast to overload the -operator and realize a handy copy function for datalist_frames_, which is from type .\n\nIn the , I have tried the following:\n\nand then calling this by\n\nwhereas is a pointer to the instantiated class.\n\nHowever, this is not working at all. Can you help me out what is the wrong point here?"
    },
    {
        "link": "https://studyplan.dev/intro-to-programming/overloading-cout-operator",
        "document": "So far, we've been using a simple terminal prompt to view the output of our program. Later in this course, we'll switch to rendering graphics using SDL.\n\nBut, there are some useful tricks we have that can help us make the most of our terminal for building out quick programs.\n\nWe've seen how we can stream numbers and strings to the terminal using the operator:\n\nWe'd like to be able to do something similar with our custom objects. For example:\n\nTo do this, we need to overload the operator to be usable with as the left operand, and as the right operand.\n\nInspecting that in our IDE, or checking the documentation, would reveal it to be a , which is an output stream.\n\nBecause is the left operand, the reference needs to be the first argument for our overload, whilst the is the second argument. So, our overload would look like this:\n\nWith that, our code will now compile, with \"Hello World\" being streamed to the terminal:\n\nIt’s tempting to define the overload as a member function on the class, to keep everything encapsulated. However, as a member function, it would need to be defined by the type of the left operand. In this case, that is the class, not our class. The class is not our code, so extending it is quite difficult. As such, we define overloads as free functions instead. In a large project, these functions can be defined within the same files we use for the right operand’s type - eg - so our code is still kept organized.\n\nWe want to make two updates to make our overload more useful. Firstly, we want to be able to chain operators, just like we can when streaming other types. For example, we want to be able to do things like this:\n\nTo enable this, we need to ensure our overload function returns a reference to the stream we're writing to. So, we update the return type of our overload, and the stream that was used as the left operand:\n\nWith that, we can now chain additional operators after streaming a object:\n\nSecondly, we want our output to generate some meaningful output, so we can stream it rather than \"Hello World\".\n\nRepresenting the state of objects as a simple string is sometimes referred to as serialization. We’ll see more of this in the next course, as it unlocks features like saving files to the user’s hard drive and communicating over the internet, enabling programs like multiplayer games.\n\nFor now, we can just create a simple function that generates a string that stores some info about our object, in this format:\n\nTo accomplish this, we could add a public function that uses the techniques we covered in the previous lesson:\n\nFinally, let's update our overload to use this function:\n\nWith that, everything is in place. Developers can now easily stream information about our objects to like any other type:\n\nIn this lesson, we explored how to overload the operator in C++, enabling us to stream custom objects directly to the console using . Through practical examples, we demonstrated chaining operators and serializing objects for more effective output. Key topics included:\n• Understanding the concept and implementation of overloading the operator for user-defined types.\n• Learning how to make the overloaded operator compatible with by using and a reference to our custom type as parameters.\n• Exploring the technique of chaining operators by returning a reference to the stream.\n• An introduction to object serialization, through implementing a method in our class.\n\nPreview of the Next Lesson\n\nSo far, our programs have been restricted to outputting a vertical stream of text. In the next lesson, we’ll begin to introduce the concept of an application loop. This involves our program clearing the screen and regenerating new output on each iteration, which is the basis for much richer interactions."
    },
    {
        "link": "https://stackoverflow.com/questions/39909814/c-custom-type",
        "document": "I've got a class , and it is set up in a way that it can essentially be interfaced with as an (operator overloads), but there's one part I don't get.\n\nWhat operator would I need to overload to achieve referencing i32 returning it's stored value, in this case, 100 (or how else could it be done)?"
    },
    {
        "link": "https://learn.microsoft.com/en-us/cpp/standard-library/overloading-the-output-operator-for-your-own-classes?view=msvc-170",
        "document": "Overloading the Operator for Your Own Classes\n\nOutput streams use the insertion ( ) operator for standard types. You can also overload the operator for your own classes.\n\nThe function example showed the use of a structure. A date is an ideal candidate for a C++ class in which the data members (month, day, and year) are hidden from view. An output stream is the logical destination for displaying such a structure. This code displays a date using the object:\n\nTo get to accept a object after the insertion operator, overload the insertion operator to recognize an object on the left and a on the right. The overloaded operator function must then be declared as a friend of class so it can access the private data within a object.\n\nThe overloaded operator returns a reference to the original object, which means you can combine insertions:"
    },
    {
        "link": "https://stackoverflow.com/questions/476272/how-can-i-properly-overload-the-operator-for-an-ostream",
        "document": "I am writing a small matrix library in C++ for matrix operations. However, my compiler complains, where before it did not. This code was left on a shelf for six months and in between I upgraded my computer from Debian 4.0 (Etch) to Debian 5.0 (Lenny) (g++ (Debian 4.3.2-1.1) 4.3.2). However, I have the same problem on a Ubuntu system with the same g++.\n\nHere is the relevant part of my matrix class:\n\nThis is the error given by the compiler:\n\nI'm a bit confused by this error, but then again my C++ has gotten a bit rusty after doing lots of Java those six months. :-)"
    },
    {
        "link": "https://stackoverflow.com/questions/59438534/are-there-better-ways-to-overload-ostream-operator",
        "document": "I believe that the comments have answered your question well enough. From a pure performance standpoint, there likely is no \"better\" way to overload the operator for output streams because your function is likely not the bottleneck in the first place.\n\nI will suggest that there is a \"better\" way to write the function itself that handles some corner cases.\n\nYour overload, as it exists now, will 'break' when trying to perform certain output formatting operations.\n\nThis does not left align your entire output. Instead it only left aligns the member. This is because you put your items in the stream one at a time. will grab the next item to left align, which is only a part of your class output.\n\nThe easiest way is to build a string and then dump that string into your output stream. Something like this:\n\nIt's worth noting a few things here. The first is that in this specific example, you will get trailing 0's because you don't get any control over how formats its values. This may mean writing type-specific conversion functions to do any trimming for you. You may also be able to use (to gain back some efficiency (again, it likely doesn't matter as the function itself is probably still not your bottleneck)), but I have no experience with them.\n\nBy putting all of the object's information into the stream at once, that left-align will now align the full output of your object.\n\nThere is also the argument about friend vs. non-friend. If the necessary getters exist, I would argue that non-friend is the way to go. Friends are useful, but also break encapsulation since they are non-member functions with special access. This gets way into opinion territory, but I don't write simple getters unless I feel that they are necessary, and I don't count overloads as necessary."
    },
    {
        "link": "https://geeksforgeeks.org/overloading-stream-insertion-operators-c",
        "document": "In C++, stream insertion operator “<<” is used for output and extraction operator “>>” is used for input. \n\nWe must know the following things before we start overloading these operators. \n\n1) cout is an object of ostream class and cin is an object of istream class \n\n2) These operators must be overloaded as a global function. And if we want to allow them to access private data members of the class, we must make them friend. \n\nWhy these operators must be overloaded as global? \n\nIn operator overloading, if an operator is overloaded as a member, then it must be a member of the object on the left side of the operator. For example, consider the statement “ob1 + ob2” (let ob1 and ob2 be objects of two different classes). To make this statement compile, we must overload ‘+’ in a class of ‘ob1’ or make ‘+’ a global function. \n\nThe operators ‘<<‘ and ‘>>’ are called like ‘cout << ob1’ and ‘cin >> ob1’. So if we want to make them a member method, then they must be made members of ostream and istream classes, which is not a good option most of the time. Therefore, these operators are overloaded as global functions with two parameters, cout and object of user-defined class.\n\nFollowing is a complete C++ program to demonstrate overloading of <> operators."
    },
    {
        "link": "https://cplusplus.com/reference/ostream/ostream/operator%3C%3C",
        "document": ""
    }
]