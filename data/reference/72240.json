[
    {
        "link": "https://cplusplus.com/reference/string/string",
        "document": ""
    },
    {
        "link": "https://geeksforgeeks.org/cpp-string-functions",
        "document": "A string is referred to as an array of characters. In C++, a stream/sequence of characters is stored in a char array. C++ includes the std::string class that is used to represent strings. It is one of the most fundamental datatypes in C++ and it comes with a huge set of inbuilt functions. In this article, will look at the functions of string computations.\n\nCommonly Used String Functions in C++\n\nThe std::string class contains functions to provide some common string operations. The below table contains some of the most commonly used functions in C++:\n\nWe can find the length of the string (number of characters) using either length() or size() function of the std::string class.\n• This function does not take any parameter.\n• This function returns the number of characters in the string object.\n\nIt will return the length of the string text which is 13.\n\nGenerally, we can access the character of a string using the [] array subscript operator and indexing. But std::string also has a function named at() which can be used to access the characters of the string.\n• index: It represents the position of the character in the string.\n• This function returns the character present at the index.\n\nThe std::cout will print K on the console as it is the character present at index 3.\n\nWe can concatenate string in C++ using two methods:\n\nThe + operator is overloaded in the std::string class to perform string concatenation.\n\n+ operator is used to concatenate two strings. The string fullName will be \"GeeksforGeeks\".\n\nThe append() function is another member function to concatenate two strings.\n• string2: This function takes the string to be appended as a parameter. It can be both C or C++ Style string.\n\nThe append() function adds one string to the end of another.\n\nJust like the concatenation, we can do the string comparison using two methods:\n\nThe equality operator can be used to compare the two strings as it is overloaded for this operation in the std::string class.\n\nThis will return true if both the strings are equal, otherwise returns false.\n\nHere, \"Strings are not equal\" will be printed as the == operator will return false.\n\nThe compare() function is a member function of std::string class which can be used to compare two strings.\n• str2: It is the string to be compared. It can be both C or C++ style string.\n• If the strings are equal, return zero.\n• If str1 is greater than str2, return value >0\n• If str2 is greater than str1, return value <0\n\nThe result will contain a value less than zero as str2 is greater than str1.\n\nWe can also compare the substring of str2 using the compare function():\n• position: position of the first character substring.\n\nWe can use the find() function of the std::string class to check whether a given character or a substring is present in the string or a part of string.\n• var: It can be a C style string, C++ style string, or a character that is to be searched in the string.\n• It returns the pointer to the first occurrence of the character or a substring in the string.\n\nThe position variable will contain 4 which is the start of the first occurrence of the string \"Programming\" in string text.\n\nWe can use the substr() function to generate a part of the string as a new string object. It is a member function of the std::string class.\n\nSyntax of substr() in C\n• start: Starting position of the substring to be generated.\n• end: Ending of the substring to be generated.\n\nIn the above example. the sub string will contain the \"World\".\n\nThe following function allows us to modify the current string.\n\nThe insert() function not only allows us to add a string but also allows us to add it at the specified position. It is also a member function of the std::string class.\n• index: position of where to insert the new string\n\nThe replace() function replaces the part of the string with the given other string. Unlike insert, the characters in the part where the new string is to be inserted are removed.\n• index: Index of where to start replacing the new string.\n• size: length of the part of the string that is to be replaced.\n• str2: new string that is to be inserted.\n\nThe erase() function is a member function of std::string class that is used to remove a character or a part of the string.\n\nThe c_str() function is a member function that is used to convert the C++ style string i.e. std::string objects to C style string i.e. array of characters.\n• This function does not take any parameter.\n• Pointer to the equivalent array of characters.\n\nExample of String Functions in C++\n\nThe below code demonstrate the use of the above specified string functions:"
    },
    {
        "link": "https://learn.microsoft.com/en-us/cpp/standard-library/basic-string-class?view=msvc-170",
        "document": "The sequences controlled by an object of type are the Standard C++ string class and are referred to as strings, but they shouldn't be confused with the null-terminated C-style strings used throughout the C++ Standard Library. The Standard C++ string is a container that enables the use of strings as normal types, such as comparison and concatenation operations, iterators, C++ Standard Library algorithms, and copying and assigning with class allocator-managed memory. If you need to convert a Standard C++ string to a null-terminated C-style string, use the member.\n\n\n\n The data type of a single character to be stored in the string. The C++ Standard Library provides specializations of this class template, with the type definitions for elements of type , , for , for , and for .\n\n\n\n Various important properties of the elements in a basic_string specialization are described by the class . The default value is < >.\n\n\n\n The type that represents the stored allocator object that encapsulates details about the string's allocation and deallocation of memory. The default value is .\n\nThe headers that define also define the following user-defined literals, which create a string of the specified type from the input parameters.\n\nIf a function is asked to generate a sequence longer than elements, the function reports a length error by throwing an object of type .\n\nReferences, pointers, and iterators that designate elements of the controlled sequence can become invalid after any call to a function that alters the controlled sequence, or after the first call to a non- member function.\n\nA type that represents the allocator class for a string object.\n\nThe type is a synonym for the template parameter .\n\nAdds characters to the end of a string.\n\n\n\n The C-string to be appended.\n\n\n\n The string whose characters are to be appended.\n\n\n\n The index of the part of the source string supplying the characters to be appended.\n\n\n\n The number of characters to be appended, at most, from the source string.\n\n\n\n The character value to be appended.\n\n\n\n An input iterator addressing the first element in the range to be appended.\n\n\n\n An input iterator, , or addressing the position of the one beyond the last element in the range to be appended.\n\nA reference to the string object that is being appended with the characters passed by the member function.\n\nCharacters may be appended to a string using the or the member functions or . appends single-argument values while the multiple-argument member function allows a specific part of a string to be specified for adding.\n\nAssigns new character values to the contents of a string.\n\n\n\n A pointer to the characters of the C-string to be assigned to the target string.\n\n\n\n The number of characters to be assigned, from the source string.\n\n\n\n The source string whose characters are to be assigned to the target string.\n\n\n\n The character value to be assigned.\n\n\n\n An input iterator, const_pointer, or const_iterator addressing the first character in the range of the source string to be assigned to the target range.\n\n\n\n An input iterator, const_pointer, or const_iterator addressing the one beyond the last character in the range of the source string to be assigned to the target range.\n\n\n\n The position at which new characters will start to be assigned.\n\nA reference to the string object that is being assigned new characters by the member function.\n\nThe strings can be assigned new character values. The new value can be either a string and C-string or a single character. The may be used if the new value can be described by a single parameter; otherwise the member function , which has multiple parameters, can be used to specify which part of the string is to be assigned to a target string.\n\nProvides a reference to the character with a specified index in a string.\n\n\n\n The index of the position of the element to be referenced.\n\nA reference to the character of the string at the position specified by the parameter index.\n\nThe first element of the string has an index of zero and the following elements are indexed consecutively by the positive integers, so that a string of length n has an nth element indexed by the number n - 1.\n\nThe member is faster than the member function for providing read and write access to the elements of a string.\n\nThe member doesn't check whether the index passed as a parameter is valid but the member function does and so should be used if the validity isn't certain. An invalid index, which is an index less that zero or greater than or equal to the size of the string, passed to the member function throws an Class exception. An invalid index passed to the results in undefined behavior, but the index equal to the length of the string is a valid index for const strings and the operator returns the null-character when passed this index.\n\nThe reference returned may be invalidated by string reallocations or modifications for the non- strings.\n\nReturns a reference to the last element in the string.\n\nA reference to the last element of the string, which must be non-empty.\n\nConstructs a string that is empty, initialized by specific characters, or is a copy of all or part of another string object or C style (null-terminated) string.\n\n\n\n The C-string whose characters are to be used to initialize the being constructed. This value can't be a null pointer unless is zero.\n\n\n\n The storage allocator class for the string object being constructed.\n\n\n\n The number of characters to be initialized.\n\n\n\n The string to initialize the string being constructed.\n\n\n\n The index of a character in a string that is the first to be used to initialize character values for the string being constructed.\n\n\n\n The character value to be copied into the string being constructed.\n\n\n\n An input iterator, const_pointer, or const_iterator addressing the first element in the source range to be inserted.\n\n\n\n An input iterator, const_pointer, or const_iterator addressing the position of the one beyond the last element in the source range to be inserted.\n\nA reference to the string object that is being constructed by the constructors.\n\nAll constructors store a and initialize the controlled sequence. The allocator object is the argument , if present. For the copy constructor, it's , a call to . Otherwise, the allocator is .\n\nThe controlled sequence is initialized to a copy of the operand sequence specified by the remaining operands. A constructor without an operand sequence specifies an empty initial controlled sequence. If is an integer type in a template constructor, the operand sequence behaves the same as .\n\nReturns an iterator addressing the first element in the string.\n\nA random-access iterator that addresses the first element of the sequence or just beyond the end of an empty sequence.\n\nConverts the contents of a string as a C-style, null-terminated string.\n\nA pointer to the C-style version of the invoking string. The pointer value isn't valid after calling a non- function, including the destructor, in the class on the object.\n\nObjects of type string belonging to the class template aren't necessarily null terminated. The null character is used as a special character in a C-string to mark the end of the string but has no special meaning in an object of type string and may be a part of the string just like any other character. There's an automatic conversion from into strings, but the string class doesn't provide for automatic conversions from C-style strings to objects of type .\n\nThe returned C-style string shouldn't be modified, which could invalidate the pointer to the string, or deleted, as the string has a limited lifetime and is owned by the class string.\n\nReturns the largest number of elements that could be stored in a string without increasing the memory allocation of the string.\n\nThe size of storage currently allocated in memory to hold the string.\n\nThe member function returns the storage currently allocated to hold the controlled sequence, a value at least as large as .\n\nReturns a iterator that addresses the first element in the range.\n\nA random-access iterator that points at the first element of the range, or the location just beyond the end of an empty range (for an empty range, ).\n\nWith the return value of , the elements in the range can't be modified.\n\nYou can use this member function in place of the member function to guarantee that the return value is . Typically, it's used along with the type deduction keyword, as shown in the following example. In the example, consider to be a modifiable (non- ) container of any kind that supports and .\n\nReturns a iterator that addresses the location just beyond the last element in a range.\n\nA random-access iterator that points just beyond the end of the range.\n\nis used to test whether an iterator has passed the end of its range.\n\nYou can use this member function in place of the member function to guarantee that the return value is . Typically, it's used along with the type deduction keyword, as shown in the following example. In the example, consider to be a modifiable (non- ) container of any kind that supports and .\n\nThe value returned by shouldn't be dereferenced.\n\nThe string on which the member function is called will be empty.\n\nDoes a case-sensitive comparison with a specified string to determine if the two strings are equal or if one is lexicographically less than the other.\n\n\n\n The string that is to be compared to the operand string.\n\n\n\n The index of the operand string at which the comparison begins.\n\n\n\n The maximum number of characters from the operand string to be compared.\n\n\n\n The maximum number of characters from the parameter string to be compared.\n\n\n\n The index of the parameter string at which the comparison begins.\n\n\n\n The maximum number of characters from the parameter string to be compared.\n\n\n\n The C-string to be compared to the operand string.\n\nA negative value if the operand string is less than the parameter string; zero if the two strings are equal; or a positive value if the operand string is greater than the parameter string.\n\nThe member functions compare either all, or part, of the parameter and operand strings depending on which in used.\n\nA type that provides a random-access iterator that can access and read a element in the string.\n\nA type can't be used to modify the value of a character and is used to iterate through a string in a forward direction.\n\nSee the example for for an example of how to declare and use .\n\nA type that provides a pointer to a element in a string.\n\nThe type is a synonym for .\n\nFor type , it's equivalent to .\n\nPointers that are declared const must be initialized when they're declared. Const pointers always point to the same memory location and may point to constant or non-constant data.\n\nA type that provides a reference to a element stored in a string for reading and performing operations.\n\nA type can't be used to modify the value of an element.\n\nThe type is a synonym for . For type , it's equivalent to const .\n\nSee the example for for an example of how to declare and use .\n\nA type that provides a random-access iterator that can read any element in the string.\n\nA type can't modify the value of a character and is used to iterate through a string in reverse.\n\nSee the example for for an example of how to declare and use .\n\nCopies at most a specified number of characters from an indexed position in a source string to a target character array.\n\nThis method is potentially unsafe, as it relies on the caller to check that the passed values are correct. Consider using instead.\n\n\n\n The target character array to which the elements are to be copied.\n\nThe number of characters to be copied, at most, from the source string.\n\n\n\n The beginning position in the source string from which copies are to be made.\n\nA null character isn't appended to the end of the copy.\n\nReturns a const iterator that addresses the first element in a reversed string.\n\nA reverse iterator that points just beyond the end of the string. The position designates the beginning of the reverse string.\n\nReturns a iterator that addresses the location succeeding the last element in a reversed string.\n\nA reverse iterator that addresses the location succeeding the last element in a reversed string (the location that had preceded the first element in the unreversed string).\n\nCopies at most a specified number of characters from an indexed position in a source string to a target character array.\n\n\n\n The target character array to which the elements are to be copied.\n\nThe number of characters to be copied, at most, from the source string.\n\n\n\n The beginning position in the source string from which copies are to be made.\n\nA null character isn't appended to the end of the copy. This function is Microsoft specific.\n\nConverts the contents of a string into a null-terminated array of characters.\n\nA pointer to the first element of the null-terminated array containing the contents of the string. For an empty string, the pointer points to a single null character equal to .\n\nThe pointer returned by points at a valid range . Each element in the range corresponds to the current data in the string. That is, for every valid offset in the range, .\n\nIf you modify the contents of the string returned by the overload of , the behavior is undefined. You also get undefined behavior if the terminal null character is changed to any other value. The returned pointer may be invalidated if a non- reference to the string is passed to a standard library function. It can also be invalidated by a call to a non- member function. Calls to members , , , , , , , and don't invalidate the pointer.\n\nBefore C++11, didn't guarantee the returned string was null-terminated. Since C++11, and both return a null-terminated string, and are effectively the same.\n\nThe non- overload is new in C++17. To use it, specify the or later compiler option.\n\nA type that provides the difference between two iterators that refer to elements within the same string.\n\nThe signed integer type describes an object that can represent the difference between the addresses of any two elements in the controlled sequence.\n\nFor type , it's equivalent to .\n\nTests whether the string contains characters or not.\n\nif the string object contains no characters; if it has at least one character.\n\nThe member function is equivalent to == 0.\n\nReturns an iterator that addresses the location succeeding the last element in a string.\n\nReturns a random-access iterator that addresses the location succeeding the last element in a string.\n\nis often used to test whether an iterator has reached the end of its string. The value returned by shouldn't be dereferenced.\n\nIf the return value of is assigned to a , the string object can't be modified. If the return value of is assigned to an , the string object can be modified.\n\nCheck whether the string ends with the specified suffix.\n\n\n\n The single character suffix to look for.\n\n\n\n A string view containing the suffix to look for.\n\n You can pass a , which converts to a string view.\n\n\n\n Null-terminated character string containing the suffix to look for.\n\nif the string ends with the specified suffix; otherwise.\n\nis new in C++20. To use it, specify the or later compiler option.\n\nSee to check if a string starts with the specified prefix.\n\nRemoves an element or a range of elements in a string from a specified position.\n\n\n\n An iterator addressing the position of the first element in the range to be erased.\n\n\n\n An iterator addressing the position one past the last element in the range to be erased.\n\n\n\n An iterator addressing the position of the element in the string to be erased.\n\n\n\n The index of the first character in the string to be removed.\n\n\n\n The number of elements that will be removed if there are as many in the range of the string beginning with .\n\nFor the first two member functions, an iterator addressing the first character after the last character removed by the member function. For the third member function, a reference to the string object from which the elements have been erased.\n\nSearches a string in a forward direction for the first occurrence of a substring that matches a specified sequence of characters.\n\n\n\n The character value for which the member function is to search.\n\n\n\n Index of the position at which the search is to begin.\n\n\n\n The C-string for which the member function is to search.\n\n\n\n The number of characters, counting forward from the first character, in the C-string for which the member function is to search.\n\n\n\n The string for which the member function is to search.\n\nThe index of the first character of the substring searched for when successful; otherwise .\n\nSearches through a string for the first character that isn't an element of a specified string.\n\n\n\n The character value for which the member function is to search.\n\n\n\n Index of the position at which the search is to begin.\n\n\n\n The C-string for which the member function is to search.\n\n\n\n The number of characters, counting forward from the first character, in the C-string for which the member function is to search.\n\n\n\n The string for which the member function is to search.\n\nThe index of the first character of the substring searched for when successful; otherwise .\n\nSearches through a string for the first character that matches any element of a specified string.\n\n\n\n The character value for which the member function is to search.\n\n\n\n Index of the position at which the search is to begin.\n\n\n\n The C-string for which the member function is to search.\n\n\n\n The number of characters, counting forward from the first character, in the C-string for which the member function is to search.\n\n\n\n The string for which the member function is to search.\n\nThe index of the first character of the substring searched for when successful; otherwise .\n\nSearches through a string for the last character that isn't any element of a specified string.\n\n\n\n The character value for which the member function is to search.\n\n\n\n Index of the position at which the search is to finish.\n\n\n\n The C-string for which the member function is to search.\n\n\n\n The number of characters, counting forward from the first character, in the C-string for which the member function is to search.\n\n\n\n The string for which the member function is to search.\n\nThe index of the first character of the substring searched for when successful; otherwise .\n\nSearches through a string for the last character that matches any element of a specified string.\n\n\n\n The character value for which the member function is to search.\n\n\n\n Index of the position at which the search is to finish.\n\n\n\n The C-string for which the member function is to search.\n\n\n\n The number of characters, counting forward from the first character, in the C-string for which the member function is to search.\n\n\n\n The string for which the member function is to search.\n\nThe index of the last character of the substring searched for when successful; otherwise .\n\nReturns a reference to the first element in a string.\n\nA reference to the first element of the string, which must be non-empty.\n\nReturns a copy of the allocator object used to construct the string.\n\nThe allocator used by the string.\n\nAllocators for the string class specify how the class manages storage. The default allocators supplied with container classes are sufficient for most programming needs. Writing and using your own allocator class is an advanced C++ feature.\n\nInserts an element, several elements, or a range of elements into the string at a specified position.\n\n\n\n The index of the position behind the point of insertion the new characters.\n\n\n\n The C-string to be wholly or partly inserted into the string.\n\n\n\n The number of characters to be inserted.\n\n\n\n The string to be wholly or partly inserted into the target string.\n\n\n\n The index of the part of the source string supplying the characters to be appended.\n\n\n\n The character value of the elements to be inserted.\n\n\n\n An iterator addressing the position behind which a character is to be inserted.\n\n\n\n An input iterator, , or addressing the first element in the source range to be inserted.\n\n\n\n An input iterator, , or addressing the position of the one beyond the last element in the source range to be inserted.\n\nThe functions that return a value return either:\n• A reference to the that contains the original string plus the new characters.\n• An iterator at the start of the inserted character(s).\n\nA type that provides a random-access iterator that can access and read a element in the string.\n\nA type can be used to modify the value of a character and is used to iterate through a string in a forward direction.\n\nSee the example for for an example of how to declare and use .\n\nReturns the current number of elements in a string.\n\nThe member function is the same as .\n\nReturns the maximum number of characters a string could contain.\n\nThe maximum number of characters a string could contain.\n\nAn exception of type Class is thrown when an operation produces a string with a length greater than the maximum size.\n\nAn unsigned integral value initialized to -1 that indicates either \"not found\" or \"all remaining characters\" when a search function fails.\n\nWhen the return value is to be checked for the value, it might not work unless the return value is of type and not either or .\n\nSee the example for for an example of how to declare and use .\n\n\n\n The character to be appended.\n\n\n\n The characters of the C-string to be appended.\n\n\n\n The characters of the string to be appended.\n\nA reference to the string object that is being appended with the characters passed by the member function.\n\nCharacters may be appended to a string using the or the member functions or . The appends single-argument values while the multiple argument append member function allows a specific part of a string to be specified for adding.\n\nAssigns new character values to the contents of a string.\n\n\n\n The character value to be assigned.\n\n\n\n A pointer to the characters of the C-string to be assigned to the target string.\n\n\n\n The source string whose characters are to be assigned to the target string.\n\nA reference to the string object that is being assigned new characters by the member function.\n\nThe strings may be assigned new character values. The new value may be either a string and C-string or a single character. The may be used if the new value can be described by a single parameter, otherwise the member function , which has multiple parameters, may be used to specify which part of the string is to be assigned to a target string.\n\nProvides a reference to the character with a specified index in a string.\n\n\n\n The index of the position of the element to be referenced.\n\nA reference to the character of the string at the position specified by the parameter index.\n\nThe first element of the string has an index of zero, and the following elements are indexed consecutively by the positive integers. It means that a string of length n has an nth element indexed by the number n - 1.\n\nis faster than the member function for providing read and write access to the elements of a string.\n\ndoesn't check whether the index passed as a parameter is valid, but the member function does and so should be used in the validity isn't certain. An invalid index (an index less that zero or greater than or equal to the size of the string) passed to the member function throws an Class exception. An invalid index passed to results in undefined behavior, but the index equal to the length of the string is a valid index for const strings and the operator returns the null character when passed this index.\n\nThe reference returned may be invalidated by string reallocations or modifications for the non- strings.\n\nWhen compiling with set to 1 or 2, a runtime error will occur if you attempt to access an element outside the bounds of the string. For more information, see Checked Iterators.\n\nA type that provides a pointer to a character element in a string or character array.\n\nThe type is a synonym for .\n\nFor type , it's equivalent to .\n\nErases the last element of the string.\n\nThis member function effectively calls to erase the last element of the sequence, which must be non-empty.\n\nAdds an element to the end of the string.\n\n\n\n The character to be added to the end of the string.\n\nThe member function effectively calls . For more information, see and .\n\nReturns an iterator to the first element in a reversed string.\n\nReturns a random-access iterator to the first element in a reversed string, addressing what would be the last element in the corresponding unreversed string.\n\nis used with a reversed string just as is used with a string.\n\nIf the return value of is assigned to a , the string object can't be modified. If the return value of is assigned to a , the string object can be modified.\n\ncan be used to initialize an iteration through a string backwards.\n\nA type that provides a reference to an element stored in a string.\n\nA type can be used to modify the value of an element.\n\nThe type is a synonym for .\n\nFor type , it's equivalent to .\n\nSee the example for for an example of how to declare and use .\n\nReturns an iterator that addresses the location succeeding the last element in a reversed string.\n\nA reverse random-access iterator that addresses the location succeeding the last element in a reversed string.\n\nis used with a reversed string just as is used with a string.\n\nIf the return value of is assigned to a , the string object can't be modified. If the return value of is assigned to a , the string object can be modified.\n\ncan be used to test whether a reverse iterator has reached the end of its string.\n\nThe value returned by shouldn't be dereferenced.\n\nReplaces elements in a string at a specified position with specified characters, or with characters copied from other ranges, strings, or C-strings.\n\n\n\n The string that is to be a source of characters for the operand string.\n\n\n\n The index of the operand string at which the replacement begins.\n\n\n\n The maximum number of characters to be replaced in the operand string.\n\n\n\n The index of the parameter string at which the copying begins.\n\n\n\n The maximum number of characters to be used from the parameter C-string.\n\n\n\n The C-string that is to be a source of characters for the operand string.\n\n\n\n The character to be copied into the operand string.\n\n\n\n An iterator addressing the first character to be removed in the operand string.\n\n\n\n An iterator addressing the last character to be removed in the operand string.\n\n\n\n An iterator, const_pointer, or const_iterator addressing the first character to be copied in the parameter string.\n\n\n\n An iterator, const_pointer, or const_iterator addressing the last character to be copied in the parameter string.\n\n\n\n The number of times is copied into the operand string.\n\nThe operand string with the replacement made.\n\nSets the capacity of the string to a number at least as great as a specified number.\n\n\n\n The number of characters for which memory is being reserved.\n\nHaving sufficient capacity is important because reallocation is a time-consuming process. And, it invalidates all references, pointers, and iterators that refer to characters in a string.\n\nThe concept of capacity for string object types is the same as for objects of type . Unlike , the member function may be called to shrink the capacity of an object. The request is nonbinding and may or may not happen. As the default value for the parameter is zero, a call of is a non-binding request to shrink the capacity of the string to fit the number of characters currently in the string. The capacity is never reduced below the current number of characters.\n\nCalling is the only possible way to shrink the capacity of a string. However, as noted above, this request is nonbinding and may not happen.\n\nSpecifies a new size for a string, appending or erasing elements as required.\n\n\n\n The new size of the string.\n\n\n\n The value that appended characters are initialized with, if more elements are required.\n\nIf the resulting size exceeds the maximum number of characters, the form throws .\n\nA type that provides a reference to an element stored in a string.\n\nA type can be used to modify the value of a character and is used to iterate through a string in reverse.\n\nSee the example for for an example of how to declare and use .\n\nSearches a string in a backward direction for the first occurrence of a substring that matches a specified sequence of characters.\n\n\n\n The character value for which the member function is to search.\n\n\n\n Index of the position at which the search is to begin.\n\n\n\n The C-string for which the member function is to search.\n\n\n\n The number of characters, counting forward from the first character, in the C-string for which the member function is to search.\n\n\n\n The string for which the member function is to search.\n\nThe index of the last occurrence, when searched backwards, of the first character of the substring when successful; otherwise .\n\nDiscards the excess capacity of the string.\n\nThis member function eliminates any unneeded storage in the container.\n\nReturns the current number of elements in a string.\n\nThe length of the string.\n\nAn unsigned integer type that can represent the number of elements and indices in a string.\n\nFor type , it's equivalent to .\n\nCheck whether the string starts with the specified prefix.\n\n\n\n The single character prefix to look for.\n\n\n\n A string view containing the prefix to look for.\n\n You can pass a , which converts to a string view.\n\n\n\n Null-terminated character string containing the prefix to look for.\n\nif the string starts with the specified prefix; otherwise.\n\nis new in C++20. To use it, specify the or later compiler option.\n\nSee to see if a string ends with the specified suffix.\n\nCopies a substring of at most some number of characters from a string beginning from a specified position.\n\n\n\n An index locating the element at the position from which the copy of the string is made, with a default value of 0.\n\n\n\n The number of characters that are to be copied if they're present.\n\nA substring object that's a copy of elements of the string operand, beginning at the position specified by the first argument.\n\nExchange the contents of two strings.\n\n\n\n The source string whose elements are to be exchanged with the ones in the destination string.\n\nIf the strings being swapped have the same allocator object, the member function:\n• Invalidates no references, pointers, or iterators that designate elements in the two strings.\n\nOtherwise, it makes element assignments and constructor calls proportional to the number of elements in the two controlled sequences.\n\nA type for the character traits of the elements stored in a string.\n\nThe type is a synonym for the second template parameter .\n\nFor type , it's equivalent to .\n\nSee the example for for an example of how to declare and use .\n\nA type that represents the type of characters stored in a string.\n\nIt's equivalent to and is equivalent to for objects of type .\n\n\n\n Thread safety in the C++ standard library"
    },
    {
        "link": "https://en.cppreference.com/w/cpp/string/basic_string",
        "document": "The class template stores and manipulates sequences of character-like objects, which are non-array objects of TrivialType and StandardLayoutType. The class is dependent neither on the character type nor on the nature of operations on that type. The definitions of the operations are supplied via the template parameter - a specialization of std::char_traits or a compatible traits class.\n\nThe elements of a are stored contiguously, that is, for a s, &*(s.begin() + n) == &*s.begin() + n for any n in ​0​ s.size() , and *(s.begin() + s.size()) has value CharT() (a null terminator)(since C++11); or, equivalently, a pointer to s[0] can be passed to functions that expect a pointer to the first element of an array(until C++11)a null-terminated array(since C++11) of .\n\nsatisfies the requirements of AllocatorAwareContainer (except that customized / are not used for construction/destruction of elements), SequenceContainer and ContiguousContainer(since C++17).\n\nIf any of and is different from , the program is ill-formed.\n\nAll member functions of are constexpr: it is possible to create and use objects in the evaluation of a constant expression. However, objects generally cannot be constexpr, because any dynamically allocated storage must be released in the same evaluation of constant expression.\n\nSeveral typedefs for common character types are provided:\n\nReferences, pointers, and iterators referring to the elements of a may be invalidated by any standard library function taking a reference to non-const as an argument, such as std::getline, std::swap, or , and by calling non-const member functions, except , , , , , , , , and .\n\nAlthough it is required that customized or is used when constructing or destroying elements of until C++23, all implementations only used the default mechanism. The requirement is corrected by P1072R10 to match existing practice.\n\nThe following behavior-changing defect reports were applied retroactively to previously published C++ standards."
    },
    {
        "link": "https://geeksforgeeks.org/stdstring-class-in-c",
        "document": "C++ has in its definition a way to represent a sequence of characters as an object of the class. This class is called std:: string. The string class stores the characters as a sequence of bytes with the functionality of allowing access to the single-byte character.\n\nclass that defines objects that be represented as a stream of characters. array of characters that can be terminated by a null character. In the case of strings, memory is allocated dynamically . More memory can be allocated at run time on demand. As no memory is preallocated, no memory is wasted The size of the character array has to be allocated statically , more memory cannot be allocated at run time if required. Unused allocated memory is also wasted As strings are represented as objects, no array decay threat of array decay in the case of the character array. Strings are slower when compared to implementation than character array. a number of functionalities that allow manifold operations on strings.\n\nSpace Complexity: O(n) where n is the size of the string\n\nThis function returns the capacity allocated to the string, which can be equal to or more than the size of the string. Additional space is allocated so that when the new characters are added to the string, the operations can be done efficiently. This function changes the size of the string, the size can be increased or decreased. This function finds the length of the string. This function decreases the capacity of the string and makes it equal to the minimum capacity of the string. This operation is useful to save additional memory if we are sure that no further addition of characters has to be made.\n\nSpace Complexity: O(n) where n is the size of the string\n\nThis function returns an iterator to the beginning of the string. This function returns an iterator to the next to the end of the string. This function returns a reverse iterator pointing at the end of the string. This function returns a reverse iterator pointing to the previous of beginning of the string. This function returns a constant iterator pointing to the beginning of the string, it cannot be used to modify the contents it points-to. This function returns a constant iterator pointing to the next of end of the string, it cannot be used to modify the contents it points-to. This function returns a constant reverse iterator pointing to the end of the string, it cannot be used to modify the contents it points-to. This function returns a constant reverse iterator pointing to the previous of beginning of the string, it cannot be used to modify the contents it points-to.\n\nSpace Complexity: O(n) where n is the size of the string\n\n\n\nMust Read: C++ String Class and its Applications"
    },
    {
        "link": "https://stackoverflow.com/questions/545907/what-is-the-best-way-to-do-input-validation-in-c-with-cin",
        "document": "Here is code you could use to make sure you also reject things like\n\nWhere non-number characters follow the number. If you read the whole line and then parse it and execute actions appropriately it will possibly require you to change the way your program works. If your program read your number from different places until now, you then have to put one central place that parses one line of input, and decides on the action. But maybe that's a good thing too - so you could increase the readability of the code that way by having things separated: Input - Processing - Output\n\nAnyway, here is how you can reject the number-non-number of above. Read a line into a string, then parse it with a :\n\nIt eats all trailing whitespace. When it hits the end-of-file of the stringstream while reading the integer or trailing whitespace, then it sets the eof-bit, and we check that. If it failed to read any integer in the first place, then the fail or bad bit will have been set.\n\nEarlier versions of this answer used directly - but won't work well together with connected to a terminal (it will block instead waiting for the user to input something), so we use a for reading the integer.\n\nAnswering some of your questions:\n\nQuestion: 1. Using a try catch block. It didn't work. I think this is because an exception is not raised due to bad input.\n\nAnswer: Well, you can tell the stream to throw exceptions when you read something. You use the function, which you tell for which kind of error you want to have an exception thrown:\n\nI did never use it. If you do that on , you will have to remember to restore the flags for other readers that rely on it not throwing. Finding it way easier to just use the functions fail, bad to ask for the state of the stream.\n\nQuestion: 2. I tried which didn't work either. I haven't yet figured this one out.\n\nAnswer: That could come from the fact that you gave it something like \"42crap\". For the stream, that is completely valid input when doing an extraction into an integer.\n\nQuestion: 3. Thirdly, I tried inputting a fixed length string and then parsing it. I would use atoi(). Is this standards compliant and portable? Should I write my own parsing function?\n\nAnswer: atoi is Standard Compliant. But it's not good when you want to check for errors. There is no error checking, done by it as opposed to other functions. If you have a string and want to check whether it contains a number, then do it like in the initial code above.\n\nThere are C-like functions that can read directly from a C-string. They exist to allow interaction with old, legacy code and writing fast performing code. One should avoid them in programs because they work rather low-level and require using raw naked pointers. By their very nature, they can't be enhanced to work with user defined types either. Specifically, this talks about the function \"strtol\" (string-to-long) which is basically atoi with error checking and capability to work with other bases (hex for example).\n\nQuestion: 4. If I write a class that uses cin, but dynamically do this kind of error detection, perhaps by determining the type of the input variable at runtime, will it have too much overhead? Is it even possible?\n\nAnswer: Generally, you don't need to care too much about overhead here (if you mean runtime-overhead). But it depends specifically on where you use that class. That question will be very important if you are writing a high performance system that processes input and needs to have high throughout. But if you need to read input from a terminal or a file, you already see what this comes down to: Waiting for the user to input something takes really so long, you don't need to watch runtime costs at this point anymore on this scale.\n\nIf you mean code overhead - well it depends on how the code is implemented. You would need to scan your string that you read - whether it contains a number or not, whether some arbitrary string. Depending on what you want to scan (maybe you have a \"date\" input, or a \"time\" input format too. Look into for that), your code can become arbitrarily complex. For simple things like classifying between number or not, I think you can get away with small amount of code."
    },
    {
        "link": "https://labex.io/tutorials/c-how-to-validate-input-in-c-programming-425511",
        "document": "Input validation is a critical aspect of robust C programming that ensures the reliability and security of software applications. This tutorial explores comprehensive techniques for validating user inputs, helping developers prevent potential vulnerabilities and improve the overall quality of their C programs by implementing systematic input checking methods.\n\n%%%%{init: {'theme':'neutral'}}%%%% flowchart RL c((\"C\")) -.-> c/FunctionsGroup([\"Functions\"]) c((\"C\")) -.-> c/UserInteractionGroup([\"User Interaction\"]) c((\"C\")) -.-> c/BasicsGroup([\"Basics\"]) c((\"C\")) -.-> c/ControlFlowGroup([\"Control Flow\"]) c/BasicsGroup -.-> c/operators(\"Operators\") c/ControlFlowGroup -.-> c/if_else(\"If...Else\") c/FunctionsGroup -.-> c/function_declaration(\"Function Declaration\") c/FunctionsGroup -.-> c/function_parameters(\"Function Parameters\") c/UserInteractionGroup -.-> c/user_input(\"User Input\") subgraph Lab Skills c/operators -.-> lab-425511{{\"How to validate input in C programming\"}} c/if_else -.-> lab-425511{{\"How to validate input in C programming\"}} c/function_declaration -.-> lab-425511{{\"How to validate input in C programming\"}} c/function_parameters -.-> lab-425511{{\"How to validate input in C programming\"}} c/user_input -.-> lab-425511{{\"How to validate input in C programming\"}} end"
    },
    {
        "link": "https://devzery.com/post/guide-to-yn-c",
        "document": "In the world of C programming, user input validation is crucial for creating robust and error-free applications. One common scenario is asking users a simple yes/no question and validating their response. This guide will walk you through everything you need to know about implementing \"yn c\" (yes/no user input validation) in C. We'll cover various methods, best practices, and common pitfalls to avoid, ensuring you can handle user input effectively in your programs.\n\nWhat is \"yn c\"?\n\n\"yn c\" refers to the process of asking users a yes/no question and validating their response in the C programming language. This often involves prompting the user to enter 'y' for yes or 'n' for no and ensuring the input is valid before proceeding.\n\nWhy User Input Validation is Important in C\n\nBest Practices for Implementing \"yn c\"\n\nImplementing \"yn c\" or yes/no user input validation in C is essential for creating interactive and user-friendly applications. By following the techniques and best practices outlined in this guide, you can ensure your programs handle user input effectively and securely."
    },
    {
        "link": "https://stackoverflow.com/questions/66784977/how-can-i-create-a-validate-function-that-would-validate-the-input-from-the-user",
        "document": "I am validating user input using Regular Expressions in C++, but the problem I'm facing is that the code is very repetitive. I'd like to have a function that simply takes in the variable to which the user is inputting a value and its defined RE as arguments, validating these inputs and only then allowing the user to move on to the next input. At the current moment I'm doing this like so:\n\nI have a few more inputs that follow the same pattern, but I would like to avoid that."
    },
    {
        "link": "https://wiki.sei.cmu.edu/confluence/display/c/API00-C.+Functions+should+validate+their+parameters",
        "document": "Redundant testing by caller and by callee as a style of defensive programming is largely discredited in the C and C++ communities, the main problem being performance. The usual discipline in C and C++ is to require validation on only one side of each interface.\n\nRequiring the caller to validate arguments can result in faster code because the caller may understand certain invariants that prevent invalid values from being passed. Requiring the callee to validate arguments allows the validation code to be encapsulated in one location, reducing the size of the code and making it more likely that these checks are performed in a consistent and correct fashion.\n\nFor safety and security reasons, this standard recommends that the called function validate its parameters. Validity checks allow the function to survive at least some forms of improper usage, enabling an application using the function to likewise survive. Validity checks can also simplify the task of determining the condition that caused the invalid parameter.\n\nIn this noncompliant code example, and do not validate their parameters. It is possible that an invalid file pointer can be used by the library, corrupting the library's internal state and exposing a vulnerability.\n\nThe vulnerability can be more severe if the internal state references sensitive or system-critical data.\n\nValidating the function parameters and verifying the internal state leads to consistency of program execution and may eliminate potential vulnerabilities. In addition, implementing commit or rollback semantics (leaving program state unchanged on error) is a desirable practice for error safety.\n\nFailing to validate the parameters in library functions may result in an access violation or a data integrity violation. Such a scenario indicates a flaw in how the library is used by the calling code. However, the library itself may still be the vector by which the calling code's vulnerability is exploited.\n\nSearch for vulnerabilities resulting from the violation of this rule on the CERT website."
    }
]