[
    {
        "link": "https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.reset_index.html",
        "document": "Reset the index, or a level of it.\n\nReset the index of the DataFrame, and use the default one instead. If the DataFrame has a MultiIndex, this method can remove one or more levels.\n\nOnly remove the given levels from the index. Removes all levels by default. Do not try to insert index into dataframe columns. This resets the index to the default integer index. Whether to modify the DataFrame rather than creating a new one. If the columns have multiple levels, determines which level the labels are inserted into. By default it is inserted into the first level. If the columns have multiple levels, determines how the other levels are named. If None then the index name is repeated. Allow duplicate column labels to be created. Using the given string, rename the DataFrame column which contains the index data. If the DataFrame has a MultiIndex, this has to be a list or tuple with length equal to the number of levels. DataFrame with the new index or None if .\n\nWhen we reset the index, the old index is added as a column, and a new sequential index is used:\n\nWe can use the parameter to avoid the old index being added as a column:\n\nYou can also use with .\n\nUsing the parameter, choose a name for the index column:\n\nIf the index has multiple levels, we can reset a subset of them:\n\nIf we are not dropping the index, by default, it is placed in the top level. We can place it in another level:\n\nWhen the index is inserted under another level, we can specify under which one with the parameter :\n\nIf we specify a nonexistent level for , it is created:"
    },
    {
        "link": "https://geeksforgeeks.org/python-pandas-dataframe-reset_index",
        "document": "In Pandas, reset_index() method is used to reset the index of a DataFrame. By default, it creates a new integer-based index starting from 0, making the DataFrame easier to work with in certain cases.\n• level: Specifies the index level(s) to remove or reset. It can be an integer, string, or a list of levels.\n• drop: If True, it removes the index column entirely instead of adding it as a column in the DataFrame.\n• inplace: If True, modifies the original DataFrame in place. By default, it’s False, and a new DataFrame is returned.\n• col_level: Used to select the level of the column to insert the index labels.\n• col_fill: If the DataFrame has multiple columns, this determines how missing levels are filled in the column headers.\n\nIn this example, we will set the “First Name” column as the index and then reset the index using .\n\nAfter running the code, a new index will be generated starting from 0, with a new column named level_0 containing the original index value\n\nIf you are working with a multi-level index, you may want to reset only one or more specific levels. In this case, we reset the third level of the multi-level index.\n• Simplifying Data Manipulation: After performing operations like filtering or sorting, you might want to reset the index to have a clean, sequential index.\n• Handling Multi-Level Indexes: reset_index() can be used to remove specific index levels without affecting the rest of the structure.\n• Restoring Default Index: If you’ve set a custom index using the set_index() reset_index()"
    },
    {
        "link": "https://pandas.pydata.org/docs/reference/general_functions.html",
        "document": "Compute a simple cross tabulation of two (or more) factors.\n\nEncode the object as an enumerated type or categorical variable."
    },
    {
        "link": "https://stackoverflow.com/questions/20490274/how-to-reset-index-in-a-pandas-dataframe",
        "document": "I have a dataframe from which I remove some rows. As a result, I get a dataframe in which index is something like and I would like to reset it to . How can I do it?\n\nThe following seems to work:\n\nThe following does not work:"
    },
    {
        "link": "https://docs.vultr.com/python/third-party/pandas/DataFrame/reset_index",
        "document": "Handling data effectively in Python often involves the use of Pandas DataFrames, a powerful tool for data manipulation and analysis. One common task you might face while working with DataFrames is resetting their index. The method is crucial when you need to transform the index of your DataFrame into a more suitable format after operations like sorting, filtering, or subsetting have altered the structure of the DataFrame.\n\nIn this article, you will learn how to utilize the method in various contexts. Explore how to reset the index to the default integer index, work with the and parameters to modify the DataFrame directly, and understand how to incorporate the previous index as a column in the DataFrame.\n• None Use to reset the index. This example starts with a DataFrame that has a custom index ('x', 'y', 'z'). The method resets the DataFrame's index to the default integer index, and the original index becomes a new column in the DataFrame.\n• None Understand the purpose of the parameter, which removes the existing index and does not add it as a column in the DataFrame.\n• In this case, tells Pandas not to retain the old index. After using , the original index is discarded, and the DataFrame retains only its data columns.\n• None Learn about , which allows the modifications to affect the original DataFrame without creating a new object.\n• Applying in combination with modifies directly, resetting its index in place and discarding the old index, so itself is updated without needing to reassign it to a new variable.\n• None Recognize the use of in DataFrames with multiple levels of indexing.\n• None Demonstrate resetting the level and how to handle multiple indices. In multi-index scenarios, the method converts each level of the index into separate columns. The resulting DataFrame has a default numerical index and includes the former index levels as columns.\n• None Understand how to specify levels to reset in multi-index.\n• None Reset only certain levels using the parameter. This code snippet resets only the 'second' level of the index. The 'first' level remains intact as part of the DataFrame's index. This flexibility allows precise control over which parts of the index are turned into columns.\n\nThe function in Python's Pandas library is a versatile tool for managing DataFrame indices. Whether handling simple, single-level indexes, or navigating the complexities of multi-level indexing, this method provides a straightforward approach for reformatting and manipulating DataFrame indices. Use to make your DataFrames easier to work with, especially after operations that modify the DataFrame structure."
    },
    {
        "link": "https://kernc.github.io/backtesting.py/doc/backtesting/backtesting.html",
        "document": "Backtest a particular (parameterized) strategy on particular data. Initialize a backtest. Requires data and a strategy to test. After initialization, you can call method to run a backtest instance, or to optimize it. is a with columns: , , , , and (optionally) . If any columns are missing, set them to what you have available, e.g. The passed data frame can contain additional columns that can be used by the strategy (e.g. sentiment info). DataFrame index can be either a datetime index (timestamps) or a monotonic range index (i.e. a sequence of periods). is a subclass (not an instance). is the initial cash to start with. is the the constant bid-ask spread rate (relative to the price). E.g. set it to for commission-less forex trading where the average spread is roughly 0.2‰ of the asking price. is the commission rate. E.g. if your broker's commission is 1% of order value, set commission to . The commission is applied twice: at trade entry and at trade exit. Besides one single floating value, can also be a tuple of floating values . E.g. set it to if your broker charges minimum $100 + 1%. Additionally, can be a callable (note, order size is negative for short orders), which can be used to model more complex commission structures. Negative commission values are interpreted as market-maker's rebates. Before v0.4.0, the commission was only applied once, like is now. If you want to keep the old behavior, simply set instead. With nonzero , long and short orders will be placed at an adjusted price that is slightly higher or lower (respectively) than the current price. See e.g. #153, #538, #633. is the required margin (ratio) of a leveraged account. No difference is made between initial and maintenance margins. To run the backtest using e.g. 50:1 leverge that your broker allows, set margin to (1 / leverage). If is , market orders will be filled with respect to the current bar's closing price instead of the next bar's open. If is , allow trades in both directions simultaneously. If , the opposite-facing orders first close existing trades in a FIFO manner. If is , each new order auto-closes the previous trade/position, making at most a single trade (long or short) in effect at each time. If is , the trades that are still active and ongoing at the end of the backtest will be closed on the last bar and will contribute to the computed backtest statistics. See also if you want to trade fractional units (of e.g. bitcoin). Optimize strategy parameters to an optimal combination. Returns result of the best run. is a string key from the -returned results series, or a function that accepts this series object and returns a number; the higher the better. By default, the method maximizes Van Tharp's System Quality Number. is the optimization method. Currently two methods are supported:\n• which does an exhaustive (or randomized) search over the cartesian product of parameter combinations, and\n• which finds close-to-optimal strategy parameters using model-based optimization, making at most evaluations. is the maximal number of strategy runs to perform. If , this results in randomized grid search. If is a floating value between (0, 1], this sets the number of runs to approximately that fraction of full grid space. Alternatively, if integer, it denotes the absolute maximum number of evaluations. If unspecified (default), grid search is exhaustive, whereas for , is set to 200. is a function that accepts a dict-like object of parameters (with values) and returns when the combination is admissible to test with. By default, any parameters combination is considered admissible. If is , besides returning the result series, an additional is returned with a multiindex of all admissible parameter combinations, which can be further inspected or projected onto 2D to plot a heatmap (see ). If is True and , in addition to result series (and maybe heatmap), return raw for further inspection, e.g. with SAMBO's plotting tools. If you want reproducible optimization results, set to a fixed integer random seed. Additional keyword arguments represent strategy arguments with list-like collections of possible values. For example, the following code finds and returns the \"best\" of the 7 admissible (of the 9 possible) parameter combinations: Plot the progression of the last backtest run. If is provided, it should be a particular result such as returned by or , otherwise the last run's results are used. is the path to save the interactive HTML plot to. By default, a strategy/parameter-dependent file is created in the current working directory. is the width of the plot in pixels. If None (default), the plot is made to span 100% of browser width. The height is currently non-adjustable. If is , the resulting plot will contain an equity (initial cash plus assets) graph section. This is the same as plus initial 100%. If is , the resulting plot will contain a cumulative return graph section. This is the same as minus initial 100%. If is , the resulting plot will contain a profit/loss (P/L) indicator section. If is , the resulting plot will contain a trade volume section. If is , the resulting plot will contain a separate drawdown graph section. If is , the stretches between trade entries and trade exits are marked by hash-marked tractor beams. If is , the equity graph will be interpolated between fixed points at trade closing times, unaffected by any interim asset volatility. If is , scale and label equity graph axis with return percent, not absolute cash-equivalent values. If is , superimpose larger-timeframe candlesticks over the original candlestick chart. Default downsampling rule is: monthly for daily data, daily for hourly data, hourly for minute data, and minute for (sub-)second data. can also be a valid Pandas offset string, such as or , in which case this frequency will be used to superimpose. Note, this only works for data with a datetime index. If is , the OHLC data is resampled in a way that makes the upper number of candles for Bokeh to plot limited to 10_000. This may, in situations of overabundant data, improve plot's interactive performance and avoid browser's or similar. Equity & dropdown curves and individual trades data is, likewise, reasonably aggregated. can also be a Pandas offset string, such as or , in which case this frequency will be used to resample, overriding above numeric limitation. Note, all this only works for data with a datetime index. If is , the indicators below the OHLC chart are plotted in reverse order of declaration. If is , the resulting plot graphs will contain labeled legends. If is , the resulting will be opened in the default web browser. Run the backtest. Returns with results and statistics. You may obtain different results for different strategy parameters. E.g. if you use 50- and 200-bar SMA, the trading simulation will begin on bar 201. The actual length of delay is equal to the lookback period of the indicator which lags the most. Obviously, this can affect results.\n\nPlace new orders through and . Query existing orders through . When an order is executed or filled, it results in a . If you wish to modify aspects of a placed but not yet filled order, cancel it and place a new one instead. All placed orders are Good 'Til Canceled. True for contingent orders, i.e. OCO stop-loss and take-profit bracket orders placed upon an active trade. Remaining contingent orders are canceled when their parent is closed. You can modify contingent orders through and . True if the order is long (order size is positive). True if the order is short (order size is negative). Order limit price for limit orders, or None for market orders, which are filled at next available price. If size is a value between 0 and 1, it is interpreted as a fraction of current available liquidity (cash plus minus used margin). A value greater than or equal to 1 indicates an absolute number of units. A stop-loss price at which, if set, a new contingent stop-market order will be placed upon the following this order's execution. See also . Order stop price for stop-limit/stop-market order, otherwise None if no stop was set, or the stop price has already been hit. Arbitrary value (such as a string) which, if set, enables tracking of this order and the associated (see ). A take-profit price at which, if set, a new contingent limit order will be placed upon the following this order's execution. See also .\n\nA trading strategy base class. Extend this class and override methods and to define your own strategy. Price data, roughly as passed into , but with two significant exceptions:\n• is not a DataFrame, but a custom structure that serves customized numpy arrays for reasons of performance and convenience. Besides OHLCV columns, and length, it offers property, the smallest price unit of change.\n• Within , arrays are available in full length, as passed into (for precomputing indicators and such). However, within , arrays are only as long as the current iteration, simulating gradual price point revelation. In each call of (iteratively called by internally), the last array value (e.g. ) is always the most recent value.\n• If you need data arrays (e.g. ) to be indexed Pandas series, you can call their accessor (e.g. ). If you need the whole of data as a DataFrame, use accessor (i.e. ). List of orders (see ) waiting for execution. Declare an indicator. An indicator is just an array of values (or a tuple of such arrays in case of, e.g., MACD indicator), but one that is revealed gradually in much like is. Returns of indicator values. is a function that returns the indicator array(s) of same length as . In the plot legend, the indicator is labeled with function name, unless overrides it. If returns a tuple of arrays, can be a sequence of strings, and its size must agree with the number of arrays returned. If is , the indicator is plotted on the resulting . If is , the indicator is plotted overlaying the price candlestick chart (suitable e.g. for moving averages). If , the indicator is plotted standalone below the candlestick chart. By default, a heuristic is used which decides correctly most of the time. can be string hex RGB triplet or X11 color name. By default, the next available color is assigned. If is , the plotted indicator marker will be a circle instead of a connected line segment (default). Additional and are passed to and can be used for parameters. For example, using simple moving average function from TA-Lib: Rolling indicators may front-pad warm-up values with NaNs. In this case, the backtest will only begin on the first bar when all declared indicators have non-NaN values (e.g. bar 201 for a strategy that uses a 200-bar MA). This can affect results. Place a new long order and return it. For explanation of parameters, see and its properties. Unless you're running , market orders are filled on next bar's open, whereas other order types (limit, stop-limit, stop-market) are filled when the respective conditions are met. See and for closing existing positions. Initialize the strategy. Override this method. Declare indicators (with ). Precompute what needs to be precomputed or can be precomputed in a vectorized fashion before the strategy starts. If you extend composable strategies from , make sure to call: Main strategy runtime method, called as each new instance (row; full candlestick bar) becomes available. This is the main method where strategy decisions upon data precomputed in take place. If you extend composable strategies from , make sure to call: Place a new short order and return it. For explanation of parameters, see and its properties. Keep in mind that doesn't close existing trade unless:\n• the backtest was run with ,\n• the underlying asset price is equal in both cases and the backtest was run with . Use or to explicitly exit trades. If you merely want to close an existing long position, use or .\n\nWhen an is filled, it results in an active . Find active trades in and closed, settled trades in . Candlestick bar index of when the trade was entered. Datetime of when the trade was entered. Candlestick bar index of when the trade was exited (or None if the trade is still active). Trade exit price (or None if the trade is still active). Datetime of when the trade was exited. True if the trade is long (trade size is positive). True if the trade is short (trade size is negative). Stop-loss price at which to close the trade. This variable is writable. By assigning it a new price value, you create or modify the existing SL order. By assigning it , you cancel it. A tag value inherited from the that opened this trade. This can be used to track trades and apply conditional logic / subgroup analysis. Take-profit price at which to close the trade. This property is writable. By assigning it a new price value, you create or modify the existing TP order. By assigning it , you cancel it. Place new to close of the trade at next market price."
    },
    {
        "link": "https://github.com/kernc/backtesting.py/blob/master/doc/examples/Quick%20Start%20User%20Guide.py",
        "document": "# _Backtesting.py_ is a small and lightweight, blazing fast backtesting framework that uses state-of-the-art Python structures and procedures (Python 3.6+, Pandas, NumPy, Bokeh). It has a very small and simple API that is easy to remember and quickly shape towards meaningful results. The library _doesn't_ really support stock picking or trading strategies that rely on arbitrage or multi-asset portfolio rebalancing; instead, it works with an individual tradeable asset at a time and is best suited for optimizing position entrance and exit signal strategies, decisions upon values of technical indicators, and it's also a versatile interactive trade visualization and statistics tool.\n\n# In `next()`, we simply check if the faster moving average just crossed over the slower one. If it did and upwards, we close the possible short position and go long; if it did and downwards, we close the open long position and go short. Note, we don't adjust order size, so _Backtesting.py_ assumes _maximal possible position_. We use\n\n# In `init()`, the whole series of points was available, whereas **in `next()`, the length of `self.data` and all declared indicators is adjusted** on each `next()` call so that `array[-1]` (e.g. `self.data.Close[-1]` or `self.sma1[-1]`) always contains the most recent value, `array[-2]` the previous value, etc. (ordinary Python indexing of ascending-sorted 1D arrays).\n\n# method with each parameter a keyword argument pointing to its pool of possible values to test. Parameter `n1` is tested for values in range between 5 and 30 and parameter `n2` for values between 10 and 70, respectively. Some combinations of values of the two parameters are invalid, i.e. `n1` should not be _larger than_ or equal to `n2`. We limit admissible parameter combinations with an _ad hoc_ constraint function, which takes in the parameters and returns `True` (i.e. admissible) whenever `n1` is less than `n2`. Additionally, we search for such parameter combination that maximizes return over the observed period. We could instead choose to optimize any other key from the returned `stats` series."
    },
    {
        "link": "https://kernc.github.io/backtesting.py",
        "document": "Does it seem like you had missed getting rich during the recent crypto craze? Despair not—the international financial markets continue their move rightwards every day. You still have your chance. But successful traders all agree emotions have no place in trading — if you are ever to enjoy a fortune attained by trading, better first make sure your strategy or system is well-tested and working reliably toward consistent profits. Mechanical or algorithmic trading, they call it. They'll usually recommend signing up with a broker and trading on a demo account for a few months … But you know better. You know some programming.\n\nis a Python framework for inferring viability of trading strategies on historical (past) data. Of course, past performance is not indicative of future results, but a strategy that proves itself resilient in a multitude of market conditions can, with a little luck, remain just as reliable in the future. Improved upon the vision of , and by all means surpassingly comparable to other accessible alternatives, is lightweight, fast, user-friendly, intuitive, interactive, intelligent and, hopefully, future-proof. It is also documented well, including a handful of tutorials."
    },
    {
        "link": "https://github.com/kernc/backtesting.py/blob/master/backtesting/backtesting.py",
        "document": ""
    },
    {
        "link": "https://kernc.github.io/backtesting.py/doc/examples/Quick%20Start%20User%20Guide.html",
        "document": "This tutorial shows some of the features of backtesting.py, a Python framework for backtesting trading strategies.\n\nBacktesting.py is a small and lightweight, blazing fast backtesting framework that uses state-of-the-art Python structures and procedures (Python 3.6+, Pandas, NumPy, Bokeh). It has a very small and simple API that is easy to remember and quickly shape towards meaningful results. The library doesn't really support stock picking or trading strategies that rely on arbitrage or multi-asset portfolio rebalancing; instead, it works with an individual tradeable asset at a time and is best suited for optimizing position entrance and exit signal strategies, decisions upon values of technical indicators, and it's also a versatile interactive trade visualization and statistics tool.\n\nYou bring your own data. Backtesting ingests all kinds of OHLC data (stocks, forex, futures, crypto, ...) as a pandas.DataFrame with columns , , , and (optionally) . Such data is widely obtainable, e.g. with packages:\n\nBesides these columns, your data frames can have additional columns which are accessible in your strategies in a similar manner.\n\nDataFrame should ideally be indexed with a datetime index (convert it with ); otherwise a simple range index will do."
    },
    {
        "link": "https://ta-lib.github.io/ta-lib-python",
        "document": "This is a Python wrapper for TA-LIB based on Cython instead of SWIG. From the homepage:\n\nThe original Python bindings use SWIG which unfortunately are difficult to install and aren't as efficient as they could be. Therefore this project uses Cython and Numpy to efficiently and cleanly bind to TA-Lib -- producing results 2-4 times faster than the SWIG interface.\n\nSimilar to TA-Lib, the function interface provides a lightweight wrapper of the exposed TA-Lib indicators.\n\nEach function returns an output array and have default values for their parameters, unless specified as keyword arguments. Typically, these functions will have an initial \"lookback\" period (a required number of observations before an output is generated) set to .\n\nAll of the following examples use the function API:\n\nCalculating momentum of the close prices, with a time period of 5:\n\nIf you're already familiar with using the function API, you should feel right at home using the abstract API. Every function takes the same input, passed as a dictionary of Numpy arrays:\n\nFunctions can either be imported directly or instantiated by name:\n\nFrom there, calling functions is basically the same as the function API:\n\nLearn about more advanced usage of TA-Lib here.\n\nWe can show all the TA functions supported by TA-Lib, either as a or as a sorted by group (e.g. \"Overlap Studies\", \"Momentum Indicators\", etc):"
    },
    {
        "link": "https://ta-lib.org",
        "document": "Use TA-Lib to add technical analysis to your own financial market trading applications\n• 200 indicators such as ADX, MACD, RSI, Stochastic, Bollinger Bands etc... See complete list...\n• Core written in C/C++ with API also available for Python.\n• Open-Source (BSD License). Can be freely integrated in your own open-source or commercial applications.\n\nTA-Lib was release in 2001 for well-known algorithms that are still widely used >20 years later. The code is stable and have passed the test of time."
    },
    {
        "link": "https://github.com/TA-Lib/ta-lib-python",
        "document": "This is a Python wrapper for TA-LIB based on Cython instead of SWIG. From the homepage:\n\nThe original Python bindings included with TA-Lib use SWIG which unfortunately are difficult to install and aren't as efficient as they could be. Therefore this project uses Cython and Numpy to efficiently and cleanly bind to TA-Lib -- producing results 2-4 times faster than the SWIG interface.\n\nIn addition, this project also supports the use of the Polars and Pandas libraries.\n\nThe upstream TA-Lib C library released version 0.6.1 and changed the library name to from . After trying to support both via autodetect and having some issues, we have decided to currently support three feature branches:\n\nYou can install from PyPI:\n\nOr checkout the sources and run yourself:\n\nIt also appears possible to install via Conda Forge:\n\nTo use TA-Lib for python, you need to have the TA-Lib already installed. You should probably follow their installation directions for your platform, but some suggestions are included below for reference.\n\nYou can simply install using Homebrew:\n\nIf you are using Apple Silicon, such as the M1 processors, and building mixed architecture Homebrew projects, you might want to make sure it's being built for your architecture:\n\nAnd perhaps you can set these before installing with :\n\nYou might also find this helpful, particularly if you have tried several different installations without success:\n\nFor 64-bit Windows, the easiest way is to get the executable installer:\n• Run the Installer or run from the command-line.\n\nAlternatively, if you prefer to get the libraries without installing, or would like to use the 32-bit version:\n\nNote: if your directory path includes spaces, the installation will probably fail with No such file or directory errors.\n\nIf you get a warning that looks like this:\n\nThis typically means can't find the underlying library, a dependency which needs to be installed.\n\nIf you installed the underlying library with a custom prefix (e.g., with ), then when you go to install this python wrapper you can specify additional search paths to find the library and include files for the underlying library using the and environment variables:\n\nSometimes installation will produce build errors like this:\n\nThis typically means that it can't find the underlying library, a dependency which needs to be installed. On Windows, this could be caused by installing the 32-bit binary distribution of the underlying library, but trying to use it with 64-bit Python.\n\nSometimes installation will fail with errors like this:\n\nThis typically means that you need the Python headers, and should run something like:\n\nSometimes building the underlying library has errors running that look like this:\n\nThis might mean that the directory path to the underlying library has spaces in the directory names. Try putting it in a path that does not have any spaces and trying again.\n\nSometimes you might get this error running :\n\nThis is likely an issue with trying to compile for 32-bit platform but without the appropriate headers. You might find some success looking at the first answer to this question.\n\nIf you get an error on macOS like this:\n\nYou might look at this question and use to fix it.\n\nIf you wonder why gives you different results than you expect, probably you want applied to , which is a little different than the which is applied to :\n\nIf the build appears to hang, you might be running on a VM with not enough memory -- try 1 GB or 2 GB.\n\nIf you get \"permission denied\" errors such as this, you might need to give your user access to the location where the underlying TA-Lib C library is installed -- or install it to a user-accessible location.\n\nIf you're having trouble compiling the underlying TA-Lib C library on ARM64, you might need to configure it with an explicit build type before running and , for example:\n\nThis is caused by old file, so another way to solve this is to copy a newer version of config.guess into the underlying TA-Lib C library sources:\n\nIf you're having trouble using PyInstaller and get an error that looks like this:\n\nThen, perhaps you can use the argument to fix this:\n\nIf you want to use , then you should use .\n\nIf you want to use , then you should use .\n\nIf you have trouble getting the code autocompletions to work in Visual Studio Code, a suggestion was made to look for the extension settings, and an option for , and change it from (which means Pylance if it is installed, Jedi otherwise , to manually set and the completions should work. It is possible that you might need to install it manually for this to work.\n\nSimilar to TA-Lib, the Function API provides a lightweight wrapper of the exposed TA-Lib indicators.\n\nEach function returns an output array and have default values for their parameters, unless specified as keyword arguments. Typically, these functions will have an initial \"lookback\" period (a required number of observations before an output is generated) set to .\n\nFor convenience, the Function API supports both and and inputs.\n\nAll of the following examples use the Function API:\n\nCalculating momentum of the close prices, with a time period of 5:\n\nThe underlying TA-Lib C library handles NaN's in a sometimes surprising manner by typically propagating NaN's to the end of the output, for example:\n\nYou can compare that to a Pandas rolling mean, where their approach is to output NaN until enough \"lookback\" values are observed to generate new outputs:\n\nIf you're already familiar with using the function API, you should feel right at home using the Abstract API.\n\nEvery function takes a collection of named inputs, either a of or or , or a or . If a or is provided, the output is returned as the same type with named output columns.\n\nFor example, inputs could be provided for the typical \"OHLCV\" data:\n\nFunctions can either be imported directly or instantiated by name:\n\nFrom there, calling functions is basically the same as the function API:\n\nAn experimental Streaming API was added that allows users to compute the latest value of an indicator. This can be faster than using the Function API, for example in an application that receives streaming data, and wants to know just the most recent updated indicator value.\n\nWe can show all the TA functions supported by TA-Lib, either as a or as a sorted by group (e.g. \"Overlap Studies\", \"Momentum Indicators\", etc):"
    },
    {
        "link": "https://medium.com/@financial_python/building-a-macd-indicator-in-python-190b2a4c1777",
        "document": "The Moving Average Convergence Divergence (MACD) is a widely used technical indicator in trading and investing. It helps traders identify potential trends, reversals, and momentum in an asset’s price. In this article, we’ll delve into coding a MACD indicator in Python using AAPL stock data from yfinance with a 1-hour timeframe. We’ll calculate both the MACD line and the Signal line, and we’ll also print if a cross above or below happened in the last two rows. We’ll use common values for the EMA short-term (12-period) and long-term (26-period) components of MACD and explain why these values are popular choices.\n\nLet’s use yfinance to fetch AAPL stock data with a 1-hour timeframe. Import the required libraries and fetch the data:\n\nIn this step, we’ll calculate the Moving Average Convergence Divergence (MACD) indicator and the Signal Line. The MACD is derived from two Exponential Moving Averages (EMAs): a short-term EMA and a long-term EMA. Commonly, a 12-period EMA is used for the short-term component, and a 26-period EMA is used for the long-term component.\n\nThe choice of these specific periods is grounded in the following principles:\n• Sensitivity: The 12-period EMA is more responsive to recent price changes, providing sensitivity to short-term price movements. In contrast, the 26-period EMA is smoother and reacts more slowly, capturing longer-term trends. This combination helps the MACD identify potential shifts in momentum across various timeframes.\n• Convergence and Divergence: The MACD’s name itself reflects its capacity to detect both convergence (when the MACD line crosses above the Signal Line) and divergence (when it crosses below the Signal Line). This duality makes it a versatile tool for traders interested in both trend-following and reversal strategies.\n\nNow, let’s delve into the Python code for calculating the MACD and Signal Line using the AAPL stock data:\n\nIn the code above:\n• We calculate the 12-period EMA (Short-Term EMA) using the method, specifying a of 12. This method applies exponential smoothing to the closing prices.\n• Similarly, we calculate the 26-period EMA (Long-Term EMA) with a of 26.\n• The MACD is determined as the difference between the Short-Term EMA (EMA12) and the Long-Term EMA (EMA26).\n• Lastly, we calculate the Signal Line, which is the 9-period EMA of the MACD.\n\nThis code effectively computes the MACD and Signal Line for the given stock data. You can read more about the pandas method here: https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.ewm.html\n\nWe want to check if the MACD line crosses above or below the Signal Line in the last two rows of the data. We’ll implement this logic:\n\nHere we are just printing whether or not a cross over happened, but there are many things we can do with this. We can send an email or a text message to alert ourselves if this happened, or we can implement this logic as part of a trading bot. Those are just two suggestions, but you get the idea.\n\nIn this article, we’ve coded a MACD indicator in Python using AAPL stock data with a 1-hour timeframe. We’ve also explained why the common values of 12-period and 26-period EMAs are used in MACD calculations. The MACD indicator is a valuable tool for traders and investors to identify potential trends and reversals in price movements.\n\nFeel free to adapt this code for other stocks, timeframes, or additional trading strategies."
    },
    {
        "link": "https://technical-analysis-library-in-python.readthedocs.io/en/latest/ta.html",
        "document": "It is a Technical Analysis library useful to do feature engineering from financial time series datasets (Open, Close, High, Low, Volume). It is built on Pandas and Numpy.\n\nThe Awesome Oscillator is an indicator used to measure market momentum. AO calculates the difference of a 34 Period and 5 Period Simple Moving Averages. The Simple Moving Averages that are used are not calculated using closing price but rather each bar’s midpoints. AO is generally used to affirm trends or to anticipate possible reversals. Awesome Oscillator is a 34-period simple moving average, plotted through the central points of the bars (H+L)/2, and subtracted from the 5-period simple moving average, graphed across the central points of the bars (H+L)/2. Moving average designed to account for market noise or volatility. KAMA will closely follow prices when the price swings are relatively small and the noise is low. KAMA will adjust when the price swings widen and follow prices from a greater distance. This trend-following indicator can be used to identify the overall trend, time turning points and filter price movements.\n• None pow1 (int) – number of periods for the fastest EMA constant.\n• None pow2 (int) – number of periods for the slowest EMA constant. The Percentage Price Oscillator (PPO) is a momentum oscillator that measures the difference between two moving averages as a percentage of the larger moving average. The Percentage Volume Oscillator (PVO) is a momentum oscillator for volume. The PVO measures the difference between two volume-based moving averages as a percentage of the larger moving average. The Rate-of-Change (ROC) indicator, which is also referred to as simply Momentum, is a pure momentum oscillator that measures the percent change in price from one period to the next. The ROC calculation compares the current price with the price “n” periods ago. The plot forms an oscillator that fluctuates above and below the zero line as the Rate-of-Change moves from positive to negative. As a momentum oscillator, ROC signals include centerline crossovers, divergences and overbought-oversold readings. Divergences fail to foreshadow reversals more often than not, so this article will forgo a detailed discussion on them. Even though centerline crossovers are prone to whipsaw, especially short-term, these crossovers can be used to identify the overall trend. Identifying overbought or oversold extremes comes naturally to the Rate-of-Change oscillator. Compares the magnitude of recent gains and losses over a specified time period to measure speed and change of price movements of a security. It is primarily used to attempt to identify overbought or oversold conditions in the trading of an asset. The StochRSI oscillator was developed to take advantage of both momentum indicators in order to create a more sensitive indicator that is attuned to a specific security’s historical performance rather than a generalized analysis of price change. Developed in the late 1950s by George Lane. The stochastic oscillator presents the location of the closing price of a stock in relation to the high and low range of the price of a stock over a period of time, typically a 14-day period. Larry Williams’ (1976) signal, a momentum oscillator designed to capture momentum across three different timeframes. BP = Close - Minimum(Low or Prior Close). TR = Maximum(High or Prior Close) - Minimum(Low or Prior Close) Average7 = (7-period BP Sum) / (7-period TR Sum) Average14 = (14-period BP Sum) / (14-period TR Sum) Average28 = (28-period BP Sum) / (28-period TR Sum) Developed by Larry Williams, Williams %R is a momentum indicator that is the inverse of the Fast Stochastic Oscillator. Also referred to as %R, Williams %R reflects the level of the close relative to the highest high for the look-back period. In contrast, the Stochastic Oscillator reflects the level of the close relative to the lowest low. %R corrects for the inversion by multiplying the raw value by -100. As a result, the Fast Stochastic Oscillator and Williams %R produce the exact same lines, only the scaling is different. Williams %R oscillates from 0 to -100. Readings from 0 to -20 are considered overbought. Readings from -80 to -100 are considered oversold. Unsurprisingly, signals derived from the Stochastic Oscillator are also applicable to Williams %R. Lowest Low = lowest low for the look-back period Highest High = highest high for the look-back period %R is multiplied by -100 correct the inversion and move the decimal. The Williams %R oscillates from 0 to -100. When the indicator produces readings from 0 to -20, this indicates overbought market conditions. When readings are -80 to -100, it indicates oversold market conditions. The Awesome Oscillator is an indicator used to measure market momentum. AO calculates the difference of a 34 Period and 5 Period Simple Moving Averages. The Simple Moving Averages that are used are not calculated using closing price but rather each bar’s midpoints. AO is generally used to affirm trends or to anticipate possible reversals. Awesome Oscillator is a 34-period simple moving average, plotted through the central points of the bars (H+L)/2, and subtracted from the 5-period simple moving average, graphed across the central points of the bars (H+L)/2. Moving average designed to account for market noise or volatility. KAMA will closely follow prices when the price swings are relatively small and the noise is low. KAMA will adjust when the price swings widen and follow prices from a greater distance. This trend-following indicator can be used to identify the overall trend, time turning points and filter price movements.\n• None window (int) – n number of periods for the efficiency ratio.\n• None pow1 (int) – number of periods for the fastest EMA constant.\n• None pow2 (int) – number of periods for the slowest EMA constant. The Percentage Price Oscillator (PPO) is a momentum oscillator that measures the difference between two moving averages as a percentage of the larger moving average. The Percentage Price Oscillator (PPO) is a momentum oscillator that measures the difference between two moving averages as a percentage of the larger moving average. The Percentage Price Oscillator (PPO) is a momentum oscillator that measures the difference between two moving averages as a percentage of the larger moving average. The Percentage Volume Oscillator (PVO) is a momentum oscillator for volume. The PVO measures the difference between two volume-based moving averages as a percentage of the larger moving average. The Percentage Volume Oscillator (PVO) is a momentum oscillator for volume. The PVO measures the difference between two volume-based moving averages as a percentage of the larger moving average. The Percentage Volume Oscillator (PVO) is a momentum oscillator for volume. The PVO measures the difference between two volume-based moving averages as a percentage of the larger moving average. The Rate-of-Change (ROC) indicator, which is also referred to as simply Momentum, is a pure momentum oscillator that measures the percent change in price from one period to the next. The ROC calculation compares the current price with the price “n” periods ago. The plot forms an oscillator that fluctuates above and below the zero line as the Rate-of-Change moves from positive to negative. As a momentum oscillator, ROC signals include centerline crossovers, divergences and overbought-oversold readings. Divergences fail to foreshadow reversals more often than not, so this article will forgo a detailed discussion on them. Even though centerline crossovers are prone to whipsaw, especially short-term, these crossovers can be used to identify the overall trend. Identifying overbought or oversold extremes comes naturally to the Rate-of-Change oscillator. Compares the magnitude of recent gains and losses over a specified time period to measure speed and change of price movements of a security. It is primarily used to attempt to identify overbought or oversold conditions in the trading of an asset. Developed in the late 1950s by George Lane. The stochastic oscillator presents the location of the closing price of a stock in relation to the high and low range of the price of a stock over a period of time, typically a 14-day period. The StochRSI oscillator was developed to take advantage of both momentum indicators in order to create a more sensitive indicator that is attuned to a specific security’s historical performance rather than a generalized analysis of price change. The StochRSI oscillator was developed to take advantage of both momentum indicators in order to create a more sensitive indicator that is attuned to a specific security’s historical performance rather than a generalized analysis of price change. The StochRSI oscillator was developed to take advantage of both momentum indicators in order to create a more sensitive indicator that is attuned to a specific security’s historical performance rather than a generalized analysis of price change. Larry Williams’ (1976) signal, a momentum oscillator designed to capture momentum across three different timeframes. BP = Close - Minimum(Low or Prior Close). TR = Maximum(High or Prior Close) - Minimum(Low or Prior Close) Average7 = (7-period BP Sum) / (7-period TR Sum) Average14 = (14-period BP Sum) / (14-period TR Sum) Average28 = (28-period BP Sum) / (28-period TR Sum) Developed by Larry Williams, Williams %R is a momentum indicator that is the inverse of the Fast Stochastic Oscillator. Also referred to as %R, Williams %R reflects the level of the close relative to the highest high for the look-back period. In contrast, the Stochastic Oscillator reflects the level of the close relative to the lowest low. %R corrects for the inversion by multiplying the raw value by -100. As a result, the Fast Stochastic Oscillator and Williams %R produce the exact same lines, only the scaling is different. Williams %R oscillates from 0 to -100. Readings from 0 to -20 are considered overbought. Readings from -80 to -100 are considered oversold. Unsurprisingly, signals derived from the Stochastic Oscillator are also applicable to Williams %R. Lowest Low = lowest low for the look-back period Highest High = highest high for the look-back period %R is multiplied by -100 correct the inversion and move the decimal. From: https://www.investopedia.com/terms/w/williamsr.asp The Williams %R oscillates from 0 to -100. When the indicator produces readings from 0 to -20, this indicates overbought market conditions. When readings are -80 to -100, it indicates oversold market conditions.\n\nIt measures the amount of Money Flow Volume over a specific period. It relate an asset’s price change to its volume and is particularly useful for assessing the strength of a trend. It illustrates how strong the actual buying or selling pressure is. High positive values mean there is a strong rising trend, and low values signify a strong downward trend. Uses both price and volume to measure buying and selling pressure. It is positive when the typical price rises (buying pressure) and negative when the typical price declines (selling pressure). A ratio of positive and negative money flow is then plugged into an RSI formula to create an oscillator that moves between zero and one hundred. It relates price and volume in the stock market. OBV is based on a cumulative total volume. Is based on a running cumulative volume that adds or substracts a multiple of the percentage change in share price trend and current volume, depending upon the investment’s upward or downward movements. VWAP equals the dollar value of all trading periods divided by the total trading volume for the current day. The calculation starts when trading opens and ends when it closes. Because it is good for the current trading day only, intraday periods and data are used in the calculation. It measures the amount of Money Flow Volume over a specific period. It relate an asset’s price change to its volume and is particularly useful for assessing the strength of a trend. It illustrates how strong the actual buying or selling pressure is. High positive values mean there is a strong rising trend, and low values signify a strong downward trend. Uses both price and volume to measure buying and selling pressure. It is positive when the typical price rises (buying pressure) and negative when the typical price declines (selling pressure). A ratio of positive and negative money flow is then plugged into an RSI formula to create an oscillator that moves between zero and one hundred. The Negative Volume Index (NVI) is a cumulative indicator that uses the change in volume to decide when the smart money is active. Paul Dysart first developed this indicator in the 1930s. […] Dysart’s Negative Volume Index works under the assumption that the smart money is active on days when volume decreases and the not-so-smart money is active on days when volume increases. The cumulative NVI line was unchanged when volume increased from one period to the other. In other words, nothing was done. Norman Fosback, of Stock Market Logic, adjusted the indicator by substituting the percentage price change for Net Advances. This implementation is the Fosback version. If today’s volume is less than yesterday’s volume then: Please note: the “stockcharts.com” example calculation just adds the percentange change of price to previous NVI when volumes decline; other sources indicate that the same percentage of the previous NVI value should be added, which is what is implemented here. It relates price and volume in the stock market. OBV is based on a cumulative total volume. It relate an asset’s price change to its volume and is particularly useful for assessing the strength of a trend. Is based on a running cumulative volume that adds or substracts a multiple of the percentage change in share price trend and current volume, depending upon the investment’s upward or downward movements. VWAP equals the dollar value of all trading periods divided by the total trading volume for the current day. The calculation starts when trading opens and ends when it closes. Because it is good for the current trading day only, intraday periods and data are used in the calculation.\n\nThe indicator provide an indication of the degree of price volatility. Strong moves, in either direction, are often accompanied by large ranges, or large True Ranges. It returns 1, if close is higher than bollinger_hband. Else, it returns 0. It returns 1, if close is lower than bollinger_lband. Else, it returns 0. Keltner Channels are a trend following indicator used to identify reversals with channel breakouts and channel direction. Channels can also be used to identify overbought and oversold levels when the trend is flat.\n• None window_atr (int) – n atr period. Only valid if original_version param is False.\n• None original_version (bool) – if True, use original version as the centerline (SMA of typical price) if False, use EMA of close as the centerline. More info: https://school.stockcharts.com/doku.php?id=technical_indicators:keltner_channels\n• None multiplier (int) – The multiplier has the most effect on the channel width. default is 2 It returns 1, if close is higher than keltner_channel_hband. Else, it returns 0. It returns 1, if close is lower than keltner_channel_lband. Else, it returns 0. The indicator provide an indication of the degree of price volatility. Strong moves, in either direction, are often accompanied by large ranges, or large True Ranges. Upper band at K times an N-period standard deviation above the moving average (MA + Kdeviation). Returns 1, if close is higher than bollinger high band. Else, return 0. Lower band at K times an N-period standard deviation below the moving average (MA − Kdeviation). Returns 1, if close is lower than bollinger low band. Else, return 0. The upper band marks the highest price of an issue for n periods. The lower band marks the lowest price for n periods.\n• None window_atr (int) – n atr period. Only valid if original_version param is False.\n• None original_version (bool) – if True, use original version as the centerline (SMA of typical price) if False, use EMA of close as the centerline. More info: https://school.stockcharts.com/doku.php?id=technical_indicators:keltner_channels Returns 1, if close is higher than keltner high band channel. Else, return 0.\n• None window_atr (int) – n atr period. Only valid if original_version param is False.\n• None original_version (bool) – if True, use original version as the centerline (SMA of typical price) if False, use EMA of close as the centerline. More info: https://school.stockcharts.com/doku.php?id=technical_indicators:keltner_channels\n• None window_atr (int) – n atr period. Only valid if original_version param is False.\n• None original_version (bool) – if True, use original version as the centerline (SMA of typical price) if False, use EMA of close as the centerline. More info: https://school.stockcharts.com/doku.php?id=technical_indicators:keltner_channels Returns 1, if close is lower than keltner low band channel. Else, return 0.\n• None window_atr (int) – n atr period. Only valid if original_version param is False.\n• None original_version (bool) – if True, use original version as the centerline (SMA of typical price) if False, use EMA of close as the centerline. More info: https://school.stockcharts.com/doku.php?id=technical_indicators:keltner_channels\n• None window_atr (int) – n atr period. Only valid if original_version param is False.\n• None original_version (bool) – if True, use original version as the centerline (SMA of typical price) if False, use EMA of close as the centerline. More info: https://school.stockcharts.com/doku.php?id=technical_indicators:keltner_channels\n• None window_atr (int) – n atr period. Only valid if original_version param is False.\n• None original_version (bool) – if True, use original version as the centerline (SMA of typical price) if False, use EMA of close as the centerline. More info: https://school.stockcharts.com/doku.php?id=technical_indicators:keltner_channels\n• None window_atr (int) – n atr period. Only valid if original_version param is False.\n• None original_version (bool) – if True, use original version as the centerline (SMA of typical price) if False, use EMA of close as the centerline. More info: https://school.stockcharts.com/doku.php?id=technical_indicators:keltner_channels\n\nThe Plus Directional Indicator (+DI) and Minus Directional Indicator (-DI) are derived from smoothed averages of these differences, and measure trend direction over time. These two indicators are often referred to collectively as the Directional Movement Indicator (DMI). The Average Directional Index (ADX) is in turn derived from the smoothed averages of the difference between +DI and -DI, and measures the strength of the trend (regardless of direction) over time. Using these three indicators together, chartists can determine both the direction and strength of the trend. Identify when trends are likely to change direction. Aroon Up = ((N - Days Since N-day High) / N) x 100 Aroon Down = ((N - Days Since N-day Low) / N) x 100 Aroon Indicator = Aroon Up - Aroon Down CCI measures the difference between a security’s price change and its average price change. High positive readings indicate that prices are well above their average, which is a show of strength. Low negative readings indicate that prices are well below their average, which is a show of weakness. Is an indicator designed to remove trend from price and make it easier to identify cycles. It is useful to identify major stock market cycle junctures because its formula is weighed to be more greatly influenced by the longer and more dominant time spans, in order to better reflect the primary swings of stock market cycle. Is a trend-following momentum indicator that shows the relationship between two moving averages of prices. It uses the high-low range to identify trend reversals based on range expansions. It identifies range bulges that can foreshadow a reversal of the current trend. The Parabolic Stop and Reverse, more commonly known as the Parabolic SAR,is a trend-following indicator developed by J. Welles Wilder. The Parabolic SAR is displayed as a single parabolic line (or dots) underneath the price bars in an uptrend, and above the price bars in a downtrend.\n• None step (float) – the Acceleration Factor used to compute the SAR.\n• None max_step (float) – the maximum value allowed for the Acceleration Factor. The Schaff Trend Cycle (STC) is a charting indicator that is commonly used to identify market trends and provide buy and sell signals to traders. Developed in 1999 by noted currency trader Doug Schaff, STC is a type of oscillator and is based on the assumption that, regardless of time frame, currency trends accelerate and decelerate in cyclical patterns. Shows the percent rate of change of a triple exponentially smoothed moving average. It consists of two oscillators that capture positive and negative trend movement. A bullish signal triggers when the positive trend indicator crosses above the negative trend indicator or a key level. The Plus Directional Indicator (+DI) and Minus Directional Indicator (-DI) are derived from smoothed averages of these differences, and measure trend direction over time. These two indicators are often referred to collectively as the Directional Movement Indicator (DMI). The Average Directional Index (ADX) is in turn derived from the smoothed averages of the difference between +DI and -DI, and measures the strength of the trend (regardless of direction) over time. Using these three indicators together, chartists can determine both the direction and strength of the trend. The Plus Directional Indicator (+DI) and Minus Directional Indicator (-DI) are derived from smoothed averages of these differences, and measure trend direction over time. These two indicators are often referred to collectively as the Directional Movement Indicator (DMI). The Average Directional Index (ADX) is in turn derived from the smoothed averages of the difference between +DI and -DI, and measures the strength of the trend (regardless of direction) over time. Using these three indicators together, chartists can determine both the direction and strength of the trend. The Plus Directional Indicator (+DI) and Minus Directional Indicator (-DI) are derived from smoothed averages of these differences, and measure trend direction over time. These two indicators are often referred to collectively as the Directional Movement Indicator (DMI). The Average Directional Index (ADX) is in turn derived from the smoothed averages of the difference between +DI and -DI, and measures the strength of the trend (regardless of direction) over time. Using these three indicators together, chartists can determine both the direction and strength of the trend. Identify when trends are likely to change direction (downtrend). Identify when trends are likely to change direction (uptrend). CCI measures the difference between a security’s price change and its average price change. High positive readings indicate that prices are well above their average, which is a show of strength. Low negative readings indicate that prices are well below their average, which is a show of weakness. Is an indicator designed to remove trend from price and make it easier to identify cycles. It identifies the trend and look for potential signals within that trend. It identifies the trend and look for potential signals within that trend. It identifies the trend and look for potential signals within that trend. It identifies the trend and look for potential signals within that trend. It is useful to identify major stock market cycle junctures because its formula is weighed to be more greatly influenced by the longer and more dominant time spans, in order to better reflect the primary swings of stock market cycle. It is useful to identify major stock market cycle junctures because its formula is weighed to be more greatly influenced by the longer and more dominant time spans, in order to better reflect the primary swings of stock market cycle. Is a trend-following momentum indicator that shows the relationship between two moving averages of prices. Shows the relationship between MACD and MACD Signal. It uses the high-low range to identify trend reversals based on range expansions. It identifies range bulges that can foreshadow a reversal of the current trend. Returns the PSAR series with non-N/A values for downward trends\n• None step (float) – the Acceleration Factor used to compute the SAR.\n• None max_step (float) – the maximum value allowed for the Acceleration Factor. Returns 1, if there is a reversal towards an downward trend. Else, returns 0.\n• None step (float) – the Acceleration Factor used to compute the SAR.\n• None max_step (float) – the maximum value allowed for the Acceleration Factor. Returns the PSAR series with non-N/A values for upward trends\n• None step (float) – the Acceleration Factor used to compute the SAR.\n• None max_step (float) – the maximum value allowed for the Acceleration Factor. Returns 1, if there is a reversal towards an upward trend. Else, returns 0.\n• None step (float) – the Acceleration Factor used to compute the SAR.\n• None max_step (float) – the maximum value allowed for the Acceleration Factor. The Schaff Trend Cycle (STC) is a charting indicator that is commonly used to identify market trends and provide buy and sell signals to traders. Developed in 1999 by noted currency trader Doug Schaff, STC is a type of oscillator and is based on the assumption that, regardless of time frame, currency trends accelerate and decelerate in cyclical patterns. Shows the percent rate of change of a triple exponentially smoothed moving average. It consists of two oscillators that capture positive and negative trend movement. A bearish signal triggers when the negative trend indicator crosses above the positive trend indicator or a key level. It consists of two oscillators that capture positive and negative trend movement. A bullish signal triggers when the positive trend indicator crosses above the negative trend indicator or a key level."
    }
]