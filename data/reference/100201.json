[
    {
        "link": "https://stackoverflow.com/questions/6509154/using-kerberos-authentication-for-server-client-application",
        "document": "In c++ I am trying to build a portable server running on Linux and Windows and client running in Windows that will use MS Active Directory for authentication. After some research I decided that best way to go is use Kerberos. I decided to use MIT Kerberos v5 library due to BSD style licence.\n\nBut my problem is that I am completely unable to find good resource on working in Kerberos in C++. All examples that I found are just simple code snippets that fail to explain in enough details what input parameters to functions are and reference manuals (doxygen style) that briefly explains the function in question but does not provide enough information to understand the context where to use it.\n\nIn short, can you recommend good resource for C++ programmer that two weeks ago did not even know what Kerberos is?"
    },
    {
        "link": "https://stackoverflow.com/questions/1337923/authenticating-users-using-active-directory-in-client-server-application",
        "document": "I've been asked to provide support for authenticating users against an Active Directory in our existing client server application.\n\nAt the moment a user supplies a user name and password from a client machine, passed over the wire (encrypted) to our server process and matched against a user name/password stored in a database.\n\nInitially, I thought this would be a easy problem to solve, since I could simply authenticate the users' name/password against Active Directory from our server process. However it turns out that users shouldn't have to enter a password from our client application, instead taking it's credentials from the current Windows login session.\n\nI'm now faced with a problem of how to authenticate using Active Directory without having a password? I'm sure there must be a way of somehow passing some sort of \"token\" from the client to our server process that could be used as an alternative authentication method, but my research so far has drawn a blank.\n\nOur server is written in C++, so we'll be using the win32 API. I also intend to develop and debug this using a virtual machine running Windows 2008 AD LDS - I'm hoping this will be sufficient for what I'm trying to achieve.\n\nAny help or advice is much appreciated."
    },
    {
        "link": "https://learn.microsoft.com/en-us/windows-server/security/kerberos/kerberos-authentication-overview",
        "document": "Kerberos is an authentication protocol that is used to verify the identity of a user or host. This topic contains information about Kerberos authentication in Windows Server 2012 and Windows 8.\n\nThe Windows Server operating systems implement the Kerberos version 5 authentication protocol and extensions for public key authentication, transporting authorization data, and delegation. The Kerberos authentication client is implemented as a security support provider (SSP), and it can be accessed through the Security Support Provider Interface (SSPI). Initial user authentication is integrated with the Winlogon single sign-on architecture.\n\nThe Kerberos Key Distribution Center (KDC) is integrated with other Windows Server security services that run on the domain controller. The KDC uses the domain's Active Directory Domain Services database as its security account database. Active Directory Domain Services is required for default Kerberos implementations within the domain or forest.\n\nThe benefits gained by using Kerberos for domain-based authentication are:\n• Services that run on Windows operating systems can impersonate a client computer when accessing resources on the client's behalf. In many cases, a service can complete its work for the client by accessing resources on the local computer. When a client computer authenticates to the service, NTLM and Kerberos protocol provide the authorization information that a service needs to impersonate the client computer locally. However, some distributed applications are designed so that a front-end service must use the client computer's identity when it connects to back-end services on other computers. Kerberos authentication supports a delegation mechanism that enables a service to act on behalf of its client when connecting to other services.\n• Using Kerberos authentication within a domain or in a forest allows the user or service access to resources permitted by administrators without multiple requests for credentials. After initial domain sign on through Winlogon, Kerberos manages the credentials throughout the forest whenever access to resources is attempted.\n• The implementation of the Kerberos V5 protocol by Microsoft is based on standards-track specifications that are recommended to the Internet Engineering Task Force (IETF). As a result, in Windows operating systems, the Kerberos protocol lays a foundation for interoperability with other networks in which the Kerberos protocol is used for authentication. In addition, Microsoft publishes Windows Protocols documentation for implementing the Kerberos protocol. The documentation contains the technical requirements, limitations, dependencies, and Windows-specific protocol behavior for Microsoft's implementation of the Kerberos protocol.\n• Before Kerberos, NTLM authentication could be used, which requires an application server to connect to a domain controller to authenticate every client computer or service. With the Kerberos protocol, renewable session tickets replace pass-through authentication. The server is not required to go to a domain controller (unless it needs to validate a Privilege Attribute Certificate (PAC)). Instead, the server can authenticate the client computer by examining credentials presented by the client. Client computers can obtain credentials for a particular server once and then reuse those credentials throughout a network logon session.\n• By using the Kerberos protocol, a party at either end of a network connection can verify that the party on the other end is the entity it claims to be. NTLM does not enable clients to verify a server's identity or enable one server to verify the identity of another. NTLM authentication was designed for a network environment in which servers were assumed to be genuine. The Kerberos protocol makes no such assumption."
    },
    {
        "link": "https://kerberos.org/software/appskerberos.pdf",
        "document": ""
    },
    {
        "link": "https://sapien.com/forums/viewtopic.php?t=13742",
        "document": ""
    },
    {
        "link": "https://learn.microsoft.com/en-us/windows/win32/winhttp/winhttp-start-page",
        "document": "Microsoft Windows HTTP Services (WinHTTP) provides developers with an HTTP client application programming interface (API) to send requests through the HTTP protocol to other HTTP servers.\n\nFor more information on how to use WinHTTP for applications built on the Microsoft .NET Framework, see the WinHttpHandler API\n\nWinHTTP offers both a C/C++ application programming interface (API) and a Component Object Model (COM) automation component suitable for use in Active Server Pages (ASP) based applications.\n\nA basic understanding of the HTTP protocol is important to use either interface.\n\nWinHTTP 5.1 offers improvements over version 5.0. It is included in the operating system. For more information about new features, see What's New in WinHTTP 5.1 and What's New in Windows Server 2008 and Windows Vista."
    },
    {
        "link": "https://learn.microsoft.com/en-us/windows/win32/winhttp/using-the-winhttp-c-c---api",
        "document": "This browser is no longer supported.\n\nUpgrade to Microsoft Edge to take advantage of the latest features, security updates, and technical support."
    },
    {
        "link": "https://learn.microsoft.com/en-us/archive/msdn-magazine/2008/august/windows-with-c-asynchronous-winhttp",
        "document": "As a result of advances in distributed programming, most modern Windows®-based applications must be able to make HTTP requests. Although HTTP is relatively simple, modern HTTP handling is not at all trivial. Asynchronous processing requires buffering potentially large requests and responses, authentication, automatic proxy server detection, persistent connections, and much more. Sure, you can ignore many of these issues but the quality of your application will suffer. And HTTP is not simple enough to imitate with TCP sockets. So what is a C++ developer to do?\n\nA common misconception is that you need to use the Microsoft® .NET Framework if you want your application to access the Web. The truth is that developers using managed code still must deal with many of the same issues I just mentioned, and many of new styles of Web services, such as Representational State Transfer (REST), are just as easy to program using native code.\n\nIn this month's column, I am going to show you how to use the Windows HTTP Services, or WinHTTP, API for implementing HTTP clients. On Windows Vista® and Windows Server® 2008, WinHTTP additionally include support for file uploads larger than 4GB, improvements to certificate-based authentication, the ability to retrieve source and destination IP addresses, and more.\n\nWinHTTP provides both a C API as well as a COM API. The C API is naturally harder to use at first, but with a little help from C++ it provides a very powerful and flexible API for building HTTP clients. It also provides both synchronous and asynchronous programming models. I'm going to focus on the asynchronous model for a few reasons. First, parallel programming is critical in today's concurrency-aware world. Second, too much emphasis in documentation and training in general is placed on single-threaded programming to the point where little room is left to discuss parallel programming. What little prescriptive guidance is provided tends to be unrealistic in its simplicity. Many developers shy away from parallel programming, but you'll soon discover that it can be quite natural and even fun! (OK, so your definition of fun might differ from mine, but don't be discouraged.)\n\nAlthough the C API doesn't make it obvious, the WinHTTP API is logically modeled as three separate objects: session, connection, and request. A session object is required to initialize WinHTTP. Only one session is required per application. The session helps to create connection objects. One connection object is required for each HTTP server with which you wish to communicate. The connection object, in turn, helps to create individual request objects. An actual network connection is established the first time a request is sent. The relationship between these objects is illustrated in Figure 1. A session may have multiple active connections and a connection may have multiple concurrent requests.\n\nSession, connection, and request objects are represented by HINTERNET handles. Although different functions are used to create these objects, they are all destroyed by passing their respective handles to the WinHttpCloseHandle function. Additionally, functions such as WinHttpQueryOption and WinHttpSetOption use the handles to query and set a variety of different options supported by the WinHTTP objects.\n\nFigure 2 lists the WinHttpHandle class that you can use to manage the lifetime of all three types of WinHTTP handles as well as query and set options on them. So, given a request object, you can retrieve its full URL with the WINHTTP_OPTION_URL option:\n\nI use the COM_VERIFY macro in my code snippets to clearly identify where functions return an HRESULT that must be checked. You can replace this with appropriate error handling, whether that is throwing an exception or returning the HRESULT yourself.\n\nA session object is created using the WinHttpOpen function. The first parameter specifies an optional agent string for your application. The next three parameters specify how WinHTTP will resolve server names. This is useful for controlling whether servers are accessed directly or through a proxy server (read more about handling proxies in the sidebar entitled \"Determining Proxy Settings\" below). The last parameter contains flags of which there is currently only one defined. WINHTTP_FLAG_ASYNC indicates that WinHTTP functions should operate asynchronously:\n\nFigure 3 lists the WinHttpSession class that derives from the WinHttpHandle in Figure 2 and simplifies the creation of session objects. WinHttpSession creates the session with certain default values that should suffice in most cases.\n\nA connection object is created using the WinHttpConnect function. The first parameter specifies the session to which the new connection will belong. The next one lists the name or IP address of the server. The third parameter specifies the server's port number. For this parameter, you can alternatively use INTERNET_DEFAULT_PORT, and WinHTTP will use port 80 for regular HTTP requests and port 443 for secure HTTP requests (HTTPS):\n\nThe code in Figure 4 shows the WinHttpConnection class, which also derives from the WinHttpHandle and simplifies the creation of connection objects.\n\nThe request object is where things start to get interesting. A request object is created using the WinHttpOpenRequest function:\n\nThe first parameter specifies the connection to which the request will belong. The second parameter specifies the HTTP verb to use in the request; if this parameter is 0 then a GET request is assumed. The third parameter specifies the name or relative path of the resource that is being requested. The fourth parameter specifies the HTTP protocol version to use; if 0, then HTTP version 1.1 is assumed. The fifth parameter specifies any referring URL. This parameter is usually WINHTTP_NO_REFERRER, indicating no referrer. The second-to-last parameter specifies the media types that you as the client will accept. If this parameter is WINHTTP_DEFAULT_­ACCEPT_TYPES, no types are specified. Servers typically take this to mean that the client only accepts text responses. The last parameter specifies flags that can be used to control the behavior of the request. For example, you might want to specify the WINHTTP_FLAG_SECURE flag for making an SSL request.\n\nHere the synchronous and asynchronous programming models diverge. The synchronous model calls a function to send the request and then calls a function that blocks until a response has been received. The asynchronous model, on the other hand, uses a callback function allowing the remaining function calls to operate asynchronously and thus not block the calling thread.\n\nThe callback function is associated with a request object using the WinHttpSetStatusCallback function:\n\nThe first WinHttpSetStatusCallback parameter specifies the request about whose progress you would like to be notified. The second parameter specifies the address of a callback function. And the third parameter specifies the notifications that you are interested in receiving. WINHTTP_CALLBACK_FLAG_ALL_­NOTIFICATIONS is simply a bitmask that includes all possible notifications.\n\nThe callback function should be prototyped as follows:\n\nThe first parameter provides the handle for the object to which the callback relates. Technically, you can have a callback to handle notifications for session and connection objects, but for the most part this will be a request object. The second parameter is an application-defined value associated with a request when it is sent. The third parameter provides a code indicating the reason for the callback. The last two parameters specify a buffer that may contain any additional information depending on the code provided by the previous parameter. For example, if the WINHTTP_­CALLBACK_STATUS_REQUEST_ERROR notification code is received, then the info parameter points to a WINHTTP_ASYNC_RESULT structure.\n\nA request is sent using the WinHttpSendRequest function:\n\nThe first parameter identifies the request to send. The second and third parameters specify a string that may contain any additional headers to include the request. If WINHTTP_NO_ADDITIONAL_­HEADERS is specified, then no additional headers are initially included. As an alternative, you can add headers to the request before it is sent using the WinHttpAddRequestHeaders function. The fourth and fifth parameters specify an optional buffer containing any data to be included as the content, or body, of the request. This is commonly used for POST requests. The second-to-last parameter specifies the total length of the request's content. This value is used to create the Content-Length header included with the request. If it is greater than the length of the data provided by the previous parameters, then additional data may be written to complete the request using the WinHttpWriteData function.\n\nSince I'm using the asynchronous programming model, the function will return without waiting for the request to be sent, and WinHTTP will provide status updates via the callback function passing to it the context value specified in the last parameter to WinHttpSendRequest.\n\nLet's stop for a moment and consider how we can use C++ to bring together what I've covered thus far. In the previous sections, I introduced the rather straightforward WinHttpSession and WinHttpConnection classes for modeling sessions and connections. I need a WinHttpRequest class that not only wraps the various request-related function calls but also provides a simple way to author specific types of requests for an application. Included in that is efficiently managing a buffer that will store both request and response data as it is transferred. Figure 5 provides the outline of the WinHttpRequest class template that I'll build on during the rest of this article. Much of the interesting logic happens inside of the OnCallback member function. However, let me first describe how the WinHttpRequest class template is designed.\n\nFigure 6 lists the DownloadFileRequest class. It derives from WinHttpRequest and uses itself as the template parameter. This is a common technique used by the Visual C++® libraries to implement efficient compile-time virtual function calls. Like the WinHttp­Session and WinHttpConnection classes, WinHttpRequest provides an Initialize member function that initializes the WinHTTP request object. It starts by creating a buffer that will be used for the request and response data. This buffer's implementation isn't important. It just needs to manage the lifetime of a BYTE array. Initialize then calls WinHttpOpenRequest to create the WinHTTP request object and WinHttpSetStatusCallback to associate it with the static Callback member function inside the WinHttpRequest class.\n\nThe SendRequest member function just wraps the WinHttpSendRequest function and passes its \"this\" pointer as the context value for the request. Recall that this value is passed to the callback function and enables it to determine which request object the notification is for. SendRequest uses a static_cast to adjust the \"this\" pointer to the derived class specified by the template parameter. This is how the compile-time polymorphism is implemented in this case.\n\nFinally, the static Callback member function casts the context value back into a pointer to a request object and calls the On­Callback member function to handle the notification. Since network errors are inevitable, there needs to be some way of handling them naturally. Derived classes implement an OnResponse­Complete member function that takes an HRESULT. If it is S_OK, then the request completed successfully. But if there was some failure in the callback, then an appropriate HRESULT indicates the request has failed.\n\nBefore we look at the implementation of the OnCallback member function, take another look at the DownloadFileRequest concrete class in Figure 6 to put WinHttpRequest into perspective. The beauty here is that DownloadFileRequest can focus on the specifics involved in downloading a file. It is not bogged down by the complexities of HTTP request management. Its Initialize member function accepts the path to the source of the file to download as well as a destination stream to which to write it. The OnReadComplete member function will be called as each chunk of the response is received; OnResponseComplete is called when the request is completed.\n\nNow I would like to discuss how the OnCallback member function is implemented. As you can see in Figure 7, OnCallback once again uses a static_cast in order to adjust the \"this\" pointer to point to the derived class. The switch statement is then used to handle various notifications. It will return S_FALSE if there is a particular notification that has not been handled. This may come in handy if you want to override the OnCallback member function in a derived class.\n\nThe first notification of interest when sending the request, assuming the server is reachable, is WINHTTP_CALLBACK_STATUS_­SENDREQUEST_COMPLETE. This indicates that the WinHttpSendRequest function call completed successfully. Assuming that you're sending a simple GET request, you can now call the WinHttpReceiveResponse function to instruct WinHTTP to start reading the response\n\nIf a response is received, the WINHTTP_CALLBACK_­STATUS_HEADERS_AVAILABLE notification arrives indicating that the response headers are available to read. You can query for various headers that may be relevant to your application. At the very least, you should query for the HTTP status code returned by the server. Header information may be retrieved using the WinHttpQueryHeaders function. A simple implementation might just check for the HTTP_STATUS_OK status code, indicating that the request was successful (see Figure 8).\n\nWinHttpQueryHeaders is a powerful function. Rather than simply returning the text value of a particular named header, it provides a set of information flags that, for the most part, map to headers. But these flags also provide access to other aspects of an HTTP request/response state.\n\nIn Figure 8, I'm using the WINHTTP_­QUERY_STATUS_CODE flag in order to retrieve the status code returned by the server. And I'm also using the WINHTTP_QUERY_FLAG_NUMBER modifier to tell WinHttpQueryHeaders that I want the value returned as a 32-bit number rather than as a string.\n\nThe third parameter specifies the name of the header to query. If this parameter is WINHTTP_HEADER_NAME_BY_INDEX, the flag passed to the previous parameter identifies the information to return. The next two parameters specify a buffer that will receive the information. The last parameter is useful for reading multiple headers with the same name. If this parameter is WINHTTP_NO_HEADER_INDEX, only the first header's value is returned.\n\nOnce you're satisfied that the request was successful, you can call the WinHttpReadData function to begin reading the response. The second and third parameters specify a buffer that will receive the data. In this particular case, I'm using the buffer owned by the WinHttpRequest class template. The last parameter must be zero when using the asynchronous programming model.\n\nWhen enough response data is received, the WINHTTP_­CALLBACK_STATUS_READ_COMPLETE notification arrives, indicating that data may be available in the buffer. The amount of data read is indicated by OnCallback's length parameter. It can be zero, which would indicate that no more data is available, or it can have any value up to the size of the buffer specified in the WinHttpRead­Data function call (see Figure 9).\n\nNow you should be able to see exactly where the \"events\" in the DownloadFileRequest class in Figure 6 come from. The WINHTTP_CALLBACK_­STATUS_READ_COMPLETE handler calls the OnReadComplete method on the derived class each time data is received. This is followed by another call to WinHttp­ReadData to read the next block of data. Finally, when there is no more data available, it calls the OnResponseComplete method on the derived class with S_OK indicating that the response has been read successfully.\n\nWinHTTP provides a relatively error-prone model for asynchronous completion since your application is always notified of an operation's completion via the callback function. Since worker threads are used to execute the callback function, however, canceling a request does require some attention to detail.\n\nA request is canceled simply by closing the request handle using the WinHttpCloseHandle function, but you need to be prepared for subsequent callbacks to arrive after closing the request handle. You can call the WinHttpSetStatusCallback function to indicate that no more callbacks should be made prior to closing the request handle, but WinHTTP does not synchronize this with its worker threads.\n\nYou should thus ensure that any shared state is suitably guarded. In particular, any unprotected data that is being shared with the callback should not be freed until the WINHTTP_STATUS_­CALLBACK_HANDLE_CLOSING notification arrives.\n\nIn addition, you need to synchronize calls to WinHttpCloseHandle with other functions that may be operating on the request object such as WinHttpReadData, WinHttpWriteData, and WinHttpSendRequest. Request cancellation is one of the more problematic areas of asynchronous WinHTTP so be sure to carefully review your code as it relates to cancellation.\n\nWhat about POST requests? Apart from using a different HTTP verb, such requests also have additional data that is included as content within the body of the request. Figure 10 illustrates an updated WINHTTP_CALLBACK_STATUS_SENDREQUEST_COMPLETE handler, which can easily handle both GET and POST requests.\n\nWhen the WINHTTP_CALLBACK_STATUS_SENDREQUEST_­COMPLETE notification arrives, it gives the derived class an opportunity to write data as part of the request by calling its OnWriteData member function. The WinHttpRequest class template provides a default implementation for GET requests that simply returns S_FALSE. Data can be written using the WinHttpWriteData function:\n\nThe second and third parameters specify a buffer containing the data to write. Once the data has been written, the WINHTTP_CALLBACK_STATUS_WRITE_COMPLETE notification arrives. The OnWriteData member function on the derived class is once again called to write the next block of data. Once it has completed, it returns S_FALSE and the base class handler proceeds to call WinHttpReceiveResponse to receive the response as usual.\n\nOf course, there's a lot more that I could say about writing HTTP client applications with C++, but unfortunately I'm out of space here. However, I hope this detailed introduction has given you enough information to get you started.\n\nAs you can see, WinHTTP provides a modern and powerful API for writing HTTP client applications. Over and above all of the functionality I've described in this article, it also provides a few other important facilities including support for a variety of authentication schemes as well as supplying and validating certificates for SSL. Furthermore, it also provides functions for building and parsing URLs. If you are looking for a rich platform for building efficient and scalable HTTP client applications, WinHTTP may be just what you need.\n\nOne of the challenges in writing a reliable HTTP client application is the lack of a consistent way to retrieve proxy settings. What happens when the server cannot be reached? How do you determine which proxy server to use? Although there isn't a universal standard in place, with a little effort you can usually figure out which proxy server to use. Unfortunately, many applications instead simply prompt the user for the name of a proxy server. But I think that software should be smart enough not to require the user to supply information that software can usually figure out.\n\nThere are a few places to look for proxy settings. I'll start with the most direct approach. In my discussion on Session objects I introduced the WinHttpOpen function for creating a new session object:\n\nIt had a few parameters for proxy settings that I skimmed over initially. Here I'll describe what they do. The second parameter specifies the access type. Figure A lists the values that may be used.\n\nWINHTTP_ACCESS_TYPE_NO_PROXY indicates that proxy settings should not be retrieved or used. You can override this after the session has been created and I'll describe how to do that in a moment.\n\nWINHTTP_ACCESS_TYPE_DEFAULT_PROXY indicates that any proxy settings stored by WinHTTP in the registry should be used. This is useful in allowing administrators to control the proxy settings. It is also independent of Internet Explorer's proxy settings and is thus ideal for server scenarios. The proxycfg.exe utility may be used on Windows XP and Windows Server 2003 to set and query the WinHTTP proxy settings. The proxycfg.exe utility has been replaced on Windows Vista and Windows Server 2008 and the functionality is now provided by the netsh.exe utility. You can also set the WinHTTP proxy settings directly using the WinHttpSetDefaultProxyConfiguration function and query it using the WinHttpGetDefaultProxyConfiguration function. These settings persist across reboots and are shared by all logon sessions. Both functions use the WINHTTP_PROXY_INFO structure which maps directly to the three proxy-related parameters of the WinHttpOpen function.\n\nWINHTTP_ACCESS_TYPE_NAMED_PROXY indicates that WinHTTP should use the proxy settings in the next two parameters. WinHttpOpen's third parameter specifies the name of a proxy server and the fourth parameter specifies an optional list of HTTP servers that should not be routed through the proxy server specified in the previous parameter.\n\nIf you're writing a Windows service or server application then this may be all that you need. On the other hand, end users don't typically know how or want to configure proxy settings so a little more effort may be required to make it as seamless as possible. Another approach is to retrieve Internet Explorer's proxy settings since most users will have their browsers already configured to access the Web through a Web proxy. You can find the Internet Explorer dialog for configuring proxy settings by clicking the \"LAN settings\" button on the Connections tab of the Internet Explorer Options window. As this is a common requirement, WinHTTP provides the WinHttpGetIEProxyConfigForCurrentUser function for directly retrieving these very Internet Explorer proxy settings for the current user:\n\nThe non-null string member variables must be freed using the GlobalFree function. The fAutoDetect member maps to the \"Automatically detect settings\" option in the LAN settings dialog. The lpszAutoConfigUrl member maps to the \"Use automatic configuration script\" address and is only populated if this option is checked. The lpszProxy member maps to the \"Use a proxy server...\" address and port and is only populated if this option is checked. Finally, lpszProxyBypass maps to the list of servers specified in the Exceptions area of the window that appears when you click the Advanced button and is only populated if the \"Bypass proxy server for local addresses\" option is checked.\n\nIf lpszProxy is populated you're in luck as you can simply use it as the proxy server. Figuring out what to do in the case of the other options takes a bit more work.\n\nIf lpszAutoConfigUrl is populated then it means that Internet Explorer downloads a Proxy Auto-Configuration (PAC) file to determine the proxy server for a particular connection. Reproducing this behavior can be challenging since the downloaded PAC file often contains JavaScript that may be used to direct the client to a particular proxy server depending on the destination server. Fortunately WinHTTP provides the WinHttpGetProxyForUrl function that abstracts this for you:\n\nThe non-null string member variables of the WINHTTP_PROXY_INFO structure must also be freed using the GlobalFree function. The first WinHttpGetProxyForUrl parameter specifies the WinHTTP session handle. The second parameter specifies the URL of the request you would like to send. The third parameter is an input parameter and specifies a WINHTTP_AUTOPROXY_OPTIONS structure which controls the behavior of the WinHttpGetProxyForUrl function. This is where you specify the URL of the PAC file retrieved from Internet Explorer proxy settings. The last parameter is an out parameter and specifies the WINHTTP_PROXY_INFO structure that receives the results. The results can then be used with the WinHttpSetOption function along with the WINHTTP_OPTION_PROXY option to set the proxy settings for a particular request object.\n\nFinally, if WINHTTP_CURRENT_USER_IE_PROXY_CONFIG's fAutoDetect member variable is true it means that Internet Explorer uses the Web Proxy Auto-Discovery (WPAD) protocol to discover proxy settings. WPAD relies on updates to the network's DNS or DHCP servers to provide the URL of a PAC script so that clients don't have to be preconfigured with a specific PAC script. This is analogous to the relationship between static and dynamic IP addresses. You can instruct WinHttpGetProxyForUrl to use WPAD to discover the URL of the PAC file automatically by changing the WINHTTP_AUTOPROXY_OPTIONS initialization as follows:\n\nNaturally you can use the WinHTTP \"AutoProxy\" capabilities without a dependency on Internet Explorer. Using Internet Explorer settings is mainly a stopgap until WPAD becomes more ubiquitous in corporate network environments. If WPAD is not available on your network then WinHttpGetProxyForUrl may take a few seconds to return and GetLastError will return ERROR_WINHTTP_AUTODETECTION_FAILED.\n\nSend your questions and comments to mmwincpp@microsoft.com.\n\nKenny Kerr is a software craftsman specializing in software development for Windows. He has a passion for writing and teaching developers about programming and software design. Reach Kenny at weblogs.asp.net/kennykerr."
    },
    {
        "link": "https://stackoverflow.com/questions/65731778/microsoft-http-server-api-environment-requirments",
        "document": "I want my C++ application/process to be an HTTP server that listens to requests from another Java process. I am planning to use Microsoft's HTTP Server API for this, but the documentation says:\n\nDoes this mean that this only works on Windows Server 2003 but not later? I am using Microsoft Window Server 2019 standard.\n\nAlso, the documentation says:\n\nPSDK was replaced by Windows SDK a long time ago, and I am not able to find any sample in the Windows 10 SDK, and also I could not find any sample for the same on GIT.\n\nI am afraid that the HTTP Server API is deprecated, or I am looking at older resources.\n\nIs there any other solution for my problem?"
    },
    {
        "link": "https://github.com/MicrosoftDocs/win32/blob/docs/desktop-src/WinHttp/winhttp-sessions-overview.md",
        "document": "The Microsoft Windows HTTP Services (WinHTTP) exposes a set of C/C++ functions that enable your application to access HTTP resources on the Web. This topic provides an overview of how these functions are used to interact with an HTTP server.\n• Using the WinHTTP API to Access the Web\n\nThe following diagram shows the order in which WinHTTP functions are typically called when interacting with an HTTP server. The shaded boxes represent functions that generate an HINTERNET handle, while the plain boxes represent functions that use those handles.\n\nBefore interacting with a server, WinHTTP must be initialized by calling WinHttpOpen. WinHttpOpen creates a session context to maintain details about the HTTP session, and returns a session handle. Using this handle, the WinHttpConnect function is then able to specify a target HTTP or Secure Hypertext Transfer Protocol (HTTPS) server.\n\nThe WinHttpOpenRequest function opens an HTTP request for a particular resource and returns an HINTERNET handle that can be used by the other HTTP functions. WinHttpOpenRequest does not send the request to the server when called. The WinHttpSendRequest function actually establishes a connection over the network and sends the request.\n\nThe following example shows a sample call to WinHttpOpenRequest that uses the default options.\n\nThe WinHttpAddRequestHeaders function allows an application to append additional free-format request headers to the HTTP request handle. It is intended for use by sophisticated applications that require precise control over the requests sent to the HTTP server.\n\nThe WinHttpAddRequestHeaders function requires an HTTP request handle created by WinHttpOpenRequest, a string that contains the headers, the length of the headers, and any modifiers.\n\nThe following modifiers can be used with WinHttpAddRequestHeaders.\n\nThe WinHttpSendRequest function establishes a connection to the server and sends the request to the specified site. This function requires an HINTERNET handle created by WinHttpOpenRequest. WinHttpSendRequest can also send additional headers or optional information. The optional information is generally used for operations that write information to the server, such as PUT and POST.\n\nAfter the WinHttpSendRequest function sends the request, the application can use the WinHttpReadData and WinHttpQueryDataAvailable functions on the HINTERNET handle to download the server's resources.\n\nTo post data to a server, the HTTP verb in the call to WinHttpOpenRequest must be either POST or PUT. When WinHttpSendRequest is called, the dwTotalLength parameter should be set to the size of the data in bytes. Then use WinHttpWriteData to post the data to the server.\n\nAlternatively, set the lpOptional parameter of WinHttpSendRequest to the address of a buffer that contains data to post to the server. When using this technique, you must set both the dwOptionalLength and dwTotalLength parameters of WinHttpSendRequest to be the size of the data being posted. Calling WinHttpSendRequest in this manner eliminates the need to call WinHttpWriteData.\n\nThe WinHttpQueryHeaders function allows an application to retrieve information about an HTTP request. The function requires an HINTERNET handle created by WinHttpOpenRequest, an information level value, and a buffer length. WinHttpQueryHeaders also accepts a buffer that stores the information and a zero-based header index that enumerates multiple headers with the same name.\n\nUse any of the information level values found on the Query Info Flags page with a modifier to control the format in which the information is stored in the lpvBuffer parameter of WinHttpQueryHeaders.\n\nAfter opening a request with the WinHttpOpenRequest function, sending it to the server with WinHttpSendRequest, and preparing the request handle to receive a response with WinHttpReceiveResponse, the application can use the WinHttpReadData and WinHttpQueryDataAvailable functions to download the resource from the HTTP server.\n\nThe following sample code shows how to download a resource with secure transaction semantics. The sample code initializes the WinHTTP application programming interface (API), selects a target HTTPS server, and then opens and sends a request for this secure resource. WinHttpQueryDataAvailable is used with the request handle to determine how much data is available for download, and then WinHttpReadData is used to read that data. This process is repeated until the entire document has been retrieved and displayed.\n\nDWORD dwSize = ; DWORD dwDownloaded = ; LPSTR pszOutBuffer; BOOL bResults = ; HINTERNET hSession = , hConnect = , hRequest = ; hSession = WinHttpOpen( , WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, WINHTTP_NO_PROXY_NAME, WINHTTP_NO_PROXY_BYPASS, ); ( hSession ) hConnect = WinHttpConnect( hSession, , INTERNET_DEFAULT_HTTPS_PORT, ); ( hConnect ) hRequest = WinHttpOpenRequest( hConnect, , , , WINHTTP_NO_REFERER, WINHTTP_DEFAULT_ACCEPT_TYPES, WINHTTP_FLAG_SECURE ); ( hRequest ) bResults = WinHttpSendRequest( hRequest, WINHTTP_NO_ADDITIONAL_HEADERS, , WINHTTP_NO_REQUEST_DATA, , , ); ( bResults ) bResults = WinHttpReceiveResponse( hRequest, ); Keep checking for data until there is nothing left. ( bResults ) { { dwSize = ; ( ! ( hRequest, &dwSize ) ) ( , ( ) ); pszOutBuffer = [dwSize+ ]; ( !pszOutBuffer ) { ( ); dwSize= ; } { ( pszOutBuffer, dwSize+ ); ( ! ( hRequest, (LPVOID)pszOutBuffer, dwSize, &dwDownloaded ) ) ( , ( ) ); ( , pszOutBuffer ); Free the memory allocated to the buffer. pszOutBuffer; } } ( dwSize > ); } ( !bResults ) ( , GetLastError( ) ); ( hRequest ) WinHttpCloseHandle( hRequest ); ( hConnect ) WinHttpCloseHandle( hConnect ); ( hSession ) WinHttpCloseHandle( hSession );"
    }
]