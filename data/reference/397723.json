[
    {
        "link": "https://svgjs.dev",
        "document": ""
    },
    {
        "link": "https://svgjs.dev/docs/3.0/contributing/documentation",
        "document": "The SVG.js docs are built upon Kirby with the KDoc theme.\n• Download or clone the svgdotjs.github.io repo and switch to the branch.\n• Run . This is only required the first time.\n• Run which will open up your default browser with the docs running.\n\nLog in to Kirby on localhost:8030/panel using username svgjs and password svgjs.\n\nThe text editors in Kirby are Markdown and Kirbytext enabled.\n\nIf you're not a core collaborator on svgdotjs, fork the branch, make the required changes in Kirby following the same style as the rest of the docs, and create a PR. We will take care of the rest, so no need to build or include a static version.\n• Go to localhost:8030/statify.php in a web browser to run the build. The static files will be generated in a folder called at the root of the repo.\n• Move the folder out of the repo.\n• Commit and push the changes in the branch and switch to the branch.\n• Replace the folder in the branch with the newly generated folder.\n• Commit and push the changes in the branch and you're done!"
    },
    {
        "link": "https://svgjs.dev/docs/3.0",
        "document": "The lightweight library for manipulating and animating SVG.\n\nSVG.js has no dependencies and aims to be as small as possible while providing close to complete coverage of the SVG spec. If you're not convinced yet, here are a few highlights.\n\nSVG.js is fast. Obviously not as fast as vanilla js, but many times faster than the competition:\n\nLess is better. Tested on an Intel Core i7-4702MQ @ 2.2GHz.\n\nCreating and manipulating SVG using JavaScript alone is pretty verbose. For example, just creating a simple pink square requires quite a lot of code:\n\nSVG.js provides a syntax that is concise and easy to read. Doing the same as the vanilla js example above:\n\nThat's just two lines of code instead of ten! And a whole lot less repetition.\n\nThere is more...\n• painless extension thanks to the modular structure\n• various useful plugins available\n• fully documented (you're looking at it :)\n\nSVG.js is licensed under the terms of the MIT License.\n\nWondering what has changed in the latest releases? Have a look at the change log."
    },
    {
        "link": "https://github.com/svgdotjs/svg.js/releases",
        "document": "To see all available qualifiers, see our documentation .\n\nSaved searches Use saved searches to filter your results more quickly\n\nWe read every piece of feedback, and take your input very seriously.\n\nYou signed in with another tab or window. Reload to refresh your session.\n\nYou signed out in another tab or window. Reload to refresh your session.\n\nYou switched accounts on another tab or window. Reload to refresh your session."
    },
    {
        "link": "https://w3.org/TR/SVG2",
        "document": "This specification defines the features and syntax for Scalable Vector Graphics (SVG) Version 2. SVG is a language based on XML for describing two-dimensional vector and mixed vector/raster graphics. SVG content is stylable, scalable to different display resolutions, and can be viewed stand-alone, mixed with HTML content, or embedded using XML namespaces within other XML languages. SVG also supports dynamic changes; script can be used to create interactive documents, and animations can be performed using declarative animation features or by using script.\n\nThis section describes the status of this document at the time of its publication. Other documents may supersede this document. A list of current W3C publications and the latest revision of this technical report can be found in the W3C technical reports index at https://www.w3.org/TR/.\n\nThis document is the 04 October 2018 Candidate Recommendation of SVG 2. This version of SVG builds upon SVG 1.1 Second Edition by improving the usability and precision of the language. The Changes appendix lists all of the changes that have been made since SVG 1.1 Second Edition.\n\nPublication as a Candidate Recommendation does not imply endorsement by the W3C Membership. This is a draft document and may be updated, replaced or obsoleted by other documents at any time. It is inappropriate to cite this document as other than work in progress.\n\nThis Candidate Recommendation is expected to advance to Proposed Recommendation no earlier than 04 December 2018.\n\nThere is no preliminary implementation report at this time. The SVG Working Group is working on a test suite for SVG2 and expects to produce an implementation report based on those tests.\n\nComments on this Candidate Recommendation are welcome. Comments can be raised as GitHub issues (preferred), or alternatively be sent to www-svg@w3.org, the public email list for issues related to vector graphics on the Web. This list is archived and senders must agree to have their message publicly archived from their first posting. To subscribe send an email to www-svg-request@w3.org with the word in the subject line.\n\nThis document has been produced by the W3C SVG Working Group as part of the Graphics Activity within the W3C Interaction Domain. The goals of the W3C SVG Working Group are discussed in the W3C SVG Charter. The W3C SVG Working Group maintains a public Web page, https://www.w3.org/Graphics/SVG/, that contains further background information. The authors of this document are the SVG Working Group participants.\n\nThis document was produced by a group operating under the W3C Patent Policy. W3C maintains a public list of any patent disclosures made in connection with the deliverables of the group; that page also includes instructions for disclosing a patent. An individual who has actual knowledge of a patent which the individual believes contains Essential Claim(s) must disclose the information in accordance with section 6 of the W3C Patent Policy.\n\nA list of current W3C Recommendations and other technical documents can be found at https://www.w3.org/TR/. W3C publications may be updated, replaced, or obsoleted by other documents at any time.\n\nThis document is governed by the 1 February 2018 W3C Process Document.\n\nAll features in this specification depend upon implementation in browsers or authoring tools. If a feature is not certain to be implemented, we define that feature as \"at risk\". At-risk features will be removed from the current specification, and may be included in future versions of the specification. If an at-risk feature is particularly important to authors of SVG, those authors are encouraged to give feedback to implementers regarding its priority. The following features are at risk, and may be dropped during the CR period:\n• More than one or to provide localisation\n\nThe SVG Working Group would like to thank the following people for contributing to this specification with patches or by participating in discussions that resulted in changes to the document: David Dailey, Eric Eastwood, Jarek Foksa, Daniel Holbert, Paul LeBeau, Robert Longson, Henri Manson, Ms2ger, Kari Pihkala, Philip Rogers, David Zbarsky.\n\nIn addition, the SVG Working Group would like to acknowledge the contributions of the editors and authors of the previous versions of SVG – as much of the text in this document derives from these earlier specifications – including:\n\nFinally, the SVG Working Group would like to acknowledge the great many people outside of the SVG Working Group who help with the process of developing the SVG specifications. These people are too numerous to list individually. They include but are not limited to the early implementers of the SVG 1.0 and 1.1 languages (including viewers, authoring tools, and server-side transcoders), developers of SVG content, people who have contributed on the www-svg@w3.org and svg-developers@yahoogroups.com email lists, other Working Groups at the W3C, and the W3C Team. SVG 1.1 is truly a cooperative effort between the SVG Working Group, the rest of the W3C, and the public and benefits greatly from the pioneering work of early implementers and content developers, feedback from the public, and help from the W3C team."
    },
    {
        "link": "https://medium.com/bluecore-engineering/svgs-b%C3%A9zier-curves-and-nodes-oh-my-540ea6cfeae5",
        "document": "When evaluating the current open source offerings, we considered a multitude of options including:\n• Countless tree rendering libraries (including D3 and various forks of the D3 tree implementation as well as some React specific tree libraries)\n\nOver a period of a week and a half, we evaluated the alternatives and at the end of that time, we were left with the realization that the best we could do using these libraries wasn’t good enough for what we needed:\n• D3 didn’t work for us because while it gave us the flexibility over the lines that we needed, the actual nodes themselves weren’t customizable enough as is and would have required a greater amount of effort to work around.\n• A lot of the tree rendering libraries required us to pre-define the configurations of the trees and then they would simply inject the variables and values where needed. That was a problem because the whole point of this feature is to support almost any configuration of lines and nodes.\n• Sankey diagrams led us down a whole rabbit hole of other options and trade-offs, but ultimately we were left with the realization that we would just need to come up with our own solution.\n\nSome of the custom options we considered but ended up discarding were:\n• Using HTML elements and just using styling to control the look and positioning of the lines\n• Using the HTML Canvas methods and drawing the lines by moving to each point separately\n\nWe discarded Option 1 because it would have forced us to spend a lot of time on styling the elements and we would have had to make too many compromises on design. Meanwhile, Option 2 would have involved some heavy calculations each time the components needed to be updated and would have made the code more unreadable and harder to maintain in the future.\n\nHaving exhausted those choices, we spent two days prototyping a few options and there was one that was clearly superior. The final design we landed on to render the structures we needed was a mix of Scalable Vector Graphics (SVG) paths and React components.\n\nOnce we had a plan in place, the question then became: Where do we even start with this? One of the things that was clear from the beginning was that we needed to keep track of the parent-child relationships of our nodes since all of the positioning of the elements relied on the positioning of the parent nodes. For example, if we have a node `Foo` that has two children: `Bar` and `Baz`, where we render Bar and Baz directly relies on where `Foo` is positioned. Furthermore, the shapes of the lines connecting the children to the parent node needed to be smooth curves that we could easily define. So for each line we needed to be able to connect two nodes: the parent and the child. To do so, we needed at least:\n• Location of the parent = starting point of the line\n• Location of the child node = ending point of the line\n• Intermediate point(s) defining the smoothness and definition of the curve itself\n\nThese requirements led us to cubic Bézier curves because they are widely used in vector graphics to model smooth curves and they require only three defining sets of coordinates: Two control points that specify where the curve begins and ends and the actual point (x,y) where you want the line to end (the starting point of the line is handled separately). This is exactly what we wanted!\n\nBut before we get into the actual calculations of our starting and ending points, let’s talk about SVG paths. SVGs themselves are defined in XML format within HTML <svg /> tags. The path element is used to create lines, curves, arcs and other 2d shapes. The shape of the path element is defined by the d attribute which contains a series of commands and parameters that the commands use. In the example below, the M command is the “move to” command so it specifies that the path will move to and in this case start at the coordinate (10,55). Using SVG paths was a clear choice then because two of the three curve commands for SVG paths (denoted by the C in the example below) use Bézier curves! For more about reading and understanding SVG paths, check out this handy tutorial.\n\nUsing all this information about Bézier curves and SVG paths, we came up with a few formulas to generate the Bézier curves, which use the position of the parent node as well as the number of sibling nodes the child node has in order to calculate the starting and ending points for the curves. Once the starting and ending points of the lines have been calculated, we pass the coordinates into React components to be rendered into SVG paths.\n\nOne of the other main reasons for going with SVG paths was the ability to render the nodes themselves as separate HTML components from the lines. Since the lines and the nodes are independently created, the positioning of the nodes simply relies on using the already calculated coordinates of the lines. The ending coordinate of a line is also the starting coordinate of the child node. Since the structure of our entire tree is stored as a hierarchical representation of the nodes, by recursively iterating through the tree and drawing each node as it is processed along with the lines that connect it to its children, we are able to parallelize the rendering of the lines and the nodes. This is a modified preorder traversal of the tree which uses a visitor design pattern to actually process and render each node appropriately. Thus, each node is actually a React component that is added to the results of the recursive call which are eventually rendered. Since each node is represented as an HTML component, it is extremely easy to customize and control the elements.\n\nThe basic implementation of the lines and nodes can be boiled down to the following:\n• Calculate the starting and ending points for the Bézier curve control points\n\nOnce we had the rendering of the lines and nodes figured out, all that was left was to tweak the formulas used to calculate the starting and ending points. At one point, we even had the length of the lines as a customizable option that resulted in lines of time-proportionate length. Since the rendering of the lines and nodes has been separated, making changes like that are relatively simple and do not require large re-writes of the code, which is obviously optimal. There are also some optimizations to reduce the amount of times the whole tree structure needs to be iterated over as well as how often each element renders due to changes in other elements. However, since it all depends on the positioning of the other elements, we needed a solution that would allow for quick and lightweight re-renders and updates as needed.\n\nWe could have probably spent time cobbling together bits and pieces of various open source solutions for tree and line graphs to come up with something that fit our needs, but we found that it made more sense to implement a custom solution given the parameters of the problem we needed to solve. In our case, configurability and customizability were two things we simply couldn’t give up, and that meant we couldn’t use an existing solution easily. In general, we say evaluate the current offerings out there, and if none quite fit what you need, figure out the best approach that gives you the things that are missing. If you need a highly customizable and configurable network of curves and nodes, we are planning on open sourcing our approach in the future, but in the meantime we recommend you look into Bézier curves and SVG paths."
    },
    {
        "link": "https://stackoverflow.com/questions/19230034/bezier-curves-in-svg",
        "document": "I would like to draw Bezier Curves in SVG, and i know that the code looks like:\n\nbut what to do if i want to give attributes on page i mean like:\n\nwhere cx,cy,r are given from page text field after i submit it with button. I would like to draw them in loop so that every curve would be difrent."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorials/SVG_from_scratch/Paths",
        "document": "The element is the most powerful element in the SVG library of basic shapes. It can be used to create lines, curves, arcs, and more. Paths create complex shapes by combining multiple straight lines or curved lines. Complex shapes composed only of straight lines can be created as elements. While and elements can create similar-looking shapes, elements require a lot of small straight lines to simulate curves and don't scale well to larger sizes. A good understanding of paths is important when drawing SVGs. While creating complex paths using an XML editor or text editor is not recommended, understanding how they work will allow to identify and repair display issues in SVGs. The shape of a element is defined by one parameter: . (See more in basic shapes.) The attribute contains a series of commands and parameters used by those commands. Each of the commands is instantiated (for example, creating a class, naming and locating it) by a specific letter. For instance, let's move to the x and y coordinates ( , ). The \"Move to\" command is called with the letter . When the parser runs into this letter, it knows it needs to move to a point. So, to move to ( , ) the command to use would be . After that, the parser begins reading for the next command. All of the commands also come in two variants. An uppercase letter specifies absolute coordinates on the page, and a lowercase letter specifies relative coordinates (e.g., move 10px up and 7px to the left from the last point). Coordinates in the parameter are always unitless and hence in the user coordinate system. Later, we will learn how paths can be transformed to suit other needs.\n\nThere are five line commands for nodes. The first command is the \"Move To\" or , which was described above. It takes two parameters, a coordinate ( ) and coordinate ( ) to move to. If the cursor was already somewhere on the page, no line is drawn to connect the two positions. The \"Move To\" command appears at the beginning of paths to specify where the drawing should start. For example: In the following example there's only a point at ( , ). Note, though, that it wouldn't show up if a path was just drawn normally. For example: There are three commands that draw lines. The most generic is the \"Line To\" command, called with . takes two parameters—x and y coordinates—and draws a line from the current position to a new position. There are two abbreviated forms for drawing horizontal and vertical lines. draws a horizontal line, and draws a vertical line. Both commands only take one parameter since they only move in one direction. An easy place to start is by drawing a shape. We will start with a rectangle (the same type that could be more easily made with a element). It's composed of horizontal and vertical lines only. We can shorten the above path declaration a little bit by using the \"Close Path\" command, called with . This command draws a straight line from the current position back to the first point of the path. It is often placed at the end of a path node, although not always. There is no difference between the uppercase and lowercase command. So our path above could be shortened to: The relative forms of these commands can also be used to draw the same picture. Relative commands are called by using lowercase letters, and rather than moving the cursor to an exact coordinate, they move it relative to its last position. For instance, since our rectangle is 80×80, the element could have been written as: The path will move to point ( , ) and then move horizontally 80 points to the right, then 80 points down, then 80 points to the left, and then back to the start. In these examples, it would probably be more intuitive to use the or elements. However, paths are used so often in drawing SVG that developers may be more comfortable using them instead. There is no real performance penalty or bonus for using one or the other.\n\nThe cubic curve, , is the slightly more complex curve. Cubic Béziers take in two control points for each point. Therefore, to create a cubic Bézier, three sets of coordinates need to be specified. C x1 y1, x2 y2, x y (or) c dx1 dy1, dx2 dy2, dx dy The last set of coordinates here ( , ) specify where the line should end. The other two are control points. ( , ) is the control point for the start of the curve, and ( , ) is the control point for the end. The control points essentially describe the slope of the line starting at each point. The Bézier function then creates a smooth curve that transfers from the slope established at the beginning of the line, to the slope at the other end. <svg width=\"190\" height=\"160\" xmlns=\"http://www.w3.org/2000/svg\"> <path d=\"M 10 10 C 20 20, 40 20, 50 10\" stroke=\"black\" fill=\"transparent\"/> <path d=\"M 70 10 C 70 20, 110 20, 110 10\" stroke=\"black\" fill=\"transparent\"/> <path d=\"M 130 10 C 120 20, 180 20, 170 10\" stroke=\"black\" fill=\"transparent\"/> <path d=\"M 10 60 C 20 80, 40 80, 50 60\" stroke=\"black\" fill=\"transparent\"/> <path d=\"M 70 60 C 70 80, 110 80, 110 60\" stroke=\"black\" fill=\"transparent\"/> <path d=\"M 130 60 C 120 80, 180 80, 170 60\" stroke=\"black\" fill=\"transparent\"/> <path d=\"M 10 110 C 20 140, 40 140, 50 110\" stroke=\"black\" fill=\"transparent\"/> <path d=\"M 70 110 C 70 140, 110 140, 110 110\" stroke=\"black\" fill=\"transparent\"/> <path d=\"M 130 110 C 120 140, 180 140, 170 110\" stroke=\"black\" fill=\"transparent\"/> </svg> The example above creates nine cubic Bézier curves. As the curves move toward the right, the control points become spread out horizontally. As the curves move downward, they become further separated from the end points. The thing to note here is that the curve starts in the direction of the first control point, and then bends so that it arrives along the direction of the second control point. Several Bézier curves can be strung together to create extended, smooth shapes. Often, the control point on one side of a point will be a reflection of the control point used on the other side to keep the slope constant. In this case, a shortcut version of the cubic Bézier can be used, designated by the command (or ). produces the same type of curve as earlier—but if it follows another command or a command, the first control point is assumed to be a reflection of the one used previously. If the command doesn't follow another or command, then the current position of the cursor is used as the first control point. The result is not the same as what the command would have produced with the same parameters, but is similar. An example of this syntax is shown below, and in the figure to the left the specified control points are shown in red, and the inferred control point in blue. The other type of Bézier curve, the quadratic curve called with , is actually a simpler curve than the cubic one. It requires one control point which determines the slope of the curve at both the start point and the end point. It takes two parameters: the control point and the end point of the curve. Note: The co-ordinate deltas for are both relative to the previous point (that is, and are not relative to and ). As with the cubic Bézier curve, there is a shortcut for stringing together multiple quadratic Béziers, called with . This shortcut looks at the previous control point used and infers a new one from it. This means that after the first control point, fairly complex shapes can be made by specifying only end points. This only works if the previous command was a or a command. If not, then the control point is assumed to be the same as the previous point, and only lines will be drawn. Both curves produce similar results, although the cubic one allows greater freedom in exactly what the curve looks like. Deciding which curve to use is situational and depends on the amount of symmetry the line has.\n\nThe other type of curved line that can be created using SVG is the arc, called with the command. Arcs are sections of circles or ellipses. For a given x-radius and y-radius, there are two ellipses that can connect any two points (as long as they're within the radius of the circle). Along either of those circles, there are two possible paths that can be taken to connect the points—so in any situation, there are four possible arcs available. Because of that, arcs require quite a few parameters: At its start, the arc element takes in two parameters for the x-radius and y-radius. If needed, see s and how they behave. The final two parameters designate the x and y coordinates to end the stroke. Together, these four values define the basic structure of the arc. The third parameter describes the rotation of the arc. This is best explained with an example: The example shows a element that goes diagonally across the page. At its center, two elliptical arcs have been cut out (x radius = , y radius = ). In the first one, the x-axis-rotation has been left at , so the ellipse that the arc travels around (shown in gray) is oriented straight up and down. For the second arc, though, the x-axis-rotation is set to degrees. This rotates the ellipse so that it is aligned with its minor axis along the path direction, as shown by the second ellipse in the example image. For the unrotated ellipse in the image above, there are only two different arcs and not four to choose from because the line drawn from the start and end of the arc goes through the center of the ellipse. In a slightly modified example the two ellipses that form the four different arcs can be seen: Notice that each of the blue ellipses are formed by two arcs, depending on traveling clockwise or counter-clockwise. Each ellipse has one short arc and one long arc. The two ellipses are just mirror images of each other. They are flipped along the line formed from the start→end points. If the start→end points are farther than the ellipse's and radius can reach, the ellipse's radii will be minimally expanded so it could reach the start→end points. The interactive codepen at the bottom of this page demonstrates this well. To determine if an ellipse's radii are large enough to require expanding, a system of equations would need to be solved, such as this on wolfram alpha. This computation is for the non-rotated ellipse with start→end ( , )→( , ). The solution, ( , ), is the center of the ellipse(s). The solution will be imaginary if the ellipse's radii are too small. This second computation is for the non-rotated ellipse with start→end ( , )→( , ). The solution has a small imaginary component because the ellipse was just barely expanded. The four different paths mentioned above are determined by the next two parameter flags. As mentioned earlier, there are still two possible ellipses for the path to travel around and two different possible paths on both ellipses, giving four possible paths. The first parameter is the . It determines if the arc should be greater than or less than 180 degrees; in the end, this flag determines which direction the arc will travel around a given circle. The second parameter is the . It determines if the arc should begin moving at positive angles or negative ones, which essentially picks which of the two circles will be traveled around. The example below shows all four possible combinations, along with the two circles for each case. Arcs are an easy way to create pieces of circles or ellipses in drawings. For instance, a pie chart would require a different arc for each piece. If transitioning to SVG from , arcs can be the hardest thing to learn, but are also much more powerful. Complete circles and ellipses are the only shapes that SVG arcs have trouble drawing. Because the start and end points for any path going around a circle are the same point, there are an infinite number of circles that could be chosen, and the actual path is undefined. It's possible to approximate them by making the start and end points of the path slightly askew, and then connecting them with another path segment. For example, it's possible to make a circle with an arc for each semi-circle. At that point, it's often easier to use a real or node instead. This interactive demo might help understand the concepts behind SVG arcs: https://codepen.io/lingtalfi/pen/yaLWJG (tested in Chrome and Firefox only, might not work in your browser)"
    },
    {
        "link": "https://pages.graphics.cs.wisc.edu/559-sp21/tutorials/svg/svg6",
        "document": "Note: this is part 6 of the 6 part SVG tutorial copied over from 2014. This Tutorial discusses Bézier curves (after it discusses paths) which are a topic that we won’t get to until week 5 or 6 in CS559.\n\nSVG has the ability to draw arbitrary shapes using its primitive. The primitive is discussed in detail in the Mozilla SVG Tutorial: Paths.\n\nThe basic idea is that paths encode a sequence of simple curve pieces (such as lines and arcs) in a string that is given as an attribute of the primitive.\n\nHere is a simple example:\n\nThe key thing is the parameter, where the path data goes. Notice that the path begins with an (moveto) command that tells SVG where to move the pen to. The command has two numbers (x and y). Then there’s an command (or lineto) that tell SVG to draw a line connecting the current pen position to the new position.\n\nEffectively, the string is a little program is a “language” that lets you specify shapes. The programs are lists of commands (each command is a letter), followed by some numbers that are the parameters for the commands.\n\nThe most important commands for us in this language are:\n• for “closepath” - the connects back to the last “move to point”\n• for “Quaratic” Bézier curves (takes 4 parameters - X and Y for 2 control points)\n• for “Cubic” Bézier curves (takes 4 parameters - X and Y for 3 control points)\n• for “arc” to create circular or elliptical arcs (takes 7 parameters)\n\nNote: for all commands, there is a lower-case version where X and Y are relative to the last drawing position.\n\nThese are all well documented in the Mozilla SVG Tutorial: Paths.\n\nYou can think of the path string as a sequence of commands that tell SVG how to move it’s pen.\n\nThe (moveto) command moves the pen to a new location, whereas everything else “draws” with the pen to the new location. Here is a simple example of a single path: ( svg6-2.svg )\n• I am using commas between X and Y - you can use spaces.\n• The first triangle doesn’t have a to close the path - it still fills correctly, but the stroke doesn’t go all the way around.\n• The path is not connected - the second (moveto) moves the pen to a new location without drawing it.\n\nHere is the same thing drawn in a slightly different way: ( svg6-2a.svg )\n\nNote how here I used relative movement (lower case commands) to describe how the pen moves from its current position (rather than giving its target X,Y position). I also used the single-axis line commands.\n\nWhat to do with Paths\n\nUnlike HTML Canvas, SVG Paths are both stroked and filled. You can specify the colors for each. If you don’t want to fill, set fill to . If you don[’t want to stroke, set stroke to (you probably want to do one or the other).\n\nThe styles (for stroke and fill) are inherited from the enclosing group. If nothing is specified, things fill with black and have no stroke color.\n\nA warning: the default is to fill objects with black. If you’re trying to draw a curve, this is probably not what you want to do. Be sure to set if that’s what you mean to do. If you fill a path, SVG will connect the first and last points for you (even if you leave out the “close paths”). Notice what happens if I try to draw some L shapes: ( svg6-3.svg )\n\nSVG has good facilitities for drawing 2D curves. This is a good way to experiment with Bézier curves (since it supports them).\n\nSVG curve drawing is through the “path” tag object. Unlike other objects (like lines and circles), paths don’t have a bunch of parameters: they take a single string that describes the entire path. Once you figure out how to make these strings, paths aren’t so hard.\n\nA path is a piecewise curve. For each piece, you can either move the “pen” to a new location, or add a new piece of curve starting wherever the pen was last. The pieces can be line segments, quadratic or cubic Bézier segments, and elliptical arc segments (which includes circular arcs).\n\nThe official documentation is here, and has a lot of details you may not care about. But it also has some good examples.\n\nOf course, we didn’t have to stop with just 1 and 1 We could keep going\n\nNotice here that after adding a line segment, I then moved to a new place and started drawing lines again.\n\nIf you’re just drawing lines, there are probably easier ways to do it. But the nice thing about paths is that you can add other curve types in the paths. For example, you can attach a line to a Bézier Segment:\n\nHere, notice that we made a cubic Bézier segment (the C command). As you know, cubic Béziers have 4 control points. The first one is the position of the pen before the C command, so there are 6 numbers for the parameters of the C command (3 points, each with x and y).\n\nYou are welcome to make the curve be discontinuous by putting the control points anywhere you like. You can also mix and match curve types. This uses a quadratic bezier, two line segments, and an elliptical arc.\n\nThe parameters for the arc segments are confusing. They are rx, ry, theta, large-arc-flag, sweep-flag, x, y.\n• rx, ry are the radii of the ellipse\n• theta is the orientation of the ellipse (if the major axis isn’t aligned with the X/Y axes)\n• the flags tell which way around the ellipse to go. If you read the documentation a few times, you might get it. But probably you’ll set these by trial and error.\n• x,y is the position where the curve ends.\n\nThe nice thing about figuring this out (especially for Béziers) is that you can experiment with Bézier curves without having to figure out how to implement them. It’s also nice that SVG can fill the curved shapes (which is tricky to implement)."
    },
    {
        "link": "https://joshwcomeau.com/animation/dynamic-bezier-curves",
        "document": "In 2018, I had a problem. I had been publishing my blog posts on Medium, but I was getting frustrated by the lack of control. I had all these whimsical ideas bouncing around in my head, and no outlet! And so, I decided to build my own blog.\n\nLooking back, the first version of my blog was pretty cringy, but there was one cool feature that I'm still pretty happy with. The lime-green hero had these dramatic swoops, and they flattened out on scroll:\n\nIn this blog post, I'm going to show you how I did this. We’ll learn how to create swoopy SVGs that can be updated dynamically:\n\nFor achieving this effect, we'll use SVG. We could also use HTML Canvas, but I generally prefer to work with SVG. It's more React-like in its API, there's less complexity in setting it up, and it's more a11y-friendly.\n\nWhile doing a deep dive into SVG is beyond the scope of this post (I'd recommend the W3Schools tutorial (opens in new tab) for that), we'll cover the basics, and show how to create some shapes from scratch. Experienced SVG-ers can jump to the next section.\n\nThe simplest form of SVG drawings use shape elements, like or .\n\nTry tweaking some of the values below, to build an understanding of how SVG shapes work:\n\nThese shapes are straightforward and declarative, but that simplicity comes at the cost of flexibility; you can only create a handful of different shapes.\n\nTo do neat curvy things, we need to use the element. This swiss-army-knife of an SVG primitive lets you specify a sequence of steps to execute, in a seemingly-inscrutable bundle of letters and numbers:\n\nThe interactive code snippet above uses 2 commands:\n• None , which instructs the path to move to a specific coordinate.\n• None , which instructs the path to create a line from the current position to the specified coordinate.\n\nAfter the commands and , we see some numbers. These can be thought of as \"arguments\" for the commands. In this case, the arguments are coordinates; both commands require a single X/Y pair.\n\nIn other words, we can read the above path as: \"Move to , then draw a line to \", and so on.\n\nThe coordinate system is relative to the values specified in the . The current viewbox specifies that the viewable area has a top-left corner of 0/0, a width of 300, and a height of 300. So all of the coordinates specified in the are within that 300x300 box.\n\nThe is what makes SVGs scalable; we can make our SVG any size we like, and everything will scale naturally, since the elements within our SVG are relative to this 300x300 box.\n\nThe element features quite a number (opens in new tab) of these commands. There are two that are relevant for our purposes:\n• None , which instructs the path to create a quadratic Bézier curve.\n• None , which instructs the path to create a cubic Bézier curve.\n\nBézier curves are surprisingly common. Due to their versatility, they're a staple in most graphics software like Photoshop, but they're also used as timing functions: if you've ever used non-linear CSS transitions (like the default \"ease\"), you've already worked with Bézier curves!\n\nBut what are they, and how do they work?\n\nA Bézier curve is essentially a line from a start point to an end point that is acted upon by one or more control points. A control point curves the line towards it, as if the control point was pulling it in its direction.\n\nThe following line looks like a straight line, but check out what happens when you move the points around—try dragging the middle control point up and down.\n\nThe line above is a quadratic Bézier curve; this means that it has a single control point. I'm guessing it gets its name from the fact that you can create parabola-like shapes with it:\n\nA cubic Bézier curve, in contrast, has two control points. This allows for much more interesting curves:\n\nThe syntax for Bézier curves in SVG definitions is a little counter-intuitive, but it looks like this. The following code is written in JSX, rather than HTML, so that I can name the variables:\n\nThe thing that makes this counter-intuitive, to me at least, is that the is inferred in the command; while there are 3 points needed for a quadratic Bézier curve, only 2 points are passed as arguments to .\n\nSimilarly, for a cubic Bézier curve, only the control points and the end point are provided to the command.\n\nThis syntax does mean that curves can conveniently be chained together, as one curve starts where the last one ends:\n\nOk, I think that's enough playing with vanilla SVGs. Let's see how we can leverage React to make these curves dynamic!\n\nUp to this point, we've been looking at static SVGs. How do we make them change, over time or based on user input?\n\nWell, in keeping with the \"meta\" theme of this blog post, why not examine the draggable-with-lines Bézier curves from earlier in this post?\n\nThere's a fair bit of code to manage this, even in this slightly-simplified snippet. I've annotated it heavily, which hopefully makes things easier to parse. 🤞\n\nTo summarize how this works:\n• None React holds variables in component state for , , and .\n• None In the render method, we build the instructions for the using these state variables.\n• None When the user clicks or taps on one of the points, we update the state to keep track of which point is moving with .\n• None As the user moves the mouse (or finger) across the SVG's surface, we do some calculations to figure out where the currently-dragging point needs to move to. This is made complex by the fact that SVGs have their own internal coordinate system (viewBox), and so we have to translate the on-screen pixels to this system.\n• None Once we have the new X/Y coordinate for the active point, lets React know about this state change, and the component re-renders, which causes the to be re-calculated.\n\nBy using React's update cycle to manage the point coordinates, there is added overhead of letting React run its reconciliation cycle on every . Is this prohibitively expensive?\n\nThe answer is that it depends. React's reconciliation can be surprisingly fast, especially when dealing with such a small tree (after all, the only thing that needs to be diffed is an SVG). Especially in \"production\" mode, when React doesn't have to do a lot of dev warning checks, this process can take fractions of a millisecond.\n\nI wrote an alternative implementation (opens in new tab) that updates the DOM directly. It does run faster (about 50% faster in my quick test), but both implementations still clock in under 1ms on modern high-end hardware. On the cheapest Chromebook I could find, the \"unoptimized\" one still averaged 50fps or so.\n\nI seem to have gotten a little side-tracked! Our original goal was to create a Bézier curve that flattens itself on scroll.\n\nGiven what we've gone over so far, we have almost all of the tools we need to solve this problem! A Bézier curve with its control point(s) directly between the start and end points is actually a straight line! So we need to transition the control points from their curvy values to a flat value.\n\nWe need a way to interpolate values. We know where the control points should be at 0% and 100%, but what about when the user is 25% scrolled through the content?\n\nWhile we could be fancy and ease the transition, a linear transformation works just fine for our purposes. So when the user is 50% scrolled through the content, the control points will be 50% of the way between their initial curvy value, and the flat-line value.\n\nFor this, some secondary-school maths will come in handy. If you're already up to speed on interpolation, you can skip this bit.\n\nIf you plumb the depths of your memory, you may remember how to calculate the slope of a line. The slope tells you how the line changes over time. We calculate it by dividing the change in y over the change in x:\n\nThere's also this rascal, the linear equation formula. This allows us to graph a straight line, and figure out the y value for a given x value. By convention, slope is given the variable a:\n\nHow does this relate to interpolation? Well, let's imagine that our Bézier curve's control point, when it's all curvy, is 200 pixels away from its flattened position, so we'll give it an initial y value of 200. The x in this case is really a measure of progress, so we'll have it range from 0 (completely curvy) to 1 (completely flat). If we graph this line, we get this:\n\nTo clarify, this line represents the range of possible y values for a quadratic Bézier curve's control point. Our x values represent the degree of \"flattening\"; this is useful to us because we want to be able to provide an x value like 0.46, and figure out what the corresponding y value is (our x value will come from user input, like the percentage scrolled through the viewport).\n\nTo make our formula work, we need to know at least 2 points on this line. Thankfully, we do! We know that the initial position, fully curved, is at , and we know that the curve becomes fully flattened at .\n• None The slope would be equal to = = = .\n• None Our b value is the y-axis intercept, which is our initial curved value, 200.\n• None x will be the ratio of scroll-through, between 0 and 1, that we'll get from our scroll handler.\n\nIf it's 25% of the way through, x will be 0.25, and so our y value would be y = (-200)(0.25) + 200 = 150, which is correct: 150 is 1/4 of the way between 200 and 0.\n\nHere's our function that performs the above calculations:\n\nLooks like teenage-me was wrong; algebra is useful and practical!\n\nWe're in the home stretch now! Time to combine all these ideas into something usable.\n\nLet's start by building a component that contains our scroll-handler to interpolate from the bottom of the viewport to the top, and connect those values to a Bézier curve in the render function:\n\nThis initial approach seems to work OK! There are two things I want to improve though:\n• None \n\n When the curve fully enters the viewport, it's already starting to be flattened. We don't get to see it in 100%-curved form. Worse, it hasn't finished flattening by the time it scrolls out of view! This is because this page has a header that takes up the top 50px of the viewport, and we aren't taking that into account.\n\n To solve these problems, we need to define a scrollable area, instead of using the viewport. The \"timing\" of the flattening feels wrong to me.When the curve fully enters the viewport, it's already starting to be flattened. We don't get to see it in 100%-curved form. Worse, it hasn't finished flattening by the time it scrolls out of view! This is because this page has a header that takes up the top 50px of the viewport, and we aren't taking that into account.To solve these problems, we need to define a scrollable area, instead of using the viewport.\n• None This component is doing an awful lot. It feels like we could extract a couple components from this. Refactoring it would not only make it easier to follow/understand, but it would make it more reusable.\n\nAhh, much nicer! The effect is more pleasant as the flattening animation happens within a smaller scroll window, and the code is easier to parse. As a bonus, our and components are generic, so they could be useful in totally different contexts.\n\nThe two versions above were written without any concern for performance. As it turns out, the performance is not so bad; on my low-end Chromebook, it stutters a little bit from time to time but mostly runs at 60fps. On my sluggish iPhone 6, it runs well enough (the biggest issue on mobile is that the browser address bar changes on scroll. Because of that, it may be wise to disable scroll-based things like this altogether on mobile).\n\nThat said, your mileage may vary. If you want to improve performance, there are a few ways this could be optimized:\n• None the scroll-handler in that it only fires every 20ms or so. This is to calm down certain touch-screen or trackpad interfaces that can fire far more often than is required. the scroll-handler inthat it only fires every 20ms or so. This is to calm down certain touch-screen or trackpad interfaces that can fire far more often than is required. the scroll-handler inthat it only fires every 20ms or so. This is to calm down certain touch-screen or trackpad interfaces that can fire far more often than is required.\n• None on mount, and then check the current scroll distance against this value.\n\n Unfortunately, this method opens up new problems. It assumes that nothing between the top of the document and your Bézier curve will change height, since our calculations assume a static distance between the two. Mobile browsers like iOS Safari will hide their chrome as you scroll down, so we'd have to factor that in as well.\n\n It's far from impossible, but it wasn't worth the trouble for me, given that performance was satisfactory on the devices I'm targeting. One of the more expensive parts of this effect is that we're interacting with the DOM, via , on every scroll event. Ideally, we could cache the position of ouron mount, and then check the current scroll distance against this value.Unfortunately, this method opens up new problems. It assumes that nothing between the top of the document and your Bézier curve will change height, since our calculations assume a static distance between the two. Mobile browsers like iOS Safari will hide their chrome as you scroll down, so we'd have to factor that in as well.It's far from impossible, but it wasn't worth the trouble for me, given that performance was satisfactory on the devices I'm targeting.\n• None in state and re-rendering whenever it changes, React needs some time to work out how the DOM has changed as a result of the scroll.\n\n The refactor to extract several components, while very good for DX and reusability, also means that React has a slightly more complex tree to reconcile.\n\n This all sounds a bit scary, but as we discovered earlier, React's reconciliation process is very quick on small trees like this. The cost of the refactor was negligible on my chromebook.\n\n If you really need to extract every drop of performance, you could work with the DOM directly, by setting the new instructions using . Note that you'd need to store everything in 1 component again. By storingin state and re-rendering whenever it changes, React needs some time to work out how the DOM has changed as a result of the scroll.The refactor to extract several components, while very good for DX and reusability, also means that React has a slightly more complex tree to reconcile.This all sounds a bit scary, but as we discovered earlier, React's reconciliation process is very quick on small trees like this. The cost of the refactor was negligible on my chromebook.If you really need to extract every drop of performance, you could work with the DOM directly, by setting the newinstructions using. Note that you'd need to store everything in 1 component again.\n\nWhew, you made it through this Bézier deep-dive!\n\nThe technique described in this blog post is foundational, and there's tons of flourishes you can add on top of it:\n• None This blog uses 3 layered Bézier curves with different fill colours to provide depth to the experience.\n• None You can experiment with different easings for the interpolation (Bézier curves are often used for timing , after all!). What if the curve got even more dramatic before smoothing it out?\n• None You could experiment with spring physics , to give the transition inertia.\n\nI'm excited to see what you build with this technique! Let me know on Bluesky (opens in new tab).\n\nLearn more about the math and mechanics behind Bézier curves with these two amazing resources:\n• None , by Jamie Wong , by Jamie Wong Bezier Curves from the Ground , by Jamie Wong"
    }
]