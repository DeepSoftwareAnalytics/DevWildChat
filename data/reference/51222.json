[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
        "document": "A JavaScript date is fundamentally specified as the time in milliseconds that has elapsed since the epoch, which is defined as the midnight at the beginning of January 1, 1970, UTC (equivalent to the UNIX epoch). This timestamp is timezone-agnostic and uniquely defines an instant in history. Note: While the time value at the heart of a Date object is UTC, the basic methods to fetch the date and time or its components all work in the local (i.e. host system) time zone and offset. The maximum timestamp representable by a object is slightly smaller than the maximum safe integer ( , which is 9,007,199,254,740,991). A object can represent a maximum of ±8,640,000,000,000,000 milliseconds, or ±100,000,000 (one hundred million) days, relative to the epoch. This is the range from April 20, 271821 BC to September 13, 275760 AD. Any attempt to represent a time outside this range results in the object holding a timestamp value of , which is an \"Invalid Date\". There are various methods that allow you to interact with the timestamp stored in the date:\n• You can interact with the timestamp value directly using the and methods.\n• The and (when passed ) methods — which are automatically called in number coercion — return the timestamp, causing objects to behave like their timestamps when used in number contexts.\n• All static methods ( , , and ) return timestamps instead of objects.\n• The constructor can be called with a timestamp as the only argument.\n\nA date is represented internally as a single number, the timestamp. When interacting with it, the timestamp needs to be interpreted as a structured date-and-time representation. There are always two ways to interpret a timestamp: as a local time or as a Coordinated Universal Time (UTC), the global standard time defined by the World Time Standard. The local timezone is not stored in the date object, but is determined by the host environment (user's device). Note: UTC should not be confused with the Greenwich Mean Time (GMT), because they are not always equal — this is explained in more detail in the linked Wikipedia page. For example, the timestamp 0 represents a unique instant in history, but it can be interpreted in two ways:\n• As a UTC time, it is midnight at the beginning of January 1, 1970, UTC,\n• As a local time in New York (UTC-5), it is 19:00:00 on December 31, 1969. The method returns the difference between UTC and the local time in minutes. Note that the timezone offset does not only depend on the current timezone, but also on the time represented by the object, because of daylight saving time and historical changes. In essence, the timezone offset is the offset from UTC time, at the time represented by the object and at the location of the host environment. There are two groups of methods: one group gets and sets various date components by interpreting the timestamp as a local time, while the other uses UTC. The constructor can be called with two or more arguments, in which case they are interpreted as the year, month, day, hour, minute, second, and millisecond, respectively, in local time. works similarly, but it interprets the components as UTC time and also accepts a single argument representing the year. Note: Some methods, including the constructor, , and the deprecated / methods, interpret a two-digit year as a year in the 1900s. For example, is interpreted as June 24, 1999, not June 24, 99. See Interpretation of two-digit years for more information. When a segment overflows or underflows its expected range, it usually \"carries over to\" or \"borrows from\" the higher segment. For example, if the month is set to 12 (months are zero-based, so December is 11), it become the January of the next year. If the day of month is set to 0, it becomes the last day of the previous month. This also applies to dates specified with the date time string format.\n\nThere are many ways to format a date as a string. The JavaScript specification only specifies one format to be universally supported: the date time string format, a simplification of the ISO 8601 calendar date extended format. The format is as follows:\n• is the year, with four digits ( to ), or as an expanded year of or followed by six digits. The sign is required for expanded years. is explicitly disallowed as a valid year.\n• is the month, with two digits ( to ). Defaults to .\n• is the day of the month, with two digits ( to ). Defaults to .\n• is a literal character, which indicates the beginning of the time part of the string. The is required when specifying the time part.\n• is the hour, with two digits ( to ). As a special case, is allowed, and is interpreted as midnight at the beginning of the next day. Defaults to .\n• is the minute, with two digits ( to ). Defaults to .\n• is the second, with two digits ( to ). Defaults to .\n• is the millisecond, with three digits ( to ). Defaults to .\n• is the timezone offset, which can either be the literal character (indicating UTC), or or followed by , the offset in hours and minutes from UTC. Various components can be omitted, so the following are all valid:\n• Date-time form: one of the above date-only forms, followed by , followed by , , or . Each combination can be followed by a time zone offset. For example, (date-only form), (date-time form), or (date-time form with milliseconds and time zone) are all valid date time strings. When the time zone offset is absent, date-only forms are interpreted as a UTC time and date-time forms are interpreted as a local time. The interpretation as a UTC time is due to a historical spec error that was not consistent with ISO 8601 but could not be changed due to web compatibility. See Broken Parser – A Web Reality Issue. and the constructor both accept strings in the date time string format as input. Furthermore, implementations are allowed to support other date formats when the input fails to match this format. The method returns a string representation of the date in the date time string format, with the time zone offset always set to (UTC). Note: You are encouraged to make sure your input conforms to the date time string format above for maximum compatibility, because support for other formats is not guaranteed. However, there are some formats that are supported in all major implementations — like RFC 2822 format — in which case their usage can be acceptable. Always conduct cross-browser tests to ensure your code works in all target browsers. A library can help if many different formats are to be accommodated. Non-standard strings can be parsed in any way as desired by the implementation, including the time zone — most implementations use the local time zone by default. Implementations are not required to return invalid date for out-of-bounds date components, although they usually do. A string may have in-bounds date components (with the bounds defined above), but does not represent a date in reality (for example, \"February 30\"). Implementations behave inconsistently in this case. The page offers more examples about these non-standard cases.\n\nReturns the day of the month ( – ) for the specified date according to local time. Returns the day of the week ( – ) for the specified date according to local time. Returns the year (4 digits for 4-digit years) of the specified date according to local time. Returns the hour ( – ) in the specified date according to local time. Returns the milliseconds ( – ) in the specified date according to local time. Returns the minutes ( – ) in the specified date according to local time. Returns the month ( – ) in the specified date according to local time. Returns the seconds ( – ) in the specified date according to local time. Returns the numeric value of the specified date as the number of milliseconds since January 1, 1970 00:00:00 UTC. (Negative values are returned for prior times.) Returns the time-zone offset in minutes for the current locale. Returns the day (date) of the month ( – ) in the specified date according to universal time. Returns the day of the week ( – ) in the specified date according to universal time. Returns the year (4 digits for 4-digit years) in the specified date according to universal time. Returns the hours ( – ) in the specified date according to universal time. Returns the milliseconds ( – ) in the specified date according to universal time. Returns the minutes ( – ) in the specified date according to universal time. Returns the month ( – ) in the specified date according to universal time. Returns the seconds ( – ) in the specified date according to universal time. Returns the year (usually 2–3 digits) in the specified date according to local time. Use instead. Sets the day of the month for a specified date according to local time. Sets the full year (e.g. 4 digits for 4-digit years) for a specified date according to local time. Sets the hours for a specified date according to local time. Sets the milliseconds for a specified date according to local time. Sets the minutes for a specified date according to local time. Sets the month for a specified date according to local time. Sets the seconds for a specified date according to local time. Sets the object to the time represented by the number of milliseconds since January 1, 1970 00:00:00 UTC. Use negative numbers for times prior. Sets the day of the month for a specified date according to universal time. Sets the full year (e.g. 4 digits for 4-digit years) for a specified date according to universal time. Sets the hour for a specified date according to universal time. Sets the milliseconds for a specified date according to universal time. Sets the minutes for a specified date according to universal time. Sets the month for a specified date according to universal time. Sets the seconds for a specified date according to universal time. Sets the year (usually 2–3 digits) for a specified date according to local time. Use instead. Returns the \"date\" portion of the as a human-readable string like . Converts a date to a string following the ISO 8601 Extended Format. Returns a string representing the using . Intended to be implicitly called by . Returns a string with a locality sensitive representation of the date portion of this date based on system settings. Returns a string with a locality-sensitive representation of this date. Overrides the method. Returns a string with a locality-sensitive representation of the time portion of this date, based on system settings. Returns a string representing the specified object. Overrides the method. Returns a new object with the same value as this date's timestamp. Returns the \"time\" portion of the as a human-readable string. Converts a date to a string using the UTC timezone. Returns the primitive value of a object. Overrides the method. Converts this object to a primitive value.\n\nexhibits legacy undesirable, inconsistent behavior with two-digit year values; specifically, when a call is given a two-digit year value, that year value does not get treated as a literal year and used as-is but instead gets interpreted as a relative offset — in some cases as an offset from the year , but in other cases, as an offset from the year . let date = new Date(98, 1); // Sun Feb 01 1998 00:00:00 GMT+0000 (GMT) date = new Date(22, 1); // Wed Feb 01 1922 00:00:00 GMT+0000 (GMT) date = new Date(\"2/1/22\"); // Tue Feb 01 2022 00:00:00 GMT+0000 (GMT) // Legacy method; always interprets two-digit year values as relative to 1900 date.setYear(98); date.toString(); // Sun Feb 01 1998 00:00:00 GMT+0000 (GMT) date.setYear(22); date.toString(); // Wed Feb 01 1922 00:00:00 GMT+0000 (GMT) So, to create and get dates between the years and , instead use the preferred and methods:. // Preferred method; never interprets any value as being a relative offset, // but instead uses the year value as-is date.setFullYear(98); date.getFullYear(); // 98 (not 1998) date.setFullYear(22); date.getFullYear(); // 22 (not 1922, not 2022)\n\nThe following examples show how to determine the elapsed time between two JavaScript dates in milliseconds. Due to the differing lengths of days (due to daylight saving changeover), months, and years, expressing elapsed time in units greater than hours, minutes, and seconds requires addressing a number of issues, and should be thoroughly researched before being attempted. // Using Date objects const start = Date.now(); // The event to time goes here: doSomethingForALongTime(); const end = Date.now(); const elapsed = end - start; // elapsed time in milliseconds // Using built-in methods const start = new Date(); // The event to time goes here: doSomethingForALongTime(); const end = new Date(); const elapsed = end.getTime() - start.getTime(); // elapsed time in milliseconds // To test a function and get back its return function printElapsedTime(testFn) { const startTime = Date.now(); const result = testFn(); const endTime = Date.now(); console.log(`Elapsed time: ${String(endTime - startTime)} milliseconds`); return result; } const yourFunctionReturn = printElapsedTime(yourFunction); Note: In browsers that support the Performance API's high-resolution time feature, can provide more reliable and precise measurements of elapsed time than ."
    },
    {
        "link": "https://freecodecamp.org/news/how-to-format-a-date-with-javascript-date-formatting-in-js",
        "document": "Dates are a fundamental part of many JavaScript applications, whether it's displaying the current date on a webpage or handling user input for scheduling events.\n\nBut displaying dates in a clear and consistent format is crucial for a positive user experience.\n\nIn the past, I have written two articles on Date formatting. The first explained solely how to use the method to format dates, while the second explained custom date formatting with the , , and methods.\n\nIn this article, we'll explore various techniques to format dates in JavaScript, enabling you to present dates in your desired format for your application.\n\nBefore we dive into date formatting, let's get familiar with the JavaScript object. It provides methods to work with dates and times effectively.\n\nTo create a new date instance, you can use the constructor.\n\nThe above code will output the current date and time in the default format. However, this format is not suitable for all use cases.\n\nThis is why we need to format dates so we can extract what we need from this date object.\n\nIn JavaScript, there is no direct syntax that provides you with your expected format because date format varies based on location, circumstance, and so on.\n\nJavaScript provides a few built-in methods to format dates conveniently. Let's take a look at some of these methods:\n• toDateString(): This method converts the date portion of a object into a human-readable string format.\n• toISOString(): This method converts a object into a string representation following the ISO 8601 format.\n• toLocaleDateString(): This method returns a string representing the date portion of a object using the system's local conventions.\n\nOutput: . This Format may vary based on the system's locale. For more explanation on how this method works, read this article.\n\nWhile the basic formatting methods can be useful in certain scenarios, you might often need more control over the date format.\n• String Concatenation: One approach is to manually concatenate the different components of a date using string manipulation.\n\nYou can manipulate this however you like and come up with more creative ways of representing dates. You can read this article to understand custom date formatting in detail and this article on how to format dates with ordinal number suffixes (-st, -nd, -rd, -th) in JavaScript.\n• Intl.DateTimeFormat: JavaScript's object offers powerful formatting capabilities through the object. It provides localization support and various options to format dates and times.\n\nUsing , you can specify the desired locale and various options to format dates precisely as needed. There are more options you can use in the official documentation.\n\nWhen working with dates, it's essential to consider time zones, especially when dealing with global applications or time-sensitive information.\n• None Time Zone Offset: The method of the object returns the difference in minutes between the local time zone and UTC. You can use this offset to adjust dates for specific time zones.\n• None Displaying Time Zones: To display the time zone information alongside the date, you can use the method with the appropriate options.\n\nCertain date formatting patterns are commonly used. Here are a few examples:\n• Specific Date Format: To display a date in a specific format, such as , you can use with the appropriate options.\n• Time Format: To format the time portion of a date, you can use the , , and options.\n\nApart from formatting dates for display, it's essential to handle user input for dates effectively. Here are a few considerations:\n• None Parsing User Input: Use the method or external libraries like Moment.js or Luxon to parse user-provided dates into valid objects.\n• None Validating User Input: Implement validation mechanisms to ensure the user's input adheres to the expected date format. Regular expressions or external libraries can help with this.\n\nFormatting dates in JavaScript is an essential skill when building web applications. By utilizing the built-in date formatting methods, custom formatting techniques, and external libraries, you can ensure dates are presented clearly and accurately.\n\nExperiment with different approaches and stay mindful of time zones for a seamless user experience with date formatting in JavaScript.\n\nFor further study on how to format dates, check these resources:\n• None JavaScript Date Format – How to Format a Date in JS\n• None How to Format Dates in JavaScript with One Line of Code\n• None How to Format Dates with Ordinal Number Suffixes (-st, -nd, -rd, -th) in JavaScript\n\nEmbark on a journey of learning! Browse 200+ expert articles on web development. Check out my blog for more captivating content from me."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat",
        "document": "These properties are defined on and shared by all instances. The constructor function that created the instance object. For instances, the initial value is the constructor. The initial value of the property is the string . This property is used in .\n\nGetter function that formats a date according to the locale and formatting options of this object. This method receives two Dates and formats the date range in the most concise way based on the locale and options provided when instantiating . This method receives two Dates and returns an Array of objects containing the locale-specific tokens representing each part of the formatted date range. Returns an of objects representing the date string in parts that can be used for custom locale-aware formatting. Returns a new object with properties reflecting the locale and formatting options computed during initialization of the object.\n\nIn basic use without specifying a locale, uses the default locale and default options. const date = new Date(Date.UTC(2012, 11, 20, 3, 0, 0)); // toLocaleString without arguments depends on the implementation, // the default locale, and the default time zone console.log(new Intl.DateTimeFormat().format(date)); // \"12/19/2012\" if run with en-US locale (language) and time zone America/Los_Angeles (UTC-0800)\n\nThis example shows some of the variations in localized date and time formats. In order to get the format of the language used in the user interface of your application, make sure to specify that language (and possibly some fallback languages) using the argument: const date = new Date(Date.UTC(2012, 11, 20, 3, 0, 0)); // Results below use the time zone of America/Los_Angeles (UTC-0800, Pacific Standard Time) // US English uses month-day-year order console.log(new Intl.DateTimeFormat(\"en-US\").format(date)); // \"12/19/2012\" // British English uses day-month-year order console.log(new Intl.DateTimeFormat(\"en-GB\").format(date)); // \"19/12/2012\" // Korean uses year-month-day order console.log(new Intl.DateTimeFormat(\"ko-KR\").format(date)); // \"2012. 12. 19.\" // Arabic in most Arabic speaking countries uses real Arabic digits console.log(new Intl.DateTimeFormat(\"ar-EG\").format(date)); // \"١٩‏/١٢‏/٢٠١٢\" // for Japanese, applications may want to use the Japanese calendar, // where 2012 was the year 24 of the Heisei era console.log(new Intl.DateTimeFormat(\"ja-JP-u-ca-japanese\").format(date)); // \"24/12/19\" // when requesting a language that may not be supported, such as // Balinese, include a fallback language, in this case Indonesian console.log(new Intl.DateTimeFormat([\"ban\", \"id\"]).format(date)); // \"19/12/2012\"\n\nThe date and time formats can be customized using the argument: const date = new Date(Date.UTC(2012, 11, 20, 3, 0, 0, 200)); // request a weekday along with a long date let options = { weekday: \"long\", year: \"numeric\", month: \"long\", day: \"numeric\", }; console.log(new Intl.DateTimeFormat(\"de-DE\", options).format(date)); // \"Donnerstag, 20. Dezember 2012\" // an application may want to use UTC and make that visible options.timeZone = \"UTC\"; options.timeZoneName = \"short\"; console.log(new Intl.DateTimeFormat(\"en-US\", options).format(date)); // \"Thursday, December 20, 2012, GMT\" // sometimes you want to be more precise options = { hour: \"numeric\", minute: \"numeric\", second: \"numeric\", timeZone: \"Australia/Sydney\", timeZoneName: \"short\", }; console.log(new Intl.DateTimeFormat(\"en-AU\", options).format(date)); // \"2:00:00 pm AEDT\" // sometimes you want to be very precise options.fractionalSecondDigits = 3; //number digits for fraction-of-seconds console.log(new Intl.DateTimeFormat(\"en-AU\", options).format(date)); // \"2:00:00.200 pm AEDT\" // sometimes even the US needs 24-hour time options = { year: \"numeric\", month: \"numeric\", day: \"numeric\", hour: \"numeric\", minute: \"numeric\", second: \"numeric\", hour12: false, timeZone: \"America/Los_Angeles\", }; console.log(new Intl.DateTimeFormat(\"en-US\", options).format(date)); // \"12/19/2012, 19:00:00\" // to specify options but use the browser's default locale, use undefined console.log(new Intl.DateTimeFormat(undefined, options).format(date)); // \"12/19/2012, 19:00:00\" // sometimes it's helpful to include the period of the day options = { hour: \"numeric\", dayPeriod: \"short\" }; console.log(new Intl.DateTimeFormat(\"en-US\", options).format(date)); // 10 at night The used calendar and numbering formats can also be set independently via arguments:"
    },
    {
        "link": "https://stackoverflow.com/questions/1056728/where-can-i-find-documentation-on-formatting-a-date-in-javascript",
        "document": "There is no “universal” documentation that javascript caters to; every browser that has javascript is really an implementation. However, there is a standard that most modern browsers tend to follow, and that’s the EMCAScript standard; the ECMAScript standard strings would take, minimally, a modified implementation of the ISO 8601 definition.\n\nIn addition to this, there is a second standard set forward by the IETF that browsers tend to follow as well, which is the definition for timestamps made in the RFC 2822. Actual documentation can be found in the references list at the bottom.\n\nFrom this you can expect basic functionality, but what “ought” to be is not inherently what “is”. I’m going to go a little in depth with this procedurally though, as it appears only three people actually answered the question (Scott, goofballLogic, and peller namely) which, to me, suggests most people are unaware of what actually happens when you create a Date object.\n\nTo answer the question, or typically even look for the answer to this question, you need to know that javascript is not a novel language; it’s actually an implementation of ECMAScript, and follows the ECMAScript standards (but note, javascript also actually pre-dated those standards; EMCAScript standards are built off the early implementation of LiveScript/JavaScript). The current ECMAScript standard is 5.1 (2011); at the time that the question was originally asked (June ’09), the standard was 3 (4 was abandoned), but 5 was released shortly after the post at the end of 2009. This should outline one problem; what standard a javascript implementation may follow, may not reflect what is actually in place, because a) it’s an implementation of a given standard, b) not all implementations of a standard are puritan, and c) functionality is not released in synchronization with a new standard as d) an implementation is a constant work in progress\n\nEssentially, when dealing with javascript, you’re dealing with a derivative (javascript specific to the browser) of an implementation (javascript itself). Google’s V8, for example, implements ECMAScript 5.0, but Internet Explorer’s JScript doesn’t attempt to conform to any ECMAScript standard, yet Internet Explorer 9 does conform to ECMAScript 5.0.\n\nWhen a single argument is passed to new Date(), it casts this function prototype:\n\nWhen two or more arguments are passed to new Date(), it casts this function prototype:\n\nBoth of those functions should look familiar, but this does not immediately answer your question and what quantifies as an acceptable “date format” requires further explanation. When you pass a string to new Date(), it will call the prototype (note that I'm using the word prototype loosely; the versions may be individual functions, or it may be part of a conditional statement in a single function) forwith your string as the argument for the “value” parameter. This function will first check whether it is a number or a string. The documentation for this function can be found here:\n\nFrom this, we can deduce that to get the string formatting allowed for new Date(value), we have to look at the method Date.parse(string). The documentation for this method can be found here:\n\nAnd we can further infer that dates are expected to be in a modified ISO 8601 Extended Format, as specified here:\n\nHowever, we can recognize from experience that javascript’s Date object accepts other formats (enforced by the existence of this question in the first place), and this is okay because ECMAScript allows for implementation specific formats. However, that still doesn’t answer the question of what documentation is available on the available formats, nor what formats are actually allowed. We’re going to look at Google’s javascript implementation, V8; please note I’m not suggesting this is the “best” javascript engine (how can one define “best” or even “good”) and one cannot assume that the formats allowed in V8 represent all formats available today, but I think it’s fair to assume they do follow modern expectations.\n\nLooking at the DateConstructor function, we can deduce we need to find the DateParse function; however, note that “year” is not the actual year and is only a reference to the “year” parameter.\n\nThis calls %DateParseString, which is actually a run-time function reference for a C++ function. It refers to the following code:\n\nThe function call we’re concerned with in this function is for DateParser::Parse(); ignore the logic surrounding those function calls, these are just checks to conform to the encoding type (ASCII and UC16). DateParser::Parse is defined here:\n\nThis is the function that actually defines what formats it accepts. Essentially, it checks for the EMCAScript 5.0 ISO 8601 standard and if it is not standards compliant, then it will attempt to build the date based on legacy formats. A few key points based on the comments:\n• Words before the first number that are unknown to the parser are ignored.\n• Unsigned numbers followed by “:” are interpreted as a “time component”.\n• Unsigned numbers followed by “.” are interpreted as a “time component”, and must be followed by milliseconds.\n• Signed numbers followed by the hour or hour minute (e.g. +5:15 or +0515) are interpreted as the timezone.\n• When declaring the hour and minute, you can use either “hh:mm” or “hhmm”.\n• Words that indicate a time zone are interpreted as a time zone.\n• All other numbers are interpreted as “date components”.\n• All words that start with the first three digits of a month are interpreted as the month.\n• You can define minutes and hours together in either of the two formats: “hh:mm” or “hhmm”.\n• Symbols like “+”, “-“ and unmatched “)” are not allowed after a number has been processed.\n• Items that match multiple formats (e.g. 1970-01-01) are processed as a standard compliant EMCAScript 5.0 ISO 8601 string.\n\nSo this should be enough to give you a basic idea of what to expect when it comes to passing a string into a Date object. You can further expand upon this by looking at the following specification that Mozilla points to on the Mozilla Developer Network (compliant to the IETF RFC 2822 timestamps):\n\nThe Microsoft Developer Network additionally mentions an additional standard for the Date object: ECMA-402, the ECMAScript Internationalization API Specification, which is complementary to the ECMAScript 5.1 standard (and future ones). That can be found here:\n\nIn any case, this should aid in highlighting that there is no \"documentation\" that universally represents all implementations of javascript, but there is still enough documentation available to make reasonable sense of what strings are acceptable for a Date object. Quite the loaded question when you think about it, yes? :P"
    },
    {
        "link": "https://thenextweb.com/news/how-to-manipulate-date-and-time-in-javascript",
        "document": "In theory, handling dates as a developer is as simple as creating, storing, and, if necessary, manipulating dates. But as a JavaScript developer, you would know this theory doesn’t hold long after you start working with dates for real. On top of different date-time formats, you have to consider timezone and local differences.\n\nFor this reason, plenty of JavaScript developers seek help from third-party libraries when they have to manage dates in an application. While these libraries reduce the task’s complexity, having a clear understanding of handling vanilla JavaScript dates has its benefits.\n\nThis tutorial will introduce you to working with dates in vanilla JavaScript, as well as useful third-party libraries to help you simplify more complex date-related tasks.\n\nThe Date object in JavaScript is the main element when it comes to handling date and time. It records a single point in time as the milliseconds’ number elapsed since the 1st January 1970 00:00:00 (UTC). This date-time combination is known as the epoch time. As far as JavaScript is concerned, it’s the beginning of time in the world.\n\nYou can simply create a date using . You can pass parameters to the Date constructor to create a date of your choice. The given parameter can take different forms.\n\nYou can pass a date string of an accepted format when creating a new Date object.\n\nNow, if we print the created date, it shows this.\n\nIn addition to the date we passed, the date object has more values, including a time and a timezone. Since we didn’t give a specific value for these parameters when creating the object, JavaScript uses the local time and timezone of the code’s system.\n\nIf we want to pass the time or timezone with the parameter string, we can use a format like this.\n• T is used to separate the date and time in the string\n• If Z is present, the time is assumed to be in UTC. Otherwise, it assumes the local time.\n\nHowever, if T and Z are not present, the string’s created date may give different results in different browsers. In that case, to always have the same timezone for the date, add or to the end.\n\nYou can get the same results using the function instead of passing the date string to the Date constructor. is indirectly being called inside the constructor whenever you pass a date string.\n\nThe format used in these strings is the ISO 8601 calendar extended format. You can refer to its details in the ECMAScript specification .\n\nYou can directly pass the date arguments to the Date constructor without using confusing date strings. The order and length of each year, month, etc., are exactly as in a date string.\n\nWhen we inspect the created date’s outcome, we can notice one crucial difference in the final date.\n\nWhat’s weird? When we created the date, we used 9 for the month, which we could assume to be September. However, when we print the result, the month is October instead. Why is that?\n\nJavaScript uses a zero-based index to identify each month in a year. This means, for JavaScript, January is represented by 0 instead of 1. Similarly, October is represented by 9 instead of 10.\n\nIn this method of creating a date, we can’t pass an argument to indicate its time zone. So, it’s defaulted to the local time of the system. But we can use the function to convert the date to UTC before passing it to the Date constructor.\n\nRemember that I mentioned JavaScript stores the time elapsed since the epoch time in the Date object? We can pass this elapsed time value, called a timestamp, to indicate the date we are creating.\n\nIf you want to create a Date object for the current date and time of the system, use the Date constructor without passing any argument.\n\nYou can also use the function for the same task.\n\nJavaScript provides several built-in functions to format a date. However, these functions only convert the date to a format specific to each one.\n\nLet’s see how each formatting function works.\n\nECMAScript Internationalization API allows the formatting of a date into a specific locale using the Intl object.\n\nYou can pass an options object to the DateTimeFormat function to display time values and customize the output.\n\nIf you want to format the date to any other format beyond what these functions provide, you’ll have to do so by accessing each part of the date separately and combining them.\n\nJavaScript provides the following functions to retrieve the year, month, date, and day from a Date object.\n\nNow, you can convert the date to a custom format using retrieved parts.\n\nJavaScript provides several methods to edit an already created date.\n\nIf you want to know whether a specific date comes before another, you can use greater than and less than operators directly for comparison.\n\nThis is because Dates in JavaScript are objects, so each date has a different instance of the class, and the or operator are comparing the memory address instead of the actual values of the dates.\n\nWe can find several JavaScript date and time manipulation libraries as open-source projects or otherwise. Some of them, designed for all kinds of date-time manipulations, and some have a specific set of use cases. In this section, I’ll only talk about popular multi-purpose libraries.\n\nMoment.js used to be the king of date manipulation libraries among JavaScript developers. However, its developers recently announced that it’s focusing on maintaining the current codebase instead of adding new features. They recommend looking for an alternative solution for those who are working on new projects.\n\nSo, apart from Moment.js, what are the libraries we can use to make our life easier as developers?\n\nDate-fns in an open-source library supporting date parsing and formatting, locales, and date arithmetic like addition and subtraction. It’s dubbed as Lodash for dates due to its versatility.\n\nLuxon is a date-time manipulation library created by one of the Moment.js developers to suit modern application requirements. Similar to Date-fns, Luxon offers data formatting and parsing functions. Also, it has native Intl support and is chainable.\n\nThis tutorial discussed how to work with date and time in JavaScript with and without external libraries. Working with dates is always painful in almost (if not all) programming languages. Fortunately for us, JS and its ecosystem of libraries does all the heavy work for us, allowing us to focus on building features.\n\nThis article was originally published on Live Code Stream by Juan Cruz Martinez (twitter: @bajcmartinez), founder and publisher of Live Code Stream, entrepreneur, developer, author, speaker, and doer of things.\n\nLive Code Stream is also available as a free weekly newsletter. Sign up for updates on everything related to programming, AI, and computer science in general."
    },
    {
        "link": "https://medium.com/@vitorbritto/mastering-date-an-time-in-javascript-a4c12501aa6a",
        "document": "Dates and time zones are frequently encountered aspects in web applications, yet their complexity can expose challenges when it comes to handling them.\n\nJavaScript handles dates using the object, which is built into the language. The object represents a specific moment in time and provides methods for working with dates, times, and time zones.\n\nEffective date management is of paramount importance in web applications and development for several reasons.\n\nHere’s an exploration of why handling dates properly is important.\n\nDates are integral to various user interactions within web applications. From displaying post timestamps to scheduling events, ensuring accurate and user-friendly date representations enhances the overall user experience.\n\nProper date management is vital for maintaining data integrity. Inaccurate handling of dates can lead to inconsistencies and errors, affecting the reliability and trustworthiness of the information presented or stored in the application.\n\nMany web applications rely on time-sensitive functionalities, such as scheduling, reminders, or countdowns. Accurate date management is essential for the proper functioning of these features, ensuring they provide value to users.\n\nWeb applications often serve a global audience, leading to diverse time zones and date formats. Effective date management allows applications to cater to users worldwide, offering a seamless experience regardless of geographical location.\n\nSome applications, especially those dealing with financial transactions or sensitive data, must adhere to regulatory standards regarding date and time accuracy. Proper date management is critical for compliance with legal and industry-specific requirements.\n\nIn business and analytics applications, proper date management is essential for accurate data analysis and reporting. Timely and precise reporting depends on the correct interpretation of dates, ensuring insights are reliable and actionable.\n\nWeb applications often interact with external systems and APIs, some of which may have specific date-related requirements. Effective date management facilitates smooth integration with external services, preventing issues related to data inconsistencies.\n\nCode maintenance and debugging become more manageable with clear and consistent date management practices. Well-handled dates contribute to code readability, reducing the likelihood of errors and making it easier for developers to maintain and enhance the application.\n\nWeb applications run on various devices and platforms with different settings. Consistent date management ensures cross-platform compatibility, preventing issues related to date rendering, parsing, or manipulation on different browsers or operating systems.\n\nBefore the release of ECMAScript 2015 (ES6), JavaScript developers had to contend with certain limitations and inconsistencies in the language, especially when it came to date operations. Let’s take a brief retrospective look at how date operations were handled in JavaScript before ES6.\n\nBefore ES6, creating a Date object required passing a timestamp as the argument. This timestamp was the number of milliseconds elapsed since January 1, 1970, UTC (commonly known as the Unix Epoch).\n\nThis approach was not very intuitive, and developers often had to perform manual calculations to obtain the desired date.\n\nMonths in the Date object were zero-indexed, meaning January was 0, February was 1, and so on. This indexing system led to confusion and off-by-one errors when working with months.\n\nDevelopers had to remember to subtract 1 from the desired month.\n\nDate objects had limited methods for accessing and modifying individual components like year, month, day, etc.\n\nThese methods were not very expressive or chainable, making code less readable and more error-prone.\n\nUnlike other programming languages, JavaScript lacked a literal syntax for creating dates. Developers had to rely on the Date constructor or external libraries for date manipulation.\n\nBefore ES6, formatting dates for display required manual construction of date strings using methods like , , and string concatenation.\n\nThis approach was cumbersome and prone to errors.\n\nJavaScript Date objects were not well-equipped to handle timezones effectively. Timezone-related operations were often challenging, and developers had to resort to external libraries or custom solutions.\n\nECMAScript 2015 (ES6) brought significant improvements to date manipulation in JavaScript, introducing new features and enhancing the capabilities of the object.\n\nES6 introduced a new class that provided a more modern and object-oriented approach to working with dates. The class addressed many of the limitations of the old object, offering a more expressive and consistent API for date manipulation.\n\nDevelopers could now create formatted date strings directly using template literals, reducing the need for manual concatenation and improving code readability.\n\nDevelopers could directly access and modify year, month, day, and other components in a more readable and chainable manner.\n\nDevelopers could now create date instances using a simplified syntax, improving code readability.\n\nThe object introduced in ES6 included features for handling internationalization, including improved timezone support. Developers gained more reliable tools for dealing with timezones, addressing the limitations of the old object.\n\nES6 added several new methods to the class, expanding its functionality. Developers gained access to methods like , , and , which simplified the process of formatting dates for specific locales.\n\nThe JavaScript object, while powerful, has some common issues and pitfalls that developers need to be aware of.\n\nNavigating time zones in the context of international operations presents a myriad of challenges that demand careful consideration. One common problem is the complexity introduced by Daylight Saving Time (DST) changes, which vary globally and can lead to discrepancies in scheduled activities. The lack of standardized time zone identifiers and abbreviations across platforms brings another issue, requiring developers to meticulously handle and interpret time-related data.\n\nHandling , , or invalid values when working with the JavaScript object is also important to ensure robust and error-free date manipulation in applications.\n\nCalculating date differences in JavaScript may lead to inaccurate results. Issues include time zone differences, daylight saving time ambiguity, and precision loss.\n\nUsing libraries that manage time zone transitions and offer higher precision can enhance accuracy in date difference calculations. Vigilance in addressing these considerations is crucial for robust and error-free date-related operations.\n\nThere are some strategies and considerations for dealing with such scenarios.\n\nBefore performing any date-related operations, check if the date variable is or . Also, you can check if a object is valid using the .\n\nProvide default values for date variables when they are or .\n\nUse robust parsing mechanisms and validate the result before using it in the application.\n\nClearly document date-handling practices and expectations in the codebase, especially when dealing with potential edge cases.\n\nMishandling dates in an application can significantly impact performance, leading to various issues that may degrade user experience and system efficiency.\n\nTo mitigate these performance impacts, developers should adopt best practices in date management, leverage built-in browser APIs, optimize date-related operations, and consider caching strategies for repetitive tasks.\n\nRegular profiling and testing of date-related functionalities can help identify and address potential bottlenecks, ensuring a smoother and more efficient application performance.\n\nThe use of external libraries, such as Day.js, can greatly enhance the efficiency and flexibility of date and time handling in JavaScript applications.\n\nDay.js is a lightweight, modern JavaScript library for parsing, validating, manipulating, and formatting dates. It is designed as an alternative to Moment.js, with a focus on simplicity, performance, and a smaller footprint. It also provides a comprehensive set of features for working with dates and times, making it a popular choice for developers seeking a fast and efficient date manipulation library.\n\nSome key features from DayJS are:\n\nTo install Day.js in a project, you can follow these steps:\n\n1. Open your terminal in the root directory of your project.\n\n2. Run the following command to install Day.js using yarn:\n\n3. After the installation is complete, you can import Day.js where needed:\n\nOnce Day.js is installed, you can use it for various date and time operations in your project.\n\nDay.js is agnostic and you can use with any library or framework.\n\nDay.js offers advanced features that can simplify complex date and time-related tasks in JavaScript applications.\n\nDay.js provides a method to represent time in a human-readable relative format.\n\nDay.js allows custom parsing formats, providing flexibility when dealing with diverse date formats.\n\nDay.js introduces and objects for precise handling of time spans and intervals.\n\nDay.js supports localization for date formatting, allowing you to display dates based on different locales.\n\nDay.js allows isolating and extracting specific time components, such as year, month, day, hour, minute, and second.\n\nDay.js supports chaining query and manipulation methods, providing a concise way to perform multiple operations.\n\nDay.js allows advanced difference calculations, including precision up to milliseconds and specifying the unit of measurement.\n\nDay.js can operate in UTC mode, making it easier to handle dates without considering local time zones.\n\nDay.js supports strict mode parsing, helping ensure that only valid date strings are accepted.\n\nWorking with Day.js plugins and extensions allows you to extend the functionality of Day.js to suit specific needs.\n\nHere’s a guide on how to use Day.js plugins.\n\nSelect a Day.js plugin that matches your requirements. Many plugins are available on the Day.js Plugin Directory.\n\nUse a package manager like npm or yarn to install the Day.js plugin. Replace with the actual name of the plugin.\n\nImport both Day.js and the installed plugin in your JavaScript or TypeScript file.\n\nExtend Day.js by applying the plugin using the method.\n\nOnce the plugin is extended, you can use its features as part of the Day.js API.\n\nChoosing the right strategy for handling dates is a indispensable decision with widespread ramifications for the success of a software project.\n\nIt directly affects user satisfaction, data integrity, functional capabilities, ease of maintenance, and many other key points. It is significantly important to select a method (whether using the , , or a library like Day.js) that harmonizes effectively with the project’s unique needs, ensuring precise and dependable date operations throughout the application."
    },
    {
        "link": "https://stackoverflow.com/questions/56340626/javascript-es6-date-to-string-format",
        "document": "In Javascript I have object which I need to convert to string of format and . How do I format the Date in Javascript?"
    },
    {
        "link": "https://medium.com/@AlexanderObregon/handling-dates-and-times-in-javascript-8b62091f2e74",
        "document": "Working with dates and times is a common requirement in many applications. Whether you’re building a calendar, scheduling system, or just need to display the current date and time, understanding how to handle dates and times in JavaScript is important. This article explores various methods and best practices for working with dates and times in JavaScript.\n\nThe object in JavaScript is a versatile tool for handling dates and times. It provides methods for creating, manipulating, and formatting dates. Understanding how to use the object is essential for any developer working with JavaScript.\n\nCreating a object can be done in several ways, each suited to different needs:\n\nWhen you create a object without any arguments, it defaults to the current date and time, using the system's local time zone.\n\nIn this example, the date is set to June 24, 2024, at 10:33:30. Note that the month is zero-indexed, meaning January is 0 and December is 11.\n\nParsing a date string can be particularly useful when working with dates from APIs or user input. The string format should follow the ISO 8601 standard for best compatibility.\n\nCreating a date from a Unix timestamp (milliseconds since January 1, 1970) is useful when dealing with time calculations or data from certain APIs.\n\nThe object provides methods to get and set various components of a date, allowing for detailed manipulation.\n• Get Methods: You can retrieve individual components of a date with various get methods:\n\nThese methods allow you to access each part of the date individually, which can be useful for custom formatting or calculations.\n• Set Methods: Similarly, you can set individual components of a date:\n\nThe set methods modify the object in place, allowing you to change specific parts of the date without affecting the rest.\n\nJavaScript’s object defaults to the local time zone of the system. However, you can work with UTC (Coordinated Universal Time) as well:\n\nJavaScript’s object does not provide built-in formatting methods like some other programming languages. However, you can create custom formatting functions:\n\nThese examples demonstrate how to build custom date formatting functions to suit various needs.\n\nJavaScript allows you to perform arithmetic operations with dates, such as adding or subtracting days, months, or years:\n\nWhen working with user input or data from external sources, you may encounter invalid dates. JavaScript provides ways to handle these scenarios:\n\nThe function can help you detect invalid dates, making sure that your code handles them gracefully.\n\nComparing dates in JavaScript is straightforward using standard comparison operators:\n\nMoment.js is a widely used library for handling dates and times in JavaScript. It provides a simple and consistent API for parsing, validating, manipulating, and formatting dates, making it easier to work with dates than using the built-in object alone. However, it's important to note that although it is still commonly used, Moment.js is no longer actively developed. Depending on your project or preference, you might want to consider modern alternatives such as Luxon or Day.js, which offer similar functionality.\n\nTo use Moment.js, you need to include it in your project. This can be done via a CDN or by installing it using npm.\n\nMoment.js simplifies the creation and manipulation of dates. Here are some common operations:\n\nMoment.js excels at formatting dates with its flexible method:\n• Localized Formats: Moment.js supports localized formats, allowing you to display dates in a format appropriate for a specific locale:\n\nMoment.js can parse dates from strings, making it easy to handle various date formats:\n\nMoment.js provides strong methods for validating dates, making sure that they are correctly formatted and represent real dates:\n\nMoment.js can handle time zones and UTC (Coordinated Universal Time), making it easier to work with dates across different regions:\n• Time Zones: Using the extension, you can work with specific time zones:\n\nMoment.js can display dates relative to the current time, which is useful for showing human-readable time differences:\n\nBest Practices for Working with Dates and Times\n\nWorking with dates and times can be challenging, especially when dealing with different time zones, formats, and locales. Following best practices can help you avoid common problems and make sure your code is strong and maintainable.\n\nWhenever possible, use the ISO 8601 format ( ) for dates and times. This format is unambiguous and widely supported across different programming languages and systems.\n\nUsing ISO 8601 ensures consistency and compatibility, making it easier to parse and format dates.\n\nAlways be mindful of time zones when working with dates and times. JavaScript’s object uses the local time zone by default, while Moment.js and other libraries can handle time zones explicitly.\n\nHandling time zones correctly is crucial for applications that operate across different regions.\n\nMutating date objects can lead to bugs and unexpected behavior. Instead, create new date objects when making modifications.\n\nCreating new date objects helps maintain the integrity of the original date and prevents side effects.\n\nFor complex date manipulations and formatting, use libraries like Moment.js, Luxon, or date-fns. These libraries provide strong and tested methods for handling various date and time operations.\n\nUsing libraries can simplify your code and reduce the likelihood of errors.\n\nWhen accepting dates from user input or external sources, always validate and sanitize them to make sure they are in the expected format and represent valid dates.\n\nValidating inputs helps prevent errors and potential security issues in your application.\n\nWhen displaying dates to users, consider localization and internationalization to present dates in a format familiar to them.\n\nProviding localized date formats enhances the user experience, especially for international audiences.\n\nBe aware of edge cases such as leap years, daylight saving time changes, and different calendar systems. Proper handling of these cases makes sure your application functions correctly in all scenarios.\n\nAddressing edge cases prevents unexpected behavior and improves the reliability of your application.\n\nDocument how your application handles dates and times, including any libraries or formats used. Clear documentation helps other developers understand your code and ensures consistency.\n\nGood documentation practices make your codebase easier to maintain and extend.\n\nHandling dates and times in JavaScript can be complex due to various factors like different time zones, formats, and edge cases. However, with the right tools and best practices, you can manage these complexities effectively.\n\nThe JavaScript object provides a fundamental way to create, manipulate, and format dates. For more advanced needs, libraries like Moment.js offer powerful capabilities, though it's important to consider newer alternatives like Luxon or Day.js for active development.\n\nBy following best practices — such as using the ISO 8601 format, being mindful of time zones, avoiding date object mutations, and validating inputs — you can make sure your date and time handling is strong and reliable. Additionally, leveraging libraries for complex operations and considering localization can significantly improve your application’s user experience.\n\nWith a strong understanding of these tools and practices, you can confidently handle dates and times in your JavaScript projects, creating applications that are accurate, user-friendly, and maintainable.\n\nThank you for reading! If you find this article helpful, please consider highlighting, clapping, responding or connecting with me on Twitter/X as it’s very appreciated and helps keeps content like this free!"
    },
    {
        "link": "https://geeksforgeeks.org/es6-date",
        "document": "The ES6 Date is defined as the number of milliseconds that have been passed since midnight on January 1, 1970, UTC. Date objects can be created by the new Date() constructor. In JavaScript, both date and time are represented by the Date object.\n\nJavascript Date Constructors: In JavaScript, a constructor gets called when an object is created using the new keyword.\n\nInstance Properties: An instance property is a property that has a new copy for every new instance of the class\n\nStatic Methods: If the method is called using the date class itself then it is called a static method\n\nDate.prototype Methods: If the method is called on an instance of a date then it is called an instance method\n\nIt returns the date of the month from the given date object. It returns the day of the week from 0 to 6 according to the local time of the given date object. the It returns the full year of the given date object. It returns the hour (0-23) of the given date object. It returns the milliseconds (0-999) of the given date object according to the local time. It returns the minute (0-59) of the given date object according to the local time. It returns the month (0-11) of the given date object according to the local time. It returns the seconds (0-59) of the given date object according to the local time. It returns the number of milliseconds elapsed since January 1, 1970, 00:00:00 UTC., It returns the difference between UTC and local timezone in minutes. It returns the day of the month (1-31) according to the universal time of the given date object. It returns the day of the week (0-6) according to the universal time of the given date object. It returns the year according to the universal time of the given date object. It returns the hour (0-23) according to the universal time of the given date object. It returns the milliseconds (0-999) according to the universal time of the given date object. It returns the minutes according to the universal time of the given date object. It returns the month (0-11) according to the universal time of the given date object. It returns seconds (0-59) according to the universal time of the given date object. It is used to set the date of a month to the date object in local time. It is used to set the year to the date object in local time. It is used to set hour (0-23) to the date object in local time. It is used to set milliseconds to the date object in local time. It is used to set minutes (0-59) to the date object in local time. It is used to set month (0-11) to the date object in local time. It is used to set seconds (0-59) to the date object in local time. It is used to set milliseconds after January 1, 1970, 00:00:00 UTC to the date object in local time., It is used to set the date of the month (0-11) to the date object according to universal time. It is used to set the year to the date object according to universal time. It is used to set hours (0-23) to the date object according to universal time. It is used to set milliseconds to the date object according to universal time. It is used to set minutes (0-59) to the date object according to universal time. It is used to set month (0-11) to the date object according to universal time. It is used to set seconds (0-59) to the date object according to universal time.\n\nDate Conversion Methods: The methods that are used to convert dates from one format to others.\n\nIt returns the string representation for the date portion of the date object. It returns the string representation for the date portion of the date object using ISO 8601 extended format. It returns the string representation for the date portion of the date object. It takes two parameters (optional) – locale and options and returns the string representation for the date portion according to the specified locale. It returns the string of the date object of the date portion in locale format. It returns the string representation for the time portion of the date object. It returns the string representation for the date of the date object. It returns the string representation for the time portion of the date object. It returns the string representation for the date object in the format of a universal timezone. It returns the number of milliseconds elapsed from January 1, 1970, 00:00:00 UTC to the date provided.,"
    },
    {
        "link": "https://stackoverflow.com/questions/31792398/format-date-in-es6",
        "document": "I am formatting a Date, with not momentjs or any other library, just pure JS. And I want to know if there is a way to simplify this with ES6\n\nI saw that in the DOM you use something like\n\nso you don't have to do\n\nis there something I should use to do that kind of format?"
    }
]