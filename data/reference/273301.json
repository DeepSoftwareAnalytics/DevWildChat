[
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.math.round?view=net-9.0",
        "document": "In addition to the examples in the Remarks section, this article includes examples that illustrate the following overloads of the method:\n\nYou can use the following table to select an appropriate rounding method. In addition to the methods, it also includes Math.Ceiling and Math.Floor.\n\nRounding involves converting a numeric value with a specified precision to a value with less precision. For example, you can use the Round(Double) method to round a value of 3.4 to 3.0, and the Round(Double, Int32) method to round a value of 3.579 to 3.58.\n\nIn a midpoint value, the value after the least significant digit in the result is precisely half way between two numbers. For example, 3.47500 is a midpoint value if it is to be rounded to two decimal places, and 7.500 is a midpoint value if it is to be rounded to an integer. In these cases, if the round-to-nearest strategy is used, the nearest value can't be easily identified without a rounding convention.\n\nThe Round method supports two rounding conventions for handling midpoint values:\n• None Rounding away from zero Midpoint values are rounded to the next number away from zero. For example, 3.75 rounds to 3.8, 3.85 rounds to 3.9, -3.75 rounds to -3.8, and -3.85 rounds to -3.9. This form of rounding is represented by the MidpointRounding.AwayFromZero enumeration member.\n• None Rounding to nearest even, or banker's rounding Midpoint values are rounded to the nearest even number. For example, both 3.75 and 3.85 round to 3.8, and both -3.75 and -3.85 round to -3.8. This form of rounding is represented by the MidpointRounding.ToEven enumeration member.\n\nRounding away from zero is the most widely known form of rounding, while rounding to nearest even is the standard in financial and statistical operations. It conforms to IEEE Standard 754, section 4. When used in multiple rounding operations, rounding to nearest even reduces the rounding error that is caused by consistently rounding midpoint values in a single direction. In some cases, this rounding error can be significant.\n\nThe following example illustrates the bias that can result from consistently rounding midpoint values in a single direction. The example computes the true mean of an array of Decimal values, and then computes the mean when the values in the array are rounded by using the two conventions. In this example, the true mean and the mean that results when rounding to nearest are the same. However, the mean that results when rounding away from zero differs by .05 (or by 3.6%) from the true mean.\n\nBy default, the Round method uses the round to nearest even convention. The following table lists the overloads of the Round method and the rounding convention that each uses.\n\nIn order to determine whether a rounding operation involves a midpoint value, the Round method multiplies the original value to be rounded by 10n, where n is the desired number of fractional digits in the return value, and then determines whether the remaining fractional portion of the value is greater than or equal to .5. This is a slight variation on a test for equality, and as discussed in the \"Testing for Equality\" section of the Double reference topic, tests for equality with floating-point values are problematic because of the floating-point format's issues with binary representation and precision. This means that any fractional portion of a number that is slightly less than .5 (because of a loss of precision) will not be rounded upward.\n\nThe following example illustrates the problem. It repeatedly adds .1 to 11.0 and rounds the result to the nearest integer. 11.5 should round to 12 using either of the midpoint-rounding conventions ( or ). However, as the output from the example shows, it does not. The example uses the \"R\" standard numeric format string to display the floating point value's full precision, and shows that the value to be rounded has lost precision during repeated additions, and its value is actually 11.499999999999998. Because .499999999999998 is less than .5, the midpoint-rounding conventions don't come into play and the value is rounded down. As the example also shows, this problem does not occur if you assign the constant value 11.5 to a Double variable.\n\nProblems of precision in rounding midpoint values are most likely to arise in the following conditions:\n• None When a fractional value cannot be expressed precisely in the floating-point type's binary format.\n• None When the value to be rounded is calculated from one or more floating-point operations.\n• None When the value to be rounded is a Single rather than a Double or Decimal. For more information, see the next section, Rounding and single-precision floating-point values.\n\nIn cases where the lack of precision in rounding operations is problematic, you can do the following:\n• None If the rounding operation calls an overload that rounds a Double value, you can change the Double to a Decimal value and call an overload that rounds a Decimal value instead. Although the Decimal data type also has problems of representation and loss of precision, these issues are far less common.\n• None Define a custom rounding algorithm that performs a \"nearly equal\" test to determine whether the value to be rounded is acceptably close to a midpoint value. The following example defines a method that examines whether a fractional value is sufficiently near to a midpoint value to be subject to midpoint rounding. As the output from the example shows, it corrects the rounding problem shown in the previous example. public static void Example() { Console.WriteLine(\"{0,5} {1,20:R} {2,12} {3,15}\n\n\", \"Value\", \"Full Precision\", \"ToEven\", \"AwayFromZero\"); double value = 11.1; for (int ctr = 0; ctr <= 5; ctr++) value = RoundValueAndAdd(value); Console.WriteLine(); value = 11.5; RoundValueAndAdd(value); } private static double RoundValueAndAdd(double value) { const double tolerance = 8e-14; Console.WriteLine(\"{0,5:N1} {0,20:R} {1,12} {2,15}\", value, RoundApproximate(value, 0, tolerance, MidpointRounding.ToEven), RoundApproximate(value, 0, tolerance, MidpointRounding.AwayFromZero)); return value + .1; } private static double RoundApproximate(double dbl, int digits, double margin, MidpointRounding mode) { double fraction = dbl * Math.Pow(10, digits); double value = Math.Truncate(fraction); fraction = fraction - value; if (fraction == 0) return dbl; double tolerance = margin * dbl; // Determine whether this is a midpoint value. if ((fraction >= .5 - tolerance) & (fraction <= .5 + tolerance)) { if (mode == MidpointRounding.AwayFromZero) return (value + 1) / Math.Pow(10, digits); else if (value % 2 != 0) return (value + 1) / Math.Pow(10, digits); else return value / Math.Pow(10, digits); } // Any remaining fractional value greater than .5 is not a midpoint value. if (fraction > .5) return (value + 1) / Math.Pow(10, digits); else return value / Math.Pow(10, digits); } // The example displays the following output: // Value Full Precision ToEven AwayFromZero // // 11.1 11.1 11 11 // 11.2 11.2 11 11 // 11.3 11.299999999999999 11 11 // 11.4 11.399999999999999 11 11 // 11.5 11.499999999999998 12 12 // 11.6 11.599999999999998 12 12 // // 11.5 11.5 12 12 open System let roundApproximate dbl digits margin mode = let fraction = dbl * Math.Pow(10, digits) let value = Math.Truncate fraction let fraction = fraction - value if fraction = 0 then dbl else let tolerance = margin * dbl // Determine whether this is a midpoint value. if (fraction >= 0.5 - tolerance) && (fraction <= 0.5 + tolerance) then if mode = MidpointRounding.AwayFromZero then (value + 1.) / Math.Pow(10, digits) elif value % 2. <> 0 then (value + 1.) / Math.Pow(10, digits) else value / Math.Pow(10, digits) // Any remaining fractional value greater than .5 is not a midpoint value. elif fraction > 0.5 then (value + 1.) / Math.Pow(10, digits) else value / Math.Pow(10, digits) let roundValueAndAdd value = let tolerance = 8e-14 let round = roundApproximate value 0 tolerance printfn $\"{value,5:N1} {value,20:R} {round MidpointRounding.ToEven,12} {round MidpointRounding.AwayFromZero,15}\" value + 0.1 printfn \"%5s %20s %12s %15s\n\n\" \"Value\" \"Full Precision\" \"ToEven\" \"AwayFromZero\" let mutable value = 11.1 for _ = 0 to 5 do value <- roundValueAndAdd value printfn \"\" value <- 11.5 roundValueAndAdd value |> ignore // The example displays the following output: // Value Full Precision ToEven AwayFromZero // // 11.1 11.1 11 11 // 11.2 11.2 11 11 // 11.3 11.299999999999999 11 11 // 11.4 11.399999999999999 11 11 // 11.5 11.499999999999998 12 12 // 11.6 11.599999999999998 12 12 // // 11.5 11.5 12 12 Public Sub Example() Dim value As Double = 11.1 Console.WriteLine(\"{0,5} {1,20:R} {2,12} {3,15}\n\n\", \"Value\", \"Full Precision\", \"ToEven\", \"AwayFromZero\") For ctr As Integer = 0 To 5 value = RoundValueAndAdd(value) Next Console.WriteLine() value = 11.5 RoundValueAndAdd(value) End Sub Private Function RoundValueAndAdd(value As Double) As Double Const tolerance As Double = 0.00000000000008 Console.WriteLine(\"{0,5:N1} {0,20:R} {1,12} {2,15}\", value, RoundApproximate(value, 0, tolerance, MidpointRounding.ToEven), RoundApproximate(value, 0, tolerance, MidpointRounding.AwayFromZero)) Return value + 0.1 End Function Private Function RoundApproximate(dbl As Double, digits As Integer, margin As Double, mode As MidpointRounding) As Double Dim fraction As Double = dbl * Math.Pow(10, digits) Dim value As Double = Math.Truncate(fraction) fraction = fraction - value If fraction = 0 Then Return dbl Dim tolerance As Double = margin * dbl ' Determine whether this is a midpoint value. If (fraction >= 0.5 - tolerance) And (fraction <= 0.5 + tolerance) Then If mode = MidpointRounding.AwayFromZero Then Return (value + 1) / Math.Pow(10, digits) Else If value Mod 2 <> 0 Then Return (value + 1) / Math.Pow(10, digits) Else Return value / Math.Pow(10, digits) End If End If End If ' Any remaining fractional value greater than .5 is not a midpoint value. If fraction > 0.5 Then Return (value + 1) / Math.Pow(10, digits) Else Return value / Math.Pow(10, digits) End If End Function ' The example displays the following output: ' Value Full Precision ToEven AwayFromZero ' ' 11.1 11.1 11 11 ' 11.2 11.2 11 11 ' 11.3 11.299999999999999 11 11 ' 11.4 11.399999999999999 11 11 ' 11.5 11.499999999999998 12 12 ' 11.6 11.599999999999998 12 12 ' ' 11.5 11.5 12 12\n\nThe Round method includes overloads that accept arguments of type Decimal and Double. There are no methods that round values of type Single. If you pass a Single value to one of the overloads of the Round method, it is cast (in C#) or converted (in Visual Basic) to a Double, and the corresponding Round overload with a Double parameter is called. Although this is a widening conversion, it often involves a loss of precision, as the following example illustrates. When a Single value of 16.325 is passed to the Round method and rounded to two decimal places using the rounding to nearest convention, the result is 16.33 and not the expected result of 16.32.\n\nThis unexpected result is due to a loss of precision in the conversion of the Single value to a Double. Because the resulting Double value of 16.325000762939453 is not a midpoint value and is greater than 16.325, it is always rounded upward.\n\nIn many cases, as the example illustrates, the loss of precision can be minimized or eliminated by casting or converting the Single value to a Decimal. Note that, because this is a narrowing conversion, it requires using a cast operator or calling a conversion method."
    },
    {
        "link": "https://geeksforgeeks.org/c-sharp-math-round-method-set-1",
        "document": "In C#, Math.Round() is a Math class method which is used to round a value to the nearest integer or to the particular number of fractional digits. This method can be overloaded by changing the number and type of the arguments passed. There are total 8 methods in the overload list of the Math.Round() method. Here we will discuss only 4 methods and remaining 4 methods are discussed in C# | Math.Round() Method | Set – 2.\n\nThis method rounds a double-precision floating-point value to the nearest integer value.\n\nReturn Type:It returns the integer nearest to x and return type is System.Double.\n\nNote: In case if the fractional component of x is halfway between two integers, one of which is even and the other odd, then the even number is returned.\n\nExplanation: In above code suppose the user wants to round off the above specified double value to nearest integer. So the compiler will first check whether that double value is greater than or less than the even and odd integral value of that double number. If it is less than the halfway value, its output will be floor value, else if greater than halfway value, its output will be the ceiling value.\n\nThis method rounds a double precision floating-point value to a specified number of fractional digits.\n\nReturn Type:It returns the integer nearest to x which contains a number of fractional digits equal to y and return type is System.Double.\n\nException: This method will give ArgumentOutOfRangeException if the value of y is less than 0 or greater than 15.\n\nExplanation: Method will check that whether the digit next to the specified number of decimal digits is greater than or equals to 5 or not. If it is greater than or equal to 5 then it increments the previous number else previous digit remains the same.\n\nThis method rounds off a decimal value whose precision is 128 bits to the nearest integer value.\n\nReturn Type:It returns the integer nearest to x and return type is System.Decimal.\n\nNote: In case if the fractional component of x is halfway between two integers, one of which is even and the other odd, then the even number is returned.\n\nThis method rounds a decimal value to a specified number of fractional digits.\n\nReturn Type:It returns the integer nearest to x which contains a number of fractional digits equal to y and return type is System.Decimal.\n\nException: This method will give ArgumentOutOfRangeException if the value of y is less than 0 or greater than 15 and OverflowException in case of result is outside the range of a Decimal.\n\nNote: The above codes for Decimal Value works in a similar way as in case of Double value. The only difference between Decimal type and Double type lies within the concept of precision i.e. in case of Double, precision is 64-bit and in case of Decimal precision is 128-bits."
    },
    {
        "link": "https://ironpdf.com/blog/net-help/math-round-csharp",
        "document": "Test in production without watermarks.\n\nWorks wherever you need it to."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.decimal.round?view=net-9.0",
        "document": "The number that is rounded to using the rounding strategy and with a precision of . If the precision of is less than , is returned unchanged.\n\nThe following example demonstrates how to use the Round(Decimal, Int32, MidpointRounding) method with the MidpointRounding enumeration.\n\nThe parameter specifies the number of significant decimal places in the return value and ranges from 0 to 28. If is zero, an integer is returned.\n\nIf you specify ToEven or AwayFromZero for the parameter, those rounding strategies are only applied for midpoint values, that is, values whose least significant digit is 5."
    },
    {
        "link": "https://stackoverflow.com/questions/72362928/does-math-round-in-net-round-certain-values-incorrectly",
        "document": "The answer to your actual question \"Does Math.Round in .NET round certain values incorrectly?\" is: Yes. (Well, Microsoft would probably argue that this behaviour is defined, and is therefore correct.)\n\nThe reason for this is described in the documentation for :\n\nBecause of the loss of precision that can result from representing decimal values as floating-point numbers or performing arithmetic operations on floating-point values, in some cases the Round(Double, Int32, MidpointRounding) method may not appear to round midpoint values as specified by the mode parameter. This is illustrated in the following example, where 2.135 is rounded to 2.13 instead of 2.14. This occurs because internally the method multiplies value by 10^digits, and the multiplication operation in this case suffers from a loss of precision.\n\nWe can test this:\n\nYou can see that the value after multiplication by 10^1 is 25.5, which will be rounded up in the next step of the rounding algorithm.\n\nYou can look at the actual implementation here.\n\nIt's a bit fiddly, but the answer is really \"something something rounding something\" ;)"
    },
    {
        "link": "https://stackoverflow.com/questions/257005/how-do-you-round-a-number-to-two-decimal-places-in-c",
        "document": "If you want to round a number, you can obtain different results depending on: how you use the Math.Round() function (if for a round-up or round-down), you're working with doubles and/or floats numbers, and you apply the midpoint rounding. Especially, when using with operations inside of it or the variable to round comes from an operation. Let's say, you want to multiply these two numbers: 0.75 * 0.95 = 0.7125. Right? Not in C#\n\nLet's see what happens if you want to round to the 3rd decimal:\n\nAs you see, the first Round() is correct if you want to round down the midpoint. But the second Round() it's wrong if you want to round up.\n\nSo, IMHO, you should create your own wrap function for Math.Round() that fit your requirements. I created a function in which, the parameter 'roundUp=true' means to round to next greater number. That is: 0.7125 rounds to 0.713 and -0.7125 rounds to -0.712 (because -0.712 > -0.713). This is the function I created and works for any number of decimals:\n\nThe variable 'corrector' is for fixing the inaccuracy of operating with floating or double numbers."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/api/system.math.round?view=net-9.0",
        "document": "In addition to the examples in the Remarks section, this article includes examples that illustrate the following overloads of the method:\n\nYou can use the following table to select an appropriate rounding method. In addition to the methods, it also includes Math.Ceiling and Math.Floor.\n\nRounding involves converting a numeric value with a specified precision to a value with less precision. For example, you can use the Round(Double) method to round a value of 3.4 to 3.0, and the Round(Double, Int32) method to round a value of 3.579 to 3.58.\n\nIn a midpoint value, the value after the least significant digit in the result is precisely half way between two numbers. For example, 3.47500 is a midpoint value if it is to be rounded to two decimal places, and 7.500 is a midpoint value if it is to be rounded to an integer. In these cases, if the round-to-nearest strategy is used, the nearest value can't be easily identified without a rounding convention.\n\nThe Round method supports two rounding conventions for handling midpoint values:\n• None Rounding away from zero Midpoint values are rounded to the next number away from zero. For example, 3.75 rounds to 3.8, 3.85 rounds to 3.9, -3.75 rounds to -3.8, and -3.85 rounds to -3.9. This form of rounding is represented by the MidpointRounding.AwayFromZero enumeration member.\n• None Rounding to nearest even, or banker's rounding Midpoint values are rounded to the nearest even number. For example, both 3.75 and 3.85 round to 3.8, and both -3.75 and -3.85 round to -3.8. This form of rounding is represented by the MidpointRounding.ToEven enumeration member.\n\nRounding away from zero is the most widely known form of rounding, while rounding to nearest even is the standard in financial and statistical operations. It conforms to IEEE Standard 754, section 4. When used in multiple rounding operations, rounding to nearest even reduces the rounding error that is caused by consistently rounding midpoint values in a single direction. In some cases, this rounding error can be significant.\n\nThe following example illustrates the bias that can result from consistently rounding midpoint values in a single direction. The example computes the true mean of an array of Decimal values, and then computes the mean when the values in the array are rounded by using the two conventions. In this example, the true mean and the mean that results when rounding to nearest are the same. However, the mean that results when rounding away from zero differs by .05 (or by 3.6%) from the true mean.\n\nBy default, the Round method uses the round to nearest even convention. The following table lists the overloads of the Round method and the rounding convention that each uses.\n\nIn order to determine whether a rounding operation involves a midpoint value, the Round method multiplies the original value to be rounded by 10n, where n is the desired number of fractional digits in the return value, and then determines whether the remaining fractional portion of the value is greater than or equal to .5. This is a slight variation on a test for equality, and as discussed in the \"Testing for Equality\" section of the Double reference topic, tests for equality with floating-point values are problematic because of the floating-point format's issues with binary representation and precision. This means that any fractional portion of a number that is slightly less than .5 (because of a loss of precision) will not be rounded upward.\n\nThe following example illustrates the problem. It repeatedly adds .1 to 11.0 and rounds the result to the nearest integer. 11.5 should round to 12 using either of the midpoint-rounding conventions ( or ). However, as the output from the example shows, it does not. The example uses the \"R\" standard numeric format string to display the floating point value's full precision, and shows that the value to be rounded has lost precision during repeated additions, and its value is actually 11.499999999999998. Because .499999999999998 is less than .5, the midpoint-rounding conventions don't come into play and the value is rounded down. As the example also shows, this problem does not occur if you assign the constant value 11.5 to a Double variable.\n\nProblems of precision in rounding midpoint values are most likely to arise in the following conditions:\n• None When a fractional value cannot be expressed precisely in the floating-point type's binary format.\n• None When the value to be rounded is calculated from one or more floating-point operations.\n• None When the value to be rounded is a Single rather than a Double or Decimal. For more information, see the next section, Rounding and single-precision floating-point values.\n\nIn cases where the lack of precision in rounding operations is problematic, you can do the following:\n• None If the rounding operation calls an overload that rounds a Double value, you can change the Double to a Decimal value and call an overload that rounds a Decimal value instead. Although the Decimal data type also has problems of representation and loss of precision, these issues are far less common.\n• None Define a custom rounding algorithm that performs a \"nearly equal\" test to determine whether the value to be rounded is acceptably close to a midpoint value. The following example defines a method that examines whether a fractional value is sufficiently near to a midpoint value to be subject to midpoint rounding. As the output from the example shows, it corrects the rounding problem shown in the previous example. public static void Example() { Console.WriteLine(\"{0,5} {1,20:R} {2,12} {3,15}\n\n\", \"Value\", \"Full Precision\", \"ToEven\", \"AwayFromZero\"); double value = 11.1; for (int ctr = 0; ctr <= 5; ctr++) value = RoundValueAndAdd(value); Console.WriteLine(); value = 11.5; RoundValueAndAdd(value); } private static double RoundValueAndAdd(double value) { const double tolerance = 8e-14; Console.WriteLine(\"{0,5:N1} {0,20:R} {1,12} {2,15}\", value, RoundApproximate(value, 0, tolerance, MidpointRounding.ToEven), RoundApproximate(value, 0, tolerance, MidpointRounding.AwayFromZero)); return value + .1; } private static double RoundApproximate(double dbl, int digits, double margin, MidpointRounding mode) { double fraction = dbl * Math.Pow(10, digits); double value = Math.Truncate(fraction); fraction = fraction - value; if (fraction == 0) return dbl; double tolerance = margin * dbl; // Determine whether this is a midpoint value. if ((fraction >= .5 - tolerance) & (fraction <= .5 + tolerance)) { if (mode == MidpointRounding.AwayFromZero) return (value + 1) / Math.Pow(10, digits); else if (value % 2 != 0) return (value + 1) / Math.Pow(10, digits); else return value / Math.Pow(10, digits); } // Any remaining fractional value greater than .5 is not a midpoint value. if (fraction > .5) return (value + 1) / Math.Pow(10, digits); else return value / Math.Pow(10, digits); } // The example displays the following output: // Value Full Precision ToEven AwayFromZero // // 11.1 11.1 11 11 // 11.2 11.2 11 11 // 11.3 11.299999999999999 11 11 // 11.4 11.399999999999999 11 11 // 11.5 11.499999999999998 12 12 // 11.6 11.599999999999998 12 12 // // 11.5 11.5 12 12 open System let roundApproximate dbl digits margin mode = let fraction = dbl * Math.Pow(10, digits) let value = Math.Truncate fraction let fraction = fraction - value if fraction = 0 then dbl else let tolerance = margin * dbl // Determine whether this is a midpoint value. if (fraction >= 0.5 - tolerance) && (fraction <= 0.5 + tolerance) then if mode = MidpointRounding.AwayFromZero then (value + 1.) / Math.Pow(10, digits) elif value % 2. <> 0 then (value + 1.) / Math.Pow(10, digits) else value / Math.Pow(10, digits) // Any remaining fractional value greater than .5 is not a midpoint value. elif fraction > 0.5 then (value + 1.) / Math.Pow(10, digits) else value / Math.Pow(10, digits) let roundValueAndAdd value = let tolerance = 8e-14 let round = roundApproximate value 0 tolerance printfn $\"{value,5:N1} {value,20:R} {round MidpointRounding.ToEven,12} {round MidpointRounding.AwayFromZero,15}\" value + 0.1 printfn \"%5s %20s %12s %15s\n\n\" \"Value\" \"Full Precision\" \"ToEven\" \"AwayFromZero\" let mutable value = 11.1 for _ = 0 to 5 do value <- roundValueAndAdd value printfn \"\" value <- 11.5 roundValueAndAdd value |> ignore // The example displays the following output: // Value Full Precision ToEven AwayFromZero // // 11.1 11.1 11 11 // 11.2 11.2 11 11 // 11.3 11.299999999999999 11 11 // 11.4 11.399999999999999 11 11 // 11.5 11.499999999999998 12 12 // 11.6 11.599999999999998 12 12 // // 11.5 11.5 12 12 Public Sub Example() Dim value As Double = 11.1 Console.WriteLine(\"{0,5} {1,20:R} {2,12} {3,15}\n\n\", \"Value\", \"Full Precision\", \"ToEven\", \"AwayFromZero\") For ctr As Integer = 0 To 5 value = RoundValueAndAdd(value) Next Console.WriteLine() value = 11.5 RoundValueAndAdd(value) End Sub Private Function RoundValueAndAdd(value As Double) As Double Const tolerance As Double = 0.00000000000008 Console.WriteLine(\"{0,5:N1} {0,20:R} {1,12} {2,15}\", value, RoundApproximate(value, 0, tolerance, MidpointRounding.ToEven), RoundApproximate(value, 0, tolerance, MidpointRounding.AwayFromZero)) Return value + 0.1 End Function Private Function RoundApproximate(dbl As Double, digits As Integer, margin As Double, mode As MidpointRounding) As Double Dim fraction As Double = dbl * Math.Pow(10, digits) Dim value As Double = Math.Truncate(fraction) fraction = fraction - value If fraction = 0 Then Return dbl Dim tolerance As Double = margin * dbl ' Determine whether this is a midpoint value. If (fraction >= 0.5 - tolerance) And (fraction <= 0.5 + tolerance) Then If mode = MidpointRounding.AwayFromZero Then Return (value + 1) / Math.Pow(10, digits) Else If value Mod 2 <> 0 Then Return (value + 1) / Math.Pow(10, digits) Else Return value / Math.Pow(10, digits) End If End If End If ' Any remaining fractional value greater than .5 is not a midpoint value. If fraction > 0.5 Then Return (value + 1) / Math.Pow(10, digits) Else Return value / Math.Pow(10, digits) End If End Function ' The example displays the following output: ' Value Full Precision ToEven AwayFromZero ' ' 11.1 11.1 11 11 ' 11.2 11.2 11 11 ' 11.3 11.299999999999999 11 11 ' 11.4 11.399999999999999 11 11 ' 11.5 11.499999999999998 12 12 ' 11.6 11.599999999999998 12 12 ' ' 11.5 11.5 12 12\n\nThe Round method includes overloads that accept arguments of type Decimal and Double. There are no methods that round values of type Single. If you pass a Single value to one of the overloads of the Round method, it is cast (in C#) or converted (in Visual Basic) to a Double, and the corresponding Round overload with a Double parameter is called. Although this is a widening conversion, it often involves a loss of precision, as the following example illustrates. When a Single value of 16.325 is passed to the Round method and rounded to two decimal places using the rounding to nearest convention, the result is 16.33 and not the expected result of 16.32.\n\nThis unexpected result is due to a loss of precision in the conversion of the Single value to a Double. Because the resulting Double value of 16.325000762939453 is not a midpoint value and is greater than 16.325, it is always rounded upward.\n\nIn many cases, as the example illustrates, the loss of precision can be minimized or eliminated by casting or converting the Single value to a Decimal. Note that, because this is a narrowing conversion, it requires using a cast operator or calling a conversion method."
    },
    {
        "link": "https://stackoverflow.com/questions/12621640/rounding-a-variable-to-two-decimal-places-c-sharp",
        "document": "You should use a form of . Be aware that defaults to banker's rounding (rounding to the nearest even number) unless you specify a value. If you don't want to use banker's rounding, you should use , like so:"
    },
    {
        "link": "https://ironpdf.com/blog/net-help/csharp-round-guide",
        "document": "Test in production without watermarks.\n\nWorks wherever you need it to."
    },
    {
        "link": "https://ironpdf.com/blog/net-help/math-round-csharp",
        "document": "Test in production without watermarks.\n\nWorks wherever you need it to."
    }
]