[
    {
        "link": "https://comptia.org/blog/nine-ways-to-use-grep-to-filter-results-linux",
        "document": ""
    },
    {
        "link": "https://docs.fluentbit.io/manual/pipeline/filters/grep",
        "document": "The Grep Filter plugin lets you match or exclude specific records based on regular expression patterns for values or nested values.\n\nThe plugin supports the following configuration parameters:\n\nEnable the Record Accessor feature to specify the KEY. Use the record accessor to match values against nested values.\n\nTo start filtering records, run the filter from the command line or through the configuration file. The following example assumes that you have a file named with the following content:\n\nWhen using the command line, pay close attention to quote the regular expressions. Using a configuration file might be easier.\n\nThe following command loads the tail plugin and reads the content of . Then the filter applies a regular expression rule over the field created by the plugin and only passes records with a field value starting with :\n\nThe filter lets you use multiple rules which are applied in order. You can have as many and entries as required.\n\nTo match or exclude records based on nested values, you can use Record Accessor format as the name.\n\nConsider the following record example:\n\nFor example, to exclude records that match the nested field , use the following rule:\n\nYou might want to drop records that are missing certain keys.\n\nOne way to do this is to with a regex that matches anything. A missing key fails this check.\n\nThe followinfg example checks for a specific valid value for the key:\n\nThe specified key must match the expected expression. If it doesn't, or is missing or empty, then it will be excluded.\n\nIf you want to set multiple or , use the property to use a logical conjuction or disjunction.\n\nIf is set, setting both and results in an error.\n\nThe output looks similar to:"
    },
    {
        "link": "https://docs.fluentbit.io/manual/1.9-pre/pipeline/filters/grep",
        "document": "The Grep Filter plugin allows you to match or exclude specific records based on regular expression patterns for values or nested values.\n\nThe plugin supports the following configuration parameters:\n\nThis plugin enables the Record Accessor feature to specify the KEY. Using the record accessor is suggested if you want to match values against nested values.\n\nIn order to start filtering records, you can run the filter from the command line or through the configuration file. The following example assumes that you have a file called with the following content:\n\nThe following command will load the tail plugin and read the content of file. Then the grep filter will apply a regular expression rule over the log field (created by tail plugin) and only pass the records which field value starts with aa:\n\nThe filter allows to use multiple rules which are applied in order, you can have many Regex and Exclude entries as required.\n\nIf you want to match or exclude records based on nested values, you can use a Record Accessor format as the KEY name. Consider the following record example:\n\nif you want to exclude records that match given nested field (for example ), you can use the following rule:\n\nIt may be that in your processing pipeline you want to drop records that are missing certain keys.\n\nA simple way to do this is just to with a regex that matches anything, a missing key will fail this check.\n\nHere is an example that checks for a specific valid value for the key as well:\n\nThe specified key must match the expected expression - if it does not or is missing/empty then it will be excluded."
    },
    {
        "link": "https://caspar.bgsu.edu/~courses/Stats/Labs/Handouts/grepadvanced.htm",
        "document": ""
    },
    {
        "link": "https://blog.robertelder.org/top-5-grep-mistakes",
        "document": ""
    },
    {
        "link": "https://digitalocean.com/community/tutorials/using-grep-regular-expressions-to-search-for-text-patterns-in-linux",
        "document": "The command is one of the most useful commands in a Linux terminal environment. The name stands for “global regular expression print”. This means that you can use to check whether the input it receives matches a specified pattern. This seemingly trivial program is extremely powerful; its ability to sort input based on complex rules makes it a popular link in many command chains.\n\nIn this tutorial, you will explore the command’s options, and then you’ll dive into using regular expressions to do more advanced searching.\n\nTo follow along with this guide, you will need access to a computer running a Linux-based operating system. This can either be a virtual private server which you’ve connected to with SSH or your local machine. Note that this tutorial was validated using a Linux server running Ubuntu 20.04, but the examples given should work on a computer running any version of any Linux distribution.\n\nIf you plan to use a remote server to follow this guide, we encourage you to first complete our Initial Server Setup guide. Doing so will set you up with a secure server environment — including a non-root user with privileges and a firewall configured with UFW — which you can use to build your Linux skills.\n\nIn this tutorial, you’ll use to search the GNU General Public License version 3 for various words and phrases.\n\nIf you’re on an Ubuntu system, you can find the file in the folder. Copy it to your home directory:\n\nIf you’re on another system, use the command to download a copy:\n\nYou’ll also use the BSD license file in this tutorial. On Linux, you can copy that to your home directory with the following command:\n\nIf you’re on another system, create the file with the following command:\n\nNow that you have the files, you can start working with .\n\nIn the most basic form, you use to match literal patterns within a text file. This means that if you pass a word to search for, it will print out every line in the file containing that word.\n\nExecute the following command to use to search for every line that contains the word :\n\nThe first argument, , is the pattern you’re searching for, while the second argument, , is the input file you wish to search.\n\nThe resulting output will be every line containing the pattern text:\n\nOn some systems, the pattern you searched for will be highlighted in the output.\n\nBy default, will search for the exact specified pattern within the input file and return the lines it finds. You can make this behavior more useful though by adding some optional flags to .\n\nIf you want to ignore the “case” of your search parameter and search for both upper- and lower-case variations, you can specify the or option.\n\nSearch for each instance of the word (with upper, lower, or mixed cases) in the same file as before with the following command:\n\nThe results contain: , , and :\n\nIf there was an instance with , that would have been returned as well.\n\nIf you want to find all lines that do not contain a specified pattern, you can use the or option.\n\nSearch for every line that does not contain the word in the BSD license with the following command:\n\nSince you did not specify the “ignore case” option, the last two items were returned as not having the word .\n\nIt is often useful to know the line number that the matches occur on. You can do this by using the or option. Re-run the previous example with this flag added:\n\nThis will return the following text:\n\nNow you can reference the line number if you want to make changes to every line that does not contain . This is especially handy when working with source code.\n\nIn the introduction, you learned that stands for “global regular expression print”. A “regular expression” is a text string that describes a particular search pattern.\n\nDifferent applications and programming languages implement regular expressions slightly differently. In this tutorial you will only be exploring a small subset of the way that describes its patterns.\n\nIn the previous examples in this tutorial, when you searched for the words and , you were actually searching for basic regular expressions which matched the exact string of characters and . Patterns that exactly specify the characters to be matched are called “literals” because they match the pattern literally, character-for-character.\n\nIt is helpful to think of these as matching a string of characters rather than matching a word. This will become a more important distinction as you learn more complex patterns.\n\nAll alphabetical and numerical characters (as well as certain other characters) are matched literally unless modified by other expression mechanisms.\n\nAnchors are special characters that specify where in the line a match must occur to be valid.\n\nFor instance, using anchors, you can specify that you only want to know about the lines that match at the very beginning of the line. To do this, you could use the anchor before the literal string.\n\nRun the following command to search the file and find lines where occurs at the very beginning of a line:\n\nThis command will return the following two lines:\n\nSimilarly, you use the anchor at the end of a pattern to indicate that the match will only be valid if it occurs at the very end of a line.\n\nThis command will match every line ending with the word in the file:\n\nThe period character (.) is used in regular expressions to mean that any single character can exist at the specified location.\n\nFor example, to match anything in the file that has two characters and then the string , you would use the following pattern:\n\nThis command returns the following output:\n\nThis output has instances of both and and variations of the two words. The pattern would also have matched if that was found as well.\n\nBy placing a group of characters within brackets ( and ), you can specify that the character at that position can be any one character found within the bracket group.\n\nFor example, to find the lines that contain or , you would specify those variations succinctly by using the following pattern:\n\nThe output shows that both variations exist in the file:\n\nBracket notation gives you some interesting options. You can have the pattern match anything except the characters within a bracket by beginning the list of characters within the brackets with a character.\n\nThis example is like the pattern , but will not match the pattern :\n\nNotice that in the second line returned, there is, in fact, the word . This is not a failure of the regular expression or grep. Rather, this line was returned because earlier in the line, the pattern , found within the word , was found. The line was returned because there was an instance that matched the pattern.\n\nAnother helpful feature of brackets is that you can specify a range of characters instead of individually typing every available character.\n\nThis means that if you want to find every line that begins with a capital letter, you can use the following pattern:\n\nDue to some legacy sorting issues, it is often more accurate to use POSIX character classes instead of character ranges like you just used.\n\nTo discuss every POSIX character class would be beyond the scope of this guide, but an example that would accomplish the same procedure as the previous example uses the character class within a bracket selector:\n\nThe output will be the same as before.\n\nRepeat Pattern Zero or More Times\n\nFinally, one of the most commonly used meta-characters is the asterisk, or , which means “repeat the previous character or expression zero or more times”.\n\nTo find each line in the file that contains an opening and closing parenthesis, with only letters and single spaces in between, use the following expression:\n\nYou’ll get the following output:\n\nSo far you’ve used periods, asterisks, and other characters in your expressions, but sometimes you need to search for those characters specifically.\n\nThere are times where you’ll need to search for a literal period or a literal opening bracket, especially when working with source code or configuration files. Because these characters have special meaning in regular expressions, you need to “escape” these characters to tell that you do not wish to use their special meaning in this case.\n\nYou escape characters by using the backslash character ( ) in front of the character that would normally have a special meaning.\n\nFor instance, to find any line that begins with a capital letter and ends with a period, use the following expression which escapes the ending period so that it represents a literal period instead of the usual “any character” meaning:\n\nThis is the output you’ll see:\n\nNow let’s look at other regular expression options.\n\nThe command supports a more extensive regular expression language by using the flag or by calling the command instead of .\n\nThese options open up the capabilities of “extended regular expressions”. Extended regular expressions include all of the basic meta-characters, along with additional meta-characters to express more complex matches.\n\nOne of the most useful abilities that extended regular expressions open up is the ability to group expressions together to manipulate or reference as one unit.\n\nTo group expressions together, wrap them in parentheses. If you would like to use parentheses without using extended regular expressions, you can escape them with the backslash to enable this functionality. This means that the following three expressions are functionally equivalent:\n\nSimilar to how bracket expressions can specify different possible choices for single character matches, alternation allows you to specify alternative matches for strings or expression sets.\n\nTo indicate alternation, use the pipe character . These are often used within parenthetical grouping to specify that one of two or more possibilities should be considered a match.\n\nThe following will find either or in the text:\n\nThe output looks like this:\n\nAlternation can select between more than two choices by adding additional choices within the selection group separated by additional pipe ( ) characters.\n\nLike the meta-character that matched the previous character or character set zero or more times, there are other meta-characters available in extended regular expressions that specify the number of occurrences.\n\nTo match a character zero or one times, you can use the character. This makes character or character sets that came before optional, in essence.\n\nThe following matches and by putting in an optional group:\n\nThe character matches an expression one or more times. This is almost like the meta-character, but with the character, the expression must match at least once.\n\nThe following expression matches the string plus one or more characters that are not white space characters:\n\nTo specify the number of times that a match is repeated, use the brace characters ( and ). These characters let you specify an exact number, a range, or an upper or lower bounds to the amount of times an expression can match.\n\nUse the following expression to find all of the lines in the file that contain triple-vowels:\n\nEach line returned has a word with three vowels:\n\nTo match any words that have between 16 and 20 characters, use the following expression:\n\nOnly lines containing words within that length are displayed.\n\nis useful in finding patterns within files or within the file system hierarchy, so it’s worth spending time getting comfortable with its options and syntax.\n\nRegular expressions are even more versatile, and can be used with many popular programs. For instance, many text editors implement regular expressions for searching and replacing text.\n\nFurthermore, most modern programming languages use regular expressions to perform procedures on specific pieces of data. Once you understand regular expressions, you’ll be able to transfer that knowledge to many common computer-related tasks, from performing advanced searches in your text editor to validating user input."
    },
    {
        "link": "https://cyberciti.biz/faq/grep-regular-expressions",
        "document": "How do I use the grep command with regular expressions on a Linux and Unix-like operating systems? How do I use grep and regular expressions (regex)to search for text/ words in Linux?Linux comes with GNU grep, which supports extended regular expressions. GNU grep is the default on all Linux systems. The grep command is used to locate information stored anywhere on your server or workstation. Let us see fundamental of regex and how to use regular expressions in the Linux and Unix like systems.\n\nRegular Expressions is nothing but a pattern to match for each input line. A pattern is a sequence of characters. Following all are examples of pattern:\n\nThe grep understands three different types of regular expression syntax as follows:\n\nSearch for a word named ‘vivek’ in the /etc/passwd file:\n\n \n\n Sample outputs:\n\nNext, search for a word named ‘vivek’ in any case (i.e. case insensitive search):\n\n \n\n Let us try to search two words ‘vivek’ or ‘raj’ in any case:\n\n \n\n The PATTERN in last example, used as an extended regular expression. The following will match word Linux or UNIX in any case using the egrep command:\n\n $ egrep -i '^(linux|unix)' filename\n\n # Same as above by passing the '-E' to the grep #\n\n $ grep -E -i '^(linux|unix)' filename\n\nThe latest version of egrep will show the following warning\n\nYou need to update all your scripts and command to use the following syntax. From:\n\n \n\n To (avoid using the ):\n\n\n\nThe character (period, or dot) matches any one character. Consider the following demo.txt file:\n\n \n\n Sample outputs:\n\nLet us find all filenames starting with purchase, type:\n\n \n\n Next I need to find all filenames starting with purchase and followed by another character:\n\n \n\n Our final example find all filenames starting with purchase but ending with db:\n\n \n\n\n\nHow to match only dot (.)\n\nA dot (.) has a special meaning in regex, i.e. match any character. But, what if you need to match dot (.) only? I want to tell my grep command that I want actual dot (.) character and not the regex special meaning of the . (dot) character. You can escape the dot (.) by preceding it with a \\ (backslash):\n\n \n\n\n\nYou can use ^ and $ to force a regex to match only at the start or end of a line, respectively. The following example displays lines starting with the vivek only:\n\n \n\n Sample outputs:\n\nYou can display only lines starting with the word vivek only i.e. do not display vivekgite, vivekg etc:\n\n \n\n Find lines ending with word foo:\n\n \n\n Match line only containing foo:\n\n \n\n You can search for blank lines with the following examples:\n\n \n\n Matching Sets of Characters\n\nHow to match sets of character using grep\n\nThe dot (.) matches any single character. You can match specific characters and character ranges using [..] syntax. Say you want to Match both ‘Vivek’ or ‘vivek’:\n\n \n\n OR\n\n \n\n Let us match digits and upper and lower case characters. For example, try to math words such as vivek1, Vivek2 and so on:\n\n \n\n In this example match two numeric digits. In other words match foo11, foo12, foo22 and so on, enter:\n\n \n\n You are not limited to digits, you can match at least one letter:\n\n \n\n Display all the lines containing either a “w” or “n” character:\n\n \n\n Within a bracket expression, the name of a character class enclosed in “[:” and “:]” stands for the list of all characters belonging to that class. Standard character class names are:\n\nIn this example match all upper case letters:\n\n\n\nThe ^ negates all ranges in a set:\n\n \n\n\n\nYou can use the “.” for a single character match. In this example match all 3 character word starting with “b” and ending in “t”:\n• \\< Match the empty string at the beginning of word\n• \\> Match the empty string at the end of word.\n\nPrint all lines with exactly two characters:\n\n \n\n Display any lines starting with a dot and digit:\n\n\n\nSay you just want to match an IP address 192.168.2.254 and nothing else. The following regex to find an IP address 192.168.1.254 will not work (remember the dot matches any single character?):\n\n \n\n Sample outputs:\n\nAll three dots need to be escaped:\n\n\n\n The following example will only match an IP address:\n\n\n\nHow Do I Search a Pattern Which Has a Leading Symbol?\n\nSearches for all lines matching ‘ ‘ using option Without , grep would attempt to parse ‘ ‘ as a list of options. For example:\n\n\n\nHow Do I do OR with grep?\n\nUse the following syntax:\n\n \n\n OR Try the following syntax:\n\n\n\nHow do I AND with grep?\n\nUse the following syntax to display all lines that contain both ‘word1’ and ‘word2’\n\n \n\n OR try the following syntax:\n\n\n\nYou can test how often a character must be repeated in sequence using the following syntax:\n\nMatch a character “v” two times:\n\n \n\n The following will match both “col” and “cool” words:\n\n \n\n Our next example will match any row of at least three letters ‘c’.\n\n \n\n In this example, I will match mobile number which is in the following format 91-1234567890 (i.e TwoDigit-TenDigit)\n\n\n\nHow Do I Highlight with grep?\n\nHow Do I Show Only The Matches, Not The Lines?\n\nUse the following syntax:\n\n\n\nI hope following table will help you quickly understand regular expressions in grep when using under Linux or Unix-like systems:\n\n\n\nThe egrep is the same as command. It interpret PATTERN as an extended regular expression. From the grep man page:\n\nYou learned how to regular expressions (regex) in grep running on Linux or Unix with various examples. See GNU/grep man page online here or see the following resources using the man command or info command (or pass the --help option:\n\n \n\n\n\n🥺 Was this helpful? Please add a comment to show your appreciation or feedback."
    },
    {
        "link": "https://stackoverflow.com/questions/25781642/how-to-search-for-a-pattern-using-grep-and-exclude-another-pattern",
        "document": "I have been looking at several other answers and couldn't find what I want.\n\nI have a big file with some urls in it and I am looking for urls which have the pattern tt in them. Of course every line has http in it. so if I do\n\nI get all the lines of the file. How can I find patterns which match tt, without matching http?\n\nI tried with --exclude and it doesn't work, I think exclude only works on the path, right?\n\nI could use sed and replace http by something else and then grep normally, but how elegant is that? there must be another way..."
    },
    {
        "link": "https://charmm-gui.org?doc=lecture&module=unix&lesson=9",
        "document": "One of the most common things you'll want to do is search for text in a file that follows a specific pattern. The way we find regularly-occurring patterns in UNIX is with regular expressions (usually abbreviated \"regex\"). In this lesson, we'll learn about grep. In the next lesson, we'll learn a little about the other programs UNIX has for regex: sed and awk\n\nThe most basic reason to use grep is to search a file for a word. grep will display each line containing the word:\n\nThe entire line is displayed, even if only a part of it matches the pattern we give grep. Consider this example:\n\nAlmost every single line in /etc/shells got displayed! Each of the above lines was displayed because it contained \"sh\" somewhere in the line, regardless of whether it was part of a larger word. E.g. the first line contains the word \"shells\", but it was displayed because \"shells\" has \"sh\" in it. Lines that match a pattern we search for are said to match a regular expression.\n\nIf we search /etc/protocols for lines containing \"IP\", we'll get only lines that contain uppercase IP. To include results where \"IP\" is lowercase or mixed-case, use the -i option to grep:\n\nThe above commands will include lines containing IP, ip, iP, or Ip.\n\nMatch Results at Beginning or End of Line\n\nSometimes you only want to find a line that contains a word or pattern at the beginning or end of a line. In a regular expression, ^ matches to the beginning of a line, and $ matches to the end of a line:\n\nThe first command will match lines starting with \"ip\", and the second command will match lines ending with \"ip\" (both are case-insensitive).\n\nIf you want to match only lines which don't contain a word or pattern, use the -v option:\n\nThe above command will exclude any lines with \"IP\" (case-insensitive).\n\nCombining grep commands with piping allows for some pretty specific searches, e.g.:\n\nThe above will search for lines that have a hyphen, but which don't mention \"ip\".\n\nIf the only thing you could do was search for an exact piece of text in a file, regular expressions would be pretty useless. However, the reason we say we are matching for patterns is that we can get grep to find text even if we don't know exactly what it looks like.\n\nThe most powerful tool for doing this is the character class. A character class is a set of characters enclosed in square brackets ([]). To search for a general pattern, we need to use the -e option for grep, which (among other things) tells grep to interpret square braces braces as a character class:\n\nThe above command will match text at the end of a line in /etc/shells that has a forward slash, followed by either a c, k, or z, followed by \"sh\". Note also that the order doesn't matter in a character class. All of these will do the same thing:\n\nWith what we've discussed so far, if we wanted to search for a line containing, say, any number, we would have to specify all of the numbers like this:\n\nAnd it would be even longer if we wanted to search for any letter. We can shorten this by specifying a range instead:\n\nThe above will match any number. We can be more specific with the range if we want:\n\nThe above will match 1, 2, 3, or 4. We can also include multiple ranges in a class:\n\nThe first command will match any number except 4 and 5, the second will match any number or any lower-case letter, and the third will match any letter (upper- or lower-case).\n\nSo far, we know how to match a single character within some range, but it would be pretty tedious if we wanted to match several characters. For example, if we wanted to match any 3 digits, we'd have to do it like this:\n\nSo far, we know how to match a single character within some range, but if we wanted to match several characters, it would be pretty tedious. For example, if we wanted to match any 3 digits, we'd have to do it like this:\n\nThere is a shortcut for this. First, you need to use grep with the -E option (for \"extended\" regular expressions), then specify the number of times you want a character class to match with curly braces:\n\nThe above command will match any number that has three digits\n\nYou can match a more specific length of characters matching a class by specifying the minimum and maximum, separated by a comma:\n\nThe above command will match two or three consecutive digits.\n\nMatch a minimum number of something like this:\n\nThe above command will match any lines that contain at least two consecutive digits.\n\nIf you wanted to match a character that occurs either once or not at all, you could do so with a question-mark, like this:\n\nThe above command will match any line containing a space, followed either by nothing or an alpha-numeric character, followed by \"ip\" preceded by an alpha-numeric character.\n\nThe shortcut for \"at least one\" is <+>:\n\nThe above command will match any line containing at least one digit, followed by a character that is not a digit, followed by at least one digit\n\nFinally, you can match any number (including zero) of characters by following it with an asterisk:\n\nMatch Any Character Except Those in a Class\n\nA character class that starts with carat <^>, will match any character NOT in the class. For example, if we wanted to find any lines containing \"ip\", where \"ip\" wasn't part of a larger word like \"pipe\", we could do so like this:\n\nThe above command will match a non-letter character, followed by \"ip\", followed by a non-letter character.\n\nThe period <.> is a shortcut that will match any character whatsoever. To list any line with an \"i\", followed by any character, followed by \"p\", do this:\n\nIf you wanted to match for lines containing a special character, you would need to put a backslash <\\> before the character like this:\n\nUnless escaped (\\.), the period has a special meaning to grep. The backslash tells grep that you are looking for a literal period. For another example, suppose we wanted to find any lines that contain non-empty parentheses:\n\nThe above command matches a (, at least one of any character, then ).\n\nDisplay Only the Part that Matched with\n\nSo far, everything we've done will display the entire line, even if we are only interested in a part of it. You can restrict the output of grep with the -o option:\n\nYou may have noticed that the first line of output from the last command we used displayed text outside of parentheses. By default, grep will match the most text that it possibly can. This is referred to as a greedy match. In other words, since there were two sets of parentheses in the first line of output, grep matched the first one, and everything all the way to the last one.\n\nA lazy match is one that matches the least amount of text possible. Most versions of grep allow you to do this with Perl-style regular expressions. However, Perl is beyond the scope of this tutorial, so they will not be covered here. Just know that there are a lot more options to modify the behavior of grep.\n\nSince searching for digits or words is extremely common, there are shortcuts for doing this. grep supports these shortcut classes:\n• searches for anything except digits ( )\n\nWe can use the above classes to search for lines of text formatted like a street address like this:\n\nThat command would match \"1234 Willow Way\" or \"31337 E. Strange St.\", but will not match \"Good Morning.\"\n\ngrep also allows searching for the boundary of a word like this:\n\nThe above command finds words where \"ip\" occurs somewhere in the middle of the word.\n\nFor more information about grep's shortcut classes, use man re_pattern, and skip to the \"Assertions\" and \"Shortcuts\" sections.\n\nParentheses in a regular expression means \"do this to everything in the parentheses\". With the operations we've learned so far, we could, if we wanted, search for any line starting with a 4-character word:\n\nBut we would have to get pretty creative to search for lines starting with an even number of characters. Fortunately, there is a way to apply a length specifier to more than just one character. Just wrap what you want to specify the length of in parentheses:\n\nThe above command matches a line starting with any multiple of two alpha-numeric characters.\n\nPlease keep in mind that there is a lot more than this to regex, but this should be enough to get you started with it."
    },
    {
        "link": "https://developers.redhat.com/articles/2022/09/14/beginners-guide-regular-expressions-grep",
        "document": "A regular expression (also called a regex or regexp) is a rule that a computer can use to match characters or groups of characters within a larger body of text. For instance, using regular expressions, you could find all the instances of the word cat in a document, or all instances of a word that begins with c and ends with t.\n\nUse of regular expressions in the real world can get much more complex—and powerful—than that. For example, imagine you need to write code verifying that all content in the body of an HTTP POST request is free of script injection attacks. Malicious code can appear in any number of ways, but you know that injected script code will always appear between HTML tags. You can apply the regular expression , which matches any block of code text bracketed by tags, to the HTTP request body as part of your search for script injection code.\n\nThis example is but one of many uses for regular expressions. In this series, you'll learn more about how the syntax for this and other regular expressions work.\n\nAs just demonstrated, a regex can be a powerful tool for finding text according to a particular pattern in a variety of situations. Once mastered, regular expressions provide developers with the ability to locate patterns of text in source code and documentation at design time. You can also apply regular expressions to text that is subject to algorithmic processing at runtime such as content in HTTP requests or event messages.\n\nRegular expressions are supported by many programming languages, as well as classic command-line applications such as awk, sed, and grep, which were developed for Unix many decades ago and are now offered on GNU/Linux.\n\nThis article examines the basics of using regular expressions under . The article shows how you can use a regular expression to declare a pattern that you want to match, and outlines the essential building blocks of regular expressions, with many examples. This article assumes no prior knowledge of regular expressions, but you should understand how to with the Linux operating system at the command line.\n\nWhat are regular expressions, and what is grep?\n\nAs we've noted, a regular expression is a rule used for matching characters in text. These rules are declarative, which means they are immutable: once declared, they do not change. But a single rule can be applied to any variety of situations.\n\nRegular expressions are written in a special language. Although this language has been standardized, dialects vary from one regular expression engine to another. For example, JavaScript has a regex dialect, as do C++, Java, and Python.\n\nThis article uses the regular expression dialect that goes with the Linux grep command, with an extension to support more powerful features. is a binary executable that filters content in a file or output from other commands (stdout). Regular expressions are central to : The re in the middle of the name stands for \"regular expression.\"\n\nThis article uses because it doesn't require that you set up a particular coding environment or write any code to work with the examples of regular expressions demonstrated in this article. All you need to do is copy and paste an example onto the command line of a Linux terminal and you'll see results immediately. The command can be used in any shell.\n\nBecause this article focuses on regular expressions as a language, and not on manipulating files, the examples use samples of text piped to instead of input files.\n\nHow to use grep against content in a file\n\nTo print lines in a file that match a regular expression, use the following syntax:\n• , if specified, control the behavior of the command.\n• indicates the regular expression to execute against the files.\n• indicate one or more files against which the regular will be executed.\n\nThe options used in this article are:\n• : Apply regular expressions in the style of the Perl programming language. This option, which is specific to GNU/Linux, is used in the article to unlock powerful features that aren't recognized by by default. There is nothing specific to Perl in the regular expressions used in this article; the same features can be found in many programming languages.\n• : Print only the characters matching the regular expression. By default, the whole line containing the matching string is printed.\n\nHow to pipe content to a regular expression\n\nAs mentioned earlier, you can also use a regular expression to filter output from stdout. The following example uses the pipe symbol ( ) to feed the result of an command to .\n\nThe command produces the following output:\n\nWhy does return the characters to match the regular expression specified here? We'll explore the reasons in subsequent sections of this article.\n\nRegular characters, metacharacters, and patterns: The building blocks of regular expressions\n\nYou'll use three basic building blocks when working with regular expressions: regular characters, metacharacters, and patterns. Regular characters and metacharacters are used to create a regular expression, and that regular expression represents a matching pattern that the regex engine applies to some content.\n\nYou can think of a metacharacter as a placeholder symbol. For example, the metacharacter (a dot or period) represents \"any character.\" The metacharacter represents any single numeral, 0 through 9.\n\nThe metacharacter is a shorthand that represents the instruction \"search for a character that occurs zero or more times as defined by the preceding character.\" (You'll see how to work with the metacharacter in sections to come.)\n\nRegular expressions support many metacharacters, each worthy of a page or two of description. For now, the important thing to understand is that a metacharacter is a reserved symbol used by the regex engine to describe a character in a generic manner. Also, certain metacharacters are a shorthand for a search instruction.\n\nYou can combine regular characters with metacharacters to declare rules that define search patterns. For example, consider the following short regular expression:\n\nThis matches a pattern consisting of two characters. The first character can be any character, as declared by the (dot) metacharacter, but the second character must be . Thus, applying the regular expression to the string I like cats but not rats matches the strings highlighted in bold font here:\n\nI like cats but not rats\n\nYou can do a lot using just the basic metacharacters to create regular expressions with . The following sections provide a number of useful examples.\n\nThe following subsections demonstrate various examples of regular expressions. The examples are presented as two commands to enter in a Linux terminal. The first command creates a variable named that contains a sample string. The second executes the command against and pipes the result of the command to . The command then filters the input according to the associated regular expression.\n\nHow to declare an exact pattern match using regular characters\n\nThe following example demonstrates how to search a string according to the pattern of regular characters, . The search declaration is case-sensitive:\n\nThe following example demonstrates how to search a string according to a pattern of regular characters, . The search declaration is case-insensitive, as indicated by the option in the command. Thus, the regex engine will find occurrences such as as well as or .\n\nThe following example uses the metacharacter symbol to search according to a this or that condition—that is, a condition that can be satisfied by either of the regular expressions on either side of . In this case, the regular expression matches occurrences of the regular character or :\n\nThe command identifies each occurrence that satisfies the rule declared in the regular expression. Conceptually, the regular expression is saying, Return any character that is either an f or a g. We are leaving the search case-sensitive, as is the default. Thus, the identified characters are highlighted in bold text here:\n\nJeff and the pet Lucky. Gregg and the dog Fido. Chris has 1 bird named Tweety.\n\nBecause each character is identified and returned on a one-by-one basis, the output sent to the terminal window is:\n\nHow to find a character at the beginning of a line\n\nThe following example uses the metacharacter to search for the beginning of a line of text. Conceptually, the metacharacter matches the beginning of a line.\n\nThe example executes the regular expression . This regular expression searches for a match that satisfies two conditions. The first condition is to find the beginning of the line; the next is to find the regular character at that position.\n\nThe regular expression matches the character highlighted in bold text as shown here:\n\nJeff and the pet Lucky. Gregg and the dog Fido. Chris has 1 bird named Tweety.\n\nThe result returned to the terminal is:\n\nHow to find a character at the end of a line\n\nThe following example uses the metacharacter to search for the end of a line to text.\n\nThe example executes the regular expression . The regular expression declares a matching rule that has two conditions. First, the regular expression searches for an occurrence of the regular character (dot). Then the regular expression looks to see whether the end of the line is next. Thus, if the character comes at the end of the line, it's deemed a match.\n\nThe regular expression includes a backslash ( ) as an \"escape\" metacharacter before the dot. The escape metacharacter is needed to override the normal meaning of the dot as a metacharacter. Remember that the (dot) metacharacter means any character. With the escape character, the dot is treated as a regular character, and so matches just itself:\n\nThe regular expression matches the final dot in the text, highlighted in bold as shown here:\n\nJeff and the pet Lucky. Gregg and the dog Fido. Chris has 1 bird named Tweety.\n\nThe result is just the final dot:\n\nSuppose you were to use an unescaped dot in the regular expression:\n\nYou would get the same result as using the escaped dot, but a different logic is being executed. That logic is: Match any character that is the last character before the end of the string. Thus, the regular expression would always match any line. Using the escape character to identify a character as a regular character is a subtle distinction in this case, but an important one nonetheless.\n\nHow to find multiple characters at the end of a line\n\nThe following example searches the string assigned to the variable to match the characters when they appear at the end of a line.\n\nAgain, note the user of the escape metacharacter ( ) to declare the (dot) character as a regular character.\n\nHow to find occurrences of a character using the metacharacters for matching numerals\n\nThe following example uses the metacharacter to create a regular expression that looks for matches of any numeral in a given piece of text.\n\nBecause each numeral is matched and returned on a one-by-one basis, the output sent to the terminal is:\n\nHow to find a string using metacharacters for a numeral and a space\n\nThe following example uses the and metacharacters along with regular characters to create a regular expression that matches text according to the following logic: Match any numeral that is followed by a space and then the regular characters cats.\n\nThe metacharacter matches a numeral and the metacharacter matches a whitespace character (a space, a tab, or a few other rare characters):\n\nHow to combine metacharacters to create a complex regular expression\n\nThe following example uses the metacharacter to match a numeral, to match a space, and (dot) to match any character. The regular expressions uses the metacharacter to say, Match zero or more successive occurrences of the preceding character.\n\nThe logic expressed in the regular expression is this: Find a string of text that starts with a numeral followed by a space character and the regular characters cats. Then keep going, matching any characters until you come to another numeral followed by a space character and the regular characters dogs:\n\nHow to traverse a line of text to a stop point\n\nThe following example uses the (dot) metacharacter and along with the regular characters to create a regular expression with the following logic: Match any character zero or more times until you come to the characters cats:\n\nThe interesting thing about this regular expression is that starting from the beginning of the line is implicit. The metacharacter could be used to indicate the start of a line, but because the regular expression matches any characters until you come to , it isn't necessary to explicitly declare the start of the line using . The regular expression starts processing from the beginning of the line by default.\n\nRegular expressions offer a powerful yet concise way to do complex text filtering. You can use them in programming languages such as JavaScript, Python, Perl, and C++, and directly in a Linux terminal to process files and text using the command, as demonstrated in this article.\n\nGetting the hang of regular expressions takes time. Mastering the intricacies of working with the metacharacters alone can be daunting. Fortunately, the learning curve is developmental. You don't have to master the entirety of regular expressions to work with them usefully as a beginner. You can start with the basics, and as you learn more you can do more. Just being able to do pattern matching using the basic examples shown in this article can provide immediate benefit.\n\nThe next article in this series explains regular expression features that are even more powerful. Read it here: Regex how-to: Quantifiers, pattern collections, and word boundaries"
    }
]