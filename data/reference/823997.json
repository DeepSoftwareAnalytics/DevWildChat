[
    {
        "link": "https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Resources.Load.html",
        "document": "Suggest a change Thank you for helping us improve the quality of Unity Documentation. Although we cannot accept all submissions, we do read each suggested change from our users and will make updates where applicable. Close For some reason your suggested change could not be submitted. Please <a>try again</a> in a few minutes. And thank you for taking the time to help us improve the quality of Unity Documentation. Close\n\nThis method returns the asset at if it can be found, otherwise it returns null.\n\n Note that the is case insensitive and must not contain a file extension. All asset names and paths in Unity use forward slashes, so using backslashes in the will not work.\n\n\n\n The is relative to any folder named inside the Assets folder of your project. More than one Resources folder can be used. If you have multiple Resources folders you cannot duplicate the use of an asset name.\n\n\n\nFor example, a project may have Resources folders called and . The path does not need to include and in the string, for example loading a GameObject at would only require as the . Also, if exists it can be loaded using as the string.\n\n If you have multiple Resources folders you cannot duplicate the use of an asset name.\n\n\n\nIf you have multiple assets of different types with the same name, and you don't specify the type, then the object that Unity returns is non-deterministic because the potential candidates are not ordered in any particular way. Instead, use to specify the required asset.\n\nThis method returns the asset at if it can be found and if its type matches the requested generic parameter type, otherwise it returns null. You can use this overload to reduce type conversion in your code by providing a generic type parameter. This allows Unity to perform the C# type conversion for you.\n\nThis method returns the asset at if it can be found and if its type matches the optional parameter, otherwise it returns null.\n\n You may need to cast the returned object to the actual associated C# type of the asset in order to access its methods and properties, or use it with other Unity APIs."
    },
    {
        "link": "https://docs.unity3d.com/2023.2/Documentation/Manual/LoadingResourcesatRuntime.html",
        "document": "In some situations, it is useful to make an asset available to a project without loading it in as part of a sceneA Scene contains the environments and menus of your game. Think of each unique Scene file as a unique level. In each Scene, you place your environments, obstacles, and decorations, essentially designing and building your game in pieces. More info\n\nSee in Glossary. For example, there may be a character or other object that can appear in any scene of the game but which will only be used infrequently (this might be a “secret” feature, an error message or a highscore alert, say). Furthermore, you may even want to load assets from a separate file or URL to reduce initial download time or allow for interchangeable game content.\n\nYou can use Resource Folders in your project to include content in your player build, which will make it available to load when needed, independently of the scenes that you build.\n\nResource Folders contain collections of assets that are included in the built Unity player even when they are not directly referenced from any Scene included the Build.\n\nTo put assets into a Resource Folder, create a new folder in the Project windowA window that shows the contents of your folder (Project tab) More info\n\nSee in Glossary, and name the folder “Resources”. You can have multiple Resource Folders located at different subfolders within your Assets folder, and packages may also contain Resources folders. You can then place assets into that folder in the same way as any other folder in the Project window. Whenever you want to load an asset from one of these folders, call Resources.Load().\n\nNote: All assets found in the Resources folders and their dependencies are stored in a file in the build output called resources.assets. If a scene in the build references an asset then that asset is serialized into a sharedAssets*.assets file instead.\n\nOnly assets that are in the Resources folder can be accessed through Resources.Load(). However many more assets might end up in the resources.assets file since they are dependencies. For example a Material in the Resources folder might reference a Texture outside of the Resources folder. In that case the Texture is also included in the resources.assets file, but it is not available to load directly.\n\nIf you want to destroy scene objects that were loaded using Resources.Load() prior to loading another scene, call Object.Destroy() on them. To release assets and reclaim memory, use Resources.UnloadUnusedAssets().\n\nThe Resources system is convenient to use, especially for rapid prototyping and small projects. But it does not scale well and overall use of this feature is discouraged. For this reason AssetBundles and the Addressables package are the recommended alternative.\n\nSome downsides of using Resources:\n• Placing a lot of content in this folder will slow down application startup and the length of builds.\n• The Resource folder is not appropriate for delivering custom content for specific platforms.\n• Making changes to Assets in the Resource folder requires a player rebuild and redeployment, whereas AssetBundles are better suited for incremental content updates.\n\nThe resources folder can be appropriate for small Assets that are required throughout the project’s lifetime, that do not require updates, and do not vary across platforms or devices. Resource assets might be part of the minimal bootstrapping for a game, with the main content downloaded on-demand with AssetBundles. But local AssetBundles located in the StreamingAssets folder could also serve that bootstrapping need."
    },
    {
        "link": "https://discussions.unity.com/t/how-much-should-i-use-resources-load/919259",
        "document": ""
    },
    {
        "link": "https://docs.unity.cn/520/Documentation/Manual/LoadingResourcesatRuntime.html",
        "document": "In some situations, it is useful to make an asset available to a project without loading it in as part of a scene. For example, there may be a character or other object that can appear in any scene of the game but which will only be used infrequently (this might be a “secret” feature, an error message or a highscore alert, say). Furthermore, you may even want to load assets from a separate file or URL to reduce initial download time or allow for interchangeable game content.\n\nUnity supports Resource Folders in the project to allow content to be supplied in the main game file yet not be loaded until requested. You can also create Asset Bundles. These are files completely separate from the main game file which contain assets to be accessed by the game on demand from a file or URL.\n\nAn Asset Bundle is an external collection of assets. You can have many Asset Bundles and therefore many different external collections of assets. These files exist outside of the built Unity player, usually sitting on a web server for end-users to access dynamically.\n\nTo build an Asset Bundle, you call BuildPipeline.BuildAssetBundle() from inside an Editor script. In the arguments, you specify an array of Objects to be included in the built file, along with some other options. This will build a file that you can later load dynamically in the runtime by using AssetBundle.LoadAsset().\n\nResource Folders are collections of assets that are included in the built Unity player, but are not necessarily linked to any GameObject in the Inspector.\n\nTo put anything into a Resource Folder, you simply create a new folder inside the Project View, and name the folder “Resources”. You can have multiple Resource Folders organized differently in your Project. Whenever you want to load an asset from one of these folders, you call Resources.Load().\n\nIf your target deployable is a Streaming Web Player, you can define which scene will include everything in your Resource Folders. You do this in the Player Settings, accessible via Edit->Project Settings->Player. Stream queue is determined by Build Settings’ scene order.\n\nAll assets found in the Resources folders and their dependencies are stored in a file called resources.assets. If an asset is already used by another level it is stored in the .sharedAssets file for that level. The Edit -> PlayerSettings First Streamed Level setting determines the level at which the resources.assets will be collected and included in the build.\n\nIf a level prior to “First streamed Level” is including an asset in a Resource folder, the asset will be stored in assets for that level. if it is included afterwards, the level will reference the asset from the “resources.assets” file.\n\nOnly assets that are in the Resources folder can be accessed through Resources.Load(). However many more assets might end up in the “resources.assets” file since they are dependencies. (For example a Material in the Resources folder might reference a Texture outside of the Resources folder)\n\nYou can unload resources of an AssetBundle by calling AssetBundle.Unload(). If you pass true for the unloadAllLoadedObjects parameter, both the objects held internally by the AssetBundle and the ones loaded from the AssetBundle using AssetBundle.LoadAsset() will be destroyed and memory used by the bundle will be released.\n\nSometimes you may prefer to load an AssetBundle, instantiate the objects desired and release the memory used up by the bundle while keeping the objects around. The benefit is that you free up memory for other tasks, for instance loading another AssetBundle. In this scenario you would pass false as the parameter. After the bundle is destroyed you will not be able to load objects from it any more.\n\nIf you want to destroy scene objects loaded using Resources.Load() prior to loading another level, call Object.Destroy() on them. To release assets, use Resources.UnloadUnusedAssets()."
    },
    {
        "link": "https://discussions.unity.com/t/resources-load-not-working/449366",
        "document": ""
    },
    {
        "link": "https://docs.unity3d.com/2017.2/Documentation/Manual/class-SpriteRenderer.html",
        "document": "The Sprite Renderer component lets you display images as Sprites for use in both 2D and 3D scenes.\n\nAdd it to a GameObject via the Components menu (Component > Rendering > Sprite Renderer or alternatively, you can just create a GameObject directly with a Sprite Renderer already attached (menu: GameObject > 2D Object > Sprite).\n\nIn 3D graphics, an object’s appearance will vary according to lighting and the position from which it is viewed. In 2D, by contrast, an image is simply displayed onscreen with no transformations other than basic position, scale and rotation. A sprite’s position is given by a 2D coordinate, so there is no concept of “depth” or distance from camera when rendering.\n\nHowever, it is still very important to have some way to determine the overlay priority of different sprites (ie, which sprites will obscure others when they cross paths). For example, in a driving game, a car should be seen to pass over flat objects on the road surface. Unity uses the concept of sorting layers to allow you to divide sprites into groups for overlay priority. Sprites with a sorting layer lower in the order will be overlaid by those in a higher sorting layer.\n\nSometimes, two or more objects in the same sorting layer can overlap (eg, two player characters in a side scrolling game). The order in layer property can be used to apply consistent priorities to sprites in the same layer. As with sorting layers, the rule is that lower numbers are rendered first and can be obscured by the higher numbers rendered later. See the layer manager page for details of editing sorting layers. If sorting layers are not used, standard depth-based sorting can be used.\n\nA Sprite Renderer uses the texture supplied in the Sprite property but uses the shader and other properties from the Material property (this is actually accomplished using a MaterialPropertyBlock behind the scenes). This means that you can use the same material to render different sprites without worrying about which texture is assigned on the material.\n\nThe sprite is rendered on a mesh that uses position, color and UV at each vertex but no normal vector. If your material requires normal vectors then you can calculate them using a vertex shader (see the Surface Shader Examples page for further details).\n\nThe default shaders used for sprites are:\n• None Sprites/Default - a simple alpha blended shader that does not interact with lights in the scene.\n• None Sprites/Diffuse - a simple alpha-blended surface shader that does interact with lights. This generates a front-facing normal vector (0,0,–1).\n\nWhile Sprites can be flipped by setting negative , this has the side effect of also flipping the child GameObjects and also flipping the colliders, which can be performance intensive or otherwise not preferred.\n\nThe SpriteRenderer flipping feature provides a lightweight alternative which doesn’t affect any other components or GameObjects. It simply flips the rendered sprite on x or y axis and nothing else."
    },
    {
        "link": "https://docs.unity3d.com/6000.0/Documentation/Manual/sprite/renderer/renderer-landing.html",
        "document": "The SpriteA 2D graphic objects. If you are used to working in 3D, Sprites are essentially just standard textures but there are special techniques for combining and managing sprite textures for efficiency and convenience during development. More info\n\nSee in Glossary Renderer component renders the Sprite and controls how it visually appears in a SceneA Scene contains the environments and menus of your game. Think of each unique Scene file as a unique level. In each Scene, you place your environments, obstacles, and decorations, essentially designing and building your game in pieces. More info\n\nSee in Glossary for both 2D and 3D projects.\n\nWhen you create a sprite (GameObject > 2D Object > Sprite), Unity automatically creates a GameObject with the Sprite Renderer component attached. You can also add the component to an existing GameObject via the Components menu (Component > Rendering > Sprite Renderer)."
    },
    {
        "link": "https://stackoverflow.com/questions/61639276/unity-spriterenderer-set-material-in-script",
        "document": "I just want to set the material of my sprite renderer in my script. How can I do that? So I want to set the material of the Sprite Renderer in code but it doesn't work and I don't know why."
    },
    {
        "link": "https://gamedevbeginner.com/how-to-change-a-sprite-from-a-script-in-unity-with-examples",
        "document": "Although it’s a simple thing to do, changing a Sprite at runtime in Unity is a question that’s asked surprisingly often.\n\nThis may simply be because each developer’s specific needs are different, so it’s not always clear which method is the best or is the most efficient.\n\nHowever, if you’ve ever tried to load all of the Sprites from a Sprite Sheet into an array from a script, or if you’ve tried to load a Sprite by its filename, what appears to be a simple task can quickly become confusing.\n\nEspecially for a beginner, like me.\n\nThere are several different uses and multiple methods available for changing sprites at runtime. So I’ve done a little digging and will be exploring each of them, along with their benefits and drawbacks, so that you can more confidently choose which one to use.\n\nHere’s what you’ll learn in this post:\n• How to change a single Sprite from script\n• How to load Sprite from a Sprite Sheet into a Sprite Array (2 methods)\n• How to load Sprites by filename (using the Resources folder)\n• How to load Sprites by file path (using Addressable Assets)\n\nHow to change a Sprite from a script in Unity\n\nTo change a Sprite from a script in Unity, create a reference variable to hold the new Sprite. Then set the Sprite property of the Sprite Renderer Component on the Game Object you wish to change to match the new, replacement Sprite.\n\nIn scripting, it looks like this:\n\nIn the inspector select the new Sprite that you want to use by dragging it into the field or by using the circle select button.\n\nMake sure to also set the Sprite Renderer reference in the Inspector, otherwise you’ll get an error.\n\nAlternatively, if the script is on the same Game Object, you can easily get it by using Get Component in Start.\n\nThen, when you want to change the Sprite, just call the Change Sprite function.\n\nLike in this example if the Left Mouse Button is clicked:\n\nThe example will easily change a Sprite Renderer’s existing sprite to use a different one instead. But what if you want to change to one of a number of different Sprites?\n\nWhat if you have multiple Sprites, such as Slices stored in a Sprite Sheet, and you want to switch to one of them, or all of them in order, or a random Sprite, all from a script?\n\nHow to change a Sprite from a Sprite Sheet in Unity\n\nChanging a Sprite to another image from a Sprite Sheet can be done using a similar method as changing a single Sprite.\n\nWhat’s different is that, in this case, the method of loading the Sprites is different, as you’ll be storing multiple Sprites in an array and retrieving the one that you want with an index.\n\nCreating a Sprite array is simple, just add brackets to the Sprite variable to declare it as an array.\n\nNext we need to add the Sprites to the array.\n\nThere are two main ways of doing this. We’ll start with the simplest method first, which is the manual method.\n\nThis method works in much the same way as changing a single Sprite, by manually dragging the Sprites to your array in the Inspector.\n\nIt helps to lock the inspector window when doing this, as it’s very easy to accidentally switch to the import settings of the file you’re trying to drag across.\n\nOnce the Sprites are loaded into the array you’ll be able to retrieve them using their index, like this:\n\nSimply pass in the array element number in the square brackets that corresponds with the Sprite you wish to switch to.\n\nTo check which Sprite is assigned to which element, click the array dropdown in the Inspector.\n\nWhen to use the manual method\n\nThe Manual Method is the simplest way to switch between multiple Sprites and is ideal if you are able to assign the sprites you’re going to use manually in the Inspector. For example, when using a Prefab.\n\nBut, what if you want to access Sprites entirely from scripting, without getting a reference to them first?\n\nWell, as it turns out, there is a way to access Sprites from a script by their filename automatically.\n\nThe Automatic Method allows you to access individual Sprites, or even a set of Sprites from a Sprite Sheet, without needing to get a reference to them in the Inspector.\n\nInstead, by using this method, you will be able to load Sprites into a Scene with their filename from the Resources folder, a special folder that Unity will automatically load assets from (even if they’re not referenced in the Scene).\n\nNormally, this is not how Unity works, as assets are usually identified by assigning references to them (as is the case in the Manual Method). As a result, using this method comes with a few words of caution (more on that later) but, if it works for you and your project, and you understand what you’re doing, here’s how to do it.\n• First, create a new folder inside of your Assets folder called Resources. This can be placed anywhere in your Assets directory.\n• Next place the Sprites into the Resources folder.\n• Lastly, from a script, load the Sprite with Resources.Load<Type>(“filename”) passing in a String for the filename (without its extension).\n\nInstead of manually adding the Sprites to the array, we can now, instead, load all of the Sprites associated with a Sprite Sheet by using Load All.\n\nIn the example above I’ve loaded every file of the type Sprite found in the BirdHeroSprite Texture, which is essentially a directory from which all the Slices are loaded.\n\nWhile extremely useful, the Resources folder should be used with caution.\n\nReasons you shouldn’t use the Resources folder\n\nDespite offering a useful option for loading assets, using the Resources folder is, generally, not recommended, as it’s not good practice.\n\nThe main reasons you should avoid using the Resources folder in Unity include:\n• Increased memory usage and a bigger application size: as everything inside the Resources folder is packaged and loaded, whether you need it or not.\n• Assets are more difficult to manage: as using filename paths can make it more likely that a connection will be broken if a file name or string is changed.\n• Longer loading and startup time: as, if you’re using a large number of assets, the operation to load them all takes exponentially longer as more and more is added to the Resources folder. In extreme cases (think thousands of assets) this can add multiple seconds to the startup time of applications to load assets that are not initially required (source).\n\nSo, while more experienced developers will no doubt understand the risks of using this special folder, and will be able to work around issues like these easily, it’s worth knowing that the general advice is not to use the Resources folder wherever possible.\n\nIf the Resources folder isn’t recommended, then why does it exist? And what’s the right way to use it?\n\nWhen it’s OK to use the Resources folder\n\nAccording to Unity, there are a couple of use cases for which the Resources folder is particularly useful:\n• Prototyping – Where performance is less important than being able to rapidly create ideas. In this case, the flexibility of the Resources folder can be extremely helpful and outweighs the performance hit.\n• Minor Uses – Using relatively few assets, that are not memory intensive, and are unlikely to change between platforms is much less likely to cause you significant issues.\n\nGenerally speaking, if your game is small or performance is not (yet) critical to your project, then using the Resources folder isn’t necessarily a problem. For more information on what Unity considers to be best practice when using the Resources folder, see this tutorial.\n\nSo what can you do if you want to load a Sprite by its filename, without using the Resources folder?\n\nWell, what if I told you that there is an option that leverages the flexibility of the Resources folder but without the potential drawbacks.\n\nHow to load a Sprite from a script by filename (using Addressable Assets)\n\nThis method requires a little extra work to set up, but it allows you to load assets into a Scene with a filename and without the drawbacks of the Resources folder.\n\nWhat are Addressable Assets in Unity?\n\n“The Addressable Asset system provides an easy way to load assets by “address”. It handles asset management overhead by simplifying content pack creation and deployment. The Addressable Asset system uses asynchronous loading to support loading from any location with any collection of dependencies. Whether you use direct references, traditional asset bundles, or Resource folders for asset management, Addressable Assets provide a simpler way to make your game more dynamic.”\n\nHow to change a Sprite from a Sprite Sheet in scripting using Addressable Assets in Unity:\n• Select Window > Package Manager and install the Addressable Assets package from the Package Manager (this requires Unity 2018.3 or later).\n• Next select Window > Asset Management > Addressables > Groups to open the Addressables Groups Window.\n• Click the button labelled Create Addressable Settings, this will create a default Addressable Group.\n• In the Project Folder, select the Texture containing the Sprites you want to use and, in the Inspector, check the Addressable checkbox. This will reveal the asset’s Addressable Path, which you’ll need for the script.\n• The file should now have been added to the default Addressable Group.\n\n\n\nThe asset is now Addressable and can be accessed from a script without a reference.\n• How to use Addressable Assets in Unity\n\nUsing Addressable Assets after using the Resources folder\n\nIf you were already using the Resources folder, you may have noticed the Resources directory, and its files, in the Groups Window alongside the Addressable Group. If so, dragging those assets to the Addressable Group will automatically mark them Addressable and move them into a new folder for you (as they can’t stay in Resources for this to work).\n\nHow to fix the Invalid Key Exception Error when using Addressable Assets\n\nDepending on your version of Unity, the path that is assigned to the asset may continue to match the string that was being used for the Resources folder value (e.g. BirdHeroSprite, without a folder path or a file extension).\n\nHowever, if you’re getting an Invalid Key Exception error be sure to check that the Addressable Path (displayed next to the asset’s Addressable Checkbox) matches the value you’re using in the script.\n\nHow to access Addressable Sprite Assets from a Script\n\nNow that the Sprites are addressable it’s possible to load them from a script, without a reference. Here’s how to do it:\n\nFirst, add the following two namespaces to the top of the script. These are required for the Addressable features and loading operations to work properly.\n\nYou can add them below the existing namespace declarations, using UnityEngine etc.\n\nNext we need to load the Sprites from the Sprite Sheet, just as we did when using the Resources folder.\n\nThis happens in two steps:\n• First, load the Sprites using an asynchronous operation.\n• When that operation is completed, assign the result to the Sprite Array.\n\nIn scripting it looks like this:\n\nInstead of setting the contents of the array directly, what’s happening here is we’re starting a loading operation and creating a reference to it (the AsyncOperationHandle). Then when the loading is finished, we’re assigning the result to the Array, using the Handle reference to look up what was loaded.\n\nDoing it in this way allows time for the assets to load.\n\nRegistering the function LoadSpritesWhenReady to the spriteHandle.Completed event means that, as soon as the assets are finished loading, the function will be called and the Sprites will be assigned to the Array.\n\nWhile this part of the method could be done in several ways (inside a Coroutine for example), using an action like this avoids having to repeatedly check in Update, which would inefficient, especially since we know it’s only going to happen once.\n\nAlthough using Addressable Assets requires more work than simply dropping the Sprites into the Resources folder, it’s more efficient, and it’s a much more up to date solution when compared to using the Resources folder.\n\nA comprehensive guide of the Addressable Asset system is beyond the scope of this article but you can view the full Unity documentation here.\n\nNow that you’ve loaded the Sprites into the Array, it’s time to put them to good use.\n\nHow to change a Sprite from an array (3 examples)\n\nOnce the Sprites are assigned to the array, you can change the Sprite Renderer’s Sprite property using the same function as in the first example. Simply pass in the name of the array and the index of the Sprite.\n\nFor example, to switch to the first Sprite in the array would look like this in scripting:\n\nOr, if you want to switch to a random Sprite simply pass in a random number between zero and the length of the array. Like this:\n\nLastly, if you want to cycle through each sprite of the array, create an Integer variable to store the last Sprite index. Then increment it every time you change the Sprite:\n\nYou’ll notice in the example above that I’ve added an If Statement. This is to check if the index number has reached the end of the array. This is important as trying to retrieve a Sprite outside of the array’s range will result in an error."
    },
    {
        "link": "https://discussions.unity.com/t/how-to-create-a-2d-object-that-is-based-on-a-material-rather-than-a-sprite/903985",
        "document": ""
    }
]