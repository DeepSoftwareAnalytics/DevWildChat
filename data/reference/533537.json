[
    {
        "link": "https://stackoverflow.com/questions/12077007/c-dynamic-array-without-stl",
        "document": "The most basic form of dynamic array is one created using , and destroyed using :\n\nHowever, this brings the danger that the code using the array might throw an exception, return from the function, or otherwise prevent the from happening. If that happens, then you will lose the only pointer to the allocated memory, and it will remain allocated but inaccessible; this is known as a memory leak. For this reason, it's better to wrap the array in a class, with:\n• member variables to store a pointer to the array, and (optionally) its size\n\nDeleting the allocation in an object's destructor uses the principle of RAII to ensure that the array is deleted once it is no longer needed.\n\nThis leaves one more danger: if you copy this array object, then you will end up with two objects that both try to delete the same array, which is disasterous. To prevent this, you'll need to consider the Rule of Three. Either write a copy constructor and copy-assignment operator to allocate a new array and copy the contents; or delete them. (If you're learning old-fashioned C++, then you can't delete member functions, so you'll have to declare them private and not implement them instead).\n\nUsually, yes. But if you're learning C++, it's a good idea to understand how memory management works, as well as how to get the library to handle it for you. That's probably part of the point of this exercise."
    },
    {
        "link": "https://stackoverflow.com/questions/25474248/dynamic-array-without-new-c",
        "document": "I'm new to C++ and this is a very basic question.\n\nIn C++ there are only two ways to create dynamic arrays (read in a book, correct me if I'm wrong) using memory allocation either by operator or function which is taken from C.\n\nWhen declaring an array , the square brackets must have a .\n\nHowever in the following code is an variable.\n\nWhile compiling g++ throws no error and moreover the program runs perfectly.\n\nQuestion 1 : Could this be another way to create dynamic array?\n\nQuestion 3 : If can only contain , why does the code work?"
    },
    {
        "link": "https://geeksforgeeks.org/how-to-dynamically-allocate-an-array-in-cpp",
        "document": "How to Dynamically Allocate an Array in C++?\n\nIn C++, dynamic memory allocation allows us to allocate memory during runtime. Dynamic allocation in an array is particularly useful when the size of an array is not known at compile time and needs to be specified during runtime. In this article, we will learn how to dynamically allocate an array in C++.\n\nDynamic Allocation of Arrays in C++\n\nIn C++, we use the for . To allocate an dynamically,\n• None that will store the base address of the allocated array.\n• None Next, use the new operator to reserve memory space to accommodate an array of a particular data type.\n• None When making this allocation specify the size of the array that indicates how many elements it can contain. This specified size determines the amount of memory to be allocated.\n\nBelow is the general syntax for dynamically allocating an array in C++.\n• None is the type of data that we want to store in the array.\n• None is a keyword used for dynamic memory allocation.\n• None is the size of the array we want to allocate.\n\nC++ Program to Dynamically Allocate an Array\n\nThe below program demonstrates the dynamic array allocation in C++.\n\nTime Complexity: O(1)\n\nAuxilliary Space: O(n), where n is the size of the dynamically allocated array."
    },
    {
        "link": "https://reddit.com/r/cpp_questions/comments/zxs3fu/when_to_use_dynamic_memory_allocation",
        "document": "I notice that lots of std containers (e.g. vector) internally use a dynamically allocated array on the heap for storing elements. Initially, I don't get the motivations behind this design\n\nUnlike C, C++ does not support variable length arrays, so before creating any kind of object, the compiler first needs to figure out the size that is needed for that object, regardless of whether it is going to be allocated on heap or stack. Once an object is created, its memory is **fixed** and cannot be further enlarged\n\nAs a result, the only way to work around this is to dynamically allocate an array that allows the size to be determined at runtime\n\nSo is it a safe assertion to say that if we want to create any kind of data structure where the number of elements it can hold is not known ahead of time, ultimately we have to rely on some form of a dynamic array?\n\nI'm asking this because I was told that in modern C++ development dynamic memory allocation should be avoided at all costs. But I still think there must be some valid use cases"
    },
    {
        "link": "https://geeksforgeeks.org/new-and-delete-operators-in-cpp-for-dynamic-memory",
        "document": "Dynamic memory allocation in C/C++ refers to performing memory allocation manually by a programmer. Dynamically allocated memory is allocated on Heap, and non-static and local variables get memory allocated on Stack (Refer to Memory Layout C Programs for details).\n• None One use of dynamically allocated memory is to allocate memory of variable size, which is not possible with compiler allocated memory except for\n• None The most important use is the flexibility provided to programmers. We are free to allocate and deallocate memory whenever we need it and whenever we don’t need it anymore. There are many cases where this flexibility helps. Examples of such cases are\n\nHow is it different from memory allocated to normal variables?\n\nFor normal variables like “int a”, “char str[10]”, etc, memory is automatically allocated and deallocated. For dynamically allocated memory like “int *p = new int[10]”, it is the programmer’s responsibility to deallocate memory when no longer needed. If the programmer doesn’t deallocate memory, it causes a memory leak (memory is not deallocated until the program terminates).\n\nHow is memory allocated/deallocated in C++? \n\nC uses the malloc() and calloc() function to allocate memory dynamically at run time and uses a free() function to free dynamically allocated memory. C++ supports these functions and also has two operators new and delete, that perform the task of allocating and freeing the memory in a better and easier way.\n\nThe new operator denotes a request for memory allocation on the Free Store. If sufficient memory is available, a new operator initializes the memory and returns the address of the newly allocated and initialized memory to the pointer variable.\n\nSyntax to use new operator\n\nHere, the pointer variable is the pointer of type data-type. Data type could be any built-in data type including array or any user-defined data type including structure and class. \n\nExample:\n\nInitialize memory: We can also initialize the memory for built-in data types using a new operator. For custom data types, a constructor is required (with the data type as input) for initializing the value. Here’s an example of the initialization of both data types :\n\nAllocate a block of memory: a new operator is also used to allocate a block(an array) of memory of type data type.\n\nwhere size(a variable) specifies the number of elements in an array.\n\nDynamically allocates memory for 10 integers continuously of type int and returns a pointer to the first element of the sequence, which is assigned top(a pointer). p[0] refers to the first element, p[1] refers to the second element, and so on.\n\nNormal Array Declaration vs Using new \n\nThere is a difference between declaring a normal array and allocating a block of memory using new. The most important difference is, that normal arrays are deallocated by the compiler (If the array is local, then deallocated when the function returns or completes). However, dynamically allocated arrays always remain there until either they are deallocated by the programmer or the program terminates.\n\nWhat if enough memory is not available during runtime? \n\nIf enough memory is not available in the heap to allocate, the new request indicates failure by throwing an exception of type std::bad_alloc, unless “nothrow” is used with the new operator, in which case it returns a NULL pointer (scroll to section “Exception handling of new operator” in this article). Therefore, it may be a good idea to check for the pointer variable produced by the new before using its program.\n\nSince it is the programmer’s responsibility to deallocate dynamically allocated memory, programmers are provided delete operator in C++ language.\n\nHere, the pointer variable is the pointer that points to the data object created by new.\n\nTo free the dynamically allocated array pointed by pointer variable, use the following form of delete:\n\nTime Complexity: O(n), where n is the given memory size.\n• None Quiz on new and delete"
    },
    {
        "link": "https://stackoverflow.com/questions/26052653/how-to-generate-a-massive-amount-of-high-quality-random-numbers",
        "document": "I'm working on a random walk simulation of particles moving in a lattice. For that reason I must create a massive amount of random numbers, about 10^12 and above. Currently I'm using the possibilities C++11 provides with . When profiling my program, I see that a major amount of time is spent in . The vast majority of those numbers are between 0 and 1, evenly distributed. Here a then I need a number from a binomial distribution. But the focus lies on the 0..1 numbers.\n\nThe question is: What can I do to reduce the CPU time needed to generate these numbers and what would the impact be on their quality?\n\nAs you can see, I tried different engines, but that had no big effect on CPU time. Further, what is the difference between my and anyhow?\n\nEdit: Reading through the answers I conclude that there is not THE ideal solution for my problem. Thus I decided to first make my program multi threading capable and run multiple RNG in different threads (seeded with one random_device number + an thread individual increment). For the time being this seams to be the most unavoidable step (multi threading would be required anyhow). As a further step, pending on exact requirements I consider switching to the suggested Intel RNG or to Thrust. Meaning that my RNG implementation should not be to complex, which, currently is is not. But for now I like to focus on the physical correctness of my model and not on programming stuff, this comes as soon as the output of my program is physically correct. Thrust Concerning Intel RNG\n\nHere is what I do currently:"
    },
    {
        "link": "https://stackoverflow.com/questions/9471604/what-is-the-best-way-to-generate-random-numbers-in-c",
        "document": "If and only if:\n• None you are not looking for \"perfect uniformity\" or\n• None you have no C++11 support and not even TR1 (thus you don't have another choice)\n\nthen you might consider using the following C-style solution, which (for the sake of the reputation of this community ~ see rand() Considered Harmful) is written in strike-through font:\n\nHere's the simple C-style function that generates random number from the interval from to , inclusive. Those numbers seem to be very close to being uniformly distributed.\n\nand don't forget to call before you use it:\n\nAlso have a look at:\n\n Generate a random number within range?\n\n Generate random numbers uniformly over an entire range\n\n and find some time and watch at least first 11 minutes of aforementioned video\n\nuse just like it was pointed out by Kerrek SB already."
    },
    {
        "link": "https://reddit.com/r/learnprogramming/comments/gu43cc/c_best_practice_for_gettingusing_random_number",
        "document": "I fell down a rabbit hole...now my head hurts..looking for a little direction and clarification since there seems to be MANY ways to use different random generators and i would like to learn the best practice.\n\nFirst, in class i was taught to use\n\nWhich seems to work fine. But when looking up how to shuffle a vector i am across some post saying that, that is a old method and for modern c++ should start using the <random> library.\n\nand for the default_random_generator() iv come across two different method that seems to be suggested for seeding it.\n\n(this one i don't really understand which makes me hesitant to use, also involves bringing in a new library <chrono>\n\nwhich seems to be about the same as srand(time(0)) so maybe best to use for most cases..\n\nand for generating numbers within in a range i found i would use uniform_int_distribution\n\nso both these methods seem to produce the same result, is one considered better practice? Similarly\n\nfor shuffling a container (vector for ex) should i just use the simpler\n\nor shuffle, which requires bringing in and seeding a random generator\n\nLast question! I know globals are super taboo and iv never heard a good thing about them but, should i make my seed global if i am going to be using it in multiple functions ?\n\nthis got really long if anyone read this i want you to know i honestly greatly appreciate your time and patience!!!"
    },
    {
        "link": "https://codingnest.com/generating-random-numbers-using-c-standard-library-the-problems",
        "document": "Recently I found myself once again writing a long forum post about the problems with standard-provided random number generation facilities (both C++'s , and C's ) in C++. Since I keep writing these, I decided to write it all down into one blog post so that I can link it to people later. This is that blog post.\n\nA quick summary of this post would be \"Using C++'s standard library for random number generation is a bad idea, and you should either roll your own, or use an existing library. I recommend C++ PCG utilities, or, if you already use Boost, Boost.Random\".\n\nNow, onto the actual content itself.\n\nIn this post, we will use what should be a straightforward task: generate a bunch of uniformly distributed integers in the range [0, 100k).\n\nThis code is simple enough to write and to understand but comes with a host of problems.\n• The resulting numbers will not be uniformly distributed. The results will be biased towards lower numbers, due to the use of modulo.\n• Numbers above 32767 might not be present at all.\n• Whether the code is thread-safe is up to the implementation. Which functions invoke is also up to the implementation, so data races can happen without you expecting them.\n\nIf you do not see why converting the numbers using modulo cause non-uniformly distributed results, consider a simple case, where can only return 0, 1, or 2, each with the same probability, and we desire numbers in the range [0, 2). There are 2 ways to get 0, , and , while there is only one way to get 1, . In other words, we get 2:1 ratio of 0s to 1s due to using modulo.\n\nThe second problem is more obscure, but simpler to understand. The range of possible values generated by is specified as [0, ), where can be any constant larger-or-equal to 32767. On platforms that use this lower bound , the example above will never print number larger than 32767.\n\nThe last problem is just a symptom of the original C specification ignored threading.\n\nThe first two problems are solvable. Replacing modulo with rejection sampling (and potentially calling multiple times if needed) solves the bias issue. To generate values larger than , you can just concatenate the result of multiple calls to .\n\nThe thread-safety is impossible to solve in general case , but in specific cases, you can guard user code calls to with a mutex, and it should work well enough. Some implementations provide a per-thread , which is a much better solution, but you cannot rely on this.\n\nHowever, solving all of this is either impossible, or a lot of non-trivial work, and even then you run into the problem that is allowed to return different numbers on different platforms given the same seed. At this point, it is easier to write your own set of random number generation tools, and so C++11 standardized its own set, in the form of .\n\nAt first glance, seems exceedingly complex for a simple task. You have to pick a templated Uniform Random Bit Generator, possibly seed it, pick a templated Distribution, and then pass an instance of your URBG to the distribution to get a number... This is the C example rewritten using :\n\nThere is bit more code than there was with C, but bearably so, and most of the issues are fixed. The distribution will be uniform, all numbers in the desired interval are possible, and the code is thread-safe.\n\nAt second glance, is awesome, even if there is a bit of boilerplate for simple operations. The decomposed and pluggable design means that you can customize your random numbers by replacing only a small part of the random number generation pipeline. The standard also provides a wide range of Random Number Engines and distributions , so you should be able to do most things you want out of the box. It even provides an abstraction for getting actually random numbers for seeding the generators, .\n\nAt the third glance, when you've started using extensively and started digging deeper, you will find out that every single part of it is deeply flawed, and the best solution is to avoid using it completely.\n\nDid you notice that the text above said\n\nand then did not talk about portability? That's because both of the snippets, the C one and the C++ one, share one issue. Even if you hardcode the seed, the snippets will give you different results on different platforms . For bonus points, the results are not even guaranteed to be portable between different versions of the same standard library, as the standard library implementations are allowed to change how they implement .\n\nWhat this boils down to is that if you have repeatability requirements for your generated random numbers , then you cannot use the standard-provided distributions. Luckily, generating random numbers using is properly decomposed, and you can \"just\" write your own distributions, and keep using the rest of , right?\n\nmight not be random, and there is no way to check\n\nThe C++ snippet uses to generate some initial randomness to seed our instance of Mersenne Twister in the form of . The problem is that is poorly specified, and inscrutable.\n\nIn theory, it should serve as an abstraction over some external source of entropy. In practice, an implementation is allowed to use any deterministic random number engine to implement it, e.g. a Mersenne twister, and there is no way to find out. There is a member function , which is in theory there to detect such case, but it does not work in practice.\n\nThe blame for this is shared between the standard and the implementations. The function's full signature is , and it is the return type that breaks it. The standard provides a definition of entropy , but it does not provide any sort of guidance on how to count entropy of an external source of randomness, or expected return values for different cases.\n\nThis, in turn, caused different implementations to do their own thing. We will take a look at the big three, MS's STL, libc++ and libstdc++.\n\nMS's implementation handles this the best. It knows its is just a thin wrapper over kernel's cryptographically secure random, so it always returns 32 and inlines the member function into the header to allow for constant propagation .\n\nIn order of sanity of implementation, libc++ is next, because it always just returns 0. This return value does not reflect reality, 4 out of 5 possible configurations of libc++'s use strong random backend, and the last one also provides strong random bytes unless the user deliberately sabotages themselves. The return value also makes libc++'s implementation of useless, but at least it is obviously useless, so the user is not given false hopes and expectations. There is value in this.\n\nThe worst implementation of can be found in libstdc++. The reason it is the worst is that it is not obviously useless, you have to think about it for a bit to figure out why the return value is useless. This is because, unlike libc++, libstdc++ can return non-zero values. In most configurations, libstdc++ always returns 0 , but when it is configured to read from (or ), it uses to check how much entropy the kernel thinks it has available and returns that to the user.\n\nThe underlying problem of this approach is TOCTOU. If you first check whether there is enough randomness , and only then ask for that randomness, then by the time you ask for the randomness it could've been depleted, and you cannot get it anymore.\n\nAt this point, we know that we will likely have to implement our own distributions, and either implement our own , or detect which standard library we are compiling against, and hardcode versions that provide good implementations. But at least we can still use all the different Random Number Engines provided by the standard library, right?\n\nThere is no way to seed a Random Number Engine properly\n\nThe Random Number Engines almost work. But if something only almost works, it is broken.\n\nLet's go back to the first line of the C++ example.\n\nIt seeds a specific version of Mersenne Twister with worth of random data. Let's assume . The internal state of is 2496 (624 * 4) bytes. Taken together, this means that for every state we can seed the rng into, there are \\(2^{4984}\\) states that we cannot seed the rng into.\n\nThis has some interesting implications. For example, the program below will never print 7 .\n\nSome output values also uniquely identify their seed. If I tell you that the code program printed 3046098682, then you can quickly find the seed generated by , and thus predict all future outputs of a Mersenne twister seeded in this way .\n\nIn theory, the standard provides a way to seed the Mersenne twister properly. The tool is called SeedSequence, and there is an implementation of it in the standard library, . Once again, when you try to use it in practice, it breaks down.\n\nis essentially a wrapper over that you can give a bunch of randomness to, and then a random number engine can extract (stretched) randomness out. It is used like this:\n\nThis time we initialized our instance of with 16 (4 * 4) bytes of randomness. Progress! There are two problems with this snippet though:\n• There is no way to know how much randomness you have to provide to a RandomNumberEngine , and thus how much randomness you have to feed into .\n• is very tightly specified by the standard. The implementation forced by the standard is not a bijection .\n\nA fun fact about 1. is that provides a member variable you can query to find out how much data it needs . However, this is an accident of standardization, and no other standard-provided random number engine provides a way to retrieve this information.\n\nThe second problem means that even if you hardcode seed sizes of all random number engine types your program uses, you still couldn't use for initialization, because it loses entropy... here is an example of this on Godbolt:\n\nIn other words, even if you write your own type that fulfils the SeedSequence named requirements, you have to hardcode the sizes of your Random Number Engine types somewhere.\n\nTo recapitulate, generating random numbers using C standard library has many problems, with some fixable at great programming effort, and other unfixable. If you are for some reason stuck with just the C library, you should definitely write your own.\n\nGenerating random numbers using C++ standard library fixes most of the problems of using the C library. However, the operative word here is most, and it introduces its own problems instead. In the end, whether you can successfully use depends on your requirements.\n• If you need cross-platform reproducibility, then you cannot use standard-provided distributions at all, and you have to write your own.\n• If you need actually random data for whatever reason, you either have to write your own version of , or hardcode a list of platforms + configurations where you can use .\n• if you want to properly seed a Random Number Engine, you have to write your own SeedSequence, and also hardcode the required seed sizes of all your Random Number Engines.\n\nMy use cases for usually require cross-platform reproducibility, need properly random seed values, and would prefer fully seeded RNEs. This means that I either have to write 90% of on my own, or use a different implementation, such as Boost.Random or PCG random utilities...\n\nAnd I am not the only one. When I was writing a couple of standardization proposals for fixing , I made an informal Reddit poll asking people about their use of . The absolute majority of people answered either that they have their own implementation, or use Boost.Random. Few people used other open source libraries, and very, very, very few people use the standard random.\n\nThat's it for this post. The next post explores possible avenues for fixing and making it usable by more people in more domains."
    },
    {
        "link": "https://digitalocean.com/community/tutorials/random-number-generator-c-plus-plus",
        "document": "In this article, we’ll go over the functions needed to create a random number generator in C++. In the world of computers, random numbers form an essential component to add the flavor of anonymity and security.\n\nThe idea behind pseudo-random numbers is that a computer does not have a thinking process to select a random number. So even though an output number produced may seem random, the values are mathematically computed.\n\nThe srand() function in C++ can perform pseudo-random number calculation. This function requires a seed value which forms the basis of computation of random numbers.\n\nWith the help of the seed value, sets the stage for the generation of pseudo-random numbers by the function.\n\nAnd Voila! We have achieved the simple task of generating a random number. However, the hard part is to understand the concept behind the random number generators.\n\nThe seed value holds the key to the series of random numbers. The set of numbers calculated will be similar if the same seed value is provided to the function.\n\nThe default seed value for the function is , therefore a rand() function call without providing a fresh seed value will still fetch us a string of random numbers. The problem here is that every time you run the program with the seed value, the output will remain the same.\n\nA simple solution to our problem is using a fresh seed value each time we run the program. What changes every second? - Time. We used the concept of the current timestamp being the current seed value.\n\nYou can create a timestamp by using:\n\nThe variable holds the number of seconds passed since January, 1970. This value is passed to the function and then we get a fresh sequence of pseudo-random numbers.\n\nWe can skip the initialization of timestamp to a variable and simply pass the timestamp to the function.\n\nThe seed value is provided once in a program no matter how many random numbers are to be generated.\n\nCreate the Perfect Random Number Generator in C++\n\nThe following code demonstrates the proper generation of a random number.\n\nThe number generated is too huge for proper usage in normal calculations.\n\nThere is a need to restrict the random numbers within a certain range. For this specific purpose, we use the modulus operator.\n\nFor instance, in order to generate random numbers from 0 to 9, we can use:\n\nSimilarly, if we need to fetch random numbers from 1 to 9, we use:\n\nThe general equation can be stated as:\n\nIn the above equation:\n• offset - The starting point for the range of random numbers\n• range - The number of values between first and the last possible random number including the limits.\n\nFor instance, in a set of random numbers between 10 - 100, we have offset as 10 and range as 91.\n\nLet us run an example of a program that prints 5 random numbers between 100 and 200.\n\nTo clarify, if no seed value is provided, the output for the above program will be the same every time we run it. Even though the random numbers within the set are different, the complete set will be identical.\n\nThe power of random number generation may seem limited, but it is otherwise. Therefore, let us look at a few uses of RNGs.\n\nUnpredictability is considered a measure of security in the field of cryptography. Therefore, there is significant use of Random Number Generators such as keys and nonces.\n\nThe traditional games included dices and shuffling of cards to introduce randomness to the game, thereby, adding fun and uncertain results. Similarly, modern game development has a concept of pre- and post- randomness that adds an extra dimension to the game.\n\nIn these algorithms, there is a degree of randomness introduced to an already known algorithm. Most importantly, the purpose of these algorithms is to achieve better performance by trading-off the probability of success.\n\nThe RNGs or PRNGs (Pseudo-Random Number Generators) are the building blocks of modern cyber-security and cryptography. The basic principle of these RNGs lie in some computation providing different numbers, that seem random.\n\nWe hope this article was understandable to the reader. Feel free to comment below for any queries or suggestions."
    }
]