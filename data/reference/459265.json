[
    {
        "link": "https://docs.opencv.org/3.4/dc/da5/tutorial_py_drawing_functions.html",
        "document": "\n• Learn to draw different geometric shapes with OpenCV\n• You will learn these functions : cv.line(), cv.circle() , cv.rectangle(), cv.ellipse(), cv.putText() etc.\n\nIn all the above functions, you will see some common arguments as given below:\n• img : The image where you want to draw the shapes\n• color : Color of the shape. for BGR, pass it as a tuple, eg: (255,0,0) for blue. For grayscale, just pass the scalar value.\n• thickness : Thickness of the line or circle etc. If -1 is passed for closed figures like circles, it will fill the shape. default thickness = 1\n• lineType : Type of line, whether 8-connected, anti-aliased line etc. By default, it is 8-connected. cv.LINE_AA gives anti-aliased line which looks great for curves.\n\nTo draw a line, you need to pass starting and ending coordinates of line. We will create a black image and draw a blue line on it from top-left to bottom-right corners.\n\nTo draw a rectangle, you need top-left corner and bottom-right corner of rectangle. This time we will draw a green rectangle at the top-right corner of image.\n\nTo draw a circle, you need its center coordinates and radius. We will draw a circle inside the rectangle drawn above.\n\nTo draw the ellipse, we need to pass several arguments. One argument is the center location (x,y). Next argument is axes lengths (major axis length, minor axis length). angle is the angle of rotation of ellipse in anti-clockwise direction. startAngle and endAngle denotes the starting and ending of ellipse arc measured in clockwise direction from major axis. i.e. giving values 0 and 360 gives the full ellipse. For more details, check the documentation of cv.ellipse(). Below example draws a half ellipse at the center of the image.\n\nTo draw a polygon, first you need coordinates of vertices. Make those points into an array of shape ROWSx1x2 where ROWS are number of vertices and it should be of type int32. Here we draw a small polygon of with four vertices in yellow color.\n\nTo put texts in images, you need specify following things.\n• Text data that you want to write\n• Position coordinates of where you want put it (i.e. bottom-left corner where data starts).\n• regular things like color, thickness, lineType etc. For better look, lineType = cv.LINE_AA is recommended.\n\nWe will write OpenCV on our image in white color.\n\nSo it is time to see the final result of our drawing. As you studied in previous articles, display the image to see it.\n• The angles used in ellipse function is not our circular angles. For more details, visit this discussion.\n• Try to create the logo of OpenCV using drawing functions available in OpenCV."
    },
    {
        "link": "https://docs.opencv.org/4.x/dc/da5/tutorial_py_drawing_functions.html",
        "document": "\n• Learn to draw different geometric shapes with OpenCV\n• You will learn these functions : cv.line(), cv.circle() , cv.rectangle(), cv.ellipse(), cv.putText() etc.\n\nIn all the above functions, you will see some common arguments as given below:\n• img : The image where you want to draw the shapes\n• color : Color of the shape. for BGR, pass it as a tuple, eg: (255,0,0) for blue. For grayscale, just pass the scalar value.\n• thickness : Thickness of the line or circle etc. If -1 is passed for closed figures like circles, it will fill the shape. default thickness = 1\n• lineType : Type of line, whether 8-connected, anti-aliased line etc. By default, it is 8-connected. cv.LINE_AA gives anti-aliased line which looks great for curves.\n\nTo draw a line, you need to pass starting and ending coordinates of line. We will create a black image and draw a blue line on it from top-left to bottom-right corners.\n\nTo draw a rectangle, you need top-left corner and bottom-right corner of rectangle. This time we will draw a green rectangle at the top-right corner of image.\n\nTo draw a circle, you need its center coordinates and radius. We will draw a circle inside the rectangle drawn above.\n\nTo draw the ellipse, we need to pass several arguments. One argument is the center location (x,y). Next argument is axes lengths (major axis length, minor axis length). angle is the angle of rotation of ellipse in anti-clockwise direction. startAngle and endAngle denotes the starting and ending of ellipse arc measured in clockwise direction from major axis. i.e. giving values 0 and 360 gives the full ellipse. For more details, check the documentation of cv.ellipse(). Below example draws a half ellipse at the center of the image.\n\nTo draw a polygon, first you need coordinates of vertices. Make those points into an array of shape ROWSx1x2 where ROWS are number of vertices and it should be of type int32. Here we draw a small polygon of with four vertices in yellow color.\n\nTo put texts in images, you need specify following things.\n• Text data that you want to write\n• Position coordinates of where you want put it (i.e. bottom-left corner where data starts).\n• regular things like color, thickness, lineType etc. For better look, lineType = cv.LINE_AA is recommended.\n\nWe will write OpenCV on our image in white color.\n\nSo it is time to see the final result of our drawing. As you studied in previous articles, display the image to see it.\n• The angles used in ellipse function is not our circular angles. For more details, visit this discussion.\n• Try to create the logo of OpenCV using drawing functions available in OpenCV."
    },
    {
        "link": "https://stackoverflow.com/questions/18632276/how-to-draw-a-line-on-an-image-in-opencv",
        "document": "If I have the polar coordinates of a line, how can I draw it on an image in OpenCV & python?\n\nfunction takes 2 points, but draws only the segment. I want to draw a line from one edge of the image to other."
    },
    {
        "link": "https://geeksforgeeks.org/python-opencv-cv2-line-method",
        "document": ""
    },
    {
        "link": "https://docs.opencv.org/4.x/d6/d6e/group__imgproc__draw.html",
        "document": "Drawing functions work with matrices/images of arbitrary depth. The boundaries of the shapes can be rendered with antialiasing (implemented only for 8-bit images for now). All the functions include the parameter color that uses an RGB value (that may be constructed with the Scalar constructor ) for color images and brightness for grayscale images. For color images, the channel ordering is normally Blue, Green, Red. This is what imshow, imread, and imwrite expect. So, if you form a color using the Scalar constructor, it should look like:\n\nIf you are using your own image rendering and I/O functions, you can use any channel ordering. The drawing functions process each channel independently and do not depend on the channel order or even on the used color space. The whole image can be converted from BGR to RGB or to a different color space using cvtColor .\n\nIf a drawn figure is partially or completely outside the image, the drawing functions clip it. Also, many drawing functions can handle pixel coordinates specified with sub-pixel accuracy. This means that the coordinates can be passed as fixed-point numbers encoded as integers. The number of fractional bits is specified by the shift parameter and the real point coordinates are calculated as \\(\\texttt{Point}(x,y)\\rightarrow\\texttt{Point2f}(x*2^{-shift},y*2^{-shift})\\) . This feature is especially effective when rendering antialiased shapes.\n\nDraws a simple or thick elliptic arc or fills an ellipse sector. The function cv::ellipse with more parameters draws an ellipse outline, a filled ellipse, an elliptic arc, or a filled ellipse sector. The drawing code uses general parametric form. A piecewise-linear curve is used to approximate the elliptic arc boundary. If you need more control of the ellipse rendering, you can retrieve the curve using ellipse2Poly and then render it with polylines or fill it with fillPoly. If you use the first variant of the function and want to draw the whole ellipse, not an arc, pass and . If is greater than , they are swapped. The figure below explains the meaning of the parameters to draw the blue arc. Half of the size of the ellipse main axes. Starting angle of the elliptic arc in degrees. Ending angle of the elliptic arc in degrees. Thickness of the ellipse arc outline, if positive. Otherwise, this indicates that a filled ellipse sector is to be drawn. Type of the ellipse boundary. See LineTypes Number of fractional bits in the coordinates of the center and values of axes."
    },
    {
        "link": "https://scipy-lectures.org/advanced/image_processing",
        "document": "2.6. Image manipulation and processing using Numpy and Scipy¶\n\nThis section addresses basic image manipulation and processing using the core scientific modules NumPy and SciPy. Some of the operations covered by this tutorial may be useful for other kinds of multidimensional array processing than image processing. In particular, the submodule provides functions operating on n-dimensional NumPy arrays.\n\nTools used in this tutorial:\n• None : submodule dedicated to image processing (n-dimensional images). See the documentation:\n• Image segmentation: labeling pixels corresponding to different objects\n\n# First we need to create the PNG file Need to know the shape and dtype of the image (how to separate data bytes). For large data, use for memory mapping:\n\nLocal filters: replace the value of pixels by a function of the values of neighboring pixels. increase the weight of edges by adding an approximation of the Laplacian: A Gaussian filter smoothes the noise out… and the edges as well:\n• Create a binary image (of 0s and 1s) with several objects (circles, ellipses, squares, or random shapes).\n• Try two different denoising methods for denoising the image: gaussian filtering and median filtering.\n• Compare the histograms of the two different denoised images. Which one is the closest to the histogram of the original (noise-free) image? More denoising filters are available in , see the Scikit-image: image processing tutorial. See wikipedia for a definition of mathematical morphology. Probe an image with a simple shape (a structuring element), and modify this image according to how the shape locally fits or misses the image. Erosion = minimum filter. Replace the value of a pixel by the minimal value covered by the structuring element.: Many other mathematical morphology operations: hit and miss transform, tophat, etc.\n\nUse mathematical morphology to clean up the result: Check that reconstruction operations (erosion + propagation) produce a better result than opening/closing: Check how a first denoising step (e.g. with a median filter) modifies the histogram, and check that the resulting histogram-based segmentation is more accurate. More advanced segmentation algorithms are found in the : see Scikit-image: image processing. Other Scientific Packages provide algorithms that can be useful for image processing. In this example, we use the spectral clustering function of the in order to segment glued objects. # Convert the image into a graph with the value of the gradient on # Take a decreasing function of the gradient: we take it weakly # dependant from the gradient the segmentation is close to a voronoi\n\nCompute size, mean_value, etc. of each region: Can be used outside the limited scope of segmentation applications. # note that we use broadcasting When regions are regular blocks, it is more efficient to use stride tricks (Example: fake dimensions with strides). One example with mathematical morphology: granulometry"
    },
    {
        "link": "https://numpy.org/doc/2.2/user/basics.creation.html",
        "document": "NumPy arrays can be defined using Python sequences such as lists and tuples. Lists and tuples are defined using and , respectively. Lists and tuples can define ndarray creation:\n• None further nested lists will create higher-dimensional arrays. In general, any array object is called an ndarray in NumPy. When you use to define a new array, you should consider the dtype of the elements in the array, which can be specified explicitly. This feature gives you more control over the underlying data structures and how the elements are handled in C/C++ functions. When values do not fit and you are using a , NumPy may raise an error: : Python integer 128 out of bounds for int8 An 8-bit signed integer represents integers from -128 to 127. Assigning the array to integers outside of this range results in overflow. This feature can often be misunderstood. If you perform calculations with mismatching , you can get unwanted results, for example: Notice when you perform operations with two arrays of the same : , the resulting array is the same type. When you perform operations with different , NumPy will assign a new type that satisfies all of the array elements involved in the computation, here and can both be represented in as . The default NumPy behavior is to create arrays in either 32 or 64-bit signed integers (platform dependent and matches C size) or double precision floating point numbers. If you expect your integer arrays to be a specific type, then you need to specify the dtype while you create the array.\n\nNumPy has over 40 built-in functions for creating arrays as laid out in the Array creation routines. These functions can be split into roughly three categories, based on the dimension of the array they create: The 1D array creation functions e.g. and generally need at least two inputs, and . creates arrays with regularly incrementing values. Check the documentation for complete information and examples. A few examples are shown: Note: best practice for is to use integer start, end, and step values. There are some subtleties regarding . In the second example, the is defined. In the third example, the array is to accommodate the step size of . Due to roundoff error, the value is sometimes included. will create arrays with a specified number of elements, and spaced equally between the specified beginning and end values. For example: The advantage of this creation function is that you guarantee the number of elements and the starting and end point. The previous will not include the value . The 2D array creation functions e.g. , , and define properties of special matrices represented as 2D arrays. defines a 2D identity matrix. The elements where i=j (row index and column index are equal) are 1 and the rest are 0, as such: can define either a square 2D array with given values along the diagonal or if given a 2D array returns a 1D array that is only the diagonal elements. The two array creation functions can be helpful while doing linear algebra, as such: defines a Vandermonde matrix as a 2D NumPy array. Each column of the Vandermonde matrix is a decreasing power of the input 1D array or list or tuple, where the highest polynomial order is . This array creation routine is helpful in generating linear least squares models, as such: The ndarray creation functions e.g. , , and define arrays based upon the desired shape. The ndarray creation functions can create arrays with any dimension by specifying how many dimensions and length along that dimension in a tuple or list. will create an array filled with 0 values with the specified shape. The default dtype is : will create an array filled with 1 values. It is identical to in all other respects as such: The method of the result of will create an array filled with random values between 0 and 1. It is included with the library. Below, two arrays are created with shapes (2,3) and (2,3,2), respectively. The seed is set to 42 so you can reproduce these pseudorandom numbers: will create a set of arrays (stacked as a one-higher dimensioned array), one per dimension with each representing variation in that dimension: This is particularly useful for evaluating functions of multiple dimensions on a regular grid.\n\nOnce you have created arrays, you can replicate, join, or mutate those existing arrays to create new arrays. When you assign an array or its elements to a new variable, you have to explicitly the array, otherwise the variable is a view into the original array. Consider the following example: In this example, you did not create a new array. You created a variable, that viewed the first 2 elements of . When you added 1 to you would get the same result by adding 1 to . If you want to create a new array, use the array creation routine as such: For more information and examples look at Copies and Views. There are a number of routines to join existing arrays e.g. , , and . Here is an example of joining four 2-by-2 arrays into a 4-by-4 array using : Other routines use similar syntax to join ndarrays. Check the routine’s documentation for further examples and syntax.\n\n4) Reading arrays from disk, either from standard or custom formats# This is the most common case of large array creation. The details depend greatly on the format of data on disk. This section gives general pointers on how to handle various formats. For more detailed examples of IO look at How to Read and Write files. Various fields have standard formats for array data. The following lists the ones with known Python libraries to read them and return NumPy arrays (there may be others for which it is possible to read and convert to NumPy arrays so check the last section as well) Examples of formats that cannot be read directly but for which it is not hard to convert are those formats supported by libraries like PIL (able to read and write many image formats such as jpg, png, etc). Delimited files such as comma separated value (csv) and tab separated value (tsv) files are used for programs like Excel and LabView. Python functions can read and parse these files line-by-line. NumPy has two standard routines for importing a file with delimited data and . These functions have more involved use cases in Reading and writing files. A simple example given a : More generic ASCII files can be read using and Pandas."
    },
    {
        "link": "https://numpy.org/devdocs/user/basics.creation.html",
        "document": "NumPy arrays can be defined using Python sequences such as lists and tuples. Lists and tuples are defined using and , respectively. Lists and tuples can define ndarray creation:\n• None further nested lists will create higher-dimensional arrays. In general, any array object is called an ndarray in NumPy. When you use to define a new array, you should consider the dtype of the elements in the array, which can be specified explicitly. This feature gives you more control over the underlying data structures and how the elements are handled in C/C++ functions. When values do not fit and you are using a , NumPy may raise an error: : Python integer 128 out of bounds for int8 An 8-bit signed integer represents integers from -128 to 127. Assigning the array to integers outside of this range results in overflow. This feature can often be misunderstood. If you perform calculations with mismatching , you can get unwanted results, for example: Notice when you perform operations with two arrays of the same : , the resulting array is the same type. When you perform operations with different , NumPy will assign a new type that satisfies all of the array elements involved in the computation, here and can both be represented in as . The default NumPy behavior is to create arrays in either 32 or 64-bit signed integers (platform dependent and matches C size) or double precision floating point numbers. If you expect your integer arrays to be a specific type, then you need to specify the dtype while you create the array.\n\nNumPy has over 40 built-in functions for creating arrays as laid out in the Array creation routines. These functions can be split into roughly three categories, based on the dimension of the array they create: The 1D array creation functions e.g. and generally need at least two inputs, and . creates arrays with regularly incrementing values. Check the documentation for complete information and examples. A few examples are shown: Note: best practice for is to use integer start, end, and step values. There are some subtleties regarding . In the second example, the is defined. In the third example, the array is to accommodate the step size of . Due to roundoff error, the value is sometimes included. will create arrays with a specified number of elements, and spaced equally between the specified beginning and end values. For example: The advantage of this creation function is that you guarantee the number of elements and the starting and end point. The previous will not include the value . The 2D array creation functions e.g. , , and define properties of special matrices represented as 2D arrays. defines a 2D identity matrix. The elements where i=j (row index and column index are equal) are 1 and the rest are 0, as such: can define either a square 2D array with given values along the diagonal or if given a 2D array returns a 1D array that is only the diagonal elements. The two array creation functions can be helpful while doing linear algebra, as such: defines a Vandermonde matrix as a 2D NumPy array. Each column of the Vandermonde matrix is a decreasing power of the input 1D array or list or tuple, where the highest polynomial order is . This array creation routine is helpful in generating linear least squares models, as such: The ndarray creation functions e.g. , , and define arrays based upon the desired shape. The ndarray creation functions can create arrays with any dimension by specifying how many dimensions and length along that dimension in a tuple or list. will create an array filled with 0 values with the specified shape. The default dtype is : will create an array filled with 1 values. It is identical to in all other respects as such: The method of the result of will create an array filled with random values between 0 and 1. It is included with the library. Below, two arrays are created with shapes (2,3) and (2,3,2), respectively. The seed is set to 42 so you can reproduce these pseudorandom numbers: will create a set of arrays (stacked as a one-higher dimensioned array), one per dimension with each representing variation in that dimension: This is particularly useful for evaluating functions of multiple dimensions on a regular grid.\n\nOnce you have created arrays, you can replicate, join, or mutate those existing arrays to create new arrays. When you assign an array or its elements to a new variable, you have to explicitly the array, otherwise the variable is a view into the original array. Consider the following example: In this example, you did not create a new array. You created a variable, that viewed the first 2 elements of . When you added 1 to you would get the same result by adding 1 to . If you want to create a new array, use the array creation routine as such: For more information and examples look at Copies and Views. There are a number of routines to join existing arrays e.g. , , and . Here is an example of joining four 2-by-2 arrays into a 4-by-4 array using : Other routines use similar syntax to join ndarrays. Check the routine’s documentation for further examples and syntax.\n\n4) Reading arrays from disk, either from standard or custom formats# This is the most common case of large array creation. The details depend greatly on the format of data on disk. This section gives general pointers on how to handle various formats. For more detailed examples of IO look at How to Read and Write files. Various fields have standard formats for array data. The following lists the ones with known Python libraries to read them and return NumPy arrays (there may be others for which it is possible to read and convert to NumPy arrays so check the last section as well) Examples of formats that cannot be read directly but for which it is not hard to convert are those formats supported by libraries like PIL (able to read and write many image formats such as jpg, png, etc). Delimited files such as comma separated value (csv) and tab separated value (tsv) files are used for programs like Excel and LabView. Python functions can read and parse these files line-by-line. NumPy has two standard routines for importing a file with delimited data and . These functions have more involved use cases in Reading and writing files. A simple example given a : More generic ASCII files can be read using and Pandas."
    },
    {
        "link": "https://geeksforgeeks.org/image-processing-with-scipy-and-numpy-in-python",
        "document": "In this tutorial, we will discuss Image Processing in Python using the core scientific modules like NumPy and SciPy. The images are made up of NumPy ndarrays so we can process and manipulate images and SciPy provides the submodule scipy.ndimage that provides functions that can operate on the NumPy arrays.\n\nWe will discuss how to open and write to images, and will also cover different manipulation and filtering techniques. So before getting started let’s see how to install both modules.\n\nNumpy: To install numpy type the below command in the terminal.\n\nSciPy: You can use the above command to install SciPy as well.\n\nThe misc package of SciPy comes with some preloaded images. We will use those images to learn about image processing. One such image is provided by the face() function. The face() function will get a colored image of a raccoon face.\n\nExample: Creating NumPy array from the image\n\nHere we will read the image using the imread() function.\n\nA RAW file is a file containing minimally processed data from an image sensor. We can create this file using the tofile() method of the scipy package.\n\nThis will create a .raw file in our current working directory.\n\nFor opening .raw file we will be needing the NumPy module that will use the fromfile() method. This function is an efficient way of reading binary data with known data type as well as parsing simply formatted text.\n\nExample: Reading from RAW file using NumPy\n\nWe can use the max() and min() functions to get the maximum and minimum along the given axis. And to find the mean we can use the mean() function.\n\nExample: Getting min, max, and mean values\n\nAs we know that images are represented by numbers in a matrix, so changing the value of the matrix will result in changing the original image. Let’s see how to use this idea for cropping the image.\n\nWe can use the flipud() function of the numpy module to flip that image. This function flips the array(entries in each column) in up-down direction, shape preserved.\n\nTo rotate the images we can use the ndarray.rotate() function. This function rotates the image at a specific angle.\n\nExample: Rotate Image using SciPy and NumPy\n\nIn simpler terms image filtering is a process for enhancing or modifying an image where we can increase sharpness, enhance edges, or blurs the image. In Image filtering, some algorithm is applied to the pixel value of the given image and that algorithm determines the value of the output image. Let’s see some image filtering operations that can be done using NumPy and SciPy.\n\nBlurring an image is a process of reducing the level of noise in the image. For this, we can either use a Gaussian filter or a unicorn filter.\n\nExample: Blur Images using SciPy and NumPy\n\nSharpening refers to increase contrast b/w light and dark regions and make the image more defined and brings out image features. There are three main reasons to sharpen your image: to overcome blurring introduced by camera equipment, to draw attention to certain areas, and to increase legibility. If blurry text is present in the image it becomes easy to read.\n\nExample: Sharpening images using NumPy and SciPy\n\nDenoising of an image refers to the process of reconstruction of a signal from noisy images. Denoising is done to remove unwanted noise from image to analyze it in better form. At first, let’s create a noisy image –\n\nTo smooth the edges and the noise we use the Gaussian filter.\n\nWe can also preserve the edges using the median filter.\n\nThe process of image detection involves detecting edges in the image. It works by detecting discontinuities in the brightness. For high-intensity variations, we can use Sobel, a gradient operator-\n\nExample: Edge detection using SciPy and NumPy"
    },
    {
        "link": "https://numpy.org/doc/2.2/user/absolute_beginners.html",
        "document": "Welcome to the absolute beginner’s guide to NumPy!\n\nNumPy (Numerical Python) is an open source Python library that’s widely used in science and engineering. The NumPy library contains multidimensional array data structures, such as the homogeneous, N-dimensional , and a large library of functions that operate efficiently on these data structures. Learn more about NumPy at What is NumPy, and if you have comments or suggestions, please reach out!\n\nOne way to initialize an array is using a Python sequence, such as a list. For example: Elements of an array can be accessed in various ways. For instance, we can access an individual element of this array as we would access an element in the original list: using the integer index of the element within square brackets. As with built-in Python sequences, NumPy arrays are “0-indexed”: the first element of the array is accessed using index , not . Like the original list, the array is mutable. Also like the original list, Python slice notation can be used for indexing. One major difference is that slice indexing of a list copies the elements into a new list, but slicing an array returns a view: an object that refers to the data in the original array. The original array can be mutated using the view. See Copies and views for a more comprehensive explanation of when array operations return views rather than copies. Two- and higher-dimensional arrays can be initialized from nested Python sequences: In NumPy, a dimension of an array is sometimes referred to as an “axis”. This terminology may be useful to disambiguate between the dimensionality of an array and the dimensionality of the data represented by the array. For instance, the array could represent three points, each lying within a four-dimensional space, but has only two “axes”. Another difference between an array and a list of lists is that an element of the array can be accessed by specifying the index along each axis within a single set of square brackets, separated by commas. For instance, the element is in row and column : It is familiar practice in mathematics to refer to elements of a matrix by the row index first and the column index second. This happens to be true for two-dimensional arrays, but a better mental model is to think of the column index as coming last and the row index as second to last. This generalizes to arrays with any number of dimensions. You might hear of a 0-D (zero-dimensional) array referred to as a “scalar”, a 1-D (one-dimensional) array as a “vector”, a 2-D (two-dimensional) array as a “matrix”, or an N-D (N-dimensional, where “N” is typically an integer greater than 2) array as a “tensor”. For clarity, it is best to avoid the mathematical terms when referring to an array because the mathematical objects with these names behave differently than arrays (e.g. “matrix” multiplication is fundamentally different from “array” multiplication), and there are other objects in the scientific Python ecosystem that have these names (e.g. the fundamental data structure of PyTorch is the “tensor”).\n\nCan you reshape an array?# Using will give a new shape to an array without changing the data. Just remember that when you use the reshape method, the array you want to produce needs to have the same number of elements as the original array. If you start with an array with 12 elements, you’ll need to make sure that your new array also has a total of 12 elements. If you start with this array: You can use to reshape your array. For example, you can reshape this array to an array with three rows and two columns: With , you can specify a few optional parameters: is the array to be reshaped. is the new shape you want. You can specify an integer or a tuple of integers. If you specify an integer, the result will be an array of that length. The shape should be compatible with the original shape. means to read/write the elements using C-like index order, means to read/write the elements using Fortran-like index order, means to read/write the elements in Fortran-like index order if a is Fortran contiguous in memory, C-like order otherwise. (This is an optional parameter and doesn’t need to be specified.) If you want to learn more about C and Fortran order, you can read more about the internal organization of NumPy arrays here. Essentially, C and Fortran orders have to do with how indices correspond to the order the array is stored in memory. In Fortran, when moving through the elements of a two-dimensional array as it is stored in memory, the first index is the most rapidly varying index. As the first index moves to the next row as it changes, the matrix is stored one column at a time. This is why Fortran is thought of as a Column-major language. In C on the other hand, the last index changes the most rapidly. The matrix is stored by rows, making it a Row-major language. What you do for C or Fortran depends on whether it’s more important to preserve the indexing convention or not reorder the data. Learn more about shape manipulation here.\n\nYou can index and slice NumPy arrays in the same ways you can slice Python lists. You can visualize it this way: You may want to take a section of your array or specific array elements to use in further analysis or additional operations. To do that, you’ll need to subset, slice, and/or index your arrays. If you want to select values from your array that fulfill certain conditions, it’s straightforward with NumPy. For example, if you start with this array: You can easily print all of the values in the array that are less than 5. You can also select, for example, numbers that are equal to or greater than 5, and use that condition to index an array. You can select elements that are divisible by 2: Or you can select elements that satisfy two conditions using the and operators: You can also make use of the logical operators & and | in order to return boolean values that specify whether or not the values in an array fulfill a certain condition. This can be useful with arrays that contain names or other categorical values. You can also use to select elements or indices from an array. You can use to print the indices of elements that are, for example, less than 5: In this example, a tuple of arrays was returned: one for each dimension. The first array represents the row indices where these values are found, and the second array represents the column indices where the values are found. If you want to generate a list of coordinates where the elements exist, you can zip the arrays, iterate over the list of coordinates, and print them. For example: You can also use to print the elements in an array that are less than 5 with: If the element you’re looking for doesn’t exist in the array, then the returned array of indices will be empty. For example: Learn more about indexing and slicing here and here. Read more about using the nonzero function at: .\n\nHow to create an array from existing data# You can easily create a new array from a section of an existing array. Let’s say you have this array: You can create a new array from a section of your array any time by specifying where you want to slice your array. Here, you grabbed a section of your array from index position 3 through index position 8 but not including position 8 itself. Reminder: Array indexes begin at 0. This means the first element of the array is at index 0, the second element is at index 1, and so on. You can also stack two existing arrays, both vertically and horizontally. Let’s say you have two arrays, and : You can stack them vertically with : Or stack them horizontally with : You can split an array into several smaller arrays using . You can specify either the number of equally shaped arrays to return or the columns after which the division should occur. Let’s say you have this array: If you wanted to split this array into three equally shaped arrays, you would run: If you wanted to split your array after the third and fourth column, you’d run: Learn more about stacking and splitting arrays here. You can use the method to create a new array object that looks at the same data as the original array (a shallow copy). Views are an important NumPy concept! NumPy functions, as well as operations like indexing and slicing, will return views whenever possible. This saves memory and is faster (no copy of the data has to be made). However it’s important to be aware of this - modifying data in a view also modifies the original array! Let’s say you create this array: Now we create an array by slicing and modify the first element of . This will modify the corresponding element in as well! Using the method will make a complete copy of the array and its data (a deep copy). To use this on your array, you could run: Learn more about copies and views here.\n\nHow to access the docstring for more information# When it comes to the data science ecosystem, Python and NumPy are built with the user in mind. One of the best examples of this is the built-in access to documentation. Every object contains the reference to a string, which is known as the docstring. In most cases, this docstring contains a quick and concise summary of the object and how to use it. Python has a built-in function that can help you access this information. This means that nearly any time you need more information, you can use to quickly find the information that you need. Help on built-in function max in module builtins: With a single iterable argument, return its biggest item. The default keyword-only argument specifies an object to return if With two or more arguments, return the largest argument. Because access to additional information is so useful, IPython uses the character as a shorthand for accessing this documentation along with other relevant information. IPython is a command shell for interactive computing in multiple languages. You can find more information about IPython here. max With a single iterable argument, return its biggest item. The default keyword-only argument specifies an object to return if With two or more arguments, return the largest argument. You can even use this notation for object methods and objects themselves. Let’s say you create this array: Then you can obtain a lot of useful information (first details about itself, followed by the docstring of of which is an instance): a of fixed-size items. An associated data-type object describes the format of each element in the array (its byte-order, how many bytes it occupies in memory, whether it is an integer, a floating point number, Arrays should be constructed using `array`, `zeros` or `empty` (refer to the See Also section below). The parameters given here refer to For more information, refer to the `numpy` module and examine the methods and attributes of an array. This also works for functions and other objects that you create. Just remember to include a docstring with your function using a string literal ( or around your documentation). For example, if you create this function: You can obtain information about the function: You can reach another level of information by reading the source code of the object you’re interested in. Using a double question mark ( ) allows you to access the source code. If the object in question is compiled in a language other than Python, using will return the same information as . You’ll find this with a lot of built-in objects and types, for example: len Docstring: Return the number of items in a container. len Docstring: Return the number of items in a container. have the same output because they were compiled in a programming language other than Python.\n\nHow to save and load NumPy objects# You will, at some point, want to save your arrays to disk and load them back without having to re-run the code. Fortunately, there are several ways to save and load objects with NumPy. The ndarray objects can be saved to and loaded from the disk files with and functions that handle normal text files, and functions that handle NumPy binary files with a .npy file extension, and a function that handles NumPy files with a .npz file extension. The .npy and .npz files store data, shape, dtype, and other information required to reconstruct the ndarray in a way that allows the array to be correctly retrieved, even when the file is on another machine with different architecture. If you want to store a single ndarray object, store it as a .npy file using . If you want to store more than one ndarray object in a single file, save it as a .npz file using . You can also save several arrays into a single file in compressed npz format with . It’s easy to save and load an array with . Just make sure to specify the array you want to save and a file name. For example, if you create this array: You can save it as “filename.npy” with: You can use to reconstruct your array. If you want to check your array, you can run: You can save a NumPy array as a plain text file like a .csv or .txt file with . For example, if you create this array: You can easily save it as a .csv file with the name “new_file.csv” like this: You can quickly and easily load your saved text file using : The and functions accept additional optional parameters such as header, footer, and delimiter. While text files can be easier for sharing, .npy and .npz files are smaller and faster to read. If you need more sophisticated handling of your text file (for example, if you need to work with lines that contain missing values), you will want to use the function. With , you can specify headers, footers, comments, and more. Learn more about input and output routines here."
    }
]