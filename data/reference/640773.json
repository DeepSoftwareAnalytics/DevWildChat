[
    {
        "link": "https://geeksforgeeks.org/stack-in-python",
        "document": "A stack is a linear data structure that stores items in a Last-In/First-Out (LIFO) or First-In/Last-Out (FILO) manner. In stack, a new element is added at one end and an element is removed from that end only. The insert and delete operations are often called push and pop.\n\nThe functions associated with stack are:\n• empty() – Returns whether the stack is empty – Time Complexity: O(1)\n• size() – Returns the size of the stack – Time Complexity: O(1)\n• top() / peek() – Returns a reference to the topmost element of the stack – Time Complexity: O(1)\n• push(a) – Inserts the element ‘a’ at the top of the stack – Time Complexity: O(1)\n• pop() – Deletes the topmost element of the stack – Time Complexity: O(1)\n\nThere are various ways from which a stack can be implemented in Python. This article covers the implementation of a stack using data structures and modules from the Python library. \n\nStack in Python can be implemented using the following ways:\n\nPython’s built-in data structure list can be used as a stack. Instead of push(), append() is used to add elements to the top of the stack while pop() removes the element in LIFO order. \n\nUnfortunately, the list has a few shortcomings. The biggest issue is that it can run into speed issues as it grows. The items in the list are stored next to each other in memory, if the stack grows bigger than the block of memory that currently holds it, then Python needs to do some memory allocations. This can lead to some append() calls taking much longer than other ones.\n\nPython stack can be implemented using the deque class from the collections module. Deque is preferred over the list in the cases where we need quicker append and pop operations from both the ends of the container, as deque provides an O(1) time complexity for append and pop operations as compared to list which provides O(n) time complexity.\n\nThe same methods on deque as seen in the list are used, append() and pop().\n\nQueue module also has a LIFO Queue, which is basically a Stack. Data is inserted into Queue using the put() function and get() takes data out from the Queue.\n\nThere are various functions available in this module:\n• maxsize – Number of items allowed in the queue.\n• empty() – Return True if the queue is empty, False otherwise.\n• full() – Return True if there are maxsize items in the queue. If the queue was initialized with maxsize=0 (the default), then full() never returns True.\n• get() – Remove and return an item from the queue. If the queue is empty, wait until an item is available.\n• get_nowait() – Return an item if one is immediately available, else raise QueueEmpty.\n• put(item) – Put an item into the queue. If the queue is full, wait until a free slot is available before adding the item.\n• put_nowait(item) – Put an item into the queue without blocking. If no free slot is immediately available, raise QueueFull.\n• qsize() – Return the number of items in the queue.\n\nThe linked list has two methods addHead(item) and removeHead() that run in constant time. These two methods are suitable to implement a stack.\n• getSize() – Get the number of items in the stack.\n• isEmpty() – Return True if the stack is empty, False otherwise.\n• peek() – Return the top item in the stack. If the stack is empty, raise an exception.\n• push(value) – Push a value into the head of the stack.\n• pop() – Remove and return a value in the head of the stack. If the stack is empty, raise an exception.\n\nBelow is the implementation of the above approach:\n• None Stacks are simple data structures with a well-defined set of operations, which makes them easy to understand and use.\n• None Stacks are efficient for adding and removing elements, as these operations have a time complexity of O(1).\n• None In order to reverse the order of elements we use the stack data structure.\n• None Stacks can be used to implement undo/redo functions in applications.\n• None Restriction of size in Stack is a drawback and if they are full, you cannot add any more elements to the stack.\n• None Stacks do not provide fast access to elements other than the top element.\n• None Stacks do not support efficient searching, as you have to pop elements one by one until you find the element you are looking for.\n\nHow to create a stack in Python?\n\nHow to inspect a stack in Python?\n\nHow to use a stack in Python?\n\nIs a stack in Python implemented as a list?"
    },
    {
        "link": "https://runestone.academy/ns/books/published/pythonds/BasicDS/ImplementingaStackinPython.html",
        "document": "Now that we have clearly defined the stack as an abstract data type we will turn our attention to using Python to implement the stack. Recall that when we give an abstract data type a physical implementation we refer to the implementation as a data structure.\n\nAs we described in Chapter 1, in Python, as in any object-oriented programming language, the implementation of choice for an abstract data type such as a stack is the creation of a new class. The stack operations are implemented as methods. Further, to implement a stack, which is a collection of elements, it makes sense to utilize the power and simplicity of the primitive collections provided by Python. We will use a list.\n\nRecall that the list class in Python provides an ordered collection mechanism and a set of methods. For example, if we have the list [2,5,3,6,7,4], we need only to decide which end of the list will be considered the top of the stack and which will be the base. Once that decision is made, the operations can be implemented using the list methods such as and .\n\nThe following stack implementation (ActiveCode 1) assumes that the end of the list will hold the top element of the stack. As the stack grows (as operations occur), new items will be added on the end of the list. operations will manipulate that same end.\n\nRemember that nothing happens when we click the button other than the definition of the class. We must create a object and then use it. ActiveCode 2 shows the class in action as we perform the sequence of operations from Table 1. Notice that the definition of the class is imported from the module.\n\nIt is important to note that we could have chosen to implement the stack using a list where the top is at the beginning instead of at the end. In this case, the previous and methods would no longer work and we would have to index position 0 (the first item in the list) explicitly using and . The implementation is shown in CodeLens 1.\n\nThis ability to change the physical implementation of an abstract data type while maintaining the logical characteristics is an example of abstraction at work. However, even though the stack will work either way, if we consider the performance of the two implementations, there is definitely a difference. Recall that the and operations were both O(1). This means that the first implementation will perform push and pop in constant time no matter how many items are on the stack. The performance of the second implementation suffers in that the and operations will both require O(n) for a stack of size n. Clearly, even though the implementations are logically equivalent, they would have very different timings when performing benchmark testing."
    },
    {
        "link": "https://realpython.com/how-to-implement-python-stack",
        "document": "Have you heard of stacks and wondered what they are? Do you have the general idea but are wondering how to implement a Python stack? You’ve come to the right place!\n• How to recognize when a stack is a good choice for data structures\n• How to decide which implementation is best for your program\n• What extra considerations to make about stacks in a threading or multiprocessing environment\n\nThis tutorial is for Pythonistas who are comfortable running scripts, know what a is and how to use it, and are wondering how to implement Python stacks.\n\nA stack is a data structure that stores items in an Last-In/First-Out manner. This is frequently referred to as LIFO. This is in contrast to a queue, which stores items in a First-In/First-Out (FIFO) manner. It’s probably easiest to understand a stack if you think of a use case you’re likely familiar with: the Undo feature in your editor. Let’s imagine you’re editing a Python file so we can look at some of the operations you perform. First, you add a new function. This adds a new item to the undo stack: You can see that the stack now has an Add Function operation on it. After adding the function, you delete a word from a comment. This also gets added to the undo stack: Notice how the Delete Word item is placed on top of the stack. Finally you indent a comment so that it’s lined up properly: You can see that each of these commands are stored in an undo stack, with each new command being put at the top. When you’re working with stacks, adding new items like this is called . Now you’ve decided to undo all three of those changes, so you hit the undo command. It takes the item at the top of the stack, which was indenting the comment, and removes that from the stack: Your editor undoes the indent, and the undo stack now contains two items. This operation is the opposite of and is commonly called . When you hit undo again, the next item is popped off the stack: This removes the Delete Word item, leaving only one operation on the stack. Finally, if you hit Undo a third time, then the last item will be popped off the stack: The undo stack is now empty. Hitting Undo again after this will have no effect because your undo stack is empty, at least in most editors. You’ll see what happens when you call on an empty stack in the implementation descriptions below.\n\nThere are a couple of options when you’re implementing a Python stack. This article won’t cover all of them, just the basic ones that will meet almost all of your needs. You’ll focus on using data structures that are part of the Python library, rather than writing your own or using third-party packages. You’ll look at the following Python stack implementations: The built-in structure that you likely use frequently in your programs can be used as a stack. Instead of , you can use to add new elements to the top of your stack, while removes the elements in the LIFO order: You can see in the final command that a will raise an if you call on an empty stack. has the advantage of being familiar. You know how it works and likely have used it in your programs already. Unfortunately, has a few shortcomings compared to other data structures you’ll look at. The biggest issue is that it can run into speed issues as it grows. The items in a are stored with the goal of providing fast access to random elements in the . At a high level, this means that the items are stored next to each other in memory. If your stack grows bigger than the block of memory that currently holds it, then Python needs to do some memory allocations. This can lead to some calls taking much longer than other ones. There is a less serious problem as well. If you use to add an element to your stack at a position other than the end, it can take much longer. This is not normally something you would do to a stack, however. The next data structure will help you get around the reallocation problem you saw with . The module contains , which is useful for creating Python stacks. is pronounced “deck” and stands for “double-ended queue.” You can use the same methods on as you saw above for , , and : This looks almost identical to the example above. At this point, you might be wondering why the Python core developers would create two data structures that look the same. Why Have and ? As you saw in the discussion about above, it was built upon blocks of contiguous memory, meaning that the items in the list are stored right next to each other: This works great for several operations, like indexing into the . Getting is fast, as Python knows exactly where to look in memory to find it. This memory layout also allows slices to work well on lists. The contiguous memory layout is the reason that might need to take more time to some objects than others. If the block of contiguous memory is full, then it will need to get another block, which can take much longer than a normal : , on the other hand, is built upon a doubly linked list. In a linked list structure, each entry is stored in its own memory block and has a reference to the next entry in the list. A doubly linked list is just the same, except that each entry has references to both the previous and the next entry in the list. This allows you to easily add nodes to either end of the list. Adding a new entry into a linked list structure only requires setting the new entry’s reference to point to the current top of the stack and then pointing the top of the stack to the new entry: This constant-time addition and removal of entries onto a stack comes with a trade-off, however. Getting is slower than it was for a list, because Python needs to walk through each node of the list to get to the third element. Fortunately, you rarely want to do random indexing or slicing on a stack. Most operations on a stack are either or . The constant time and operations make an excellent choice for implementing a Python stack if your code doesn’t use threading.\n\nPython stacks can be useful in multi-threaded programs as well, but if you’re not interested in threading, then you can safely skip this section and jump to the summary. The two options you’ve seen so far, and , behave differently if your program has threads. To start with the simpler one, you should never use for any data structure that can be accessed by multiple threads. is not thread-safe. Note: If you need a refresher on thread safety and race conditions, check out An Intro to Threading in Python. is a little more complex, however. If you read the documentation for , it clearly states that both the and operations are atomic, meaning that they won’t be interrupted by a different thread. So if you restrict yourself to using only and , then you will be thread safe. The concern with using in a threaded environment is that there are other methods in that class, and those are not specifically designed to be atomic, nor are they thread safe. So, while it’s possible to build a thread-safe Python stack using a , doing so exposes yourself to someone misusing it in the future and causing race conditions. Okay, if you’re threading, you can’t use for a stack and you probably don’t want to use for a stack, so how can you build a Python stack for a threaded program? The answer is in the module, . Remember how you learned that stacks operate on the Last-In/First-Out principle? Well, that’s what the “Lifo” portion of stands for. While the interface for and were similar, uses and to add and remove data from the stack: File , line , in File , line , in File , line , in Unlike , is designed to be fully thread-safe. All of its methods are safe to use in a threaded environment. It also adds optional time-outs to its operations which can frequently be a must-have feature in threaded programs. This full thread safety comes at a cost, however. To achieve this thread-safety, has to do a little extra work on each operation, meaning that it will take a little longer. Frequently, this slight slow down will not matter to your overall program speed, but if you’ve measured your performance and discovered that your stack operations are the bottleneck, then carefully switching to a might be worth doing. I’d like to stress again that switching from to because it’s faster without having measurements showing that your stack operations are a bottleneck is an example of premature optimization. Don’t do that."
    },
    {
        "link": "https://stackoverflow.com/questions/31229962/efficient-stack-implementation-in-python",
        "document": "1st Implementation: The following stack implementation assumes that the end of the list will hold the top element of the stack. As the stack grows, new items will be added on the end of the list.\n\n2nd Implementation : The second implementation assumes that the beginning of the list holds the top element of the stack and new items are added at the index 0.\n\nBeing a beginner to Data Structures, I would like to know:\n\n 1. Which implementation is more efficient with respect to time or space, and why ?\n\n 2. Is the time complexity of the in the 2nd implementation O(n). If yes, how ?"
    },
    {
        "link": "https://geeksforgeeks.org/stack-data-structure",
        "document": "A Stack is a linear data structure that follows a particular order in which the operations are performed. The order may be LIFO(Last In First Out) or FILO(First In Last Out). LIFO implies that the element that is inserted last, comes out first and FILO implies that the element that is inserted first, comes out last.\n\nIt behaves like a stack of plates, where the last plate added is the first one to be removed. Think of it this way:\n• None Pushing an element onto the stack is like adding a new plate on top.\n• None Popping an element removes the top plate from the stack.\n\nImplementations of Stack in Different Languages\n• None Implement two stacks in an array\n• None Reversing the first K of a Queue\n• None Next Smaller of next Greater in an array\n• None Max product of indexes of greater on left and right\n• None Reverse a stack without using extra space in O(n)\n• None Check if a queue can be sorted into another queue\n• None Check if an array is stack sortable\n• None Index of closing bracket for a given opening bracket\n• None Max Diff between nearest left and right smaller elements\n• None Sum of Max of all Subarrays\n• None Max of Mins of every window size\n• None Print ancestors of a given binary tree node without recursion\n• None Expression contains redundant bracket or not\n• None Find if an expression has duplicate parenthesis\n• None Remove brackets from an algebraic string containing + and – operators"
    },
    {
        "link": "https://geeksforgeeks.org/stack-in-python",
        "document": "A stack is a linear data structure that stores items in a Last-In/First-Out (LIFO) or First-In/Last-Out (FILO) manner. In stack, a new element is added at one end and an element is removed from that end only. The insert and delete operations are often called push and pop.\n\nThe functions associated with stack are:\n• empty() – Returns whether the stack is empty – Time Complexity: O(1)\n• size() – Returns the size of the stack – Time Complexity: O(1)\n• top() / peek() – Returns a reference to the topmost element of the stack – Time Complexity: O(1)\n• push(a) – Inserts the element ‘a’ at the top of the stack – Time Complexity: O(1)\n• pop() – Deletes the topmost element of the stack – Time Complexity: O(1)\n\nThere are various ways from which a stack can be implemented in Python. This article covers the implementation of a stack using data structures and modules from the Python library. \n\nStack in Python can be implemented using the following ways:\n\nPython’s built-in data structure list can be used as a stack. Instead of push(), append() is used to add elements to the top of the stack while pop() removes the element in LIFO order. \n\nUnfortunately, the list has a few shortcomings. The biggest issue is that it can run into speed issues as it grows. The items in the list are stored next to each other in memory, if the stack grows bigger than the block of memory that currently holds it, then Python needs to do some memory allocations. This can lead to some append() calls taking much longer than other ones.\n\nPython stack can be implemented using the deque class from the collections module. Deque is preferred over the list in the cases where we need quicker append and pop operations from both the ends of the container, as deque provides an O(1) time complexity for append and pop operations as compared to list which provides O(n) time complexity.\n\nThe same methods on deque as seen in the list are used, append() and pop().\n\nQueue module also has a LIFO Queue, which is basically a Stack. Data is inserted into Queue using the put() function and get() takes data out from the Queue.\n\nThere are various functions available in this module:\n• maxsize – Number of items allowed in the queue.\n• empty() – Return True if the queue is empty, False otherwise.\n• full() – Return True if there are maxsize items in the queue. If the queue was initialized with maxsize=0 (the default), then full() never returns True.\n• get() – Remove and return an item from the queue. If the queue is empty, wait until an item is available.\n• get_nowait() – Return an item if one is immediately available, else raise QueueEmpty.\n• put(item) – Put an item into the queue. If the queue is full, wait until a free slot is available before adding the item.\n• put_nowait(item) – Put an item into the queue without blocking. If no free slot is immediately available, raise QueueFull.\n• qsize() – Return the number of items in the queue.\n\nThe linked list has two methods addHead(item) and removeHead() that run in constant time. These two methods are suitable to implement a stack.\n• getSize() – Get the number of items in the stack.\n• isEmpty() – Return True if the stack is empty, False otherwise.\n• peek() – Return the top item in the stack. If the stack is empty, raise an exception.\n• push(value) – Push a value into the head of the stack.\n• pop() – Remove and return a value in the head of the stack. If the stack is empty, raise an exception.\n\nBelow is the implementation of the above approach:\n• None Stacks are simple data structures with a well-defined set of operations, which makes them easy to understand and use.\n• None Stacks are efficient for adding and removing elements, as these operations have a time complexity of O(1).\n• None In order to reverse the order of elements we use the stack data structure.\n• None Stacks can be used to implement undo/redo functions in applications.\n• None Restriction of size in Stack is a drawback and if they are full, you cannot add any more elements to the stack.\n• None Stacks do not provide fast access to elements other than the top element.\n• None Stacks do not support efficient searching, as you have to pop elements one by one until you find the element you are looking for.\n\nHow to create a stack in Python?\n\nHow to inspect a stack in Python?\n\nHow to use a stack in Python?\n\nIs a stack in Python implemented as a list?"
    },
    {
        "link": "https://docs.python.org/3/tutorial/datastructures.html",
        "document": "This chapter describes some things you’ve learned about already in more detail, and adds some new things as well.\n\nThe list data type has some more methods. Here are all of the methods of list objects: Add an item to the end of the list. Similar to . Extend the list by appending all the items from the iterable. Similar to . Insert an item at a given position. The first argument is the index of the element before which to insert, so inserts at the front of the list, and is equivalent to . Remove the first item from the list whose value is equal to x. It raises a if there is no such item. Remove the item at the given position in the list, and return it. If no index is specified, removes and returns the last item in the list. It raises an if the list is empty or the index is outside the list range. Remove all items from the list. Similar to . Return zero-based index in the list of the first item whose value is equal to x. Raises a if there is no such item. The optional arguments start and end are interpreted as in the slice notation and are used to limit the search to a particular subsequence of the list. The returned index is computed relative to the beginning of the full sequence rather than the start argument. Return the number of times x appears in the list. Sort the items of the list in place (the arguments can be used for sort customization, see for their explanation). Reverse the elements of the list in place. Return a shallow copy of the list. Similar to . An example that uses most of the list methods: You might have noticed that methods like , or that only modify the list have no return value printed – they return the default . This is a design principle for all mutable data structures in Python. Another thing you might notice is that not all data can be sorted or compared. For instance, doesn’t sort because integers can’t be compared to strings and can’t be compared to other types. Also, there are some types that don’t have a defined ordering relation. For example, isn’t a valid comparison. The list methods make it very easy to use a list as a stack, where the last element added is the first element retrieved (“last-in, first-out”). To add an item to the top of the stack, use . To retrieve an item from the top of the stack, use without an explicit index. For example: It is also possible to use a list as a queue, where the first element added is the first element retrieved (“first-in, first-out”); however, lists are not efficient for this purpose. While appends and pops from the end of list are fast, doing inserts or pops from the beginning of a list is slow (because all of the other elements have to be shifted by one). To implement a queue, use which was designed to have fast appends and pops from both ends. For example: # The first to arrive now leaves # The second to arrive now leaves List comprehensions provide a concise way to create lists. Common applications are to make new lists where each element is the result of some operations applied to each member of another sequence or iterable, or to create a subsequence of those elements that satisfy a certain condition. For example, assume we want to create a list of squares, like: Note that this creates (or overwrites) a variable named that still exists after the loop completes. We can calculate the list of squares without any side effects using: which is more concise and readable. A list comprehension consists of brackets containing an expression followed by a clause, then zero or more or clauses. The result will be a new list resulting from evaluating the expression in the context of the and clauses which follow it. For example, this listcomp combines the elements of two lists if they are not equal: Note how the order of the and statements is the same in both these snippets. If the expression is a tuple (e.g. the in the previous example), it must be parenthesized. # create a new list with the values doubled # apply a function to all the elements # the tuple must be parenthesized, otherwise an error is raised File , line : did you forget parentheses around the comprehension target? # flatten a list using a listcomp with two 'for' List comprehensions can contain complex expressions and nested functions: The initial expression in a list comprehension can be any arbitrary expression, including another list comprehension. Consider the following example of a 3x4 matrix implemented as a list of 3 lists of length 4: The following list comprehension will transpose rows and columns: As we saw in the previous section, the inner list comprehension is evaluated in the context of the that follows it, so this example is equivalent to: which, in turn, is the same as: # the following 3 lines implement the nested listcomp In the real world, you should prefer built-in functions to complex flow statements. The function would do a great job for this use case: See Unpacking Argument Lists for details on the asterisk in this line.\n\nWe saw that lists and strings have many common properties, such as indexing and slicing operations. They are two examples of sequence data types (see Sequence Types — list, tuple, range). Since Python is an evolving language, other sequence data types may be added. There is also another standard sequence data type: the tuple. A tuple consists of a number of values separated by commas, for instance: File , line , in : # but they can contain mutable objects: As you see, on output tuples are always enclosed in parentheses, so that nested tuples are interpreted correctly; they may be input with or without surrounding parentheses, although often parentheses are necessary anyway (if the tuple is part of a larger expression). It is not possible to assign to the individual items of a tuple, however it is possible to create tuples which contain mutable objects, such as lists. Though tuples may seem similar to lists, they are often used in different situations and for different purposes. Tuples are immutable, and usually contain a heterogeneous sequence of elements that are accessed via unpacking (see later in this section) or indexing (or even by attribute in the case of ). Lists are mutable, and their elements are usually homogeneous and are accessed by iterating over the list. A special problem is the construction of tuples containing 0 or 1 items: the syntax has some extra quirks to accommodate these. Empty tuples are constructed by an empty pair of parentheses; a tuple with one item is constructed by following a value with a comma (it is not sufficient to enclose a single value in parentheses). Ugly, but effective. For example: The statement is an example of tuple packing: the values , and are packed together in a tuple. The reverse operation is also possible: This is called, appropriately enough, sequence unpacking and works for any sequence on the right-hand side. Sequence unpacking requires that there are as many variables on the left side of the equals sign as there are elements in the sequence. Note that multiple assignment is really just a combination of tuple packing and sequence unpacking.\n\nPython also includes a data type for sets. A set is an unordered collection with no duplicate elements. Basic uses include membership testing and eliminating duplicate entries. Set objects also support mathematical operations like union, intersection, difference, and symmetric difference. Curly braces or the function can be used to create sets. Note: to create an empty set you have to use , not ; the latter creates an empty dictionary, a data structure that we discuss in the next section. Here is a brief demonstration: # show that duplicates have been removed # Demonstrate set operations on unique letters from two words # letters in a but not in b # letters in a or b or both # letters in both a and b # letters in a or b but not both Similarly to list comprehensions, set comprehensions are also supported:\n\nAnother useful data type built into Python is the dictionary (see Mapping Types — dict). Dictionaries are sometimes found in other languages as “associative memories” or “associative arrays”. Unlike sequences, which are indexed by a range of numbers, dictionaries are indexed by keys, which can be any immutable type; strings and numbers can always be keys. Tuples can be used as keys if they contain only strings, numbers, or tuples; if a tuple contains any mutable object either directly or indirectly, it cannot be used as a key. You can’t use lists as keys, since lists can be modified in place using index assignments, slice assignments, or methods like and . It is best to think of a dictionary as a set of key: value pairs, with the requirement that the keys are unique (within one dictionary). A pair of braces creates an empty dictionary: . Placing a comma-separated list of key:value pairs within the braces adds initial key:value pairs to the dictionary; this is also the way dictionaries are written on output. The main operations on a dictionary are storing a value with some key and extracting the value given the key. It is also possible to delete a key:value pair with . If you store using a key that is already in use, the old value associated with that key is forgotten. It is an error to extract a value using a non-existent key. Performing on a dictionary returns a list of all the keys used in the dictionary, in insertion order (if you want it sorted, just use instead). To check whether a single key is in the dictionary, use the keyword. Here is a small example using a dictionary: The constructor builds dictionaries directly from sequences of key-value pairs: In addition, dict comprehensions can be used to create dictionaries from arbitrary key and value expressions: When the keys are simple strings, it is sometimes easier to specify pairs using keyword arguments:\n\nWhen looping through dictionaries, the key and corresponding value can be retrieved at the same time using the method. When looping through a sequence, the position index and corresponding value can be retrieved at the same time using the function. To loop over two or more sequences at the same time, the entries can be paired with the function. What is your name? It is lancelot. What is your quest? It is the holy grail. What is your favorite color? It is blue. To loop over a sequence in reverse, first specify the sequence in a forward direction and then call the function. To loop over a sequence in sorted order, use the function which returns a new sorted list while leaving the source unaltered. Using on a sequence eliminates duplicate elements. The use of in combination with over a sequence is an idiomatic way to loop over unique elements of the sequence in sorted order. It is sometimes tempting to change a list while you are looping over it; however, it is often simpler and safer to create a new list instead.\n\nThe conditions used in and statements can contain any operators, not just comparisons. The comparison operators and are membership tests that determine whether a value is in (or not in) a container. The operators and compare whether two objects are really the same object. All comparison operators have the same priority, which is lower than that of all numerical operators. Comparisons can be chained. For example, tests whether is less than and moreover equals . Comparisons may be combined using the Boolean operators and , and the outcome of a comparison (or of any other Boolean expression) may be negated with . These have lower priorities than comparison operators; between them, has the highest priority and the lowest, so that A and not B or C is equivalent to (A and (not B)) or C . As always, parentheses can be used to express the desired composition. The Boolean operators and are so-called short-circuit operators: their arguments are evaluated from left to right, and evaluation stops as soon as the outcome is determined. For example, if and are true but is false, A and B and C does not evaluate the expression . When used as a general value and not as a Boolean, the return value of a short-circuit operator is the last evaluated argument. It is possible to assign the result of a comparison or other Boolean expression to a variable. For example, Note that in Python, unlike C, assignment inside expressions must be done explicitly with the walrus operator . This avoids a common class of problems encountered in C programs: typing in an expression when was intended.\n\nSequence objects typically may be compared to other objects with the same sequence type. The comparison uses lexicographical ordering: first the first two items are compared, and if they differ this determines the outcome of the comparison; if they are equal, the next two items are compared, and so on, until either sequence is exhausted. If two items to be compared are themselves sequences of the same type, the lexicographical comparison is carried out recursively. If all items of two sequences compare equal, the sequences are considered equal. If one sequence is an initial sub-sequence of the other, the shorter sequence is the smaller (lesser) one. Lexicographical ordering for strings uses the Unicode code point number to order individual characters. Some examples of comparisons between sequences of the same type: Note that comparing objects of different types with or is legal provided that the objects have appropriate comparison methods. For example, mixed numeric types are compared according to their numeric value, so 0 equals 0.0, etc. Otherwise, rather than providing an arbitrary ordering, the interpreter will raise a exception."
    },
    {
        "link": "https://realpython.com/python-data-structures",
        "document": "Data structures are the fundamental constructs around which you build your programs. Each data structure provides a particular way of organizing data so it can be accessed efficiently, depending on your use case. Python ships with an extensive set of data structures in its standard library.\n\nHowever, Python’s naming convention doesn’t provide the same level of clarity that you’ll find in other languages. In Java, a list isn’t just a —it’s either a or an . Not so in Python. Even experienced Python developers sometimes wonder whether the built-in type is implemented as a linked list or a dynamic array.\n• Which common abstract data types are built into the Python standard library\n• How the most common abstract data types map to Python’s naming scheme\n• How to put abstract data types to practical use in various algorithms\n\nIn Python, dictionaries (or dicts for short) are a central data structure. Dicts store an arbitrary number of objects, each identified by a unique dictionary key. Dictionaries are also often called maps, hashmaps, lookup tables, or associative arrays. They allow for the efficient lookup, insertion, and deletion of any object associated with a given key. Phone books make a decent real-world analog for dictionary objects. They allow you to quickly retrieve the information (phone number) associated with a given key (a person’s name). Instead of having to read a phone book front to back to find someone’s number, you can jump more or less directly to a name and look up the associated information. This analogy breaks down somewhat when it comes to how the information is organized to allow for fast lookups. But the fundamental performance characteristics hold. Dictionaries allow you to quickly find the information associated with a given key. Dictionaries are one of the most important and frequently used data structures in computer science. So, how does Python handle dictionaries? Let’s take a tour of the dictionary implementations available in core Python and the Python standard library. Because dictionaries are so important, Python features a robust dictionary implementation that’s built directly into the core language: the data type. Python also provides some useful syntactic sugar for working with dictionaries in your programs. For example, the curly-brace ({ }) dictionary expression syntax and dictionary comprehensions allow you to conveniently define new dictionary objects: There are some restrictions on which objects can be used as valid keys. Python’s dictionaries are indexed by keys that can be of any hashable type. A hashable object has a hash value that never changes during its lifetime (see ), and it can be compared to other objects (see ). Hashable objects that compare as equal must have the same hash value. Immutable types like strings and numbers are hashable and work well as dictionary keys. You can also use objects as dictionary keys as long as they contain only hashable types themselves. For most use cases, Python’s built-in dictionary implementation will do everything you need. Dictionaries are highly optimized and underlie many parts of the language. For example, class attributes and variables in a stack frame are both stored internally in dictionaries. Python dictionaries are based on a well-tested and finely tuned hash table implementation that provides the performance characteristics you’d expect: O(1) time complexity for lookup, insert, update, and delete operations in the average case. There’s little reason not to use the standard implementation included with Python. However, specialized third-party dictionary implementations exist, such as skip lists or B-tree–based dictionaries. Besides plain objects, Python’s standard library also includes a number of specialized dictionary implementations. These specialized dictionaries are all based on the built-in dictionary class (and share its performance characteristics) but also include some additional convenience features. Let’s take a look at them. Python includes a specialized subclass that remembers the insertion order of keys added to it: . Note: is not a built-in part of the core language and must be imported from the module in the standard library. While standard instances preserve the insertion order of keys in CPython 3.6 and above, this was simply a side effect of the CPython implementation and was not defined in the language spec until Python 3.7. So, if key order is important for your algorithm to work, then it’s best to communicate this clearly by explicitly using the class: odict_keys(['one', 'two', 'three', 'four']) Until Python 3.8, you couldn’t iterate over dictionary items in reverse order using . Only instances offered that functionality. Even in Python 3.8, and objects aren’t exactly the same. instances have a method that is unavailable on plain instance, as well as a more customizable method than the one plain instances. The class is another dictionary subclass that accepts a callable in its constructor whose return value will be used if a requested key cannot be found. This can save you some typing and make your intentions clearer as compared to using or catching a exception in regular dictionaries: # initializes it using the default factory, # i.e. list() in this example: The data structure groups multiple dictionaries into a single mapping. Lookups search the underlying mappings one by one until a key is found. Insertions, updates, and deletions only affect the first mapping added to the chain: ChainMap({'one': 1, 'two': 2}, {'three': 3, 'four': 4}) # ChainMap searches each collection in the chain # from left to right until it finds the key (or fails): File , line , in : is a wrapper around a standard dictionary that provides a read-only view into the wrapped dictionary’s data. This class was added in Python 3.3 and can be used to create immutable proxy versions of dictionaries. can be helpful if, for example, you’d like to return a dictionary carrying internal state from a class or module while discouraging write access to this object. Using allows you to put these restrictions in place without first having to create a full copy of the dictionary: File , line , in : # Updates to the original are reflected in the proxy: All the Python dictionary implementations listed in this tutorial are valid implementations that are built into the Python standard library. If you’re looking for a general recommendation on which mapping type to use in your programs, I’d point you to the built-in data type. It’s a versatile and optimized hash table implementation that’s built directly into the core language. I would recommend that you use one of the other data types listed here only if you have special requirements that go beyond what’s provided by . All the implementations are valid options, but your code will be clearer and easier to maintain if it relies on standard Python dictionaries most of the time.\n\nAn array is a fundamental data structure available in most programming languages, and it has a wide range of uses across different algorithms. In this section, you’ll take a look at array implementations in Python that use only core language features or functionality that’s included in the Python standard library. You’ll see the strengths and weaknesses of each approach so you can decide which implementation is right for your use case. But before we jump in, let’s cover some of the basics first. How do arrays work, and what are they used for? Arrays consist of fixed-size data records that allow each element to be efficiently located based on its index: Because arrays store information in adjoining blocks of memory, they’re considered contiguous data structures (as opposed to linked data structures like linked lists, for example). A real-world analogy for an array data structure is a parking lot. You can look at the parking lot as a whole and treat it as a single object, but inside the lot there are parking spots indexed by a unique number. Parking spots are containers for vehicles—each parking spot can either be empty or have a car, a motorbike, or some other vehicle parked on it. But not all parking lots are the same. Some parking lots may be restricted to only one type of vehicle. For example, a motor home parking lot wouldn’t allow bikes to be parked on it. A restricted parking lot corresponds to a typed array data structure that allows only elements that have the same data type stored in them. Performance-wise, it’s very fast to look up an element contained in an array given the element’s index. A proper array implementation guarantees a constant O(1) access time for this case. Python includes several array-like data structures in its standard library that each have slightly different characteristics. Let’s take a look. Lists are a part of the core Python language. Despite their name, Python’s lists are implemented as dynamic arrays behind the scenes. This means a list allows elements to be added or removed, and the list will automatically adjust the backing store that holds these elements by allocating or releasing memory. Python lists can hold arbitrary elements—everything is an object in Python, including functions. Therefore, you can mix and match different kinds of data types and store them all in a single list. This can be a powerful feature, but the downside is that supporting multiple data types at the same time means that data is generally less tightly packed. As a result, the whole structure takes up more space: ['one', 'hello', 'three'] Just like lists, tuples are part of the Python core language. Unlike lists, however, Python’s objects are immutable. This means elements can’t be added or removed dynamically—all elements in a tuple must be defined at creation time. Tuples are another data structure that can hold elements of arbitrary data types. Having this flexibility is powerful, but again, it also means that data is less tightly packed than it would be in a typed array: Python’s module provides space-efficient storage of basic C-style data types like bytes, 32-bit integers, floating-point numbers, and so on. Arrays created with the class are mutable and behave similarly to lists except for one important difference: they’re typed arrays constrained to a single data type. Because of this constraint, objects with many elements are more space efficient than lists and tuples. The elements stored in them are tightly packed, and this can be useful if you need to store many elements of the same type. Also, arrays support many of the same methods as regular lists, and you might be able to use them as a drop-in replacement without requiring other changes to your application code: File , line , in : must be real number, not str Python 3.x uses objects to store textual data as immutable sequences of Unicode characters. Practically speaking, that means a is an immutable array of characters. Oddly enough, it’s also a recursive data structure—each character in a string is itself a object of length 1. String objects are space efficient because they’re tightly packed and they specialize in a single data type. If you’re storing Unicode text, then you should use a string. Because strings are immutable in Python, modifying a string requires creating a modified copy. The closest equivalent to a mutable string is storing individual characters inside a list: File , line , in : File , line , in : # Strings can be unpacked into a list to objects are immutable sequences of single bytes, or integers in the range 0 ≤ x ≤ 255. Conceptually, objects are similar to objects, and you can also think of them as immutable arrays of bytes. Like strings, have their own literal syntax for creating objects and are space efficient. objects are immutable, but unlike strings, there’s a dedicated mutable byte array data type called that they can be unpacked into: # Bytes literals have their own syntax: File , line , in : bytes must be in range(0, 256) File , line , in : File , line , in : The type is a mutable sequence of integers in the range 0 ≤ x ≤ 255. The object is closely related to the object, with the main difference being that a can be modified freely—you can overwrite elements, remove existing elements, or add new ones. The object will grow and shrink accordingly. A can be converted back into immutable objects, but this involves copying the stored data in full—a slow operation taking O(n) time: # Bytearrays can grow and shrink in size: File , line , in : 'str' object cannot be interpreted as an integer File , line , in : byte must be in range(0, 256) # Bytearrays can be converted back into bytes objects: # (This will copy the data) There are a number of built-in data structures you can choose from when it comes to implementing arrays in Python. In this section, you’ve focused on core language features and data structures included in the standard library. If you’re willing to go beyond the Python standard library, then third-party packages like NumPy and pandas offer a wide range of fast array implementations for scientific computing and data science. If you want to restrict yourself to the array data structures included with Python, then here are a few guidelines:\n• If you need to store arbitrary objects, potentially with mixed data types, then use a or a , depending on whether or not you want an immutable data structure.\n• If you have numeric (integer or floating-point) data and tight packing and performance is important, then try out .\n• If you have textual data represented as Unicode characters, then use Python’s built-in . If you need a mutable string-like data structure, then use a of characters.\n• If you want to store a contiguous block of bytes, then use the immutable type or a if you need a mutable data structure. In most cases, I like to start out with a simple . I’ll only specialize later on if performance or storage space becomes an issue. Most of the time, using a general-purpose array data structure like gives you the fastest development speed and the most programming convenience. I’ve found that this is usually much more important in the beginning than trying to squeeze out every last drop of performance right from the start.\n\nCompared to arrays, record data structures provide a fixed number of fields. Each field can have a name and may also have a different type. In this section, you’ll see how to implement records, structs, and plain old data objects in Python using only built-in data types and classes from the standard library. Note: I’m using the definition of a record loosely here. For example, I’m also going to discuss types like Python’s built-in that may or may not be considered records in a strict sense because they don’t provide named fields. Python offers several data types that you can use to implement records, structs, and data transfer objects. In this section, you’ll get a quick look at each implementation and its unique characteristics. At the end, you’ll find a summary and a decision-making guide that will help you make your own picks. Note: This tutorial is adapted from the chapter “Common Data Structures in Python” in Python Tricks: The Book. If you enjoy what you’re reading, then be sure to check out the rest of the book. As mentioned previously, Python dictionaries store an arbitrary number of objects, each identified by a unique key. Dictionaries are also often called maps or associative arrays and allow for efficient lookup, insertion, and deletion of any object associated with a given key. Using dictionaries as a record data type or data object in Python is possible. Dictionaries are easy to create in Python as they have their own syntactic sugar built into the language in the form of dictionary literals. The dictionary syntax is concise and quite convenient to type. Data objects created using dictionaries are mutable, and there’s little protection against misspelled field names as fields can be added and removed freely at any time. Both of these properties can introduce surprising bugs, and there’s always a trade-off to be made between convenience and error resilience: Python’s tuples are a straightforward data structure for grouping arbitrary objects. Tuples are immutable—they can’t be modified once they’ve been created. Performance-wise, tuples take up slightly less memory than lists in CPython, and they’re also faster to construct. As you can see in the bytecode disassembly below, constructing a tuple constant takes a single opcode, while constructing a list object with the same contents requires several more operations: However, you shouldn’t place too much emphasis on these differences. In practice, the performance difference will often be negligible, and trying to squeeze extra performance out of a program by switching from lists to tuples will likely be the wrong approach. A potential downside of plain tuples is that the data you store in them can only be pulled out by accessing it through integer indexes. You can’t give names to individual properties stored in a tuple. This can impact code readability. Also, a tuple is always an ad-hoc structure: it’s difficult to ensure that two tuples have the same number of fields and the same properties stored in them. This makes it easy to introduce slip-of-the-mind bugs, such as mixing up the field order. Therefore, I would recommend that you keep the number of fields stored in a tuple as low as possible: File , line , in : # No protection against missing or extra fields Classes allow you to define reusable blueprints for data objects to ensure each object provides the same set of fields. Using regular Python classes as record data types is feasible, but it also takes manual work to get the convenience features of other implementations. For example, adding new fields to the constructor is verbose and takes time. Also, the default string representation for objects instantiated from custom classes isn’t very helpful. To fix that, you may have to add your own method, which again is usually quite verbose and must be updated each time you add a new field. Fields stored on classes are mutable, and new fields can be added freely, which you may or may not like. It’s possible to provide more access control and to create read-only fields using the decorator, but once again, this requires writing more glue code. Writing a custom class is a great option whenever you’d like to add business logic and behavior to your record objects using methods. However, this means that these objects are technically no longer plain data objects: # String representation is not very useful Data classes are available in Python 3.7 and above. They provide an excellent alternative to defining your own data storage classes from scratch. By writing a data class instead of a plain Python class, your object instances get a few useful features out of the box that will save you some typing and manual implementation work:\n• The syntax for defining instance variables is shorter, since you don’t need to implement the method.\n• Instances of your data class automatically get nice-looking string representation via an auto-generated method.\n• Instance variables accept type annotations, making your data class self-documenting to a degree. Keep in mind that type annotations are just hints that are not enforced without a separate type-checking tool. Data classes are typically created using the decorator, as you’ll see in the code example below: # Type annotations are not enforced without To learn more about Python data classes, check out the The Ultimate Guide to Data Classes in Python 3.7. The class available in Python 2.6+ provides an extension of the built-in data type. Similar to defining a custom class, using allows you to define reusable blueprints for your records that ensure the correct field names are used. objects are immutable, just like regular tuples. This means you can’t add new fields or modify existing fields after the instance is created. Besides that, objects are, well . . . named tuples. Each object stored in them can be accessed through a unique identifier. This frees you from having to remember integer indexes or resort to workarounds like defining integer constants as mnemonics for your indexes. objects are implemented as regular Python classes internally. When it comes to memory usage, they’re also better than regular classes and just as memory efficient as regular tuples: objects can be an easy way to clean up your code and make it more readable by enforcing a better structure for your data. I find that going from ad-hoc data types like dictionaries with a fixed format to objects helps me to express the intent of my code more clearly. Often when I apply this refactoring, I magically come up with a better solution for the problem I’m facing. Using objects over regular (unstructured) tuples and dicts can also make your coworkers’ lives easier by making the data that’s being passed around self-documenting, at least to a degree: Added in Python 3.6, is the younger sibling of the class in the module. It’s very similar to , with the main difference being an updated syntax for defining new record types and added support for type hints. Please note that type annotations are not enforced without a separate type-checking tool like mypy. But even without tool support, they can provide useful hints for other programmers (or be terribly confusing if the type hints become out of date): File , line , in : File , line , in : # Type annotations are not enforced without The class converts between Python values and C structs serialized into Python objects. For example, it can be used to handle binary data stored in files or coming in from network connections. Structs are defined using a mini language based on format strings that allows you to define the arrangement of various C data types like , , and as well as their variants. Serialized structs are seldom used to represent data objects meant to be handled purely inside Python code. They’re intended primarily as a data exchange format rather than as a way of holding data in memory that’s only used by Python code. In some cases, packing primitive data into structs may use less memory than keeping it in other data types. However, in most cases that would be quite an advanced (and probably unnecessary) optimization: # All you get is a blob of data: # Data blobs can be unpacked again: Here’s one more slightly obscure choice for implementing data objects in Python: . This class was added in Python 3.3 and provides attribute access to its namespace. This means instances expose all of their keys as class attributes. You can use dotted attribute access instead of the square-bracket indexing syntax that’s used by regular dicts. All instances also include a meaningful by default. As its name proclaims, is simple! It’s basically a dictionary that allows attribute access and prints nicely. Attributes can be added, modified, and deleted freely: As you’ve seen, there’s quite a number of different options for implementing records or data objects. Which type should you use for data objects in Python? Generally your decision will depend on your use case:\n• If you have only a few fields, then using a plain tuple object may be okay if the field order is easy to remember or field names are superfluous. For example, think of an point in three-dimensional space.\n• If you need immutable fields, then plain tuples, , and are all good options.\n• If you need to lock down field names to avoid typos, then and are your friends.\n• If you want to keep things simple, then a plain dictionary object might be a good choice due to the convenient syntax that closely resembles JSON.\n• If you need full control over your data structure, then it’s time to write a custom class with setters and getters.\n• If you need to add behavior (methods) to the object, then you should write a custom class, either from scratch, or using the decorator, or by extending or .\n• If you need to pack data tightly to serialize it to disk or to send it over the network, then it’s time to read up on because this is a great use case for it! If you’re looking for a safe default choice, then my general recommendation for implementing a plain record, struct, or data object in Python would be to use in Python 2.x and its younger sibling, in Python 3.\n\nIn this section, you’ll see how to implement mutable and immutable set and multiset (bag) data structures in Python using built-in data types and classes from the standard library. A set is an unordered collection of objects that doesn’t allow duplicate elements. Typically, sets are used to quickly test a value for membership in the set, to insert or delete new values from a set, and to compute the union or intersection of two sets. In a proper set implementation, membership tests are expected to run in fast O(1) time. Union, intersection, difference, and subset operations should take O(n) time on average. The set implementations included in Python’s standard library follow these performance characteristics. Just like dictionaries, sets get special treatment in Python and have some syntactic sugar that makes them easy to create. For example, the curly-brace set expression syntax and set comprehensions allow you to conveniently define new set instances: But be careful: To create an empty set you’ll need to call the constructor. Using empty curly-braces ( ) is ambiguous and will create an empty dictionary instead. Python and its standard library provide several set implementations. Let’s have a look at them. The type is the built-in set implementation in Python. It’s mutable and allows for the dynamic insertion and deletion of elements. Python’s sets are backed by the data type and share the same performance characteristics. Any hashable object can be stored in a set: The class implements an immutable version of that can’t be changed after it’s been constructed. objects are static and allow only query operations on their elements, not inserts or deletions. Because objects are static and hashable, they can be used as dictionary keys or as elements of another set, something that isn’t possible with regular (mutable) objects: File , line , in : # Frozensets are hashable and can # be used as dictionary keys: The class in the Python standard library implements a multiset, or bag, type that allows elements in the set to have more than one occurrence. This is useful if you need to keep track of not only if an element is part of a set, but also how many times it’s included in the set: One caveat for the class is that you’ll want to be careful when counting the number of elements in a object. Calling returns the number of unique elements in the multiset, whereas the total number of elements can be retrieved using : Sets are another useful and commonly used data structure included with Python and its standard library. Here are a few guidelines for deciding which one to use:\n• If you need a mutable set, then use the built-in type.\n• If you need hashable objects that can be used as dictionary or set keys, then use a .\n• If you need a multiset, or bag, data structure, then use .\n\nA stack is a collection of objects that supports fast Last-In/First-Out (LIFO) semantics for inserts and deletes. Unlike lists or arrays, stacks typically don’t allow for random access to the objects they contain. The insert and delete operations are also often called push and pop. A useful real-world analogy for a stack data structure is a stack of plates. New plates are added to the top of the stack, and because the plates are precious and heavy, only the topmost plate can be moved. In other words, the last plate on the stack must be the first one removed (LIFO). To reach the plates that are lower down in the stack, the topmost plates must be removed one by one. Performance-wise, a proper stack implementation is expected to take O(1) time for insert and delete operations. Stacks have a wide range of uses in algorithms. For example, they’re used in language parsing as well as runtime memory management, which relies on a call stack. A short and beautiful algorithm using a stack is depth-first search (DFS) on a tree or graph data structure. Python ships with several stack implementations that each have slightly different characteristics. Let’s take a look at them and compare their characteristics. Python’s built-in type makes a decent stack data structure as it supports push and pop operations in amortized O(1) time. Python’s lists are implemented as dynamic arrays internally, which means they occasionally need to resize the storage space for elements stored in them when elements are added or removed. The list over-allocates its backing storage so that not every push or pop requires resizing. As a result, you get an amortized O(1) time complexity for these operations. The downside is that this makes their performance less consistent than the stable O(1) inserts and deletes provided by a linked list–based implementation (as you’ll see below with ). On the other hand, lists do provide fast O(1) time random access to elements on the stack, and this can be an added benefit. There’s an important performance caveat that you should be aware of when using lists as stacks: To get the amortized O(1) performance for inserts and deletes, new items must be added to the end of the list with the method and removed again from the end using . For optimum performance, stacks based on Python lists should grow towards higher indexes and shrink towards lower ones. Adding and removing from the front is much slower and takes O(n) time, as the existing elements must be shifted around to make room for the new element. This is a performance antipattern that you should avoid as much as possible: The class implements a double-ended queue that supports adding and removing elements from either end in O(1) time (non-amortized). Because deques support adding and removing elements from either end equally well, they can serve both as queues and as stacks. Python’s objects are implemented as doubly-linked lists, which gives them excellent and consistent performance for inserting and deleting elements but poor O(n) performance for randomly accessing elements in the middle of a stack. Overall, is a great choice if you’re looking for a stack data structure in Python’s standard library that has the performance characteristics of a linked-list implementation: The stack implementation in the Python standard library is synchronized and provides locking semantics to support multiple concurrent producers and consumers. Besides , the module contains several other classes that implement multi-producer, multi-consumer queues that are useful for parallel computing. Depending on your use case, the locking semantics might be helpful, or they might just incur unneeded overhead. In this case, you’d be better off using a or a as a general-purpose stack: As you’ve seen, Python ships with several implementations for a stack data structure. All of them have slightly different characteristics as well as performance and usage trade-offs. If you’re not looking for parallel processing support (or if you don’t want to handle locking and unlocking manually), then your choice comes down to the built-in type or . The difference lies in the data structure used behind the scenes and overall ease of use. is backed by a dynamic array, which makes it great for fast random access but requires occasional resizing when elements are added or removed. The list over-allocates its backing storage so that not every push or pop requires resizing, and you get an amortized O(1) time complexity for these operations. But you do need to be careful to only insert and remove items using and . Otherwise, performance slows down to O(n). is backed by a doubly-linked list, which optimizes appends and deletes at both ends and provides consistent O(1) performance for these operations. Not only is its performance more stable, the class is also easier to use because you don’t have to worry about adding or removing items from the wrong end. In summary, is an excellent choice for implementing a stack (LIFO queue) in Python.\n\nIn this section, you’ll see how to implement a First-In/First-Out (FIFO) queue data structure using only built-in data types and classes from the Python standard library. A queue is a collection of objects that supports fast FIFO semantics for inserts and deletes. The insert and delete operations are sometimes called enqueue and dequeue. Unlike lists or arrays, queues typically don’t allow for random access to the objects they contain. Imagine a line of Pythonistas waiting to pick up their conference badges on day one of PyCon registration. As new people enter the conference venue and queue up to receive their badges, they join the line (enqueue) at the back of the queue. Developers receive their badges and conference swag bags and then exit the line (dequeue) at the front of the queue. Another way to memorize the characteristics of a queue data structure is to think of it as a pipe. You add ping-pong balls to one end, and they travel to the other end, where you remove them. While the balls are in the queue (a solid metal pipe) you can’t get at them. The only way to interact with the balls in the queue is to add new ones at the back of the pipe (enqueue) or to remove them at the front (dequeue). Queues are similar to stacks. The difference between them lies in how items are removed. With a queue, you remove the item least recently added (FIFO) but with a stack, you remove the item most recently added (LIFO). Performance-wise, a proper queue implementation is expected to take O(1) time for insert and delete operations. These are the two main operations performed on a queue, and in a correct implementation, they should be fast. Queues have a wide range of applications in algorithms and often help solve scheduling and parallel programming problems. A short and beautiful algorithm using a queue is breadth-first search (BFS) on a tree or graph data structure. Scheduling algorithms often use priority queues internally. These are specialized queues. Instead of retrieving the next element by insertion time, a priority queue retrieves the highest-priority element. The priority of individual elements is decided by the queue based on the ordering applied to their keys. A regular queue, however, won’t reorder the items it carries. Just like in the pipe example, you get out what you put in, and in exactly that order. Python ships with several queue implementations that each have slightly different characteristics. Let’s review them. It’s possible to use a regular as a queue, but this is not ideal from a performance perspective. Lists are quite slow for this purpose because inserting or deleting an element at the beginning requires shifting all the other elements by one, requiring O(n) time. Therefore, I would not recommend using a as a makeshift queue in Python unless you’re dealing with only a small number of elements: The class implements a double-ended queue that supports adding and removing elements from either end in O(1) time (non-amortized). Because deques support adding and removing elements from either end equally well, they can serve both as queues and as stacks. Python’s objects are implemented as doubly-linked lists. This gives them excellent and consistent performance for inserting and deleting elements, but poor O(n) performance for randomly accessing elements in the middle of the stack. As a result, is a great default choice if you’re looking for a queue data structure in Python’s standard library: The implementation in the Python standard library is synchronized and provides locking semantics to support multiple concurrent producers and consumers. The module contains several other classes implementing multi-producer, multi-consumer queues that are useful for parallel computing. Depending on your use case, the locking semantics might be helpful or just incur unneeded overhead. In this case, you’d be better off using as a general-purpose queue: is a shared job queue implementation that allows queued items to be processed in parallel by multiple concurrent workers. Process-based parallelization is popular in CPython due to the global interpreter lock (GIL) that prevents some forms of parallel execution on a single interpreter process. As a specialized queue implementation meant for sharing data between processes, makes it easy to distribute work across multiple processes in order to work around the GIL limitations. This type of queue can store and transfer any pickleable object across process boundaries: Python includes several queue implementations as part of the core language and its standard library. objects can be used as queues, but this is generally not recommended due to slow performance. If you’re not looking for parallel processing support, then the implementation offered by is an excellent default choice for implementing a FIFO queue data structure in Python. It provides the performance characteristics you’d expect from a good queue implementation and can also be used as a stack (LIFO queue).\n\nA priority queue is a container data structure that manages a set of records with totally-ordered keys to provide quick access to the record with the smallest or largest key in the set. You can think of a priority queue as a modified queue. Instead of retrieving the next element by insertion time, it retrieves the highest-priority element. The priority of individual elements is decided by the order applied to their keys. Priority queues are commonly used for dealing with scheduling problems. For example, you might use them to give precedence to tasks with higher urgency. Think about the job of an operating system task scheduler: Ideally, higher-priority tasks on the system (such as playing a real-time game) should take precedence over lower-priority tasks (such as downloading updates in the background). By organizing pending tasks in a priority queue that uses task urgency as the key, the task scheduler can quickly select the highest-priority tasks and allow them to run first. In this section, you’ll see a few options for how you can implement priority queues in Python using built-in data structures or data structures included in Python’s standard library. Each implementation will have its own upsides and downsides, but in my mind there’s a clear winner for most common scenarios. Let’s find out which one it is. You can use a sorted to quickly identify and delete the smallest or largest element. The downside is that inserting new elements into a list is a slow O(n) operation. While the insertion point can be found in O(log n) time using in the standard library, this is always dominated by the slow insertion step. Maintaining the order by appending to the list and re-sorting also takes at least O(n log n) time. Another downside is that you must manually take care of re-sorting the list when new elements are inserted. It’s easy to introduce bugs by missing this step, and the burden is always on you, the developer. This means sorted lists are only suitable as priority queues when there will be few insertions: # Remember to re-sort every time a new element is inserted, is a binary heap implementation usually backed by a plain , and it supports insertion and extraction of the smallest element in O(log n) time. This module is a good choice for implementing priority queues in Python. Since technically provides only a min-heap implementation, extra steps must be taken to ensure sort stability and other features typically expected from a practical priority queue: uses internally and shares the same time and space complexities. The difference is that is synchronized and provides locking semantics to support multiple concurrent producers and consumers. Depending on your use case, this might be helpful, or it might just slow your program down slightly. In any case, you might prefer the class-based interface provided by over the function-based interface provided by : Python includes several priority queue implementations ready for you to use. stands out from the pack with a nice object-oriented interface and a name that clearly states its intent. It should be your preferred choice. If you’d like to avoid the locking overhead of , then using the module directly is also a good option."
    },
    {
        "link": "https://geeksforgeeks.org/implementation-of-stack-in-python-using-list",
        "document": "In Python list is one of the most widely used and popular built-in datatypes that represents ordered and mutable collections of elements. List also allows to storage of duplicate items. Lists are widely used for various tasks in Python programming, such as storing collections of data, implementing stacks and queues, and handling sequences of values.\n\nUsing List As Stack In Python\n\nStack is a linear data structure that follows the LIFO principle which means Last in First Out. In the stack insertion of a new element and removal of an existing element takes place at the same end represented as the top of the stack.\n• push() :- This is a method to insert an element into the stack\n• pop() :- This is a method to remove an element from the stack\n• top() :- This is a method that returns the top element of the stack.\n• isEmpty() :- This is a method that returns true if the stack is empty else false.\n• size() :- This is a method that returns the size of the stack.\n\nBelow are some of the examples by which we can use the list as a stack in Python:\n\nIn this operation, we push data to the stack which is implemented by a list. As we all know stack data structure follows the LIFO principle i.e., Last in First Out.\n\nThe pop Operation in stack use to remove the last element from the stack. Here, we will use pop() function to perform pop operation in list. If the stack is empty it return none.\n\nThe top() method of stack used to print the topmost element of the stack. It return the last or recently pushed element from the last.\n\nThe isEmpty method of stack used to check the stack is empty or not. If the stack is empty it return 1 else it returns 0.\n\nIn this example, we will implement a stack class and we will implement all the stack opertion like push, pop, top, empty, and size by the help of class method."
    },
    {
        "link": "https://codingnomads.com/python-301-use-a-list-in-stack-or-queue",
        "document": "Previously, you've learned how to build stacks and queues by defining your own Python classes. But Python is a high-level language, so why not take a look at this task from the other side? Because, as it turns out, you already know a Python data structure that makes it relatively straightforward to build both stacks and queues: the list.\n\nEarlier, you learned that for a stack to do its thing, you need at least two methods:\n• Push adds an element to the collection.\n• Pop removes the most recently added element from the collection.\n\nOne of the two method names might already sound familiar. Python lists have a method that does exactly what a stack expects a pop method to do. Another list method, , has a different name but does what a stack expects a push method to do:\n\nAs shown in the code snippet above, you can use Python's list data type as a stack without any modifications by using two native list methods:\n• allows you to add an element to the end of the list. The method returns .\n• allows you to remove the right-most element from the list. The method returns the element that you removed.\n\nWith a Python list, you can also check whether the list is empty and view the topmost item without removing it from the list, which are two other common functionalities implemented in a stack:\n\nThe list allows all the fundamental operations that you'd expect from a stack. Note that a Python list isn't equal to a stack. You can do more with the list, for example, adding and removing elements at different spots of the collection, not just the end.\n\nTherefore, you are just using the Python list as a stack by limiting yourself to adding and removing elements only with and , respectively.\n\nJust like the stack, you can also implement the functionality of a queue using a Python :\n\nIn this example, you're using two native list methods to implement the functionality of a queue with a Python list:\n• allows you to add elements to the end of the collection.\n• , used with an argument of , allows you to remove the first element from the collection.\n\nJust like in the stack example above, you can also check whether your is empty and peek at the first item of the list without removing it. If you stick to using the methods in the way described above, then you're functionally using your Python list as a queue.\n\nNote that using is very slow, so you really shouldn't use this approach to model a queue in Python!\n\nUsing a Python list as a queuehas very poor performance. This is because of how Python lists are designed. If you add an item to the beginning of a list, Python needs to shift all the other items, which means that the amount of time it takes will increase significantly if your list grows larger. It becomes very costly when you're working with large amounts of data.\n\nUsing a Python list as a stack is not such a bad implementation. However, there are also some issues that come with it. A Python list isn't strictly a stack because you can still access items at different indices of the list:\n\nIn a true stack, you'd have to pop all items that were added after in order to access it. When you use a Python list, you can directly access the value. However, that comes with an overhead.\n\nAlso, because you're using a data structure that is designed to be much more than just a stack or just a queue, you need to explicitly limit yourself to a certain use case. That comes with problems when using it, as well as with performance hits.\n\nBut because of how Python lists are designed, the performance penalties you get from using a list as a stack are much less intense than if you were using a list as a queue. Don't do it; there are better ways!\n\nSoon, you'll learn how to use modules in Python's standard library to better model specific data structures that go beyond the more versatile data types, such as a list.\n• A can be used as a stack and a queue\n• Using a list as a queue has very low performance\n• A list as a stack works well for performance\n• Since each element can always be accessed in a list, there is risk when using it as a stack or queue"
    }
]