[
    {
        "link": "https://docs.github.com/actions/security-guides/automatic-token-authentication",
        "document": "At the start of each workflow job, GitHub automatically creates a unique secret to use in your workflow. You can use the to authenticate in the workflow job.\n\nWhen you enable GitHub Actions, GitHub installs a GitHub App on your repository. The secret is a GitHub App installation access token. You can use the installation access token to authenticate on behalf of the GitHub App installed on your repository. The token's permissions are limited to the repository that contains your workflow. For more information, see Permissions for the .\n\nBefore each job begins, GitHub fetches an installation access token for the job. The expires when a job finishes or after a maximum of 24 hours.\n\nThe token is also available in the context. For more information, see Accessing contextual information about workflow runs.\n\nUsing the in a workflow\n\nYou can use the by using the standard syntax for referencing secrets: . Examples of using the include passing the token as an input to an action, or using it to make an authenticated GitHub API request.\n\nWhen you use the repository's to perform tasks, events triggered by the , with the exception of and , will not create a new workflow run. This prevents you from accidentally creating recursive workflow runs. For example, if a workflow run pushes code using the repository's , a new workflow will not run even when the repository contains a workflow configured to run when events occur.\n\nCommits pushed by a GitHub Actions workflow that uses the do not trigger a GitHub Pages build.\n\nExample 1: passing the as an input\n\nThis example workflow uses the GitHub CLI, which requires the as the value for the input parameter:\n\nYou can use the to make authenticated API calls. This example workflow creates an issue using the GitHub REST API:\n\nFor information about the API endpoints GitHub Apps can access with each permission, see Permissions required for GitHub Apps.\n\nThe following table shows the permissions granted to the by default. People with admin permissions to an enterprise, organization, or repository, can set the default permissions to be either permissive or restricted. For information on how to set the default permissions for the for your enterprise, organization, or repository, see Enforcing policies for GitHub Actions in your enterprise, Disabling or limiting GitHub Actions for your organization, or Managing GitHub Actions settings for a repository.\n\nModifying the permissions for the\n\nYou can modify the permissions for the in individual workflow files. If the default permissions for the are restrictive, you may have to elevate the permissions to allow some actions and commands to run successfully. If the default permissions are permissive, you can edit the workflow file to remove some permissions from the . As a good security practice, you should grant the the least required access.\n\nYou can see the permissions that had for a specific job in the \"Set up job\" section of the workflow run log. For more information, see Using workflow run logs.\n\nYou can use the key in your workflow file to modify permissions for the for an entire workflow or for individual jobs. This allows you to configure the minimum required permissions for a workflow or job.\n\nYou can use the key to add and remove read permissions for forked repositories, but typically you can't grant write access. The exception to this behavior is where an admin user has selected the Send write tokens to workflows from pull requests option in the GitHub Actions settings. For more information, see Managing GitHub Actions settings for a repository.\n\nThe two workflow examples earlier in this article show the key being used at the job level, as it is best practice to limit the permissions' scope.\n\nFor full details of the key, see Workflow syntax for GitHub Actions.\n\nHow the permissions are calculated for a workflow job\n\nThe permissions for the are initially set to the default setting for the enterprise, organization, or repository. If the default is set to the restricted permissions at any of these levels then this will apply to the relevant repositories. For example, if you choose the restricted default at the organization level then all repositories in that organization will use the restricted permissions as the default. The permissions are then adjusted based on any configuration within the workflow file, first at the workflow level and then at the job level. Finally, if the workflow was triggered by a pull request from a forked repository, and the Send write tokens to workflows from pull requests setting is not selected, the permissions are adjusted to change any write permissions to read only.\n\nIf you need a token that requires permissions that aren't available in the , you can create a GitHub App and generate an installation access token within your workflow. For more information, see Making authenticated API requests with a GitHub App in a GitHub Actions workflow. Alternatively, you can create a personal access token, store it as a secret in your repository, and use the token in your workflow with the syntax. For more information, see Managing your personal access tokens and Using secrets in GitHub Actions."
    },
    {
        "link": "https://docs.github.com/en/packages/managing-github-packages-using-github-actions-workflows/publishing-and-installing-a-package-with-github-actions",
        "document": "GitHub Actions help you automate your software development workflows in the same place you store code and collaborate on pull requests and issues. You can write individual tasks, called actions, and combine them to create a custom workflow. With GitHub Actions you can build end-to-end continuous integration (CI) and continuous deployment (CD) capabilities directly in your repository. For more information, see Writing workflows.\n\nYou can extend the CI and CD capabilities of your repository by publishing or installing packages as part of your workflow.\n\nSome GitHub Packages registries support granular permissions. This means you can choose to allow packages to be scoped to a user or an organization, or linked to a repository. For the list of registries that support granular permissions, see About permissions for GitHub Packages.\n\nFor registries that support granular permissions, if your GitHub Actions workflow is using a personal access token to authenticate to a registry, we highly recommend you update your workflow to use the . For guidance on updating your workflows that authenticate to a registry with a personal access token, see Publishing and installing a package with GitHub Actions.\n\nYou can use a in a GitHub Actions workflow to delete or restore a package using the REST API, if the token has permission to the package. Repositories that publish packages using a workflow, and repositories that you have explicitly connected to packages, are automatically granted permission to packages in the repository.\n\nFor more information about the , see Automatic token authentication. For more information about the best practices when using a registry in actions, see Security hardening for GitHub Actions.\n\nSome GitHub Packages registries only support repository-scoped permissions, and do not support granular permissions. For a list of these registries, see About permissions for GitHub Packages.\n\nIf you want your workflow to access a GitHub Packages registry that does not support granular permissions, then we recommend using the that GitHub automatically creates for your repository when you enable GitHub Actions. You should set the permissions for this access token in the workflow file to grant read access for the scope and write access for the scope. For forks, the is granted read access for the parent repository. For more information, see Automatic token authentication.\n\nYou can reference the in your workflow file using the context. For more information, see Automatic token authentication.\n\nRegistries that support granular permissions allow users to create and administer packages as free-standing resources at the organization level. Packages can be scoped to an organization or personal account and you can customize access to each of your packages separately from repository permissions.\n\nAll workflows accessing registries that support granular permissions should use the instead of a personal access token. For more information about security best practices, see Security hardening for GitHub Actions.\n\nWhen you enable GitHub Actions, GitHub installs a GitHub App on your repository. The secret is a GitHub App installation access token. You can use the installation access token to authenticate on behalf of the GitHub App installed on your repository. The token's permissions are limited to the repository that contains your workflow. For more information, see Automatic token authentication.\n\nGitHub Packages allows you to push and pull packages through the available to a GitHub Actions workflow.\n\nDefault permissions and access settings for packages modified through workflows\n\nFor packages in registries that support granular permissions, when you create, install, modify, or delete a package through a workflow, there are some default permission and access settings used to ensure admins have access to the workflow. You can adjust these access settings as well. For the list of registries that support granular permissions, see About permissions for GitHub Packages.\n\nFor example, by default if a workflow creates a package using the , then:\n• The package inherits the visibility and permissions model of the repository where the workflow is run.\n• Repository admins where the workflow is run become the admins of the package once the package is created.\n\nThese are more examples of how default permissions work for workflows that manage packages.\n\nYou can also adjust access to packages in a more granular way or adjust some of the default permissions behavior. For more information, see Configuring a package's access control and visibility.\n\nYou can use GitHub Actions to automatically publish packages as part of your continuous integration (CI) flow. This approach to continuous deployment (CD) allows you to automate the creation of new package versions, if the code meets your quality standards. For example, you could create a workflow that runs CI tests every time a developer pushes code to a particular branch. If the tests pass, the workflow can publish a new package version to GitHub Packages.\n\nConfiguration steps vary by package client. For general information about configuring a workflow for GitHub Actions, see Writing workflows.\n\nThe following example demonstrates how you can use GitHub Actions to build your app, and then automatically create a Docker image and publish it to GitHub Packages. The relevant settings are explained in the code. For full details about each element in a workflow, see Workflow syntax for GitHub Actions.\n\nCreate a new workflow file in your repository (such as ), and add the following YAML.\n\n# name: Create and publish a Docker image # Configures this workflow to run every time a change is pushed to the branch called `release`. on: push: branches: ['release'] # Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds. env: REGISTRY: ghcr.io IMAGE_NAME: ${{ github.repository }} # There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu. jobs: build-and-push-image: runs-on: ubuntu-latest # Sets the permissions granted to the `GITHUB_TOKEN` for the actions in this job. permissions: contents: read packages: write attestations: write id-token: write # steps: - name: Checkout repository uses: actions/checkout@v4 # Uses the `docker/login-action` action to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here. - name: Log in to the Container registry uses: docker/login-action@65b78e6e13532edd9afa3aa52ac7964289d1a9c1 with: registry: ${{ env.REGISTRY }} username: ${{ github.actor }} password: ${{ secrets.GITHUB_TOKEN }} # This step uses [docker/metadata-action](https://github.com/docker/metadata-action#about) to extract tags and labels that will be applied to the specified image. The `id` \"meta\" allows the output of this step to be referenced in a subsequent step. The `images` value provides the base name for the tags and labels. - name: Extract metadata (tags, labels) for Docker id: meta uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfbe97b2010124a938b7 with: images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }} # This step uses the `docker/build-push-action` action to build the image, based on your repository's `Dockerfile`. If the build succeeds, it pushes the image to GitHub Packages. # It uses the `context` parameter to define the build's context as the set of files located in the specified path. For more information, see [Usage](https://github.com/docker/build-push-action#usage) in the README of the `docker/build-push-action` repository. # It uses the `tags` and `labels` parameters to tag and label the image with the output from the \"meta\" step. - name: Build and push Docker image id: push uses: docker/build-push-action@f2a1d5e99d037542a71f64918e516c093c6f3fc4 with: context: . push: true tags: ${{ steps.meta.outputs.tags }} labels: ${{ steps.meta.outputs.labels }} # This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, see [Using artifact attestations to establish provenance for builds](/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds). - name: Generate artifact attestation uses: actions/attest-build-provenance@v2 with: subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME}} subject-digest: ${{ steps.push.outputs.digest }} push-to-registry: true Configures this workflow to run every time a change is pushed to the branch called . Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds. There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu. Sets the permissions granted to the for the actions in this job. Uses the action to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here. This step uses docker/metadata-action to extract tags and labels that will be applied to the specified image. The \"meta\" allows the output of this step to be referenced in a subsequent step. The value provides the base name for the tags and labels. This step uses the action to build the image, based on your repository's . If the build succeeds, it pushes the image to GitHub Packages. It uses the parameter to define the build's context as the set of files located in the specified path. For more information, see Usage in the README of the repository. It uses the and parameters to tag and label the image with the output from the \"meta\" step. This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, see Using artifact attestations to establish provenance for builds.\n\nThis new workflow will run automatically every time you push a change to a branch named in the repository. You can view the progress in the Actions tab.\n\nA few minutes after the workflow has completed, the new package will be visible in your repository. To find your available packages, see Viewing packages.\n\nYou can install packages as part of your CI flow using GitHub Actions. For example, you could configure a workflow so that anytime a developer pushes code to a pull request, the workflow resolves dependencies by downloading and installing packages hosted by GitHub Packages. Then, the workflow can run CI tests that require the dependencies.\n\nInstalling packages hosted by GitHub Packages through GitHub Actions requires minimal configuration or additional authentication when you use the . Data transfer is also free when an action installs a package. For more information, see About billing for GitHub Packages.\n\nConfiguration steps vary by package client. For general information about configuring a workflow for GitHub Actions, see Writing workflows.\n\nGitHub Packages supports the for easy and secure authentication in your workflows. If you're using a registry that supports granular permissions, and your workflow is using a personal access token to authenticate to the registry, then we highly recommend you update your workflow to use the .\n\nFor more information about the , see Automatic token authentication.\n\nUsing the , instead of a personal access token (classic) with the scope, increases the security of your repository as you don't need to use a long-lived personal access token that offers unnecessary access to the repository where your workflow is run. For more information about security best practices, see Security hardening for GitHub Actions.\n• To ensure your package has access to your workflow, you must add the repository where the workflow is stored to your package. Under \"Manage Actions access\", click Add repository and search for the repository you want to add. Adding a repository to your package by using the Add Repository button under \"Manage Actions access\" in the package's settings is different than connecting your package to a repository. For more information, see Configuring a package's access control and visibility and Connecting a repository to a package.\n• Optionally, use the Role drop-down menu to select the default access level that you'd like the repository to have to your package.\n• Open your workflow file. On the line where you log in to the registry, replace your personal access token with .\n\nFor example, this workflow publishes a Docker image to the Container registry and uses to authenticate. For more information, see Set up Automated Builds in the Docker documentation."
    },
    {
        "link": "https://docs.github.com/en/actions/security-for-github-actions/security-guides/security-hardening-for-github-actions",
        "document": "This guide explains how to configure security hardening for certain GitHub Actions features. If the GitHub Actions concepts are unfamiliar, see Understanding GitHub Actions.\n\nSensitive values should never be stored as plaintext in workflow files, but rather as secrets. Secrets can be configured at the organization, repository, or environment level, and allow you to store sensitive information in GitHub.\n\nSecrets use Libsodium sealed boxes, so that they are encrypted before reaching GitHub. This occurs when the secret is submitted using the UI or through the REST API. This client-side encryption helps minimize the risks related to accidental logging (for example, exception logs and request logs, among others) within GitHub's infrastructure. Once the secret is uploaded, GitHub is then able to decrypt it so that it can be injected into the workflow runtime.\n\nTo help prevent accidental disclosure, GitHub uses a mechanism that attempts to redact any secrets that appear in run logs. This redaction looks for exact matches of any configured secrets used within the job, as well as common encodings of the values, such as Base64. However, because there are multiple ways a secret value can be transformed, this redaction is not guaranteed. Additionally, the runner can only redact secrets used within the current job. As a result, there are certain proactive steps and good practices you should follow to help ensure secrets are redacted, and to limit other risks associated with secrets:\n• Never use structured data as a secret\n• Structured data can cause secret redaction within logs to fail, because redaction largely relies on finding an exact match for the specific secret value. For example, do not use a blob of JSON, XML, or YAML (or similar) to encapsulate a secret value, as this significantly reduces the probability the secrets will be properly redacted. Instead, create individual secrets for each sensitive value.\n• Register all secrets used within workflows\n• If a secret is used to generate another sensitive value within a workflow, that generated value should be formally registered as a secret, so that it will be redacted if it ever appears in the logs. For example, if using a private key to generate a signed JWT to access a web API, be sure to register that JWT as a secret or else it won’t be redacted if it ever enters the log output.\n• Registering secrets applies to any sort of transformation/encoding as well. If your secret is transformed in some way (such as Base64 or URL-encoded), be sure to register the new value as a secret too.\n• Audit how secrets are handled\n• Audit how secrets are used, to help ensure they’re being handled as expected. You can do this by reviewing the source code of the repository executing the workflow, and checking any actions used in the workflow. For example, check that they’re not sent to unintended hosts, or explicitly being printed to log output.\n• View the run logs for your workflow after testing valid/invalid inputs, and check that secrets are properly redacted, or not shown. It's not always obvious how a command or tool you’re invoking will send errors to and , and secrets might subsequently end up in error logs. As a result, it is good practice to manually review the workflow logs after testing valid and invalid inputs. For information on how to clean up workflow logs that may unintentionally contain sensitive data, see Using workflow run logs.\n• Use credentials that are minimally scoped\n• Make sure the credentials being used within workflows have the least privileges required, and be mindful that any user with write access to your repository has read access to all secrets configured in your repository.\n• Actions can use the by accessing it from the context. For more information, see Accessing contextual information about workflow runs. You should therefore make sure that the is granted the minimum required permissions. It's good security practice to set the default permission for the to read access only for repository contents. The permissions can then be increased, as required, for individual jobs within the workflow file. For more information, see Automatic token authentication.\n• Audit and rotate registered secrets\n• Periodically review the registered secrets to confirm they are still required. Remove those that are no longer needed.\n• Rotate secrets periodically to reduce the window of time during which a compromised secret is valid.\n• Consider requiring review for access to secrets\n• You can use required reviewers to protect environment secrets. A workflow job cannot access environment secrets until approval is granted by a reviewer. For more information about storing secrets in environments or requiring reviews for environments, see Using secrets in GitHub Actions and Managing environments for deployment.\n\nUsing to monitor changes\n\nYou can use the feature to control how changes are made to your workflow files. For example, if all your workflow files are stored in , you can add this directory to the code owners list, so that any proposed changes to these files will first require approval from a designated reviewer.\n\nFor more information, see About code owners.\n\nWhen creating workflows, custom actions, and composite actions, you should always consider whether your code might execute untrusted input from attackers. This can occur when an attacker adds malicious commands and scripts to a context. When your workflow runs, those strings might be interpreted as code which is then executed on the runner.\n\nAttackers can add their own malicious content to the context, which should be treated as potentially untrusted input. These contexts typically end with , , , , , , , , , and . For example: , or .\n\nYou should ensure that these values do not flow directly into workflows, actions, API calls, or anywhere else where they could be interpreted as executable code. By adopting the same defensive programming posture you would use for any other privileged application code, you can help security harden your use of GitHub Actions. For information on some of the steps an attacker could take, see Security hardening for GitHub Actions.\n\nIn addition, there are other less obvious sources of potentially untrusted input, such as branch names and email addresses, which can be quite flexible in terms of their permitted content. For example, would be a valid branch name and would be a possible attack vector for a target repository.\n\nThe following sections explain how you can help mitigate the risk of script injection.\n\nA script injection attack can occur directly within a workflow's inline script. In the following example, an action uses an expression to test the validity of a pull request title, but also adds the risk of script injection:\n\nThis example is vulnerable to script injection because the command executes within a temporary shell script on the runner. Before the shell script is run, the expressions inside are evaluated and then substituted with the resulting values, which can make it vulnerable to shell command injection.\n\nTo inject commands into this workflow, the attacker could create a pull request with a title of :\n\nIn this example, the character is used to interrupt the statement, allowing the command to be executed on the runner. You can see the output of the command in the log:\n\nThere are a number of different approaches available to help you mitigate the risk of script injection:\n\nUsing an action instead of an inline script (recommended)\n\nThe recommended approach is to create a JavaScript action that processes the context value as an argument. This approach is not vulnerable to the injection attack, since the context value is not used to generate a shell script, but is instead passed to the action as an argument:\n\nFor inline scripts, the preferred approach to handling untrusted input is to set the value of the expression to an intermediate environment variable.\n\nThe following example uses Bash to process the value as an environment variable:\n\nIn this example, the attempted script injection is unsuccessful, which is reflected by the following lines in the log:\n\nWith this approach, the value of the expression is stored in memory and used as a variable, and doesn't interact with the script generation process. In addition, consider using double quote shell variables to avoid word splitting, but this is one of many general recommendations for writing shell scripts, and is not specific to GitHub Actions.\n\nFor more information, see About code scanning and Configuring advanced setup for code scanning.\n\nTo help mitigate the risk of an exposed token, consider restricting the assigned permissions. For more information, see Automatic token authentication.\n\nIf your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), you can configure your workflows to authenticate directly to the cloud provider. This will let you stop storing these credentials as long-lived secrets and provide other security benefits. For more information, see About security hardening with OpenID Connect.\n\nThe individual jobs in a workflow can interact with (and compromise) other jobs. For example, a job querying the environment variables used by a later job, writing files to a shared directory that a later job processes, or even more directly by interacting with the Docker socket and inspecting other running containers and executing commands in them.\n\nThis means that a compromise of a single action within a workflow can be very significant, as that compromised action would have access to all secrets configured on your repository, and may be able to use the to write to the repository. Consequently, there is significant risk in sourcing actions from third-party repositories on GitHub. For information on some of the steps an attacker could take, see Security hardening for GitHub Actions.\n\nYou can help mitigate this risk by following these good practices:\n• Pinning an action to a full length commit SHA is currently the only way to use an action as an immutable release. Pinning to a particular SHA helps mitigate the risk of a bad actor adding a backdoor to the action's repository, as they would need to generate a SHA-1 collision for a valid Git object payload. When selecting a SHA, you should verify it is from the action's repository and not a repository fork.\n• Audit the source code of the action Ensure that the action is handling the content of your repository and secrets as expected. For example, check that secrets are not sent to unintended hosts, or are not inadvertently logged.\n• Pin actions to a tag only if you trust the creator Although pinning to a commit SHA is the most secure option, specifying a tag is more convenient and is widely used. If you’d like to specify a tag, then be sure that you trust the action's creators. The ‘Verified creator’ badge on GitHub Marketplace is a useful signal, as it indicates that the action was written by a team whose identity has been verified by GitHub. Note that there is risk to this approach even if you trust the author, because a tag can be moved or deleted if a bad actor gains access to the repository storing the action.\n\nThe same principles described above for using third-party actions also apply to using third-party workflows. You can help mitigate the risks associated with reusing workflows by following the same good practices outlined above. For more information, see Reusing workflows.\n\nYou can use Dependabot to ensure that references to actions and reusable workflows used in your repository are kept up to date. Actions are often updated with bug fixes and new features to make automated processes faster, safer, and more reliable. Dependabot takes the effort out of maintaining your dependencies as it does this automatically for you. For more information, see Keeping your actions up to date with Dependabot and About Dependabot security updates.\n\nYou can choose to allow or prevent GitHub Actions workflows from creating or approving pull requests. Allowing workflows, or any other automation, to create or approve pull requests could be a security risk if the pull request is merged without proper oversight.\n\nFor more information on how to configure this setting, see Disabling or limiting GitHub Actions for your organization, and Managing GitHub Actions settings for a repository.\n\nCode scanning can automatically detect and suggest improvements for common vulnerable patterns used in GitHub Actions workflows. For more information on how to enable code scanning, see Configuring default setup for code scanning.\n\nScorecards is an automated security tool that flags risky supply chain practices. You can use the Scorecards action and workflow template to follow best security practices. Once configured, the Scorecards action runs automatically on repository changes, and alerts developers about risky supply chain practices using the built-in code scanning experience. The Scorecards project runs a number of checks, including script injection attacks, token permissions, and pinned actions.\n\nThese sections consider some of the steps an attacker can take if they're able to run malicious commands on a GitHub Actions runner.\n\nWorkflows triggered from a forked repository using the event have read-only permissions and have no access to secrets. However, these permissions differ for various event triggers such as , , and from a branch within the repository, where the attacker could attempt to steal repository secrets or use the write permission of the job's .\n• If the secret or token is set to an environment variable, it can be directly accessed through the environment using .\n• If the secret is used directly in an expression, the generated shell script is stored on-disk and is accessible.\n• For a custom action, the risk can vary depending on how a program is using the secret it obtained from the argument:\n\nAlthough GitHub Actions scrubs secrets from memory that are not referenced in the workflow (or an included action), the and any referenced secrets can be harvested by a determined attacker.\n\nAn attacker can exfiltrate any stolen secrets or other data from the runner. To help prevent accidental secret disclosure, GitHub Actions automatically redact secrets printed to the log, but this is not a true security boundary because secrets can be intentionally sent to the log. For example, obfuscated secrets can be exfiltrated using . In addition, since the attacker may run arbitrary commands, they could use HTTP requests to send secrets or other repository data to an external server.\n\nIt is possible for an attacker to steal a job's . The GitHub Actions runner automatically receives a generated with permissions that are limited to just the repository that contains the workflow, and the token expires after the job has completed. Once expired, the token is no longer useful to an attacker. To work around this limitation, they can automate the attack and perform it in fractions of a second by calling an attacker-controlled server with the token, for example: .\n\nThe attacker server can use the GitHub API to modify repository content, including releases, if the assigned permissions of are not restricted.\n\nGitHub Actions is intentionally scoped for a single repository at a time. The grants the same level of access as a write-access user, because any write-access user can access this token by creating or modifying a workflow file, elevating the permissions of the if necessary. Users have specific permissions for each repository, so allowing the for one repository to grant access to another would impact the GitHub permission model if not implemented carefully. Similarly, caution must be taken when adding GitHub authentication tokens to a workflow, because this can also affect the GitHub permission model by inadvertently granting broad access to collaborators.\n\nIf your organization is owned by an enterprise account, then you can share and reuse GitHub Actions by storing them in internal repositories. For more information, see Sharing actions and workflows with your enterprise.\n\nYou can perform other privileged, cross-repository interactions by referencing a GitHub authentication token or SSH key as a secret within the workflow. Because many authentication token types do not allow for granular access to specific resources, there is significant risk in using the wrong token type, as it can grant much broader access than intended.\n\nThis list describes the recommended approaches for accessing repository data within a workflow, in descending order of preference:\n• The\n• This token is intentionally scoped to the single repository that invoked the workflow, and can have the same level of access as a write-access user on the repository. The token is created before each job begins and expires when the job is finished. For more information, see Automatic token authentication.\n• The should be used whenever possible.\n• Repository deploy key\n• Deploy keys are one of the only credential types that grant read or write access to a single repository, and can be used to interact with another repository within a workflow. For more information, see Managing deploy keys.\n• Note that deploy keys can only clone and push to the repository using Git, and cannot be used to interact with the REST or GraphQL API, so they may not be appropriate for your requirements.\n• GitHub App tokens\n• GitHub Apps can be installed on select repositories, and even have granular permissions on the resources within them. You could create a GitHub App internal to your organization, install it on the repositories you need access to within your workflow, and authenticate as the installation within your workflow to access those repositories. For more information, see Making authenticated API requests with a GitHub App in a GitHub Actions workflow.\n• personal access tokens\n• You should never use a personal access token (classic). These tokens grant access to all repositories within the organizations that you have access to, as well as all personal repositories in your personal account. This indirectly grants broad access to all write-access users of the repository the workflow is in.\n• If you do use a personal access token, you should never use a personal access token from your own account. If you later leave an organization, workflows using this token will immediately break, and debugging this issue can be challenging. Instead, you should use a fine-grained personal access token for a new account that belongs to your organization and that is only granted access to the specific repositories that are needed for the workflow. Note that this approach is not scalable and should be avoided in favor of alternatives, such as deploy keys.\n• SSH keys on a personal account\n• Workflows should never use the SSH keys on a personal account. Similar to personal access tokens (classic), they grant read/write permissions to all of your personal repositories as well as all the repositories you have access to through organization membership. This indirectly grants broad access to all write-access users of the repository the workflow is in. If you're intending to use an SSH key because you only need to perform repository clones or pushes, and do not need to interact with public APIs, then you should use individual deploy keys instead.\n\nGitHub-hosted runners take measures to help you mitigate security risks.\n\nFor GitHub-hosted runners created from images maintained by GitHub, you can view a software bill of materials (SBOM) to see what software was pre-installed on the runner. You can provide your users with the SBOM which they can run through a vulnerability scanner to validate if there are any vulnerabilities in the product. If you are building artifacts, you can include this SBOM in your bill of materials for a comprehensive list of everything that went into creating your software.\n\nSBOMs are available for Ubuntu, Windows, and macOS runner images maintained by GitHub. You can locate the SBOM for your build in the release assets at https://github.com/actions/runner-images/releases. An SBOM with a filename in the format of can be found in the attachments of each release.\n\nFor third-party images, such as the images for ARM-powered runners, you can find details of the software that's included in the image in the repository.\n\nGitHub-hosted runners are provisioned with an file that blocks network access to various cryptocurrency mining pools and malicious sites. Hosts such as MiningMadness.com and cpu-pool.com are rerouted to localhost so that they do not present a significant security risk. For more information, see Using GitHub-hosted runners.\n\nGitHub-hosted runners execute code within ephemeral and clean isolated virtual machines, meaning there is no way to persistently compromise this environment, or otherwise gain access to more information than was placed in this environment during the bootstrap process.\n\nSelf-hosted runners for GitHub do not have guarantees around running in ephemeral clean virtual machines, and can be persistently compromised by untrusted code in a workflow.\n\nAs a result, self-hosted runners should almost never be used for public repositories on GitHub, because any user can open pull requests against the repository and compromise the environment. Similarly, be cautious when using self-hosted runners on private or internal repositories, as anyone who can fork the repository and open a pull request (generally those with read access to the repository) are able to compromise the self-hosted runner environment, including gaining access to secrets and the which, depending on its settings, can grant write access to the repository. Although workflows can control access to environment secrets by using environments and required reviews, these workflows are not run in an isolated environment and are still susceptible to the same risks when run on a self-hosted runner.\n\nOrganization owners can choose which repositories are allowed to create repository-level self-hosted runners.\n\nFor more information, see Disabling or limiting GitHub Actions for your organization.\n\nWhen a self-hosted runner is defined at the organization or enterprise level, GitHub can schedule workflows from multiple repositories onto the same runner. Consequently, a security compromise of these environments can result in a wide impact. To help reduce the scope of a compromise, you can create boundaries by organizing your self-hosted runners into separate groups. You can restrict what organizations and repositories can access runner groups. For more information, see Managing access to self-hosted runners using groups.\n\nYou should also consider the environment of the self-hosted runner machines:\n• What sensitive information resides on the machine configured as a self-hosted runner? For example, private SSH keys, API access tokens, among others.\n• Does the machine have network access to sensitive services? For example, Azure or AWS metadata services. The amount of sensitive information in this environment should be kept to a minimum, and you should always be mindful that any user capable of invoking workflows has access to this environment.\n\nSome customers might attempt to partially mitigate these risks by implementing systems that automatically destroy the self-hosted runner after each job execution. However, this approach might not be as effective as intended, as there is no way to guarantee that a self-hosted runner only runs one job. Some jobs will use secrets as command-line arguments which can be seen by another job running on the same runner, such as . This can lead to secret leakages.\n\nTo improve runner registration security, you can use the REST API to create ephemeral, just-in-time (JIT) runners. These self-hosted runners perform at most one job before being automatically removed from the repository, organization, or enterprise. For more information about configuring JIT runners, see REST API endpoints for self-hosted runners.\n\nOnce you have the config file from the REST API response, you can pass it to the runner at startup.\n\nA self-hosted runner can be added to various levels in your GitHub hierarchy: the enterprise, organization, or repository level. This placement determines who will be able to manage the runner:\n• If you plan to have a centralized team own the self-hosted runners, then the recommendation is to add your runners at the highest mutual organization or enterprise level. This gives your team a single location to view and manage your runners.\n• If you only have a single organization, then adding your runners at the organization level is effectively the same approach, but you might encounter difficulties if you add another organization in the future.\n• If each team will manage their own self-hosted runners, then the recommendation is to add the runners at the highest level of team ownership. For example, if each team owns their own organization, then it will be simplest if the runners are added at the organization level too.\n• You could also add runners at the repository level, but this will add management overhead and also increases the numbers of runners you need, since you cannot share runners between repositories.\n\nIf you are using GitHub Actions to deploy to a cloud provider, or intend to use HashiCorp Vault for secret management, then its recommended that you consider using OpenID Connect to create short-lived, well-scoped access tokens for your workflow runs. For more information, see About security hardening with OpenID Connect.\n\nYou can use the security log to monitor activity for your user account and the audit log to monitor activity in your organization. The security and audit log records the type of action, when it was run, and which personal account performed the action.\n\nFor example, you can use the audit log to track the event, which tracks changes to organization secrets.\n\nFor the full list of events that you can find in the audit log for each account type, see the following articles:"
    },
    {
        "link": "https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions",
        "document": "Workflow files use YAML syntax, and must have either a or file extension. If you're new to YAML and want to learn more, see Learn YAML in Y minutes.\n\nYou must store workflow files in the directory of your repository.\n\nThe name of the workflow. GitHub displays the names of your workflows under your repository's \"Actions\" tab. If you omit , GitHub displays the workflow file path relative to the root of the repository.\n\nThe name for workflow runs generated from the workflow. GitHub displays the workflow run name in the list of workflow runs on your repository's \"Actions\" tab. If is omitted or is only whitespace, then the run name is set to event-specific information for the workflow run. For example, for a workflow triggered by a or event, it is set as the commit message or the title of the pull request.\n\nThis value can include expressions and can reference the and contexts.\n\nTo automatically trigger a workflow, use to define which events can cause the workflow to run. For a list of available events, see Events that trigger workflows.\n\nYou can define single or multiple events that can trigger a workflow, or set a time schedule. You can also restrict the execution of a workflow to only occur for specific files, tags, or branch changes. These options are described in the following sections.\n\nFor example, a workflow with the following value will run when a push is made to any branch in the workflow's repository:\n\nYou can specify a single event or multiple events. For example, a workflow with the following value will run when a push is made to any branch in the repository or when someone forks the repository:\n\nIf you specify multiple events, only one of those events needs to occur to trigger your workflow. If multiple triggering events for your workflow occur at the same time, multiple workflow runs will be triggered.\n\nSome events have activity types that give you more control over when your workflow should run. Use to define the type of event activity that will trigger a workflow run.\n\nFor example, the event has the , , and activity types. If your workflow triggers on the event, it will run whenever a label is created, edited, or deleted. If you specify the activity type for the event, your workflow will run when a label is created but not when a label is edited or deleted.\n\nIf you specify multiple activity types, only one of those event activity types needs to occur to trigger your workflow. If multiple triggering event activity types for your workflow occur at the same time, multiple workflow runs will be triggered. For example, the following workflow triggers when an issue is opened or labeled. If an issue with two labels is opened, three workflow runs will start: one for the issue opened event and two for the two issue labeled events.\n\nFor more information about each event and their activity types, see Events that trigger workflows.\n\nSome events have filters that give you more control over when your workflow should run.\n\nFor example, the event has a filter that causes your workflow to run only when a push to a branch that matches the filter occurs, instead of when any push occurs.\n\nUsing activity types and filters with multiple events\n\nIf you specify activity types or filters for an event and your workflow triggers on multiple events, you must configure each event separately. You must append a colon ( ) to all events, including events without configuration.\n\nFor example, a workflow with the following value will run when:\n• A push is made to the branch in the repository\n\nUse to define the type of activity that will trigger a workflow run. Most GitHub events are triggered by more than one type of activity. For example, the is triggered when a label is , , or . The keyword enables you to narrow down activity that causes the workflow to run. When only one activity type triggers a webhook event, the keyword is unnecessary.\n\nYou can use an array of event . For more information about each event and their activity types, see Events that trigger workflows.\n\nWhen using the and events, you can configure a workflow to run only for pull requests that target specific branches.\n\nUse the filter when you want to include branch name patterns or when you want to both include and exclude branch names patterns. Use the filter when you only want to exclude branch name patterns. You cannot use both the and filters for the same event in a workflow.\n\nIf you define both / and / , the workflow will only run when both filters are satisfied.\n\nThe and keywords accept glob patterns that use characters like , , , , and others to match more than one branch name. If a name contains any of these characters and you want a literal match, you need to escape each of these special characters with . For more information about glob patterns, see the Workflow syntax for GitHub Actions.\n\nThe patterns defined in are evaluated against the Git ref's name. For example, the following workflow would run whenever there is a event for a pull request targeting:\n• A branch whose name starts with , like ( )\n\nIf a workflow is skipped due to branch filtering, path filtering, or a commit message, then checks associated with that workflow will remain in a \"Pending\" state. A pull request that requires those checks to be successful will be blocked from merging.\n\nWhen a pattern matches the pattern, the workflow will not run. The patterns defined in are evaluated against the Git ref's name. For example, the following workflow would run whenever there is a event unless the pull request is targeting:\n• A branch whose name matches , like ( )\n\nYou cannot use and to filter the same event in a single workflow. If you want to both include and exclude branch patterns for a single event, use the filter along with the character to indicate which branches should be excluded.\n\nIf you define a branch with the character, you must also define at least one branch without the character. If you only want to exclude branches, use instead.\n\nThe order that you define patterns matters.\n• A matching negative pattern (prefixed with ) after a positive match will exclude the Git ref.\n• A matching positive pattern after a negative match will include the Git ref again.\n\nThe following workflow will run on events for pull requests that target or , but not for pull requests that target or because the negative pattern follows the positive pattern.\n\nWhen using the event, you can configure a workflow to run on specific branches or tags.\n\nUse the filter when you want to include branch name patterns or when you want to both include and exclude branch names patterns. Use the filter when you only want to exclude branch name patterns. You cannot use both the and filters for the same event in a workflow.\n\nUse the filter when you want to include tag name patterns or when you want to both include and exclude tag names patterns. Use the filter when you only want to exclude tag name patterns. You cannot use both the and filters for the same event in a workflow.\n\nIf you define only / or only / , the workflow won't run for events affecting the undefined Git ref. If you define neither / or / , the workflow will run for events affecting either branches or tags. If you define both / and / , the workflow will only run when both filters are satisfied.\n\nThe , , , and keywords accept glob patterns that use characters like , , , , and others to match more than one branch or tag name. If a name contains any of these characters and you want a literal match, you need to escape each of these special characters with . For more information about glob patterns, see the Workflow syntax for GitHub Actions.\n\nThe patterns defined in and are evaluated against the Git ref's name. For example, the following workflow would run whenever there is a event to:\n• A branch whose name starts with , like ( )\n• A tag whose name starts with , like ( )\n\nWhen a pattern matches the or pattern, the workflow will not run. The patterns defined in and are evaluated against the Git ref's name. For example, the following workflow would run whenever there is a event, unless the event is to:\n• A branch whose name matches , like ( )\n• A tag whose name starts with , like ( )\n\nYou can't use and to filter the same event in a single workflow. Similarly, you can't use and to filter the same event in a single workflow. If you want to both include and exclude branch or tag patterns for a single event, use the or filter along with the character to indicate which branches or tags should be excluded.\n\nIf you define a branch with the character, you must also define at least one branch without the character. If you only want to exclude branches, use instead. Similarly, if you define a tag with the character, you must also define at least one tag without the character. If you only want to exclude tags, use instead.\n\nThe order that you define patterns matters.\n• A matching negative pattern (prefixed with ) after a positive match will exclude the Git ref.\n• A matching positive pattern after a negative match will include the Git ref again.\n\nThe following workflow will run on pushes to or , but not on or because the negative pattern follows the positive pattern.\n\nWhen using the and events, you can configure a workflow to run based on what file paths are changed. Path filters are not evaluated for pushes of tags.\n\nUse the filter when you want to include file path patterns or when you want to both include and exclude file path patterns. Use the filter when you only want to exclude file path patterns. You cannot use both the and filters for the same event in a workflow. If you want to both include and exclude path patterns for a single event, use the filter prefixed with the character to indicate which paths should be excluded.\n\nIf you define both / and / , the workflow will only run when both filters are satisfied.\n\nThe and keywords accept glob patterns that use the and wildcard characters to match more than one path name. For more information, see the Workflow syntax for GitHub Actions.\n\nIf at least one path matches a pattern in the filter, the workflow runs. For example, the following workflow would run anytime you push a JavaScript file ( ).\n\nIf a workflow is skipped due to path filtering, branch filtering, or a commit message, then checks associated with that workflow will remain in a \"Pending\" state. A pull request that requires those checks to be successful will be blocked from merging.\n\nWhen all the path names match patterns in , the workflow will not run. If any path names do not match patterns in , even if some path names match the patterns, the workflow will run.\n\nA workflow with the following path filter will only run on events that include at least one file outside the directory at the root of the repository.\n\nYou cannot use and to filter the same event in a single workflow. If you want to both include and exclude path patterns for a single event, use the filter prefixed with the character to indicate which paths should be excluded.\n\nIf you define a path with the character, you must also define at least one path without the character. If you only want to exclude paths, use instead.\n\nThe order that you define patterns matters:\n• A matching negative pattern (prefixed with ) after a positive match will exclude the path.\n• A matching positive pattern after a negative match will include the path again.\n\nThis example runs anytime the event includes a file in the directory or its subdirectories, unless the file is in the directory. For example, a push that changed or will trigger a workflow run, but a push changing only will not.\n\nThe filter determines if a workflow should run by evaluating the changed files and running them against the or list. If there are no files changed, the workflow will not run.\n\nGitHub generates the list of changed files using two-dot diffs for pushes and three-dot diffs for pull requests:\n• Pull requests: Three-dot diffs are a comparison between the most recent version of the topic branch and the commit where the topic branch was last synced with the base branch.\n• Pushes to existing branches: A two-dot diff compares the head and base SHAs directly with each other.\n• Pushes to new branches: A two-dot diff against the parent of the ancestor of the deepest commit pushed.\n\nDiffs are limited to 300 files. If there are files changed that aren't matched in the first 300 files returned by the filter, the workflow will not run. You may need to create more specific filters so that the workflow will run automatically.\n\nFor more information, see About comparing branches in pull requests.\n\nYou can use to define a time schedule for your workflows. You can schedule a workflow to run at specific UTC times using POSIX cron syntax. Scheduled workflows run on the latest commit on the default or base branch. The shortest interval you can run scheduled workflows is once every 5 minutes.\n\nThis example triggers the workflow every day at 5:30 and 17:30 UTC:\n\nA single workflow can be triggered by multiple events. You can access the schedule event that triggered the workflow through the context. This example triggers the workflow to run at 5:30 UTC every Monday-Thursday, but skips the Not on Monday or Wednesday step on Monday and Wednesday.\n\nFor more information about cron syntax, see Events that trigger workflows.\n\nUse to define the inputs and outputs for a reusable workflow. You can also map the secrets that are available to the called workflow. For more information on reusable workflows, see Reusing workflows.\n\nWhen using the keyword, you can optionally specify inputs that are passed to the called workflow from the caller workflow. For more information about the keyword, see Events that trigger workflows.\n\nIn addition to the standard input parameters that are available, requires a parameter. For more information, see .\n\nIf a parameter is not set, the default value of the input is for a boolean, for a number, and for a string.\n\nWithin the called workflow, you can use the context to refer to an input. For more information, see Accessing contextual information about workflow runs.\n\nIf a caller workflow passes an input that is not specified in the called workflow, this results in an error.\n\nFor more information, see Reusing workflows.\n\nRequired if input is defined for the keyword. The value of this parameter is a string specifying the data type of the input. This must be one of: , , or .\n\nA map of outputs for a called workflow. Called workflow outputs are available to all downstream jobs in the caller workflow. Each output has an identifier, an optional and a The must be set to the value of an output from a job within the called workflow.\n\nIn the example below, two outputs are defined for this reusable workflow: and . These are mapped to outputs called and , both from a job called .\n\nFor information on how to reference a job output, see . For more information, see Reusing workflows.\n\nA map of the secrets that can be used in the called workflow.\n\nWithin the called workflow, you can use the context to refer to a secret.\n\nIf a caller workflow passes a secret that is not specified in the called workflow, this results in an error.\n\nA string identifier to associate with the secret.\n\nA boolean specifying whether the secret must be supplied.\n\nWhen using the event, you can specify what branches the triggering workflow must run on in order to trigger your workflow.\n\nThe and filters accept glob patterns that use characters like , , , , and others to match more than one branch name. If a name contains any of these characters and you want a literal match, you need to escape each of these special characters with . For more information about glob patterns, see the Workflow syntax for GitHub Actions.\n\nFor example, a workflow with the following trigger will only run when the workflow named runs on a branch whose name starts with :\n\nA workflow with the following trigger will only run when the workflow named runs on a branch that is not named :\n\nYou cannot use both the and filters for the same event in a workflow. If you want to both include and exclude branch patterns for a single event, use the filter along with the character to indicate which branches should be excluded.\n\nThe order that you define patterns matters.\n• A matching negative pattern (prefixed with ) after a positive match will exclude the branch.\n• A matching positive pattern after a negative match will include the branch again.\n\nFor example, a workflow with the following trigger will run when the workflow named runs on a branch that is named or but will not , , or .\n\nWhen using the event, you can optionally specify inputs that are passed to the workflow.\n\nThis trigger only receives events when the workflow file is on the default branch.\n\nThe triggered workflow receives the inputs in the context. For more information, see Contexts.\n\nA boolean specifying whether the input must be supplied.\n\nThe value of this parameter is a string specifying the data type of the input. This must be one of: , , , or .\n\nYou can use to modify the default permissions granted to the , adding or removing access as required, so that you only allow the minimum required access. For more information, see Automatic token authentication.\n\nYou can use either as a top-level key, to apply to all jobs in the workflow, or within specific jobs. When you add the key within a specific job, all actions and run commands within that job that use the gain the access rights you specify. For more information, see .\n\nFor each of the available permissions, shown in the table below, you can assign one of the access levels: (if applicable), , or . includes . If you specify the access for any of these permissions, all of those that are not specified are set to .\n\nAvailable permissions and details of what each allows an action to do:\n\nYou can define the access that the will permit by specifying , , or as the value of the available permissions within the key.\n\nIf you specify the access for any of these permissions, all of those that are not specified are set to .\n\nYou can use the following syntax to define one of or access for all of the available permissions:\n\nYou can use the following syntax to disable permissions for all of the available permissions:\n\nYou can use the key to add and remove read permissions for forked repositories, but typically you can't grant write access. The exception to this behavior is where an admin user has selected the Send write tokens to workflows from pull requests option in the GitHub Actions settings. For more information, see Managing GitHub Actions settings for a repository.\n\nSetting the permissions for all jobs in a workflow\n\nYou can specify at the top level of a workflow, so that the setting applies to all jobs in the workflow.\n\nExample: Setting the permissions for an entire workflow\n\nThis example shows permissions being set for the that will apply to all jobs in the workflow. All permissions are granted read access.\n\nA of variables that are available to the steps of all jobs in the workflow. You can also set variables that are only available to the steps of a single job or to a single step. For more information, see and .\n\nVariables in the map cannot be defined in terms of other variables in the map.\n\nWhen more than one environment variable is defined with the same name, GitHub uses the most specific variable. For example, an environment variable defined in a step will override job and workflow environment variables with the same name, while the step executes. An environment variable defined for a job will override a workflow variable with the same name, while the job executes.\n\nUse to create a of default settings that will apply to all jobs in the workflow. You can also set default settings that are only available to a job. For more information, see .\n\nWhen more than one default setting is defined with the same name, GitHub uses the most specific default setting. For example, a default setting defined in a job will override a default setting that has the same name defined in a workflow.\n\nYou can use to provide default and options for all steps in a workflow. You can also set default settings for that are only available to a job. For more information, see . You cannot use contexts or expressions in this keyword.\n\nWhen more than one default setting is defined with the same name, GitHub uses the most specific default setting. For example, a default setting defined in a job will override a default setting that has the same name defined in a workflow.\n\nExample: Set the default shell and working directory\n\nUse to define the for a step. This keyword can reference several contexts. For more information, see Contexts.\n\nWhen more than one default setting is defined with the same name, GitHub uses the most specific default setting. For example, a default setting defined in a job will override a default setting that has the same name defined in a workflow.\n\nUse to define the working directory for the for a step. This keyword can reference several contexts. For more information, see Contexts.\n\nUse to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. The expression can only use , and contexts. For more information about expressions, see Evaluate expressions in workflows and actions.\n\nYou can also specify at the job level. For more information, see .\n\nThis means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be . Any existing job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place.\n\nTo also cancel any currently running job or workflow in the same concurrency group, specify . To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify as an expression with any of the allowed expression contexts.\n\nExample: Using concurrency and the default behavior\n\nThe default behavior of GitHub Actions is to allow multiple jobs or workflow runs to run concurrently. The keyword allows you to control the concurrency of workflow runs.\n\nFor example, you can use the keyword immediately after where trigger conditions are defined to limit the concurrency of entire workflow runs for a specific branch:\n\nYou can also limit the concurrency of jobs within a workflow by using the keyword at the job level:\n\nConcurrency groups provide a way to manage and limit the execution of workflow runs or jobs that share the same concurrency key.\n\nThe key is used to group workflows or jobs together into a concurrency group. When you define a key, GitHub Actions ensures that only one workflow or job with that key runs at any given time. If a new workflow run or job starts with the same key, GitHub Actions will cancel any workflow or job already running with that key. The key can be a hard-coded string, or it can be a dynamic expression that includes context variables.\n\nIt is possible to define concurrency conditions in your workflow so that the workflow or job is part of a concurrency group.\n\nThis means that when a workflow run or job starts, GitHub will cancel any workflow runs or jobs that are already in progress in the same concurrency group. This is useful in scenarios where you want to prevent parallel runs for a certain set of a workflows or jobs, such as the ones used for deployments to a staging environment, in order to prevent actions that could cause conflicts or consume more resources than necessary.\n\nIn this example, is part of a concurrency group named . This means that if a new run of is triggered, any runs of the same job in the concurrency group that are already in progress will be cancelled.\n\nAlternatively, using a dynamic expression such as in your workflow means that the workflow or job would be part of a concurrency group named followed by the reference of the branch or tag that triggered the workflow. In this example, if a new commit is pushed to the main branch while a previous run is still in progress, the previous run will be cancelled and the new one will start:\n\nExample: Using concurrency to cancel any in-progress job or run\n\nTo use concurrency to cancel any in-progress job or run in GitHub Actions, you can use the key with the option set to :\n\nNote that in this example, without defining a particular concurrency group, GitHub Actions will cancel any in-progress run of the job or workflow.\n\nExample: Using a fallback value\n\nIf you build the group name with a property that is only defined for specific events, you can use a fallback value. For example, is only defined on events. If your workflow responds to other events in addition to events, you will need to provide a fallback to avoid a syntax error. The following concurrency group cancels in-progress jobs or runs on events only; if is undefined, the concurrency group will fallback to the run ID, which is guaranteed to be both unique and defined for the run.\n\nExample: Only cancel in-progress jobs or runs for the current workflow\n\nIf you have multiple workflows in the same repository, concurrency group names must be unique across workflows to avoid canceling in-progress jobs or runs from other workflows. Otherwise, any previously in-progress or pending job will be canceled, regardless of the workflow.\n\nTo only cancel in-progress runs of the same workflow, you can use the property to build the concurrency group:\n\nExample: Only cancel in-progress jobs on specific branches\n\nIf you would like to cancel in-progress jobs on certain branches but not on others, you can use conditional expressions with . For example, you can do this if you would like to cancel in-progress jobs on development branches but not on release branches.\n\nTo only cancel in-progress runs of the same workflow when not running on a release branch, you can set to an expression similar to the following:\n\nIn this example, multiple pushes to a branch would not cancel in-progress runs. Pushes to another branch, such as , would cancel in-progress runs.\n\nA workflow run is made up of one or more , which run in parallel by default. To run jobs sequentially, you can define dependencies on other jobs using the keyword.\n\nEach job runs in a runner environment specified by .\n\nYou can run an unlimited number of jobs as long as you are within the workflow usage limits. For more information, see Usage limits, billing, and administration for GitHub-hosted runners and About self-hosted runners for self-hosted runner usage limits.\n\nIf you need to find the unique identifier of a job running in a workflow run, you can use the GitHub API. For more information, see REST API endpoints for GitHub Actions.\n\nUse to give your job a unique identifier. The key is a string and its value is a map of the job's configuration data. You must replace with a string that is unique to the object. The must start with a letter or and contain only alphanumeric characters, , or .\n\nIn this example, two jobs have been created, and their values are and .\n\nUse to set a name for the job, which is displayed in the GitHub UI.\n\nFor a specific job, you can use to modify the default permissions granted to the , adding or removing access as required, so that you only allow the minimum required access. For more information, see Automatic token authentication.\n\nBy specifying the permission within a job definition, you can configure a different set of permissions for the for each job, if required. Alternatively, you can specify the permissions for all jobs in the workflow. For information on defining permissions at the workflow level, see .\n\nFor each of the available permissions, shown in the table below, you can assign one of the access levels: (if applicable), , or . includes . If you specify the access for any of these permissions, all of those that are not specified are set to .\n\nAvailable permissions and details of what each allows an action to do:\n\nYou can define the access that the will permit by specifying , , or as the value of the available permissions within the key.\n\nIf you specify the access for any of these permissions, all of those that are not specified are set to .\n\nYou can use the following syntax to define one of or access for all of the available permissions:\n\nYou can use the following syntax to disable permissions for all of the available permissions:\n\nYou can use the key to add and remove read permissions for forked repositories, but typically you can't grant write access. The exception to this behavior is where an admin user has selected the Send write tokens to workflows from pull requests option in the GitHub Actions settings. For more information, see Managing GitHub Actions settings for a repository.\n\nExample: Setting the permissions for one job in a workflow\n\nThis example shows permissions being set for the that will only apply to the job named . Write access is granted for the and permissions. All other permissions will have no access.\n\nUse to identify any jobs that must complete successfully before this job will run. It can be a string or array of strings. If a job fails or is skipped, all jobs that need it are skipped unless the jobs use a conditional expression that causes the job to continue. If a run contains a series of jobs that need each other, a failure or skip applies to all jobs in the dependency chain from the point of failure or skip onwards. If you would like a job to run even if a job it is dependent on did not succeed, use the conditional expression in .\n\nIn this example, must complete successfully before begins, and waits for both and to complete.\n\nThe jobs in this example run sequentially:\n\nIn this example, uses the conditional expression so that it always runs after and have completed, regardless of whether they were successful. For more information, see Evaluate expressions in workflows and actions.\n\nYou can use the conditional to prevent a job from running unless a condition is met. You can use any supported context and expression to create a conditional. For more information on which contexts are supported in this key, see Accessing contextual information about workflow runs.\n\nWhen you use expressions in an conditional, you can, optionally, omit the expression syntax because GitHub Actions automatically evaluates the conditional as an expression. However, this exception does not apply everywhere.\n\nYou must always use the expression syntax or escape with , , or when the expression starts with , since is reserved notation in YAML format. For example:\n\nFor more information, see Evaluate expressions in workflows and actions.\n\nExample: Only run job for specific repository\n\nThis example uses to control when the job can run. It will only run if the repository is named and is within the organization. Otherwise, the job will be marked as skipped.\n\nUse to define the type of machine to run the job on.\n• The destination machine can be either a GitHub-hosted runner, larger runner, or a self-hosted runner.\n• You can target runners based on the labels assigned to them, or their group membership, or a combination of these.\n• You can provide as:\n• An array of strings, variables containing strings, or a combination of both\n• A pair using the or keys\n• If you specify an array of strings or variables, your workflow will execute on any runner that matches all of the specified values. For example, here the job will only run on a self-hosted runner that has the labels , , and : For more information, see Choosing self-hosted runners.\n• You can mix strings and variables in an array. For example:\n• If you would like to run your workflow on multiple machines, use .\n\nIf you use a GitHub-hosted runner, each job runs in a fresh instance of a runner image specified by .\n\nThe value for runs-on, when you are using a GitHub-hosted runner, is a runner label or the name of a runner group. The labels for the standard GitHub-hosted runners are shown in the following tables.\n\nFor more information, see About GitHub-hosted runners.\n\nFor public repositories, jobs using the workflow labels shown in the table below will run on virtual machines with the associated specifications. The use of these runners on public repositories is free and unlimited.\n\nFor private repositories, jobs using the workflow labels shown in the table below will run on virtual machines with the associated specifications. These runners use your GitHub account's allotment of free minutes, and are then charged at the per minute rates. For more information, see About billing for GitHub Actions.\n\nIn addition to the standard GitHub-hosted runners, GitHub offers customers on GitHub Team and GitHub Enterprise Cloud plans a range of managed virtual machines with advanced features - for example, more cores and disk space, GPU-powered machines, and ARM-powered machines. For more information, see About larger runners.\n\nExample: Specifying an operating system\n\nFor more information, see Using GitHub-hosted runners.\n\nTo specify a self-hosted runner for your job, configure in your workflow file with self-hosted runner labels.\n\nSelf-hosted runners may have the label. When setting up a self-hosted runner, by default we will include the label . You may pass in the flag to prevent the self-hosted label from being applied. Labels can be used to create targeting options for runners, such as operating system or architecture, we recommend providing an array of labels that begins with (this must be listed first) and then includes additional labels as needed. When you specify an array of labels, jobs will be queued on runners that have all the labels that you specify.\n\nNote that Actions Runner Controller does not support multiple labels and does not support the label.\n\nExample: Using labels for runner selection\n\nFor more information, see About self-hosted runners and Using self-hosted runners in a workflow.\n\nYou can use to target runner groups, so that the job will execute on any runner that is a member of that group. For more granular control, you can also combine runner groups with labels.\n\nRunner groups can only have larger runners or self-hosted runners as members.\n\nExample: Using groups to control where jobs are run\n\nIn this example, Ubuntu runners have been added to a group called . The key sends the job to any available runner in the group:\n\nWhen you combine groups and labels, the runner must meet both requirements to be eligible to run the job.\n\nIn this example, a runner group called is populated with Ubuntu runners, which have also been assigned the label . The key combines and so that the job is routed to any available runner within the group that also has a matching label:\n\nUse to define the environment that the job references.\n\nYou can provide the environment as only the environment , or as an environment object with the and . The URL maps to in the deployments API. For more information about the deployments API, see REST API endpoints for repositories.\n\nExample: Using a single environment name\n\nExample: Using environment name and URL\n\nThe value of can be an expression. Allowed expression contexts: , , , , , , , , , and . For more information about expressions, see Evaluate expressions in workflows and actions.\n\nExample: Using output as URL\n\nThe value of can be an expression. Allowed expression contexts: , , , , , and . For more information about expressions, see Evaluate expressions in workflows and actions.\n\nExample: Using an expression as environment name\n\nYou can use to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. Allowed expression contexts: , , , , , and . For more information about expressions, see Evaluate expressions in workflows and actions.\n\nYou can also specify at the workflow level. For more information, see .\n\nThis means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be . Any existing job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place.\n\nTo also cancel any currently running job or workflow in the same concurrency group, specify . To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify as an expression with any of the allowed expression contexts.\n\nExample: Using concurrency and the default behavior\n\nThe default behavior of GitHub Actions is to allow multiple jobs or workflow runs to run concurrently. The keyword allows you to control the concurrency of workflow runs.\n\nFor example, you can use the keyword immediately after where trigger conditions are defined to limit the concurrency of entire workflow runs for a specific branch:\n\nYou can also limit the concurrency of jobs within a workflow by using the keyword at the job level:\n\nConcurrency groups provide a way to manage and limit the execution of workflow runs or jobs that share the same concurrency key.\n\nThe key is used to group workflows or jobs together into a concurrency group. When you define a key, GitHub Actions ensures that only one workflow or job with that key runs at any given time. If a new workflow run or job starts with the same key, GitHub Actions will cancel any workflow or job already running with that key. The key can be a hard-coded string, or it can be a dynamic expression that includes context variables.\n\nIt is possible to define concurrency conditions in your workflow so that the workflow or job is part of a concurrency group.\n\nThis means that when a workflow run or job starts, GitHub will cancel any workflow runs or jobs that are already in progress in the same concurrency group. This is useful in scenarios where you want to prevent parallel runs for a certain set of a workflows or jobs, such as the ones used for deployments to a staging environment, in order to prevent actions that could cause conflicts or consume more resources than necessary.\n\nIn this example, is part of a concurrency group named . This means that if a new run of is triggered, any runs of the same job in the concurrency group that are already in progress will be cancelled.\n\nAlternatively, using a dynamic expression such as in your workflow means that the workflow or job would be part of a concurrency group named followed by the reference of the branch or tag that triggered the workflow. In this example, if a new commit is pushed to the main branch while a previous run is still in progress, the previous run will be cancelled and the new one will start:\n\nExample: Using concurrency to cancel any in-progress job or run\n\nTo use concurrency to cancel any in-progress job or run in GitHub Actions, you can use the key with the option set to :\n\nNote that in this example, without defining a particular concurrency group, GitHub Actions will cancel any in-progress run of the job or workflow.\n\nExample: Using a fallback value\n\nIf you build the group name with a property that is only defined for specific events, you can use a fallback value. For example, is only defined on events. If your workflow responds to other events in addition to events, you will need to provide a fallback to avoid a syntax error. The following concurrency group cancels in-progress jobs or runs on events only; if is undefined, the concurrency group will fallback to the run ID, which is guaranteed to be both unique and defined for the run.\n\nExample: Only cancel in-progress jobs or runs for the current workflow\n\nIf you have multiple workflows in the same repository, concurrency group names must be unique across workflows to avoid canceling in-progress jobs or runs from other workflows. Otherwise, any previously in-progress or pending job will be canceled, regardless of the workflow.\n\nTo only cancel in-progress runs of the same workflow, you can use the property to build the concurrency group:\n\nExample: Only cancel in-progress jobs on specific branches\n\nIf you would like to cancel in-progress jobs on certain branches but not on others, you can use conditional expressions with . For example, you can do this if you would like to cancel in-progress jobs on development branches but not on release branches.\n\nTo only cancel in-progress runs of the same workflow when not running on a release branch, you can set to an expression similar to the following:\n\nIn this example, multiple pushes to a branch would not cancel in-progress runs. Pushes to another branch, such as , would cancel in-progress runs.\n\nYou can use to create a of outputs for a job. Job outputs are available to all downstream jobs that depend on this job. For more information on defining job dependencies, see .\n\nOutputs can be a maximum of 1 MB per job. The total of all outputs in a workflow run can be a maximum of 50 MB. Size is approximated based on UTF-16 encoding.\n\nJob outputs containing expressions are evaluated on the runner at the end of each job. Outputs containing secrets are redacted on the runner and not sent to GitHub Actions.\n\nIf an output is skipped because it may contain a secret, you will see the following warning message: \"Skip output since it may contain secret.\" For more information on how to handle secrets, please refer to the Example: Masking and passing a secret between jobs or workflows.\n\nTo use job outputs in a dependent job, you can use the context. For more information, see Accessing contextual information about workflow runs.\n\nMatrices can be used to generate multiple outputs of different names. When using a matrix, job outputs will be combined from all jobs inside the matrix.\n\nA of variables that are available to all steps in the job. You can set variables for the entire workflow or an individual step. For more information, see and .\n\nWhen more than one environment variable is defined with the same name, GitHub uses the most specific variable. For example, an environment variable defined in a step will override job and workflow environment variables with the same name, while the step executes. An environment variable defined for a job will override a workflow variable with the same name, while the job executes.\n\nUse to create a of default settings that will apply to all steps in the job. You can also set default settings for the entire workflow. For more information, see .\n\nWhen more than one default setting is defined with the same name, GitHub uses the most specific default setting. For example, a default setting defined in a job will override a default setting that has the same name defined in a workflow.\n\nUse to provide default and to all steps in the job.\n\nYou can provide default and options for all steps in a job. You can also set default settings for for the entire workflow. For more information, see .\n\nThese can be overriden at the and levels.\n\nWhen more than one default setting is defined with the same name, GitHub uses the most specific default setting. For example, a default setting defined in a job will override a default setting that has the same name defined in a workflow.\n\nUse to define the for a step. This keyword can reference several contexts. For more information, see Contexts.\n\nWhen more than one default setting is defined with the same name, GitHub uses the most specific default setting. For example, a default setting defined in a job will override a default setting that has the same name defined in a workflow.\n\nUse to define the working directory for the for a step. This keyword can reference several contexts. For more information, see Contexts.\n\nA job contains a sequence of tasks called . Steps can run commands, run setup tasks, or run an action in your repository, a public repository, or an action published in a Docker registry. Not all steps run actions, but all actions run as a step. Each step runs in its own process in the runner environment and has access to the workspace and filesystem. Because steps run in their own process, changes to environment variables are not preserved between steps. GitHub provides built-in steps to set up and complete a job.\n\nGitHub only displays the first 1,000 checks, however, you can run an unlimited number of steps as long as you are within the workflow usage limits. For more information, see Usage limits, billing, and administration for GitHub-hosted runners and About self-hosted runners for self-hosted runner usage limits.\n\nA unique identifier for the step. You can use the to reference the step in contexts. For more information, see Accessing contextual information about workflow runs.\n\nYou can use the conditional to prevent a step from running unless a condition is met. You can use any supported context and expression to create a conditional. For more information on which contexts are supported in this key, see Accessing contextual information about workflow runs.\n\nWhen you use expressions in an conditional, you can, optionally, omit the expression syntax because GitHub Actions automatically evaluates the conditional as an expression. However, this exception does not apply everywhere.\n\nYou must always use the expression syntax or escape with , , or when the expression starts with , since is reserved notation in YAML format. For example:\n\nFor more information, see Evaluate expressions in workflows and actions.\n\nThis step only runs when the event type is a and the event action is .\n\nThe only runs when the previous step of a job fails. For more information, see Evaluate expressions in workflows and actions.\n\nSecrets cannot be directly referenced in conditionals. Instead, consider setting secrets as job-level environment variables, then referencing the environment variables to conditionally run steps in the job.\n\nIf a secret has not been set, the return value of an expression referencing the secret (such as in the example) will be an empty string.\n\nFor more information, see Accessing contextual information about workflow runs and Using secrets in GitHub Actions.\n\nA name for your step to display on GitHub.\n\nSelects an action to run as part of a step in your job. An action is a reusable unit of code. You can use an action defined in the same repository as the workflow, a public repository, or in a published Docker container image.\n\nWe strongly recommend that you include the version of the action you are using by specifying a Git ref, SHA, or Docker tag. If you don't specify a version, it could break your workflows or cause unexpected behavior when the action owner publishes an update.\n• Using the commit SHA of a released action version is the safest for stability and security.\n• If the action publishes major version tags, you should expect to receive critical fixes and security patches while still retaining compatibility. Note that this behavior is at the discretion of the action's author.\n• Using the default branch of an action may be convenient, but if someone releases a new major version with a breaking change, your workflow could break.\n\nSome actions require inputs that you must set using the keyword. Review the action's README file to determine the inputs required.\n\nActions are either JavaScript files or Docker containers. If the action you're using is a Docker container you must run the job in a Linux environment. For more details, see .\n\nYou can specify a branch, ref, or SHA in a public GitHub repository.\n\nExample: Using a public action in a subdirectory\n\nA subdirectory in a public GitHub repository at a specific branch, ref, or SHA.\n\nExample: Using an action in the same repository as the workflow\n\nThe path to the directory that contains the action in your workflow's repository. You must check out your repository before using the action.\n\nThe path is relative ( ) to the default working directory ( , ). If the action checks out the repository to a location different than the workflow, the relative path used for local actions must be updated.\n\nExample: Using the GitHub Packages Container registry\n\nA Docker image in a public registry. This example uses the Google Container Registry at .\n\nExample: Using an action inside a different private repository than the workflow\n\nYour workflow must checkout the private repository and reference the action locally. Generate a personal access token and add the token as a secret. For more information, see Managing your personal access tokens and Using secrets in GitHub Actions.\n\nReplace in the example with the name of your secret.\n\nAlternatively, use a GitHub App instead of a personal access token in order to ensure your workflow continues to run even if the personal access token owner leaves. For more information, see Making authenticated API requests with a GitHub App in a GitHub Actions workflow.\n\nRuns command-line programs that do not exceed 21,000 characters using the operating system's shell. If you do not provide a , the step name will default to the text specified in the command.\n\nCommands run using non-login shells by default. You can choose a different shell and customize the shell used to run commands. For more information, see .\n\nEach keyword represents a new process and shell in the runner environment. When you provide multi-line commands, each line runs in the same shell. For example:\n\nUsing the keyword, you can specify the working directory of where to run the command.\n\nAlternatively, you can specify a default working directory for all steps in a job, or for all steps in the entire workflow. For more information, see and .\n\nYou can also use a step to run a script. For more information, see Adding scripts to your workflow.\n\nYou can override the default shell settings in the runner's operating system and the job's default using the keyword. You can use built-in keywords, or you can define a custom set of shell options. The shell command that is run internally executes a temporary file that contains the commands specified in the keyword.\n\nAlternatively, you can specify a default shell for all steps in a job, or for all steps in the entire workflow. For more information, see and .\n\nExample: Using PowerShell Desktop to run a command\n\nYou can set the value to a template string using . GitHub interprets the first whitespace-delimited word of the string as the command, and inserts the file name for the temporary script at .\n\nThe command used, in this example, must be installed on the runner.\n\nFor information about the software included on GitHub-hosted runners, see Using GitHub-hosted runners.\n\nFor built-in shell keywords, we provide the following defaults that are executed by GitHub-hosted runners. You should use these guidelines when running shell scripts.\n• \n• By default, fail-fast behavior is enforced using for both and . When is specified, is also applied to enforce early exit from pipelines that generate a non-zero exit status.\n• You can take full control over shell parameters by providing a template string to the shell options. For example, .\n• -like shells exit with the exit code of the last command executed in a script, which is also the default behavior for actions. The runner will report the status of the step as fail/succeed based on this exit code.\n• \n• Fail-fast behavior when possible. For and built-in shell, we will prepend to script contents.\n• We append to powershell scripts so action statuses reflect the script's last exit code.\n• Users can always opt out by not using the built-in shell, and providing a custom shell option like: , or , depending on need.\n• \n• There doesn't seem to be a way to fully opt into fail-fast behavior other than writing your script to check each error code and respond accordingly. Because we can't actually provide that behavior by default, you need to write this behavior into your script.\n• will exit with the error level of the last program it executed, and it will return the error code to the runner. This behavior is internally consistent with the previous and default behavior and is the default, so this behavior remains intact.\n\nA of the input parameters defined by the action. Each input parameter is a key/value pair. Input parameters are set as environment variables. The variable is prefixed with and converted to upper case.\n\nInput parameters defined for a Docker container must use . For more information, see .\n\nDefines the three input parameters ( , , and ) defined by the action. These input variables will be accessible to the action as , , and environment variables.\n\nA that defines the inputs for a Docker container. GitHub passes the to the container's when the container starts up. An is not supported by this parameter. A single argument that includes spaces should be surrounded by double quotes .\n\nThe are used in place of the instruction in a . If you use in your , use the guidelines ordered by preference:\n• Document required arguments in the action's README and omit them from the instruction.\n• Use defaults that allow using the action without specifying any .\n• If the action exposes a flag, or something similar, use that as the default to make your action self-documenting.\n\nOverrides the Docker in the , or sets it if one wasn't already specified. Unlike the Docker instruction which has a shell and exec form, keyword accepts only a single string defining the executable to be run.\n\nThe keyword is meant to be used with Docker container actions, but you can also use it with JavaScript actions that don't define any inputs.\n\nSets variables for steps to use in the runner environment. You can also set variables for the entire workflow or a job. For more information, see and .\n\nWhen more than one environment variable is defined with the same name, GitHub uses the most specific variable. For example, an environment variable defined in a step will override job and workflow environment variables with the same name, while the step executes. An environment variable defined for a job will override a workflow variable with the same name, while the job executes.\n\nPublic actions may specify expected variables in the README file. If you are setting a secret or sensitive value, such as a password or token, you must set secrets using the context. For more information, see Accessing contextual information about workflow runs.\n\nPrevents a job from failing when a step fails. Set to to allow a job to pass when this step fails.\n\nThe maximum number of minutes to run the step before killing the process.\n\nFractional values are not supported. must be a positive integer.\n\nThe maximum number of minutes to let a job run before GitHub automatically cancels it. Default: 360\n\nIf the timeout exceeds the job execution time limit for the runner, the job will be canceled when the execution time limit is met instead. For more information about job execution time limits, see Usage limits, billing, and administration for GitHub-hosted runners and About self-hosted runners for self-hosted runner usage limits.\n\nUse to use a matrix strategy for your jobs. A matrix strategy lets you use variables in a single job definition to automatically create multiple job runs that are based on the combinations of the variables. For example, you can use a matrix strategy to test your code in multiple versions of a language or on multiple operating systems. For more information, see Running variations of jobs in a workflow.\n\nUse to define a matrix of different job configurations. Within your matrix, define one or more variables followed by an array of values. For example, the following matrix has a variable called with the value and a variable called with the value :\n\nA job will run for each possible combination of the variables. In this example, the workflow will run six jobs, one for each combination of the and variables.\n\nBy default, GitHub will maximize the number of jobs run in parallel depending on runner availability. The order of the variables in the matrix determines the order in which the jobs are created. The first variable you define will be the first job that is created in your workflow run. For example, the above matrix will create the jobs in the following order:\n\nA matrix will generate a maximum of 256 jobs per workflow run. This limit applies to both GitHub-hosted and self-hosted runners.\n\nThe variables that you define become properties in the context, and you can reference the property in other areas of your workflow file. In this example, you can use and to access the current value of and that the job is using. For more information, see Accessing contextual information about workflow runs.\n\nYou can specify a single variable to create a single-dimension matrix.\n\nFor example, the following workflow defines the variable with the values . The workflow will run three jobs, one for each value in the variable. Each job will access the value through the context and pass the value as to the action.\n\nYou can specify multiple variables to create a multi-dimensional matrix. A job will run for each possible combination of the variables.\n\nFor example, the following workflow specifies two variables:\n• Two operating systems specified in the variable\n• Three Node.js versions specified in the variable\n\nThe workflow will run six jobs, one for each combination of the and variables. Each job will set the value to the current value and will pass the current value to the action.\n\nA variable configuration in a matrix can be an of s.\n\nThis matrix produces 4 jobs with corresponding contexts.\n\nExample: Using contexts to create matrices\n\nYou can use contexts to create matrices. For more information about contexts, see Accessing contextual information about workflow runs.\n\nFor example, the following workflow triggers on the event and uses information from the event payload to build the matrix. When a repository dispatch event is created with a payload like the one below, the matrix variable will have a value of . For more information about the trigger, see Events that trigger workflows.\n\nUse to expand existing matrix configurations or to add new configurations. The value of is a list of objects.\n\nFor each object in the list, the key:value pairs in the object will be added to each of the matrix combinations if none of the key:value pairs overwrite any of the original matrix values. If the object cannot be added to any of the matrix combinations, a new matrix combination will be created instead. Note that the original matrix values will not be overwritten, but added matrix values can be overwritten.\n\nFor example, this matrix:\n\nwill result in six jobs with the following matrix combinations:\n• is added to all of the original matrix combinations because it can be added without overwriting any part of the original combinations.\n• adds only to the original matrix combinations that include . This overwrites the that was added by the previous entry.\n• adds only to the original matrix combinations that include .\n• cannot be added to any original matrix combination without overwriting a value, so it is added as an additional matrix combination.\n• cannot be added to any original matrix combination without overwriting a value, so it is added as an additional matrix combination. It does not add to the matrix combination because that combination was not one of the original matrix combinations.\n\nFor example, the following workflow will run four jobs, one for each combination of and . When the job for the value of and value of runs, an additional variable called with the value of will be included in the job.\n\nFor example, this matrix will run 10 jobs, one for each combination of and in the matrix, plus a job for the value of and value of .\n\nIf you don't specify any matrix variables, all configurations under will run. For example, the following workflow would run two jobs, one for each entry. This lets you take advantage of the matrix strategy without having a fully populated matrix.\n\nTo remove specific configurations defined in the matrix, use . An excluded configuration only has to be a partial match for it to be excluded. For example, the following workflow will run nine jobs: one job for each of the 12 configurations, minus the one excluded job that matches , and the two excluded jobs that match .\n\nYou can control how job failures are handled with and .\n\napplies to the entire matrix. If is set to or its expression evaluates to , GitHub will cancel all in-progress and queued jobs in the matrix if any job in the matrix fails. This property defaults to .\n\napplies to a single job. If is , other jobs in the matrix will continue running even if the job with fails.\n\nYou can use and together. For example, the following workflow will start four jobs. For each job, is determined by the value of . If any of the jobs with fail, all jobs that are in progress or queued will be cancelled. If the job with fails, the other jobs will not be affected.\n\nBy default, GitHub will maximize the number of jobs run in parallel depending on runner availability. To set the maximum number of jobs that can run simultaneously when using a job strategy, use .\n\nFor example, the following workflow will run a maximum of two jobs at a time, even if there are runners available to run all six jobs at once.\n\nPrevents a workflow run from failing when a job fails. Set to to allow a workflow run to pass when this job fails.\n\nYou can allow specific jobs in a job matrix to fail without failing the workflow run. For example, if you wanted to only allow an experimental job with set to to fail without failing the workflow run.\n\nUse to create a container to run any steps in a job that don't already specify a container. If you have steps that use both script and container actions, the container actions will run as sibling containers on the same network with the same volume mounts.\n\nIf you do not set a , all steps will run directly on the host specified by unless a step refers to an action configured to run in a container.\n\nWhen you only specify a container image, you can omit the keyword.\n\nUse to define the Docker image to use as the container to run the action. The value can be the Docker Hub image name or a registry name.\n\nIf the image's container registry requires authentication to pull the image, you can use to set a of the and . The credentials are the same values that you would provide to the command.\n\nUse to set a of environment variables in the container.\n\nUse to set an of ports to expose on the container.\n\nUse to set an of volumes for the container to use. You can use volumes to share data between services or other steps in a job. You can specify named Docker volumes, anonymous Docker volumes, or bind mounts on the host.\n\nTo specify a volume, you specify the source and destination path:\n\nThe is a volume name or an absolute path on the host machine, and is an absolute path in the container.\n\nUse to configure additional Docker container resource options. For a list of options, see options.\n\nUsed to host service containers for a job in a workflow. Service containers are useful for creating databases or cache services like Redis. The runner automatically creates a Docker network and manages the life cycle of the service containers.\n\nIf you configure your job to run in a container, or your step uses container actions, you don't need to map ports to access the service or action. Docker automatically exposes all ports between containers on the same Docker user-defined bridge network. You can directly reference the service container by its hostname. The hostname is automatically mapped to the label name you configure for the service in the workflow.\n\nIf you configure the job to run directly on the runner machine and your step doesn't use a container action, you must map any required Docker service container ports to the Docker host (the runner machine). You can access the service container using localhost and the mapped port.\n\nFor more information about the differences between networking service containers, see About service containers.\n\nThis example creates two services: nginx and redis. When you specify the container port but not the host port, the container port is randomly assigned to a free port on the host. GitHub sets the assigned host port in the context. In this example, you can access the service host ports using the and contexts.\n\nThe Docker image to use as the service container to run the action. The value can be the Docker Hub image name or a registry name.\n\nIf is assigned an empty string, the service will not start. You can use this to set up conditional services, similar to the following example.\n\nIf the image's container registry requires authentication to pull the image, you can use to set a of the and . The credentials are the same values that you would provide to the command.\n\nSets a of environment variables in the service container.\n\nSets an of ports to expose on the service container.\n\nSets an of volumes for the service container to use. You can use volumes to share data between services or other steps in a job. You can specify named Docker volumes, anonymous Docker volumes, or bind mounts on the host.\n\nTo specify a volume, you specify the source and destination path:\n\nThe is a volume name or an absolute path on the host machine, and is an absolute path in the container.\n\nAdditional Docker container resource options. For a list of options, see options.\n\nThe location and version of a reusable workflow file to run as a job. Use one of the following syntaxes:\n• for reusable workflows in public and private repositories.\n• for reusable workflows in the same repository.\n\nIn the first option, can be a SHA, a release tag, or a branch name. If a release tag and a branch have the same name, the release tag takes precedence over the branch name. Using the commit SHA is the safest option for stability and security. For more information, see Security hardening for GitHub Actions.\n\nIf you use the second syntax option (without and ) the called workflow is from the same commit as the caller workflow. Ref prefixes such as and are not allowed. You cannot use contexts or expressions in this keyword.\n\nFor more information, see Reusing workflows.\n\nWhen a job is used to call a reusable workflow, you can use to provide a map of inputs that are passed to the called workflow.\n\nAny inputs that you pass must match the input specifications defined in the called workflow.\n\nUnlike , the inputs you pass with are not available as environment variables in the called workflow. Instead, you can reference the inputs by using the context.\n\nA pair consisting of a string identifier for the input and the value of the input. The identifier must match the name of an input defined by in the called workflow. The data type of the value must match the type defined by in the called workflow.\n\nWhen a job is used to call a reusable workflow, you can use to provide a map of secrets that are passed to the called workflow.\n\nAny secrets that you pass must match the names defined in the called workflow.\n\nUse the keyword to pass all the calling workflow's secrets to the called workflow. This includes all secrets the calling workflow has access to, namely organization, repository, and environment secrets. The keyword can be used to pass secrets across repositories within the same organization, or across organizations within the same enterprise.\n\nA pair consisting of a string identifier for the secret and the value of the secret. The identifier must match the name of a secret defined by in the called workflow.\n\nYou can use special characters in path, branch, and tag filters.\n• : Matches zero or more characters, but does not match the character. For example, matches .\n• : Matches zero or more of any character.\n• : Matches zero or one of the preceding character.\n• : Matches one or more of the preceding character.\n• Matches one alphanumeric character listed in the brackets or included in ranges. Ranges can only include , , and . For example, the range matches any digit or lowercase letter. For example, matches or and matches and .\n• : At the start of a pattern makes it negate previous positive patterns. It has no special meaning if not the first character.\n\nThe characters , , and are special characters in YAML. If you start a pattern with , , or , you must enclose the pattern in quotes. Also, if you use a flow sequence with a pattern containing and/or , the pattern must be enclosed in quotes.\n\nFor more information about branch, tag, and path filter syntax, see , , and .\n\nPath patterns must match the whole path, and start from the repository's root."
    },
    {
        "link": "https://stepsecurity.io/blog/github-token-how-it-works-and-how-to-secure-automatic-github-action-tokens",
        "document": "GitHub Actions has tons of different tools and resources that make it a powerful and convenient platform for developers. One of these is the GITHUB_TOKEN, the API token automatically generated by GitHub for each GitHub Action job run. All steps in the GitHub Action job can use this token to interact with GitHub services.\n\nIn this blog, we'll delve into the nuances of GitHub Tokens, their permissions, and best practices for ensuring secure and efficient workflow execution.\n\nIf you are looking for a solution to secure GITHUB_TOKEN across your organization, checkout the StepSecurity GitHub App. The App discovers all GitHub Action workflows with elevated GITHUB_TOKEN permissions and helps set the minimum permissions.\n\nIf you’re looking for more blog on GitHub Actions security, check out these previous blogs:\n\nPinning GitHub Actions for Enhanced Security: Everything You Should Know\n\nThe GITHUB_TOKEN secret, is an automatically generated API token provided by GitHub for authentication within GitHub Actions workflows. This token serves as a means to interact with GitHub's APIs on behalf of GitHub Actions. When you enable GitHub Actions for a repository in your GitHub account, GitHub installs a GitHub App on the repository behind the scenes. GITHUB_TOKEN is actually a GitHub App installation access token. Each time a GitHub Actions job is run, GitHub generates a new installation access token for this app and injects it as GITHUB_TOKEN secret in the job runtime environment. The GitHUB_TOKEN expires when a job finishes or after 24 hours. As the app is installed on the repository, the token is authorized to call GitHub APIs only for the repository.\n\nYou can reference GITHUB_TOKEN in two ways inside your GitHub account.\n\nGitHub automatically creates an Action secret named GITHUB_TOKEN for all workflow runs. The example below shows how to access GITHUB_TOKEN as a secret:\n\nThe GitHub context also provides a property named token that contains the GITHUB_TOKEN value for the run. The example below shows how to use GITHUB_TOKEN from the context.\n\nMost GitHub dev tools such as GitHub CLI already know how to use GITHUB_TOKEN so you don’t need to do anything explict to make these tools work with GITHUB_TOKEN.\n\nPersonal access tokens are intended to access GitHub resources on behalf of the GitHub user for programmatic scenarios. As opposed to GITHUB_TOKEN, which is tied to a repository, PATs are tied to GitHub users. GITHUB_TOKEN lifecycle from generation to revocation is completely managed by GitHub. Whereas enterprises are responsible for managing PATs.\n\nFor GitHub Action, it’s recommended to use GITHUB_TOKEN wherever possible. As GITHUB_TOKEN is scoped to a repository, PAT (or GitHub Personal Access Token) is a solution in case you want a workflow to make GitHub API requests for another repository.\n\nAs GITHUB_TOKEN has permissions to make GitHub API requests, it can be misused to maliciously overwrite software releases and source code files. An adversary can compromise a build tool, dependency or Action to:\n• Run malicious code in the Action workflow to make GitHub API calls.\n• Exfiltrating GITHUB_TOKEN to a remote endpoint and using it outside of the runner.\n\nAll Actions can access the GITHUB_TOKEN secret by the GitHub context even if you don't explicitly pass the token to the Action.\n\nThe GITHUB_TOKEN permissions are limited only to your workflow-containing repository. However, it's essential to use the least privileged token permissions to ensure the security and efficiency of workflows. The token is authorized to call GitHub APIs for the following GitHub resources:\n\nIf you don’t set explicit token permissions, it will have write access to most of the resources mentioned above.\n\nWhy Do I Need to Modify GITHUB_TOKEN Permission?\n\nAs a security best practice, it’s essential to set minimum token permissions for GitHub Actions workflows. This will ensure that even if GITHUB_TOKEN is compromised, it will limit the extent of damage. There have been several real-world attacks related to GITHUB_TOKEN for malicious purposes. We have given a few examples below:\n• In February 2024, security researchers demonstrated that they could steal GITHUB_TOKEN by a command injection vulnerability in the Bazel project.\n• In January 2024, security researchers successfully carried out a supply chain attack on PyTorch and many other organizations, including GitHub itself, by exploiting CI/CD vulnerabilities in their repositories.\n• Another similar incident took place in December 2020 when a security researcher broke into Microsoft’s Visual Studio Code GitHub repository. The attack was due to a vulnerability in the CI script, and the researcher was able to get write access to the repository.\n\nAlso read: Analysis of Backdoored XZ Utils Build Process with Harden-Runner\n\nIf a GitHub Actions workflow file has the permissions property defined either at the workflow level or job level, it means that it has restricted permissions. The example below shows how one can explicitly set token permissions at the workflow and job level:\n\nHowever, absence of the permissions property does not mean that the workflow has elevated permissions as one can also set default workflow permissions at the repository or organization level (more on this in the section below). The conclusive way to check GITHUB_TOKEN permissions is to look at the build log for a workflow run under the ‘Set up job’ step.\n\nThe best way to implement the least privileged permissions for GITHUB_TOKEN is to set “Read repository contents and package permissions” as workflow permissions in repository/organization settings. This will ensure that all workflows inside the repository/organization have read-only access by default.\n\nAlternatively, the default setting may grant all read and write permissions to GITHUB_TOKEN. In such cases, you will have to manually define the least privileged permissions for GITHUB_TOKEN within each workflow file. As this method requires manual updates to each file, it can be challenging to manage permissions across various workflows at one time.\n\nYou can explicitly set token permissions in workflow files. One advantage of setting explicit token permissions in workflow files is that it would secure all forks on the repositories as well.\n\nTo modify permissions of GITHUB_TOKEN, you must use the permission key in the concerned workflow file. If a workflow is using a permission key:\n• GITHUB_TOKEN for the job will only have explicitly defined permissions in the permission key.\n• GitHub will set all unspecified permissions to “no access”. The only exception here would be the metadata scope which is always given a “read access” permission.\n• For forked repositories, permissions key can add or remove only “read” permissions. They can’t add “write” access for them.\n\nBefore you start setting permissions, know what the initial default setting of the permissions is for your enterprise. If the default setting is restrictive, all the repositories in the enterprise will have the same permissions by default.\n\nNow, to calculate the permission, check out the configurations of the workflow file, the workflow, and the job. You can modify the permissions of each of these levels separately.\n\nTo calculate minimum token permissions for a job, you need to analyze all the steps in it. For each step, you need to calculate minimum GitHub API permissions. For example, if a job step publishes a package on GitHub, it would require the packages:write permission. Similarly, if a job needs to manage pull requests, it will require the pull-requests:write permission. You can get minimum token permission for the job by adding minimum token permissions for all the steps in it.\n\nIf you were do this process manually, you may accidentally come up with restrictive permissions that break your workflow. You can iteratively come up with minimum token permissions by analyzing logs for failed workflow runs, identifying the GitHub APIs that return 403, and updating token permissions accordingly.\n\nTo make it easy for you to understand the right GITHUB_TOKEN permission for each job and set minimum token permissions for each workflow, StepSecurity is here for you! Let’s explore how StepScurity helps organizations set minimum token permission for the workflow files at scale.\n\nStepSecurity has built a knowledge base of required permissions for popular GitHub Actions. Using this knowledge base, we can calculate minimum token permissions for most workflow files. Not only does StepSecurity calculate minimum token permissions, but our platform also creates automated pull requests to update workflow files. You can try this out by visiting https://app.stepsecurity.io/securerepo\n\nFor enterprises, StepSecurity’s CI/CD infrastructure security platform monitors outbound GitHub API calls to determine the necessary permissions for each job. By analyzing the HTTP method and path of these calls, StepSecurity calculates the minimum GITHUB_TOKEN permissions for each workflow job, ensuring a granular and secure access control model. This approach is helpful for private Actions as well as public Actions for which, the knowledge base does not exist currently. You can read more about this feature here.\n\nHere are a few pull requests leveraging the StepSecurity platform to set minimum GITHUB_TOKEN permissions and more with automated pull requests:\n\nEager to learn more about how StepSecurity Harden-Runner helps you determine minimum GitHub_Token permissions using eBPF? Deep dive into our blog post here: https://www.stepsecurity.io/blog/determine-minimum-github-token-permissions-using-ebpf-with-stepsecurity-harden-runner\n\nLeverage StepSecurity to set the right GitHub permissions for all your workflows and get runtime security of GitHub API requests to enhance GitHub Actions security of your workflows. Try our app for free!\n\nAs we wrap up this blog about GITHUB_TOKEN, it is evident that setting minimum GITHUB_TOKEN permissions play a huge role in securing your GitHub Actions environment. Setting least privileged access for GITHUB_TOKEN is one of the most important recommended GitHub Actions security best practices and cannot be overlooked. With careful implementation of this best practice, you can gain control of your CI/CD environment and ensure its safety.\n\nYou don't need to manually generate a GitHub personal access token. GitHub automatically creates and injects the GITHUB_TOKEN for each job run in your GitHub Actions workflow. This token is specific to your repository and is used for authentication within GitHub Actions workflows.\n\nHow to use GITHUB_TOKEN?\n\nTo use the GITHUB_TOKEN in your GitHub Actions workflow, you can reference it as a secret called ${{ secrets.GITHUB_TOKEN }}. This GITHUB_TOKEN secret allows your workflow to authenticate and interact with GitHub's APIs on behalf of GitHub Actions, enabling various actions such as pushing changes, creating issues, and more.\n\nWhere do I find my GITHUB_TOKEN?\n\nYou can access the GITHUB_TOKEN within your GitHub Actions workflow using the ${{ secrets.GITHUB_TOKEN }} syntax. This token is automatically generated and injected by GitHub at the beginning of each job run, making it readily available for authentication and API interactions within your workflow.\n\nHow do I authenticate with GITHUB_TOKEN?\n\nAuthentication with the GITHUB_TOKEN is automatic within GitHub Actions workflows. When you reference ${{ secrets.GITHUB_TOKEN }} in your workflow file, GitHub automatically handles the authentication process for you. This token grants the necessary permissions to interact with GitHub APIs securely during the execution of your workflow."
    },
    {
        "link": "https://github.blog/enterprise-software/ci-cd/build-ci-cd-pipeline-github-actions-four-steps",
        "document": "Learn how GitHub Artifact Attestations can enhance your build security and help your organization achieve SLSA Level 3. This post breaks down the basics of SLSA, explains the importance of artifact attestations, and provides a step-by-step guide to securing your build process."
    },
    {
        "link": "https://medium.com/@bhumikadasari0/a-beginners-guide-to-git-workflow-and-implementing-ci-cd-with-github-actions-040b4e03635e",
        "document": "Git is the backbone of modern software development, enabling teams to collaborate seamlessly on codebases. Coupled with CI/CD (Continuous Integration and Continuous Deployment), Git becomes a powerful tool to streamline workflows and accelerate project delivery. This article walks you through essential Git commands and introduces you to setting up a CI/CD pipeline using GitHub Actions.\n• Continuous Integration (CI): Automates the integration of code changes into the repository, ensuring all contributions are merged into a shared branch frequently and tested for errors.\n• Continuous Deployment (CD): Automatically deploys the application after code changes are pushed, enabling faster delivery to end-users.\n\nGit allows developers to manage and version-control their projects effectively. Below are some of the fundamental Git commands you’ll frequently use:\n\nCreates a new Git repository in your local directory.\n\nCheck the status of your repository:\n\nDisplays changes in your working directory, such as untracked or modified files.\n\nStages all changes in your working directory for the next commit.\n\nSaves your changes with a descriptive message explaining what you modified.\n\nPush changes to the remote repository:\n\nUploads your local changes to the remote repository.\n\nPushes the committed changes from your local repository to the master branch of the remote repository."
    },
    {
        "link": "https://docs.github.com/articles/getting-started-with-github-actions",
        "document": "GitHub Actions is a continuous integration and continuous delivery (CI/CD) platform that allows you to automate your build, test, and deployment pipeline. You can create workflows that build and test every pull request to your repository, or deploy merged pull requests to production.\n\nGitHub Actions goes beyond just DevOps and lets you run workflows when other events happen in your repository. For example, you can run a workflow to automatically add the appropriate labels whenever someone creates a new issue in your repository.\n\nGitHub provides Linux, Windows, and macOS virtual machines to run your workflows, or you can host your own self-hosted runners in your own data center or cloud infrastructure.\n\nYou can configure a GitHub Actions workflow to be triggered when an event occurs in your repository, such as a pull request being opened or an issue being created. Your workflow contains one or more jobs which can run in sequential order or in parallel. Each job will run inside its own virtual machine runner, or inside a container, and has one or more steps that either run a script that you define or run an action, which is a reusable extension that can simplify your workflow.\n\nA workflow is a configurable automated process that will run one or more jobs. Workflows are defined by a YAML file checked in to your repository and will run when triggered by an event in your repository, or they can be triggered manually, or at a defined schedule.\n\nWorkflows are defined in the directory in a repository. A repository can have multiple workflows, each of which can perform a different set of tasks such as:\n• Deploying your application every time a release is created\n• Adding a label whenever a new issue is opened\n\nYou can reference a workflow within another workflow. For more information, see Reusing workflows.\n\nFor more information, see Writing workflows.\n\nAn event is a specific activity in a repository that triggers a workflow run. For example, an activity can originate from GitHub when someone creates a pull request, opens an issue, or pushes a commit to a repository. You can also trigger a workflow to run on a schedule, by posting to a REST API, or manually.\n\nFor a complete list of events that can be used to trigger workflows, see Events that trigger workflows.\n\nA job is a set of steps in a workflow that is executed on the same runner. Each step is either a shell script that will be executed, or an action that will be run. Steps are executed in order and are dependent on each other. Since each step is executed on the same runner, you can share data from one step to another. For example, you can have a step that builds your application followed by a step that tests the application that was built.\n\nYou can configure a job's dependencies with other jobs; by default, jobs have no dependencies and run in parallel. When a job takes a dependency on another job, it waits for the dependent job to complete before running.\n\nFor example, you might configure multiple build jobs for different architectures without any job dependencies and a packaging job that depends on those builds. The build jobs run in parallel, and once they complete successfully, the packaging job runs.\n\nFor more information, see Choosing what your workflow does.\n\nAn action is a custom application for the GitHub Actions platform that performs a complex but frequently repeated task. Use an action to help reduce the amount of repetitive code that you write in your workflow files. An action can pull your Git repository from GitHub, set up the correct toolchain for your build environment, or set up the authentication to your cloud provider.\n\nYou can write your own actions, or you can find actions to use in your workflows in the GitHub Marketplace.\n\nFor more information on actions, see Sharing automations.\n\nA runner is a server that runs your workflows when they're triggered. Each runner can run a single job at a time. GitHub provides Ubuntu Linux, Microsoft Windows, and macOS runners to run your workflows. Each workflow run executes in a fresh, newly-provisioned virtual machine.\n\nGitHub also offers larger runners, which are available in larger configurations. For more information, see Using larger runners.\n\nIf you need a different operating system or require a specific hardware configuration, you can host your own runners.\n\nFor more information about self-hosted runners, see Hosting your own runners.\n\nGitHub Actions can help you automate nearly every aspect of your application development processes. Ready to get started? Here are some helpful resources for taking your next steps with GitHub Actions:\n• To create a GitHub Actions workflow, see Using workflow templates.\n• For continuous integration (CI) workflows, see Building and testing.\n• For building and publishing packages, see Publishing packages.\n• For deploying projects, see Use cases and examples.\n• For automating tasks and processes on GitHub, see Managing projects.\n• For examples that demonstrate more complex features of GitHub Actions, see Use cases and examples. These detailed examples explain how to test your code on a runner, access the GitHub CLI, and use advanced features such as concurrency and test matrices.\n• To certify your proficiency in automating workflows and accelerating development with GitHub Actions, earn a GitHub Actions certificate with GitHub Certifications. For more information, see About GitHub Certifications."
    },
    {
        "link": "https://codefresh.io/learn/github-actions/deployment-with-github-actions",
        "document": "GitHub provides GitHub Actions, a CI/CD (Continuous Integration/Continuous Deployment) platform that automates application deployment. It integrates with your GitHub code repository, allowing you to define workflows in YAML files that execute predefined steps when triggered. These actions can deploy code to various environments including VM servers, cloud infrastructures, and Kubernetes clusters.\n\nGitHub Actions supports continuous deployment (CD), which is the practice of deploying every code change to production, following automated testing. You can use GitHub Actions to ensure that every change to the codebase is automatically built, tested, and deployed without manual intervention, thereby speeding up the software delivery process.\n\nGitHub Actions enables you to set up custom workflows that can be triggered by various events, such as code pushes, pull requests, or scheduled times. Each workflow is defined in a YAML file within the repository, specifying the steps required to build, test, and deploy the application.\n\nTo set up a CD workflow with GitHub Actions, start by defining a workflow YAML file in your repository. This file will outline the steps to build, test, and deploy your application.\n\nNote: The following example assumes that you have Kubernetes running on your system. You can run a minimal Kubernetes cluster using minikube.\n\nSuppose you have a Python script called app.py that calls an API to get current gold prices. You can configure the workflow to trigger on specific events, such as pushing code to the main branch:\n\nIn this example, the workflow is triggered by a push to the main branch. It includes separate jobs for building and deploying the application. We use a simple Dockerfile to create an image for our Python code.\n\nThe first step logs into Docker Hub using docker hub username and password from Github secrets.\n\nThis second step builds the image and pushes the built image to Dockerhub.\n\nLet’s make changes to a file in our repository and initiate Github action:\n\nNow browse to the Actions page of your github repository, you will see an action is automatically triggered:\n\nOnce Actions finish running, you can check deployment on your Kubernetes cluster by using the following command:\n\nThe output should look something like this:\n\nLearn more in our detailed guide to GitHub actions workflow.\n\nThese instructions are adapted from the GitHub documentation.\n\nYou can use a variety of events to trigger your deployment workflow in GitHub Actions. Common triggers include pull_request, push, and workflow_dispatch.\n\nFor example, the following workflow triggers on:\n\nNote: You can use multiple branches for push or pull_request triggers. Using a wildcard such as feature/* will start GitHub action for all branches starting with feature/\n\nEnvironments in GitHub Actions represent deployment targets such as production, staging, or development. They can be used to enforce rules before a job proceeds, such as requiring approvals or limiting access to secrets.\n\nTo use environments, define them in your workflow like this:\n\nThis setup allows you to monitor and control deployments per environment, enhancing security and process adherence.\n\nConcurrency in GitHub Actions ensures that only a single job or workflow with the same concurrency group runs at a time. This is useful for preventing multiple deployments to the same environment simultaneously.\n\nTo implement concurrency, add the concurrency key in your workflow:\n\nThis configuration ensures that if a deployment to the production environment is already in progress, any new deployment will be paused until the current one finishes.\n\nIntegrating GitHub with communication platforms like Microsoft Teams or Slack can help track deployments. You can receive notifications about deployment statuses and approvals, providing real-time updates to your team.\n\nFor example, to set up Slack notifications, you would configure your GitHub repository to send updates through a Slack app:\n\nSecrets like API keys and passwords must be managed carefully in any deployment environment. GitHub Actions allows you to store and manage secrets through the GitHub repository’s settings. Access to these secrets can be granted on a per-environment basis, ensuring that only specified workflows can access them.\n\nKeeping secrets within GitHub’s encrypted storage means they are not stored in plaintext in code repositories. This reduces the risk of accidental leaks, providing a way to handle sensitive information.\n\n2. Use the Least Privilege Principle\n\nImplementing the principle of least privilege means giving only the minimum access required for a task. In GitHub Actions, you can restrict permissions for workflows, ensuring they only have access to what they need. This reduces the risk of malicious actions if a workflow is compromised.\n\nBy limiting permissions and using role-based access controls, you can minimize the potential damage caused by an exploited workflow. This is a step in securing your deployment pipeline.\n\nCaching dependencies in GitHub Actions can significantly speed up your build and deployment processes. By using the cache action, you can store dependencies like npm packages or Maven repositories between workflow runs. This reduces setup time and improves efficiency.\n\nEffective caching not only accelerates deployments but also reduces external dependency load times, which can be variable. This leads to more predictable and reliable build times.\n\nRunning jobs in parallel is a way to reduce the time it takes for your workflows to complete. GitHub Actions supports parallel job execution, allowing you to break down tasks and run them simultaneously. This can expedite complex pipelines, improving productivity.\n\nWhen parallelizing jobs, make sure that dependent tasks are correctly sequenced to avoid issues. Proper job management can lead to much faster execution without compromising on task reliability or success rates.\n\nClean and readable workflows are easier to maintain and debug. Use comments, consistent naming conventions, and well-structured YAML files to make workflows understandable. This practice benefits the original authors and helps team members who need to understand or modify the workflows later.\n\nHaving well-documented workflows makes onboarding new team members easier and ensures consistency in deployment processes. Readability and maintainability should be prioritized to facilitate workflow management.\n\nCombine GitHub Actions with Codefresh to Support GitOps and Kubernetes Deployments\n\nGitHub actions is a very powerful platform but it is focused mostly on CI and does not support GitOps and native Kubernetes deployments. Codefresh is created specifically for GitOps and Cloud native applications and includes native support for using GitHub Actions for the CI part of the Software lifecycle.\n\nThis means that you can get the best of both worlds by keeping all your CI workflows in GitHub Actions, while using Codefresh for advanced features such as:\n\nIn case you are new to Codefresh – we have made it our mission since 2014 to help teams accelerate their pace of innovation. Codefresh recently released a completely rebuilt GitOps CI/CD toolset. Powered by Argo, Codefresh now combines the best of open source with an enterprise-grade runtime allowing you to fully tap the power of Argo Workflows, Events, CD, and Rollouts. It provides teams with a unified GitOps experience to build, test, deploy, and scale their applications."
    },
    {
        "link": "https://docs.github.com/en/actions/about-github-actions/about-continuous-integration-with-github-actions",
        "document": "Continuous integration (CI) is a software practice that requires frequently committing code to a shared repository. Committing code more often detects errors sooner and reduces the amount of code a developer needs to debug when finding the source of an error. Frequent code updates also make it easier to merge changes from different members of a software development team. This is great for developers, who can spend more time writing code and less time debugging errors or resolving merge conflicts.\n\nWhen you commit code to your repository, you can continuously build and test the code to make sure that the commit doesn't introduce errors. Your tests can include code linters (which check style formatting), security checks, code coverage, functional tests, and other custom checks.\n\nBuilding and testing your code requires a server. You can build and test updates locally before pushing code to a repository, or you can use a CI server that checks for new code commits in a repository.\n\nCI using GitHub Actions offers workflows that can build the code in your repository and run your tests. Workflows can run on GitHub-hosted virtual machines, or on machines that you host yourself. For more information, see Using GitHub-hosted runners and About self-hosted runners.\n\nYou can configure your CI workflow to run when a GitHub event occurs (for example, when new code is pushed to your repository), on a set schedule, or when an external event occurs using the repository dispatch webhook.\n\nGitHub runs your CI tests and provides the results of each test in the pull request, so you can see whether the change in your branch introduces an error. When all CI tests in a workflow pass, the changes you pushed are ready to be reviewed by a team member or merged. When a test fails, one of your changes may have caused the failure.\n\nWhen you set up CI in your repository, GitHub analyzes the code in your repository and recommends CI workflows based on the language and framework in your repository. For example, if you use Node.js, GitHub will suggest a workflow template that installs your Node.js packages and runs your tests. You can use the CI workflow template suggested by GitHub, customize the suggested workflow template, or create your own custom workflow file to run your CI tests.\n\nIn addition to helping you set up CI workflows for your project, you can use GitHub Actions to create workflows across the full software development life cycle. For example, you can use actions to deploy, package, or release your project. For more information, see Writing workflows.\n\nFor a definition of common terms, see Understanding GitHub Actions.\n\nGitHub offers CI workflow templates for a variety of languages and frameworks.\n\nBrowse the complete list of CI workflow templates offered by GitHub in the actions/starter-workflows repository."
    }
]