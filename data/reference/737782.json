[
    {
        "link": "https://bleak.readthedocs.io",
        "document": "Bleak is an acronym for Bluetooth Low Energy platform Agnostic Klient.\n\nBleak is a GATT client software, capable of connecting to BLE devices acting as GATT servers. It is designed to provide a asynchronous, cross-platform Python API to connect and communicate with e.g. sensors."
    },
    {
        "link": "https://github.com/hbldh/bleak",
        "document": "Bleak is an acronym for Bluetooth Low Energy platform Agnostic Klient.\n\nBleak is a GATT client software, capable of connecting to BLE devices acting as GATT servers. It is designed to provide a asynchronous, cross-platform Python API to connect and communicate with e.g. sensors.\n• OS X/macOS support via Core Bluetooth API, from at least OS X version 10.11\n\nBleak supports reading, writing and getting notifications from GATT servers, as well as a function for discovering BLE devices.\n\nTo discover Bluetooth devices that can be connected to:\n\nConnect to a Bluetooth device and read its model number:\n\nDO NOT NAME YOUR SCRIPT ! It will cause a circular import error.\n\nSee examples folder for more code, for instance example code for connecting to a TI SensorTag CC2650"
    },
    {
        "link": "https://bleak.readthedocs.io/en/latest/api/client.html",
        "document": "The Client interface for connecting to a specific BLE GATT server and communicating with it. A BleakClient can be used as an asynchronous context manager in which case it automatically connects and disconnects. How many BLE connections can be active simultaneously, and whether connections can be active while scanning depends on the Bluetooth adapter hardware.\n• None address_or_ble_device – A received from a or a Bluetooth address (device UUID on macOS).\n• None disconnected_callback – Callback that will be scheduled in the event loop when the client is disconnected. The callable must take one argument, which will be this client object.\n• None services – Optional list of services to filter. If provided, only these services will be resolved. This may or may not reduce the time needed to enumerate the services depending on if the OS supports such filtering in the Bluetooth stack or not (should affect Windows and Mac). These can be 16-bit or 128-bit UUIDs.\n• None timeout – Timeout in seconds passed to the implicit call when is not a . Defaults to 10.0.\n• None backend – Used to override the automatically selected backend (i.e. for a custom backend). Although example code frequently initializes with a Bluetooth address for simplicity, it is not recommended to do so for more complex use cases. There are several known issues with providing a Bluetooth address as the argument.\n• None macOS does not provide access to the Bluetooth address for privacy/ security reasons. Instead it creates a UUID for each Bluetooth device which is used in place of the address on this platform.\n• None Providing an address or UUID instead of a causes the method to implicitly call . This is known to cause problems when trying to connect to multiple devices at the same time. Changed in version 0.15: is no longer keyword-only. Added parameter. Changed in version 0.18: No longer is alias for backend type and no longer inherits from . Added parameter.\n\nBefore doing anything else with a object, it must be connected. is a an async context manager, so the recommended way of connecting is to use it as such: # Using asyncio.run() is important to ensure that device disconnects on It is also possible to connect and disconnect without a context manager, however this can leave the device still connected when the program exits: Connect to the specified GATT server. **kwargs – For backwards compatibility - should not be used. Disconnect from the specified GATT server. The current connection status can be retrieved with: Check connection status between this client and the GATT server. A callback can be provided to the constructor via the argument to be notified of disconnection events.\n\nAll Bluetooth Low Energy devices use a common Generic Attribute Profile (GATT) for interacting with the device after it is connected. Some GATT operations like discovering the services/characteristic/descriptors and negotiating the MTU are handled automatically by Bleak and/or the OS Bluetooth stack. The primary operations for the Bleak client are reading, writing and subscribing to characteristics. The available services on a device are automatically enumerated when connecting to a device. Services describe the devices capabilities. Gets the collection of GATT services available on the device. The returned value is only valid as long as the device is connected. BleakError – if service discovery has not been performed yet during this connection. Most I/O with a device is done via the characteristics. Perform read operation on the specified GATT characteristic. char_specifier – The characteristic to read from, specified by either integer handle, UUID or directly by the BleakGATTCharacteristic object representing it. Perform a write operation on the specified GATT characteristic. There are two possible kinds of writes. Write with response (sometimes called a Request) will write the data then wait for a response from the remote device. Write without response (sometimes called Command) will queue data to be written and return immediately. Each characteristic may support one kind or the other or both or neither. Consult the device’s documentation or inspect the properties of the characteristic to find out which kind of writes are supported. Explicit is better than implicit. Best practice is to always include an explicit or when calling this method.\n• None char_specifier – The characteristic to write to, specified by either integer handle, UUID or directly by the object representing it. If a device has more than one characteristic with the same UUID, then attempting to use the UUID wil fail and a characteristic object must be used instead.\n• None data – The data to send. When a write-with-response operation is used, the length of the data is limited to 512 bytes. When a write-without-response operation is used, the length of the data is limited to . Any type that supports the buffer protocol can be passed.\n• None response – If , a write-with-response operation will be used. If , a write-without-response operation will be used. If omitted or , the “best” operation will be used based on the reported properties of the characteristic. Changed in version 0.21: The default behavior when is omitted was changed. Callbacks must accept two inputs. The first will be the characteristic and the second will be a containing the data received.\n• None char_specifier – The characteristic to activate notifications/indications on a characteristic, specified by either integer handle, UUID or directly by the BleakGATTCharacteristic object representing it.\n• None callback – The function to be called on notification. Can be regular function or async function. Changed in version 0.18: The first argument of the callback is now a instead of an . char_specifier – The characteristic to deactivate notification/indication on, specified by either integer handle, UUID or directly by the BleakGATTCharacteristic object representing it. Notifications are stopped automatically on disconnect, so this method does not need to be called unless notifications need to be stopped some time before the device disconnects. Perform read operation on the specified GATT descriptor. handle – The handle of the descriptor to read from. Perform a write operation on the specified GATT descriptor.\n• None handle – The handle of the descriptor to read from."
    },
    {
        "link": "https://pypi.org/project/bleak",
        "document": "A required part of this site couldn’t load. This may be due to a browser extension, network issues, or browser settings. Please check your connection, disable any ad blockers, or try using a different browser."
    },
    {
        "link": "https://getwavecake.com/blog/getting-started-with-bluetooth-and-python-part-2",
        "document": "Messy code can derail a project. It can lead to spending an excessive amount of time on things like troubleshooting and maintenance. Writing clean and reusable code allows programmers to keep moving the project forward as quickly as possible.\n\nThis post is the second installment of a series of posts I'm putting together about Python and Bleak. If you're a little lost, you might want to check out the first post here.\n\nIn this blog, I'm going to focus on keeping your code clean by creating a Python class for your device. Here's a quick introduction to some of the terms.\n• Bleak - A Python library for Bluetooth devices. Python does not have any built in ability to send Bluetooth messages. In order to communicate with a Bluetooth device using Python, you need to import a library. Bleak uses your computer's internal hardware to communicate with Bluetooth devices. You do not need to setup your computer with any special configuration settings. Python takes care of most of the hard stuff for us.\n• Library - Python libraries are collections of pre-written code and functions that extend the capabilities of the Python programming language.\n• Class - In Python, a class is a separate set of code that's meant to be reused. Often, a class is kept in a separate file and imported into the main program.\n• Device - This is the gadget that's sitting on your desk. It could be a pair of headphones, a devkit, or a full blown prototype. We want to use Python and Bleak to communicate with this device.\n\nClasses are a key tool for keeping code readable. By creating a separate class for our device, the main program can keep some of the messy details hidden. In the end, you'll be able to read your program like a book. Here's what the final code will look like.\n\nIf you're here to automate a Bluetooth process using Python, now's the time to point out that you could be using Wavecake instead. I built Wavecake to make it easier to share Bluetooth automations amongst teams. It's in a free Beta release. I'm actively seeking feedback. Please feel free to give it a shot and pass along your two cents!\n\nI think one of the better ways to hide the complexity of using Bleak for a device class is to combine the discovery and the connection steps into a single connect call. The discovery step finds the device. The connection step initiates the connection. With Bluetooth, you always need to do both, so why not combine them?\n\nSide note: When using Bleak, there's a temptation to incorporate the device mac address into the user flow. However, it's not a best practice. Most Bluetooth APIs (Apple's CoreBluetooth in particular) do not let you access the mac address. It's best to get used to discovering the device so that your process will scale.\n\nI went ahead and threw in a function for disconnect as well so that we can fully test this code after putting it together.\n\nThis code uses a pretty simple discovery routine. First, it looks for devices for 5 seconds. It then searches through the list for devices that match the specified name. If you're like me, you might have a lot of devices with the same name lying around your workbench. To prevent any confusion, I added an RSSI requirement. If the device is close, with an RSSI of greater than -90, then the discovery routine will return a result. The connection routine then uses the address to make a connection.\n\nBleak supports several other ways to discover devices. Name tends to be the most straightforward to work with in the beginning. For instance, if your device is named 'Tempsense10', you can use the discover function to look for all devices named 'Tempsense10'. To better future-proof your design, you might want to start incorporating discovery based on the device UUID or the device's manufacturing data.\n\nNow, in your original file, your code calling into the class should look like this.\n\nIt's so clean. The possibilities are now endless! Let's continue.\n\nNow that we can connect and disconnect from the device, it's time to expand on what our class can provide. We'll begin by writing a generic function to read characteristics. Then, we'll write a device specific function for reading the battery level.\n\nTo start, I'll create the definition for a read characteristic function.\n\nThis function is pretty straightforward. I like to have it isolated rather than combined, even though it's just one line of code. This allows you to raise the exception from a single place. That makes the higher level functions easier to write.\n\nNow, I need to create a high-level function that will perform a device specific interaction. For this tutorial, I'll use the example of getting the battery life. First, add the UUID definition to the init function.\n\nNext, use our read characteristic function. This is a great place to hide any formatting of your bytes. In this case, we convert the byte array to an integer. This let's us report the battery level back as an even number.\n\nAll together, it should look like this.\n\nNow we can add this function to our routine.\n\nIn this blog, we have done the basics of outlining a Bluetooth class for a custom device. Creating a device class takes a lot of the headaches out of scaling the code in a variety of different ways. We didn't touch on any direct examples, but I've used this method for creating test routines in addition to incorporating it into a UI. Hopefully your code can look a little cleaner, and your workflow can get a little more efficient.\n\nIf you've made it to the end of this tutorial and find the prospect a little bit daunting, you should check out Wavecake. The tool includes a library and environment. It can help you share your work with your team and break down friction involved in automation for embedded devices.\n\nI've included the complete example code for the device class below."
    },
    {
        "link": "https://stackoverflow.com/questions/62162898/run-bleak-python-library-in-background-with-asyncio",
        "document": "I want to use the bleak library in Python to receive data from a Bluetooth Low Energy device. This part is working. My problem is now, that I don't know how to run this code in the background or parallel.\n\nEventually, I want to build a tiny python app which is processing the data from the Bluetooth device. So bleak is looping all the time fetching data from a bluetooth device and sending it to the main process where it is processed and displayed.\n\nFor some reason, bleak does not run in a thread. Is it possible to use asyncio for this (since it is already used by bleak maybe a good way to go)?\n\nI checked out threads and multiprocessing but somehow I found only examples without processes which loop infinitely and send data. I'm totally new to the topic of parallelization and/or asynchronous processes. Maybe one of you can give a hint where to look for a proper solution for this case.\n\nBelow is my code so far (for now I just loop and print data)."
    },
    {
        "link": "https://stackoverflow.com/questions/78546933/python-bleak-notifications-with-a-ble-rubiks-cube",
        "document": "I am using python 3.12 with bleak to try and communicate with a BLE rubik's cube. Currently all I can do is pull the model id with this code:\n\nThis Works as Expected and prints the following out but when I try to read or start notifications on other characteristics nothing seems to happen. I added notification code like this:\n\nEven when I added this code, the output is the same and it finishes executing almost immediately after printing out the name. I do not believe I am using the wrong characteristic and more information about the cube's specific protocol can be found on this gituhb page. Additionally, I tested the notifications using a debugging app on my phone it notified my phone just fine. My main goal is to get the move notation every time the cube spins which I will eventually use to come up with a solution to the cube."
    },
    {
        "link": "https://github.com/hbldh/bleak/discussions/481",
        "document": "To see all available qualifiers, see our documentation .\n\nSaved searches Use saved searches to filter your results more quickly\n\nWe read every piece of feedback, and take your input very seriously.\n\nYou signed in with another tab or window. Reload to refresh your session.\n\nYou signed out in another tab or window. Reload to refresh your session.\n\nYou switched accounts on another tab or window. Reload to refresh your session."
    },
    {
        "link": "https://github.com/hbldh/bleak/discussions/1216",
        "document": "To see all available qualifiers, see our documentation .\n\nSaved searches Use saved searches to filter your results more quickly\n\nWe read every piece of feedback, and take your input very seriously.\n\nYou signed in with another tab or window. Reload to refresh your session.\n\nYou signed out in another tab or window. Reload to refresh your session.\n\nYou switched accounts on another tab or window. Reload to refresh your session."
    },
    {
        "link": "https://python-forum.io/thread-39896.html",
        "document": "... and\n\n \n\n Then only one is displayed to me, since both have the same name: notification_handler. If I rename it to notification_handler2, for example, the function no longer works. What can I do there?\n\n \n\n Link to the library bleak: \n\n GitHub Hello, when I read out 2 characteristics via Bleak and BLE, via the command:... andThen only one is displayed to me, since both have the same name: notification_handler. If I rename it to notification_handler2, for example, the function no longer works. What can I do there?Link to the library bleak: https://github.com/hbldh/bleak GitHub \n\n \n\n You need to post your code for anyone to be able to help you. Also describe exacty what you are trying to accomplish. The two functions you posted are identical. If they really do what you want, you only need one function (which is what you got when you gave them the same name). Same name or not, the functions do exactly the same thing and there is no need for a second.You need to post your code for anyone to be able to help you. Also describe exacty what you are trying to accomplish. The two functions you posted are identical. If they really do what you want, you only need one function (which is what you got when you gave them the same name). Same name or not, the functions do exactly the same thing and there is no need for a second.\n\n \n\n You need to post your code for anyone to be able to help you. Also describe exacty what you are trying to accomplish. \n\n Hi,\n\n \n\n i have an ESP 32 and here i read a Sensor with 2 value, i collect 100 readings in an array. To the 2 value i add a Characteristic and then i start a notify after collect 100 readings. In my python app i want to print the value with the titel. But at the moment i can only print 1 array with the function i postet above or i can print all together.\n\n \n\n Here is my ESP32 Code: \n\n \n\n This is the code to get 1 sensor value:\n\n \n\n https://github.com/ImmanuelT8/Smart-Heal..._notify.py\n\n \n\n With this Code i get both arrays but together and i can't add them a titel:\n\n \n\n import asyncio from bleak import BleakClient import numpy address = \"CC:50:E3:9C:15:02\" MODEL_NBR_UUID = \"beb5483e-36e1-4688-b7f5-ea07361b26a8\" MODEL_NBR_UUID2 = \"beb5483e-36e1-4688-b7f5-ea07361b26a9\" async def read_data(address): async with BleakClient(address) as client: # Abonniere beide Charakteristiken await client.start_notify(\"beb5483e-36e1-4688-b7f5-ea07361b26a8\", notification_handler) await client.start_notify(\"beb5483e-36e1-4688-b7f5-ea07361b26a9\", notification_handler) # Warte auf Daten while True: await asyncio.sleep(1) async def notification_handler(sender, data): # Daten in numpy-Array umwandeln values = numpy.frombuffer(data, dtype=numpy.uint32) print(values) async def main(address): await read_data(address) asyncio.run(main(address)) This code does not work:\n\n \n\n Is this information enough? Hi,i have an ESP 32 and here i read a Sensor with 2 value, i collect 100 readings in an array. To the 2 value i add a Characteristic and then i start a notify after collect 100 readings. In my python app i want to print the value with the titel. But at the moment i can only print 1 array with the function i postet above or i can print all together.Here is my ESP32 Code: https://github.com/ImmanuelT8/Smart-Heal...te_aus.ino This is the code to get 1 sensor value:With this Code i get both arrays but together and i can't add them a titel:This code does not work:Is this information enough? \n\n import asyncio from bleak import BleakClient UID_1 = \"beb5483e-36e1-4688-b7f5-ea07361b26a8\" UID_2 = \"beb5483e-36e1-4688-b7f5-ea07361b26a9\" async def read_data(address): async with BleakClient(address) as client: await client.start_notify(UID_1, notification_handler) # You assigned this a name. Use the name. await client.start_notify(UID_2, notification_handler) while True: await asyncio.sleep(1) async def notification_handler(sender, data): print(\"Sender:\", sender) async def main(address): await read_data(address) asyncio.run(main(\"CC:50:E3:9C:15:02\")) Do you see it printing the both UUID's? Do you only see one? If so, which one? What happens if you run this?Do you see it printing the both UUID's? Do you only see one? If so, which one? \n\n \n\n Btw if i want to get the data into a table, how would you handle it? At the moment i have 2 threads, one for the BLE and the other for my tkinter window, but how i can show the data in a tabel? First safe them into a svg or mySQL ? I get the code running, thanks for help!Btw if i want to get the data into a table, how would you handle it? At the moment i have 2 threads, one for the BLE and the other for my tkinter window, but how i can show the data in a tabel? First safe them into a svg or mySQL ? Could I impose upon you to answer the questions I asked in my post? I don't really want to try to duplicate the experiment myself and am curious about what you learned. It could be useful for others trying to use the bleak library. I have serious doubts about your threading. It makes no sense to make a thread for tkinter. You need 2 threads, not 3. Use the main thread for tkinter and create a new thread to read BT. Could I impose upon you to answer the questions I asked in my post? I don't really want to try to duplicate the experiment myself and am curious about what you learned. It could be useful for others trying to use the bleak library. I have serious doubts about your threading. It makes no sense to make a thread for tkinter. You need 2 threads, not 3. Use the main thread for tkinter and create a new thread to read BT. \n\n Hi, \n\n \n\n to get the value from 2 parameters with notify you need to make 2 handle_notify functions and 1 read_data. \n\n async def handle_uuid1_notify(self, sender, data): spo2_values = numpy.frombuffer(data, dtype=numpy.uint32) print(\"Red: {0}\".format(spo2_values)) for spo2_value in spo2_values: table.add_row([spo2_value, \"\"]) print_table() async def handle_uuid2_notify(self, sender, data): ir_values = numpy.frombuffer(data, dtype=numpy.uint32) print(\"IR: {0}\".format(ir_values)) for ir_value in ir_values: table.add_row([\"\", ir_value]) print_table() and\n\n \n\n async def read_data(self): UUID1 = \"beb5483e-36e1-4688-b7f5-ea07361b26a8\" UUID2 = \"beb5483e-36e1-4688-b7f5-ea07361b26a9\" async with BleakClient(self.address) as client: await client.start_notify(UUID1, self.handle_uuid1_notify) await client.start_notify(UUID2, self.handle_uuid2_notify) while True: await asyncio.sleep(1) Because i want a GUI i had make multithreading, so the functions are in the class BLEThread:\n\n \n\n Then i make a start threading function:\n\n \n\n and start them\n\n \n\n Hi,to get the value from 2 parameters with notify you need to make 2 handle_notify functions and 1 read_data.andBecause i want a GUI i had make multithreading, so the functions are in the class BLEThread:Then i make a start threading function:and start them What happens if you run this? \n\n Sry for my lat reply to your question. If i run this i get this:\n\n \n\n \n\n If this should be the BLE Devie name it should be ESP:\n\n \n\n ESP_SPO2 (CC:50:E3:9C:15:02)\n\n \n\n I will try to restart the ESP and check it again. Sry for my lat reply to your question. If i run this i get this:If this should be the BLE Devie name it should be ESP:ESP_SPO2 (CC:50:E3:9C:15:02)I will try to restart the ESP and check it again."
    }
]