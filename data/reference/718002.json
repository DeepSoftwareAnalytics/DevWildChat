[
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/visual-basic/programming-guide/language-features/strings/interpolated-strings",
        "document": "Used to construct strings. An interpolated string looks like a template string that contains interpolated expressions. An interpolated string returns a string that replaces the interpolated expressions that it contains with their string representations. This feature is available in Visual Basic 14 and later versions.\n\nThe arguments of an interpolated string are easier to understand than a composite format string. For example, the interpolated string\n\ncontains two interpolated expressions, '{name}' and '{hours:hh}'. The equivalent composite format string is:\n\nThe structure of an interpolated string is:\n• None field-width is a signed integer that indicates the number of characters in the field. If it is positive, the field is right-aligned; if negative, left-aligned.\n• None format-string is a format string appropriate for the type of object being formatted. For example, for a DateTime value, it could be a standard date and time format string such as \"D\" or \"d\".\n\nYou can use an interpolated string anywhere you can use a string literal. The interpolated string is evaluated each time the code with the interpolated string executes. This allows you to separate the definition and evaluation of an interpolated string.\n\nTo include a curly brace (\"{\" or \"}\") in an interpolated string, use two curly braces, \"{{\" or \"}}\". See the Implicit Conversions section for more details.\n\nIf the interpolated string contains other characters with special meaning in an interpolated string, such as the quotation mark (\"), colon (:), or comma (,), they should be escaped if they occur in literal text, or they should be included in an expression delimited by parentheses if they are language elements included in an interpolated expression. The following example escapes quotation marks to include them in the result string:\n\nThere are three implicit type conversions from an interpolated string:\n• None Conversion of an interpolated string to a String. The following example returns a string whose interpolated string expressions have been replaced with their string representations. For example: Public Module Example Public Sub Main() Dim name = \"Bartholomew\" Dim s1 = $\"Hello, {name}!\" Console.WriteLine(s1) End Sub End Module ' The example displays the following output: ' Hello, Bartholomew! ' </Snippet1> This is the final result of a string interpretation. All occurrences of double curly braces (\"{{\" and \"}}\") are converted to a single curly brace.\n• None Conversion of an interpolated string to an IFormattable variable that allows you create multiple result strings with culture-specific content from a single IFormattable instance. This is useful for including such things as the correct numeric and date formats for individual cultures. All occurrences of double curly braces (\"{{\" and \"}}\") remain as double curly braces until you format the string by explicitly or implicitly calling the ToString() method. All contained interpolation expressions are converted to {0}, {1}, and so on. The following example uses reflection to display the members as well as the field and property values of an IFormattable variable that is created from an interpolated string. It also passes the IFormattable variable to the Console.WriteLine(String) method. Imports System.Globalization Imports System.Reflection Public Module Example Public Sub Main() Dim price = 1000 Dim s2 As IFormattable = $\"The cost of this item is {price:C}.\" ShowInfo(s2) CultureInfo.CurrentCulture = New CultureInfo(\"en-US\") Console.WriteLine(s2) CultureInfo.CurrentCulture = New CultureInfo(\"fr-FR\") Console.WriteLine(s2) End Sub Private Sub ShowInfo(obj As Object) Console.WriteLine($\"Displaying member information:{vbCrLf}\") Dim t = obj.GetType() Dim flags = BindingFlags.Public Or BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.NonPublic For Each m In t.GetMembers(flags) Console.Write($\" {m.Name} {m.MemberType}\") If m.MemberType = MemberTypes.Property Then Dim p = t.GetProperty(m.Name, flags) Console.Write($\" Value: {p.GetValue(obj)}\") End If If m.MemberType = MemberTypes.Field Then Dim f = t.GetField(m.Name, flags) Console.Write($\" Value: {f.GetValue(obj)}\") End If Console.WriteLine() Next Console.WriteLine($\"-------{vbCrLf}\") End Sub End Module ' The example displays the following output: Displaying member information: ' get_Format Method ' GetArguments Method ' get_ArgumentCount Method ' GetArgument Method ' ToString Method ' System.IFormattable.ToString Method ' ToString Method ' Equals Method ' GetHashCode Method ' GetType Method ' Finalize Method ' MemberwiseClone Method ' .ctor Constructor ' Format Property Value: The cost of this item is {0:C}. ' ArgumentCount Property Value: 1 ' _format Field Value: The cost of this item is {0:C}. ' _arguments Field Value: System.Object[] ' ------- ' ' The cost of this item is $1,000.00. ' The cost of this item is 1 000,00 €. ' </Snippet1> Note that the interpolated string can be inspected only by using reflection. If it is passed to a string formatting method, such as WriteLine(String), its format items are resolved and the result string returned.\n• None Conversion of an interpolated string to a FormattableString variable that represents a composite format string. Inspecting the composite format string and how it renders as a result string might, for example, help you protect against an injection attack if you were building a query. A FormattableString also includes:\n• None A ToString() overload that produces a result string for the CurrentCulture.\n• None An Invariant method that produces a string for the InvariantCulture.\n• None A ToString(IFormatProvider) method that produces a result string for a specified culture. All occurrences of double curly braces (\"{{\" and \"}}\") remain as double curly braces until you format. All contained interpolation expressions are converted to {0}, {1}, and so on. Imports System.Globalization Public Module Example Public Sub Main() Dim name = \"Bartholomew\" Dim s3 As FormattableString = $\"Hello, {name}!\" Console.WriteLine($\"String: '{s3.Format}'\") Console.WriteLine($\"Arguments: {s3.ArgumentCount}\") Console.WriteLine($\"Result string: {s3}\") End Sub End Module ' The example displays the following output: ' String: 'Hello, {0}!' ' Arguments: 1 ' Result string: Hello, Bartholomew!"
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/visual-basic/language-reference/special-characters/interpolated",
        "document": "Identifies a string literal as an interpolated string. An interpolated string is a template-like string that contains literal text along with interpolated expressions. An interpolated expression is an expression that produces a result to be formatted in the resultant string. When the interpolated string is resolved, for example in an assignment statement or a method call, its interpolated expressions are replaced by their string representations in the result string. Interpolated strings are replacements for the composite format strings supported by the .NET Framework.\n\nThe following example uses the character to define an interpolated string.\n\nFor more information on interpolated strings, see the Interpolated Strings topic."
    },
    {
        "link": "https://github.com/dotnet/docs/blob/main/docs/visual-basic/programming-guide/language-features/strings/interpolated-strings.md",
        "document": "Used to construct strings. An interpolated string looks like a template string that contains interpolated expressions. An interpolated string returns a string that replaces the interpolated expressions that it contains with their string representations. This feature is available in Visual Basic 14 and later versions.\n\nThe arguments of an interpolated string are easier to understand than a composite format string. For example, the interpolated string\n\ncontains two interpolated expressions, '{name}' and '{hours:hh}'. The equivalent composite format string is:\n\nThe structure of an interpolated string is:\n• field-width is a signed integer that indicates the number of characters in the field. If it is positive, the field is right-aligned; if negative, left-aligned.\n• format-string is a format string appropriate for the type of object being formatted. For example, for a xref:System.DateTime value, it could be a standard date and time format string such as \"D\" or \"d\".\n\nYou can use an interpolated string anywhere you can use a string literal. The interpolated string is evaluated each time the code with the interpolated string executes. This allows you to separate the definition and evaluation of an interpolated string.\n\nTo include a curly brace (\"{\" or \"}\") in an interpolated string, use two curly braces, \"{{\" or \"}}\". See the Implicit Conversions section for more details.\n\nIf the interpolated string contains other characters with special meaning in an interpolated string, such as the quotation mark (\"), colon (:), or comma (,), they should be escaped if they occur in literal text, or they should be included in an expression delimited by parentheses if they are language elements included in an interpolated expression. The following example escapes quotation marks to include them in the result string:\n\nThere are three implicit type conversions from an interpolated string:\n• Conversion of an interpolated string to a xref:System.String. The following example returns a string whose interpolated string expressions have been replaced with their string representations. For example: This is the final result of a string interpretation. All occurrences of double curly braces (\"{{\" and \"}}\") are converted to a single curly brace.\n• Conversion of an interpolated string to an xref:System.IFormattable variable that allows you create multiple result strings with culture-specific content from a single xref:System.IFormattable instance. This is useful for including such things as the correct numeric and date formats for individual cultures. All occurrences of double curly braces (\"{{\" and \"}}\") remain as double curly braces until you format the string by explicitly or implicitly calling the xref:System.Object.ToString method. All contained interpolation expressions are converted to {0}, {1}, and so on. The following example uses reflection to display the members as well as the field and property values of an xref:System.IFormattable variable that is created from an interpolated string. It also passes the xref:System.IFormattable variable to the xref:System.Console.WriteLine(System.String)?displayProperty=nameWithType method. Note that the interpolated string can be inspected only by using reflection. If it is passed to a string formatting method, such as xref:System.Console.WriteLine(System.String), its format items are resolved and the result string returned.\n• Conversion of an interpolated string to a xref:System.FormattableString variable that represents a composite format string. Inspecting the composite format string and how it renders as a result string might, for example, help you protect against an injection attack if you were building a query. A xref:System.FormattableString also includes:\n• A xref:System.FormattableString.ToString overload that produces a result string for the xref:System.Globalization.CultureInfo.CurrentCulture.\n• An xref:System.FormattableString.Invariant%2A method that produces a string for the xref:System.Globalization.CultureInfo.InvariantCulture.\n• A xref:System.FormattableString.ToString(System.IFormatProvider) method that produces a result string for a specified culture. All occurrences of double curly braces (\"{{\" and \"}}\") remain as double curly braces until you format. All contained interpolation expressions are converted to {0}, {1}, and so on."
    },
    {
        "link": "https://stackoverflow.com/questions/59131321/slickest-method-for-linear-interpolation-of-10-values-with-100-results",
        "document": "I am writing some code to interpolate values between 1000 at each 100 mark and similarly between 10000 at each 1000 mark should the \"Known\" value change etc.\n\n See the below trial I did in Excel as a test which works well, I think.\n\nI have coded this in Visual Studio and being a bit of a noob as far as VB.Net is concerned (aka not VBA) I have 'd these values as as per below:\n\nwhere to is the user input data and the Result#### is the interpolated data.\n\nCan anyone recommend a slicker way to do this than writing this code out 90 more times?\n\n Researching the subject I have not really seen a neater/slicker way to do this."
    },
    {
        "link": "https://tutlane.com/tutorial/visual-basic/vb-string-interpolation",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/66075715/efficient-interpolation-implementation",
        "document": "I'm writing an interpolation method without using a library functions which does it directly. The signature of the function is:\n\nRight now my implementation is straight forward \"Lagrange Interpolation\" as explained here: https://www.codesansar.com/numerical-methods/python-program-lagrange-interpolation-method.htm\n\nHowever, this kind of implementation is O(n^2) and I'm looking for a more efficient solution which runs in O(n)."
    },
    {
        "link": "https://vbforums.com/showthread.php?394070-Linear-interpolation-for-an-array-of-values",
        "document": "Using Visual Studio 2008.\n\n I am not young enough to know everything - Oscar Wilde"
    },
    {
        "link": "https://stackoverflow.com/questions/24800508/interpolate-between-array-points",
        "document": "In the following code I built 2 arrays:\n• None One contains a \"degree data\" (so basically an Integer array increasing one by one) representing a portion of degrees in a circumference.\n• None The second one a \"power data\" (a Double, whose values keep more or less cubic increasing until a maximum corresponding to a 0 in the first array. Then they will decrease almost as they increased). This array goes for example from values that are more or less -4.0 to more or less -4.0.\n\nI thought I could \"simplify\" the second one to a parabola (looks very much like one) and use its coefficients (calculated via LinEst) A, B, C and D to interpolate data between points.\n\nWhat I do need is to find with a 0.1 degrees precision the 2 numbers which are nearest to -3.0 and then find their \"distance\" in degrees. Problem is: I can't manage to do it. There is something I'm missing and the coefficients seems not to represent my set of data.\n\nHere is the critic point:\n\nNow if I look at the YValues array, the numbers stored inside don't look absolutely how they should be. How do I interpolate to find those -3s then?"
    },
    {
        "link": "https://acme.byu.edu/00000179-d4cb-d26e-a37b-fffb576e0000/polynomialinterpolation-pdf",
        "document": ""
    },
    {
        "link": "https://smashmath.github.io/math/polyinterp",
        "document": "This post is separated into sections based on difficulty. While hopefully anyone with some algebra experience can follow along with the first few sections, the later sections use topics from more advanced math courses like Calculus and Linear Algebra.\n\nWhen I was just starting to learn algebra, and we were learning about quadratics, I wanted to know how to find a quadratic that passed through certain points. I’ve never been an artist, but the idea of “drawing” a polynomial was novel to me. It wasn’t until college that someone told me how I could do it.\n\nAnd while I’m perfectly content making up polynomials that look nice just for fun, polynomial interpolation has a number of useful applications. Some of these are:\n• Approximating definite integrals of difficult functions by instead integrating an interpolating polynomial\n• Filling in values between data points. This can be used to approximate the values of functions like \\(\\ln(x)\\) or the trig functions\n• Approximating complicated curves if you only have a few points\n\nAnd while this is a topic that is occasionally touched on in a linear algebra course, it really only requires relatively basic algebra to get started. If you want to get fancy and creative, then some calculus can spice it up too!\n\nSo, let’s try to find a quadratic equation as I wanted to do a long time ago.\n\nI want a quadratic that passes through the points\n\nSo we’re looking for a quadratic (degree two) polynomial. The general form of a quadratic is:\n\nHowever, I’m going to start writing them in a form that generalizes more easily to higher degree polynomials using function notation.\n\nThere is another reason I do it in this order. It will make solving this problem easier later on (if you use linear algebra).\n\nThe first question we must ask ourselves is: “What does it mean for this polynomial to pass through the point \\((1,9)\\)?”\n\nThat may seem like a silly question, and, indeed, when introducing this topic in linear algebra, many students are at a loss for how to even get started with this kind of problem. The key is looking at the point \\((x,y)\\) with this perspective:\n\nAnd this is where function notation really helps us out. Instead of thinking about the point as \\((x,y)\\), we want to think about it as\n\nIn other words, if we want the polynomial to pass through a specific point, we should make sure the desired \\(y\\) value is produced after plugging in the related \\(x\\) value. So in the generic case of \\((x_1,y_1)\\),\n\nwhich we can also compactly write as \\(p(x_1)=y_1\\).\n\nSo for each point, we get one equation. In our specific example, \\((1,9),(2,7),(3,-1)\\), our equations are\n\nNow at this point, we have a system of three equations in three unknowns. Three linear equations at that. Don’t let the \\(x^2\\) term fool you! Our “variables” are actually the \\(a\\) coefficients, since it’s those we’re trying to solve for.\n\nLinear algebra can actually tell us that this particular system is guaranteed to have exactly one solution. We will use this idea later to tell us when we are and are not guaranteed a unique polynomial for some given conditions.\n\nIt is at this point that I highly recommend writing this in matrix notation so that it’s a lot less cluttered.\n\nWe call the big \\(3\\times 3\\) matrix on the left the “coefficient matrix”. We can do even better, though, by writing it as an “augmented matrix”.\n\nMuch better right? Now it’s all boiled down to the parts that actually matter: the input points and the output points. We’re basically just skipping the writing of each plus and \\(a\\) term, and replacing the column of equal signs with a single vertical bar. It’s just a much cleaner way to write it.\n\nThat said, if matrix notation is unfamiliar to you, feel free to ignore it! You can solve the systems you get however you like. If you are curious about how to solve systems using matrices and Gaussian elimination in linear algebra, then here is a quick explanation (that you may feel free to skip):\n\nA brief aside: If you do choose to solve this with Gaussian elimination, notice how putting the constant term first will make it much easier. It’s natural to instinctively write it with the powers descending, since that’s the standard form of a polynomial, but that just makes it much harder to get the augmented matrix into reduced row echelon form. This way we start with a leading one in the top left corner.\n\nAssuming you were solving it with gaussian elimination, row reducing the matrix yields\n\nThe way to read this is:\n\nWhich should be the result you get by solving the system in whichever way you chose. Here’s a graph of the polynomial \\(p(x)=5+7x-3x^2\\). As you can see the polynomial does pass through the desired points.\n\nAt this point, you can probably figure out most polynomial interpolation problems. Set up your system and solve. However, there are some additional subtleties and ways to make this more general that you may be interested in.\n\nWhen are we guaranteed a polynomial?\n\nWhile our first example was a quadratic, let’s turn our attention to the simpler case of two points and a line to get a better intuition for this question. For the purpose of this discussion, we’re going to be assuming that no two points have the same \\(x\\) value.\n\nIf you draw three random points on a piece of paper, can you draw a single straight line through all three? Almost all of the time this is impossible. Not always, however. For example, the three points\n\nHave a line that passes through them. It’s the line \\(y=x\\). We call these points “collinear” because they happen to all lie on the same straight line.\n\nBy the same logic, if we have four, five, or a hundred points, we aren’t guaranteed a line that passes through all of them unless they happen to be collinear.\n\nWell, how about two points? There is only one line in this situation. In fact we have a formula for it!\n\nThis next question might seem a bit silly, but if we have just a single point, can we find a line that passes through it?\n\nWell… of course! Take the origin, \\((0,0)\\), and any line of the form\n\nWe can pick any number for \\(m\\) that we like, and, no matter what it is, it will pass through \\((0,0)\\).\n\nTwo points: Exactly one line\n\nThree or more points: There isn’t always a line\n\nSo what’s the pattern here? Clearly two points is the special number for a line, but what significance is the number two?\n\nEarlier, I mentioned that linear algebra guaranteed that our system of three equations in three unknowns for our quadratic would have exactly one solution. Three was the magic number for a quadratic, and two seems to be the magic number for a line. Can you spot the pattern?\n\nThe equation of a line is\n\nAnd the key is that we have two unknown coefficients, \\(a_0\\) and \\(a_1\\). That gives us two degrees of freedom.\n\nSimilarly, for a quadratic \\(p(x)=a_0+a_1x+a_2x^2\\), we have three coefficients, which guarantees us three points since we have three degrees of freedom.\n\nI call these general unknown forms such as \\(p(x)=a_0+a_1x\\) or \\(p(x)=a_0+a_1x+a_2x^2\\) the “guess”. It’s an assumption for the form of our solution. And though in real life assumptions are not always correct, in mathematics it can be en exact science to find the correct “guess” or form a solution must take. Without getting too technical, in the case of polynomials like this we are justified in just having the number of \\(a_kx^k\\) terms in our “guess” be equal to the number of points.\n\nHowever! Let’s suppose we didn’t realize that the polynomial that passes through \\((1,1),(2,2),(3,3)\\) is just a line. If we solved it by assuming the answer was of the form \\(p(x)=a_0+a_1x+a_2x^2\\), we would find that the \\(a_2\\) coefficient is just zero, giving us the “quadratic” \\(p(x)=x\\). So just because we have a certain number of points doesn’t mean we know exactly what degree the polynomial will be. But if we assume the number of coefficients is equal to the number of points, we are guaranteed to find exactly one solution.\n\nIn summary: The number of points a polynomial can be guaranteed to pass through is equal to the number of unknown coefficients in our guess.\n\nOr in other words: There is exactly one polynomial of degree \\(n-1\\) or less which passes through \\(n\\) distinct points.\n\nSo if you have five points, for example, that you want a polynomial to pass through, then your guess needs to be a polynomial with five unknown coefficients. Therefore, you need to assume it’s a quartic polynomial.\n\nSo far, we’ve been finding polynomials based on points that they pass through. But that’s not the only thing we can guarantee. We’re going to use a bit of calculus for this next section.\n\nLet’s say we want a polynomial which has a relative maximum at \\((-1,2)\\) and a relative minimum at \\((1,-2)\\). Like this.\n\nCalculus tells us that the slope of the tangent line is given by the derivative. So if we want our \\(p(x)\\) to have a relative maximum or minimum, then we need it’s derivative, \\(p'(x)\\), to be zero at that point.\n\nSo not only do we have the conditions \\(p(-1)=2\\) and \\(p(1)=-2\\), but we also need \\(p'(-1)=0\\) and \\(p'(1)=0\\).\n\nSince we have four conditions, we need four coefficients. That means a cubic polynomial.\n\nAnd so, our conditions yield us the system of equations\n\nIn matrix notation, this would be\n\nThus, our polynomial is \\(p(x)=x^3-3x\\).\n\nThe process of solving was no different than before. The only difference was what our equations looked like. So get creative!\n\nWhen are we guaranteed a polynomial? Part 2\n\nThis section is a bit more technical, and focuses a bit more on the linear algebra aspect of things. Back when we were just discussing points, we only needed the values of \\(x_1,\\ldots,x_n\\) to not be the same, and we would be guaranteed a solution.\n\nThis is because our matrix of the form\n\njust so happens to be “invertible” when all the values of \\(x_1,\\ldots,x_n\\) are different. This matrix actually has a special name, too. It is a Vandermonde matrix.\n\nThere are a lot of things you can say about a square matrix which is invertible, but some of the most important things for us will be\n• If a system of equations has an invertible coefficient matrix, then there is always exactly one unique solution guaranteed.\n• If the coefficient matrix of a system is square but not invertible, then there are either no solutions, or infinitely many.\n\nThere are a number of tests for invertibility, one computational method being to calculate the determinant. In practice, though, you will discover a matrix is not invertible when you either end up with a free variable or have conflicting equations.\n\nSo if we’re just dealing with points, then we don’t have to worry about if we’ll be guaranteed a solution as long as our input points are all different. But, if we start dealing with more complicated constraints, then we will have to be a bit more careful.\n\nAn example without a unique solution\n\nTake the example of wanting a polynomial passing through \\((-1,-8)\\) and \\((3,8)\\), while also having a relative extremum at \\(x=1\\).\n\nThree constraints means three coefficients. So we should be dealing with a quadratic.\n\nThe constraints give us \\(p(-1)=-8,p(3)=8,p'(1)=0\\). So our equations will be\n\nNow I recommend trying to solve this system yourself so you can see what happens. But the row reduced version of the matrix form ends up being\n\nUh-oh. That last equation doesn’t look right. That means there is no solution to this system.\n\nAnd when you look at it geometrically, that makes sense because no quadratic can possibly make that shape, since they are symmetric about their vertex. Both \\(x=-1\\) and \\(x=3\\) are an equal distance from \\(x=1\\), so any quadratic with a vertex at \\(x=1\\) will have the same value at \\(x=-1\\) as it does at \\(x=3\\).\n\nAs a simpler example of this, a quadratic with a vertex at \\(x=0\\) will look like \\(p(x)=ax^2+c\\). is it possible for \\(p(1)\n\neq p(-1)\\)? No! Because when we plug in \\(p(1)\\) and \\(p(-1)\\), we get the exact same output with each, \\(p(\\pm1)=a+c\\).\n\nAnd indeed, the coefficient matrix\n\nhas a determinant of zero. So if we had checked that prior, we would have seen that there would either be no quadratic, or infinitely many which would satisfy our conditions.\n\nSo is all hope lost? For a single unique answer, yes. But there are infinitely many cubics which satisfy our constraints. Specifically, for some number \\(t\\), any cubic of the form \\(\\begin{equation} p(x)=x^3-3x-10+t(x^2-2x-3) \\end{equation}\\)\n\nIf you’re wondering how I got that, I just solved the system\n\nNow there are plenty of resources that can show you how exactly to solve a system with infinitely many solutions. So instead, I want to point out the conceptual significance the quadratic \\(x^2-2x-3\\) has to our problem.\n\n\\(x^2-2x-3\\) has a lot of interesting things going on at \\(x\\) values of our constraints. The zeros of this quadratic are \\(x=-1\\) and \\(x=3\\), and its vertex is at \\(x=1\\). This is no coincidence!\n\nBecause the quadratic is zero at \\(x=-1,3\\), when we add any scalar multiple of it to our cubic \\(x^3-3x-10\\), it doesn’t change the value at those points. Since \\(x^3-3x-10\\) already passes through \\((-1,-8)\\) and \\((3,8)\\), then so will \\(x^3-3x-10+t(x^2-2x-3)\\).\n\nAnd because both the polynomials \\(x^2-2x-3\\) and \\(x^3-3x-10\\) have a relative extremum at \\(x=1\\), when we add a scalar multiple of the quadratic to the other, the result will still have a relative extremum there. If you know some calculus, I encourage you to try to explain why that is true.\n\nAs a final note for this example, we could guarantee a unique solution for a cubic by just adding another requirement. For example, we could specify that \\(p(1)=3\\), or \\(p(x_0)=y_0\\) if you want to make it more arbitrary.\n\nThis section is more just about some tricks and shortcuts one might use for more complicated polynomials, including a real example which isn’t cherry picked to have a nice answer.\n\nThis is the polynomial that I was questing to find when I first learned about polynomial interpolation (purely because it was pretty looking).\n\nI had drawn the shape and labeled the four points. And while the graph is quite beautiful, the equation itself is not.\n\nIn total, the constraints were\n\nBut to find it, I didn’t actually need to set it up with all 9 of these constraints. In fact, I only had to set up four equations!\n\nInstead of doing nine equations, I just noticed that I wanted an odd polynomial. So all the even coefficients \\(a_0,a_2,\\ldots,a_8\\) need to be zero. Since that means it would be mirrored across the origin (including passing through it \\(p(0)=0\\)), I only needed the constraints \\(p(3)=-5,p'(3)=0,p(5)=-3,p'(5)=0\\), and the rest would follow from the nature of being odd.\n\nFour constraints, four coefficients. They would all have to be odd though, rather than just being a cubic polynomial. So that would total me up to a degree at most seven polynomial.\n\nIn summary: if you know that you want your polynomial to satisfy some specific general condition, then make your “guess” reflect that. Similarly, a smart guess can simplify your equations significantly.\n\nAs an example of what I mean, in our previous example of having extrema at \\((-1,2)\\) and \\((1,-2)\\), if instead of our guess being \\(p(x)=a_0+a_1x+a_2x^2+a_3x^3\\), we had chosen\n\nYou can verify that two of our equations would be extremely simple. Specifically, the equation for \\(p(1)=-2\\) is simply \\(a_0=-2\\), and the equation for \\(p'(1)=0\\) is just \\(a_1=0\\). So by making our guess a little strange, we simplified the solving process to really only needing to solve for two variables instead of four. The drawback is that to get our polynomial in standard form we have to expand it out and simplify after solving.\n\nJust like we can set up our “guess” to be an even or odd polynomial, in general, you can use this interpolation method for other types of functions. Our polynomial structure was\n\nBut why limit ourselves to powers of \\(x\\) on our coefficients?\n\nWhat if I want a function with exponentials instead of polynomials?\n\nThis particular setup would allow me \\(2n+1\\) constraints.\n\nThe process is the same. Plug in your \\(g(x_i)\\) and set it equal to your desired \\(y_i\\). The coefficients aren’t quite as pretty, but you’re still just solving a system of equations.\n\nAs an example, what if I want a function of the form \\(g(x)=a_0+a_1e^{x}+a_{-1}e^{-x}\\) that passes through the same points as our original quadratic, \\((1,9),(2,7),(3,-1)\\). Then my equations will still be\n\nThe answer is completely disgusting compared to the simple polynomial we got before, but the graphs look quite similar.\n\nBut why even force it to be linear? Why not create a rational function that satisfies \\(n+m\\) constraints?\n\nSince the coefficients of rational functions are based on ratios rather than strict numbers, we can force it to be unique by having what would be \\(b_m\\) to be \\(1\\).\n\nThen we can still make it linear by multiplying the denominator to both sides and having our equations be of the form\n\nFor example, let’s say we want a rational function of the form \\(g(x)=\\frac{a_0}{b_0+b_1x}\\) which passes through the points \\(\\left(-1,\\frac{1}{2}\\right)\\) and \\((2,-1)\\). Now you may be thinking that we have three unknown coefficients, so we should be able to guarantee three points, right? Well, not quite. Our two equations would be\n\nBy multiplying out the denominator to both sides,\n\nGetting everything to one side,\n\nThis is what we call a “homogeneous” system, since everything on the right side is zero. Homogeneous systems always have at least one solution (one where every unknown is zero, called ‘the trivial solution’), and may have infinitely many. The trivial solution does not work for us, here. It doesn’t make sense for \\(g(x)=\\frac{0}{0+0x}\\). So unless there does happen to be a nontrivial solution for your third point, then you’ll find there is no usable solution.\n\nIn this case, there are infinitely many solutions because, as mentioned before, the coefficients on rational functions are based on ratios rather than concrete values. There are infinitely many ways to write a single rational function: \\(\\frac{a}{bx+c}=\\frac{2a}{2bx+2c}\\) for example. If we require that \\(b_1=1\\), then we will actually be guaranteed exactly one unique solution, since our equations could be\n\nFrom our general form \\eqref{rational}, \\(n=1\\) and \\(m=1\\). Our system is indeed in the form \\eqref{rationalsys}\n\nThe solution to this system is \\(a_0=-1,b_0=-1\\), so\n\nAnd here is the graph.\n\nNow solving these problems is considerably more difficult. We no longer have our trusty Vandermonde matrix, and our equations aren’t as pretty, so we have to be more careful in general. We are usually dealing with a lot more constants too, so we have to come up with more constraints if we want a unique solution, and have to solve much larger systems of equations.\n\nThat said! It’s possible, and that’s really all that matters, isn’t it?\n\nSo for all of you who are inspired, go forth and create beautiful graphs!"
    }
]