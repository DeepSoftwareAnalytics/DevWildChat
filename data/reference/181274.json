[
    {
        "link": "https://docs.python.org/3/library/os.html",
        "document": "This module provides a portable way of using operating system dependent functionality. If you just want to read or write a file see , if you want to manipulate paths, see the module, and if you want to read all the lines in all the files on the command line see the module. For creating temporary files and directories see the module, and for high-level file and directory handling see the module.\n\nNotes on the availability of these functions:\n• None The design of all built-in operating system dependent modules of Python is such that as long as the same functionality is available, it uses the same interface; for example, the function returns stat information about path in the same format (which happens to have originated with the POSIX interface).\n• None Extensions peculiar to a particular operating system are also available through the module, but using them is of course a threat to portability.\n• None All functions accepting path or file names accept both bytes and string objects, and result in an object of the same type, if a path or file name is returned.\n• None On VxWorks, os.popen, os.fork, os.execv and os.spawn*p* are not supported.\n• None On WebAssembly platforms, Android and iOS, large parts of the module are not available or behave differently. APIs related to processes (e.g. , ) and resources (e.g. ) are not available. Others like and are emulated or stubs. WebAssembly platforms also lack support for signals (e.g. , )."
    },
    {
        "link": "https://geeksforgeeks.org/os-module-python-examples",
        "document": "The OS module in Python provides functions for interacting with the operating system. OS comes under Python’s standard utility modules. This module provides a portable way of using operating system-dependent functionality.\n\nThe *os* and *os.path* modules include many functions to interact with the file system.\n\nHere we will discuss some important functions of the Python os module :\n• None Listing out Files and Directories with Python\n\nConsider Current Working Directory(CWD) as a folder, where Python is operating. Whenever the files are called only by their name, Python assumes that it starts in the CWD which means that name-only reference will be successful only if the file is in the Python’s CWD.\n\nTo get the location of the current working directory os.getcwd() is used.\n\nExample: This code uses the ‘ module to get and print the current working directory (CWD) of the Python script. It retrieves the CWD using the ‘ and then prints it to the console.\n\nTo change the current working directory(CWD) os.chdir() method is used. This method changes the CWD to a specified path. It only takes a single argument as a new directory path.\n\nExample: The code checks and displays the current working directory (CWD) twice: before and after changing the directory up one level using . It provides a simple example of how to work with the current working directory in Python.\n\nThere are different methods available in the OS module for creating a directory. These are –\n\nBy using os.mkdir() method in Python is used to create a directory named path with the specified numeric mode. This method raises FileExistsError if the directory to be created already exists.\n\nExample: This code creates two directories: “GeeksforGeeks” within the “D:/Pycharm projects/” directory and “Geeks” within the “D:/Pycharm projects” directory.\n• None The first directory is created using the method without specifying the mode.\n• None The second directory is created using the same method, but a specific mode ( ) is provided, which grants read and write permissions.\n• None The code then prints messages to indicate that the directories have been created.\n\nos.makedirs() method in Python is used to create a directory recursively. That means while making leaf directory if any intermediate-level directory is missing, os.makedirs() method will create them all.\n\nExample: This code creates two directories, “Nikhil” and “c”, within different parent directories. It uses the function to ensure that parent directories are created if they don’t exist.\n\nIt also sets the permissions for the “c” directory. The code prints messages to confirm the creation of these directories\n\nListing out Files and Directories with Python\n\nThere is os.listdir() method in Python is used to get the list of all files and directories in the specified directory. If we don’t specify any directory, then the list of files and directories in the current working directory will be returned.\n\nExample: This code lists all the files and directories in the root directory (“/”). It uses the function to get the list of files and directories in the specified path and then prints the results.\n\nOS module provides different methods for removing directories and files in Python. These are –\n\nos.remove() method in Python is used to remove or delete a file path. This method can not remove or delete a directory. If the specified path is a directory then OSError will be raised by the method.\n\nExample: Suppose the file contained in the folder are:\n\n\n\nThis code removes a file named “file1.txt” from the specified location “D:/Pycharm projects/GeeksforGeeks/Authors/Nikhil/”. It uses the function to delete the file at the specified path.\n\nos.rmdir() method in Python is used to remove or delete an empty directory. OSError will be raised if the specified path is not an empty directory.\n\nExample: Suppose the directories are\n\nThis code attempts to remove a directory named “Geeks” located at “D:/Pycharm projects/”.\n\nIt uses the function to delete the directory. If the directory is empty, it will be removed. If it contains files or subdirectories, you may encounter an error.\n\nThis function gives the name of the operating system dependent module imported. The following names have currently been registered: ‘posix’, ‘nt’, ‘os2’, ‘ce’, ‘java’ and ‘riscos’.\n\nNote: It may give different output on different interpreters, such as ‘posix’ when you run the code here.\n\nAll functions in this module raise OSError in the case of invalid or inaccessible file names and paths, or other arguments that have the correct type, but are not accepted by the operating system. os.error is an alias for built-in OSError exception.\n\nThis code reads the contents of a file named ‘GFG.txt’. It uses a ‘try…except‘ block to handle potential errors, particularly the ‘IOError‘ that may occur if there’s a problem reading the file.\n\nIf an error occurs, it will print a message saying, “Problem reading: GFG.txt.”\n\nThis method opens a pipe to or from command. The return value can be read or written depending on whether the mode is ‘r’ or ‘w’. \n\nSyntax:\n\nParameters mode & bufsize are not necessary parameters, if not provided, default ‘r’ is taken for mode.\n\nThis code opens a file named ‘GFG.txt’ in write mode, writes “Hello” to it, and then reads and prints its contents. The use of is not recommended, and standard file operations are used for these tasks.\n\nNote: Output for popen() will not be shown, there would be direct changes into the file.\n\nClose file descriptor fd. A file opened using open(), can be closed by close()only. But file opened through os.popen(), can be closed with close() or os.close(). If we try closing a file opened with open(), using os.close(), Python would throw TypeError.\n\nNote: The same error may not be thrown, due to the non-existent file or permission privilege.\n\nA file old.txt can be renamed to new.txt, using the function os.rename(). The name of the file changes only if, the file exists and the user has sufficient privilege permission to change the file.\n\nA file name “GFG.txt” exists, thus when os.rename() is used the first time, the file gets renamed.\n\nUpon calling the function os.rename() second time, file “New.txt” exists and not “GFG.txt” thus Python throws FileNotFoundError.\n\nUsing the Os module we can remove a file in our system using the os.remove() method. To remove a file we need to pass the name of the file as a parameter.\n\nThe OS module provides us a layer of abstraction between us and the operating system.\n\nWhen we are working with os module always specify the absolute path depending upon the operating system the code can run on any os but we need to change the path exactly. If you try to remove a file that does not exist you will get FileNotFoundError.\n\nThis method will check whether a file exists or not by passing the name of the file as a parameter. OS module has a sub-module named PATH by using which we can perform many more functions.\n\nAs in the above code, the file does not exist it will give output False. If the file exists it will give us output True.\n\nIn os.path.getsize() function, python will give us the size of the file in bytes. To use this method we need to pass the name of the file as a parameter.\n\nWhat is the OS module in Python?\n\nWhat is an OS package?\n\nWhat is OS name in Python?\n\nWhat is the OS process in Python?"
    },
    {
        "link": "https://docs.python.org/3/library/os.path.html",
        "document": "Source code: Lib/genericpath.py, Lib/posixpath.py (for POSIX) and Lib/ntpath.py (for Windows).\n\nThis module implements some useful functions on pathnames. To read or write files see , and for accessing the filesystem see the module. The path parameters can be passed as strings, or bytes, or any object implementing the protocol.\n\nUnlike a Unix shell, Python does not do any automatic path expansions. Functions such as and can be invoked explicitly when an application desires shell-like path expansion. (See also the module.)\n\nSince different operating systems have different path name conventions, there are several versions of this module in the standard library. The module is always the path module suitable for the operating system Python is running on, and therefore usable for local paths. However, you can also import and use the individual modules if you want to manipulate a path that is always in one of the different formats. They all have the same interface:\n\nOn Unix and Windows, return the argument with an initial component of or replaced by that user’s home directory. On Unix, an initial is replaced by the environment variable if it is set; otherwise the current user’s home directory is looked up in the password directory through the built-in module . An initial is looked up directly in the password directory. On Windows, will be used if set, otherwise a combination of and will be used. An initial is handled by checking that the last directory component of the current user’s home directory matches , and replacing it if so. If the expansion fails or if the path does not begin with a tilde, the path is returned unchanged. Changed in version 3.8: No longer uses on Windows.\n\nJoin one or more path segments intelligently. The return value is the concatenation of path and all members of *paths, with exactly one directory separator following each non-empty part, except the last. That is, the result will only end in a separator if the last part is either empty or ends in a separator. If a segment is an absolute path (which on Windows requires both a drive and a root), then all previous segments are ignored and joining continues from the absolute path segment. On Windows, the drive is not reset when a rooted path segment (e.g., ) is encountered. If a segment is on a different drive or is an absolute path, all previous segments are ignored and the drive is reset. Note that since there is a current directory for each drive, represents a path relative to the current directory on drive ( ), not . Changed in version 3.6: Accepts a path-like object for path and paths."
    },
    {
        "link": "https://canardanalytics.com/blog/file-and-folder-operations-os-module",
        "document": "Python's module provides a set of functions to allow you to interact with your operating system. The module is a part of Python's standard utility modules which means that it is bundled with any clean Python install. It is most commonly used to interact with your file system; specifying paths, creating and deleting folders, or renaming files. Part of the power of the module is that for many of its common uses it is operating system independent. This means that you can develop on a Windows PC and deploy to a Linux machine without having to rewrite the sections of code dealing with filepaths (Windows and Linux specify paths differently).\n\nThis tutorial will walk through some of the more often used functionality that the module offers. Let's get started.\n\nIn order to use the module you'll first need to import it. This should be placed along with the rest of your imports at the start of your script.\n\nThe concept of a current working directory (cwd) in the context of running a python programme is one that tends to confuse many developers who are starting out. It is not a difficult concept to master but in order to understand the working directory you must first be comfortable with the concept of files and directories (folders).\n\nA directory is simply a file, whose contents are a collection of other files. This structures provides a way to organise files and folders in order to create an orderly and logical structure. As the name implies, the current working directory is simply the directory in which the files that you are currently working with are sitting. You can think of the File Explorer window as a current working directory.\n\nPerhaps an even better way to visualise the cwd is to think of a terminal prompt.\n\nAs you navigate through the file system you are changing the current working directory. If you want to access files within the current working directory you do not need to include the entire path from the root but rather just the name of the file within the current working directory.\n\nThis works the same with when using the module. Every process has a current directory which it inherits from it's parent process. This doesn't have to be the directory in which the program you are running is located.\n\nIn Python the current working directory is returned as a string using the function. You can then change the current working directory with .\n\nNow we change the current working directory using the method:\n\nAll files and folders within the current working directory can be easily accessed by simply referring to their name rather than the absolute or root path to the file or directory.\n\nIn our example the current working directory has two files.\n\nThe module is a very powerful way to work with and manipulate paths within your Python application. One of the many reasons to use the module is the fact that it is operating system independent and so will work whether you are working in a Windows environment or a Linux environment.\n\nThe function takes two or more string paths and intelligently joins them to form a single filepath that is valid on all operating systems.\n\nIn the next example let's create a path that will join a folder located in the current working directory to a file within the folder.\n\nWhen you look at the result you should notice that the file path is given relative to the current working directory.\n\nIf you want the full path to the file then you can use .\n\nCheck Whether the Path Exists using os.path.exists\n\nUse to check whether the specified path exists or not. The result is a boolean, either or .\n\nSince the folder does not yet exist we can use the module to create it.\n\nIf the folder/directory does not exist then you can create it using .\n\nThe file extension can be extracted from a filepath with the function. The output is a tuple such that . The extension will either be empty or begin with a single period and contain at most one period."
    },
    {
        "link": "https://w3schools.com/python/module_os.asp?ref=escape.tech",
        "document": "Python has a built-in module with methods for interacting with the operating system, like creating files and directories, management of files and directories, input, output, environment variables, process management, etc.\n\nThe module has the following set of methods and constants."
    },
    {
        "link": "https://docs.python.org/3/library/xml.etree.elementtree.html",
        "document": "The module implements a simple and efficient API for parsing and creating XML data.\n\nThis is a short tutorial for using ( in short). The goal is to demonstrate some of the building blocks and basic concepts of the module. XML is an inherently hierarchical data format, and the most natural way to represent it is with a tree. has two classes for this purpose - represents the whole XML document as a tree, and represents a single node in this tree. Interactions with the whole document (reading and writing to/from files) are usually done on the level. Interactions with a single XML element and its sub-elements are done on the level. We’ll be using the fictive XML document as the sample data for this section: We can import this data by reading from a file: parses XML from a string directly into an , which is the root element of the parsed tree. Other parsing functions may create an . Check the documentation to be sure. As an , has a tag and a dictionary of attributes: It also has children nodes over which we can iterate: Children are nested, and we can access specific child nodes by index: Not all elements of the XML input will end up as elements of the parsed tree. Currently, this module skips over any XML comments, processing instructions, and document type declarations in the input. Nevertheless, trees built using this module’s API rather than parsing from XML text can have comments and processing instructions in them; they will be included when generating XML output. A document type declaration may be accessed by passing a custom instance to the constructor. Most parsing functions provided by this module require the whole document to be read at once before returning any result. It is possible to use an and feed data into it incrementally, but it is a push API that calls methods on a callback target, which is too low-level and inconvenient for most needs. Sometimes what the user really wants is to be able to parse XML incrementally, without blocking operations, while enjoying the convenience of fully constructed objects. The most powerful tool for doing this is . It does not require a blocking read to obtain the XML data, and is instead fed with data incrementally with calls. To get the parsed XML elements, call . Here is an example: The obvious use case is applications that operate in a non-blocking fashion where the XML data is being received from a socket or read incrementally from some storage device. In such cases, blocking reads are unacceptable. Because it’s so flexible, can be inconvenient to use for simpler use-cases. If you don’t mind your application blocking on reading XML data but would still like to have incremental parsing capabilities, take a look at . It can be useful when you’re reading a large XML document and don’t want to hold it wholly in memory. Where immediate feedback through events is wanted, calling method can help reduce delay; please make sure to study the related security notes. has some useful methods that help iterate recursively over all the sub-tree below it (its children, their children, and so on). For example, : finds only elements with a tag which are direct children of the current element. finds the first child with a particular tag, and accesses the element’s text content. accesses the element’s attributes: More sophisticated specification of which elements to look for is possible by using XPath. provides a simple way to build XML documents and write them to files. The method serves this purpose. Once created, an object may be manipulated by directly changing its fields (such as ), adding and modifying attributes ( method), as well as adding new children (for example with ). Let’s say we want to add one to each country’s rank, and add an attribute to the rank element: Our XML now looks like this: We can remove elements using . Let’s say we want to remove all countries with a rank higher than 50: # using root.findall() to avoid removal during traversal Note that concurrent modification while iterating can lead to problems, just like when iterating and modifying Python lists or dicts. Therefore, the example first collects all matching elements with , and only then iterates over the list of matches. Our XML now looks like this: The function also provides a convenient way to create new sub-elements for a given element: If the XML input has namespaces, tags and attributes with prefixes in the form get expanded to where the prefix is replaced by the full URI. Also, if there is a default namespace, that full URI gets prepended to all of the non-prefixed tags. Here is an XML example that incorporates two namespaces, one with the prefix “fictional” and the other serving as the default namespace: One way to search and explore this XML example is to manually add the URI to every tag or attribute in the xpath of a or : A better way to search the namespaced XML example is to create a dictionary with your own prefixes and use those in the search functions: These two approaches both output:\n\nThis module provides limited support for XPath expressions for locating elements in a tree. The goal is to support a small subset of the abbreviated syntax; a full XPath engine is outside the scope of the module. Here’s an example that demonstrates some of the XPath capabilities of the module. We’ll be using the XML document from the Parsing XML section: # All 'neighbor' grand-children of 'country' children of the top-level # Nodes with name='Singapore' that have a 'year' child # 'year' nodes that are children of nodes with name='Singapore' # All 'neighbor' nodes that are the second child of their parent For XML with namespaces, use the usual qualified notation: # All dublin-core \"title\" tags in the document Selects all child elements with the given tag. For example, selects all child elements named , and selects all grandchildren named in all children named . selects all tags in the given namespace, selects tags named in any (or no) namespace, and only selects tags that are not in a namespace. Changed in version 3.8: Support for star-wildcards was added. Selects all child elements, including comments and processing instructions. For example, selects all grandchildren named . Selects the current node. This is mostly useful at the beginning of the path, to indicate that it’s a relative path. Selects all subelements, on all levels beneath the current element. For example, selects all elements in the entire tree. Selects the parent element. Returns if the path attempts to reach the ancestors of the start element (the element was called on). Selects all elements that have the given attribute. Selects all elements for which the given attribute has the given value. The value cannot contain quotes. Selects all elements for which the given attribute does not have the given value. The value cannot contain quotes. Selects all elements that have a child named . Only immediate children are supported. Selects all elements whose complete text content, including descendants, equals the given . Selects all elements whose complete text content, including descendants, does not equal the given . Selects all elements that have a child named whose complete text content, including descendants, equals the given . Selects all elements that have a child named whose complete text content, including descendants, does not equal the given . Selects all elements that are located at the given position. The position can be either an integer (1 is the first position), the expression (for the last position), or a position relative to the last position (e.g. ). Predicates (expressions within square brackets) must be preceded by a tag name, an asterisk, or another predicate. predicates must be preceded by a tag name.\n\nCanonicalization is a way to normalise XML output in a way that allows byte-by-byte comparisons and digital signatures. It reduces the freedom that XML serializers have and instead generates a more constrained XML representation. The main restrictions regard the placement of namespace declarations, the ordering of attributes, and ignorable whitespace. This function takes an XML data string (xml_data) or a file path or file-like object (from_file) as input, converts it to the canonical form, and writes it out using the out file(-like) object, if provided, or returns it as a text string if not. The output file receives text, not bytes. It should therefore be opened in text mode with encoding. The configuration options are as follows:\n• None strip_text: set to true to strip whitespace before and after text content\n• None rewrite_prefixes: set to true to replace namespace prefixes by “n{number}”\n• None qname_aware_tags: a set of qname aware tag names in which prefixes should be replaced in text content (default: empty)\n• None qname_aware_attrs: a set of qname aware attribute names in which prefixes should be replaced in text content (default: empty)\n• None exclude_attrs: a set of attribute names that should not be serialised\n• None exclude_tags: a set of tag names that should not be serialised In the option list above, “a set” refers to any collection or iterable of strings, no ordering is expected. Comment element factory. This factory function creates a special element that will be serialized as an XML comment by the standard serializer. The comment string can be either a bytestring or a Unicode string. text is a string containing the comment string. Returns an element instance representing a comment. Note that skips over comments in the input instead of creating comment objects for them. An will only contain comment nodes if they have been inserted into to the tree using one of the methods. Writes an element tree or element structure to sys.stdout. This function should be used for debugging only. The exact output format is implementation dependent. In this version, it’s written as an ordinary XML file. elem is an element tree or an individual element. Changed in version 3.8: The function now preserves the attribute order specified by the user. Parses an XML section from a string constant. Same as . text is a string containing XML data. parser is an optional parser instance. If not given, the standard parser is used. Returns an instance. Parses an XML document from a sequence of string fragments. sequence is a list or other sequence containing XML data fragments. parser is an optional parser instance. If not given, the standard parser is used. Returns an instance. Appends whitespace to the subtree to indent the tree visually. This can be used to generate pretty-printed XML output. tree can be an Element or ElementTree. space is the whitespace string that will be inserted for each indentation level, two space characters by default. For indenting partial subtrees inside of an already indented tree, pass the initial indentation level as level. Check if an object appears to be a valid element object. element is an element instance. Return if this is an element object. Parses an XML section into an element tree incrementally, and reports what’s going on to the user. source is a filename or file object containing XML data. events is a sequence of events to report back. The supported events are the strings , , , , and (the “ns” events are used to get detailed namespace information). If events is omitted, only events are reported. parser is an optional parser instance. If not given, the standard parser is used. parser must be a subclass of and can only use the default as a target. Returns an iterator providing pairs; it has a attribute that references the root element of the resulting XML tree once source is fully read. The iterator has the method that closes the internal file object if source is a filename. Note that while builds the tree incrementally, it issues blocking reads on source (or the file it names). As such, it’s unsuitable for applications where blocking reads can’t be made. For fully non-blocking parsing, see . only guarantees that it has seen the “>” character of a starting tag when it emits a “start” event, so the attributes are defined, but the contents of the text and tail attributes are undefined at that point. The same applies to the element children; they may or may not be present. If you need a fully populated element, look for “end” events instead. Changed in version 3.8: The and events were added. Parses an XML section into an element tree. source is a filename or file object containing XML data. parser is an optional parser instance. If not given, the standard parser is used. Returns an instance. PI element factory. This factory function creates a special element that will be serialized as an XML processing instruction. target is a string containing the PI target. text is a string containing the PI contents, if given. Returns an element instance, representing a processing instruction. Note that skips over processing instructions in the input instead of creating PI objects for them. An will only contain processing instruction nodes if they have been inserted into to the tree using one of the methods. Registers a namespace prefix. The registry is global, and any existing mapping for either the given prefix or the namespace URI will be removed. prefix is a namespace prefix. uri is a namespace uri. Tags and attributes in this namespace will be serialized with the given prefix, if at all possible. Subelement factory. This function creates an element instance, and appends it to an existing element. The element name, attribute names, and attribute values can be either bytestrings or Unicode strings. parent is the parent element. tag is the subelement name. attrib is an optional dictionary, containing element attributes. extra contains additional attributes, given as keyword arguments. Returns an element instance. Generates a string representation of an XML element, including all subelements. element is an instance. encoding is the output encoding (default is US-ASCII). Use to generate a Unicode string (otherwise, a bytestring is generated). method is either , or (default is ). xml_declaration, default_namespace and short_empty_elements has the same meaning as in . Returns an (optionally) encoded string containing the XML data. Changed in version 3.8: Added the xml_declaration and default_namespace parameters. Changed in version 3.8: The function now preserves the attribute order specified by the user. Generates a string representation of an XML element, including all subelements. element is an instance. encoding is the output encoding (default is US-ASCII). Use to generate a Unicode string (otherwise, a bytestring is generated). method is either , or (default is ). xml_declaration, default_namespace and short_empty_elements has the same meaning as in . Returns a list of (optionally) encoded strings containing the XML data. It does not guarantee any specific sequence, except that . Changed in version 3.8: Added the xml_declaration and default_namespace parameters. Changed in version 3.8: The function now preserves the attribute order specified by the user. Parses an XML section from a string constant. This function can be used to embed “XML literals” in Python code. text is a string containing XML data. parser is an optional parser instance. If not given, the standard parser is used. Returns an instance. Parses an XML section from a string constant, and also returns a dictionary which maps from element id:s to elements. text is a string containing XML data. parser is an optional parser instance. If not given, the standard parser is used. Returns a tuple containing an instance and a dictionary.\n\nDefault loader. This default loader reads an included resource from disk. href is a URL. parse is for parse mode either “xml” or “text”. encoding is an optional text encoding. If not given, encoding is . Returns the expanded resource. If the parse mode is , this is an instance. If the parse mode is , this is a string. If the loader fails, it can return or raise an exception. This function expands XInclude directives in-place in tree pointed by elem. elem is either the root or an instance to find such element. loader is an optional resource loader. If omitted, it defaults to . If given, it should be a callable that implements the same interface as . base_url is base URL of the original file, to resolve relative include file references. max_depth is the maximum number of recursive inclusions. Limited to reduce the risk of malicious content explosion. Pass to disable the limitation. Changed in version 3.9: Added the base_url and max_depth parameters. Element class. This class defines the Element interface, and provides a reference implementation of this interface. The element name, attribute names, and attribute values can be either bytestrings or Unicode strings. tag is the element name. attrib is an optional dictionary, containing element attributes. extra contains additional attributes, given as keyword arguments. A string identifying what kind of data this element represents (the element type, in other words). These attributes can be used to hold additional data associated with the element. Their values are usually strings but may be any application-specific object. If the element is created from an XML file, the text attribute holds either the text between the element’s start tag and its first child or end tag, or , and the tail attribute holds either the text between the element’s end tag and the next tag, or . For the XML data the a element has for both text and tail attributes, the b element has text and tail , the c element has text and tail , and the d element has text and tail . To collect the inner text of an element, see , for example . Applications may store arbitrary objects in these attributes. A dictionary containing the element’s attributes. Note that while the attrib value is always a real mutable Python dictionary, an ElementTree implementation may choose to use another internal representation, and create the dictionary only if someone asks for it. To take advantage of such implementations, use the dictionary methods below whenever possible. The following dictionary-like methods work on the element attributes. Resets an element. This function removes all subelements, clears all attributes, and sets the text and tail attributes to . Returns the attribute value, or default if the attribute was not found. Returns the element attributes as a sequence of (name, value) pairs. The attributes are returned in an arbitrary order. Returns the elements attribute names as a list. The names are returned in an arbitrary order. Set the attribute key on the element to value. The following methods work on the element’s children (subelements). Adds the element subelement to the end of this element’s internal list of subelements. Raises if subelement is not an . Appends subelements from an iterable of elements. Raises if a subelement is not an . Finds the first subelement matching match. match may be a tag name or a path. Returns an element instance or . namespaces is an optional mapping from namespace prefix to full name. Pass as prefix to move all unprefixed tag names in the expression into the given namespace. Finds all matching subelements, by tag name or path. Returns a list containing all matching elements in document order. namespaces is an optional mapping from namespace prefix to full name. Pass as prefix to move all unprefixed tag names in the expression into the given namespace. Finds text for the first subelement matching match. match may be a tag name or a path. Returns the text content of the first matching element, or default if no element was found. Note that if the matching element has no text content an empty string is returned. namespaces is an optional mapping from namespace prefix to full name. Pass as prefix to move all unprefixed tag names in the expression into the given namespace. Inserts subelement at the given position in this element. Raises if subelement is not an . Creates a tree iterator with the current element as the root. The iterator iterates over this element and all elements below it, in document (depth first) order. If tag is not or , only elements whose tag equals tag are returned from the iterator. If the tree structure is modified during iteration, the result is undefined. Finds all matching subelements, by tag name or path. Returns an iterable yielding all matching elements in document order. namespaces is an optional mapping from namespace prefix to full name. Creates a text iterator. The iterator loops over this element and all subelements, in document order, and returns all inner text. Creates a new element object of the same type as this element. Do not call this method, use the factory function instead. Removes subelement from the element. Unlike the find* methods this method compares elements based on the instance identity, not on tag value or contents. objects also support the following sequence type methods for working with subelements: , , , . Caution: Elements with no subelements will test as . In a future release of Python, all elements will test as regardless of whether subelements exist. Instead, prefer explicit or elem is not None tests.: \"element not found, or element has no subelements\" Changed in version 3.12: Testing the truth value of an Element emits . Prior to Python 3.8, the serialisation order of the XML attributes of elements was artificially made predictable by sorting the attributes by their name. Based on the now guaranteed ordering of dicts, this arbitrary reordering was removed in Python 3.8 to preserve the order in which attributes were originally parsed or created by user code. In general, user code should try not to depend on a specific ordering of attributes, given that the XML Information Set explicitly excludes the attribute order from conveying information. Code should be prepared to deal with any ordering on input. In cases where deterministic XML output is required, e.g. for cryptographic signing or test data sets, canonical serialisation is available with the function. In cases where canonical output is not applicable but a specific attribute order is still desirable on output, code should aim for creating the attributes directly in the desired order, to avoid perceptual mismatches for readers of the code. In cases where this is difficult to achieve, a recipe like the following can be applied prior to serialisation to enforce an order independently from the Element creation: ElementTree wrapper class. This class represents an entire element hierarchy, and adds some extra support for serialization to and from standard XML. element is the root element. The tree is initialized with the contents of the XML file if given. Replaces the root element for this tree. This discards the current contents of the tree, and replaces it with the given element. Use with care. element is an element instance. Same as , starting at the root of the tree. Same as , starting at the root of the tree. Same as , starting at the root of the tree. Returns the root element for this tree. Creates and returns a tree iterator for the root element. The iterator loops over all elements in this tree, in section order. tag is the tag to look for (default is to return all elements). Same as , starting at the root of the tree. Loads an external XML section into this element tree. source is a file name or file object. parser is an optional parser instance. If not given, the standard parser is used. Returns the section root element. Writes the element tree to a file, as XML. file is a file name, or a file object opened for writing. encoding is the output encoding (default is US-ASCII). xml_declaration controls if an XML declaration should be added to the file. Use for never, for always, for only if not US-ASCII or UTF-8 or Unicode (default is ). default_namespace sets the default XML namespace (for “xmlns”). method is either , or (default is ). The keyword-only short_empty_elements parameter controls the formatting of elements that contain no content. If (the default), they are emitted as a single self-closed tag, otherwise they are emitted as a pair of start/end tags. The output is either a string ( ) or binary ( ). This is controlled by the encoding argument. If encoding is , the output is a string; otherwise, it’s binary. Note that this may conflict with the type of file if it’s an open file object; make sure you do not try to write a string to a binary stream and vice versa. Changed in version 3.8: The method now preserves the attribute order specified by the user. This is the XML file that is going to be manipulated: Example of changing the attribute “target” of every link in first paragraph: # Finds first occurrence of tag p in body QName wrapper. This can be used to wrap a QName attribute value, in order to get proper namespace handling on output. text_or_uri is a string containing the QName value, in the form {uri}local, or, if the tag argument is given, the URI part of a QName. If tag is given, the first argument is interpreted as a URI, and this argument is interpreted as a local name. instances are opaque. Generic element structure builder. This builder converts a sequence of start, data, end, comment and pi method calls to a well-formed element structure. You can use this class to build an element structure using a custom XML parser, or a parser for some other XML-like format. element_factory, when given, must be a callable accepting two positional arguments: a tag and a dict of attributes. It is expected to return a new element instance. The comment_factory and pi_factory functions, when given, should behave like the and functions to create comments and processing instructions. When not given, the default factories will be used. When insert_comments and/or insert_pis is true, comments/pis will be inserted into the tree if they appear within the root element (but not outside of it). Flushes the builder buffers, and returns the toplevel document element. Returns an instance. Adds text to the current element. data is a string. This should be either a bytestring, or a Unicode string. Closes the current element. tag is the element name. Returns the closed element. Opens a new element. tag is the element name. attrs is a dictionary containing element attributes. Returns the opened element. Creates a comment with the given text. If is true, this will also add it to the tree. Creates a process instruction with the given target name and text. If is true, this will also add it to the tree. In addition, a custom object can provide the following methods: Handles a doctype declaration. name is the doctype name. pubid is the public identifier. system is the system identifier. This method does not exist on the default class. Is called whenever the parser encounters a new namespace declaration, before the callback for the opening element that defines it. prefix is for the default namespace and the declared namespace prefix name otherwise. uri is the namespace URI. Is called after the callback of an element that declared a namespace prefix mapping, with the name of the prefix that went out of scope. A C14N 2.0 writer. Arguments are the same as for the function. This class does not build a tree but translates the callback events directly into a serialised form using the write function. This class is the low-level building block of the module. It uses for efficient, event-based parsing of XML. It can be fed XML data incrementally with the method, and parsing events are translated to a push API - by invoking callbacks on the target object. If target is omitted, the standard is used. If encoding is given, the value overrides the encoding specified in the XML file. Changed in version 3.8: Parameters are now keyword-only. The html argument is no longer supported. Finishes feeding data to the parser. Returns the result of calling the method of the target passed during construction; by default, this is the toplevel document element. Feeds data to the parser. data is encoded data. Triggers parsing of any previously fed unparsed data, which can be used to ensure more immediate feedback, in particular with Expat >=2.6.0. The implementation of temporarily disables reparse deferral with Expat (if currently enabled) and triggers a reparse. Disabling reparse deferral has security consequences; please see for details. Note that has been backported to some prior releases of CPython as a security fix. Check for availability of using if used in code running across a variety of Python versions. calls target's method for each opening tag, its method for each closing tag, and data is processed by method . For further supported callback methods, see the class. calls target's method . can be used not only for building a tree structure. This is an example of counting the maximum depth of an XML file: # The target object of the parser # We do not need to do anything with data. # Called when all data has been parsed. A pull parser suitable for non-blocking applications. Its input-side API is similar to that of , but instead of pushing calls to a callback target, collects an internal list of parsing events and lets the user read from it. events is a sequence of events to report back. The supported events are the strings , , , , and (the “ns” events are used to get detailed namespace information). If events is omitted, only events are reported. Feed the given bytes data to the parser. Triggers parsing of any previously fed unparsed data, which can be used to ensure more immediate feedback, in particular with Expat >=2.6.0. The implementation of temporarily disables reparse deferral with Expat (if currently enabled) and triggers a reparse. Disabling reparse deferral has security consequences; please see for details. Note that has been backported to some prior releases of CPython as a security fix. Check for availability of using if used in code running across a variety of Python versions. Signal the parser that the data stream is terminated. Unlike , this method always returns . Any events not yet retrieved when the parser is closed can still be read with . Return an iterator over the events which have been encountered in the data fed to the parser. The iterator yields pairs, where event is a string representing the type of event (e.g. ) and elem is the encountered object, or other context value as follows.\n• None : (this may change in a future version) Events provided in a previous call to will not be yielded again. Events are consumed from the internal queue only when they are retrieved from the iterator, so multiple readers iterating in parallel over iterators obtained from will have unpredictable results. only guarantees that it has seen the “>” character of a starting tag when it emits a “start” event, so the attributes are defined, but the contents of the text and tail attributes are undefined at that point. The same applies to the element children; they may or may not be present. If you need a fully populated element, look for “end” events instead. Changed in version 3.8: The and events were added. XML parse error, raised by the various parsing methods in this module when parsing fails. The string representation of an instance of this exception will contain a user-friendly error message. In addition, it will have the following attributes available: A numeric error code from the expat parser. See the documentation of for the list of error codes and their meanings. A tuple of line, column numbers, specifying where the error occurred."
    },
    {
        "link": "https://datacamp.com/tutorial/python-xml-elementtree",
        "document": "Master the basics of data analysis with Python in just four hours. This online course will introduce the Python interface and explore popular packages."
    },
    {
        "link": "https://stackoverflow.com/questions/52877083/python-3-parse-xml-file-with-elementtree",
        "document": "Help, I have the following XML file that I am trying to read and extract data from, below is an extract from the xml file,\n\nI am trying to extract the following,\n\nI have worked through the example here, xml.etree.ElementTree — The ElementTree XML API and I can get the example to work, but when I modify the code for the above xml, the code returns nothing!\n\nHere is my code,\n\nAny ideas? Thanks in advance for any help.\n\nEdit: Thanks to everyone who has commented. With with your advice I have had a play and a search and got the following code,\n\nTo return the following,\n\nI know, not the best code in the world, any ideas on how to streamline the code would very welcome."
    },
    {
        "link": "https://stackoverflow.com/questions/77602510/xml-parsing-using-python-elementtree-to-extract-specific-data",
        "document": "I have an xml file that I need to parse. I vaguely understand python and xml. I'm using ElementTree to parse the document, however just about every reference I've researched online gets me on the right track but I fall short on a particular aspect of my use case. If my xml looks like:\n\nI want to write a for loop to iterate over children in the tree, but I only care about category1 children with the \"status = Open\". Every reference ive read including the python documentation leads me to pulling all attributes with status Open, but this causes me to pull category2 and category3's which I dont want. Is there any way to isolate this to just category1 children? I want to eventually append the output to a list but can figure that out once I isolate this output.\n\nI've tried something like but this dosent work:"
    },
    {
        "link": "https://scrapingant.com/blog/python-parse-xml",
        "document": "Parsing XML (eXtensible Markup Language) in Python is a fundamental task for many developers, given XML's widespread use in data storage and transmission. Python offers a variety of libraries for XML parsing, each catering to different needs and use cases. Understanding the strengths and limitations of these libraries is crucial for efficient and effective XML processing. This guide explores both standard and third-party libraries, providing code samples and detailed explanations to help you choose the right tool for your project.\n\nPython's standard library includes modules like , , and , each designed for specific parsing requirements. For more advanced needs, third-party libraries like , , and offer enhanced performance, leniency in parsing malformed XML, and ease of use.\n\nThis comprehensive guide also delves into best practices for XML parsing in Python, addressing performance optimization, handling large files, and ensuring robust error handling and validation. By the end of this guide, you will be equipped with the knowledge to handle XML parsing tasks efficiently and securely, regardless of the complexity or size of the XML documents you encounter.\n\nPython's standard library offers several modules for XML parsing, each with its own strengths and use cases:\n\nThe ElementTree API is a lightweight and efficient way to parse XML in Python. It provides a simple, Pythonic interface for working with XML data (Python documentation).\n\nElementTree is suitable for most XML parsing tasks and is often the go-to choice for its simplicity and performance.\n\nThe minidom module implements a minimal DOM interface for XML parsing (Python documentation). While it's less efficient than ElementTree, it can be useful for small XML documents or when DOM compatibility is required.\n\nSAX (Simple API for XML) is an event-driven parser that doesn't load the entire XML document into memory (Python documentation). This makes it suitable for processing very large XML files or streams.\n\nWhile the standard library modules are sufficient for many tasks, third-party libraries can offer additional features, better performance, or easier-to-use APIs:\n\nlxml is a fast, feature-rich library for processing XML and HTML (lxml documentation). It combines the speed and features of libxml2 and libxslt with the simplicity of the ElementTree API.\n\nlxml is particularly useful for its XPath support, XSLT capabilities, and schema validation features. It's often the best choice for complex XML processing tasks or when performance is critical.\n\nWhile primarily known for HTML parsing, BeautifulSoup can also handle XML documents (BeautifulSoup documentation). It’s particularly useful for its forgiving nature when dealing with malformed XML.\n\nBeautifulSoup is a good choice when working with potentially malformed XML or when you need a more lenient parser.\n\nuntangle is a simple library that converts XML to Python objects, making it very easy to navigate XML structures (untangle documentation).\n\nuntangle is ideal for quick and dirty XML parsing tasks where you don't need advanced features and want a very simple API.\n\nLearn more about Python libraries for web scraping with Python in the following article Web Scraping with Python.\n\nWhen choosing an XML parsing library, performance can be a crucial factor. Here's a comparison of parsing speeds for a 10MB XML file:\n\nThese numbers are approximate and can vary based on the specific XML structure and parsing task. lxml consistently outperforms other libraries, especially for large XML files.\n\nWhen parsing XML from untrusted sources, security is a critical concern. XML parsing can be vulnerable to various attacks, including billion laughs attacks and external entity expansion (OWASP XML Security Cheat Sheet).\n\nThe standard library XML parsers in Python are vulnerable to these attacks by default. For secure XML parsing, consider using the defusedxml library (defusedxml documentation), which provides safe replacements for all of Python's standard library XML parsers:\n\nWhen using third-party libraries like lxml, be sure to disable entity resolution and other potentially dangerous features when parsing untrusted XML:\n\nThe choice of XML parsing library depends on your specific requirements:\n• For very large XML files or memory-constrained environments, use xml.sax.\n• For complex XML processing, XPath support, or high performance, use lxml.\n• For lenient parsing of potentially malformed XML, use BeautifulSoup.\n• For quick and easy XML-to-object conversion, use untangle.\n\nAlways consider the trade-offs between ease of use, performance, feature set, and security when selecting an XML parsing library for your Python project.\n\nDiscover the best Python libraries for XML parsing, including xml.etree.ElementTree, lxml, BeautifulSoup, and more. Learn how to use each with code examples and performance comparisons.\n\nWhen it comes to XML parsing in Python, selecting the appropriate parser is crucial for optimal performance and functionality. The choice largely depends on the size of the XML files and the specific requirements of your project.\n• None\n• Use or its C implementation (default in Python 3.3+) for efficient parsing (Python documentation).\n• These built-in Python XML parsers offer a good balance of speed and ease of use for most applications.\n• None\n• Consider using , a fast and feature-rich Python library that combines the power of libxml2 and libxslt (lxml documentation).\n• is particularly efficient for parsing large XML documents and provides additional functionality like XPath support.\n• None\n• Utilize event-driven parsing with or to process XML data without loading the entire document into memory (xml.parsers.expat documentation).\n\nTo enhance XML parsing performance in Python, consider implementing the following best practices:\n• None Use iterative parsing: Employ iterative parsing techniques to process large XML files efficiently. For example, with : This approach allows processing of elements as they are parsed, reducing memory usage (Stack Overflow discussion).\n• None Clear unnecessary elements: When using iterative parsing, clear processed elements to free up memory: This technique prevents memory buildup during parsing of large XML files.\n• None Use XPath for efficient querying: Leverage XPath expressions for precise and efficient element selection, especially when working with complex XML structures: XPath queries can significantly reduce the amount of code needed for element selection and improve performance (lxml XPath documentation).\n• None Implement partial parsing: For scenarios where only specific parts of the XML document are needed, use partial parsing to improve efficiency: This approach allows processing of only relevant elements, reducing unnecessary parsing overhead.\n\nWhen dealing with XML files exceeding 1GB in size, special considerations are necessary:\n• None Stream parsing: Utilize streaming parsers like or to process the XML file in chunks, avoiding the need to load the entire document into memory: This method allows processing of extremely large XML files without memory constraints (Python documentation).\n• None This approach allows processing of large XML files in smaller, memory-friendly portions.\n\nImplementing robust error handling and validation is crucial for reliable XML parsing:\n• None Use try-except blocks: Wrap parsing operations in try-except blocks to handle potential exceptions gracefully: This practice ensures that your application can handle parsing errors without crashing.\n• None Implement XML schema validation: Use XML Schema Definition (XSD) to validate XML documents before parsing: XML schema validation ensures that the parsed XML adheres to the expected structure and data types (lxml validation documentation).\n• None Handle encoding issues: Be prepared to handle different XML encodings by specifying the correct encoding or using Unicode: This approach helps prevent encoding-related parsing errors, especially when dealing with XML files from various sources.\n\nBy following these best practices, developers can significantly improve the efficiency, reliability, and performance of XML parsing in Python, even when working with large and complex XML documents.\n\nIn conclusion, parsing XML in Python can range from simple to complex tasks depending on the requirements of your project. The standard libraries like , , and offer robust solutions for most common XML parsing needs, while third-party libraries like , , and provide additional features and performance enhancements for more demanding tasks.\n\nWhen choosing an XML parser, consider the size of your XML files, memory constraints, and the specific functionalities you need. For instance, is ideal for typical use cases due to its simplicity and efficiency, whereas excels in performance and advanced XML processing capabilities, including XPath and XSLT support (lxml documentation). For handling potentially malformed XML, is a forgiving option, and offers a straightforward approach for quick XML-to-object conversion (BeautifulSoup documentation, untangle documentation).\n\nAdhering to best practices such as iterative parsing, clearing unnecessary elements, and employing XML schema validation can significantly improve the efficiency and reliability of your XML parsing tasks. Additionally, when dealing with untrusted XML sources, always consider security implications and use safe parsing methods, like those provided by the library (defusedxml documentation).\n\nBy leveraging the right tools and techniques, you can ensure that your XML parsing in Python is both efficient and secure, enabling you to handle a wide range of XML processing scenarios effectively."
    }
]