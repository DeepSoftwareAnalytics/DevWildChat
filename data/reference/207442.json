[
    {
        "link": "https://rdocumentation.org/packages/Rfast/versions/1.7.3/topics/Floyd-Warshall%20algorithm",
        "document": "The adjacency matrix of a directed graph. A positive number in x[i, j] indicates that there is an arrow from i to j and it also shows the cost of going from i to j. Hence, the algorithm will find not only the shortest path but also the with the smallest cost. A value of zero means that there is no path. Put positive number only, as negative will cause problems."
    },
    {
        "link": "https://geeksforgeeks.org/floyd-warshall-algorithm-dp-16",
        "document": "The Floyd Warshall Algorithm is an all-pair shortest path algorithm that uses Dynamic Programming to find the shortest distances between every pair of vertices in a graph, unlike Dijkstra and Bellman-Ford which are single source shortest path algorithms. This algorithm works for both the directed and undirected weighted graphs and can handle graphs with both positive and negative weight edges. \n\n\n\nNote: It does not work for the graphs with negative cycles (where the sum of the edges in a cycle is negative).\n\nSuppose we have a graph graph[][] with V vertices from 0to V-1. Now we have to evaluate a dist[][] where dist[i][j] represents the shortest path between vertex i to j. Let us assume that vertices i to j have intermediate nodes. The idea behind Floyd Warshall algorithm is to treat each and every vertex k from 0 to V-1 as an intermediate node one by one. When we consider the vertex k, we must have considered vertices from 0 to k-1 already. So we use the shortest paths built by previous vertices to build shorter paths with vertex k included. The following figure shows the above optimal substructure property in Floyd Warshall algorithm:\n• None Initialize the solution matrix same as the input graph matrix as a first step.\n• None Then update the solution matrix by considering all vertices as an intermediate vertex.\n• None The idea is to pick all vertices one by one and updates all shortest paths which include the picked vertex as an intermediate vertex in the shortest path.\n• k as an intermediate vertex, we already have considered vertices {0, 1, 2, .. k-1}\n• (i, j) of the source and destination vertices respectively, there are two possible cases.\n• k is not an intermediate vertex in shortest path from i j . We keep the value of dist[i][j] as it is.\n• k is an intermediate vertex in shortest path from i j . We update the value of dist[i][j] dist[i][k] + dist[k][j], dist[i][j] > dist[i][k] + dist[k][j]\n\n// Add all vertices one by one to // Pick all vertices as source one by one // for the above picked source // If vertex k is on the shortest path from // i to j, then update the value of graph[i][j] // Add all vertices one by one to // Pick all vertices as source one by one // for the above picked source // If vertex k is on the shortest path from // i to j, then update the value of graph[i][j] # Add all vertices one by one to # Pick all vertices as source one by one # for the above picked source # If vertex k is on the shortest path from # i to j, then update the value of graph[i][j] // Add all vertices one by one to // Pick all vertices as source one by one // for the above picked source // If vertex k is on the shortest path from // i to j, then update the value of graph[i,j] // Add all vertices one by one to // Pick all vertices as source one by one // for the above picked source // If vertex k is on the shortest path from // i to j, then update the value of graph[i][j]\n\nTime Complexity: O(V3), where V is the number of vertices in the graph and we run three nested loops each of size V.\n\nAuxiliary Space: O(V2), to create a 2-D matrix in order to store the shortest distance for each pair of nodes.\n\nNote: The above program only prints the shortest distances. We can modify the solution to print the shortest paths also by storing the predecessor information in a separate 2D matrix.\n\nThe algorithm relies on the principle of optimal substructure, meaning:\n• None If the shortest path from i to j passes through some vertex k, then the path from i to k and the path from k to j must also be shortest paths.\n• None The iterative approach ensures that by the time vertex k is considered, all shortest paths using only vertices 0 to k-1 have already been computed.\n\nBy the end of the algorithm, all shortest paths are computed optimally because each possible intermediate vertex has been considered.\n\nWhy Floyd-Warshall Algorithm better for Dense Graphs and not for Sparse Graphs?\n\nDense Graph: A graph in which the number of edges are significantly much higher than the number of vertices.\n\nSparse Graph: A graph in which the number of edges are very much low. No matter how many edges are there in the graph the Floyd Warshall Algorithm runs for O(V3) times therefore it is best suited for Dense graphs. In the case of sparse graphs, Johnson’s Algorithm is more suitable.\n• None In computer networking, the algorithm can be used to find the shortest path between all pairs of nodes in a network. This is termed as network routing\n• None Flight Connectivity In the aviation industry to find the shortest path between the airports.\n• GIS Geographic Information Systems ) applications often involve analyzing spatial data, such as road networks, to find the shortest paths between locations.\n• None which is a generalization of floyd warshall, can be used to find regular expression for a regular language.\n• None How to Detect Negative Cycle in a graph using Floyd Warshall Algorithm?\n• None How is Floyd-warshall algorithm different from Dijkstra’s algorithm?\n• None How is Floyd-warshall algorithm different from Bellman-Ford algorithm?\n• None Shortest path with one curved edge in an undirected Graph\n• None 1st to Kth shortest path lengths in given Graph\n• None Number of ways to reach at destination in shortest time"
    },
    {
        "link": "https://programiz.com/dsa/floyd-warshall-algorithm",
        "document": "Floyd-Warshall Algorithm is an algorithm for finding the shortest path between all the pairs of vertices in a weighted graph. This algorithm works for both the directed and undirected weighted graphs. But, it does not work for the graphs with negative cycles (where the sum of the edges in a cycle is negative).\n\nFloyd-Warhshall algorithm is also called as Floyd's algorithm, Roy-Floyd algorithm, Roy-Warshall algorithm, or WFI algorithm.\n\nThis algorithm follows the dynamic programming approach to find the shortest paths.\n\nLet the given graph be:\n\nFollow the steps below to find the shortest path between all the pairs of vertices.\n• Create a matrix of dimension where n is the number of vertices. The row and the column are indexed as and respectively. and are the vertices of the graph.\n\n \n\n Each cell is filled with the distance from the vertex to the vertex. If there is no path from vertex to vertex, the cell is left as infinity. Fill each cell with the distance between ith and jth vertex\n• Now, create a matrix using matrix . The elements in the first column and the first row are left as they are. The remaining cells are filled in the following way.\n\n \n\n Let be the intermediate vertex in the shortest path from source to destination. In this step, is the first vertex. is filled with .\n\n \n\n That is, if the direct distance from the source to the destination is greater than the path through the vertex , then the cell is filled with .\n\n \n\n In this step, k is vertex 1. We calculate the distance from source vertex to destination vertex through this vertex k. Calculate the distance from the source vertex to destination vertex through this vertex k \n\n For example: For , the direct distance from vertex 2 to 4 is 4 and the sum of the distance from vertex 2 to 4 through vertex (ie. from vertex 2 to 1 and from vertex 1 to 4) is 7. Since , is filled with 4.\n• Similarly, is created using . The elements in the second column and the second row are left as they are.\n\n \n\n In this step, is the second vertex (i.e. vertex 2). The remaining steps are the same as in step 2. Calculate the distance from the source vertex to destination vertex through this vertex 2\n• Similarly, and is also created. Calculate the distance from the source vertex to destination vertex through this vertex 3 Calculate the distance from the source vertex to destination vertex through this vertex 4\n• gives the shortest path between each pair of vertices.\n\nThere are three loops. Each loop has constant complexities. So, the time complexity of the Floyd-Warshall algorithm is .\n\nThe space complexity of the Floyd-Warshall algorithm is .\n• To find the shortest path is a directed graph\n• To find the transitive closure of directed graphs\n• To find the Inversion of real matrices\n• For testing whether an undirected graph is bipartite"
    },
    {
        "link": "https://search.r-project.org/CRAN/refmans/Rfast/help/floyd.html",
        "document": ""
    },
    {
        "link": "https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm",
        "document": "In computer science, the Floyd–Warshall algorithm (also known as Floyd's algorithm, the Roy–Warshall algorithm, the Roy–Floyd algorithm, or the WFI algorithm) is an algorithm for finding shortest paths in a directed weighted graph with positive or negative edge weights (but with no negative cycles).[1][2] A single execution of the algorithm will find the lengths (summed weights) of shortest paths between all pairs of vertices. Although it does not return details of the paths themselves, it is possible to reconstruct the paths with simple modifications to the algorithm. Versions of the algorithm can also be used for finding the transitive closure of a relation , or (in connection with the Schulze voting system) widest paths between all pairs of vertices in a weighted graph.\n\nThe Floyd–Warshall algorithm is an example of dynamic programming, and was published in its currently recognized form by Robert Floyd in 1962.[3] However, it is essentially the same as algorithms previously published by Bernard Roy in 1959[4] and also by Stephen Warshall in 1962[5] for finding the transitive closure of a graph,[6] and is closely related to Kleene's algorithm (published in 1956) for converting a deterministic finite automaton into a regular expression, with the difference being the use of a min-plus semiring.[7] The modern formulation of the algorithm as three nested for-loops was first described by Peter Ingerman, also in 1962.[8]\n\nThe Floyd–Warshall algorithm compares many possible paths through the graph between each pair of vertices. It is guaranteed to find all shortest paths and is able to do this with comparisons in a graph,[1][9] even though there may be edges in the graph. It does so by incrementally improving an estimate on the shortest path between two vertices, until the estimate is optimal.\n\nConsider a graph with vertices numbered 1 through . Further consider a function that returns the length of the shortest possible path (if one exists) from to using vertices only from the set as intermediate points along the way. Now, given this function, our goal is to find the length of the shortest path from each to each using any vertex in . By definition, this is the value , which we will find recursively.\n\nObserve that must be less than or equal to : we have more flexibility if we are allowed to use the vertex . If is in fact less than , then there must be a path from to using the vertices that is shorter than any such path that does not use the vertex . Since there are no negative cycles this path can be decomposed as:\n\nAnd of course, these must be a shortest such path (or several of them), otherwise we could further decrease the length. In other words, we have arrived at the recursive formula:\n\nThe base case is given by\n\nwhere denotes the weight of the edge from to if one exists and ∞ (infinity) otherwise.\n\nThese formulas are the heart of the Floyd–Warshall algorithm. The algorithm works by first computing for all pairs for , then , then , and so on. This process continues until , and we have found the shortest path for all pairs using any intermediate vertices. Pseudocode for this basic version follows.\n\nThe algorithm above is executed on the graph on the left below:\n\nPrior to the first recursion of the outer loop, labeled k = 0 above, the only known paths correspond to the single edges in the graph. At k = 1, paths that go through the vertex 1 are found: in particular, the path [2,1,3] is found, replacing the path [2,3] which has fewer edges but is longer (in terms of weight). At k = 2, paths going through the vertices {1,2} are found. The red and blue boxes show how the path [4,2,1,3] is assembled from the two known paths [4,2] and [2,1,3] encountered in previous iterations, with 2 in the intersection. The path [4,2,3] is not considered, because [2,1,3] is the shortest path encountered so far from 2 to 3. At k = 3, paths going through the vertices {1,2,3} are found. Finally, at k = 4, all shortest paths are found.\n\nThe distance matrix at each iteration of k, with the updated distances in bold, will be:\n\nA negative cycle is a cycle whose edges sum to a negative value. There is no shortest path between any pair of vertices , which form part of a negative cycle, because path-lengths from to can be arbitrarily small (negative). For numerically meaningful output, the Floyd–Warshall algorithm assumes that there are no negative cycles. Nevertheless, if there are negative cycles, the Floyd–Warshall algorithm can be used to detect them. The intuition is as follows:\n• The Floyd–Warshall algorithm iteratively revises path lengths between all pairs of vertices , including where ;\n• Initially, the length of the path is zero;\n• A path can only improve upon this if it has length less than zero, i.e. denotes a negative cycle;\n• Thus, after the algorithm, will be negative if there exists a negative-length path from back to .\n\nHence, to detect negative cycles using the Floyd–Warshall algorithm, one can inspect the diagonal of the path matrix, and the presence of a negative number indicates that the graph contains at least one negative cycle.[9] During the execution of the algorithm, if there is a negative cycle, exponentially large numbers can appear, as large as , where is the largest absolute value of a negative edge in the graph. To avoid overflow/underflow problems one should check for negative numbers on the diagonal of the path matrix within the inner for loop of the algorithm.[10] Obviously, in an undirected graph a negative edge creates a negative cycle (i.e., a closed walk) involving its incident vertices. Considering all edges of the above example graph as undirected, e.g. the vertex sequence 4 – 2 – 4 is a cycle with weight sum −2.\n\nThe Floyd–Warshall algorithm typically only provides the lengths of the paths between all pairs of vertices. With simple modifications, it is possible to create a method to reconstruct the actual path between any two endpoint vertices. While one may be inclined to store the actual path from each vertex to each other vertex, this is not necessary, and in fact, is very costly in terms of memory. Instead, we can use the shortest-path tree, which can be calculated for each node in time using memory, and allows us to efficiently reconstruct a directed path between any two connected vertices.\n\nThe array holds the penultimate vertex on the path from to (except in the case of , where it always contains even if there is no self-loop on ):[11]\n\nLet be , the number of vertices. To find all of (for all and ) from those of requires operations. Since we begin with and compute the sequence of matrices , , , , each having a cost of , the total time complexity of the algorithm is .[9][12]\n\nThe Floyd–Warshall algorithm can be used to solve the following problems, among others:\n• Transitive closure of directed graphs (Warshall's algorithm). In Warshall's original formulation of the algorithm, the graph is unweighted and represented by a Boolean adjacency matrix. Then the addition operation is replaced by logical conjunction (AND) and the minimum operation by logical disjunction (OR).\n• Finding a regular expression denoting the regular language accepted by a finite automaton (Kleene's algorithm, a closely related generalization of the Floyd–Warshall algorithm) 13\n• Optimal routing. In this application one is interested in finding the path with the maximum flow between two vertices. This means that, rather than taking minima as in the pseudocode above, one instead takes maxima. The edge weights represent fixed constraints on flow. Path weights represent bottlenecks; so the addition operation above is replaced by the minimum operation.\n\nImplementations are available for many programming languages.\n• For C++, in the boost::graph library\n• For C#, at QuikGraph\n• For C#, at QuickGraphPCL (A fork of QuickGraph with better compatibility with projects using Portable Class Libraries.)\n• For Java, in the Apache Commons Graph library\n• For JavaScript, in the Cytoscape library\n• For Julia, in the Graphs.jl package\n• For MATLAB, in the Matlab_bgl package\n• For Perl, in the Graph module\n• For Python, in the SciPy library (module scipy.sparse.csgraph) or NetworkX library\n• For R, in packages e1071 and Rfast\n• For C, a pthreads, parallelized, implementation including a SQLite interface to the data at floydWarshall.h\n\nFor graphs with non-negative edge weights, Dijkstra's algorithm can be used to find all shortest paths from a single vertex with running time . Thus, running Dijkstra starting at each vertex takes time . Since , this yields a worst-case running time of repeated Dijkstra of . While this matches the asymptotic worst-case running time of the Floyd-Warshall algorithm, the constants involved matter quite a lot. When a graph is dense (i.e., ), the Floyd-Warshall algorithm tends to perform better in practice. When the graph is sparse (i.e., is significantly smaller than ), Dijkstra tends to dominate.\n\nFor sparse graphs with negative edges but no negative cycles, Johnson's algorithm can be used, with the same asymptotic running time as the repeated Dijkstra approach.\n\nThere are also known algorithms using fast matrix multiplication to speed up all-pairs shortest path computation in dense graphs, but these typically make extra assumptions on the edge weights (such as requiring them to be small integers).[16][17] In addition, because of the high constant factors in their running time, they would only provide a speedup over the Floyd–Warshall algorithm for very large graphs.\n• Interactive animation of the Floyd–Warshall algorithm (Technical University of Munich)"
    },
    {
        "link": "https://stackoverflow.com/questions/66766468/how-to-initialize-an-mn-matrix-in-r-with-specific-row-and-column-names",
        "document": "I am trying to find a way to initialize a m*n matrix in R. Let's say I have a seq of variable names , and I would like to create a 4*10 matrix with being the vertical variable, and to be horizontal variable, so I can check the matrix with the call ."
    },
    {
        "link": "https://stackoverflow.com/questions/4070819/optimal-algorithm-for-path-finding-in-a-matrix-that-does-not-fit-entirely-into-m",
        "document": "Imagine I have a map of an entire country, represented by a huge matrix of Cells. Each cell represents a 1 square meter of territory. Each Cell is represented as a value between 0 and 1 that represents the cost of traversing the cell.\n\nThe map obviously is not fittable in memory.\n\nI am trying to wrap my mind arround a way to calculate the optimal path for a robot, from a start point to a end position. The first idea I had was to make a TCP-like moving window, with a minimap of the real map arround the moving robot, and executing the A* algorithm inside there, but I'm facing some problems with maps with huge walls, bad pathfinding, etc...\n\nI am searching the literature about A*-like algorithms and I could not visualize an approximation of what would be a good solution for this problem.\n\nI'm wondering if someone has faced a similar problem or can help with a idea of a possible solution!"
    },
    {
        "link": "https://reddit.com/r/C_Programming/comments/u5mgrx/pathfinding_within_a_2d_array",
        "document": "I've been recently working on pathfinding in my project, and I'm not sure how to solve an issue it has now.\n\nThe problem is, in cases like what's seen down below, the pathfinder is not able to go to the target\n\nI imagine there is a way to use something like an A* algorithm in order to make this happen, but I'm not sure how to put the algorithm into a 2D array, and I'm worried that because of the amound of edges and nodes in the actual project, the algorithm would make it extremely slow to go through a single turn. How can I solve this issue?"
    },
    {
        "link": "https://geeksforgeeks.org/optimal-path-in-matrix",
        "document": "Given a matrix grid[][] of size M * N, where grid[i][j] represents the value of the cell at position (i, j), the task is to determine an optimal path from the top-left corner to the bottom-right corner while minimizing the maximum value of |grid[i1][j1] - grid[i2][j2]| for adjacent cells along the path.\n\nInput: {{2,2,2}, \n\n {2,8,4},\n\n {1,2,2}};\n\nOutput: 1\n\nExplanation: The optimal path is {2, 2, 1, 2, 2}, the maximum absolute difference of adjacent cells here is 1. Input: {{3,2,2}, \n\n {7,1,8},\n\n {1,1,3}};\n\nOutput: 2\n\nExplanation: The optimal path is {3, 2, 1, 1, 3}, the maximum absolute difference of adjacent cells here is 2.\n\nWe can use Binary Search to find the optimal path. Initialize a search space [low, high] to [0, INT_MAX] where our answer could possible. Now check for mid of this range is valid answer or not (here, we have to check that absolute difference of adjacent cell should not be more than mid.), if valid then move the high to mid - 1, otherwise move start to mid + 1.\n• isValid() function to check if there's a valid path from the top-left to the bottom-right corner with an Inianialize start 0 end to some maximum possible value.\n• low high , do the following:\n• mid and check if the mid value is valid using the isV alid()\n• None If it's not valid (going outside the matrix, visiting visited cells, or exceeding the maximum value), return false\n• None If it reaches the bottom-right cell, return true\n• None Check all four directions for valid paths. If any is valid, return true\n\nBelow is the implementation of the above approach:\n\n// C++ code to implement the above approach // Function to check if there is a valid path // Check if we go outside the matrix or // is greater then our assumed maximum // Check if we reach at bottom-right // Make all four direction call and // check if any path is valid If true, // Function to find the minimum value among // path into the grid If true, // Class variable to store the size of the grid // Function to check if there is a valid path // Check if we go outside the matrix or // is greater than our assumed maximum // Check if we reach at bottom-right // Make all four direction calls and // check if any path is valid. If true, // Function to find the minimum value among // path into the grid. If true, # Global variables to store the dimensions of the grid # Function to check if there is a valid path # Check if we go outside the matrix or # is greater than our assumed maximum # value required. If true, then return false. # Check if we reach the bottom-right cell. If true, then return true. # Make all four direction calls and # check if any path is valid. If true, # Function to find the minimum value among # Check if mid is a valid answer, by choosing any # path into the grid. If true, update the result and // C# code to implement the above approach // Function to check if there is a valid path // Check if we go outside the matrix or // is greater than our assumed maximum // Check if we reach at bottom-right // Make all four direction calls and // check if any path is valid. If true, // Function to find the minimum value among // path into the grid. If true, // JavaScript Implementation of the given problem // Function to check if there is a valid path // Check if we go outside the matrix or cell(i, j) is visited // or absolute difference between consecutive cells is greater // than our assumed maximum value required. If true, return false. // Check if we reach the bottom-right // Make all four directional calls and // check if any path is valid. If true, return true. // Function to find the minimum value // Check if mid is a valid answer by choosing // any path into the grid // If true, update the result and move high to mid - 1\n\nTime Complexity: O(log (K) * (M*N)), where K is the maximum element in the matrix and M, and N are the number of rows and columns in the given matrix respectively.\n\nAuxiliary Space: O(M * N)"
    },
    {
        "link": "https://reddit.com/r/roguelikedev/comments/9dk956/path_finding_is_hard_what_are_your_tips_for",
        "document": "So it turns out path finding has a lot of nuance. Who'd have thought? ;)\n\nAs path finding is something we all have to face (right?) I wondered what top tips the community might have to share for getting it just right. Or, given learning by example can be quite effective, not to mention a chance to share some hilarity, how about some tales of when path finding lead to some interesting situations. Maybe even why that was!\n\nSo, what's your oddest path finding snafu? Or your golden rule for avoiding such?"
    }
]