[
    {
        "link": "https://stackoverflow.com/questions/6053974/python-efficiently-check-if-integer-is-within-many-ranges",
        "document": "I am working on a postage application which is required to check an integer postcode against a number of postcode ranges, and return a different code based on which range the postcode matches against.\n\nEach code has more than one postcode range. For example, the M code should be returned if the postcode is within the ranges 1000-2429, 2545-2575, 2640-2686 or is equal to 2890.\n\nI could write this as:\n\nbut this seems like a lot of lines of code, given that there are 27 returnable codes and 77 total ranges to check against. Is there a more efficient (and preferably more concise) method of matching an integer to all these ranges using Python?\n\nEdit: There's a lot of excellent solutions flying around, so I have implemented all the ones that I could, and benchmarked their performances.\n\nThe environment for this program is a web service (Django-powered actually) which needs to check postcode region codes one-by-one, on the fly. My preferred implementation, then, would be one that can be quickly used for each request, and does not need any process to be kept in memory, or needs to process many postcodes in bulk.\n\nI tested the following solutions using with default 1000000 repetitions using randomly generated postcodes each time.\n\nSomewhat more elegant to my mind and certainly easier to enter and read the ranges. Particularly good if they change over time, which is possible. But it did end up four times slower in my implementation.\n\nAs stated by the author, \"it's only better if you are building the set once to check against many postcodes in a loop\". But I thought I would test it anyway to see.\n\nThis one may have been a bit above my intellect level. I learnt a lot reading about the module but just couldn't quite work out which parameters to give to make a runnable test. I expect that it would be extremely fast with a loop of many postcodes, but not if it had to do the setup each time. So, with 1m repetitions of filling , , etc for just one postal region code (the M code with four ranges), but not actually running the :\n\nUsing one dict per postal region code pre-generated, cPickled in a source file (106 KB), and loaded for each run. I was expecting much better performance from this method, but on my system at least, the IO really destroyed it. The server is a not-quite-blindingly-fast-top-of-the-line Mac Mini.\n\nWell, I was expecting someone to just give a simple 'duh' answer that I hadn't considered, but it turns out this is much more complicated (and even a little controversial).\n\nIf every nanosecond of efficiency counted in this case, I would probably keep a separate process running which implemented one of the binary search or dict solutions and kept the result in memory for an extremely fast lookup. However, since the IF tree takes only five seconds to run a million times, which is plenty fast enough for my small business, that's what I'll end up using in my application.\n\nThank you to everyone for contributing!"
    },
    {
        "link": "https://realpython.com/python-range",
        "document": "In Python, the function generates a sequence of numbers, often used in loops for iteration. By default, it creates numbers starting from 0 up to but not including a specified stop value. You can also reverse the sequence with . If you need to count backwards, then you can use a negative step, like , which counts down from to .\n\nThe function is not just about iterating over numbers. It can also be used in various programming scenarios beyond simple loops. By mastering , you can write more efficient and readable Python code. Explore how can simplify your code and when alternatives might be more appropriate.\n\nBy the end of this tutorial, you’ll understand that:\n• A range in Python is an object representing an interval of integers, often used for looping.\n• The function can be used to generate sequences of numbers that can be converted to lists.\n• is a loop that iterates over the numbers from 0 to 4, inclusive.\n• The range parameters , , and define where the sequence begins, ends, and the interval between numbers.\n• Ranges can go backward in Python by using a negative step value and reversed by using .\n\nA range is a Python object that represents an interval of integers. Usually, the numbers are consecutive, but you can also specify that you want to space them out. You can create ranges by calling with one, two, or three arguments, as the following examples show:\n\nIn each example, you use to explicitly list the individual elements of each range. You’ll study these examples in more detail later on.\n\nA range can be an effective tool. However, throughout this tutorial, you’ll also explore alternatives that may work better in some situations. You can click the link below to download the code that you’ll see in this tutorial:\n\nIn Python, is built in. This means that you can always call without doing any preparations first. Calling constructs a range object that you can put to use. Later, you’ll see practical examples of how to use range objects. You can provide with one, two, or three integer arguments. This corresponds to three different use cases: You’ll learn how to use each of these next. When you call with one argument, you create a range that counts from zero and up to, but not including, the number you provided: Here, you’ve created a range from zero to five. To see the individual elements in the range, you can use to convert the range to a list: Inspecting shows that it contains the numbers zero, one, two, three, and four. Five itself is not a part of the range. One nice property of these ranges is that the argument, in this case, is the same as the number of elements in the range. You can call with two arguments. The first value will be the start of the range. As before, the range will count up to, but not include, the second value: The representation of a range object just shows you the arguments that you provided, so it’s not super helpful in this case. You can use to inspect the individual elements: Observe that starts at one and includes the consecutive numbers up to six. Seven is the limit of the range and isn’t included. You can calculate the number of elements in a range by subtracting the start value from the end value. In this example, there are 7 - 1 = 6 elements. Count From Start to Stop While Stepping Over Numbers The final way to construct a is by providing a third argument that specifies the step between elements in the range. By default, the step is one, but you can pass any non-zero integer. For example, you can represent all odd numbers below twenty as follows: Here, you specify that you want a range of numbers from one to twenty that are two apart. Have a look at the numbers that are part of this range: You can confirm that the range contains all odd numbers below twenty. The difference between consecutive elements in the range is two, which is equal to the step value that you provided as the third argument. In these examples, you’ve gotten started using ranges in Python. In the rest of the tutorial, you’ll learn more about how works under the hood, and you’ll see several examples of when you’d want to use objects in your own code.\n\nYou’ve seen the syntax of and how you use one, two, or three arguments to specify different kinds of ranges. In this section, you’ll dig deeper into Python’s function and see how to represent specific ranges. Note: Technically, is not a function. Instead, is a type or class. When you call , you’re calling the constructor of the class to create a new range object. Still, for all practical purposes, you can treat as a function that returns a object. First, note that a range is a lazy sequence. This means that Python doesn’t create the individual elements of a range when you create the range. Instead, it creates each element when you ask for it, for example by iterating over the range. This is different from, say, a list. Lists are eagerly constructed, so that all elements in the list are present in memory immediately when the list is created. That’s why you converted ranges into lists to inspect the individual elements earlier: The object is lazy. In this example, the individual numbers in the range are first referenced when you convert it to a list. Additionally, you don’t exhaust ranges when you iterate over them. You can reuse them as many times as you want. One property of ranges that may seem unintuitive is that the start value of the range is included, but the end value isn’t. Python ranges represent half-open intervals, to use a technical term. Closed intervals, which include both the start and end values, are more common in daily use. For example, a regular dice has values from one to six. However, using half-open intervals in programming has several advantages,which Edsger W. Dijkstra outlines as follows:\n• If the start value isn’t included in the range, then you’d need to use to specify a range running from zero.\n• If the end value is included in the range, then it’s awkward to define an empty range.\n• If the range is defined as a half-open interval, then it’s straightforward to calculate the number of elements in the range. You’ve already seen a few examples of the latter point. Recall that contains six elements which you calculate as 7 - 1 = 6. Next, you’ll explore how to create special kinds of ranges. Probably, most of the ranges that you’ll construct will consist of positive numbers. If you only provide one argument when you create a range, then, as you’ve learned, the range counts from zero and up. However, nothing’s stopping you from using negative numbers in your ranges. For example, you can create the numbers from negative ten to zero: Using negative numbers as arguments works similarly to positive numbers. The first element in the range is the start, while the second one is the end, as usual. You can use negative values for both arguments. Here are the numbers from negative seven to negative three: As always, the end value isn’t included in the range. You can still calculate the number of elements by looking at the difference of the arguments. Just keep track of the negative signs: (-3) - (-7) = 4. You can use any integer as a value for the first two arguments. However, many choices will lead to empty ranges. In particular, if the arguments are equal, then you know that the corresponding range will have zero elements. In other words, it’ll be empty: Here, you construct a range starting at . Since is also the end of the range, it’s not included, so the range is empty. In general, an empty range isn’t particularly useful. You probably won’t create an empty range explicitly. However, if you’re working with ranges with dynamic arguments, then some of those arguments may lead to an empty range. As you’ve learned, there are many ways you can create an empty range. If you need to create one explicitly, then the clearest is probably one counting from zero to zero: You confirm that represents an empty range. If your first argument is larger than the second one, then you’ll typically end up with an empty range as well: Here, you’ve constructed a range that runs from four and up to two. Since four is larger than two, there are no numbers in that range. Sometimes, you want to count down from a larger number. That’s what you’ll explore next. So far, you’ve looked at ranges with positive steps. By default, ranges use a step equal to one, but you can use any integer except zero. The following range contains all even numbers from twenty and down to zero: By using a negative step, the range counts down from start to stop. As always, the stop isn’t included. Just as most positive ranges use the default step of one, a step value of negative one is common when counting backward: This range represents counting down from five to zero, inclusive. If you use a negative step, then the range will be empty if the second argument is larger than or equal to the first. You’ve seen that you can use any integer value for the arguments, although the last one can’t be zero. In the next section, you’ll look into some practical use cases where you can loop through a range, as well as situations in which an alternative may be more appropriate.\n\nLoop Through Ranges or Use an Alternative In Python, you can create loops using two different constructs:\n• A loop, or an indefinite loop, repeats an operation until a condition is fulfilled.\n• A loop, or a definite loop, repeats an operation for each element in an existing sequence. Since a range is a sequence, you typically use loops to iterate over ranges. In many languages, including C++, Java, and JavaScript, loops are mainly based on indices. Python loops are different. In Python, a loop is based on sequence elements instead of indices. If you’re more familiar with a different language, you may need to adjust how you approach loops. In particular, if you want to re-create an index-based loop, then you may be tempted to use a range: You loop over indices and use each index to pick out the corresponding letter from the word . This approach works, but it’s usually not the best way to work with loops in Python. In fact, if you’re treating a range as indices in Python, then you should look for an alternative. There are better ways, which you’ll explore in the upcoming sections. But first, you’ll study a situation in which is the right tool for the job. If you need to repeat an operation a fixed number of times, then using a range is often a good solution. You know that is a sequence that contains elements, so looping over such a range will repeat an operation times. For example, the following code block repeats the calls three times: In this code, you repeat the indented block for each element in the range. Because the elements of the range themselves are unimportant, you use the underscore ( ) as a throwaway variable. There are also times when you work with genuine ranges of numbers, and you want to create loops over those ranges. In the next example, you’ll create a multiplication table that shows the products of all combinations of integers up to ten: You create two loops that together will set up the two-dimensional multiplication table. First, you loop over the numbers from one up to and including ten. These will represent the rows in the table, and you can see those numbers at the beginning of each row. You use the second loop to populate each column of a given row. In this range, you use the arguments to calculate times each integer from one to ten. In particular, the last step argument makes sure that numbers in each row are correctly spaced out. To format the table, you use an f-string and the parameter of , which keeps each number on the same line. In this example, you’re working directly with the range of numbers, and it makes sense to use the range in a loop. Loop Directly Over the Iterator Instead Earlier, you used a range to construct the indices of a string. A small variation of that example gives you the individual characters of the string: In most loops, the index isn’t necessary at all. If you’re interested in the characters of a string, then you can take advantage of the string already being iterable. This means that you can loop directly on the string itself: Looping directly on a sequence, like you do here, is simpler and more readable than using indices. If you have a loop where you’re using indices to find individual elements, then you should loop directly on the elements instead. Use to Create Indices Instead Sometimes, you want to work with both indices and the corresponding elements. In the earlier example, you showed the index of each character in a word: For use cases like these, you can use to create indices instead of . With , you wrap an iterable and get access to both the index and the element for each item: With , you generate an index for each element. You can also customize the counter by passing the argument to . Then, the index will begin counting at instead of zero, which is the default. For example, you can start counting letters at index one: Now the first letter is labeled by instead of . The following example is a bit more involved. You have a grid representing a treasure map. The treasures are marked by . The center of the map is at the coordinates (0, 0), and it’s marked by . You can use to find the coordinates of the treasures as follows: You first loop over each line in the grid, using to access the row coordinates. By setting , you ensure that the middle row is labeled with index . In this example, the first row gets row coordinate . Similarly, you loop over each character of each row. Now, you start counting at , which in this example is . According to your program, one treasure is at which translates to one row above the center, three columns to the right of the center. The other treasures are at and . If you need to access both an element and its corresponding index, then you should use . Use for Parallel Iteration Instead If you need to loop over several sequences at the same time, then you can use indices to find elements corresponding to each other: The capital of Norway is Oslo The capital of Canada is Ottawa The capital of Burkina Faso is Ouagadougou Here, you use indices to look up corresponding elements in and . You’re using to construct the indices. As mentioned earlier, there are better approaches in Python than working directly with indices. If you want to loop over several iterables in parallel, then you should use . With , you can rewrite the previous example as follows: The capital of Norway is Oslo The capital of Canada is Ottawa The capital of Burkina Faso is Ouagadougou Note that generates a tuple that you can unpack to one loop variable for each sequence that you loop over. The code inside the loop becomes simpler and more readable when you don’t need to deal with indices. If you need to loop over two or more iterables at the same time, then you should use .\n\nExplore Other Features and Uses of Ranges By now, you know how to construct ranges in Python and how you can loop over them. You’ve even seen some alternatives to using in specific use cases. In this section, you’ll take a closer look at the object and learn which operations it supports. You’ll learn that a range has many attributes and methods in common with tuples and lists, even though the range is lazy. You can use Python’s square bracket notation to pick out a single element from a range: You first construct a range that contains the odd numbers below twenty. Then you pick out the number at index three. Since Python sequences are zero-indexed, this is the fourth odd number, namely seven. Finally, you pick out the second number from the end, which is seventeen. In addition to picking out single elements from a range, you can use slices to create new ranges. A slice can grab one or several elements from a sequence, and the operation uses similar parameters to . In slice syntax, you use a colon ( ) to separate arguments. Additionally, numbers specify start, stop, and optionally a step for the slice. A slice like starts from index and runs up to, but not including, index . You can add a step at the end, so will also run from index to but only include every second index. If you apply a slice to a range, then you get a new range that will contain some or all of the elements of the original range: Again, you start with the odd numbers below twenty. Taking the slice gives you a new range containing the odd numbers from three to nine, inclusive. If you add a step to your slice, then the step in the resulting range changes correspondingly. Check Whether a Number Is a Member of a Range Membership tests in ranges are fast. Sometimes you can check if a value is a member of a range instead of doing other kinds of validations. For example, you can check if is a leap year in the twenty-first century as follows: The leap years are every four years, so you check if is in the range starting at 2000 and including every fourth year up to 2100. Note: In general, leap year calculations are slightly more complicated. A leap year is a year that’s a multiple of four, except for years evenly divisible by 100, but not by 400. In practice, those exceptions mean that 1900 and 2100 aren’t leap years, but 2000 is a leap year. You can always replace the range membership test with an equivalent logical condition: You use the modulus operator ( ) to check that the year is divisible by four. In some cases, using is more readable than spelling out the corresponding equation. One subtle detail with range membership tests is that all members of ranges are integers. This means that numbers with a decimal part are never range members: Here, you check if is part of the integer range starting at one and counting up to ten. While four is in the range, the decimal number is not. To get the same result with a logical test, you must remember to check that the number is divisible by one as well: You can use the modulo operator with the step value of the range to ensure that the number in question is consistent with the step. In general, if the start value isn’t divisible by the step value, then you should subtract the start value from before applying the modulo operator. Calculate the Number of Elements in a Range You’ve learned that for single-step ranges, you can calculate the number of elements in the range by taking the difference between the first two arguments. If the step is different from one, then the calculation is slightly more complicated. You need to do ceiling division with the step size: In this example, you calculate that there are ten odd numbers below twenty. However, for objects, you shouldn’t do this calculation yourself. Instead, you should use to calculate the number of elements: As above, you confirm that there are ten odd numbers below twenty. You can use with all ranges, including empty ones: Earlier, you saw that an empty range has no elements. Consistently, confirms that its length is zero. If you need to loop over a range in reverse, you can use . This function knows how to reverse many iterables, including ranges: Again, you use the odd numbers below twenty to explore. Calling creates a object that you can use in your loops. Listing the elements shows that the range has been reversed, with the odd numbers now appearing in descending order. Unfortunately, isn’t a full object, and it doesn’t support many of the features that you’ve learned about lately. For example, you can’t slice it or ask for its length: : : object of type 'range_iterator' has no len() In practice, this is rarely a problem. For example, the reversed range has the same number of elements as the original range. If you need a reversed range that retains all of its powers, you can construct it manually by calculating new arguments to pass to . As long as is one or negative one, it’s straightforward to reverse a range: You first create a function that can reverse a given range. One neat feature of ranges is that you can access the arguments used to create the range using the attributes , , and . To reverse a range, you use for the first argument and for the second. Additionally, you reverse the sign of . To account for the end value not being included in the range, you need to adjust the first two arguments by subtracting . To test , you first reverse the range that counts down from five to one, inclusive. This gives you a range that counts up from one to five, inclusive, just as it should. A good test of any function that reverses a sequence is to apply it twice. This should always bring back the original sequence. In this case, you confirm that applying twice returns the original range. This function doesn’t work if the step is different from either one or negative one. In such ranges, it’s harder to calculate the new start value because it depends on the last element of the range. For example, the last element of is seventeen. It’s not immediately clear how that’s related to the original arguments. Note: You can find a more complicated version of in the supporting materials, that can handle any step size. To take different step sizes into account, you can reverse the range with a slice instead: For these examples, you consider the range consisting of every fourth number from one up to, but not including, twenty. Since seventeen is the last number in the range, the reversed range starts from seventeen and counts down. Note that applying twice brings back the original range. Even though the stop values are different, the elements of and are the same. In general, you should just use to reverse a range. If you need any special properties of the reversed object, then you can use or a similar calculation instead. So far, you’ve used integers when setting up ranges. You can also use integer-like numbers like binary numbers or hexadecimal numbers instead: Here, is the binary representation of , while is the hexadecimal representation of . It turns out that you can create ranges from self-defined integer-like numbers as well. To be integer-like, your class needs to define the special method to convert your integer-like number into a regular integer. For example, consider the special numbers called π-digits. These are all made up of the digits of the constant π, which is approximately 3.1415926. The first π-digit is 3, the next is 31, the third is 314, and so on. You’ll create to represent such π-digits: Store this class in a file named . You can then import it and play with it: You first create the third π-digit, 314. Because you implemented , you can convert to a regular integer with and use it directly as an argument to . You can use π-digits for all arguments in : The last length calculation confirms that the resulting range contains millions of numbers, as expected. Even though you have some flexibility in providing arguments to , they all need to be integer-like. If you need more flexibility, like creating floating-point number ranges, then you have a few options. You can create a custom class. An example of this is provided in the downloadable materials. If you use NumPy in your project, then you should use its function instead."
    },
    {
        "link": "https://stackoverflow.com/questions/58776293/what-is-the-most-efficient-way-of-checking-if-value-exists-in-a-range-of-start-a",
        "document": "Lets say I have a text file that has start and end positions like this:\n\nI want to check if a given set of values exists in between and including those positions, e.g. 4,14,20 would return TRUE,TRUE,FALSE.\n\nWhat would be the most efficient way of doing so?\n\nIdea 1) I could generate each possible number into a list and check if value is in list - pseudo code would look like this:\n\nIdea 2) Instead of saving each possible position into the list, save only the start and end but then iterate through each range when checking:\n\nIf my file is very large I suspect idea 1 would take up a lot of memory, but on the other hand would idea 2 take much longer to run as it has to iterate through so much more?\n\nOr is there some completely different way that is better? Many thanks!"
    },
    {
        "link": "https://geeksforgeeks.org/python-range-function",
        "document": "The Python range() function returns a sequence of numbers, in a given range. The most common use of it is to iterate sequences on a sequence of numbers using Python loops.\n\nIn the given example, we are printing the number from 0 to 4.\n\nWhat is the use of the range function in Python\n\nIn simple terms, range() allows the user to generate a series of numbers within a given range. Depending on how many arguments the user is passing to the function, the user can decide where that series of numbers will begin and end, as well as how big the difference will be between one number and the next. Python range() function takes can be initialized in 3 ways.\n\nWhen the user call range() with one argument, the user will get a series of numbers that starts at 0 and includes every whole number up to, but not including, the number that the user has provided as the stop.\n\nIn this example, we are printing the number from 0 to 5. We are using the range function in which we are passing the stopping of the loop.\n\nWhen the user call range() with two arguments, the user gets to decide not only where the series of numbers stops but also where it starts, so the user doesn’t have to start at 0 all the time. Users can use range() to generate a series of numbers from X to Y using range(X, Y).\n\nIn this example, we are printing the number from 5 to 19. We are using the range function in which we are passing the starting and stopping points of the loop.\n\nWhen the user call range() with three arguments, the user can choose not only where the series of numbers will start and stop, but also how big the difference will be between one number and the next. If the user doesn’t provide a step, then range() will automatically behave as if the step is 1. In this example, we are printing even numbers between 0 and 10, so we choose our starting point from 0(start = 0) and stop the series at 10(stop = 10). For printing an even number the difference between one number and the next must be 2 (step = 2) after providing a step we get the following output (0, 2, 4, 8).\n\nIn this example, we are printing the number from 0 to 9 with the jump of 2. We are using the range function in which we are passing the starting and stopping points with the jump of the iterator.\n\nIf a user wants to increment, then the user needs steps to be a positive number.\n\nIf a user wants to decrement, then the user needs steps to be a negative number.\n\nPython range() function doesn’t support float numbers. i.e. user cannot use floating-point or non-integer numbers in any of its arguments. Users can use only integer numbers.\n\nConcatenation of two range() functions using itertools chain() method\n\nThe result from two range() functions can be concatenated by using the chain() method of itertools module. The chain() method is used to print all the values in iterable targets one after another mentioned in its arguments.\n\nAccessing range() with an Index Value\n\nA sequence of numbers is returned by the range() function as its object that can be accessed by its index value. Both positive and negative indexing is supported by its object.\n\nIn this example, we are creating a list and we are printing list elements with the range() in Python.\n\nSome Important points to remember about the Python range() function\n• None The range() function only works with integers, i.e. whole numbers.\n• None All arguments must be integers. Users can not pass a string or float number or any other type in a start stop, step\n• None All three arguments can be positive or negative.\n• step value must not be zero. If a step is zero, python raises a ValueError exception.\n• None Users can access items in a range() by index, just as users do with a list.\n\nWhat Does the\n\nHow to Create a Sequence of Numbers with\n\nWhat Are the Parameters of the\n\nHow to Use a Negative Step in the\n\nHow to Generate a List Using"
    },
    {
        "link": "https://datacamp.com/tutorial/python-range-function",
        "document": "Learn the art of writing your own functions in Python, as well as key concepts like scoping and error handling."
    },
    {
        "link": "https://docs.python.org/3/tutorial/datastructures.html",
        "document": "This chapter describes some things you’ve learned about already in more detail, and adds some new things as well.\n\nThe list data type has some more methods. Here are all of the methods of list objects: Add an item to the end of the list. Similar to . Extend the list by appending all the items from the iterable. Similar to . Insert an item at a given position. The first argument is the index of the element before which to insert, so inserts at the front of the list, and is equivalent to . Remove the first item from the list whose value is equal to x. It raises a if there is no such item. Remove the item at the given position in the list, and return it. If no index is specified, removes and returns the last item in the list. It raises an if the list is empty or the index is outside the list range. Remove all items from the list. Similar to . Return zero-based index in the list of the first item whose value is equal to x. Raises a if there is no such item. The optional arguments start and end are interpreted as in the slice notation and are used to limit the search to a particular subsequence of the list. The returned index is computed relative to the beginning of the full sequence rather than the start argument. Return the number of times x appears in the list. Sort the items of the list in place (the arguments can be used for sort customization, see for their explanation). Reverse the elements of the list in place. Return a shallow copy of the list. Similar to . An example that uses most of the list methods: You might have noticed that methods like , or that only modify the list have no return value printed – they return the default . This is a design principle for all mutable data structures in Python. Another thing you might notice is that not all data can be sorted or compared. For instance, doesn’t sort because integers can’t be compared to strings and can’t be compared to other types. Also, there are some types that don’t have a defined ordering relation. For example, isn’t a valid comparison. The list methods make it very easy to use a list as a stack, where the last element added is the first element retrieved (“last-in, first-out”). To add an item to the top of the stack, use . To retrieve an item from the top of the stack, use without an explicit index. For example: It is also possible to use a list as a queue, where the first element added is the first element retrieved (“first-in, first-out”); however, lists are not efficient for this purpose. While appends and pops from the end of list are fast, doing inserts or pops from the beginning of a list is slow (because all of the other elements have to be shifted by one). To implement a queue, use which was designed to have fast appends and pops from both ends. For example: # The first to arrive now leaves # The second to arrive now leaves List comprehensions provide a concise way to create lists. Common applications are to make new lists where each element is the result of some operations applied to each member of another sequence or iterable, or to create a subsequence of those elements that satisfy a certain condition. For example, assume we want to create a list of squares, like: Note that this creates (or overwrites) a variable named that still exists after the loop completes. We can calculate the list of squares without any side effects using: which is more concise and readable. A list comprehension consists of brackets containing an expression followed by a clause, then zero or more or clauses. The result will be a new list resulting from evaluating the expression in the context of the and clauses which follow it. For example, this listcomp combines the elements of two lists if they are not equal: Note how the order of the and statements is the same in both these snippets. If the expression is a tuple (e.g. the in the previous example), it must be parenthesized. # create a new list with the values doubled # apply a function to all the elements # the tuple must be parenthesized, otherwise an error is raised File , line : did you forget parentheses around the comprehension target? # flatten a list using a listcomp with two 'for' List comprehensions can contain complex expressions and nested functions: The initial expression in a list comprehension can be any arbitrary expression, including another list comprehension. Consider the following example of a 3x4 matrix implemented as a list of 3 lists of length 4: The following list comprehension will transpose rows and columns: As we saw in the previous section, the inner list comprehension is evaluated in the context of the that follows it, so this example is equivalent to: which, in turn, is the same as: # the following 3 lines implement the nested listcomp In the real world, you should prefer built-in functions to complex flow statements. The function would do a great job for this use case: See Unpacking Argument Lists for details on the asterisk in this line.\n\nWe saw that lists and strings have many common properties, such as indexing and slicing operations. They are two examples of sequence data types (see Sequence Types — list, tuple, range). Since Python is an evolving language, other sequence data types may be added. There is also another standard sequence data type: the tuple. A tuple consists of a number of values separated by commas, for instance: File , line , in : # but they can contain mutable objects: As you see, on output tuples are always enclosed in parentheses, so that nested tuples are interpreted correctly; they may be input with or without surrounding parentheses, although often parentheses are necessary anyway (if the tuple is part of a larger expression). It is not possible to assign to the individual items of a tuple, however it is possible to create tuples which contain mutable objects, such as lists. Though tuples may seem similar to lists, they are often used in different situations and for different purposes. Tuples are immutable, and usually contain a heterogeneous sequence of elements that are accessed via unpacking (see later in this section) or indexing (or even by attribute in the case of ). Lists are mutable, and their elements are usually homogeneous and are accessed by iterating over the list. A special problem is the construction of tuples containing 0 or 1 items: the syntax has some extra quirks to accommodate these. Empty tuples are constructed by an empty pair of parentheses; a tuple with one item is constructed by following a value with a comma (it is not sufficient to enclose a single value in parentheses). Ugly, but effective. For example: The statement is an example of tuple packing: the values , and are packed together in a tuple. The reverse operation is also possible: This is called, appropriately enough, sequence unpacking and works for any sequence on the right-hand side. Sequence unpacking requires that there are as many variables on the left side of the equals sign as there are elements in the sequence. Note that multiple assignment is really just a combination of tuple packing and sequence unpacking.\n\nPython also includes a data type for sets. A set is an unordered collection with no duplicate elements. Basic uses include membership testing and eliminating duplicate entries. Set objects also support mathematical operations like union, intersection, difference, and symmetric difference. Curly braces or the function can be used to create sets. Note: to create an empty set you have to use , not ; the latter creates an empty dictionary, a data structure that we discuss in the next section. Here is a brief demonstration: # show that duplicates have been removed # Demonstrate set operations on unique letters from two words # letters in a but not in b # letters in a or b or both # letters in both a and b # letters in a or b but not both Similarly to list comprehensions, set comprehensions are also supported:\n\nAnother useful data type built into Python is the dictionary (see Mapping Types — dict). Dictionaries are sometimes found in other languages as “associative memories” or “associative arrays”. Unlike sequences, which are indexed by a range of numbers, dictionaries are indexed by keys, which can be any immutable type; strings and numbers can always be keys. Tuples can be used as keys if they contain only strings, numbers, or tuples; if a tuple contains any mutable object either directly or indirectly, it cannot be used as a key. You can’t use lists as keys, since lists can be modified in place using index assignments, slice assignments, or methods like and . It is best to think of a dictionary as a set of key: value pairs, with the requirement that the keys are unique (within one dictionary). A pair of braces creates an empty dictionary: . Placing a comma-separated list of key:value pairs within the braces adds initial key:value pairs to the dictionary; this is also the way dictionaries are written on output. The main operations on a dictionary are storing a value with some key and extracting the value given the key. It is also possible to delete a key:value pair with . If you store using a key that is already in use, the old value associated with that key is forgotten. It is an error to extract a value using a non-existent key. Performing on a dictionary returns a list of all the keys used in the dictionary, in insertion order (if you want it sorted, just use instead). To check whether a single key is in the dictionary, use the keyword. Here is a small example using a dictionary: The constructor builds dictionaries directly from sequences of key-value pairs: In addition, dict comprehensions can be used to create dictionaries from arbitrary key and value expressions: When the keys are simple strings, it is sometimes easier to specify pairs using keyword arguments:\n\nWhen looping through dictionaries, the key and corresponding value can be retrieved at the same time using the method. When looping through a sequence, the position index and corresponding value can be retrieved at the same time using the function. To loop over two or more sequences at the same time, the entries can be paired with the function. What is your name? It is lancelot. What is your quest? It is the holy grail. What is your favorite color? It is blue. To loop over a sequence in reverse, first specify the sequence in a forward direction and then call the function. To loop over a sequence in sorted order, use the function which returns a new sorted list while leaving the source unaltered. Using on a sequence eliminates duplicate elements. The use of in combination with over a sequence is an idiomatic way to loop over unique elements of the sequence in sorted order. It is sometimes tempting to change a list while you are looping over it; however, it is often simpler and safer to create a new list instead.\n\nThe conditions used in and statements can contain any operators, not just comparisons. The comparison operators and are membership tests that determine whether a value is in (or not in) a container. The operators and compare whether two objects are really the same object. All comparison operators have the same priority, which is lower than that of all numerical operators. Comparisons can be chained. For example, tests whether is less than and moreover equals . Comparisons may be combined using the Boolean operators and , and the outcome of a comparison (or of any other Boolean expression) may be negated with . These have lower priorities than comparison operators; between them, has the highest priority and the lowest, so that A and not B or C is equivalent to (A and (not B)) or C . As always, parentheses can be used to express the desired composition. The Boolean operators and are so-called short-circuit operators: their arguments are evaluated from left to right, and evaluation stops as soon as the outcome is determined. For example, if and are true but is false, A and B and C does not evaluate the expression . When used as a general value and not as a Boolean, the return value of a short-circuit operator is the last evaluated argument. It is possible to assign the result of a comparison or other Boolean expression to a variable. For example, Note that in Python, unlike C, assignment inside expressions must be done explicitly with the walrus operator . This avoids a common class of problems encountered in C programs: typing in an expression when was intended.\n\nSequence objects typically may be compared to other objects with the same sequence type. The comparison uses lexicographical ordering: first the first two items are compared, and if they differ this determines the outcome of the comparison; if they are equal, the next two items are compared, and so on, until either sequence is exhausted. If two items to be compared are themselves sequences of the same type, the lexicographical comparison is carried out recursively. If all items of two sequences compare equal, the sequences are considered equal. If one sequence is an initial sub-sequence of the other, the shorter sequence is the smaller (lesser) one. Lexicographical ordering for strings uses the Unicode code point number to order individual characters. Some examples of comparisons between sequences of the same type: Note that comparing objects of different types with or is legal provided that the objects have appropriate comparison methods. For example, mixed numeric types are compared according to their numeric value, so 0 equals 0.0, etc. Otherwise, rather than providing an arbitrary ordering, the interpreter will raise a exception."
    },
    {
        "link": "https://docs.python.org/3/library/functions.html",
        "document": "The Python interpreter has a number of functions and types built into it that are always available. They are listed here in alphabetical order.\n\nOpen file and return a corresponding file object. If the file cannot be opened, an is raised. See Reading and Writing Files for more examples of how to use this function. file is a path-like object giving the pathname (absolute or relative to the current working directory) of the file to be opened or an integer file descriptor of the file to be wrapped. (If a file descriptor is given, it is closed when the returned I/O object is closed unless closefd is set to .) mode is an optional string that specifies the mode in which the file is opened. It defaults to which means open for reading in text mode. Other common values are for writing (truncating the file if it already exists), for exclusive creation, and for appending (which on some Unix systems, means that all writes append to the end of the file regardless of the current seek position). In text mode, if encoding is not specified the encoding used is platform-dependent: is called to get the current locale encoding. (For reading and writing raw bytes use binary mode and leave encoding unspecified.) The available modes are: open for writing, truncating the file first open for exclusive creation, failing if the file already exists open for writing, appending to the end of file if it exists The default mode is (open for reading text, a synonym of ). Modes and open and truncate the file. Modes and open the file with no truncation. As mentioned in the Overview, Python distinguishes between binary and text I/O. Files opened in binary mode (including in the mode argument) return contents as objects without any decoding. In text mode (the default, or when is included in the mode argument), the contents of the file are returned as , the bytes having been first decoded using a platform-dependent encoding or using the specified encoding if given. Python doesn’t depend on the underlying operating system’s notion of text files; all the processing is done by Python itself, and is therefore platform-independent. buffering is an optional integer used to set the buffering policy. Pass 0 to switch buffering off (only allowed in binary mode), 1 to select line buffering (only usable when writing in text mode), and an integer > 1 to indicate the size in bytes of a fixed-size chunk buffer. Note that specifying a buffer size this way applies for binary buffered I/O, but (i.e., files opened with ) would have another buffering. To disable buffering in , consider using the flag for . When no buffering argument is given, the default buffering policy works as follows:\n• None Binary files are buffered in fixed-size chunks; the size of the buffer is chosen using a heuristic trying to determine the underlying device’s “block size” and falling back on . On many systems, the buffer will typically be 4096 or 8192 bytes long.\n• None “Interactive” text files (files for which returns ) use line buffering. Other text files use the policy described above for binary files. encoding is the name of the encoding used to decode or encode the file. This should only be used in text mode. The default encoding is platform dependent (whatever returns), but any text encoding supported by Python can be used. See the module for the list of supported encodings. errors is an optional string that specifies how encoding and decoding errors are to be handled—this cannot be used in binary mode. A variety of standard error handlers are available (listed under Error Handlers), though any error handling name that has been registered with is also valid. The standard names include:\n• None to raise a exception if there is an encoding error. The default value of has the same effect.\n• None ignores errors. Note that ignoring encoding errors can lead to data loss.\n• None causes a replacement marker (such as ) to be inserted where there is malformed data.\n• None will represent any incorrect bytes as low surrogate code units ranging from U+DC80 to U+DCFF. These surrogate code units will then be turned back into the same bytes when the error handler is used when writing data. This is useful for processing files in an unknown encoding.\n• None is only supported when writing to a file. Characters not supported by the encoding are replaced with the appropriate XML character reference .\n• None (also only supported when writing) replaces unsupported characters with escape sequences. newline determines how to parse newline characters from the stream. It can be , , , , and . It works as follows:\n• None When reading input from the stream, if newline is , universal newlines mode is enabled. Lines in the input can end in , , or , and these are translated into before being returned to the caller. If it is , universal newlines mode is enabled, but line endings are returned to the caller untranslated. If it has any of the other legal values, input lines are only terminated by the given string, and the line ending is returned to the caller untranslated.\n• None When writing output to the stream, if newline is , any characters written are translated to the system default line separator, . If newline is or , no translation takes place. If newline is any of the other legal values, any characters written are translated to the given string. If closefd is and a file descriptor rather than a filename was given, the underlying file descriptor will be kept open when the file is closed. If a filename is given closefd must be (the default); otherwise, an error will be raised. A custom opener can be used by passing a callable as opener. The underlying file descriptor for the file object is then obtained by calling opener with (file, flags). opener must return an open file descriptor (passing as opener results in functionality similar to passing ). The following example uses the dir_fd parameter of the function to open a file relative to a given directory: 'This will be written to somedir/spamspam.txt' The type of file object returned by the function depends on the mode. When is used to open a file in a text mode ( , , , , etc.), it returns a subclass of (specifically ). When used to open a file in a binary mode with buffering, the returned class is a subclass of . The exact class varies: in read binary mode, it returns an ; in write binary and append binary modes, it returns an , and in read/write mode, it returns an . When buffering is disabled, the raw stream, a subclass of , , is returned. See also the file handling modules, such as , (where is declared), , , , and . The and arguments may have been modified or inferred from the original call.\n• None used to be raised, it is now an alias of .\n• None is now raised if the file opened in exclusive creation mode ( ) already exists.\n• None The file is now non-inheritable.\n• None If the system call is interrupted and the signal handler does not raise an exception, the function now retries the system call instead of raising an exception (see PEP 475 for the rationale).\n• None On Windows, opening a console buffer may return a subclass of other than . Changed in version 3.11: The mode has been removed.\n\nReturn a proxy object that delegates method calls to a parent or sibling class of type. This is useful for accessing inherited methods that have been overridden in a class. The object_or_type determines the method resolution order to be searched. The search starts from the class right after the type. For example, if of object_or_type is and the value of type is , then searches . The attribute of the class corresponding to object_or_type lists the method resolution search order used by both and . The attribute is dynamic and can change whenever the inheritance hierarchy is updated. If the second argument is omitted, the super object returned is unbound. If the second argument is an object, must be true. If the second argument is a type, must be true (this is useful for classmethods). When called directly within an ordinary method of a class, both arguments may be omitted (“zero-argument ”). In this case, type will be the enclosing class, and obj will be the first argument of the immediately enclosing function (typically ). (This means that zero-argument will not work as expected within nested functions, including generator expressions, which implicitly create nested functions.) There are two typical use cases for super. In a class hierarchy with single inheritance, super can be used to refer to parent classes without naming them explicitly, thus making the code more maintainable. This use closely parallels the use of super in other programming languages. The second use case is to support cooperative multiple inheritance in a dynamic execution environment. This use case is unique to Python and is not found in statically compiled languages or languages that only support single inheritance. This makes it possible to implement “diamond diagrams” where multiple base classes implement the same method. Good design dictates that such implementations have the same calling signature in every case (because the order of calls is determined at runtime, because that order adapts to changes in the class hierarchy, and because that order can include sibling classes that are unknown prior to runtime). For both use cases, a typical superclass call looks like this: # This does the same thing as: In addition to method lookups, also works for attribute lookups. One possible use case for this is calling descriptors in a parent or sibling class. Note that is implemented as part of the binding process for explicit dotted attribute lookups such as . It does so by implementing its own method for searching classes in a predictable order that supports cooperative multiple inheritance. Accordingly, is undefined for implicit lookups using statements or operators such as . Also note that, aside from the zero argument form, is not limited to use inside methods. The two argument form specifies the arguments exactly and makes the appropriate references. The zero argument form only works inside a class definition, as the compiler fills in the necessary details to correctly retrieve the class being defined, as well as accessing the current instance for ordinary methods. For practical suggestions on how to design cooperative classes using , see guide to using super()."
    },
    {
        "link": "https://docs.python.org/3/library/stdtypes.html",
        "document": "The following sections describe the standard types that are built into the interpreter.\n\nThe principal built-in types are numerics, sequences, mappings, classes, instances and exceptions.\n\nSome collection classes are mutable. The methods that add, subtract, or rearrange their members in place, and don’t return a specific item, never return the collection instance itself but .\n\nSome operations are supported by several object types; in particular, practically all objects can be compared for equality, tested for truth value, and converted to a string (with the function or the slightly different function). The latter function is implicitly used when an object is written by the function.\n\nThere are three distinct numeric types: integers, floating-point numbers, and complex numbers. In addition, Booleans are a subtype of integers. Integers have unlimited precision. Floating-point numbers are usually implemented using double in C; information about the precision and internal representation of floating-point numbers for the machine on which your program is running is available in . Complex numbers have a real and imaginary part, which are each a floating-point number. To extract these parts from a complex number z, use and . (The standard library includes the additional numeric types , for rationals, and , for floating-point numbers with user-definable precision.) Numbers are created by numeric literals or as the result of built-in functions and operators. Unadorned integer literals (including hex, octal and binary numbers) yield integers. Numeric literals containing a decimal point or an exponent sign yield floating-point numbers. Appending or to a numeric literal yields an imaginary number (a complex number with a zero real part) which you can add to an integer or float to get a complex number with real and imaginary parts. Python fully supports mixed arithmetic: when a binary arithmetic operator has operands of different numeric types, the operand with the “narrower” type is widened to that of the other, where integer is narrower than floating point, which is narrower than complex. A comparison between numbers of different types behaves as though the exact values of those numbers were being compared. The constructors , , and can be used to produce numbers of a specific type. All numeric types (except complex) support the following operations (for priorities of the operations, see Operator precedence): absolute value or magnitude of x a complex number with real part re, imaginary part im. im defaults to zero. conjugate of the complex number c\n• None Also referred to as integer division. For operands of type , the result has type . For operands of type , the result has type . In general, the result is a whole integer, though the result’s type is not necessarily . The result is always rounded towards minus infinity: is , is , is , and is .\n• None Not for complex numbers. Instead convert to floats using if appropriate.\n• None Conversion from to truncates, discarding the fractional part. See functions and for alternative conversions.\n• None float also accepts the strings “nan” and “inf” with an optional prefix “+” or “-” for Not a Number (NaN) and positive or negative infinity.\n• None Python defines and to be , as is common for programming languages.\n• None The numeric literals accepted include the digits to or any Unicode equivalent (code points with the property). See the Unicode Standard for a complete list of code points with the property. All types ( and ) also include the following operations: x rounded to n digits, rounding half to even. If n is omitted, it defaults to 0. For additional numeric operations see the and modules. Bitwise operations only make sense for integers. The result of bitwise operations is calculated as though carried out in two’s complement with an infinite number of sign bits. The priorities of the binary bitwise operations are all lower than the numeric operations and higher than the comparisons; the unary operation has the same priority as the other unary numeric operations ( and ). This table lists the bitwise operations sorted in ascending priority: bitwise exclusive or of x and y\n• None Negative shift counts are illegal and cause a to be raised.\n• None A left shift by n bits is equivalent to multiplication by .\n• None A right shift by n bits is equivalent to floor division by .\n• None Performing these calculations with at least one extra sign extension bit in a finite two’s complement representation (a working bit-width of or more) is sufficient to get the same result as if there were an infinite number of sign bits. The int type implements the abstract base class. In addition, it provides a few more methods: Return the number of bits necessary to represent an integer in binary, excluding the sign and leading zeros: More precisely, if is nonzero, then is the unique positive integer such that . Equivalently, when is small enough to have a correctly rounded logarithm, then . If is zero, then returns . Return the number of ones in the binary representation of the absolute value of the integer. This is also known as the population count. Example: Return an array of bytes representing an integer. The integer is represented using length bytes, and defaults to 1. An is raised if the integer is not representable with the given number of bytes. The byteorder argument determines the byte order used to represent the integer, and defaults to . If byteorder is , the most significant byte is at the beginning of the byte array. If byteorder is , the most significant byte is at the end of the byte array. The signed argument determines whether two’s complement is used to represent the integer. If signed is and a negative integer is given, an is raised. The default value for signed is . The default values can be used to conveniently turn an integer into a single byte object: However, when using the default arguments, don’t try to convert a value greater than 255 or you’ll get an . \"byteorder must be either 'little' or 'big'\" Changed in version 3.11: Added default argument values for and . Return the integer represented by the given array of bytes. The argument bytes must either be a bytes-like object or an iterable producing bytes. The byteorder argument determines the byte order used to represent the integer, and defaults to . If byteorder is , the most significant byte is at the beginning of the byte array. If byteorder is , the most significant byte is at the end of the byte array. To request the native byte order of the host system, use as the byte order value. The signed argument indicates whether two’s complement is used to represent the integer. \"byteorder must be either 'little' or 'big'\" Changed in version 3.11: Added default argument value for . Return a pair of integers whose ratio is equal to the original integer and has a positive denominator. The integer ratio of integers (whole numbers) is always the integer as the numerator and as the denominator. The float type implements the abstract base class. float also has the following additional methods. Return a pair of integers whose ratio is exactly equal to the original float. The ratio is in lowest terms and has a positive denominator. Raises on infinities and a on NaNs. Return if the float instance is finite with integral value, and otherwise: Two methods support conversion to and from hexadecimal strings. Since Python’s floats are stored internally as binary numbers, converting a float to or from a decimal string usually involves a small rounding error. In contrast, hexadecimal strings allow exact representation and specification of floating-point numbers. This can be useful when debugging, and in numerical work. Return a representation of a floating-point number as a hexadecimal string. For finite floating-point numbers, this representation will always include a leading and a trailing and exponent. Class method to return the float represented by a hexadecimal string s. The string s may have leading and trailing whitespace. Note that is an instance method, while is a class method. where the optional may by either or , and are strings of hexadecimal digits, and is a decimal integer with an optional leading sign. Case is not significant, and there must be at least one hexadecimal digit in either the integer or the fraction. This syntax is similar to the syntax specified in section 6.4.4.2 of the C99 standard, and also to the syntax used in Java 1.5 onwards. In particular, the output of is usable as a hexadecimal floating-point literal in C or Java code, and hexadecimal strings produced by C’s format character or Java’s are accepted by . Note that the exponent is written in decimal rather than hexadecimal, and that it gives the power of 2 by which to multiply the coefficient. For example, the hexadecimal string represents the floating-point number , or : Applying the reverse conversion to gives a different hexadecimal string representing the same number: For numbers and , possibly of different types, it’s a requirement that whenever (see the method documentation for more details). For ease of implementation and efficiency across a variety of numeric types (including , , and ) Python’s hash for numeric types is based on a single mathematical function that’s defined for any rational number, and hence applies to all instances of and , and all finite instances of and . Essentially, this function is given by reduction modulo for a fixed prime . The value of is made available to Python as the attribute of . CPython implementation detail: Currently, the prime used is on machines with 32-bit C longs and on machines with 64-bit C longs. Here are the rules in detail:\n• None If is a nonnegative rational number and is not divisible by , define as , where gives the inverse of modulo .\n• None If is a nonnegative rational number and is divisible by (but is not) then has no inverse modulo and the rule above doesn’t apply; in this case define to be the constant value .\n• None If is a negative rational number define as . If the resulting hash is , replace it with .\n• None The particular values and are used as hash values for positive infinity or negative infinity (respectively).\n• None For a number , the hash values of the real and imaginary parts are combined by computing , reduced modulo so that it lies in . Again, if the result is , it’s replaced with . To clarify the above rules, here’s some example Python code, equivalent to the built-in hash, for computing the hash of a rational number, , or : Assumes m and n are integers, with n positive. # Remove common factors of P. (Unnecessary if m and n already coprime.) # Fermat's Little Theorem: pow(n, P-1, P) is 1, so # pow(n, P-2, P) gives the inverse of n modulo P.\n\nThere are three basic sequence types: lists, tuples, and range objects. Additional sequence types tailored for processing of binary data and text strings are described in dedicated sections. The operations in the following table are supported by most sequence types, both mutable and immutable. The ABC is provided to make it easier to correctly implement these operations on custom sequence types. This table lists the sequence operations sorted in ascending priority. In the table, s and t are sequences of the same type, n, i, j and k are integers and x is an arbitrary object that meets any type and value restrictions imposed by s. The and operations have the same priorities as the comparison operations. The (concatenation) and (repetition) operations have the same priority as the corresponding numeric operations. if an item of s is equal to x, else if an item of s is equal to x, else the concatenation of s and t equivalent to adding s to itself n times slice of s from i to j with step k index of the first occurrence of x in s (at or after index i and before index j) total number of occurrences of x in s Sequences of the same type also support comparisons. In particular, tuples and lists are compared lexicographically by comparing corresponding elements. This means that to compare equal, every element must compare equal and the two sequences must be of the same type and have the same length. (For full details see Comparisons in the language reference.) Forward and reversed iterators over mutable sequences access values using an index. That index will continue to march forward (or backward) even if the underlying sequence is mutated. The iterator terminates only when an or a is encountered (or when the index drops below zero).\n• None While the and operations are used only for simple containment testing in the general case, some specialised sequences (such as , and ) also use them for subsequence testing:\n• None Values of n less than are treated as (which yields an empty sequence of the same type as s). Note that items in the sequence s are not copied; they are referenced multiple times. This often haunts new Python programmers; consider: What has happened is that is a one-element list containing an empty list, so all three elements of are references to this single empty list. Modifying any of the elements of modifies this single list. You can create a list of different lists this way: Further explanation is available in the FAQ entry How do I create a multidimensional list?.\n• None If i or j is negative, the index is relative to the end of sequence s: or is substituted. But note that is still .\n• None The slice of s from i to j is defined as the sequence of items with index k such that . If i or j is greater than , use . If i is omitted or , use . If j is omitted or , use . If i is greater than or equal to j, the slice is empty.\n• None The slice of s from i to j with step k is defined as the sequence of items with index such that . In other words, the indices are , , , and so on, stopping when j is reached (but never including j). When k is positive, i and j are reduced to if they are greater. When k is negative, i and j are reduced to if they are greater. If i or j are omitted or , they become “end” values (which end depends on the sign of k). Note, k cannot be zero. If k is , it is treated like .\n• None Concatenating immutable sequences always results in a new object. This means that building up a sequence by repeated concatenation will have a quadratic runtime cost in the total sequence length. To get a linear runtime cost, you must switch to one of the alternatives below:\n• None if concatenating objects, you can build a list and use at the end or else write to an instance and retrieve its value when complete\n• None if concatenating objects, you can similarly use or , or you can do in-place concatenation with a object. objects are mutable and have an efficient overallocation mechanism\n• None for other types, investigate the relevant class documentation\n• None Some sequence types (such as ) only support item sequences that follow specific patterns, and hence don’t support sequence concatenation or repetition.\n• None raises when x is not found in s. Not all implementations support passing the additional arguments i and j. These arguments allow efficient searching of subsections of the sequence. Passing the extra arguments is roughly equivalent to using , only without copying any data and with the returned index being relative to the start of the sequence rather than the start of the slice. The only operation that immutable sequence types generally implement that is not also implemented by mutable sequence types is support for the built-in. This support allows immutable sequences, such as instances, to be used as keys and stored in and instances. Attempting to hash an immutable sequence that contains unhashable values will result in . The operations in the following table are defined on mutable sequence types. The ABC is provided to make it easier to correctly implement these operations on custom sequence types. In the table s is an instance of a mutable sequence type, t is any iterable object and x is an arbitrary object that meets any type and value restrictions imposed by s (for example, only accepts integers that meet the value restriction ). item i of s is replaced by x slice of s from i to j is replaced by the contents of the iterable t the elements of are replaced by those of t removes the elements of from the list appends x to the end of the sequence (same as ) removes all items from s (same as ) creates a shallow copy of s (same as ) extends s with the contents of t (for the most part the same as ) inserts x into s at the index given by i (same as ) retrieves the item at i and also removes it from s removes the first item from s where is equal to x reverses the items of s in place\n• None If k is not equal to , t must have the same length as the slice it is replacing.\n• None The optional argument i defaults to , so that by default the last item is removed and returned.\n• None raises when x is not found in s.\n• None The method modifies the sequence in place for economy of space when reversing a large sequence. To remind users that it operates by side effect, it does not return the reversed sequence.\n• None and are included for consistency with the interfaces of mutable containers that don’t support slicing operations (such as and ). is not part of the ABC, but most concrete mutable sequence classes provide it.\n• None The value n is an integer, or an object implementing . Zero and negative values of n clear the sequence. Items in the sequence are not copied; they are referenced multiple times, as explained for under Common Sequence Operations. Lists are mutable sequences, typically used to store collections of homogeneous items (where the precise degree of similarity will vary by application). Lists may be constructed in several ways:\n• None Using a pair of square brackets to denote the empty list:\n• None Using the type constructor: or The constructor builds a list whose items are the same and in the same order as iterable’s items. iterable may be either a sequence, a container that supports iteration, or an iterator object. If iterable is already a list, a copy is made and returned, similar to . For example, returns and returns . If no argument is given, the constructor creates a new empty list, . Many other operations also produce lists, including the built-in. Lists implement all of the common and mutable sequence operations. Lists also provide the following additional method: This method sorts the list in place, using only comparisons between items. Exceptions are not suppressed - if any comparison operations fail, the entire sort operation will fail (and the list will likely be left in a partially modified state). accepts two arguments that can only be passed by keyword (keyword-only arguments): key specifies a function of one argument that is used to extract a comparison key from each list element (for example, ). The key corresponding to each item in the list is calculated once and then used for the entire sorting process. The default value of means that list items are sorted directly without calculating a separate key value. The utility is available to convert a 2.x style cmp function to a key function. reverse is a boolean value. If set to , then the list elements are sorted as if each comparison were reversed. This method modifies the sequence in place for economy of space when sorting a large sequence. To remind users that it operates by side effect, it does not return the sorted sequence (use to explicitly request a new sorted list instance). The method is guaranteed to be stable. A sort is stable if it guarantees not to change the relative order of elements that compare equal — this is helpful for sorting in multiple passes (for example, sort by department, then by salary grade). For sorting examples and a brief sorting tutorial, see Sorting Techniques. CPython implementation detail: While a list is being sorted, the effect of attempting to mutate, or even inspect, the list is undefined. The C implementation of Python makes the list appear empty for the duration, and raises if it can detect that the list has been mutated during a sort. Tuples are immutable sequences, typically used to store collections of heterogeneous data (such as the 2-tuples produced by the built-in). Tuples are also used for cases where an immutable sequence of homogeneous data is needed (such as allowing storage in a or instance). Tuples may be constructed in a number of ways:\n• None Using a pair of parentheses to denote the empty tuple:\n• None Using a trailing comma for a singleton tuple: or\n• None Using the built-in: or The constructor builds a tuple whose items are the same and in the same order as iterable’s items. iterable may be either a sequence, a container that supports iteration, or an iterator object. If iterable is already a tuple, it is returned unchanged. For example, returns and returns . If no argument is given, the constructor creates a new empty tuple, . Note that it is actually the comma which makes a tuple, not the parentheses. The parentheses are optional, except in the empty tuple case, or when they are needed to avoid syntactic ambiguity. For example, is a function call with three arguments, while is a function call with a 3-tuple as the sole argument. Tuples implement all of the common sequence operations. For heterogeneous collections of data where access by name is clearer than access by index, may be a more appropriate choice than a simple tuple object. The type represents an immutable sequence of numbers and is commonly used for looping a specific number of times in loops. The arguments to the range constructor must be integers (either built-in or any object that implements the special method). If the step argument is omitted, it defaults to . If the start argument is omitted, it defaults to . If step is zero, is raised. For a positive step, the contents of a range are determined by the formula where and . For a negative step, the contents of the range are still determined by the formula , but the constraints are and . A range object will be empty if does not meet the value constraint. Ranges do support negative indices, but these are interpreted as indexing from the end of the sequence determined by the positive indices. Ranges containing absolute values larger than are permitted but some features (such as ) may raise . Ranges implement all of the common sequence operations except concatenation and repetition (due to the fact that range objects can only represent sequences that follow a strict pattern and repetition and concatenation will usually violate that pattern). The value of the start parameter (or if the parameter was not supplied) The value of the stop parameter The value of the step parameter (or if the parameter was not supplied) The advantage of the type over a regular or is that a object will always take the same (small) amount of memory, no matter the size of the range it represents (as it only stores the , and values, calculating individual items and subranges as needed). Range objects implement the ABC, and provide features such as containment tests, element index lookup, slicing and support for negative indices (see Sequence Types — list, tuple, range): Testing range objects for equality with and compares them as sequences. That is, two range objects are considered equal if they represent the same sequence of values. (Note that two range objects that compare equal might have different , and attributes, for example or .) Changed in version 3.2: Implement the Sequence ABC. Support slicing and negative indices. Test objects for membership in constant time instead of iterating through all items. Changed in version 3.3: Define ‘==’ and ‘!=’ to compare range objects based on the sequence of values they define (instead of comparing based on object identity).\n• None The linspace recipe shows how to implement a lazy version of range suitable for floating-point applications."
    },
    {
        "link": "https://datacamp.com/tutorial/python-tuples-tutorial",
        "document": "Master the basics of data analysis with Python in just four hours. This online course will introduce the Python interface and explore popular packages."
    },
    {
        "link": "https://docs.python.org/2/library/functions.html",
        "document": "The Python interpreter has a number of functions built into it that are always available. They are listed here in alphabetical order.\n\nIn addition, there are other four built-in functions that are no longer considered essential: , , , and . They are documented in the Non-essential Built-in Functions section."
    }
]