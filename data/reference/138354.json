[
    {
        "link": "https://threejs.org/docs/api/en/geometries/SphereGeometry.html",
        "document": "radius — sphere radius. Default is `1`.\n\n widthSegments — number of horizontal segments. Minimum value is `3`, and the default is `32`.\n\n heightSegments — number of vertical segments. Minimum value is `2`, and the default is `16`.\n\n phiStart — specify horizontal starting angle. Default is `0`.\n\n phiLength — specify horizontal sweep angle size. Default is Math.PI * 2.\n\n thetaStart — specify vertical starting angle. Default is `0`.\n\n thetaLength — specify vertical sweep angle size. Default is Math.PI.\n\n\n\nThe geometry is created by sweeping and calculating vertexes around the Y axis (horizontal sweep) and the Z axis (vertical sweep). Thus, incomplete spheres (akin to `'sphere slices'`) can be created through the use of different values of phiStart, phiLength, thetaStart and thetaLength, in order to define the points in which we start (or end) calculating those vertices.\n\nSee the base [page:BufferGeometry] class for common properties.\n\nAn object with a property for each of the constructor parameters. Any modification after instantiation does not change the geometry.\n\nSee the base [page:BufferGeometry] class for common methods."
    },
    {
        "link": "https://threejs.org/docs",
        "document": ""
    },
    {
        "link": "https://threejs.org/docs/index.html",
        "document": ""
    },
    {
        "link": "https://threejs.org/docs/api/en/objects/Mesh.html",
        "document": "Class representing triangular [link:https://en.wikipedia.org/wiki/Polygon_mesh polygon mesh] based objects. Also serves as a base for other classes such as [page:SkinnedMesh].\n\n[page:BufferGeometry geometry] — (optional) an instance of [page:BufferGeometry]. Default is a new [page:BufferGeometry].\n\n [page:Material material] — (optional) a single or an array of [page:Material]. Default is a new [page:MeshBasicMaterial]\n\nSee the base [page:Object3D] class for common properties.\n\nAn instance of [page:BufferGeometry] (or derived classes), defining the object's structure.\n\nRead-only flag to check if a given object is of type [name].\n\nAn instance of material derived from the [page:Material] base class or an array of materials, defining the object's appearance. Default is a [page:MeshBasicMaterial].\n\nAn array of weights typically from 0-1 that specify how much of the morph is applied. Undefined by default, but reset to a blank array by [page:Mesh.updateMorphTargets updateMorphTargets].\n\nA dictionary of morphTargets based on the morphTarget.name property. Undefined by default, but rebuilt [page:Mesh.updateMorphTargets updateMorphTargets].\n\nSee the base [page:Object3D] class for common methods.\n\nGet the local-space position of the vertex at the given index, taking into account the current animation state of both morph targets and skinning.\n\nGet intersections between a casted ray and this mesh. [page:Raycaster.intersectObject] will call this method, but the results are not ordered.\n\nUpdates the morphTargets to have no influence on the object. Resets the [page:Mesh.morphTargetInfluences morphTargetInfluences] and [page:Mesh.morphTargetDictionary morphTargetDictionary] properties."
    },
    {
        "link": "https://r3f.docs.pmnd.rs/api/objects",
        "document": "You can use three.js's entire object catalogue and all properties. When in doubt, always consult the docs.\n\n❌ You could lay out an object like this:\n\n✅ The problem is that all of these properties will always be re-created. Instead, you should define properties declaratively.\n\nIn three.js objects are classes that are instantiated. These classes can receive one-time constructor arguments ( ), and properties ( ). In React Three Fiber, constructor arguments are always passed as an array via . If args change later on, the object must naturally get reconstructed from scratch!\n\nAll properties whose underlying object has a method can directly receive the same arguments that would otherwise take. For example can take a color string, so instead of you can simply write . Some methods take multiple arguments, for instance , give it an array in that case .\n\nIf you do link up an existing object to a property, for instance a THREE.Vector3() to a position, be aware that this will end up copying the object in most cases as it calls .copy() on the target. This only applies to objects that expose both .set() and .copy() (Vectors, Eulers, Matrix, ...). If you link up an existing material or geometry on the other hand, it will overwrite, because more these objects do not have a .set() method.\n\nProperties that have a method (for instance ) can be set like so:\n\nIf you want to reach into nested attributes (for instance: ), just use dash-case.\n\nYou can put non-Object3D primitives (geometries, materials, etc) into the render tree as well. They take the same properties and constructor arguments they normally would.\n\nYou might be wondering why you would want to put something in the \"scene\" that normally would not be part of it, in a vanilla three.js app at least. For the same reason you declare any object: it becomes managed, reactive and auto-disposes. These objects are not technically part of the scene, but they \"attach\" to a parent which is.\n\nUse to bind objects to their parent. If you unmount the attached object it will be taken off its parent automatically.\n\nThe following attaches a material to the property of a mesh and a geometry to the property:\n\nYou can also deeply nest attach through piercing. The following adds a buffer-attribute to and then adds the buffer geometry to .\n\nArrays must have explicit order, for instance multi-materials:\n\nYou can use the placeholder for that. You can still give it properties or attach nodes to it. Never add the same object multiple times, this is not allowed in three.js! Primitives will not dispose of the object they carry on unmount, you are responsible for disposing of it!\n\nThe function extends React Three Fiber's catalogue of JSX elements. Components added this way can then be referenced in the scene-graph using camel casing similar to other primitives.\n\nIf you're using TypeScript, you'll also need to extend the JSX namespace.\n\nFreeing resources is a manual chore in , but React is aware of object-lifecycles, hence React Three Fiber will attempt to free resources for you by calling , if present, on all unmounted objects.\n\nIf you manage assets by yourself, globally or in a cache, this may not be what you want. You can switch it off by placing onto meshes, materials, etc, or even on parent containers like groups, it is now valid for the entire tree."
    },
    {
        "link": "https://threejs.org/examples/games_fps.html",
        "document": "Octree threejs demo - basic collisions with static triangle mesh\n\n MOUSE to look around and to throw balls\n\n WASD to move and SPACE to jump"
    },
    {
        "link": "https://stackoverflow.com/questions/77503863/collisions-three-js-octree",
        "document": "Am Tryning to make that my character dont go inside my glb model of map, I saw this : https://threejs.org/examples/#games_fps and tried using the octree but getting an error if someone can help me setup collisions and if I need to setup something in my map file."
    },
    {
        "link": "https://discourse.threejs.org/t/how-to-store-an-octree/57687",
        "document": "I’m creating a FPS (not COD but almost !), and i need to handle players collisions with the objects on the map, terrain etc…\n\nI chose to use an Octree because of the good performance it offers.\n\nIn fact, each time i open my game, i generate an octree based on the map and its childs\n\nThen i manage all the collisions with the octree and a capsule for each player which handles their position\n\nI’m checking the intersections between the capsule and the octree on each frame.\n\nEverything works great, but the problem is the time it takes to generate the octree.\n\nI have a large map (a city), and the octree’s generation takes at least 30 secs.\n\nThe map is static so it’s kind of stupid to generate it again and again, because it will always remains the same.\n\nThat’s why i was wondering if it was possible to store it somewhere.\n\nI’ve tried to store it as a JSON but it doesn’t work.\n\nAs i’m building a multiplayer game, i tried to calculate it in the back, and send it to the front with a websocket, or a basic http request, but the octree is too heavy for that.\n\nSomeone knows a way to do this operation ?"
    },
    {
        "link": "https://github.com/mrdoob/three.js/blob/dev/examples/games_fps.html",
        "document": "MOUSE to look around and to throw balls\n\n// throw the ball with more force if we hold the button longer, and if we move forward\n\n// we look for collisions in substeps to mitigate the risk of"
    },
    {
        "link": "https://stackoverflow.com/questions/35534289/three-js-collision-detection-optimization-with-raycasting",
        "document": "I'm just looking for someone to point me in the right direction. My Google-fu is failing me.\n\nI'm working on a WebGL game, and I'm using raycasting for collision detection. I'm using Clara.io to create levels. I'm using THREE.ObjectLoader() to load the scenes. What I'd like to do is split the scenes I've made into smaller parts so as to not have to do raycasting on all vertices in the level. I'd like to not have to split the level mesh into tiny pieces inside of Clara for isolated raycasting, but instead do it within the game itself.\n\nHow do I go about only doing raycasting on a small section of a mesh? Is there a tutorial that anyone knows about or an example? I've chosen to not use heightmaps or any physics libraries.\n\nThank you in advance!"
    }
]