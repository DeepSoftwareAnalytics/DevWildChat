[
    {
        "link": "https://stackoverflow.com/questions/2098276/nested-json-objects-do-i-have-to-use-arrays-for-everything",
        "document": "Is there any way to have nested objects in JSON so I don't have to make arrays out of everything? For my object to be parsed without error I seem to need a structure like this:\n\nIf I fetch this object into a variable called \"result\" I have to access the nested objects like this:\n\nThis seems clumsy and redundant to me, if possible I would prefer:\n\nBut how can I use the object keys directly when everything is an array? To my confused and uneducated mind something like this would seem more appropriate:\n\nI've probably misunderstood something fundamental here, but I cannot get the jQuery parser (nor the native FF parser used by jQuery 1.4) to accept the second style object. If anyone can enlighten me it would be gratefully appreciated!"
    },
    {
        "link": "https://stackoverflow.com/questions/10539797/complex-json-nesting-of-objects-and-arrays",
        "document": "I am having difficultly with syntax and structure of JSON objects/arrays.\n\nI want to make a nested structure of objects and arrays that would house the following info:\n\nBut I have no idea what the right way to do this should be. Should I just be making JavaScript objects? Does JSON make sense for this project?\n\nWhat is the correct syntax to set something like this up?\n\nHere is my code so far:"
    },
    {
        "link": "https://dev.to/iamcymentho/demystifying-nested-data-a-guide-to-accessing-and-processing-objects-arrays-and-json-in-javascript-34im",
        "document": "Working with nested data structures is a common task when dealing with JavaScript objects, arrays, or JSON. Whether you're retrieving data from APIs, parsing configuration files, or manipulating complex data structures, understanding how to navigate and manipulate nested data is crucial. In this comprehensive guide, we'll explore techniques and best practices for accessing and processing nested data in JavaScript. From dot notation and bracket notation to recursive functions and modern ES6 methods, we'll cover everything you need to know to confidently work with nested data in your web development projects.\n\nIntroduction to nested , , and .\n\n The importance of nested data in real-world applications.\n\nAvoiding stack overflow with iterative solutions.\n\n Exploring modern solutions using ES6 and beyond.\n\n(JavaScript Object Notation) is a widely used format for exchanging data between a server and a client, or between different parts of an application. This section covers the basics of working with JSON data.\n\nIn , you can parse data from a string into a JavaScript object using the method:\n\nConversely, you can convert a JavaScript object into a JSON string using :\n\nThis section provides real-world scenarios and code examples demonstrating how to work with nested data.\n\nParsing JSON responses from APIs that contain nested objects and arrays.\n\n Reading configuration settings from JSON files.\n\n Managing user profiles with nested attributes.\n\nUse object to simplify access to nested data.\n\n Implement error handling for unexpected data structures.\n\nBe cautious of circular references when stringifying objects to JSON.\n\n For very large JSON data, consider streaming or paginating to avoid performance issues.\n\nFor deeply nested data, recursive functions can be useful to traverse and manipulate the data.\n\nConsider using libraries like or built-in functions like reduce and map to simplify complex operations on nested data.\n\nBy following these sections and code examples, developers can gain a comprehensive understanding of how to work with nested data effectively and efficiently in JavaScript."
    },
    {
        "link": "https://jsonlint.com/mastering-json-format",
        "document": "Mastering JSON Format: Advantages, Best Practices and Comparison with Other Data Formats\n\nJSON, standing for JavaScript Object Notation, is already a big player in today's era of data interchange. I'll delve into what makes JSON so standout. It's a text-based, language-independent format that allows for the easy and structured exchange of information. Boasting simplicity and being exceptionally lightweight, JSON is king when it comes to data transfer across your favorite web applications.\n\nOne undeniable charm of JSON is its compatibility. It's like that friend we all need — flexible and gets along with everyone. Whether you're coding in Python, JavaScript, or C++, JSON functions seamlessly across these and many more languages. Importantly, its plain text nature makes it readable to both humans and machines.\n\nThe beauty of JSON lies in its structure. Information is stored in a \"key: value\" pair format, which in essence is like a collection of Lego blocks. These 'blocks' or data objects can be assembled in various ways to form meaningful data structures.\n\nAn example of a simple JSON object could be:\n\nThis structure makes JSON adaptable and extendable. You can add, modify, and delete key-value pairs without disrupting the system, offering unparalleled flexibility in data storage.\n\nIn addition to supporting these object structures, JSON also supports arrays (ordered sequence of values), which further simplifies complex data representation. For instance, if you wanted to add job details for John Doe, it’d look something like this:\n\nLeveraging the power of arrays and objects, JSON can efficiently store virtually any data structure. Indeed, it is the backbone that drives today's internet, actively shaping the ways we store, retrieve, and process data.\n\nLooking into the wonderful world of JSON, it's clear there are a multitude of benefits when using this format. Let's dive deeper into why JSON makes such a significant impact in data interchange.\n\nFirstly, simplicity and readability play a key role in JSON's popularity. The structure is easy-to-follow, mimicking a simple key-value pair that anyone, coder or not, can grasp. It's this simplicity that helps developers quickly read, write or edit the data - a feature that doesn't go unnoticed in the fast-paced world of technology.\n\nJSON also shines in its compatibility with various programming languages. Languages such as JavaScript, Python, Ruby and many others natively support JSON. What does this mean? Simply put, JSON can readily integrate with these languages without any need for additional libraries. Now that's efficient.\n\nAnother winning feature of JSON is its support for arrays and objects. This ability to handle complex data through a recognized syntax makes JSON superior in data representation to many other formats. Whether you're dealing with multi-level arrays or nested objects, JSON has you covered.\n\nOne more advantage of JSON to highlight is its lightweight nature. JSON's format, without the need for end tags or closing tags, leads to reduced data redundancy and less data overall. This means faster data transmission and smoother execution – an essential requirement in today's digital age.\n\nIn this internet era, JSON's importance in shaping how data is stored, retrieved, and processed is undeniable. From simple inventory lists to intricate game data, JSON delivers with reliability and flexibility.\n\nAs we delve further into the nitty-gritty of JSON, it's paramount we draw comparisons between JSON and other data formats. Two main competitors of JSON that come to mind are XML and CSV. Understanding where JSON stands in relation to these will help define its unique value more accurately.\n\nXML, just like JSON, is human-readable and used widely for data exchange. But where JSON really shines is in its simplicity. Rather than the verbose and complex syntax of XML that can quickly clutter your screen, JSON stays minimal and clean, something I absolutely appreciate. JSON's format is also more condense which leads to quicker data transmissions.\n\nWell, then we have CSV. While it's true that CSV files are typically smaller, they lack the depth of JSON. In a CSV, it's challenging to represent hierarchical or multi-dimensional data. JSON, on the other hand, as we discussed earlier, has robust support for arrays and objects. It's like comparing a black-and-white photo to a 3D movie; the depth that JSON provides far outshines a mere CSV's capabilities.\n\nLet's not forget one of JSON's formidable advantages - compatibility with various programming languages. XML requires parsers to be readable in different programming languages, and CSV files often need custom parsing solutions, both of which can be cumbersome for developers. With JSON, that isn't necessary - it's supported natively in many programming languages, easing integration and reducing development time.\n\nBut before we lean too far into JSON's corner, it's worth mentioning that there are scenarios where other formats may be more suitable. Binary formats like Protobuf or Avro might provide better performance for massive or complex datasets. The world of data formats isn't black and white - there are shades of grey that give room for all, each with its own use cases.\n\nMoving forward, we'll dissect how JSON is leveraged in web development, and its role in shaping APIs. By highlighting its advantages and pointing out certain usage pitfalls, this deep dive into JSON seeks to arm you with the knowledge to efficiently utilize JSON in your own projects.\n\nUnderstanding the syntax is fundamental to appreciating JSON's beauty. It's this simplicity and readability that make JSON a desirable format. JSON structures data in name-value pairs, much like a JavaScript object. Yet, it's not limited to a particular set of programming languages. Its universal syntax is what allowed me to integrate it in various environments easily.\n\nThe first thing to look at is data types that JSON supports. It can handle simple data types like strings, numbers, and Booleans – true or false. At the same time, it embraces compound types such as arrays and other JSON objects. Being adept with these data types can make the information representation more effective.\n\nLet's take a look at a JSON object:\n\nIn this JSON object, you can see different types of data. The name is a string, the age a number, isVaccinated a Boolean, and familyNames an array of strings.\n\nWhen it comes to arrays, they are enclosed in square brackets. Each value is separated by a comma. Here's an example of a JSON array:\n\nThis array represents a list of people, each person being a JSON object itself.\n\nNext, we'll discuss how the JSON format shapes the landscape of web development, and how it’s used in creating user-friendly and feature-rich APIs. For developers seeking to use JSON in their projects, gaining a good grasp of the format and its syntax will be time well spent.\n\nParsing JSON data is a crucial skill in web development, making it an area that I must delve into due to its immense importance. It's necessary to understand that the process varies depending on the programming language you're using. In this regard, let's look at parsing JSON data using two popular languages, JavaScript and Python.\n\nParsing in JavaScript is straightforward. JavaScript natively supports JSON through the JSON object. To parse JSON using JavaScript, developers use the JSON.parse() method, converting the JSON data into a JavaScript object.\n\nIn this JavaScript example, we are converting a JSON string into a JavaScript object using the JSON.parse method. The alert function then displays the name value, \"John\".\n\nParsing in Python, on the other hand, requires the python 'json' library. Developers invoke the json.loads() method to parse JSON data.\n\nIn our Python example, after importing the json module, we invoke the json.loads() function to parse the JSON data into a python dictionary. The print function then outputs the name value, which is \"John\".\n\nTake note that converting JSON data into another data structure (for instance, a Python dictionary or JavaScript object) is called deserialization. It's an essential part of using JSON format in web development, allowing you to process the data as per your needs. As you work with JSON, remember to keep the syntax rules in mind to ensure data integrity. The ease with which JSON integrates into your coding process is what makes it a front runner in data interchange formats.\n\nMoving onward, let's delve into a crucial element associated with JSON - that's right, we're talking about JSON schema validation. This integral feature of JSON ensures code standardization, guarantees the integrity of data, and promotes a smooth coding process.\n\nSo what is JSON schema validation? Essentially, it's a powerful tool that validates your JSON data and checks if it adheres to the predefined specifications. And yes, it does all of this before you import that data into your JavaScript or Python environments, saving you from potential headaches.\n\nHere's how it works. When you're transferring data between applications using JSON, the data structure should be predictable and standardized. JSON schema validation, as its name suggests, is like a blueprint or a model for your data. It outlines what your data should look like - what elements it should contain, what data types those elements should be, whether certain fields are required or optional, and even the acceptable range of values for certain elements.\n\nApplying JSON schema validation can significantly improve your overall coding experience. It enables you to catch and address inconsistencies and errors early on, reducing debugging efforts. It helps maintain consistent data structures across multiple applications, which really comes in handy for large-scale projects involving various teams.\n\nTake a look at this simple example of JSON schema:\n\nIn this example, the schema defines an object that needs to have two properties, and . should be a string, whereas should be an integer and cannot be a negative value.\n\nNow that we've understood the concept of JSON schema validation, we'll be moving onto another exciting topic- creating custom JSON schemas. This will require another deep dive and you'll need your concentration caps on for this one. So, let's proceed...\n\nBest Practices for Using JSON\n\nJSON format is intuitive and offers a lot of flexibility, but to get the most out of it, it's crucial to follow certain best practices. These practices streamline the coding process, aid readability and optimize data interchange.\n\nFirst, always keep the JSON structure clean and organized. JSON data is represented in name-value pairs, meaning proper structuring ensures data integrity. It's easy to fall prey to messy code when dealing with complex data, so I emphasize consistency and neatness.\n\nSecondly, utilize JSON schema validation to its fullest extent. As explained before, JSON schema validation ensures code standardization and aids in catching inconsistencies early. A well-implemented validation process helps maintain the robustness of data interchange.\n\nIn addition, when dealing with large strings of data, it's better to use arrays rather than multiple name-value pairs. Data arrays in JSON are simple to understand and can hold data more efficiently than multiple name-value pairs.\n\nWhen creating custom JSON schemas for complex data, remember to keep things as simple as possible. Simplicity is the key to meaningful data representation in JSON.\n\nBelow, I've compiled a basic guide to JSON best practices:\n• Maintain clean, organized structure: Do this by using consistent name-value pairs and avoid nesting data unnecessarily.\n• Use arrays for large strings of data: Arrays are easier to manage and are intuitive for other developers.\n\nThese practices don't just apply to JSON -- they're a solid foundation for any data interchange format. The true power of these principles shines through when they're used consistently throughout a project. Get into this habit, and you'll see a marked improvement in your coding efficiency. While working with JSON, you'll soon discover other practices that can boost your experience - shaping and tailoring these guidelines to your workflow is equally important.\n\nIn the next section, we'll delve into comparing JSON with other data interchange formats - looking at where JSON stands out and where it might not be the best option. That's for another discussion though, so let's place the bookmark here.\n\nSo we've seen how JSON's simplicity and readability make it a powerful tool for data interchange. Its schema validation feature is a game changer, ensuring code standardization and catching errors early. I've shared some best practices for using JSON, like maintaining a clean structure, using arrays for large data strings, and keeping schemas simple. Remember, these aren't exclusive to JSON and can be applied to other data interchange formats too. In the next section, we'll dive into how JSON stacks up against other data formats. Stay tuned!"
    },
    {
        "link": "https://geeksforgeeks.org/how-to-access-and-process-nested-objects-arrays-or-json",
        "document": "How to Access and Process Nested Objects, Arrays, or JSON?\n\nWorking with nested objects, arrays, or JSON in JavaScript involves traversing through multiple levels of data. Here are some effective ways to access and process nested data\n\n1. Using Dot Notation and Bracket Notation – Most Common\n\nDot notation is commonly used for direct access, while bracket notation is useful when keys are variables or contain special characters.\n\nOptional chaining (?.) is used for safely accessing deeply nested properties without causing errors if any part of the path is undefined or null. This helps in preventing runtime errors in complex data structures.\n\n3. Using for…in and for…of Loops for Iteration\n\nThe for…in loops are used for iterating through the properties of objects, while for…of loops are used for arrays. These can be combined to access nested data dynamically.\n\nRecursive functions allow you to access and process deeply nested objects or arrays by repeatedly calling the function on nested items. This is helpful when we don’t know the exact length of the object.\n\n5. Using JSON.parse() and JSON.stringify() Methods for JSON Data\n\nFor JSON data, you can use JSON.parse() to convert JSON strings into JavaScript objects and JSON.stringify() to convert JavaScript objects into JSON strings. This helps when handling JSON data from APIs or storing it locally.\n\nAccessing and processing nested objects, arrays, and JSON is essential for\n• Data handling in complex applications: Often, APIs return nested JSON, and accessing these is important.\n• Error prevention: Methods like optional chaining and recursion help avoid common issues with undefined or null values."
    },
    {
        "link": "https://json-schema.org/understanding-json-schema/structuring",
        "document": "When writing computer programs of even moderate complexity, it's commonly accepted that \"structuring\" the program into reusable functions is better than duplicating code. Similarly, in JSON Schema, structuring your schema into reusable components is highly beneficial for anything beyond the most trivial cases. Here, you will learn about the keywords used to combine JSON schemas modularly and see examples of their application. Like any other code, schemas are easier to maintain if they can be broken down into logical units that reference each other as necessary. In order to reference a schema, we need a way to identify a schema. Schema documents are identified by non-relative URIs. Schema documents are not required to have an identifier, but you will need one if you want to reference one schema from another. In this documentation, we will refer to schemas with no identifier as \"anonymous schemas\". In the following sections we will see how the \"identifier\" for a schema is determined. URI terminology can sometimes be unintuitive. In this document, the following definitions are used.\n• URI [1] or non-relative URI: A full URI containing a scheme ( ). It may contain a URI fragment ( ). Sometimes this document will use \"non-relative URI\" to make it extra clear that relative URIs are not allowed.\n• relative reference [2]: A partial URI that does not contain a scheme ( ). It may contain a fragment ( ).\n• URI-reference [3]: A relative reference or non-relative URI. It may contain a URI fragment ( ).\n• absolute URI [4] A full URI containing a scheme ( ) but not a URI fragment ( ). Even though schemas are identified by URIs, those identifiers are not necessarily network-addressable. They are just identifiers. Generally, implementations don't make HTTP requests ( ) or read from the file system ( ) to fetch schemas. Instead, they provide a way to load schemas into an internal schema database. When a schema is referenced by it's URI identifier, the schema is retrieved from the internal schema database. Using non-relative URIs can be cumbersome, so any URIs used in JSON Schema can be URI-references that resolve against the schema's base URI resulting in a non-relative URI. This section describes how a schema's base URI is determined. Base URI determination and relative reference resolution is defined by RFC-3986. If you are familiar with how this works in HTML, this section should feel very familiar. The URI used to fetch a schema is known as the \"retrieval URI\". It's often possible to pass an anonymous schema to an implementation in which case that schema would have no retrieval URI. Let's assume a schema is referenced using the URI and the following schema is retrieved. The base URI for this schema is the same as the retrieval URI, . You can set the base URI by using the keyword at the root of the schema. The value of is a URI-reference without a fragment that resolves against the retrieval-uri. The resulting URI is the base URI for the schema.\n\nThis is analogous to the tag in HTML. When the keyword appears in a subschema, it means something slightly different. See the bundling section for more. Let's assume the URIs and both identify the following schema. No matter which of the two URIs is used to retrieve this schema, the base URI will be , which is the result of the URI-reference resolving against the Retrieval URI. However, using a relative reference when setting a base URI can be problematic. For example, we couldn't use this schema as an anonymous schema because there would be no Retrieval URI and you can't resolve a relative reference against nothing. For this and other reasons, it's recommended that you always use an absolute URI when declaring a base URI with . The base URI of the following schema will always be no matter what the Retrieval URI was or if it's used as an anonymous schema. In addition to identifying a schema document, you can also identify subschemas. The most common way to do that is to use a JSON Pointer in the URI fragment that points to the subschema. A JSON Pointer describes a slash-separated path to traverse the keys in the objects in the document. Therefore, means:\n• 1) find the value of the key\n• 2) within that object, find the value of the key The URI identifies the highlighted subschema in the following schema. A less common way to identify a subschema is to create a named anchor in the schema using the keyword and using that name in the URI fragment. Anchors must start with a letter followed by any number of letters, digits, , , , or .\n\nIf a named anchor is defined that doesn't follow these naming rules, then behavior is undefined. Your anchors might work in some implementation, but not others. The URI identifies the subschema on the highlighted part of the following schema. A schema can reference another schema using the keyword. The value of is a URI-reference that is resolved against the schema's Base URI. When evaluating a , an implementation uses the resolved identifier to retrieve the referenced schema and applies that schema to the instance. In Draft 4-7, behaves a little differently. When an object contains a property, the object is considered a reference, not a schema. Therefore, any other properties you put in that object will not be treated as JSON Schema keywords and will be ignored by the validator. can only be used where a schema is expected. For this example, let's say we want to define a customer record, where each customer may have both a shipping and a billing address. Addresses are always the same — they have a street address, city and state — so we don't want to duplicate that part of the schema everywhere we want to store an address. Not only would that make the schema more verbose, but it makes updating it in the future more difficult. If our imaginary company were to start doing international business in the future and we wanted to add a country field to all the addresses, it would be better to do this in a single place rather than everywhere that addresses are used. The URI-references in resolve against the schema's Base URI ( ) which results in . The implementation retrieves that schema and uses it to evaluate the \"shipping_address\" and \"billing_address\" properties. When using in an anonymous schema, relative references may not be resolvable. Let's assume this example is used as an anonymous schema The at can resolve just fine without a non-relative base URI to resolve against, but the at can't resolve to a non-relative URI and therefore can't be used to retrieve the address schema. Sometimes we have small subschemas that are only intended for use in the current schema and it doesn't make sense to define them as separate schemas. Although we can identify any subschema using JSON Pointers or named anchors, the keyword gives us a standardized place to keep subschemas intended for reuse in the current schema document. Let's extend the previous customer schema example to use a common schema for the name properties. It doesn't make sense to define a new schema for this and it will only be used in this schema, so it's a good candidate for using . \n\n isn't just good for avoiding duplication. It can also be useful for writing schemas that are easier to read and maintain. Complex parts of the schema can be defined in with descriptive names and referenced where it's needed. This allows readers of the schema to more quickly and easily understand the schema at a high level before diving into the more complex parts. It's possible to reference an external subschema, but generally you want to limit a to referencing either an external schema or an internal subschema defined in . The keyword may be used to create recursive schemas that refer to themselves. For example, you might have a schema that has an array of , each of which are also instances. \n\n Above, we created a schema that refers to itself, effectively creating a \"loop\" in the validator, which is both allowed and useful. Note, however, that a referring to another could cause an infinite loop in the resolver, and is explicitly disallowed. \n\n Working with multiple schema documents is convenient for development, but it's often more convenient for distribution to bundle all of your schemas into a single schema document. This can be done using the keyword in a subschema. When is used in a subschema, it indicates an embedded schema. The identifier for the embedded schema is the value of resolved against the Base URI of the schema it appears in. A schema document that includes embedded schemas is called a Compound Schema Document. Each schema with an in a Compound Schema Document is called a Schema Resource.\n\nThis is analogous to the tag in HTML. It is unusual to use embedded schemas when developing schemas. It's generally best not to use this feature explicitly and use schema bundling tools to construct bundled schemas if such a thing is needed. ::: This example shows the customer schema example and the address schema example bundled into a Compound Schema Document. \n\n All references in a Compound Schema Document need to be the same whether the Schema Resources are bundled or not. Notice that the keywords from the customer schema have not changed. The only difference is that the address schema is now defined at instead of a separate schema document. You couldn't use to reference the address schema because if you unbundled the schema, that reference would no longer point to the address schema. In Draft 4-7, both of these URIs are valid because a subschema only represented a base URI change, not an embedded schema. However, even though it's allowed, it's still highly recommended that JSON Pointers don't cross a schema with a base URI change. You should also see that resolves to the keyword in the address schema rather than the one at the top level schema like it would if the embedded schema wasn't used. Each Schema Resource is evaluated independently and may use different JSON Schema dialects. The example above has the address Schema Resource using Draft 7 while the customer Schema Resource uses Draft 2020-12. If no is declared in an embedded schema, it defaults to using the dialect of the parent schema. In Draft 4-7, a subschema is just a base URI change and not considered an independent Schema Resource. Because is only allowed at the root of a Schema Resource, all schemas bundled using subschema must use the same dialect. In Draft 2020-12, support for changing dialects in an embedded schema (using with a different value than the parent schema) was added."
    },
    {
        "link": "https://stackoverflow.com/questions/45844962/how-to-validate-a-json-schema-with-nested-references",
        "document": "I have a JSON schema that references multiple schemas, using the '$ref' parameter whose schemas, in turn, reference other schemas.\n\nJust for the sake of convenience, I've placed them all in a single directory and attempted to validate the schema using a library called Ajv but on compiling the schema I get the error: .\n\nHow can I possibly validate such a JSON schema? My goal is to create a single JavaScript object model for all the schemas. Thanks."
    },
    {
        "link": "https://stackoverflow.com/questions/56296709/json-complex-schema-reusable-definitions-ref-validations-in-nested-properties",
        "document": "Trying to learn JSON schemas and I have a complex schema that is all based on relative URL's. When nesting properties call a definitions property defined in another file, the validations sometimes get ignored.\n\nMy goal is to basically make reusable definitions and frequently used enums/consts/definitions globally\n\nBased on my understanding of how works at root level ref, is that it sets the base uri for the schema, where is relative to. However, in some cases, my schema is not validated against false values, while others are. Nested, or otherwise.\n\nIn intellij, the following is the result: (every single property shown should not be valid, however some are simply ignored and allowed (like negative numbers and nulls etc). I get no warnings/errors about $ref not being able to be resolved. Autocomplete even finishes the relative file name and definition property for me.\n\nAfter playing around with it some more I found that it is related to the relative URLs. For example, in my pii (personally identifiable information) folder, where jobs schema is located, if I move that schema to the root directory with the other schemas everything is validated properly. To illustrate the new project tree:\n\nFor brevity, my schema isn't actually stored at . Based on my understanding of this doesn't matter, it's just a way for the schemas to communicate with one another. I would like to modularize as much as possible and segregate schemas into their own sub-folders (like pii) but, in my example it does not validate that way."
    },
    {
        "link": "https://mongodb.com/resources/languages/json-schema-examples",
        "document": "JSON (JavaScript Object Notation) is a simple and lightweight text-based data format. JSON Schema is an IETF standard providing a format for what JSON data is required for a given application and how to interact with it. Applying such standards for a JSON document lets you enforce consistency and data validity across similar JSON data. .Let's take a look at a document example with a person's name and their indoor and outdoor hobbies. If you were to look at the above example, you would not necessarily know if can be zero (0). You would also not know if you could leave blank. For this reason, we need to have metadata that holds information about valid data types and the description of the keys. Additionally, JSON Schema gives you a standard way to structure the metadata.\n\nLet’s look at an example of a JSON Schema for the above document type. { \"$schema\": \"http://json-schema.org/draft-04/schema#\", \"$id\": \"https://example.com/employee.schema.json\", \"title\": \"Record of employee\", \"description\": \"This document records the details of an employee\", \"type\": \"object\", \"properties\": { \"id\": { \"description\": \"A unique identifier for an employee\", \"type\": \"number\" }, \"name\": { \"description\": \"Full name of the employee\", \"type\": \"string\" }, \"age\": { \"description\": \"Age of the employee\", \"type\": \"number\" }, \"hobbies\": { \"description\": \"Hobbies of the employee\", \"type\": \"object\", \"properties\": { \"indoor\": { \"type\": \"array\", \"items\": { \"description\": \"List of indoor hobbies\", \"type\": \"string\" } }, \"outdoor\": { \"type\": \"array\", \"items\": { \"description\": \"List of outdoor hobbies\", \"type\": \"string\" } } } } } } It could look daunting at first glance but we will break it down to understand further. We have different keywords that are used in the above example. The following list explains what each of these keywords mean.\n• $schema: States that this schema complies with v4 of the IETF standard\n• $id: Defines the base URI to resolve other URI references within the schema.\n• title: Describes the intent of the schema.\n• description: Gives the description of the schema.\n• properties: Defines various keys and their value types within a JSON document.\n• minimum: Defines the minimum acceptable value for a numeric datatype.\n• items: Enumerates the definition for the items that can appear in an array.\n• minItems: Defines the minimum number of items that should appear in an array.\n• uniqueItems: Enforces if every item in the array should be unique relative to one another.\n• required: Lists the keys that are required and mandatory. For a full list of keywords, visit json-schema.org. The link explains the keywords that you can use in your schema and their purpose.\n\nYou can use online JSON schema generators if you have a simple JSON document, then modify the schema as per the requirement of your project. Alternatively, you can build a JSON schema of your own from scratch by following the steps below If you have already familiarized yourself with the JSON schema keywords and properties, we can jump right into starting a basic JSON schema. Lets begin with five basic keywords to define an employee. { \"$schema\": \"https://json-schema.org/draft/2020-12/schema\", \"$id\": \"https://example.com/product.schema.json\", \"title\": \"Record of Employee\", \"description\": \"This document records the details of an employee\", \"type\": \"object\" } In the above example, links to the resource that identifies the dialect and the valid schemas written for this dialect. keyword identifies the schema resource. Here are a couple of things to know about this keyword:\n• The URI in this keyword is an identifier and not necessarily a network locator.\n• It must be a string.\n• It must represent a valid URI reference that is normalized and resolves absolute URI.\n• It must not contain a non empty fragment.\n• It should not contain an empty fragment. keyword gives a short description of the schema and you can use the keyword to explain more about the schema. In the above example, the title hints that this schema is about a record of an employee and the description explains that in detail. keyword explains the valid data type of a record. In the above example, type sets the constraint for this document and tells us that this record is an object.\n\nThe schema that we have used in the above section is a basic outline. Lets build on it by adding an field to the employee record. { \"$schema\": \"http://json-schema.org/draft-04/schema#\", \"$id\": \"https://example.com/employee.schema.json\", \"title\": \"Record of employee\", \"description\": \"This document records the details of an employee\", \"type\": \"object\", \"properties\": { \"id\": { \"description\": \"A unique identifier for an employee\", \"type\": \"number\" } } } We have added two sub-properties, “id.description”, stating that it is a unique identifier, and “id.type”, explaining that it is a number. Let's do the same for name and age -- but this time, with new keywords. { \"$schema\": \"http://json-schema.org/draft-04/schema#\", \"$id\": \"https://example.com/employee.schema.json\", \"title\": \"Record of employee\", \"description\": \"This document records the details of an employee\", \"type\": \"object\", \"properties\": { \"id\": { \"description\": \"A unique identifier for an employee\", \"type\": \"string\" }, \"name\": { \"description\": \"full name of the employee\", \"type\": \"string\" \"minLength\":2 }, \"age\": { \"description\": \"age of the employee\", \"type\": \"number\", \"minimum\": 16 } }, \"required\": [ \"id\" \"name\", \"age\" ] } In the name property, we have introduced the keyword to make sure that the property has at least two characters. Similarly, in the age property, we have used the keyword to ensure that the age of the employee exceeds 16 everytime. It can be of type number or type integer. We have also used the keyword to define the mandatory properties. Now, let’s take it a step further and add an object inside the employee object. To add an object inside an object in JSON format, we use nested data structure. Creating subschemas for Nested objects work quite similarly to the creating schemas for root objects. You can use all the schema keywords that you used when defining the root object except for and . They only have to be stated at the beginning of a schema.\n\nThe following example shows how we can create an object within an object that takes an array type data. Here, we will use a few new keywords in addition to the ones we have already used. { \"$schema\": \"http://json-schema.org/draft-04/schema#\", \"$id\": \"https://example.com/employee.schema.json\", \"title\": \"Record of employee\", \"description\": \"This document records the details of an employee\", \"type\": \"object\", \"properties\": { \"id\": { \"description\": \"A unique identifier for an employee\", \"type\": \"number\" }, \"name\": { \"description\": \"name of the employee\", \"type\": \"string\", \"minLength\":2 }, \"age\": { \"description\": \"age of the employee\", \"type\": \"number\", \"minimum\": 16 }, \"hobbies\": { \"description\": \"hobbies of the employee\", \"type\": \"object\", \"properties\": { \"indoor\": { \"type\": \"array\", \"items\": { \"description\": \"List of hobbies\", \"type\": \"string\" }, \"minItems\": 1, \"uniqueItems\": true }, \"outdoor\": { \"type\": \"array\", \"items\": { \"description\": \"List of hobbies\", \"type\": \"string\" }, \"minItems\": 1, \"uniqueItems\": true } }, \"required\": [ \"indoor\", \"outdoor\" ] } }, \"required\": [ \"id\", \"name\", \"age\", \"hobbies\" ], \"additionalProperties\": false } In the above example, we have defined two array fields - indoor and outdoor in the “hobbies” object. You might have noticed the keyword. This keyword defines the properties of each item. Similarly, defines the minimum number of items that must be present in the array, defines the maximum number of items that can be present within the array uniquely identifies each item. You will also see the required keyword again within the subobject. Like the required keyword in the root JSON object, the required keyword within the subobject dictates the mandatory properties within the subobjects. Lastly, we have also introduced . In the above example, it is a boolean taking the value false , telling us that we can’t use any other property that isn’t listed under the keyword. However, doesn’t necessarily have to be a boolean. It can also be an object. For example, in the schema below, this keyword is stating that any additional property that we use under this schema is required to be of type string.\n\nThough the above example is limited to a use case, there are limitless uses of JSON schema. One of the areas where JSON schema can be used to validate and enforce consistency is with geographical coordinates. Because of the nature of the data, there is a high chance of accepting invalid or inconsistent data. In the example below, we can see that coordinates are represented using numeric data types. But there is a limit to the value that we can use for a coordinate i.e., the values cannot be more than 90 or less than negative 90. So let’s create a JSON schema to address this scenario. Here you can see that we have used the and keyword for each property to limit the range of acceptable values. This not only resolves the issue with data validation but also ensures that incorrect values do not get through.\n\nUsing Your Schema for Validation in MongoDB Atlas You can use $jsonSchema in a document validator to enforce the specified schema on insert and update operations in MongoDB, including in MongoDB Atlas. Since MongoDB stores the data in BSON (Binary JSON), you can easily store and retrieve all your data in JSON format. MongoDB also lets you enforce a schema to validate your data and maintain a data structure. We will use MongoDB Atlas and MongoDB Compass to demonstrate how. Suppose we insert the following documents into a collection named employees inside a database named mongodatabase. We will enforce the schema from the previous section to validate these documents in MongoDB Compass. Firstly, let’s connect our cluster with our Compass.\n• Click on CONNECT to connect with your cluster.\n• Set up connection security by adding your IP address and creating a database user. Then select Choose a connection method.\n• Download MongoDB Compass if you have not already and copy the connection string.\n• Open MongoDB Compass and paste the connection string. Your connection string should look similar to this: Replace <username> and <password> with the username and password of the database user that you created. Now, let’s go into the mongodatabase and look at the documents inside the employees collection. Click on the Validation tab and insert the following JSON schema to validate our documents. Begin the schema definition with keyword. Because we don’t need the $id and $schema keywords to get started, we will remove them. { $jsonSchema: { \"title\": \"Record of employee\", \"description\": \"This document records the details of an employee\", \"type\": \"object\", \"properties\": { \"id\": { \"description\": \"A unique identifier for an employee\", \"type\": \"number\" }, \"name\": { \"description\": \"name of the employee\", \"type\": \"string\", \"minLength\":2 }, \"age\": { \"description\": \"age of the employee\", \"type\": \"number\", \"minimum\": 16 }, \"hobbies\": { \"description\": \"hobbies of the employee\", \"type\": \"object\", \"properties\": { \"indoor\": { \"type\": \"array\", \"items\": { \"description\": \"List of hobbies\", \"type\": \"string\" }, \"minItems\": 1, \"uniqueItems\": true }, \"outdoor\": { \"type\": \"array\", \"items\": { \"description\": \"List of hobbies\", \"type\": \"string\" }, \"minItems\": 1, \"uniqueItems\": true } }, \"required\": [ \"indoor\", \"outdoor\" ] } }, \"required\": [ \"id\", \"name\", \"age\", \"hobbies\" ], \"additionalProperties\": false } } If you have followed the steps so far, you should get the following result. As our schema requires a hobbies field in every document, the document with the id: 8 fails because it didn’t contain the required field. You can also set additional validation rules by following the documentation on setting validation rules for your schema. To match documents that satisfy the specified JSON Schema, you can use the operator. The MongoDB JSON Schema documentation is an excellent resource to get you up and running. To learn more about MongoDB Atlas, refer to this article."
    },
    {
        "link": "https://json-schema.org/UnderstandingJSONSchema.pdf",
        "document": ""
    }
]