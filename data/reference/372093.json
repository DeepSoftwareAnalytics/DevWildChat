[
    {
        "link": "https://vnetman.github.io/pcap/python/pyshark/scapy/libpcap/2018/10/25/analyzing-packet-captures-with-python-part-1.html",
        "document": "Why would you use Python to read a pcap?\n\nFor most situations involving analysis of packet captures, Wireshark is the tool of choice. And for good reason too - Wireshark provides an excellent GUI that not only displays the contents of individual packets, but also analysis and statistics tools that allow you to, for example, track individual TCP conversations within a pcap, and pull up related metrics.\n\nThere are situations, however, where the ability to process a pcap programmatically becomes extremely useful. Consider:\n• given a pcap that contains hundreds of thousands of packets, find the first connection to a particular server/service where the TCP SYN-ACK took more than 300ms to appear after the initial SYN\n• in a pcap that captures thousands of TCP connections between a client and several servers, find the connections that were prematurely terminated because of a RST sent by the client; at that point in time, determine how many other connections were in progress between that client and other servers\n• you are given two pcaps, one gathered on a SPAN port on an access switch, and another on an application server a few L3 hops away. At some point the application server sporadically becomes slow (retransmits on both sides, TCP windows shrinking etc.). Prove that it is (or is not) because of the network.\n• repeat the above exercises several times a week (or several times a day) with different sets of packet captures\n\nIn all these cases, it is immensely helpful to write a custom program to parse the pcaps and yield the data points you are looking for.\n\nIt is important to realize that we are not precluding the use of Wireshark; for example, after your program locates the proverbial needle(s) in the haystack, you can use that information (say a packet number or a timestamp) in Wireshark to look at a specific point inside the pcap and gain more insight.\n\nSo, this is the topic of this blog post: how to go about programmatically processing packet capture (pcap) files.\n\nI will be using Python (3). Why Python? Apart from the well-known benefits of Python (open-source, relatively gentle learning curve, ubiquity, abundance of modules and so forth), it is also the case that Network Engineers are gaining expertise in this language and are using it in other areas of their work (device management and monitoring, workflow applications etc.).\n\nI will be using scapy, plus a few other modules that are not specific to packet processing or networking (argparse, pickle, pandas).\n\nNote that there are other alternative Python modules that can be used to read and parse pcap files, like pyshark and pycapfile. Pyshark in particular is interesting because it simply leverages the underlying tshark installed on the system to do its work, so if you are in a situation where you need to leverage tshark’s powerful protocol decoding ability, pyshark is the way to go. In this blog however I am restricting myself to regular Ethernet/IPv4/TCP packets, and I can just use scapy.\n\nA few notes before we start\n\nThe code below was written and executed on Linux (Linux Mint 18.3 64-bit), but the code is OS-agnostic; it should work as well in other environments, with little or no modification.\n\nIn this post I use an example pcap file captured on my computer.\n\nBuild a skeleton for the program. This will also serve to check if your Python installation is OK.\n\nUse the module to get the pcap file name from the command line. If your argparse knowledge needs a little brushing up, you can look at my argparse recipe book, or at any other of the dozens of tutorials on the web.\n\nOpen the pcap and count how many packets it contains.\n\nThe class is provided by the module. This class is iterable, and in each iteration it yields the data (i.e. packet contents) and metadata (i.e. timestamp, packet number etc.) for every packet in the capture.\n\nAt this point you may want to open the pcap in Wireshark and verify if the packet count our program reports is consistent with that reported by Wireshark.\n\nUse scapy methods to filter out uninteresting packets. For starters, let us consider all IPv4/TCP packets as interesting.\n\nNote the use of scapy’s class in the code above, and note how we use and to extract information from the ethernet header of the packet. Also note the use of to obtain the IPv4 header.\n\nIt so happens that the example pcap we used was captured by with a capture filter that selected all IPv4/TCP packets, which is why all 22639 packets are reported as interesting. We’ll fix that in the next iteration of the code.\n\nThe packet capture contains, among several connections, one HTTP connection between client 192.168.1.137:57080 and server 152.19.134.43:80. For the rest of this discussion let’s only consider this connection as interesting and filter out other packets.\n\nNote that the code below hardcodes these addresses; you may instead consider gathering this information from the command-line with .\n\nIn this code iteration, we’ll access the packet’s metadata; in particular the timestamps and ordinal numbers (i.e. packet number within the packet capture) of the first and the last packets of the connection that we’re interested in.\n\nThe function is defined like this:\n\nA few notes on the timestamp:\n\nThe returned by this call:\n\ncontains a 64-bit timestamp that is documented here. Essentially it is split into two 32-bit fields ( and ), and represents the Unix time at which the packet was captured.\n\nThe field in metadata stores the resolution as either 1000000 (microsecond resolution) or 1000000000 (nanosecond resolution), based on the capability of the hardware/software that created the pcap. The field within the file as documented here is a 1-byte field, but the scapy RawPcapReader code processes this 1-byte field and provides the metadata as either 1000000 or 1000000000.\n\nThe output of our program at the end of this step looks like this:\n• Lines beginning with are packets sent from client to the server, and lines with are packets from the server to the client\n• The numbers in square brackets e.g. are the packet ordinals in the capture file. This is handy if you want to examine a particular packet in detail in Wireshark.\n• The timestamps e.g. are relative to the timestamp of the first packet of the connection\n• The TCP flags, relative sequence number, relative acknowledgement number and TCP payload lengths are printed next\n• Note, for example, the 3-way connection establishment handshake at packet numbers 2585, 2586 and 2587. Also note that the SYN-ACK came in about 307ms after the original SYN, and the ACK that followed was recorded less than 1ms after that; this is explained by the fact that the capture was taken on the client host, and the server was across the public internet.\n\nIf you’ve been executing the program in the previous steps, you will have noticed one thing: it is excruciatingly slow. This is because of scapy - for every one of the thousands of packets read from the capture file, our code builds scapy objects which, as it turns out, is an expensive and slow process.\n\nThis is a serious issue because you are, after all, developing code: each time you run the program and examine its output, you will want to write more code to tweak something, or to gain some different insight. Each time you make a small change to the code and run it, you will have to deal with its sluggishness which can get frustrating and impede progress.\n\nThe most obvious way to deal with this problem is to not use scapy at all, and instead find an alternate faster method to look at the capture packet data and metadata.\n\nIn this post, though, I will use a different approach:\n• use scapy (as in the above examples) to extract interesting packet data and metadata from the capture file\n• store the extracted data in a separate “custom” file on disk\n• subsequently, use the extracted data from the “custom” file for analysis, display, gaining insight etc.\n\nThe Python 3 pickle module provides a generic mechanism to save (“pickle”) a bunch of Python data structures to a file on disk, and to read the file and restore (“unpickle”) the saved data structures. This is what we will be using.\n\nThe program now has two ‘modes’ of operation:\n\nWhy is this better? Because you only have to run the step (steps 1 and 2) once. The step (step 3) - the part which you have to run repetitively after tweaking the code each time - is very fast because it does not use scapy any more.\n• a function to read the given .pcap file and pickle the interesting data into a file\n• an function to read the pickled data and print the same information as we did in Step 6; except, of course, that the data is now coming from the pickle file.\n\nThe argparse code to parse the command line is not shown below; please look at my argparse recipe book if you need help with using the argparse module.\n\nThe pickle step runs like this:\n\nThe run time for this step is the same as for the previous steps. This is because we have continued to use scapy to build packets from the pcap file and read their fields.\n\nNote the ~800KB file that was created by the program. This file is then used in the analyze step:\n\nThis display is the same as in the previous step, but it appears very fast. This is because we are no longer using scapy; instead we are reading packet fields from the pickle file.\n\nNote also that in this step we are printing the TCP window sizes as well. We first read the scale factor from the “Window Scale Factor” TCP options in the initial SYN and SYN-ACK packets, and then, for every packet, we compute the window size and store it in the pickle file.\n\nThe code for the step:\n\n# List of interesting packets, will finally be pickled. # Each element of the list is a dictionary that contains fields of interest # LLC frames will have 'len' instead of 'type'. # If this TCP packet has the Ack bit set, then it must carry an ack # Determine the TCP payload length. IP fragmentation will mess up this # logic, so first check that this is an unfragmented packet # Look for the 'Window Scale' TCP option if this is a SYN or SYN-ACK # Create a dictionary and populate it with data that we'll need in the \\\n\nIn other words, for every packet we read from the pcap, we build a Python dictionary that contains the values of the packet attributes we are interested in (‘direction’, ‘ordinal’, ‘relative_timestamp’, ‘tcp_flags’, ‘seqno’, ‘ackno’, ‘tcp_payload_len’ and ‘window’). Each dictionary is then appended to a list ( ). Once all packets are processed, the list is “pickled” and stored in the file.\n\nThe code for the step:\n\nThe goal in this iteration of the code is to generate a graphical plot of the TCP Receive window on the Client. The end result is a graph that looks like this:\n\nThe code for generating the plot shown above, using pandas and matplotlib, is almost ridiculously easy (I am only showing the function):\n\nYou will notice from the graph that the window size shows a sudden dip to some value between 400000 and 500000 shortly after timestamp 21.1. If you find this suspicious, you can again write more code to help you narrow down the exact packet number in the capture:\n\nArmed with this data, you can now open the capture file in Wireshark and take a closer look at what happened shortly before packet #9539.\n\nHere’s a fancier plot, where I am plotting two parameters - the client window size, and the ack number sent by the client (i.e. the number of bytes received thus far from the server):\n\nAnd the code for the above looks like this:\n\nWith Python code, you can iterate over the packets in a pcap, extract relevant data, and process that data in ways that make sense to you. You can use code to go over the pcap and locate a specific sequence of packets (i.e. locate the needle in the haystack) for later analysis in a GUI tool like Wireshark. Or you can create customized graphical plots that can help you visualize the packet information. Further, since this is all code, you can do this repeatedly with multiple pcaps."
    },
    {
        "link": "https://pcap-ct.readthedocs.io",
        "document": "Python pcap-ct package is a simplified object-oriented Python wrapper for libpcap C library - the current tcpdump.org version, and the WinPcap port for Windows.. pcap-ct is a pure Python package, based on the low-level is a pure Python package, based on the low-level libcap package. It is fully compliant implementation of the original PyPCAP 1.2.3 API (with some minor improvements and bug fixes) by implementing whole its functionality in a clean Python instead of Cython and C.\n\nThis is a simplified object-oriented Python wrapper for libpcap - the current tcpdump.org version, and the WinPcap port for Windows.\n\nWinPcap has compatibility issues with Windows 10, therefore it’s recommended to use Npcap (Nmap’s packet sniffing library for Windows, based on the WinPcap/Libpcap libraries, but with improved speed, portability, security, and efficiency). Please enable WinPcap API-compatible mode during the library installation."
    },
    {
        "link": "https://cdn.ttgtmedia.com/rms/pdf/MPNS_CH5.pdf",
        "document": ""
    },
    {
        "link": "https://surajsinghbisht054.medium.com/python-pentesting-capture-save-tcp-ip-packets-in-pcap-files-7bb70083a8b8",
        "document": "Hello Readers! Today’s tutorial will cover how to save TCP/IP packets in a PCAP file using Python. Handling and analyzing network packets is a crucial skill for professionals working on network projects. Capturing and storing these packets allows for detailed analysis using tools like Wireshark, which can provide insights and improve network security.\n\nIn many networking projects and penetration testing tasks, the ability to capture and save raw network packets is invaluable. These stored packets can later be analyzed to uncover vulnerabilities, understand network behavior, or even troubleshoot issues. Wireshark, one of the most popular network protocol analyzers, supports reading PCAP files, making this task easier and more accessible.\n\nHow It Works: Writing Packets to PCAP Files\n\nTo facilitate the saving of packets into a PCAP file, we’ll develop a Python class that performs the necessary operations. This class will handle creating a valid PCAP file and writing packets with appropriate headers.\n\nA PCAP file starts with a global header, which contains metadata about the capture. Our Python class will write this global header when initialized. Key components include:\n• The version of the PCAP format is being used.\n• Information about the data link type to specify how packets are captured.\n\nEach packet captured during our network audit must include a simple header with its capture timestamp and length information. This step is crucial for ensuring that the packet data is correctly interpreted by analysis tools like Wireshark.\n\nSet up the structure and values for the PCAP global header\n\nTo see the `Pcap` class in action, integrate it with a packet sniffer code.\n\nRun this script with Sudo Command and let it capture packets in a pcap file.\n\nThen, Open your ‘temp.pcap’ file in Wireshark to explore your captured packets!\n\nAs networks and malicious threats evolve, mastering the art of packet capturing with Python can be an invaluable asset. Future enhancements could include implementing more sophisticated filtering mechanisms or developing real-time analysis to identify potential threats as they occur.\n\nI hope you found this tutorial informative and engaging."
    },
    {
        "link": "https://github.com/paulveillard/cybersecurity-pcap-tools",
        "document": "An ongoing & curated collection of awesome software best practices and techniques, libraries and frameworks, E-books and videos, websites, blog posts, links to github Repositories, technical guidelines and important resources about Packet Capture (PCAP) Tools in Cybersecurity.\n\nPCAP, or full packet data capture for analysis, does what it says – it captures the entirety of every packet that comprises the network traffic (both metadata and content). If something happens on the network, PCAP knows about it. Whether it is malware moving data around, or staff arranging a private party, it can be captured and then analyzed.\n• Bmon: (Bandwidth Monitor) is a tool similar to nload that shows the traffic load over all the network interfaces on the system. The output also consists of a graph and a section with packet level details. Screenshot\n• Bwm-ng: (Bandwidth Monitor Next Generation) is another very simple real time network load monitor that reports a summary of the speed at which data is being transferred in and out of all available network interfaces on the system. Screenshot\n• CBM: (Color Bandwidth Meter) A tiny little simple bandwidth monitor that displays the traffic volume through network interfaces. No further options, just the traffic stats are display and updated in realtime. Screenshot\n• Collectl: reports system statistics in a style that is similar to dstat, and like dstat it gathers statistics about various different system resources like cpu, memory, network etc. Over here is a simple example of how to use it to report network usage/bandwidth. Screenshot\n• Dstat: is a versatile tool (written in python) that can monitor different system statistics and report them in a batch style mode or log the data to a csv or similar file. This example shows how to use dstat to report network bandwidth Screenshot\n• Ifstat: reports the network bandwidth in a batch style mode. The output is in a format that is easy to log and parse using other programs or utilities. Screenshot\n• Iftop: measures the data flowing through individual socket connections, and it works in a manner that is different from Nload. Iftop uses the pcap library to capture the packets moving in and out of the network adapter, and then sums up the size and count to find the total bandwidth under use. Although iftop reports the bandwidth used by individual connections, it cannot report the process name/id involved in the particular socket connection. But being based on the pcap library, iftop is able to filter the traffic and report bandwidth usage over selected host connections as specified by the filter. Screenshot\n• Iptraf-ng: is an interactive and colorful IP Lan monitor. It shows individual connections and the amount of data flowing between the hosts. A maintained fork of the defunct iptraf. Screenshot\n• Jnettop: Jnettop is a traffic visualiser, which captures traffic going through the host it is running from and displays streams sorted by bandwidth they use. Screenshot\n• Nethogs: is a small 'net top' tool that shows the bandwidth used by individual processes and sorts the list putting the most intensive processes on top. In the event of a sudden bandwidth spike, quickly open nethogs and find the process responsible. Nethogs reports the PID, user and the path of the program. Screenshot\n• Netload: displays a small report on the current traffic load, and the total number of bytes transferred since the program start. No more features are there. Its part of the netdiag. Screenshot\n• Netwatch: is part of the netdiag collection of tools, and it too displays the connections between local host and other remote hosts, and the speed at which data is transferring on each connection. Screenshot\n• Nload: is a commandline tool that allows users to monitor the incoming and outgoing traffic separately. It also draws outa graph to indicate the same, the scale of which can be adjusted. Easy and simple to use, and does not support many options. Screenshot\n• Pktstat: displays all the active connections in real time, and the speed at which data is being transferred through them. It also displays the type of the connection, i.e. tcp or udp and also details about http requests if involved. Screenshot\n• Slurm: is 'yet' another network load monitor that shows device statistics along with an ascii graph. It supports 3 different styles of graphs each of which can be activated using the c, s and l keys. Simple in features, slurm does not display any further details about the network load. Screenshot\n• Speedometer: Another small and simple tool that just draws out good looking graphs of incoming and outgoing traffic through a given interface. Screenshot\n• Tcptrack: is similar to iftop, and uses the pcap library to capture packets and calculate various statistics like the bandwidth used in each connection. It also supports the standard pcap filters that can be used to monitor specific connections. Screenshot\n• Trafshow: reports the current active connections, their protocol and the data transfer speed on each connection. It can filter out connections using pcap type filters. Screenshot\n• Vnstat: is bit different from most of the other tools. It actually runs a background service/daemon and keeps recording the size of data transfer all the time. Next it can be used to generate a report of the history of network usage. Screenshot\n• Libpcap/Tcpdump: The official site of tcpdump, a powerful command-line packet analyzer; and libpcap, a portable C/C++ library for network traffic capture.\n• Ngrep: strives to provide most of GNU grep's common features, applying them to the network layer. ngrep is a pcap-aware tool that will allow you to specify extended regular or hexadecimal expressions to match against data payloads of packets. It currently recognizes TCP, UDP and ICMP across Ethernet, PPP, SLIP, FDDI, Token Ring and null interfaces, and understands bpf filter logic in the same fashion as more common packet sniffing tools, such as tcpdump and snoop. Screenshot\n• clj-net-pcap: is a packet capturing library for Clojure. clj-net-pcap uses jNetPcap and adds convenience functionality around jNetPcap for easing the usability. A paper on clj-net-pcap was published in scope of COMPSACW 2014.\n• jNetPcap: jNetPcap is a packet capturing library for Java that is available for Linux and Windows. jNetPcap leverages libpcap respectively WinPcap and employs the Java Native Interface (JNI) for using the functionality provided by libpcap/WinPcap.\n• Arkime Arkime (formerly Moloch) is a large scale, open source, indexed packet capture and search tool.\n• n2disk (Commercial): A multi-Gigabit network traffic recorder with indexing capabilities. n2disk is a network traffic recorder application. With n2disk you can capture full- sized network packets at multi-Gigabit rate (above 10 Gigabit/s on adequate hardware) from a live network interface, and write them into files without any packet loss.\n• Netis Packet Agent: It is a remote data capture utility through GRE tunnel, which makes you easily capture packets from an NIC interface, encapsulate them with GRE and send them to a remote machine for monitoring and analysis.\n• OpenFPC: OpenFPC is a set of scripts that combine to provide a lightweight full-packet network traffic recorder & buffering tool. Its design goal is to allow non-expert users to deploy a distributed network traffic recorder on COTS hardware while integrating into existing alert and log tools.\n• PF_RING: PF_RING is a new type of network socket that dramatically improves the packet capture speed. Available for Linux kernels 2.6.32 and newer. No need to patch the kernel. PF_RING-aware drivers for increased packet capture acceleration.\n• TTT: (Tele Traffic Tapper) is yet another descendant of tcpdump but it is capable of real-time, graphical, and remote traffic-monitoring. ttt won't replace tcpdump, rather, it helps you find out what to look into with tcpdump. ttt monitors the network and automatically picks up the main contributors of the traffic within the time window. The graphs are updated every second by default.\n• Yaf: It's a reliable piece of software, quite solid and able to generate flow records from pcap. This is very nice for indexing huge pcap or even doing packet capture. The recent version can even extract payloads and put in the flow records.\n• Brim: Brim blends together the richness of Zeek logs with the details of packets. It's the best of both worlds. While Zeek logs can answer most all of your questions quickly, you still have fast access to packets when you need to drill down into the details. Wireshark is always just a click away.\n• BruteShark: Is an open-source, cross-platform network forensic analysis tool with many features. It includes: password extracting, displaying a visual network map, reconstruct TCP sessions, extract hashes of encrypted passwords and even convert them to a Hashcat format in order to perform an offline Brute Force attack.\n• AIEngine: is a next generation interactive/programmable packet inspection engine with capabilities of learning without any human intervention, NIDS functionality, DNS domain classification, network collector and many others. AIEngine also helps network/security professionals to identify traffic and develop signatures for use them on NIDS, Firewalls, Traffic classifiers and so on.\n• CapAnalysis - CapAnalysis is a web visual tool for information security specialists, system administrators and everyone who needs to analyze large amounts of captured network traffic. A live web demo is available for testing.\n• Chopshop: is a MITRE developed framework to aid analysts in the creation and execution of pynids based decoders and detectors of APT tradecraft.\n• CoralReef: is a software suite developed by CAIDA to analyze data collected by passive Internet traffic monitors. It provides a programming library libcoral, similar to libpcap with extensions for ATM and other network types, which is available from both C and Perl.\n• DPDK: is a set of libraries and drivers for fast packet processing. It was designed to run on any processors. The first supported CPU was Intel x86 and it is now extended to IBM Power 8, EZchip TILE-Gx and ARM. It runs mostly in Linux userland. A FreeBSD port is available for a subset of DPDK features.\n• ECap: (External Capture) is a distributed network sniffer with a web front- end. Ecap was written many years ago in 2005, but a post on the tcpdump-workers mailing list requested a similar application... so here it is. It would be fun to update it and work on it again if there's any interest.\n• EtherApe: is a graphical network monitor for Unix modeled after etherman. Featuring link layer, ip and TCP modes, it displays network activity graphically. Hosts and links change in size with traffic. Color coded protocols display. It supports Ethernet, FDDI, Token Ring, ISDN, PPP and SLIP devices. It can filter traffic to be shown, and can read traffic from a file as well as live from the network.\n• HttpSniffer: A multi-threading tool to sniff TCP flow statistics and embedded HTTP headers from PCAP file. Each TCP flow carrying HTTP is exported to text file in JSON format.\n• Ipsumdump: summarizes TCP/IP dump files into a self-describing ASCII format easily readable by humans and programs. Ipsumdump can read packets from network interfaces, from tcpdump files, and from existing ipsumdump files. It will transparently uncompress tcpdump or ipsumdump files when necessary. It can randomly sample traffic, filter traffic based on its contents, anonymize IP addresses, and sort packets from multiple dumps by timestamp. Also, it can optionally create a tcpdump file containing actual packet data. It's also convenient to work with CLICK as a inserted module.\n• ITA: The Internet Traffic Archive is a moderated repository to support widespread access to traces of Internet network traffic, sponsored by ACM SIGCOMM. The traces can be used to study network dynamics, usage characteristics, and growth patterns, as well as providing the grist for trace- driven simulations. The archive is also open to programs for reducing raw trace data to more manageable forms, for generating synthetic traces, and for analyzing traces.\n• Joy: joy is a traffic analysis and parsing tool that was developed. In part to assist in classifying encrypted traffic streams, such as HTTPS traffic. It is able to parse pcap files into usable json files that contain details on the capture statistics and features.\n• Libcrafter: is a high level library for C++ designed to make easier the creation and decoding of network packets. It is able to craft or decode packets of most common network protocols, send them on the wire, capture them and match requests and replies.\n• Libnet: is a collection of routines to help with the construction and handling of network packets. It provides a portable framework for low-level network packet shaping, handling and injection. Libnet features portable packet creation interfaces at the IP layer and link layer, as well as a host of supplementary and complementary functionality. Using libnet, quick and simple packet assembly applications can be whipped up with little effort.\n• Libnids: designed by Rafal Wojtczuk, is an implementation of an E-component of Network Intrusion Detection System. It emulates the IP stack of Linux 2.0.x. Libnids offers IP defragmentation, TCP stream assembly and TCP port scan detection. The most valuable feature of libnids is reliability. A number of tests were conducted, which proved that libnids predicts behaviour of protected Linux hosts as closely as possible.\n• Multitail: now has a colorscheme included for monitoring the tcpdump output. It can also filter, convert timestamps to timestrings and much more.\n• Netsniff-ng: Netsniff-ng is a toolkit of free Linux networking utilities, a Swiss army knife for your daily Linux network plumbing if you will.\n• NetDude: (NETwork DUmp data Displayer and Editor). From their webpage, \"it is a GUI-based tool that allows you to make detailed changes to packets in tcpdump tracefiles.\"\n• Network Expect: is a framework that allows to easily build tools that can interact with network traffic. Following a script, traffic can be injected into the network, and decisions can be taken, and acted upon, based on received network traffic. An interpreted language provides branching and high-level control structures to direct the interaction with the network. Network Expect uses libpcap for packet capture and libwireshark (from the Wireshark project) for packet dissection tasks. (GPL, BSD/Linux/OSX).\n• NFStream: is a Python framework providing fast, flexible, and expressive data structures designed to make working with online or offline network data both easy and intuitive. It aims to be the fundamental high-level building block for doing practical, real world network data analysis in Python. Additionally, it has the broader goal of becoming a common network data analytics framework for researchers providing data reproducibility across experiments.\n• Ntop: Ntop is a network traffic probe that shows the network usage, similar to what the popular top Unix command does. ntop is based on libpcap and it has been written in a portable way in order to virtually run on every Unix platform and on Win32 as well.\n• Ntopng: Ntopng is the next generation version of the original ntop, a network traffic probe that shows the network usage, similar to what the popular top Unix command does. ntop is based on libpcap and it has been written in a portable way in order to virtually run on every Unix platform, MacOSX and on Win32 as well.\n• PacketQ: A tool that provides a basic SQL-frontend to PCAP-files. Outputs JSON, CSV and XML and includes a build-in webserver with JSON-api and a nice looking AJAX GUI.\n• Pcap2har: A program to convert .pcap network capture files to HTTP Archive files using library dpkt.\n• PcapPlusPlus: PcapPlusPlus a multiplatform C++ network sniffing and packet parsing and manipulation framework. It's meant to be lightweight, efficient and easy to use. It's a C++ wrapper for popular engines like libpcap, WinPcap, DPDK and PF_RING. It also contains parsing and edit capabilities for many protocols including Ethernet, IPv4, IPv6, ARP, VLAN, MPLS, PPPoE, GRE, TCP, UDP, ICMP, DNS as well as layer 7 protocols like HTTP and SSL/TLS\n• pkt2flow: A simple utility to classify packets into flows. It's so simple that only one task is aimed to finish. For Deep Packet Inspection or flow classification, it's so common to analyze the feature of one specific flow. I have make the attempt to use made-ready tools like tcpflows, tcpslice, tcpsplit, but all these tools try to either decrease the trace volume (under requirement) or resemble the packets into flow payloads (over requirement). I have not found a simple tool to classify the packets into flows without further processing.\n• pyshark: A Python wrapper for tshark, allowing python packet parsing using wireshark dissectors. There are quite a few python packet parsing modules, this one is different because it doesn't actually parse any packets, it simply uses tshark's (wireshark command-line utility) ability to export XMLs to use its parsing.\n• Sanitize: Sanitize is a collection of five Bourne shell scripts for reducing tcpdump traces in order to address security and privacy concerns, by renumbering hosts and stripping out packet contents. Each script takes as input a tcpdump trace file and generates to stdout a reduced, ASCII file in fixed-column format.\n• Scapy: Scapy is a powerful interactive packet manipulation program. It is able to forge or decode packets of a wide number of protocols, send them on the wire, capture them, match requests and replies, and much more. It can easily handle most classical tasks like scanning, tracerouting, probing, unit tests, attacks or network discovery (it can replace hping, 85% of nmap, arpspoof, arp-sk, arping, tcpdump, tethereal, p0f, etc.). It also performs very well at a lot of other specific tasks that most other tools can't handle, like sending invalid frames, injecting your own 802.11 frames, combining technics (VLAN hopping+ARP cache poisoning, VOIP decoding on WEP encrypted channel, ...), etc.\n• Sniff: Makes output from the tcpdump program easier to read and parse.\n• Snort: Snort is an open source network intrusion prevention and detection system (IDS/IPS) developed by Sourcefire, now owned by Cisco. Combining the benefits of signature, protocol and anomaly- based inspection, Snort is the most widely deployed IDS/IPS technology worldwide. With millions of downloads and approximately 500,000 registered users, Snort has become the de facto standard for IPS.\n• Socket Sentry: Socket Sentry is a real-time network traffic monitor for KDE Plasma in the same spirit as tools like iftop and netstat.\n• Suricata: Suricata is a free and open source, mature, fast and robust network threat detection engine. The Suricata engine is capable of real time intrusion detection (IDS), inline intrusion prevention (IPS), network security monitoring (NSM) and offline pcap processing.\n• TCP-Reduce: TCP-Reduce is a collection of Bourne shell scripts for reducing tcpdump traces to one-line summaries of each TCP connection present in the trace. The scripts look only at TCP SYN/FIN/RST packets. Connections without SYN packets in the trace (such as those on- going at the beginning of the trace) will not appear in the summary. Garbaged packets (those missing some of their contents) are reported to stderr as bogon's and are discarded. Occasionally the script gets fooled by retransmissions with altered sequence numbers, and reports erroneous huge connection sizes - always check large connections (say 100 MB or more) for plausibility.\n• Tcpdpriv: Tcpdpriv is program for eliminating confidential information (user data and addresses) from packets collected on a network interface (or, from trace files created using the -w argument to tcpdump). Tcpdpriv removes the payload of TCP and UDP, and the entire IP payload for other protocols. It implements several address scrambling methods; the sequential numbering method and its variants, and a hash method with preserving address prefix.\n• Tcpflow: A program that captures data transmitted as part of TCP connections (flows), and stores the data in a way that is convenient for protocol analysis or debugging. A program like 'tcpdump' shows a summary of packets seen on the wire, but usually doesn't store the data that's actually being transmitted. In contrast, tcpflow reconstructs the actual data streams and stores each flow in a separate file for later analysis. Yet, optionally, it can isolate pcap flows per tcp flow for granularized inspection. Original link.\n• Tcplook: Tracelook is an Tcl/TK program for graphically viewing the contents of trace files created using the -w argument to tcpdump. Tracelook should look at all protocols, but presently only looks at TCP connections. The program is slow and uses system resources prodigiously.\n• Tcpreplay: Replays a pcap file on an interface using libnet.\n• Tcpslice: Tcpslice is a tool for extracting portions of packet trace files generated using tcpdump's -w flag. It can combine multiple trace files, and/or extract portions of one or more traces based on time.\n• Tcpsplit: A tool to break a single libpcap packet trace into some number of sub- traces, breaking the trace along TCP connection boundaries so that a TCP connection doesn't end up split across two sub-traces. This is useful for making large trace files tractable for in- depth analysis and for subsetting a trace for developing analysis on only part of a trace.\n• Tcpstat: Tcpstat reports certain network interface statistics much like vmstat does for system statistics. tcpstat gets its information by either monitoring a specific interface, or by reading previously saved tcpdump data from a file.\n• Tcptrace: A tool written by Shawn Ostermann at Ohio University, for analysis of TCP dump files. It can take as input the files produced by several popular packet- capture programs, including tcpdump, snoop, etherpeek, HP Net Metrix, and WinDump. tcptrace can produce several different types of output containing information on each connection seen, such as elapsed time, bytes and segments sent and received, retransmissions, round trip times, window advertisements, throughput, and more. It can also produce a number of graphs for further analysis.\n• TraceWrangler: TraceWrangler is a network capture file toolkit running on Windows (or on Linux, using WINE) that supports PCAP as well as the new PCAPng file format, which is now the standard file format used by Wireshark. The most prominent use case for TraceWrangler is the easy sanitization and anonymization of PCAP and PCAPng files (sometimes called \"trace files\", \"capture files\" or \"packet captures\"), removing or replacing sensitive data while being easy to use.\n• Tstat: A passive sniffer able to provide several insight on the traffic patterns at both the network and transport levels with a tremendous set of flow features.\n• WAND: A wonderful collection of tools built on libtrace to process network traffic, which is from The University of Waikato. I love this project!\n• WinPcap: An extract of a message from Guy Harris on state of WinPcap and WinDump.\n• WireEdit: WireEdit is a free desktop WYSIWYG editor for network packets. It allows editing any stack layer as \"rich text\" without having any knowledge of packets syntax and encoding rules. The input and output file format is Pcap.\n• Wireshark suit: The well-known tool suit to support packet analyzer and protocol decoder. It also includes a few practical tools and scripts to support most of the common usage.\n• Xplot: The program xplot was written in the late 1980s to support the analysis of TCP packet traces.\n• yaraprocessor: With yaraprocessor YARA can be run against individual packet payloads as well as a concatenation of some or all of the payloads. It was originally written for use in Chopshop, but can also be used without it.\n• Zeek: (formerly Bro) is an open source software platform that provides compact, high-fidelity transaction logs, file content, and fully customized output to analysts, from the smallest home office to the largest, fastest research and commercial networks. From the FAQ: \"Zeek provides a comprehensive platform for network traffic analysis, with a particular focus on semantic security monitoring at scale. While often compared to classic intrusion detection/prevention systems, Zeek takes a quite different approach by providing users with a flexible framework that facilitates customized, in-depth monitoring far beyond the capabilities of traditional systems. With initial versions already in operational deployment during the mid ‘90s, Zeek finds itself grounded in more than 20 years of research. For more information, see the Zeek Overview and our promotional document, Why Choose Zeek?.\"\n• dnsgram: dnsgram is a debugging tool for intermittent resolver failures. it takes one or more input PCAP files and generates statistics on 5 second segments allowing the study of intermittent resolver issues.\n• dnsreplay: Dnsreplay takes recorded questions and answers and replays them to the specified nameserver and reporting afterwards which percentage of answers matched, were worse or better. Then compares the answers and some other metrics with the actual ones with those found in the dumpfile.\n• dnsscan: dnsscan takes one or more INFILEs in PCAP format and generates a list of the number of queries per query type.\n• dnsscope: dnsscope takes an input PCAP and generates some simple statistics outputs these to console.\n• dnswasher: dnswasher takes an input file in PCAP format and writes out a PCAP file, while obfuscating end-user IP addresses. This is useful to share data with third parties while attempting to protect the privacy of your users.\n• Chaosreader: A freeware tool to trace TCP/UDP/... sessions and fetch application data from snoop or tcpdump logs. This is a type of \"any-snarf\" program, as it will fetch telnet sessions, FTP files, HTTP transfers (HTML, GIF, JPEG, ...), SMTP emails, ... from the captured data inside network traffic logs. A html index file is created that links to all the session details, including realtime replay programs for telnet, rlogin, IRC, X11 and VNC sessions; and reports such as image reports and HTTP GET/POST content reports.\n• Dsniff: Dsniff is a collection of tools for network auditing and penetration testing. dsniff, filesnarf, mailsnarf, msgsnarf, urlsnarf, and webspy passively monitor a network for interesting data (passwords, e-mail, files, etc.). arpspoof, dnsspoof, and macof facilitate the interception of network traffic normally unavailable to an attacker (e.g, due to layer-2 switching). sshmitm and webmitm implement active monkey-in-the-middle attacks against redirected SSH and HTTPS sessions by exploiting weak bindings in ad-hoc PKI.\n• Foremost: is a console program to recover files based on their headers, footers, and internal data structures. This process is commonly referred to as data carving. Foremost can work on image files, such as those generated by dd, Safeback, Encase, etc, or directly on a drive. The headers and footers can be specified by a configuration file or you can use command line switches to specify built-in file types. These built-in types look at the data structures of a given file format allowing for a more reliable and faster recovery.\n• Justniffer: Justniffer is a network protocol analyzer that captures network traffic and produces logs in a customized way, can emulate Apache web server log files, track response times and extract all \"intercepted\" files from the HTTP traffic.\n• NetworkMiner: NetworkMiner is a Network Forensic Analysis Tool (NFAT) for Windows (but also works in Linux / Mac OS X / FreeBSD). NetworkMiner can be used as a passive network sniffer/packet capturing tool in order to detect operating systems, sessions, hostnames, open ports etc. without putting any traffic on the network. NetworkMiner can also parse PCAP files for off-line analysis and to regenerate/ reassemble transmitted files and certificates from PCAP files.\n• pcapfex - Packet CAPture Forensic Evidence eXtractor (pcapfex) is a tool that finds and extracts files from packet capture files. Its power lies in its ease of use. Just provide it a pcap file, and it will try to extract all of the files. It is an extensible platform, so additional file types to recognize and extract can be added easily.\n• Snort: is an open source network intrusion prevention and detection system (IDS/IPS) developed by Sourcefire, now owned by Cisco. Combining the benefits of signature, protocol and anomaly- based inspection, Snort is the most widely deployed IDS/IPS technology worldwide.\n• Tcpick: is a textmode sniffer libpcap-based that can track, reassemble and reorder tcp streams. Tcpick is able to save the captured flows in different files or displays them in the terminal, and so it is useful to sniff files that are transmitted via ftp or http. It can display all the stream on the terminal, when the connection is closed in different display modes like hexdump, hexdump + ascii, only printable characters, raw mode and so on.\n• Tcpxtract: is a tool for extracting files from network traffic based on file signatures. Extracting files based on file type headers and footers (sometimes called \"carving\") is an age old data recovery technique.\n• Xplico: The goal of Xplico is extract from an internet traffic capture the applications data contained. For example, from a pcap file Xplico extracts each email (POP, IMAP, and SMTP protocols), all HTTP contents, each VoIP call (SIP), FTP, TFTP, and so on. Xplico isn't a network protocol analyzer. Xplico is an open source Network Forensic An alysis Tool (NFAT). Xplico is released under the GNU General Public License and with some scripts under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported (CC BY-NC-SA 3.0) License.\n• USBPcapOdinDumper - transforms .pcap files with and frames format of captures from flashing an Android phone with Odin or Heimdall into a set of files with frames payload. Useful for reverse-engineering. Has a modular architecture easily transformable for other applications formats.\n• BPF for Ultrix: A distribution of BPF for Ultrix 4.2, with both source code and binary modules.\n• BPF+: Exploiting Global Data-flow Optimization in a Generalized Packet Filter Architecture By Andrew Begel, Steven McCanne, and Susan Graham.\n• FFT-FGN-C: is a program for synthesizing a type of self-similar process known as fractional Gaussian noise. The program is fast but approximate. Fractional Gaussian noise is only one type of self-similar process. When using this program for synthesizing network traffic, you must keep in mind that it may be that the traffic you seek is better modeled using one of the other processes.\n• Haka: An open source security oriented language which allows to describe protocols and apply security policies on (live) captured traffic. The scope of Haka language is twofold. First of all, it allows to write security rules in order to filter/alter/drop unwanted packets and log and report malicious activities. Second, Haka features a grammar enabling to specify network protocols and their underlying state machine.\n• RIPE-NCC Hadoop for PCAP: A Hadoop library to read packet capture (PCAP) files. Bundles the code used to read PCAPs. Can be used within MapReduce jobs to natively read PCAP files. Also features a Hive Serializer/Deserializer (SerDe) to query PCAPs using SQL like commands.\n• Traffic Data Repository at the WIDE Project: It becomes increasingly important for both network researchers and operators to know the trend of network traffic and to find anomaly in their network traffic. This paper describes an on-going effort within the WIDE project to collect a set of free tools to build a traffic data repository containing detailed information of our backbone traffic. Traffic traces are collected by tcpdump and, after removing privacy information, the traces are made open to the public. We review the issues on user privacy, and then, the tools used to build the WIDE traffic repository. We will report the current status and findings in the early stage of our IPv6 deployment.\n• Usenix93 Paper on BPF: The libpcap interface supports a filtering mechanism based on the architecture in the BSD packet filter. BPF is described in the 1993 Winter Usenix paper \"The BSD Packet Filter: A New Architecture for User-level Packet Capture\".\n\nTo the extent possible under law, Paul Veillard has waived all copyright and related or neighboring rights to this work."
    },
    {
        "link": "https://stackoverflow.com/questions/61468224/how-to-process-packet-captures-with-pythons-dpkt-module",
        "document": "I am trying to write a python program to parse packet capture using dpkt module. I have used it on packet captures that had Ethernet and tcpdump captures and it worked fine. However, my current packet capture is raw packet capture that directly has IP header and subsequent protocols and it seems like dpkt is not able to understand these captures. Picture of capture file is attached. enter image description here\n\nThe code I had was\n\nAny ideas on how to parse such captures?"
    },
    {
        "link": "https://jon.oberheide.org/blog/2008/10/15/dpkt-tutorial-2-parsing-a-pcap-file",
        "document": "As we showed in the first dpkt tutorial, dpkt makes it simple to construct packets. dpkt is equally useful for parsing packets and files, so in this second tutorial we will demonstrate parsing a PCAP file and the packets contained within it.\n\ndpkt is a sweet framework for creating and parsing packets. While dpkt doesn't have much documentation, once you get the hang of using one module, the rest fall into place fairly easily. I'll be doing a number of dpkt tutorials with simple tasks in hopes of providing some \"documentation by example\". If you have any tasks you'd like to see done in dpkt, drop me a line.\n\nIn this tutorial, we'll not only show how to parse the raw PCAP file format, but also how to parse the packets contained in the PCAP file. Let's get started!\n\nLet's parse a previously captured PCAP file, test.pcap, that contains some HTTP sessions. If we look at the dpkt/pcap.py module, we see that it offers a Reader class that takes a file object and exposes a similar interface to pypcap for reading records from the file. Let's first open test.pcap with the Reader class:\n\nWe can now interate through the pcap object and access each packet contained in the dump. For example, we can print out the timestamp and packet data length of each record:\n\nOf course, it would be a lot more useful to parse the packet data into a more friendly, usable form. Using dpkt, we can simply pass a raw buffer to the appropriate dpkt class and have its contents automatically parsed and decoded into friendly python objects:\n\nPassing the packet data to dpkt's Ethernet class will parse and decode it into the eth object. Since dpkt's Ethernet class also contains some extra magic to parse higher layer protocols that are recognized, we see that both the IP and TCP layer information has been decoded as well:\n\nAs we can see from the output, eth is the Ethernet object, pkt.data is the IP object, and pkt.data.data is the TCP object. We can assign references to these objects in a more friendly manner:\n\nWe can then examine the attributes of the various objects as usual. For example, we can look at the source and destination ports of the TCP header:\n\nOf course, since we know that this packet dump contains HTTP sessions, we may also want to parse beyond the TCP layer and decode the HTTP requests. To do so, we'll ensure that our destination port is 80 (indicating a request as opposed to a response) and that there is data beyond the TCP layer available for parsing. We'll use dpkt's HTTP decoder to parse the data:\n\nOnce the HTTP payload has been parsed, we can examine its various attributes:\n\nFor the purposes of our tutorial program, we'll just output the http.uri attribute.\n\nAnd that concludes our tutorial for parsing a PCAP file and the packets within it. In just 10 simple lines of python, we've created a powerful tool that reads the raw PCAP file, parses and decodes the ethernet, IP, TCP, and HTTP layers, and prints out the URI of the HTTP requests.\n\nThe full python script for this tutorial follows:"
    },
    {
        "link": "https://stackoverflow.com/questions/27458476/pcap-parsing-with-dpkt-python",
        "document": "i am relativly new to python and have a little project where i need to parse pcap and extract certain data. I am now stuck! What i need help with is how to parse de actual data content of the packet stream.\n\nWhat i want to do is to be able to, for instance use a regular expression and if regexp match content of packet print.\n\nSomething like this"
    },
    {
        "link": "https://gendignoux.com/blog/2017/05/30/dpkt-parsing-http2.html",
        "document": "Some time ago I started a project involving analysis of network traffic. It is easy to capture packets and store them in a PCAP file with tcpdump, and to visualize them with Wireshark. But Wireshark is a bit heavy and not really convenient when it comes to custom analysis and scripting. So I looked for Python libraries to parse PCAP files and found dpkt, a lightweight library that supports more than 70 TCP/IP protocols.\n\nFor my project, I needed to parse HTTP/2 packets (RFC 7540). This protocol was not supported yet, but it turned out that dpkt is quite easy to extend! So I wrote a new HTTP/2 parser, which is now integrated in the project on GitHub, and I also completed the list of SSL/TLS cipher suites.\n\nIn this post, I will show you that it is easy to write your own parsers with dpkt.\n\nTo install dpkt, you can simply download the latest release with pip.\n\nAlternatively, if you want the most up-to-date code, you can clone the GitHub repository.\n\nYou can then read a PCAP file with a few lines of Python.\n\nI won’t explain in details how to use dpkt, but you can have a look at full examples on the GitHub repository.\n\nIn this section, we will write a dpkt parser for a toy packet format, that follows the tag-length-value (TLV) paradigm. This paradigm is commonly used in network protocols and binary file formats.\n\nThe specification of our TLV packets is quite simple. Each TLV packet contains three fields:\n\nWe now write a TLV parser in Python. We first import dpkt and create a new class derived from .\n\nIn this class, we then add a field containing the definitions of all header fields. For each field, we need to provide a tuple made of the field name, the field format, and a default value. The field format follows the syntax of . The default value is useful only if you want to create packets; in this example we only consider parsing so we will leave it to zero.\n\nWe have now defined the first two fields of our packet, but we still need to extract N bytes according to the length field. For this we re-implement the method, which takes as argument a byte buffer. We first call the base implementation to extract the headers.\n\nAt this point, fields and are populated, and contains the remaining of the buffer. We can simply truncate it to the correct length, or raise an exception if not enough data is available.\n\nThat’s it! You can now parse a packet by simply constructing a from a byte buffer, e.g. . You can then access , and .\n\nA more interesting function is to parse a stream of concatenated packets. For example, you can imagine application packets collected from the transport layer, but not necessarily aligned to TCP/TLS packets.\n\nLet’s assume that you have collected a byte buffer from underlying TCP/TLS packets. You can extract application packets with the following loop, checking for the exception.\n\nIt turns out that this TLV stream parser is almost a parser for the PNG image format, with the exception that PNG also uses a checksum for each « packet » (called chunk for PNG).\n\nAs we have seen, writing a dpkt parser takes only a few lines of Python code, but here are some tips that you may need in real-world cases.\n\nBy default, dpkt uses big-endian (network) byte order to extract numeric headers with . This means that dpkt adds the modifier if you don’t specify endianness, as we did in our toy example.\n\nIf your format contains little-endian fields, simply add the modifier in corresponding tuples:\n\nIn the case of HTTP/2, the data length is stored in a 24-bit integer field. Unfortunately, does not support unpacking of 24-bit integers out of the box. A practical workaround is to define a 3-byte header field and implement the conversion logic in the function.\n\nHere is an excerpt from HTTP/2.\n\nI hope that this introduction to dpkt was useful! You can now prototype your own parsers for simple binary formats in a few lines of Python. Don’t hesitate to contribute to the project on GitHub or to let me know if you found the HTTP/2 parser useful!\n\nTo react to this blog post please check the Twitter thread.\n\nYou may also like\n\nThe power of interning: making a time series database 2000x smaller in Rust \n\n Rust from a C++ and OCaml programmer's perspective (Part 1) \n\n Making my website 10x smaller in 2024, with a dark mode \n\n Tutorial: Profiling Rust applications in Docker with perf \n\n And 33 more posts on this blog!"
    },
    {
        "link": "https://github.com/kbandla/dpkt/blob/master/examples/print_packets.py",
        "document": "Use DPKT to read in a pcap file and print out the contents of the packets.\n\nThis example is focused on the fields in the Ethernet Frame and IP packet.\n\n\"\"\"Print out information about each packet in a pcap\n\n# For each packet in the pcap process the contents\n\n# Print out the timestamp in UTC\n\n# Make sure the Ethernet data contains an IP packet\n\n# Now access the data within the Ethernet frame (the IP packet)"
    }
]