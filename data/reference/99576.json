[
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/types/casting-and-type-conversions",
        "document": "Because C# is statically typed at compile time, after a variable is declared, it can't be declared again or assigned a value of another type unless that type is implicitly convertible to the variable's type. For example, the can't be implicitly converted to . Therefore, after you declare as an , you can't assign the string \"Hello\" to it, as the following code shows:\n\nHowever, you might sometimes need to copy a value into a variable or method parameter of another type. For example, you might have an integer variable that you need to pass to a method whose parameter is typed as . Or you might need to assign a class variable to a variable of an interface type. These kinds of operations are called type conversions. In C#, you can perform the following kinds of conversions:\n• None Implicit conversions: No special syntax is required because the conversion always succeeds and no data is lost. Examples include conversions from smaller to larger integral types, conversions from derived classes to base classes, and span conversions.\n• None Explicit conversions (casts): Explicit conversions require a cast expression. Casting is required when information might be lost in the conversion, or when the conversion might not succeed for other reasons. Typical examples include numeric conversion to a type that has less precision or a smaller range, and conversion of a base-class instance to a derived class.\n• None User-defined conversions: User-defined conversions use special methods that you can define to enable explicit and implicit conversions between custom types that don't have a base class–derived class relationship. For more information, see User-defined conversion operators.\n• None Conversions with helper classes: To convert between noncompatible types, such as integers and System.DateTime objects, or hexadecimal strings and byte arrays, you can use the System.BitConverter class, the System.Convert class, and the methods of the built-in numeric types, such as Int32.Parse. For more information, see the following articles:\n• None How to convert a byte array to an int\n• None How to convert a string to a number\n• None How to convert between hexadecimal strings and numeric types\n\nFor built-in numeric types, an implicit conversion can be made when the value to be stored can fit into the variable without being truncated or rounded off. For integral types, this restriction means the range of the source type is a proper subset of the range for the target type. For example, a variable of type long (64-bit integer) can store any value that an int (32-bit integer) can store. In the following example, the compiler implicitly converts the value of on the right to a type before assigning it to .\n\nFor a complete list of all implicit numeric conversions, see the Implicit numeric conversions section of the Built-in numeric conversions article.\n\nFor reference types, an implicit conversion always exists from a class to any one of its direct or indirect base classes or interfaces. No special syntax is necessary because a derived class always contains all the members of a base class.\n\nHowever, if a conversion can't be made without a risk of losing information, the compiler requires that you perform an explicit conversion, which is called a cast. A cast is a way of explicitly making the conversion. It indicates you're aware data loss might occur, or the cast might fail at run time. To perform a cast, specify the destination type in parentheses before the expression you want converted. The following program casts a double to an int. The program doesn't compile without the cast.\n\nFor a complete list of supported explicit numeric conversions, see the Explicit numeric conversions section of the Built-in numeric conversions article.\n\nFor reference types, an explicit cast is required if you need to convert from a base type to a derived type:\n\nA cast operation between reference types doesn't change the run-time type of the underlying object; it only changes the type of the value that is being used as a reference to that object. For more information, see Polymorphism.\n\nIn some reference type conversions, the compiler can't determine whether a cast is valid. It's possible for a cast operation that compiles correctly to fail at run time. As shown in the following example, a type cast that fails at run time causes an InvalidCastException to be thrown.\n\nExplicitly casting the argument to a makes a dangerous assumption. It's safer to not make assumptions, but rather check the type. C# provides the operator to enable you to test for compatibility before actually performing a cast. For more information, see How to safely cast using pattern matching and the as and is operators.\n\nFor more information, see the Conversions section of the C# language specification.\n• How to convert a string to a number"
    },
    {
        "link": "https://w3schools.com/cs/cs_type_casting.php",
        "document": "W3Schools offers a wide range of services and products for beginners and professionals, helping millions of people everyday to learn and master new skills."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/user-defined-conversion-operators",
        "document": "A user-defined type can define a custom implicit or explicit conversion from or to another type, provided a standard conversion doesn't exist between the same two types. Implicit conversions don't require special syntax to be invoked and can occur in various situations, for example, in assignments and methods invocations. Predefined C# implicit conversions always succeed and never throw an exception. User-defined implicit conversions should behave in that way as well. If a custom conversion can throw an exception or lose information, define it as an explicit conversion.\n\nThe is and as operators don't consider user-defined conversions. Use a cast expression to invoke a user-defined explicit conversion.\n\nUse the and or keywords to define an implicit or explicit conversion, respectively. The type that defines a conversion must be either a source type or a target type of that conversion. A conversion between two user-defined types can be defined in either of the two types.\n\nThe following example demonstrates how to define an implicit and explicit conversion:\n\nBeginning with C# 11, you can define checked explicit conversion operators. For more information, see the User-defined checked operators section of the Arithmetic operators article.\n\nYou also use the keyword to overload a predefined C# operator. For more information, see Operator overloading.\n\nFor more information, see the following sections of the C# language specification:"
    },
    {
        "link": "https://geeksforgeeks.org/c-sharp-type-casting",
        "document": "Type conversion happens when we assign the value of one data type to another. If the data types are compatible, then C# does Automatic Type Conversion. If not comparable, then they need to be converted explicitly which is known as Explicit Type conversion.\n\nType Casting can be divided into two parts as mentioned below:\n\nIn C# Implicit Type Casting also known as Automatic type conversion refers to the built-in mechanisms that control the flow of execution in your program without explicitly using timers or scheduling objects. These mechanisms are inherent to the language and the underlying runtime environment.\n• None The two data types are compatible.\n• None When we assign the value of a smaller data type to a bigger data type.\n\nThe implicit type casting is done automatically when we try to convert small data into large data types.\n\nIn C#, the numeric data types are compatible with each other but no automatic conversion is supported from numeric type to char or boolean. Also, char and boolean are not compatible with each other. Before converting, the compiler first checks the compatibility accordingly\n\nExample 2: This program gives a compilation error because we try to convert a large data type into a small type\n\nImplicit is not the Solution for such kind of problem where we want to convert a large data type into a small type. So, let check on how we can do this.\n\nExplicit type casting is the process of converting a value of one data type to another data type that is not implicitly compatible. This is necessary when there’s a potential for data loss or when the compiler cannot implicitly perform the conversion. When we try to assign a double value to the int data type it leads to a compilation error when types are not compatible with each other\n\nExample 1: Using Explicit Conversion to convert double into int.\n\nThis solves our some of the problems, but we can also have some available methods that can help us for conversion mentioned below.\n\nThere are some built in methods defined for type conversions mentioned below:"
    },
    {
        "link": "https://stackoverflow.com/questions/1584293/what-is-the-difference-between-explicit-and-implicit-type-casts",
        "document": "This is a little tricky because the \"cast\" syntax in C# actually does a range of different things (cast, primitive convert, bespoke convert, etc)\n\nIn an implicit cast, there is an obvious reference-preserving conversion between the two:\n\nThe compiler can prove that this is safe just from static analysis ( is always an )\n\nWith an explicit cast, either you are telling the compiler that you know more than it does - \"please believe me, but check anyway\":\n\nAlthough this cast is possible, the compiler won't accept that all s are actually - so we must tell it to let it by.\n\nIn an implicit primitive conversion (providedby the language spec), it is generally assumed that there is a safe, non-risky, non-lossy (caveat: see Jon's comment) conversion:\n\nWith an explicit primitive conversion, it is likely that the conversion could lose data, or is non-obvious:\n\nWith bespoke operators, all bets are off, and you'd have to look at the documentation. It could be a reference-cast, or it could be anything. It may follow similar rules to primitive conversions (example: ), or it could do anything randomly:\n\nBoth of these run custom code that is context-specific."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/type-testing-and-cast",
        "document": "These operators and expressions perform type checking or type conversion. The operator checks if the run-time type of an expression is compatible with a given type. The operator explicitly converts an expression to a given type if its run-time type is compatible with that type. Cast expressions perform an explicit conversion to a target type. The operator obtains the System.Type instance for a type.\n\nThe operator checks if the run-time type of an expression result is compatible with a given type. The operator also tests an expression result against a pattern.\n\nThe expression with the type-testing operator has the following form\n\nWhere is an expression that returns a value and is the name of a type or a type parameter. can't be an anonymous method or a lambda expression.\n\nThe operator returns when an expression result is non-null and any of the following conditions are true:\n• None The run-time type of an expression result is .\n• None The run-time type of an expression result derives from type , implements interface , or another implicit reference conversion exists from it to .\n• None The run-time type of an expression result is a nullable value type with the underlying type and the Nullable<T>.HasValue is .\n• None A boxing or unboxing conversion exists from the run-time type of an expression result to type when the expression isn't an instance of a .\n\nThe operator doesn't consider user-defined conversions or implicit span conversions.\n\nThe following example demonstrates that the operator returns if the run-time type of an expression result derives from a given type, that is, there exists a reference conversion between types:\n\nThe next example shows that the operator takes into account boxing and unboxing conversions but doesn't consider numeric conversions:\n\nFor information about C# conversions, see the Conversions chapter of the C# language specification.\n\nThe operator also tests an expression result against a pattern. The following example shows how to use a declaration pattern to check the run-time type of an expression:\n\nFor information about the supported patterns, see Patterns.\n\nThe operator explicitly converts the result of an expression to a given reference or nullable value type. If the conversion isn't possible, the operator returns . Unlike a cast expression, the operator never throws an exception.\n\nThe expression of the form\n\nWhere is an expression that returns a value and is the name of a type or a type parameter, produces the same result as\n\nExcept that is only evaluated once.\n\nThe operator considers only reference, nullable, boxing, and unboxing conversions. You can't use the operator to perform a user-defined conversion. To do that, use a cast expression.\n\nThe following example demonstrates the usage of the operator:\n\nA cast expression of the form performs an explicit conversion of the result of expression to type . If no explicit conversion exists from the type of to type , a compile-time error occurs. At run time, an explicit conversion might not succeed and a cast expression might throw an exception.\n\nThe following example demonstrates explicit numeric and reference conversions:\n\nFor information about supported explicit conversions, see the Explicit conversions section of the C# language specification. For information about how to define a custom explicit or implicit type conversion, see User-defined conversion operators.\n\nYou also use parentheses to call a method or invoke a delegate.\n\nOther use of parentheses is to adjust the order in which to evaluate operations in an expression. For more information, see C# operators.\n\nThe operator obtains the System.Type instance for a type. The argument to the operator must be the name of a type or a type parameter, as the following example shows:\n\nThe argument mustn't be a type that requires metadata annotations. Examples include the following types:\n\nThese types aren't directly represented in metadata. The types include attributes that describe the underlying type. In both cases, you can use the underlying type. Instead of , you can use . Instead of , you can use .\n\nYou can also use the operator with unbound generic types. The name of an unbound generic type must contain the appropriate number of commas, which is one less than the number of type parameters. The following example shows the usage of the operator with an unbound generic type:\n\nAn expression can't be an argument of the operator. To get the System.Type instance for the run-time type of an expression result, use the Object.GetType method.\n\nUse the operator to check if the run-time type of the expression result exactly matches a given type. The following example demonstrates the difference between type checking done with the operator and the operator:\n\nThe , , and operators can't be overloaded.\n\nA user-defined type can't overload the operator, but can define custom type conversions performed by a cast expression. For more information, see User-defined conversion operators.\n\nFor more information, see the following sections of the C# language specification:\n• How to safely cast by using pattern matching and the is and as operators"
    },
    {
        "link": "https://stackoverflow.com/questions/811614/c-sharp-is-keyword-and-checking-for-not",
        "document": "This is a silly question, but you can use this code to check if something is a particular type...\n\nIs there a more elegant way to check for the \"NOT\" instance?\n\nBecause there is some question on what the code looks like, it's just a simple return at the start of a method."
    },
    {
        "link": "https://stackoverflow.com/questions/32776436/which-is-the-best-practice-in-c-sharp-for-type-casting",
        "document": "I think this is a good question, that deserves a serious and detailed answer. Type casts is C# are a lot of different things actually.\n\nUnlike C#, languages like C++ are very strict about these, so I'll use the naming there as reference. I always think it's best to understand how things work, so I'll break it all down here for you with the details. Here goes:\n\nC# has value types and reference types. Reference types always follow an inheritance chain, starting with Object.\n\nBasically if you do , you're actually doing a dynamic cast, and if you're doing (or simply ) you're doing a static cast.\n\nA dynamic cast requires you to do a type check, that is, the runtime will check if the object you are casting to will be of the type. After all, you're casting down the inheritance tree, so you might as well cast to something else completely. If this is the case, you'll end up with an . Because of this, dynamic casts require runtime type information (e.g. it requires the runtime to know what object has what type).\n\nA static cast doesn't require a type check. In this case we're casting up in the inheritance tree, so we already know that the type cast will succeed. No exception will be thrown, ever.\n\nValue type casts are a special type of cast that converts different value types (f.ex. from float to int). I'll get into that later.\n\nIn IL, the only things that are supported are (cast) and (as). The operator is implemented as a with a null check, and is nothing more than a convenient shorthand notation for the combination of them both. In C#, you could write as: .\n\nsimply checks if an object is of a specific type and returns null if it's not. For the static cast case, we can determine this compile-time, for the dynamic cast case we have to check this at runtime.\n\ncasts again check if the type is correct, and throw an exception if it's not. It's basically the same as , but with a throw instead of a result. This might make you wonder why is not implemented as an exception handler -- well, that's probably because exceptions are relatively slow.\n\nA special type of cast happens when you a value type into an object. What basically happens is that the .NET runtime copies your value type on the heap (with some type information) and returns the address as a reference type. In other words: it converts a value type to a reference type.\n\nThis happens when you have code like this:\n\nUnboxing requires you to specify a type. During the unboxing operation, the type is checked (like the dynamic cast case, but it's much simpler because the inheritance chain of a value type is trivial) and if the type matches, the value is copied back on the stack.\n\nYou might expect value type casts to be implicit for boxing -- well, because of the above they're not. The only unboxing operation that's allowed, is the unboxing to the exact value type. In other words:\n\nIf you're casting a to an , you're basically converting the value. For the basic types (IntPtr, (u)int 8/16/32/64, float, double) these conversions are pre-defined in IL as instructions, which are the equivalent of bit casts (int8 -> int16), truncation (int16 -> int8), and conversion (float -> int32).\n\nThere are some funny things going on here by the ways. The runtime seems to work on multitudes of 32-bit values on the stack, so you need conversions even on places where you wouldn't expect them. For example, consider:\n\nSign extension might be tricky to wrap your head around. Computers store signed integer values as 1-complements. In hex notation, int8, this means that the value -1 is 0xFF. So what happens if we cast it to an int32? Again, the 1-complement value of -1 is 0xFFFFFFFF - so we need to propagate the most significant bit to the rest of 'added' bits. If we're doing unsigned extensions, we need to propagate zero's.\n\nThe first cast to int is here zero extended, the second cast to int is sign extended. You also might want to play with the \"x8\" format string to get the hex output.\n\nFor the exact difference between bit casts, truncation and conversion, I refer to the LLVM documentation that explains the differences. Look for / / / and all the variants.\n\nOne other category remains, and that's the conversion operators. MSDN details how you can overload the conversion operators. Basically what you can do is implement your own conversion, by overloading an operator. If you want the user to explicitly specify that you intend to cast, you add the keyword; if you want implicit conversions to happen automagically, you add . Basically you'll get:\n\n... after which you can do stuff like\n\nFirst off, understand the differences, which means implementing small test programs until you understand the distinction between all of the above. There's no surrogate for understanding How Stuff Works.\n\nThen, I'd stick to these practices:\n• The shorthands are there for a reason. Use the notation that's the shortest, it's probably the best one.\n• Don't use casts for static casts; only use casts for dynamic casts.\n• Only use boxing if you need it. The details of this go well beyond this answer; basically what I'm saying is: use the correct type, don't wrap everything.\n• Notice compiler warnings about implicit conversions (f.ex. unsigned/signed) and always resolve them with explicit casts. You don't want to get surprises with strange values due to sign/zero extension.\n• In my opinion, unless you know exactly what you're doing, it's best to simply avoid the implicit/explicit conversion -- a simple method call is usually better. The reason for this is that you might end up with an exception on the loose, that you didn't see coming."
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/tutorials/safely-cast-using-pattern-matching-is-and-as-operators",
        "document": "How to safely cast by using pattern matching and the is and as operators\n\nBecause objects are polymorphic, it's possible for a variable of a base class type to hold a derived type. To access the derived type's instance members, it's necessary to cast the value back to the derived type. However, a cast creates the risk of throwing an InvalidCastException. C# provides pattern matching statements that perform a cast conditionally only when it will succeed. C# also provides the is and as operators to test if a value is of a certain type.\n\nThe following example shows how to use the pattern matching statement:\n\nThe preceding sample demonstrates a few features of pattern matching syntax. The statement combines the test with an initialization assignment. The assignment occurs only when the test succeeds. The variable is only in scope in the embedded statement where it has been assigned. You can't access later in the same method. The preceding example also shows how to use the operator to convert an object to a specified type.\n\nYou can also use the same syntax for testing if a nullable value type has a value, as shown in the following example:\n\nThe preceding sample demonstrates other features of pattern matching to use with conversions. You can test a variable for the null pattern by checking specifically for the value. When the runtime value of the variable is , an statement checking for a type always returns . The pattern matching statement doesn't allow a nullable value type, such as or , but you can test for any other value type. The patterns from the preceding example aren't limited to the nullable value types. You can also use those patterns to test if a variable of a reference type has a value or it's .\n\nThe preceding sample also shows how you use the type pattern in a statement where the variable may be one of many different types.\n\nIf you want to test if a variable is a given type, but not assign it to a new variable, you can use the and operators for reference types and nullable value types. The following code shows how to use the and statements that were part of the C# language before pattern matching was introduced to test if a variable is of a given type:\n\nAs you can see by comparing this code with the pattern matching code, the pattern matching syntax provides more robust features by combining the test and the assignment in a single statement. Use the pattern matching syntax whenever possible."
    },
    {
        "link": "https://code-maze.com/type-checking-type-casting-csharp",
        "document": "In this article, we are going to learn various ways of converting a value from one type to another (type casting) and how to check the type of a value at run time (type checking).\n\nIn any statically-typed language, a value has an assigned type that can’t be changed after its creation.\n\nHowever, sometimes we need to copy that value to another variable or use it in a method parameter that has a different type. In that situation, we can use several ways to coerce a value of type A into type B (type casting).\n\nWhen a type can be safely converted to another type without losing data, the compiler will let us assign the new value without any special syntax.\n\nFor instance, we can implicitly assign a numeric value to a variable whose type has a wider range of values than the initial type:\n\nFor reference types, there’s always an implicit conversion to its direct or indirect base types:\n\nThere are situations where a value may be converted to another type but there is a risk of data loss or the conversion may fail for other reasons. In these cases, there will be no implicit conversion in place and we’ll have to use a cast expression:\n\nCast expressions consist of using parenthesis to the left of an expression to enclose the type we want the result of the expression to be converted to. Be aware that, if the value overflows the destination type, you may get the wrong data or an overflow exception depending on your compiler configuration.\n\nWhen working with reference types, we need to use cast expressions when converting a base type to a derived type:\n\nUsually, the compiler tries to catch an invalid cast expression and throws a compile-time error. However, that’s not always possible so, in some cases, we can get an :\n\nWe can use the as operator to perform explicit casts instead of the parentheses syntax. The difference is that the operator doesn’t throw a run-time exception in case of an invalid cast. In that case, the conversion will simply result in a null value:\n\nWe can use the operator only with reference or nullable types. The operator doesn’t consider user-defined conversions, for user-defined conversions use a cast expression.\n\nThe method will convert a string to another type provided the string has the correct format:\n\nThis operation will throw a at runtime if the string doesn’t have the right format for the conversion.\n\nWe can use the TryParse() variant to avoid having to handle exceptions. returns a value indicating whether the operation succeeded. The converted value will be stored in an output parameter:\n\nThe class exposes many static type conversion methods between basic types:\n\nFinally, we can use the class to convert basic types from and to their basic representation as byte arrays:\n\nWhen creating our reference types we can implement implicit and explicit type conversions using operator overload syntax:\n\nHere, we are creating a custom type and its implicit conversion to the base type. Also, we are overloading the explicit cast operator to allow conversions from to using cast expressions:\n\nWe will often find ourselves in situations where we need to determine whether a given value or instance belongs to a specific reference or base type, that’s what we call type checking.\n\nIn C#, the class represents a type at run-time. It is useful in many scenarios, type checking is one of them.\n\nThe operator receives the name of a type as a parameter and returns the class instance for that type:\n\nAlso, we can use with type parameters:\n\nHere, we define a function that takes a type parameter and uses to get the related instance. After that, we use the property of the class to return the type’s name to the caller. Note that the returned type names correspond to the boxed types.\n\nWe can call the method on any instance or value at run-time to get its associated instance of the class:\n\nHow to Type Check With typeof() And GetType()\n\nUsing both and we can type check any value at run-time:\n\nHere, we start with an array of values of different types. Next, we call the method on each value to get its associated run-time type definition. After that, we compare that type definition with the result of using the operator on different type names to determine whether a value is of a certain known type.\n\nNote that we are using the method to compare instances. This way, we ensure that we are correctly comparing values and not references.\n\nA more succinct and safe way to type check is to use the is operator. The operator takes a value or expression to its left and a type identifier to its right and returns true if the type of the value on the left is compatible with the type on the right:\n\nStarting with C# 7, it is possible to perform safe castings using the operator and type patterns:\n\nLet’s assume that the variable is of type and we don’t know at run-time what kind of data will it contain. We use the operator and the type pattern to conditionally create a local variable that will contain the converted data. If the value in the variable is not a the conditional expression will resolve to false and the conversion will not take place.\n\nIn this article, we’ve learned how implicit and explicit type casting works. We’ve also learned about some conversion helper methods and how to implement our custom-type conversions.\n\nAdditionally, we’ve seen some examples of how to type-check value types at run-time and we’ve learned what and operators are and how to use them."
    }
]