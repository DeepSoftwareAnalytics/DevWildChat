[
    {
        "link": "https://numpy.org/doc/2.1/reference/random/generated/numpy.random.choice.html",
        "document": "This function uses the C-long dtype, which is 32bit on windows and otherwise 64bit on 64bit platforms (and 32bit on 32bit ones). Since NumPy 2.0, NumPy’s default integer is 32bit on 32bit platforms and 64bit on 64bit platforms.\n\nIf an ndarray, a random sample is generated from its elements. If an int, the random sample is generated as if it were Output shape. If the given shape is, e.g., , then samples are drawn. Default is None, in which case a single value is returned. Whether the sample is with or without replacement. Default is True, meaning that a value of can be selected multiple times. The probabilities associated with each entry in a. If not given, the sample assumes a uniform distribution over all entries in . If a is an int and less than zero, if a or p are not 1-dimensional, if a is an array-like of size 0, if p is not a vector of probabilities, if a and p have different lengths, or if replace=False and the sample size is greater than the population size\n\nSetting user-specified probabilities through uses a more general but less efficient sampler than the default. The general sampler produces a different sample than the optimized sampler even if each element of is 1 / len(a).\n\nSampling random rows from a 2-D array is not possible with this function, but is possible with through its keyword.\n\nGenerate a uniform random sample from np.arange(5) of size 3 without replacement:\n\nGenerate a non-uniform random sample from np.arange(5) of size 3 without replacement:\n\nAny of the above can be repeated with an arbitrary array-like instead of just integers. For instance:"
    },
    {
        "link": "https://numpy.org/doc/2.0/reference/random/generated/numpy.random.choice.html",
        "document": "This function uses the C-long dtype, which is 32bit on windows and otherwise 64bit on 64bit platforms (and 32bit on 32bit ones). Since NumPy 2.0, NumPy’s default integer is 32bit on 32bit platforms and 64bit on 64bit platforms.\n\nIf an ndarray, a random sample is generated from its elements. If an int, the random sample is generated as if it were Output shape. If the given shape is, e.g., , then samples are drawn. Default is None, in which case a single value is returned. Whether the sample is with or without replacement. Default is True, meaning that a value of can be selected multiple times. The probabilities associated with each entry in a. If not given, the sample assumes a uniform distribution over all entries in . If a is an int and less than zero, if a or p are not 1-dimensional, if a is an array-like of size 0, if p is not a vector of probabilities, if a and p have different lengths, or if replace=False and the sample size is greater than the population size\n\nSetting user-specified probabilities through uses a more general but less efficient sampler than the default. The general sampler produces a different sample than the optimized sampler even if each element of is 1 / len(a).\n\nSampling random rows from a 2-D array is not possible with this function, but is possible with through its keyword.\n\nGenerate a uniform random sample from np.arange(5) of size 3 without replacement:\n\nGenerate a non-uniform random sample from np.arange(5) of size 3 without replacement:\n\nAny of the above can be repeated with an arbitrary array-like instead of just integers. For instance:"
    },
    {
        "link": "https://geeksforgeeks.org/numpy-random-choice-in-python",
        "document": ""
    },
    {
        "link": "https://docs.scipy.org/doc/numpy-1.15.0/reference/generated/numpy.random.choice.html",
        "document": "If an ndarray, a random sample is generated from its elements. If an int, the random sample is generated as if a were np.arange(a) Output shape. If the given shape is, e.g., , then samples are drawn. Default is None, in which case a single value is returned. Whether the sample is with or without replacement The probabilities associated with each entry in a. If not given the sample assumes a uniform distribution over all entries in a.\n\nIf a is an int and less than zero, if a or p are not 1-dimensional, if a is an array-like of size 0, if p is not a vector of probabilities, if a and p have different lengths, or if replace=False and the sample size is greater than the population size"
    },
    {
        "link": "https://stackoverflow.com/questions/58414272/how-does-numpy-random-choice-work-with-replacement",
        "document": "The task is to choose 1000 clients randomly. In the dataset, the number of rows and unique IDs are the same.\n\nI randomly select and then try to select the dataset with choosen IDs:\n\nThe result is quite different: size of is equal to 917. Why aren't there 1000 rows?"
    },
    {
        "link": "https://stackoverflow.com/questions/54058718/why-random-sample-cant-handle-numpy-arrays-but-random-choices-can",
        "document": "Python's module has for sampling with replacement and for sampling without replacement. Although accepts a numpy array and returns a list of randomly selected elements with respect to the first dimension, raises\n\nOn the other hand, will not accept sets, raising\n\nWhat I'm curious about is if this is an oversight or if there's an essential reason for restricting to sequences and sets while is restricted to objects supporting indexing, despite the functions having very similar purposes.\n\nP.S. if anyone is wondering about how to sample an ndarray, samples 1darrays both with and without replacement, and higher-dimension arrays can be effectively sampled with respect to any dimension with advanced indexing where the indices for that dimension are generated with"
    },
    {
        "link": "https://stackoverflow.com/questions/55880687/fast-way-to-generate-samples-with-np-random-choice",
        "document": "I want to generate random sample without replacement for times, like following:\n\nIf the iterations become very large, the overall sampling will be time consuming. Is there any way to speed up this sampling?"
    },
    {
        "link": "https://numpy.org/doc/2.1/reference/random/index.html",
        "document": "The module implements pseudo-random number generators (PRNGs or RNGs, for short) with the ability to draw samples from a variety of probability distributions. In general, users will create a instance with and call the various methods on it to obtain samples from different distributions.\n\nOur RNGs are deterministic sequences and can be reproduced by specifying a seed integer to derive its initial state. By default, with no seed provided, will seed the RNG from nondeterministic data from the operating system and therefore generate different numbers each time. The pseudo-random sequences will be independent for all practical purposes, at least those purposes for which our pseudo-randomness was good for in the first place.\n\nSeeds should be large positive integers. can take positive integers of any size. We recommend using very large, unique numbers to ensure that your seed is different from anyone else’s. This is good practice to ensure that your results are statistically independent from theirs unless you are intentionally trying to reproduce their result. A convenient way to get such a seed number is to use to get an arbitrary 128-bit integer.\n\nSee the documentation on and for more advanced options for controlling the seed in specialized scenarios.\n\nand its associated infrastructure was introduced in NumPy version 1.17.0. There is still a lot of code that uses the older and the functions in . While there are no plans to remove them at this time, we do recommend transitioning to as you can. The algorithms are faster, more flexible, and will receive more improvements in the future. For the most part, can be used as a replacement for . See Legacy random generation for information on the legacy infrastructure, What’s new or different for information on transitioning, and NEP 19 for some of the reasoning for the transition."
    },
    {
        "link": "https://sparkcodehub.com/numpy-random-sampling-guide",
        "document": ""
    },
    {
        "link": "https://numpy.org/doc/2.1/reference/random/generated/numpy.random.choice.html",
        "document": "This function uses the C-long dtype, which is 32bit on windows and otherwise 64bit on 64bit platforms (and 32bit on 32bit ones). Since NumPy 2.0, NumPy’s default integer is 32bit on 32bit platforms and 64bit on 64bit platforms.\n\nIf an ndarray, a random sample is generated from its elements. If an int, the random sample is generated as if it were Output shape. If the given shape is, e.g., , then samples are drawn. Default is None, in which case a single value is returned. Whether the sample is with or without replacement. Default is True, meaning that a value of can be selected multiple times. The probabilities associated with each entry in a. If not given, the sample assumes a uniform distribution over all entries in . If a is an int and less than zero, if a or p are not 1-dimensional, if a is an array-like of size 0, if p is not a vector of probabilities, if a and p have different lengths, or if replace=False and the sample size is greater than the population size\n\nSetting user-specified probabilities through uses a more general but less efficient sampler than the default. The general sampler produces a different sample than the optimized sampler even if each element of is 1 / len(a).\n\nSampling random rows from a 2-D array is not possible with this function, but is possible with through its keyword.\n\nGenerate a uniform random sample from np.arange(5) of size 3 without replacement:\n\nGenerate a non-uniform random sample from np.arange(5) of size 3 without replacement:\n\nAny of the above can be repeated with an arbitrary array-like instead of just integers. For instance:"
    }
]