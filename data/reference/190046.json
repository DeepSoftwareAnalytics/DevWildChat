[
    {
        "link": "https://geeksforgeeks.org/command-pattern-c-design-patterns",
        "document": "The Command Pattern is a behavioral design pattern that focuses on encapsulating a request as an object, thereby decoupling the sender of the request from the receiver. This pattern allows you to parameterize objects with commands, delay or queue a request's execution, and support undoable operations. It's a fundamental pattern for implementing a wide range of functionality in software systems.\n\nThis is an interface or abstract class that declares an execute method, defining the contract for concrete commands. It ensures that all commands have a method to perform their actions.\n\nConcrete command classes implement the Command interface or inherit from the abstract class. Each concrete command encapsulates a specific action to be performed. For instance, you might have concrete commands to turn on lights, open files, or send messages.\n\nThe receiver is responsible for performing the actual work when a command is executed. It knows how to carry out the requested action. For example, in a home automation system, the receiver could be a \"Light\" object that understands how to turn on and off.\n\nThe invoker is responsible for triggering the execution of commands. It holds references to the commands and can execute them. It acts as an intermediary between the sender (client) and the receiver, ensuring that the sender remains decoupled from the receiver.\n\nBelow is the implementation of the Command Pattern in C++:\n\nBelow is the step by step process to implement above problem statement:\n• None Create an interface or base class Command that defines a execute method, which should be implemented by concrete commands.\n• None Implement concrete command classes, such as TurnOnCommand and TurnOffCommand, to encapsulate specific actions for turning electronic devices on and off.\n• None Create a receiver class ElectronicDevice for the electronic devices that need to be controlled. It should have methods to turn the device on and off.\n• None Design an Invoker class RemoteControl to manage and execute the commands. It should provide the following features:\n• None The ability to add commands to specific buttons on the remote control.\n• None A method to press a button, which triggers the associated command's execution.\n• None Demonstrate the functionality by creating instances of electronic devices (e.g., TV, lights), concrete commands (turn on TV, turn off lights), and a remote control.\n• None Users should be able to press the buttons on the remote control to turn electronic devices on and off.\n• None Ensure that the system is flexible and extensible, allowing for easy addition of new electronic devices and commands without modifying existing code.\n\nBelow is the implementation of the above example:\n\nAdvantages of the Command Pattern in C++ Design Patterns\n• Decoupling of Sender and Receiver: The Command Pattern decouples the sender of a request from the receiver, meaning that the sender does not need to know the specifics of how a request is handled. This decoupling promotes a more flexible and maintainable codebase.\n• Command Queueing: Commands can be easily queued, which allows for the implementation of features like undo and redo functionality. This is particularly useful in applications where the order of execution matters.\n• Logging and Auditing: Since each command is encapsulated as an object, it becomes straightforward to log and audit the commands that are executed. This is valuable for tracking system behavior and debugging.\n• Extensibility: The Command Pattern makes it easy to add new commands and expand the functionality of an application without altering existing code. You can introduce new command classes without affecting the existing classes.\n• Support for Composite Commands: By creating composite commands (commands that contain other commands), you can implement complex operations. This is helpful when you need to execute a sequence of actions as a single command.\n• Encapsulation of State: Commands can encapsulate the state required for their execution. This encapsulation ensures that a command has all the information it needs to perform its action.\n\nDisadvantages of the Command Pattern in C++ Design Patterns\n• Code Complexity: Implementing the Command Pattern may lead to a more extensive class hierarchy, particularly when dealing with various types of commands and receivers. This added complexity can be overwhelming for simple systems.\n• Increased Memory Usage: As each command is represented as an object, there can be increased memory overhead, especially when dealing with a large number of commands. This might not be suitable for memory-constrained systems.\n• Potential Performance Overhead: The use of commands and their execution can introduce a slight performance overhead due to the indirection involved in encapsulating requests as objects. In performance-critical applications, this overhead may be a concern.\n• Learning Curve: Understanding and implementing the Command Pattern can be challenging for developers who are new to design patterns. It may require additional training and experience to use it effectively.\n• Limited Use Cases: The Command Pattern is not always the best choice for every scenario. It is most valuable in systems where you need to decouple senders and receivers, implement undo/redo functionality, or log commands. In simpler systems, it might be unnecessary."
    },
    {
        "link": "https://stackoverflow.com/questions/14539624/memory-management-patterns-in-c",
        "document": "The answer to all of your questions ends up being one and the same: it depends on whether you need reference semantics or value semantics (with some caveats to be taken into account).\n\nIf you need reference semantics, which is what you have by default in languages like Java and C# for UDTs (User-defined Data Types) declared with the keyword, then you will have to go for smart pointers. In this scenario you want several clients to hold safe aliases to a specific object, where the word safe encapsulates these two requirements:\n• Avoid dangling references, so that you won't try to access an object that doesn't exist anymore;\n• Avoid objects which outlive all of the references to them, so that you won't leak memory.\n\nThis is what smart pointers do. If you need reference semantics (and if your algorithms are not such to make the overhead of reference counting significant where shared ownership is needed), then you should use smart pointers.\n\nYou do need reference semantics, for instance, when you want the same object to be part of several collections. When you update the object in one collection, you want the representations of the same object in all the other collections to be consistently updated. In this case, you store smart pointers to your objects in those collections. Smart pointers encapsulate the identity of an object rather than its value.\n\nBut if you do not need to create aliases, then value semantics is probably what you should rely on. This is what you get by default in C++ when you declare an object with automatic storage (i.e. on the stack).\n\nOne thing to consider is that STL collections store values, so if you have a , then copies of will be stored in your . Always supposing that you do not need reference semantics, this might become anyway an overhead if your objects are big and expensive to copy around.\n\nTo limit the likelyhood of this scenario, C++11 comes with move operations, which make it possible to efficiently transfer objects by value when the old copy of the object is no more needed.\n\nI will now try to use the above concepts to answer your questions more directly.\n\n1) Should I return this class by value, or by smart pointer?\n\nIt depends on whether you need reference semantics or not. What does the function do with that object? Is the object returned by that function supposed to be shared by many clients? If so, then by smart pointer. If not, is it possible to define an efficient move operation (this is almost always the case)? If so, then by value. If not, by smart pointer.\n\n2) Inside the class, should the vector and the objects be normal members, or should they be stored as smart pointers again?\n\nMost likely as normal members, since vectors are usually meant to be conceptually a part of your object, and their lifetime is therefore bound to the lifetime of the object that embeds them. You rarely want reference semantics in such a scenario, but if you do, then use smart pointers.\n\n3) In the vector, should I store the objects directly, or smart pointers to them again?\n\nSame answer as for point 1): do you need to share those objects? Are you supposed to store aliases to those objects? Do you want changes to those objects to be seen in different parts of your code which refer those objects? If so, then use shared pointers. If not, is it possible to efficiently copy and/or move those objects? If so (most of the time), store values. If not, store smart pointers.\n\n4) What should the getters defined on my Results class return (i.e. values, references or smart pointers)?\n\nSame answer as for point 2): it depends on what you plan to do with the returned objects: do you want them to be shared by many parts of your code? If so, return a smart pointer. If they shall be exclusively owned by just one part, return by value, unless moving/copying those objects is too expensive or not allowed at all (quite unlikely). In that case, return a smart pointer.\n\nAs a side note, please be aware that smart pointers in C++ are a bit trickier than Java/C# references: first of all, you have two main flavors of smart pointers depending on whether shared ownership ( ) or unique ownership ( ) is desired. Secondly, you need to avoid circular references of , which would create islands of objects that keep each other alive even though they are no more reachable by your running code. This is the reason why weak pointers ( ) exist.\n\nThese concept naturally lead to the concept of responsibility for managing the lifetime of an object or (more generally) the management of a used resource. You might want to read about the RAII idiom for instance (Resource Acquisition Is Initialization), and about exception handling in general (writing exception-safe code is one of the main reasons why these techniques exist)."
    },
    {
        "link": "https://gameprogrammingpatterns.com/command.html",
        "document": "Command is one of my favorite patterns. Most large programs I write, games or otherwise, end up using it somewhere. When I’ve used it in the right place, it’s neatly untangled some really gnarly code. For such a swell pattern, the Gang of Four has a predictably abstruse description:\n\nI think we can all agree that that’s a terrible sentence. First of all, it mangles whatever metaphor it’s trying to establish. Outside of the weird world of software where words can mean anything, a “client” is a person — someone you do business with. Last I checked, human beings can’t be “parameterized”.\n\nThen, the rest of that sentence is just a list of stuff you could maybe possibly use the pattern for. Not very illuminating unless your use case happens to be in that list. My pithy tagline for the Command pattern is:\n\nOf course, “pithy” often means “impenetrably terse”, so this may not be much of an improvement. Let me unpack that a bit. “Reify”, in case you’ve never heard it, means “make real”. Another term for reifying is making something “first-class”.\n\nBoth terms mean taking some concept and turning it into a piece of data — an object — that you can stick in a variable, pass to a function, etc. So by saying the Command pattern is a “reified method call”, what I mean is that it’s a method call wrapped in an object.\n\nThat sounds a lot like a “callback”, “first-class function”, “function pointer”, “closure”, or “partially applied function” depending on which language you’re coming from, and indeed those are all in the same ballpark. The Gang of Four later says:\n\nThat would be a better slugline for the pattern than the one they chose.\n\nBut all of this is abstract and nebulous. I like to start chapters with something concrete, and I blew that. To make up for it, from here on out it’s all examples where commands are a brilliant fit.\n\nSomewhere in every game is a chunk of code that reads in raw user input — button presses, keyboard events, mouse clicks, whatever. It takes each input and translates it to a meaningful action in the game:\n\nThis function typically gets called once per frame by the game loop, and I’m sure you can figure out what it does. This code works if we’re willing to hard-wire user inputs to game actions, but many games let the user configure how their buttons are mapped.\n\nTo support that, we need to turn those direct calls to and into something that we can swap out. “Swapping out” sounds a lot like assigning a variable, so we need an object that we can use to represent a game action. Enter: the Command pattern.\n\nThen we create subclasses for each of the different game actions:\n\nIn our input handler, we store a pointer to a command for each button:\n\nNow the input handling just delegates to those:\n\nWhere each input used to directly call a function, now there’s a layer of indirection:\n\nThis is the Command pattern in a nutshell. If you can see the merit of it already, consider the rest of this chapter a bonus.\n\nThe command classes we just defined work for the previous example, but they’re pretty limited. The problem is that they assume there are these top-level , , etc. functions that implicitly know how to find the player’s avatar and make him dance like the puppet he is.\n\nThat assumed coupling limits the usefulness of those commands. The only thing the can make jump is the player. Let’s loosen that restriction. Instead of calling functions that find the commanded object themselves, we’ll pass in the object that we want to order around:\n\nHere, is our “game object” class that represents a character in the game world. We pass it in to so that the derived command can invoke methods on an actor of our choice, like so:\n\nNow, we can use this one class to make any character in the game hop around. We’re just missing a piece between the input handler and the command that takes the command and invokes it on the right object. First, we change so that it returns commands:\n\nIt can’t execute the command immediately since it doesn’t know what actor to pass in. Here’s where we take advantage of the fact that the command is a reified call — we can delay when the call is executed.\n\nThen, we need some code that takes that command and runs it on the actor representing the player. Something like:\n\nAssuming is a reference to the player’s character, this correctly drives him based on the user’s input, so we’re back to the same behavior we had in the first example. But adding a layer of indirection between the command and the actor that performs it has given us a neat little ability: we can let the player control any actor in the game now by changing the actor we execute the commands on.\n\nIn practice, that’s not a common feature, but there is a similar use case that does pop up frequently. So far, we’ve only considered the player-driven character, but what about all of the other actors in the world? Those are driven by the game’s AI. We can use this same command pattern as the interface between the AI engine and the actors; the AI code simply emits objects.\n\nThe decoupling here between the AI that selects commands and the actor code that performs them gives us a lot of flexibility. We can use different AI modules for different actors. Or we can mix and match AI for different kinds of behavior. Want a more aggressive opponent? Just plug-in a more aggressive AI to generate commands for it. In fact, we can even bolt AI onto the player’s character, which can be useful for things like demo mode where the game needs to run on auto-pilot.\n\nBy making the commands that control an actor first-class objects, we’ve removed the tight coupling of a direct method call. Instead, think of it as a queue or stream of commands:\n\nSome code (the input handler or AI) produces commands and places them in the stream. Other code (the dispatcher or actor itself) consumes commands and invokes them. By sticking that queue in the middle, we’ve decoupled the producer on one end from the consumer on the other.\n\nThe final example is the most well-known use of this pattern. If a command object can do things, it’s a small step for it to be able to undo them. Undo is used in some strategy games where you can roll back moves that you didn’t like. It’s de rigueur in tools that people use to create games. The surest way to make your game designers hate you is giving them a level editor that can’t undo their fat-fingered mistakes.\n\nWithout the Command pattern, implementing undo is surprisingly hard. With it, it’s a piece of cake. Let’s say we’re making a single-player, turn-based game and we want to let users undo moves so they can focus more on strategy and less on guesswork.\n\nWe’re conveniently already using commands to abstract input handling, so every move the player makes is already encapsulated in them. For example, moving a unit may look like:\n\nNote this is a little different from our previous commands. In the last example, we wanted to abstract the command from the actor that it modified. In this case, we specifically want to bind it to the unit being moved. An instance of this command isn’t a general “move something” operation that you could use in a bunch of contexts; it’s a specific concrete move in the game’s sequence of turns.\n\nThis highlights a variation in how the Command pattern gets implemented. In some cases, like our first couple of examples, a command is a reusable object that represents a thing that can be done. Our earlier input handler held on to a single command object and called its method anytime the right button was pressed.\n\nHere, the commands are more specific. They represent a thing that can be done at a specific point in time. This means that the input handling code will be creating an instance of this every time the player chooses a move. Something like:\n\nThe fact that commands are one-use-only will come to our advantage in a second. To make commands undoable, we define another operation each command class needs to implement:\n\nAn method reverses the game state changed by the corresponding method. Here’s our previous move command with undo support:\n\nNote that we added some more state to the class. When a unit moves, it forgets where it used to be. If we want to be able to undo that move, we have to remember the unit’s previous position ourselves, which is what and do.\n\nTo let the player undo a move, we keep around the last command they executed. When they bang on Control-Z, we call that command’s method. (If they’ve already undone, then it becomes “redo” and we execute the command again.)\n\nSupporting multiple levels of undo isn’t much harder. Instead of remembering the last command, we keep a list of commands and a reference to the “current” one. When the player executes a command, we append it to the list and point “current” at it.\n\nWhen the player chooses “Undo”, we undo the current command and move the current pointer back. When they choose “Redo”, we advance the pointer and then execute that command. If they choose a new command after undoing some, everything in the list after the current command is discarded.\n\nThe first time I implemented this in a level editor, I felt like a genius. I was astonished at how straightforward it was and how well it worked. It takes discipline to make sure every data modification goes through a command, but once you do that, the rest is easy.\n\nEarlier, I said commands are similar to first-class functions or closures, but every example I showed here used class definitions. If you’re familiar with functional programming, you’re probably wondering where the functions are.\n\nI wrote the examples this way because C++ has pretty limited support for first-class functions. Function pointers are stateless, functors are weird and still require defining a class, and the lambdas in C++11 are tricky to work with because of manual memory management.\n\nThat’s not to say you shouldn’t use functions for the Command pattern in other languages. If you have the luxury of a language with real closures, by all means, use them! In some ways, the Command pattern is a way of emulating closures in languages that don’t have them.\n\nFor example, if we were building a game in JavaScript, we could create a move unit command just like this:\n\nWe could add support for undo as well using a pair of closures:\n\nIf you’re comfortable with a functional style, this way of doing things is natural. If you aren’t, I hope this chapter helped you along the way a bit. For me, the usefulness of the Command pattern really shows how effective the functional paradigm is for many problems.\n• You may end up with a lot of different command classes. In order to make it easier to implement those, it’s often helpful to define a concrete base class with a bunch of convenient high-level methods that the derived commands can compose to define their behavior. That turns the command’s main method into the Subclass Sandbox pattern.\n• In our examples, we explicitly chose which actor would handle a command. In some cases, especially where your object model is hierarchical, it may not be so cut-and-dried. An object may respond to a command, or it may decide to pawn it off on some subordinate object. If you do that, you’ve got yourself the Chain of Responsibility pattern.\n• Some commands are stateless chunks of pure behavior like the in the first example. In cases like that, having more than one instance of that class wastes memory since all instances are equivalent. The Flyweight pattern addresses that. You could make it a singleton too, but friends don’t let friends create singletons."
    },
    {
        "link": "https://stackoverflow.com/questions/17283737/memory-management-with-command-pattern",
        "document": "So, I've got the following Command Pattern implementation, which is contained within a :\n\nThe issue I'm having is that my static analysis tool complains that is not freed or zeroed in the destructor of . However, by adding a in the destructor, I get a memory access error when I delete the Command Pattern object in the map before calling as below:\n\nAm I approaching memory management incorrectly here? I have not done much work with STL maps, so I'm not familiar with an idiomatic approach.\n\nEDIT: How I add elements to the map:\n\nThis is called each time the user chooses to write out the data, so the object used by the various 's is current with the file selected by the user.\n\nNote that is a member variable of ."
    },
    {
        "link": "https://refactoring.guru/design-patterns/cpp",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/9551014/reading-parsing-text-file-input-c",
        "document": "A little background: I am working on a sliding block puzzle for a school project and this is our first using C++ instead of Java. This is the first time I have had to implement something that reads data from a file.\n\nI have a simple question regarding reading input from a text file. I understand how to read the file line by line and hold each line in a string, I want to know if I can parse the string into different data types as the file is read.\n\nCurrently I am reading each line and storing them as strings in a vector for parsing later, and I know there must be a much simpler way to implement this\n\nThe first line holds 2 integers which will indicate the length and width of the grid, the following lines will have 4 integers and a char for use as arguments when creating the blocks.\n\nMy question is this, if I read the file character by character instead, is there a function I can use that will detect if the character is an integer or a char (and ignore the spaces) so I can store them immediately and create the block objects as the file is read? How would i deal with integers >10 in this case?\n\nEDIT: Just noting I am using fstream to read the files, I am unfamiliar with other input methods"
    },
    {
        "link": "https://geeksforgeeks.org/how-to-read-from-a-file-in-cpp",
        "document": "How to Read From a File in C++?\n\nReading from a file means retrieving the data stored inside a file as input in the program. In this article, we will learn how to read data from a file in C++.\n\nThere are two types of files: text files and binary files and the method of reading data from these files also differs from one another.\n\nTo read the content of a text file in C++, we have to first create an input file stream to the file in default flags. After that, we can use any input function such as std::getline() or >> operator to read the textual data and store it in some the string variable. We generally prefer getline() as it reads till the newline, or any specified character is found.\n\nBinary files in C++ are used to store data in the binary form i.e. in the form of 0s and 1s. So, we need to open the input file stream object with the flag. std::getline() function cannot read the data from the binary files so we use the specialized function ifstream::read() of ifstream class that reads the given block of data from the file stream and return it as a character array which can be converted to the required type using reinterprit_cast.\n• buffer : Pointer to the character array where the read data is to be stored.\n\nRead From a File in C++ - FAQs\n\nWhat are the Problems with Reading Objects from Files?\n\nReading primitive or POD data types from the binary files is easy, but things become difficult when we are working with classes. In case of reading objects that have dynamic resources or virtual functions, we have to create special methods that take cares of them while reading and writing. Otherwise, only the pointers to these resources will be read or written. This process is called deserialization of objects in C++.\n\nCan We Use C Functions for Reading Files in C++?\n\nYes, we can use C functions for reading files as C++ is a superset of C and supports all the functions such as fread(), fwrite(), etc. However, it is recommended to use the C++ file handling mechanism for better compatibility and type safety."
    },
    {
        "link": "https://udacity.com/blog/2021/05/how-to-read-from-a-file-in-cpp.html",
        "document": "In your programming journey, there will come a time when you’ll want to start working with real-world data. This kind of data is typically stored in files on disk. Since reading from files involves interacting with your operating system, it amounts to a rather complex task. In this article, we’ll look at C++ streams, file handling, and three different methods for reading data from a file into a C++ program.\n\nIf you come from a high-level programming language like Python, reading a file into a program seems like a simple enough task. You open the file, read its contents and close it. Working with a file might take up one or two lines of your code. In C++, the workflow of reading a file is a bit more complex — there is the added step of reading to or from a stream object. To understand how our C++ programs interact with files, let us now take a look at the concept of streams in C++.\n\nWhat Are C++ Streams?\n\nC++ streams are interfaces for processing sequence-like input and output. If you’ve written a “Hello World” program in C++ before, then you have worked with streams. Let’s briefly go over how this would look:\n\nIn this example, we stream our string object into the character output stream (“cout” for short). cout is part of the iostream library, and an instance of the more general class of output streams (“ostream”). ostream’s sister class is “istream,” a class for handling input streams.\n\nWhen working with files, we employ another subclass of streams: the fstream class (for file stream) consists of ifstreams for input and ofstreams for output to file. For this example, we’ll work with ifstreams, since they allow us to read from a file.\n\nTo read a character sequence from a text file, we’ll need to perform the following steps:\n• Connect it to a file on disk.\n• Read the file’s contents into our stream object.\n\nThe steps that we examine in detail below, register under the action of “file handling.” At each stage, our stream object may occupy different states, which we can check for using the following member functions:\n• bad() returns True if an error occurred while reading from or writing to a stream. If a stream is “bad,” no further operations involving the stream are possible.\n• fail() returns True if an error occurs, but we can still operate on the stream.\n• eof() returns True if the end of the file (EOF) is reached, with False returned otherwise.\n• good() returns True if each of the other three states are false, i.e., the stream is neither bad nor failed, nor has it reached the end of the file.\n\nAnother important method is provided by is_open(). It evaluates to True if a stream object is open. Let’s now finally bring all the components together and read in a file in C++.\n\nSay we have a shopping list stored in a .txt file:\n\nOur goal is to print the list’s contents to the console. Before we start writing our program, let’s include the relevant header files:\n\nWe’re now ready to write our function. Let’s first declare our fstream variable and connect it to a stream object by opening the file:\n\nStrictly speaking, we could have performed that action in a single line, using the class constructor to open the file directly when initializing the stream object:\n\nBefore we get to read the file’s contents into our stream, all that’s left to do is to declare a string variable that can hold the contents:\n\nRead a File in C++ Using the >> Operator\n\nFor starters, let’s use the stream input operator >> to read in our list from the file.\n\nNote that the ifstream destructor closes our file automatically, which is one of the perks of using this class. If we wanted, we could have added an infile.close() command to the end of the program. This is seen as good practice, but it does not really add any value.\n\nWhen we run that function, here’s the output we get on the screen:\n\nThat’s not what we expected. Our function printed only the first item of our shopping list. That’s because the >> operator reads a string only until it encounters a white space character (such as a space or line break). To read the entire file, we can place the line into a while loop:\n\nOnce we reach the end of the file, myfile.good() evaluates to False, causing the while loop to terminate. We can abbreviate the condition as follows:\n\nThis is equivalent to asking if our file is good. How does our code perform now?\n\nTwo things happened here: All our shopping items got chained together, with the last item being printed twice. While the latter has to do with how C++ handles buffered data and is out of the scope of this tutorial, the first was to be expected. After all, >> ignores whitespace, meaning that all the space and newline characters get lost. How can we include that information in the output? The answer to that question lies in the get() function.\n\nRead a File in C++ Using get()\n\nWe’ll replace >> with get(), a member function of our fstream class that reads in one character at a time. The great thing about get() is that it does not ignore white space and instead treats it as a series of ordinary characters. To read in the file’s contents in their entirety, we’ll stick to our while-loop:\n\nHow does the output of our little script look now?\n\nSuccess! Our entire shopping list was printed to the console. To demonstrate that this function really does stream each character one by one, let’s add a little functionality that tells us the position of the stream’s pointer after each output.\n\nThe tellg() function’s name is short for “tell get.” It returns the current position of the pointer as it moves through the input stream. Once the entire file has been traversed, tellg() returns the value -1.\n\nLet’s look at just the first two lines of the output after running the modified code:\n\nFor every get() action, the standard output shows the letter of the input, and the position of the pointer. We can see that every character was indeed processed individually, causing the code to evaluate the pointer’s position after every single character, be it a letter or white space.\n\nRead a File in C++ Using getline()\n\nFor our use case, there’s little point in processing every character separately — after all, we want to print every line from our shopping list to the screen one by one. This calls for getline(), another member function, which reads in the text until it encounters a line break. Here’s how we would modify our code:\n\nThe pointer’s position is now evaluated after every line read in by our file stream.\n\nTo wrap things up, here’s the final version of our script for reading a file in C++ line by line:\n\nAdding an else-condition, as we did at the end of this script, is a good idea if you encounter a problematic file. Instead of simply terminating wordlessly, the script will tell you that it was not able to open the file.\n\nRead a File in C++ Using C-style Read File\n\nAs with many aspects about the C++ language, we have another class for reading from and writing to files that’s a leftover from C, its predecessor. C-style streams are encoded in FILE objects from the cstdio library. stdin and stdout are expressions of type FILE* for handling input and output streams respectively.\n\n\n\nWith C-style file reading, the most important difference to the fstream class is that FILE* objects do not close files for you: If you forget to close your file, it will remain open. That’s why proponents of the fstream class argue that it’s safer to use.\n\nStudy To Become a C++ Developer\n\nLearning to read data from a file into your program is an important step for any aspiring C++ programmer. But it’s just one part of the equation.\n\n\n\nOur course is designed to turn you into a C++ developer. You’ll learn core programming concepts while working on five real-world projects.\n\n\n\nEnroll in Udacity’s C++ Nanodegree program today!"
    },
    {
        "link": "https://stackoverflow.com/questions/7971356/routines-for-parsing-a-text-file-in-c",
        "document": "I would like to parse a text file using C++. I know the syntax of the file and from the computer science point of view I dont think that I have any problems. However, I dont know exactly how to implement the parser in C++. I think there are a number of possibilities:\n• None flex/yacc: I think that the toolchain is a little outdated and I dont think that it would work very well with the rest of my program.\n• None plain C: I could read the entire file into one char array and use pointers for random access. The problem is that the text files might be huge and I really wouldnt want to store them in memory the whole time.\n• None C++ istreams: I think the problem here is that in the process of parsing the file I of couse need some kind of lookahead. If an expression doesn't match then I would of course have to put the chars that I read so far back into the stream. I think that this would become rather ugly using the ungetch function in C++. Also, since the expressions might be rather long, the peek function is probably inadequate for me.\n• None Using boost: Boost supplies regular expressions which would be perfect to recognize tokens, but as far as my research goes, it is not possible to match regular expressions and consume the tokens within the context of an istream.\n\nI also used javacc with java a while back and I have to say that I was very impressed with it. However I don't think that there is anything like this in C++, is there?\n\nI would really appreciate it if anyone with some experience in the area could point me in the right direction."
    },
    {
        "link": "https://geeksforgeeks.org/file-handling-c-classes",
        "document": "File handling is used to store data permanently in a computer. Using file handling we can store our data in secondary memory (Hard disk).\n\nHow to achieve the File Handling\n\nFor achieving file handling we need to follow the following steps:-\n\n STEP 1-Naming a file\n\n STEP 2-Opening a file\n\n STEP 3-Writing data into the file\n\n STEP 4-Reading data from the file\n\n STEP 5-Closing a file.\n\nWe give input to the executing program and the execution program gives back the output. The sequence of bytes given as input to the executing program and the sequence of bytes that comes as output from the executing program are called stream. In other words, streams are nothing but the flow of data in a sequence.\n\nThe input and output operation between the executing program and the devices like keyboard and monitor are known as “console I/O operation”. The input and output operation between the executing program and files are known as “disk I/O operation”.\n\nThe I/O system of C++ contains a set of classes which define the file handling methods. These include ifstream, ofstream and fstream classes. These classes are derived from fstream and from the corresponding iostream class. These classes, designed to manage the disk files, are declared in fstream and therefore we must include this file in any program that uses files. File handling is essential for data storage and retrieval in applications.\n• None This class is the base class for other classes in this class hierarchy.\n• None This class contains the necessary facilities that are used by all the other derived classes for input and output operations.\n• None This class is derived from the class ‘ios’.\n• None The extraction operator(>>) is overloaded in this class to handle input streams from files to the program execution.\n• None This class declares input functions such as get(), getline() and read().\n• None This class is derived from the class ‘ios’.\n• None The insertion operator(<<) is overloaded in this class to handle output streams to files from the program execution.\n• None This class declares output functions such as put() and write().\n• None This class contains a pointer which points to the buffer which is used to manage the input and output streams.\n• None This class provides operations common to the file streams. Serves as a base for fstream, ifstream and ofstream class.\n• None This class contains open() and close() function.\n• None It contains open() function with default input mode.\n• None Inherits the functions get(), getline(), read(), seekg() and tellg() functions from the istream.\n• None It contains open() function with default output mode.\n• None Inherits the functions put(), write(), seekp() and tellp() functions from the ostream.\n• None This class provides support for simultaneous input and output operations.\n• None Inherits all the functions from istream and ostream classes through iostream.\n• None Its purpose is to set the file buffers to read and write.\n• None We can also use file buffer member function to determine the length of the file. \n\n\n\nIn C++, files are mainly dealt by using three classes fstream, ifstream, ofstream available in fstream headerfile. \n\nofstream: Stream class to write on files \n\nifstream: Stream class to read from files \n\nfstream: Stream class to both read and write from/to files.\n\nNow the first step to open the particular file for read or write operation. We can open file by \n\n1. passing file name in constructor at the time of object creation \n\n2. using the open method\n\nBoth ios::app and ios::ate take us to the end of the file when it is opened. The difference between the two modes is that ios :: app allow us to add data to the end of the file only, while ios :: ate mode permits us add data or to modify the existing data anywhere in the file.\n\nProblem Statement : To read and write a File in C++. \n\nExamples:\n\nBelow is the implementation by using ifstream & ofstream classes.\n\nBelow is the implementation by using fstream class."
    },
    {
        "link": "https://stackoverflow.com/questions/21816537/using-strtok-to-parse-command-line-args-in-c",
        "document": "This is not the way strtok works. Subsequent calls to strtok will continue to process the first argument that was supplied in the first call. strtok shall not be used for this as the arguments already have been tokenized, i.e. they are not in one single char array."
    },
    {
        "link": "https://stackoverflow.com/questions/11628346/c-usage-of-strtok-on-string",
        "document": "I tried the following code from one of the guys who answer my previous question.\n\nMy case is I am trying to get the value 1.2597 in this string, and my non functional requirement is to use instead of which is recommend by many fellow coders here.\n\nHowever I got a issue casting result into a cstr* that can use the .\n\nI want to know how I can get 1.2597, and echo it out with"
    },
    {
        "link": "https://geeksforgeeks.org/strtok-strtok_r-functions-c-examples",
        "document": "strtok() and strtok_r() functions in C with examples\n\nC provides two functions strtok() and strtok_r() for splitting a string by some delimiter. Splitting a string is a very common task. For example, we have a comma-separated list of items from a file and we want individual items in an array.\n\nThe strtok() method splits str[] according to given delimiters and returns the next token. It needs to be called in a loop to get all tokens. It returns NULL when there are no more tokens.\n• str: It is the pointer to the string to be tokenized.\n• delims: It is a string containing all delimiters.\n• It returns the pointer to the first token encountered in the string.\n• It returns NULL if there are no more tokens found.\n\nExample 1: C Program to demonstrate how to split a string using strtok().\n\nExample 2: Program to demonstrates the use of the strtok() function to tokenize a string based on a delimiter.\n\nstrtok() can be used to split a string into multiple strings based on some separators. A simple CSV file support might be implemented using this function. CSV files have commas as delimiters.\n\nExample 3: C Program to demonstrate the use of the strtok() function in C to implement a simple CSV file.\n\nJust like strtok() function in C, strtok_r() does the same task of parsing a string into a sequence of tokens. strtok_r() is a reentrant version of strtok(), hence it is thread safe.\n• str: It is the pointer to the string to be tokenized.\n• delims: It is a string containing all delimiters.\n• saveptr: It is a pointer to a char * variable that is used internally by strtok_r() in order to maintain context between successive calls that parse the same string.\n• It returns the pointer to the first token encountered in the string.\n• It returns NULL if there are no more tokens found.\n\nExample 1: a Simple C program to show the use of strtok_r().\n\nExample 2: The below C program demonstrates the use of strtok_r() function for Nested Tokenization.\n\nLet us see the differences between strtok() and strtok_r() functions in a tabular form as shown below:"
    },
    {
        "link": "https://tutorialspoint.com/implementing-of-strtok-function-in-cplusplus",
        "document": "Implementing of strtok() function in C++\n\nThe strtok() function is one of the most utilised functions in C++. Using a delimiter as a guide, this function can divide a text into smaller chunks or tokens. It is simple to work with strings in C++ thanks to the strtok() function. The strtok() function will be thoroughly examined in this article, along with its definition, syntax, algorithm, and various implementation strategies. It is crucial to remember that the strtok function has several restrictions and potential downsides. It cannot be used on const or read-only strings, for instance, because it changes the original string in place. Edge situations and unexpected input, such as empty strings or delimiters that appear repeatedly in a sequence, can also be challenging to manage.\n\nThis function continues to be a useful tool for many programmers despite these drawbacks and is frequently used in a wide range of applications, including text processing, data parsing, and network protocols. It is a flexible and strong function that may significantly streamline many routine programming tasks.\n\nTo split a string into smaller chunks or tokens based on a delimiter, use the strtok() function in C++. A pointer to the string that has to be tokenized and a string with the delimiter characters are the two inputs for the function. A pointer to the string's very first token is returned by the function. As long as there are tokens left in the string, successive calls to the function with the same string parameter will return additional tokens and this happens with the help of NULL pointer in while loop. When calling the'strtok()' function again, supplying NULL as the first argument instructs the function to pick up where it left off with the previous tokenization of the same string.\n\nWhen the function'strtok()' is first called with the input string as the first argument, it starts looking for the first token in the string at the beginning. When it locates the initial token, it terminates it by replacing the delimiter that comes after it with the null character (''0''). When'strtok()' is used again with a NULL pointer as the first argument, the function picks up where it left off with the previous tokenization of the string, that is, directly after the previous token. It keeps looking for the delimiter's next appearance.\n\n- `str` is a pointer to the string to be tokenized.\n\n- `delimiters` is a string containing the delimiter characters.\n• None Step 1 − The `strtok()` function takes two arguments - the first argument is the input string to be tokenized and the second argument is a string containing all the delimiters that should be used to split the input string into tokens.\n• None Step 2 − When the function is called for the first time, the input string is passed as the first argument, and the delimiter string is passed as the second argument.\n• None Step 3 − The function searches for the first occurrence of any of the delimiter characters in the input string.\n• None Step 4 − When it finds a delimiter character, it replaces it with a null terminator (`'\\0'`) and returns a pointer to the beginning of the first token.\n• None Step 5 − The next time the function is called, the first argument should be set to `NULL` instead of the original input string. This tells the function to continue where it left off and search for the next token in the string.\n• None Step 6 − The function continues to search for delimiter characters and returns pointers to the beginning of subsequent tokens until it reaches the end of the string, at which point it returns `NULL`.\n\nApproach 1 − Program to show code using a loop with strtok() function and single delimeter.\n\nApproach 2 − Program to show code using a loop with strtok() function and multiple delimeter\n\nBelow is the program to show code using a loop with strtok() function and single delimeter\n\nThis example demonstrates how to tokenize a string by space using strtok. The input string str is first passed to strtok along with the delimiter \" \". The first call to strtok returns a pointer to the first token (\"Hi,\"), which is printed to the console. strtok continues to tokenize the string until there are no more tokens, and each token is printed to the console. Note that for subsequent calls to strtok, we pass a null pointer as the first argument, indicating that we want to continue tokenizing the original string\n\nBelow is the program to show code using a loop with strtok() function with multiple delimeters.Below is the program code for the same.\n\nThe '|' and'' (space) delimiters are used to tokenize the string \"The boy|is|standing|with his pet|lazy dog.\" in this example. Once with the string as the first argument and the characters '|' and'' as the second argument, the strtok() method is called twice. Following calls return the remaining tokens, the initial call returns the first token, \"The.\" Until all tokens have been extracted, the loop keeps running.\n\nIn conclusion, the C++ strtok function is a helpful and effective tool for manipulating strings. Even though it has significant restrictions and potential downsides, it is nevertheless a common option for parsing and processing text data and is a useful tool for any coder."
    },
    {
        "link": "https://cboard.cprogramming.com/c-programming/91337-trying-use-strtok-function-parse-cl.html",
        "document": ""
    }
]