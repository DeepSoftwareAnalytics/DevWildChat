[
    {
        "link": "https://pytorch.org/examples",
        "document": "This example demonstrates how to train a multi-layer recurrent neural network (RNN), such as Elman, GRU, or LSTM, or Transformer on a language modeling task by using the Wikitext-2 dataset.\n\nThis example demonstrates how you can train some of the most popular model architectures, including ResNet, AlexNet, and VGG on the ImageNet dataset.\n\nHOGWILD! is a scheme that allows Stochastic Gradient Descent (SGD) parallelization without memory locking. This example demonstrates how to perform HOGWILD! training of shared ConvNets on MNIST.\n\nTraining a CartPole to balance in OpenAI Gym with actor-critic This reinforcement learning tutorial demonstrates how to train a CartPole to balance in the OpenAI Gym toolkit by using the Actor-Critic method.\n\nThis beginner example demonstrates how to use LSTMCell to learn sine wave signals to predict the signal values in the future.\n\nThe PyTorch C++ frontend is a C++14 library for CPU and GPU tensor computation. This set of examples includes a linear regression, autograd, image recognition (MNIST), and other useful examples using PyTorch C++ frontend.\n\nThis example implements the paper The Forward-Forward Algorithm: Some Preliminary Investigations by Geoffrey Hinton. on the MNIST database. It is an introductory example to the Forward-Forward algorithm."
    },
    {
        "link": "https://pytorch.org/docs/stable/generated/torch.nn.LSTM.html",
        "document": "Apply a multi-layer long short-term memory (LSTM) RNN to an input sequence. For each element in the input sequence, each layer computes the following function:\n\n\\begin{array}{ll} \\\\ i_t = \\sigma(W_{ii} x_t + b_{ii} + W_{hi} h_{t-1} + b_{hi}) \\\\ f_t = \\sigma(W_{if} x_t + b_{if} + W_{hf} h_{t-1} + b_{hf}) \\\\ g_t = \\tanh(W_{ig} x_t + b_{ig} + W_{hg} h_{t-1} + b_{hg}) \\\\ o_t = \\sigma(W_{io} x_t + b_{io} + W_{ho} h_{t-1} + b_{ho}) \\\\ c_t = f_t \\odot c_{t-1} + i_t \\odot g_t \\\\ h_t = o_t \\odot \\tanh(c_t) \\\\ \\end{array}\n\nwhere ht​ is the hidden state at time , ct​ is the cell state at time , xt​ is the input at time , ht−1​ is the hidden state of the layer at time or the initial hidden state at time , and it​, ft​, gt​, ot​ are the input, forget, cell, and output gates, respectively. σ is the sigmoid function, and ⊙ is the Hadamard product.\n\nIn a multilayer LSTM, the input xt(l)​ of the l -th layer ( l≥2) is the hidden state ht(l−1)​ of the previous layer multiplied by dropout δt(l−1)​ where each δt(l−1)​ is a Bernoulli random variable which is 0 with probability .\n\nIf is specified, LSTM with projections will be used. This changes the LSTM cell in the following way. First, the dimension of ht​ will be changed from to (dimensions of Whi​ will be changed accordingly). Second, the output hidden state of each layer will be multiplied by a learnable projection matrix: ht​=Whr​ht​. Note that as a consequence of this, the output of LSTM network will be of different shape as well. See Inputs/Outputs sections below for exact dimensions of all variables. You can find more details in https://arxiv.org/abs/1402.1128.\n• None input: tensor of shape (L,Hin​) for unbatched input, (L,N,Hin​) when or (N,L,Hin​) when containing the features of the input sequence. The input can also be a packed variable length sequence. See or for details.\n• None h_0: tensor of shape (D∗num_layers,Hout​) for unbatched input or (D∗num_layers,N,Hout​) containing the initial hidden state for each element in the input sequence. Defaults to zeros if (h_0, c_0) is not provided.\n• None c_0: tensor of shape (D∗num_layers,Hcell​) for unbatched input or (D∗num_layers,N,Hcell​) containing the initial cell state for each element in the input sequence. Defaults to zeros if (h_0, c_0) is not provided. \\begin{aligned} N ={} & \\text{batch size} \\\\ L ={} & \\text{sequence length} \\\\ D ={} & 2 \\text{ if bidirectional=True otherwise } 1 \\\\ H_{in} ={} & \\text{input\\_size} \\\\ H_{cell} ={} & \\text{hidden\\_size} \\\\ H_{out} ={} & \\text{proj\\_size if } \\text{proj\\_size}>0 \\text{ otherwise hidden\\_size} \\\\ \\end{aligned}\n• None output: tensor of shape (L,D∗Hout​) for unbatched input, (L,N,D∗Hout​) when or (N,L,D∗Hout​) when containing the output features from the last layer of the LSTM, for each . If a has been given as the input, the output will also be a packed sequence. When , will contain a concatenation of the forward and reverse hidden states at each time step in the sequence.\n• None h_n: tensor of shape (D∗num_layers,Hout​) for unbatched input or (D∗num_layers,N,Hout​) containing the final hidden state for each element in the sequence. When , will contain a concatenation of the final forward and reverse hidden states, respectively.\n• None c_n: tensor of shape (D∗num_layers,Hcell​) for unbatched input or (D∗num_layers,N,Hcell​) containing the final cell state for each element in the sequence. When , will contain a concatenation of the final forward and reverse cell states, respectively.\n\nThere are known non-determinism issues for RNN functions on some versions of cuDNN and CUDA. You can enforce deterministic behavior by setting the following environment variables: On CUDA 10.1, set environment variable . This may affect performance. On CUDA 10.2 or later, set environment variable (note the leading colon symbol) or . See the cuDNN 8 Release Notes for more information."
    },
    {
        "link": "https://pytorch.org/docs/stable/generated/torch.nn.GRU.html",
        "document": "Apply a multi-layer gated recurrent unit (GRU) RNN to an input sequence. For each element in the input sequence, each layer computes the following function:\n\nwhere ht​ is the hidden state at time , xt​ is the input at time , h(t−1)​ is the hidden state of the layer at time or the initial hidden state at time , and rt​, zt​, nt​ are the reset, update, and new gates, respectively. σ is the sigmoid function, and ⊙ is the Hadamard product.\n\nIn a multilayer GRU, the input xt(l)​ of the l -th layer ( l≥2) is the hidden state ht(l−1)​ of the previous layer multiplied by dropout δt(l−1)​ where each δt(l−1)​ is a Bernoulli random variable which is 0 with probability .\n• None input_size – The number of expected features in the input\n• None hidden_size – The number of features in the hidden state\n• None num_layers – Number of recurrent layers. E.g., setting would mean stacking two GRUs together to form a , with the second GRU taking in outputs of the first GRU and computing the final results. Default: 1\n• None bias – If , then the layer does not use bias weights and . Default:\n• None batch_first – If , then the input and output tensors are provided as instead of . Note that this does not apply to hidden or cell states. See the Inputs/Outputs sections below for details. Default:\n• None dropout – If non-zero, introduces a layer on the outputs of each GRU layer except the last layer, with dropout probability equal to . Default: 0\n• None input: tensor of shape (L,Hin​) for unbatched input, (L,N,Hin​) when or (N,L,Hin​) when containing the features of the input sequence. The input can also be a packed variable length sequence. See or for details.\n• None h_0: tensor of shape (D∗num_layers,Hout​) or (D∗num_layers,N,Hout​) containing the initial hidden state for the input sequence. Defaults to zeros if not provided.\n• None output: tensor of shape (L,D∗Hout​) for unbatched input, (L,N,D∗Hout​) when or (N,L,D∗Hout​) when containing the output features from the last layer of the GRU, for each . If a has been given as the input, the output will also be a packed sequence.\n• None h_n: tensor of shape (D∗num_layers,Hout​) or (D∗num_layers,N,Hout​) containing the final hidden state for the input sequence.\n\nThe calculation of new gate nt​ subtly differs from the original paper and other frameworks. In the original implementation, the Hadamard product (⊙) between rt​ and the previous hidden state h(t−1)​ is done before the multiplication with the weight matrix and addition of bias: This is in contrast to PyTorch implementation, which is done after Whn​h(t−1)​ This implementation differs on purpose for efficiency."
    },
    {
        "link": "https://pytorch.org/docs/stable/nn.html",
        "document": "These are the basic building blocks for graphs:\n\nApplies a 1D convolution over an input signal composed of several input planes. Applies a 2D convolution over an input signal composed of several input planes. Applies a 3D convolution over an input signal composed of several input planes. Applies a 1D transposed convolution operator over an input image composed of several input planes. Applies a 2D transposed convolution operator over an input image composed of several input planes. Applies a 3D transposed convolution operator over an input image composed of several input planes. A module with lazy initialization of the argument. A module with lazy initialization of the argument. A module with lazy initialization of the argument. A module with lazy initialization of the argument. A module with lazy initialization of the argument. A module with lazy initialization of the argument. Combines an array of sliding local blocks into a large containing tensor.\n\nApplies a 1D max pooling over an input signal composed of several input planes. Applies a 2D max pooling over an input signal composed of several input planes. Applies a 3D max pooling over an input signal composed of several input planes. Applies a 1D average pooling over an input signal composed of several input planes. Applies a 2D average pooling over an input signal composed of several input planes. Applies a 3D average pooling over an input signal composed of several input planes. Applies a 2D fractional max pooling over an input signal composed of several input planes. Applies a 3D fractional max pooling over an input signal composed of several input planes. Applies a 1D power-average pooling over an input signal composed of several input planes. Applies a 2D power-average pooling over an input signal composed of several input planes. Applies a 3D power-average pooling over an input signal composed of several input planes. Applies a 1D adaptive max pooling over an input signal composed of several input planes. Applies a 2D adaptive max pooling over an input signal composed of several input planes. Applies a 3D adaptive max pooling over an input signal composed of several input planes. Applies a 1D adaptive average pooling over an input signal composed of several input planes. Applies a 2D adaptive average pooling over an input signal composed of several input planes. Applies a 3D adaptive average pooling over an input signal composed of several input planes.\n\nPads the input tensor using the reflection of the input boundary. Pads the input tensor using the reflection of the input boundary. Pads the input tensor using the reflection of the input boundary. Pads the input tensor using replication of the input boundary. Pads the input tensor using replication of the input boundary. Pads the input tensor using replication of the input boundary. Pads the input tensor boundaries with zero. Pads the input tensor boundaries with zero. Pads the input tensor boundaries with zero. Pads the input tensor boundaries with a constant value. Pads the input tensor boundaries with a constant value. Pads the input tensor boundaries with a constant value. Pads the input tensor using circular padding of the input boundary. Pads the input tensor using circular padding of the input boundary. Pads the input tensor using circular padding of the input boundary.\n\nCreates a criterion that measures the mean absolute error (MAE) between each element in the input x and target y. Creates a criterion that measures the mean squared error (squared L2 norm) between each element in the input x and target y. This criterion computes the cross entropy loss between input logits and target. Creates a criterion that measures the Binary Cross Entropy between the target and the input probabilities: This loss combines a layer and the in one single class. Creates a criterion that measures the loss given inputs x1, x2, two 1D mini-batch or 0D , and a label 1D mini-batch or 0D y (containing 1 or -1). Measures the loss given an input tensor x and a labels tensor y (containing 1 or -1). Creates a criterion that optimizes a multi-class multi-classification hinge loss (margin-based loss) between input x (a 2D mini-batch ) and output y (which is a 2D of target class indices). Creates a criterion that uses a squared term if the absolute element-wise error falls below delta and a delta-scaled L1 term otherwise. Creates a criterion that uses a squared term if the absolute element-wise error falls below beta and an L1 term otherwise. Creates a criterion that optimizes a two-class classification logistic loss between input tensor x and target tensor y (containing 1 or -1). Creates a criterion that optimizes a multi-label one-versus-all loss based on max-entropy, between input x and target y of size (N,C). Creates a criterion that measures the loss given input tensors x1​, x2​ and a label y with values 1 or -1. Creates a criterion that optimizes a multi-class classification hinge loss (margin-based loss) between input x (a 2D mini-batch ) and output y (which is a 1D tensor of target class indices, 0≤y≤x.size(1)−1): Creates a criterion that measures the triplet loss given an input tensors x1, x2, x3 and a margin with a value greater than 0. Creates a criterion that measures the triplet loss given input tensors a, p, and n (representing anchor, positive, and negative examples, respectively), and a nonnegative, real-valued function (\"distance function\") used to compute the relationship between the anchor and positive example (\"positive distance\") and the anchor and negative example (\"negative distance\").\n\nClip the gradient norm of an iterable of parameters. Clip the gradient norm of an iterable of parameters. Clip the gradients of an iterable of parameters at specified value. Compute the norm of an iterable of tensors. Scale the gradients of an iterable of parameters given a pre-calculated total norm and desired max norm. Utility functions to flatten and unflatten Module parameters to and from a single vector. Flatten an iterable of parameters into a single vector. Copy slices of a vector into an iterable of parameters. Fuse a convolutional module and a BatchNorm module into a single, new convolutional module. Fuse convolutional module parameters and BatchNorm module parameters into new convolutional module parameters. Fuse a linear module and a BatchNorm module into a single, new linear module. Fuse linear module parameters and BatchNorm module parameters into new linear module parameters. Convert of to The conversion recursively applies to nested , including . Utility functions to apply and remove weight normalization from Module parameters. Apply weight normalization to a parameter in the given module. Apply spectral normalization to a parameter in the given module. Given a module class object and args / kwargs, instantiate the module without initializing parameters / buffers. Abstract base class for creation of new pruning techniques. Utility pruning method that does not prune any units but generates the pruning parametrization with a mask of ones. Prune (currently unpruned) units in a tensor at random. Prune (currently unpruned) units in a tensor by zeroing out the ones with the lowest L1-norm. Prune entire (currently unpruned) channels in a tensor at random. Prune entire (currently unpruned) channels in a tensor based on their L -norm. Prune tensor by removing units with the lowest L1-norm. Prune tensor by removing random channels along the specified dimension. Prune tensor by removing channels with the lowest L -norm along the specified dimension. Globally prunes tensors corresponding to all parameters in by applying the specified . Prune tensor corresponding to parameter called in by applying the pre-computed mask in . Remove the pruning reparameterization from a module and the pruning method from the forward hook. Check if a module is pruned by looking for pruning pre-hooks. Parametrizations implemented using the new parametrization functionality in . Apply an orthogonal or unitary parametrization to a matrix or a batch of matrices. Apply weight normalization to a parameter in the given module. Apply spectral normalization to a parameter in the given module. Utility functions to parametrize Tensors on existing Modules. Note that these functions can be used to parametrize a given Parameter or Buffer given a specific function that maps from an input space to the parametrized space. They are not parameterizations that would transform an object into a parameter. See the Parametrizations tutorial for more information on how to implement your own parametrizations. Remove the parametrizations on a tensor in a module. Context manager that enables the caching system within parametrizations registered with . A sequential container that holds and manages the original parameters or buffers of a parametrized . Utility functions to call a given Module in a stateless manner. Perform a functional call on the module by replacing the module parameters and buffers with the provided ones. Holds the data and list of of a packed sequence."
    },
    {
        "link": "https://github.com/pytorch/pytorch/releases",
        "document": "We are excited to announce the release of PyTorch® 2.6 (release notes)! This release features multiple improvements for PT2: can now be used with Python 3.13; new performance-related knob ; several AOTInductor enhancements. Besides the PT2 improvements, another highlight is FP16 support on X86 CPUs.\n\nNOTE: Starting with this release we are not going to publish on Conda, please see [Announcement] Deprecating PyTorch’s official Anaconda channel for the details.\n\nFor this release the experimental Linux binaries shipped with CUDA 12.6.3 (as well as Linux Aarch64, Linux ROCm 6.2.4, and Linux XPU binaries) are built with CXX11_ABI=1 and are using the Manylinux 2.28 build platform. If you build PyTorch extensions with custom C++ or CUDA extensions, please update these builds to use CXX_ABI=1 as well and report any issues you are seeing. For the next PyTorch 2.7 release we plan to switch all Linux builds to Manylinux 2.28 and CXX11_ABI=1, please see [RFC] PyTorch next wheel build platform: manylinux-2.28 for the details and discussion.\n\nAlso in this release as an important security improvement measure we have changed the default value for parameter of . This is a backward compatibility-breaking change, please see this forum post for more details.\n\nThis release is composed of 3892 commits from 520 contributors since PyTorch 2.5. We want to sincerely thank our dedicated community for your contributions. As always, we encourage you to try these out and report any issues as we improve PyTorch. More information about how to get started with the PyTorch 2-series can be found at our Getting Started page.\n\n*To see a full list of public feature submissions click here.\n\nThis feature enables the user to specify different behaviors (“stances”) that can take between different invocations of compiled functions. One of the stances, for example, is\n\n“eager_on_recompile”, that instructs PyTorch to code eagerly when a recompile is necessary, reusing cached compiled code when possible.\n\nFor more information please refer to the set_stance documentation and the Dynamic Compilation Control with torch.compiler.set_stance tutorial.\n\noffers a standard way of creating custom operators that are backed by user-defined triton kernels.\n\nWhen users turn user-defined triton kernels into custom operators, allows to peek into the implementation, enabling to optimize the triton kernel inside it.\n\nFor more information please refer to the triton_op documentation and the Using User-Defined Triton Kernels with torch.compile tutorial.\n\npreviously only supported Python up to version 3.12. Users can now optimize models with in Python 3.13.\n\nA new package format, “PT2 archive”, has been introduced. This essentially contains a zipfile of all the files that need to be used by AOTInductor, and allows users to send everything needed to other environments. There is also functionality to package multiple models into one artifact, and to store additional metadata inside of the package.\n\nFor more details please see the updated torch.export AOTInductor Tutorial for Python runtime.\n\nIf a user encounters an error while using AOTInductor APIs, AOTInductor Minifier allows creation of a minimal nn.Module that reproduces the error.\n\nFor more information please see the AOTInductor Minifier documentation.\n\nAOTInductor-generated model code has dependency on Pytorch cpp libraries. As Pytorch evolves quickly, it’s important to make sure previously AOTInductor compiled models can continue to run on newer Pytorch versions, i.e. AOTInductor is backward compatible.\n\nIn order to guarantee application binary interface (ABI) backward compatibility, we have carefully defined a set of stable C interfaces in libtorch and make sure AOTInductor generates code that only refers to the specific set of APIs and nothing else in libtorch. We will keep the set of C APIs stable across Pytorch versions and thus provide backward compatibility guarantees for AOTInductor-compiled models.\n\n[Beta] FP16 support for X86 CPUs (both eager and Inductor modes)\n\nFloat16 datatype is commonly used for reduced memory usage and faster computation in AI inference and training. CPUs like the recently launched Intel® Xeon® 6 with P-Cores support Float16 datatype with native accelerator AMX. Float16 support on X86 CPUs was introduced in PyTorch 2.5 as a prototype feature, and now it has been further improved for both eager mode and Torch.compile + Inductor mode, making it Beta level feature with both functionality and performance verified with a broad scope of workloads.\n\nPyTorch user experience on Intel GPUs is further improved with simplified installation steps, Windows release binary distribution and expanded coverage of supported GPU models including the latest Intel® Arc™ B-Series discrete graphics. Application developers and researchers seeking to fine-tune, inference and develop with PyTorch models on Intel® Core™ Ultra AI PCs and Intel® Arc™ discrete graphics will now be able to directly install PyTorch with binary releases for Windows, Linux and Windows Subsystem for Linux 2.\n• Simplified Intel GPU software stack setup to enable one-click installation of the torch-xpu PIP wheels to run deep learning workloads in an out of the box fashion, eliminating the complexity of installing and activating Intel GPU development software bundles.\n• Windows binary releases for torch core, torchvision and torchaudio have been made available for Intel GPUs, and the supported GPU models have been expanded from Intel® Core™ Ultra Processors with Intel® Arc™ Graphics, Intel® Core™ Ultra Series 2 with Intel® Arc™ Graphics and Intel® Arc™ A-Series Graphics to the latest GPU hardware Intel® Arc™ B-Series graphics.\n• Further enhanced coverage of Aten operators on Intel GPUs with SYCL* kernels for smooth eager mode execution, as well as bug fixes and performance optimizations for torch.compile on Intel GPUs.\n\nFor more information regarding Intel GPU support, please refer to Getting Started Guide.\n\nFlexAttention was initially introduced in PyTorch 2.5 to provide optimized implementations for Attention variants with a flexible API. In PyTorch 2.6, X86 CPU support for FlexAttention was added through TorchInductor CPP backend. This new feature leverages and extends current CPP template abilities to support..."
    },
    {
        "link": "https://pythonguis.com/tutorials/pyqt-signals-slots-events",
        "document": "So far we've created a window and added a simple push button widget to it, but the button doesn't do anything. That's not very useful at all -- when you create GUI applications you typically want them to do something! What we need is a way to connect the action of pressing the button to making something happen. In Qt, this is provided by signals and slots or events.\n\nSignals are notifications emitted by widgets when something happens. That something can be any number of things, from pressing a button, to the text of an input box changing, to the text of the window changing. Many signals are initiated by user action, but this is not a rule.\n\nIn addition to notifying about something happening, signals can also send data to provide additional context about what happened.\n\nYou can also create your own custom signals, which we'll explore later.\n\nSlots is the name Qt uses for the receivers of signals. In Python any function (or method) in your application can be used as a slot -- simply by connecting the signal to it. If the signal sends data, then the receiving function will receive that data too. Many Qt widgets also have their own built-in slots, meaning you can hook Qt widgets together directly.\n\nLet's take a look at the basics of Qt signals and how you can use them to hook widgets up to make things happen in your apps.\n\nSave the following app outline to a file named .\n\nOur simple application currently has a with a set as the central widget. Let's start by hooking up this button to a custom Python method. Here we create a simple custom slot named which accepts the signal from the .\n\nRun it! If you click the button you'll see the text \"Clicked!\" on the console.\n\nThat's a good start! We've heard already that signals can also send data to provide more information about what has just happened. The signal is no exception, also providing a checked (or toggled) state for the button. For normal buttons this is always , so our first slot ignored this data. However, we can make our button checkable and see the effect.\n\nIn the following example, we add a second slot which outputs the checkstate.\n\nRun it! If you press the button you'll see it highlighted as checked. Press it again to release it. Look for the check state in the console.\n\nYou can connect as many slots to a signal as you like and can respond to different versions of signals at the same time on your slots.\n\nOften it is useful to store the current state of a widget in a Python variable. This allows you to work with the values like any other Python variable and without accessing the original widget. You can either store these values as individual variables or use a dictionary if you prefer. In the next example we store the checked value of our button in a variable called on .\n\nFirst we set the default value for our variable (to ), then use the default value to set the initial state of the widget. When the widget state changes, we receive the signal and update the variable to match.\n\nYou can use this same pattern with any PyQt widgets. If a widget does not provide a signal that sends the current state, you will need to retrieve the value from the widget directly in your handler. For example, here we're checking the checked state in a pressed handler.\n\nWe need to keep a reference to the button on so we can access it in our slot.\n\nThe released signal fires when the button is released, but does not send the check state, so instead we use to get the check state from the button in our handler.\n\nSo far we've seen how to accept signals and print output to the console. But how about making something happen in the interface when we click the button? Let's update our slot method to modify the button, changing the text and disabling the button so it is no longer clickable. We'll also turn off the checkable state for now.\n\nAgain, because we need to be able to access the in our method, we keep a reference to it on . The text of the button is changed by passing a to . To disable a button call with .\n\nRun it! If you click the button the text will change and the button will become unclickable.\n\nYou're not restricted to changing the button that triggers the signal, you can do anything you want in your slot methods. For example, try adding the following line to method to also change the window title.\n\nMost widgets have their own signals -- and the we're using for our window is no exception. In the following more complex example, we connect the signal on the to a custom slot method.\n\nIn the following example we connect the signal on the to a method slot . This slot also receives the new window title.\n\nFirst we set up a list of window titles -- we'll select one at random from this list using Python's built-in . We hook our custom slot method to the window's signal.\n\nWhen we click the button the window title will change at random. If the new window title equals \"Something went wrong\" the button will be disabled.\n\nRun it! Click the button repeatedly until the title changes to \"Something went wrong\" and the button will become disabled.\n\nThere are a few things to notice in this example.\n\nFirstly, the signal is not always emitted when setting the window title. The signal only fires if the new title is changed from the previous one. If you set the same title multiple times, the signal will only be fired the first time. It is important to double-check the conditions under which signals fire, to avoid being surprised when using them in your app.\n\nSecondly, notice how we are able to chain things together using signals. One thing happening -- a button press -- can trigger multiple other things to happen in turn. These subsequent effects do not need to know what caused them, but simply follow as a consequence of simple rules. This decoupling of effects from their triggers is one of the key concepts to understand when building GUI applications. We'll keep coming back to this throughout the book!\n\nIn this section we've covered signals and slots. We've demonstrated some simple signals and how to use them to pass data and state around your application. Next we'll look at the widgets which Qt provides for use in your applications -- together with the signals they provide.\n\nSo far we've seen examples of connecting widget signals to Python methods. When a signal is fired from the widget, our Python method is called and receives the data from the signal. But you don't always need to use a Python function to handle signals -- you can also connect Qt widgets directly to one another.\n\nIn the following example, we add a widget and a to the window. In the for the window we connect our line edit signal to the method on the . Now any time the text changes in the the will receive that text to it's method.\n\nNotice that in order to connect the input to the label, the input and label must both be defined. This code adds the two widgets to a layout, and sets that on the window. We'll cover layouts in detail later, you can ignore it for now.\n\nRun it! Type some text in the upper box, and you'll see it appear immediately on the label.\n\nAny text typed in the input immediately appears on the label.\n\nMost Qt widgets have slots available, to which you can connect any signal that emits the same type that it accepts. The widget documentation has the slots for each widget listed under \"Public Slots\". For example, see https://doc.qt.io/qt-5/qlabel.html#public-slots[QLabel].\n\nEvery interaction the user has with a Qt application is an event. There are many types of event, each representing a different type of interaction. Qt represents these events using event objects which package up information about what happened. These events are passed to specific event handlers on the widget where the interaction occurred.\n\nBy defining custom, or extended event handlers you can alter the way your widgets respond to these events. Event handlers are defined just like any other method, but the name is specific for the type of event they handle.\n\nOne of the main events which widgets receive is the . QMouseEvent events are created for each and every mouse movement and button click on a widget. The following event handlers are available for handling mouse events --\n\nFor example, clicking on a widget will cause a to be sent to the event handler on that widget. This handler can use the event object to find out information about what happened, such as what triggered the event and where specifically it occurred.\n\nYou can intercept events by sub-classing and overriding the handler method on the class. You can choose to filter, modify, or ignore events, passing them up to the normal handler for the event by calling the parent class function with . These could be added to your main window class as follows. In each case will receive the incoming event.\n\nRun it! Try moving and clicking (and double-clicking) in the window and watch the events appear.\n\nYou'll notice that mouse move events are only registered when you have the button pressed down. You can change this by calling on the window. You may also notice that the press (click) and double-click events both fire when the button is pressed down. Only the release event fires when the button is released. Typically to register a click from a user you should watch for both the mouse down and the release.\n\nInside the event handlers you have access to an event object. This object contains information about the event and can be used to respond differently depending on what exactly has occurred. We'll look at the mouse event objects next.\n\nAll mouse events in Qt are tracked with the object, with information about the event being readable from the following event methods.\n\nYou can use these methods within an event handler to respond to different events differently, or ignore them completely. The positional methods provide both global and local (widget-relative) position information as objects, while buttons are reported using the mouse button types from the namespace.\n\nFor example, the following allows us to respond differently to a left, right or middle click on the window.\n\nThe button identifiers are defined in the Qt namespace, as follows --\n\nOn left-handed mice the left and right button positions are reversed, i.e. pressing the right-most button will return . This means you don't need to account for the mouse orientation in your code.\n\nContext menus are small context-sensitive menus which typically appear when right clicking on a window. Qt has support for generating these menus, and widgets have a specific event used to trigger them. In the following example we're going to intercept the a . This event is fired whenever a context menu is about to be shown, and is passed a single value of type .\n\nTo intercept the event, we simply override the object method with our new method of the same name. So in this case we can create a method on our subclass with the name and it will receive all events of this type.\n\nIf you run the above code and right-click within the window, you'll see a context menu appear. You can set up slots on your menu actions as normal (and re-use actions defined for menus and toolbars).\n\nWhen passing the initial position to the function, this must be relative to the parent passed in while defining. In this case we pass as the parent, so we can use the global position.\n\nJust for completeness, there is actually a signal-based approach to creating context menus.\n\nIt's entirely up to you which you choose.\n\nIn PyQt every widget is part of two distinct hierarchies: the Python object hierarchy, and the Qt layout hierarchy. How you respond or ignore events can affect how your UI behaves.\n\nOften you may want to intercept an event, do something with it, yet still trigger the default event handling behavior. If your object is inherited from a standard widget, it will likely have sensible behavior implemented by default. You can trigger this by calling up to the parent implementation using .\n\nThis is the Python parent class, not the PyQt .\n\nThe event will continue to behave as normal, yet you've added some non-interfering behavior.\n\nWhen you add a widget to your application, it also gets another parent from the layout. The parent of a widget can be found by calling . Sometimes you specify these parents manually, such as for or , often it is automatic. When you add a widget to your main window for example, the main window will become the widget's parent.\n\nWhen events are created for user interaction with the UI, these events are passed to the uppermost widget in the UI. So, if you have a button on a window, and click the button, the button will receive the event first.\n\nIf the first widget cannot handle the event, or chooses not to, the event will bubble up to the parent widget, which will be given a turn. This bubbling continues all the way up nested widgets, until the event is handled or it reaches the main window.\n\nIn your own event handlers you can choose to mark an event as handled calling --\n\nAlternatively, you can mark it as unhandled by calling on the event object. In this case the event will continue to bubble up the hierarchy.\n\nIf you want your widget to appear transparent to events, you can safely ignore events which you've actually responded to in some way. Similarly, you can choose to accept events you are not responding to in order to silence them."
    },
    {
        "link": "https://pythonguis.com/pyqt5-tutorial",
        "document": "PyQt is a Python library for creating GUI applications using the Qt toolkit. Created by Riverbank Computing, PyQt is free software (GPL licensed) and has been in development since 1999. PyQt5 was released in 2016 and last updated in October 2021.\n\nThis complete PyQt5 tutorial takes you from first concepts to building fully-functional GUI applications in Python. It requires some basic Python knowledge, but no previous familiarity with GUI concepts. Everything will be introduced step by by step, using hands-on examples.\n\nPyQt5 is the Qt5-based edition of the Python GUI library PyQt from Riverbank Computing.\n\nThere are two major versions currently in use: PyQt5 based on Qt5 and PyQt6 based on Qt6. Both versions are almost completely compatible aside from imports. PyQt6 also makes some changes to how namespaces and flags work, but these are easily manageable.\n\nLooking for something else? I also have a PyQt6 tutorial, PySide2 tutorial and PySide6 tutorial.\n\nThis track consists of 36 tutorials. Keep checking back as I'm adding new tutorials regularly — last updated ."
    },
    {
        "link": "https://e-education.psu.edu/geog489/book/export/html/1867",
        "document": "There is a wealth of geographic (and other) information available out there on the web in the form of web pages and web services, and sometimes we may want to make use of this information in our Python programs. In the first walkthrough of this lesson, we will access two web services from our Python code that allow us to retrieve information about places based on the places’ names. Another common web-based programming task is scraping the content of web pages with the goal of extracting certain pieces of information from them, for instance links leading to other pages. In this section, we are laying the foundation to perform such tasks in Python by showing some examples of working with URLs and web requests using the urllib and requests packages from the standard Python library, and the BeautifulSoup4 (bs4) package, which is a 3rd party package that you will have to install. Urllib in Python 3 consists of the three main modules urllib.requests for opening and reading URLs, urllib.error defining the exceptions that can be raised, and urllib.parse for parsing URLs. It is quite comprehensive and includes many useful auxiliary functions for working with URLs and communicating with web servers, mainly via the HTTP protocol. Nevertheless, we will only use it to access a web page in this first example here, and then we will switch over to using the requests package instead, which is an easy-to-understand wrapper of the Python package urllib3 for the high-level tasks we are going to perform. In the following example, we use urllib to download the start page from Lesson 1 of this course: After importing the urllib.request module, we define the URL of the page we want to access in a string variable. Then in line 4, we use function urlopen(…) of urllib to send out an HTTP request over the internet to get the page whose URL we provide as a parameter. After a successful request, the response object returned by the function will contain the html code of the page, and we can access it via the read() method (line 5). If you run this example, you will see that the print statement in the last line prints out the raw html code of the Lesson 1 start page. Here is how the same example looks using the requests package rather than urllib: As you can see, for this simple example there really isn’t a big difference in the code. The function used to request the page in line 4 is called get(…) in requests and the raw html code can be accessed by using a property called text of the response object in line 5 not a method, that’s why there are no parentheses after text. The most common things returned by a single web request, at least in our domain, are: Most likely you are at least somewhat familiar with html code and how it uses tags to hierarchically organize the content of a page including semantic and meta information about the content as well as formatting instructions. Most common browsers like Chrome, Firefox, and Edge have some tools to inspect the html code of a page in the browser. Open the first lesson page in a new browser window and then do a right-click -> Inspect (element) on the first bullet point for “1.1 Overview and Checklist” in the middle of the window. That should open up a window in your browser showing the html code with the part that produces this line with the link to the Section 1.1 web page highlighted as in the figure below. Figure 2.1 Lesson 1 start page html code as shown when using the Inspect function of the browser The arrows indicate the hierarchical organization of the html code, the so-called Document Object Model (DOM), and can be used to unfold/fold in part of the code. Also note how most html tags (‘body’,‘div’, ‘a’, ‘span’, etc.) have an attribute “id” that defines a unique ID for that element in the document as well as an attribute “class” which declares the element to be of one or several classes (separated by spaces) that, for instance, affect how the element will be formatted. We cannot provide an introduction to html and DOM here but this should be enough background information to understand the following examples. (These topics are addressed in more detail in our GEOG 863 class.) Unless our program contains a browser component for displaying web pages, we are typically downloading the html code of a web page because we are looking for very specific information in that code. For this, it is helpful to first parse the entire html code and create a hierarchical data structure from it that reflects the DOM structure of the html code and can be used to query for specific html elements in the structure to then access their attributes or content. This is exactly what BeautifulSoup does. Go ahead and install the beautifulsoup4 package in the Python Package Manager of ArcGIS Pro as you did with Spyder in Section 1.5. Once installed, BeautifulSoup will be available under the module name bs4. The following example shows how we can use it to access the <title> element of the html document: In line 6, we are taking the raw html code from response.text and create a BeautifulSoup object from it using an html parser and store it in variable soup. Parsing the html code and creating the hierarchical data structure can take a few seconds. We then call the find(…) method to get the element demarcated by the title tags <title>…</title> in the document. This works fine here for <title> because an html document only contains a single <title> tag. If used with other tags, find(…) will always return only the first element, which may not be the one we are looking for. However, we can provide additional attributes like a class or id for the element we are looking for. For instance, the following command can be used to get the link element (= html tag <a>) that is of the class “print-page”: The output will start with <a class=”print-page” href…” and include the html code for all child elements of this <a> element. The “attrs” keyword argument takes a dictionary that maps attribute names to expected values. If we don’t want to print out all this html code but just a particular attribute of the found element, we can use the get(…) method of the object returned by find(…), for instance with ‘href’ for the attribute that contains the actual link URL: You can also get a list of all elements that match the given criteria, not only the first element, by using the method find_all(…) instead of find(…). But let’s instead look at another method that is even more powerful, the method called select(…). Let’s say what we really want to achieve with our code is extract the link URLs for all the pages linked to from the content list on the page. If you look at the highlighted part in the image above again, you will see that the <a> tags for these links do not have an id or class attribute to distinguish them from other <a> tags appearing in the document. How can we unambiguously characterize these links? What we can say is that these are the links that are formed by a <a> tag within a <li> element within a <ul> element within a <div> element that has the class “book-navigation”. This condition is only satisfied by the links we are interested in. With select(…) we can perform such queries by providing a string that describes these parent-child relationships: The list produced by the code should consist of ten URLs in total. Note how in the string given to select(…) the required class for the <div> element is appended with a dot and how the > symbol is used to describe the parent-child relationships along the chain of elements down to the <a> elements we are interested in. The result is a list of elements that match this condition and we loop through that list in line 2 and print out the “href” attribute of each element to display the URLs. One final example showing the power of BeautifulSoup: The web page www.timeanddate.com, among other things, allows you to look up the current time for a given place name by directly incorporating country and place name into the URL, e.g. … to get a web page showing the current time in State College, PA. Check out the web page returned by this request and use right-click -> Inspect (element) again to check how the digital clock with the current time for State College is produced in the html code. The highlighted line contains a <span> tag with the id “ct”. That makes it easy to extract this information with the help of BeautifulSoup. Here is the full code for this: Obviously, the exact output depends on the time of day you run the code. Please note that in the last line we use time.text to get the content of the <span> tag found, which is what appears between the <span> and </span> tags in the html. We are intentionally only doing this for a single place here because if you ever do this kind of scraping of web pages on a larger scale, you should make sure that this form of usage is not against the web site’s terms of use. In addition, some things can be done to keep the load on the server produced by web scraping as low as possible, e.g. by making sure the results are stored/cached when the program is running and not constantly being queried again unless the result may have changed. In this example, while the time changes constantly, one could still only run the query once, calculate the offset to the local computer’s current time once, and then always recalculate the current time for State College based on this information and the current local time. The examples we have seen so far all used simple URLs, although this last example was already an example where parameters of the query are encoded in the URL (country and place name), and the response was always an html page intended to be displayed in a browser. In addition, there exist web APIs that realize a form of programming interface that can be used via URLs and HTTP requests. Such web APIs are, for instance, available by Twitter to search within recent tweets, by Google Maps, and by Esri. Often there is a business model behind these APIs that requires license fees and some form of authorization. Web APIs often allow for providing additional parameters for a particular request that have to be included in the URL. This works very similar to a function call, just the syntax is a bit different with the special symbol ? used to separate the base URL of a particular web API call from its parameters and the special symbol & used to separate different parameters. Here is an example of using a URL for querying the Google Books API for the query parameter “Zandbergen Python”: www.googleapis.com/books/v1/volumes is the base URL for using the web API to perform this kind of query and q=Zandbergen%20Python is the query parameter specifying what terms we want to search for. The %20 encodes a single space in a URL. If there would be more parameters, they would be separated by & symbols like this: We also mentioned above that one common response format is JSON (JavaScript Object Notation) code. If you actually click the link above, you will see that Google sends back the response as JSON code. JSON is intended to be easily readable by computers not humans, but the good thing is that we as Python programmers are already used to reading it because it is based on notations for arrays (=lists) and objects (=dictionaries) that use the same syntax as Python. Study the JSON response to our Zandbergen query from above for a moment. At the top level we have a dictionary that describes the response. One entry “totalItems” in the dictionary says that the response contains 16 results. The entry “items” contains these results as a list of dictionaries/objects. The first dictionary from the list is the one for our course textbook. One attribute of this dictionary is “volumeInfo”, which is again a dictionary/object whose attributes include the title of the book and name of the author. Please note that the “authors” attribute is again a list because books can have multiple authors. If you scroll down a bit, you will see that at some point the dictionary for the Zandbergen book is closed with a “}” and then a new dictionary for another book starts which is the second item from the “items” list, and so on. After this explanation of web APIs and JSON, here is the Python code to run this query and process the returned JSON code: We here define the base URL for this web API call and the query term string in different variables (lines 3 and 4). You saw above that certain characters like spaces appearing in URLs need to be encoded in certain ways. When we enter such URLs into a browser, the browser will take care of this but if we construct the URL for a request in our code we have to take care of this ourselves. Fortunately, the urllib.parse module provides the function quote(…) for this, which we use in line 6 to construct the correctly encoded parameter list which is then combined with the base url in the call of requests.get(…) in line 8. By using the json() method of the response object in line 9, we get a Python data structure that will represent the JSON response and store it in variable jsonCode. In this case, it is a dictionary that under the key “items” contains a Python list with dictionaries for the individual book items returned. In line 11, we use this data structure to access the 'title' attribute of the first book item in the list: With ['items'] we first get the “items” list, then we take the first element from that list with [0], then we access the 'volumeInfo' property of the resulting dictionary, and finally with ['title'] we get the 'title' attribute from the volume info dictionary. The code from above was supposed to show you how you to explicitly encode parameters for web API requests (with the help of urllib.parse.quote(...)) and build the final URL. The great thing about the requests module is that it can take care of all these things for you: You can simply provide an additional parameter for get(…) that contains a dictionary of parameter names for the web request and what values should be assigned to these parameters. Requests then automatically encodes these values and builds the final URL. Here is the version of the previous example that uses this approach. The dictionary with parameters for the web request that we use in line 6 says that the value assigned to parameter 'q' should be the string contained in variable query. As said, requests will automatically take care of encoding special characters like spaces in the parameter values and of producing the final URL from them. You will see more examples of using web APIs and processing the JSON code returned in the first walkthrough of this lesson. These examples will actually return GeoJSON code which is a standardized approach for encoding spatial features in JSON including their geometry data. Python includes several built in methods for handling JSON (or json). As you remember from Lesson 1, json is widely used to transfer data from one language to another or from one data source to another. For this section we will demonstrate loading it into a Python Dictionary and dumping it to a json string. The official documentation can be found here. Loading json means to convert a formatted string into a json object. This is useful for converting string representations of dictionaries that come from various sources, or from API’s results. It is important to note that there is also json.load(…) which takes an file or bytes like object as an input parameter whereas json.loads(…) takes a json string. The s at the end of loads denotes that the method is for a string input, whereas the load method without the s is for objects such as files. The dump and dumps follows the same convention, except it outputs to a file writer type object or a json string so beware of what type of data you are working with. If you do forget, the Python interpreter will kindly let you know. To write the python dictionary back to a json string, you would use the .dumps() method. # Creating a dictionary wyo_hi_dict = {1:'Welcome', 2:'to', 3:'Cheyenne', 4:'Wyoming'} # Converts input dictionary into # string and stores it in json_string json_string = json.dumps(wyo_hi_dict) Equivalent json string of input dictionary: '{\"1\": \"Welcome\", \"2\": \"to\", \"3\": \"Cheyenne\", \"4\": \"Wyoming\"}' You will notice that the JSON dumps converts the keys and values to strings. The deserialization process converts the value to its datatype, but it doesn't always get it right, so sometimes we are left with adding custom casting. Accessing the properties of the json object when loaded from json.loads() is the same as accessing them via Python dictionary. Now that we know some methods for requesting data from the web and parsing JSON data, let’s look at a REST service from esri and how we can use it to generate an url for our code. There are four parameters that we need to fill out for it to return a result. Using the query UI endpoint for the service at 2023_BLM_AZ_Fire_Restrictions_view. These four parameters we will work with are the Where, Out Fields, Return Geometry, and Return format. If you need a more specific result, you can enter more parameters as needed. The base url for the query will start out as: As described in the last section, this ? is starting of the passing of the parameters, which are separated by & sign. Note that the url and the parameters we are passing does not contain spaces. The complete request’s parameters are added to the URL when the request is submitted: Building our query that will return all features and all fields in json format will look like: With this url string, we can use requests to retrieve data from services and save them locally. There are a few ways of doing this such as using pandas to read the url, converting the json to a dataframe and then to a featureclass using built methods, converting the JSON result to a dictionary and using an insert/update cursor, or creating a new featureclass using the arcpy method JSONToFeatures_conversion(…) method. It is important to note an important aspect of this method noted in the Summary section of the documentation: Converts feature collections in an Esri JSON formatted file (.json) or a GeoJSON formatted file (.geojson) to a feature class. This means that the method is expecting a file as the input and trying to pass the response json will result in an error. If you do not need to manipulate the data before outputting to a featureclass, this method might be the simplest to implement with the least amount of packages. If you need to work on the data, such as convert the datetimes for a field, converting the JSON to a dataframe or dictionary would be the preferred process. Below is an example of the process. #json example import arcpy import requests import json arcpy.env.overwriteOutput = True url = \"https://services3.arcgis.com/T4QMspbfLg3qTGWY/ArcGIS/rest/services/2023_BLM_AZ_Fire_Restrictions_view/FeatureServer/0/query?where=1=1&returnGeometry=true&outFields=*&f=json\" # send the request to the url and store the reply as response response = requests.get(url) # Get result as json jsonCode = response.json() jsonFile = r\"C:\\GEOG489\\Lesson 2\\response.json\" # write the response json to a file with open(jsonFile, \"w\") as outfile: json.dump(jsonCode, outfile) # JSONToFeatures requires a file as input arcpy.JSONToFeatures_conversion(jsonFile, r'C:\\GEOG489\\Lesson 2\\Geog489.gdb\\az_fire_districts', 'POLYGON') # Clean up if os.path.exists(jsonFile): os.remove(jsonFile) You can also separate the parameters into a dictionary and let requests do the url formatting, making for a cleaner code and this method seems to also format the returned date fields, if there are any: As we said earlier about searching for packages that perform an ETL process, we saved a hidden gem for last. Compared to the previous methods of retrieving data from a service that we went over, the few lines of code this process requires is welcoming from a managerial and readability standpoint. A hidden capability of arcpy’s conversion FeatureclassToFeatureclass (deprecated in favor of ExportFeatures) is that it can take a service endpoint as an input and make short work of this conversion to a Featureclass. However, as promising as it seems, some services do not transform. Since it is only a few lines of code, it is worth giving it a try and saving some time. To add a definition query, you can set the where_clause parameter of the method. ExportFeautures contains different parameters so it looks a little different, but works the same:\n\nWe already mentioned in Section 2.4 that often there exist different options for a GUI library to use for a project in a given programming language. This is also the case for Python. Python includes a GUI package called Tkinter in its standard library. In addition, there exist 3rd party alternatives such as the PyQT and PySide wrappers for the QT library, Kivy, Toga, wxPython, and quite a few more. Have a quick look at the overview table provided at this GUI Programming in Python page to get an idea of what’s out there. In contrast to Tkinter, these 3rd party libraries require the installation of additional packages. This can be seen as a downside since it will make sharing and installation of the developed software a bit more complicated. In addition, there are quite a few other factors that affect the choice for a GUI library for a particular project including:\n• For which platforms/operating systems is the library available?\n• Does the library draw its own widgets and have its own style or use the operating system's native look & feel?\n• How large is the collection of available widgets? Does it provide the more specialized widgets that are needed for the project?\n• How easy is the library to use/learn?\n• How easy is it to extend the library with our own widgets?\n• How active is the development? How good is the available support?\n• Is the library completely free to use? What are the license requirements? In the rest of this section, we will focus on Tkinter and QT with its two Python wrappers PySide and PyQT. We will have quick looks at Tkinter and QT individually, but using the same example of a simple GUI tool to convert miles to kilometers. In the following parts of the lesson, we will then focus solely on writing GUI-based Python programs with PyQT. As we already mentioned, Tkinter is the standard GUI for Python, but only in the sense that it is a package in the Python standard library, so it is available for all platforms without requiring any additional installation. Its name stands for “Tk interface”. It is certainly possible that you have not heard about Tk and Tcl before but Tk is one of the oldest free and open-source, cross-platform GUI toolkits (written in the Tcl scripting language and initially released in 1991) and has been adopted for building GUIs in many programming languages. Tkinter has been written by Fredrik Lundh and is essentially a set of wrapper classes and functions that use a Tcl interpreter embedded into the Python interpreter to create and manage the Tk GUI widgets. To get an impression of how tkinter is used to build a GUI in Python, let us look at the example of creating a simple miles-to-kilometers conversion tool. The tool is shown in the figure below. It has a single window with five different widgets: two label widgets, two widgets for entering or displaying single lines of text, and a button in the middle. The user can enter a number of miles into the line input field at the top, then press the button, and then the entered number of miles will be converted and displayed as kilometers in the line input field at the bottom. We are using a line input field to display the resulting distance in kilometers just to make things more symmetrical. Since we do not want the user to be able to enter anything into this text field, it has been disabled for input and we could just as easily have used another label widget. The Python code to create this tool with the help of tkinter is shown below and the explanation of the code follows. from tkinter import Tk, Label, Entry, Button, DISABLED, StringVar def convert(): \"\"\"Takes miles entered, converts them to km, and displays the result\"\"\" miles = float(entryMiles.get()) kilometers.set(str(miles * 1.60934)) # create the GUI rootWindow = Tk() # create main window rootWindow.title(\"Miles to kilometers\") rootWindow.geometry('500x200+0+0') rootWindow.grid_columnconfigure(1, weight = 1) labelMiles = Label(rootWindow, text='Distance in miles:') # create label for miles field labelMiles.grid(row=0, column=0) labelKm = Label(rootWindow, text='Distance in kilometers:') # create label for km field labelKm.grid(row=2, column=0) entryMiles = Entry(rootWindow) # create entry field for miles entryMiles.grid(row=0, column=1, sticky='w,e') kilometers = StringVar() # create entry field for displaying km entryKm = Entry(rootWindow, textvariable = kilometers, state=DISABLED) entryKm.grid(row=2, column=1, sticky='w,e') convertButton = Button(rootWindow, text='Convert', command = convert) # create button for running conversion convertButton.grid(row=1, column=1) # run the event processing loop rootWindow.mainloop() Let us ignore the first few lines of Python code for a moment and first look at lines 10 to 29. This is where the GUI of our little program is produced starting with the root window widget in lines 10 to 13. The widget is created by calling the function Tk() defined in tkinter and the created object is stored in variable rootWindow. We then use different methods of the widget to set its title, initial size, and some properties for its grid layout that we are going to use to arrange the child widgets within the content area of the root window. Next, the label saying “Distance in miles:” is created. The tkinter widget class for labels is called Label and we provide rootWindow as a parameter to Label(…), so that the widget knows what its parent widget is. As mentioned, we will be using a grid layout, namely one with three rows and two columns. We place the created label in the cell in the first row and first column of its parent by calling the grid(…) method with row = 0 and column = 0. We then take the exact same steps to create the other label and place it in the third row of the first column. In the next steps, the two text input fields are created as widget objects of the tkinter Entry class. An additional parameter sticky=’w,e’ is used for placing these widgets in the grid. This parameter says that the widgets should expand horizontally (west and east) to fill the entire cell. This is required to make the layout fill out the window horizontally and have the text field grow and shrink when the window is resized. Moreover, the Entry widget for displaying the distance in kilometers is set to DISABLED so that the user cannot enter text into it, and it is associated with a variable kilometers of tkinter class StringVar which is needed for us to be able to change the text displayed in the widget from code. Finally, the button is created as a widget of tkinter class Button. What is new here is what happens with the ‘command’ parameter given to Button(…) in line 28. Here we are saying that if this button is clicked, the function convert() that we are defining at the top of our code should be executed to deal with this event. So this is an example of connecting an event to an event handler function. What happens in convert() is very simple: With the help of the get() method, we get the current text from the Entry widget for the distance in miles, multiply it with a constant to convert it to kilometers, and then use the set() method of the StringVar object in variable kilometers to change the text displayed in the Entry widget to the distance in kilometers associated with that variable. In the last line of the code, we call the mainloop() method of our root window to start the infinite event processing loop. The program execution will only return from this call when the user closes the root window, in which case the program execution will be terminated. The only part of the code we haven’t talked about is the first line where we simply import the widget classes and other auxiliary classes from tkinter that we need in our code. Hopefully, it is clear that this is just a very prototypical implementation of a miles-to-kilometers conversion tool focusing on the GUI. We have neither implemented any sort of checking whether input values are valid nor any sort of error handling. It is therefore very easy to make the tool crash, e.g. by entering something that is not a number into the field for distance in miles. If you haven’t already done so, we suggest you create a Python script with the code from above and try out the tool yourself and see how the layout adapts if you resize the window. Feel free to experiment with making small changes to the code, like adapting the text shown by the labels or adding another button widget to the currently still empty second row of the first column; then make the button call another event handler function you write to, for instance, just print some message to the console. Don’t worry if some of the details happening here don’t seem entirely clear at the moment. A real introduction to creating GUIs with Python will follow later in this lesson. Here we just wanted to give you a general idea of how the different concepts we discussed in Section 2.4 are realized in tkinter: You saw how different widgets are created, how they were arranged in a grid layout by placing them in different cells of the layout, how to connect an event (button clicked) with a self-defined event handler function (convert()), and how to execute the application by starting the event processing loop (rootWindow.mainloop()). Now let’s move on and talk about QT as an alternative to tkinter and see how this same example would look like when produced with the PyQt instead of tkinter. We already mentioned a few things about QT in this lesson. It is a widely used cross-platform library written in C++, modern and under very active development. In addition to the GUI functionality, the library provides support for internationalization, Unicode, database and network access, XML and JSON code processing, thread management, and more. That’s why it is also called an application framework, not just a GUI library. QT was originally developed by the company Trolltech and its initial release was in 1995. KDE, one of the early GUIs for the Linux operating system, was based on QT and that triggered a lot of discussion and changes to the license and organization QT was published under. These days, the company developing QT is called The QT Company, a successor of Trolltech, and QT is published in four different editions, including the Community edition that is available under different open source licenses GPL 3.0, LGPL 3.0, and LPGL 2.1 with a special QT exception. QT is very commonly used for both open source and commercial software, and if you have worked with QT in one programming language, it is typically relatively easy to learn to use it in a different language. QT5 was released in 2012 and the current version of QT at the time of this writing is 5.10. You may wonder why there exist two different Python wrappers for QT and how different they are? The short answer is that the reason lies mainly in license related issues and that PyQt and PySide are actually very similar, so similar that the code below for a QT based version of the miles-to-kilometers converter works with both PyQt and PySide. For PySide you only have to replace the import line at the beginning. PyQt is significantly older than PySide and, partially due to that, has a larger community and is usually ahead when it comes to adopting new developments. It is mainly developed by Riverbank Computing Limited and distributed under GPL v3 and a commercial license. Releases follow a regular schedule and the software is generally considered very robust, mature, and well supported. PySide is developed by Nokia and had its initial release in 2009, in a time when Nokia was the owner of QT. As can be read on the PySide web page, PySide has been developed and published in response to a lack of a QT wrapper for Python that has a suitable license for FOSS and proprietary software development. Without going too much into the details of the different license models involved, if you want to develop a commercial application, PyQt requires you to pay fees for a commercial license, while the LGPL license of PySide permits application in commercial projects. From an educational perspective, it doesn’t really matter whether you use PySide or PyQt. As we already indicated, the programming interfaces have over the recent years converged to be very similar, at least for the basic GUI based applications we are going to develop in this course. However, we have some specific reasons to continue with PyQt that will be listed at the end of the next section. If you are interested to learn more about the differences between PyQt and PySide and when to pick which of the two options, the following blog post could serve as a starting point: Since in contrast to tkinter, PyQt5 is not part of the Python standard library, we may need to install the PyQt5 package before we can use it from our code. We are currently using the Python installation that comes with ArcGIS Pro. Therefore, we will use the conda installation manager from within ArcGIS Pro to check whether PyQt5 is installed and if not, install it with all the packages it depends on. This will also automatically install the binary QT5 library that the PyQt5 package is a wrapper for. Go ahead and open the package manager in Pro (Project -> Package Manager) and check the Installed Packages list to see if \"pyqt\" is installed. If not, go to Add Packages and type\"pyqt\". It may not be listed as a package to add in this curated list by esri so we will need to use the python command prompt. There are two quck ways to start a command window in your conda environment: search for \"Python Command Prompt\" and it should result in a \"Best match\". After opening, be sure to verify that it opened the environment you want to work in (details below). Or, you can navigate to it by clicking the \"All\" to switch to the application list view. Scroll down the list and expand the ArcGIS folder to list all of the ArcGIS applciations installed. Scroll down and open the Python Command Prompt. This is a shortcut to open a command window in the activated python envionment. Once opened, you should see the environment name in parenthesis follwed by the full path to the python environment. When you change your activated environment in Pro's Package Manager, this shortcut will also be updated to point to that activated environment. Proceed through the prompts and If this does not install, please let your instructor know. While you are here, also install QtWebEngineWidgets by using the command pip install QtWebEngineWidgets. You probably will now have version 5.15.2 or later of pyqt installed. Next, try to run the test code on the next page. If this code gives you an error of... This application failed to start because it could not find or load the Qt platform plugin \"windows\". ...then you will need to come back to this page and set the QT_QPA_PLATFORM_PLUGIN_PATH environmental variable to the path of the plugin folder of PyQt5 (as explained in the blog post Developing Python GUI in ArcGIS Pro with PyQt). This can be done with the Windows tool for setting environmental variables by following the instructions below. If you make any changes to existing variables, keep a log of anything that you change. Multiple applications may reference the environment variable and changing it may break that application. Having the log of what you changed can help reset variables and resolve issues without troubleshooting/reinstalling the broken software. We are adding a variable here so it is relatively safe but if your environment has the variable already, make note of what the current value is.\n• Go to the Windows \"Settings\" and type “environmental” into the \"Find a setting\" search field and then pick “Edit the system environment variables”.\n• Click on “Environment variables…” at the bottom. Figure 2.9 System Properties dialog with \"Environment Variables...\" button at the bottom right\n• Click on \"New...\" to add the environment variable at the bottom for \"System variables\". Figure 2.10 Variables dialog with \"New...\" button at the bottom\n• Fill out the dialog for adding a new variable. If the folder for your cloned ArcGIS Pro Python environment is something like \"C:\\Users\\<username>\\AppData\\Local\\ESRI\\conda\\envs\\arcgispro-py3-clone\", then use this to fill out the \"Variable value\" as shown in the figure below (see Section 1.5 explaining how opening Python Command Prompt will show the default folder). If you are using an older version of Pro and the default Python environment at \"C:\\Program Files\\ArcGIS\\Pro\\bin\\Python\\envs\\arcgispro-py3\", then use this for the Variable value instead. Then click Ok and restart your IDE before trying again. Figure 2.11 System Environment Variables dialog shown with variable name and variable value populated\n• If that environment key did not resolve the warning, which can occur if you have other applications that use QT, change the variable name to QT_PLUGIN_PATH and try again. If it still does not work, contact your instructor for assistance troubleshooting. Here is how the code for our miles-to-kilometers conversion tool looks when using PyQt5 instead of tkinter. You will see that there are some differences but a lot also looks very similar. We kept the names of the variables the same even though the widgets are named a little differently now. Since you now have PyQt5 installed, you can immediately run the code yourself and check out the resulting GUI. The result should look like the figure below. from PyQt5.QtWidgets import QApplication, QWidget, QLabel, QGridLayout, QLineEdit, QPushButton def convert(): \"\"\"Takes miles entered, converts them to km, and displays the result\"\"\" miles = float(entryMiles.text()) entryKm.setText(str(miles * 1.60934)) app = QApplication([]) rootWindow = QWidget() rootWindow.setWindowTitle(\"Miles to kilometers\") rootWindow.resize(500, 200) gridLayout = QGridLayout(rootWindow) labelMiles = QLabel('Distance in miles:') gridLayout.addWidget(labelMiles, 0, 0) labelKm = QLabel('Distance in kilometers:') gridLayout.addWidget(labelKm, 2, 0) entryMiles = QLineEdit() gridLayout.addWidget(entryMiles, 0, 1) entryKm = QLineEdit() gridLayout.addWidget(entryKm, 2, 1) convertButton = QPushButton('Convert') gridLayout.addWidget(convertButton, 1, 1) convertButton.clicked.connect(convert) rootWindow.show() app.exec_() Let’s look at the main differences between this code and the tkinter based code from Section 2.5.1. Obviously, we are now importing classes from the module PyQt5.QtWidgets and the widgets are named differently (all starting with ‘Q’). While with tkinter, we only created one object for the application and root window together and then called its mainloop() method to start the execution of the event processing loop, the application and its main window are two different things in QT. In line 8, we create the application object and then at the very end we call its exec_() method to start the event processing loop. The window is created separately in line 10, and before we call exec_(), we invoke its show() method to make sure it is visible on the screen. The creation of the widgets looks very similar in both versions. However, with tkinter, we didn’t have to create a grid layout explicitly; it was already available after the main window had been created. With PyQt5, we create the grid layout for the root window explicitly in line 14. To add widgets to the grid layout, we call the addWidget(…) method of the layout providing numbers for the row and column as paramters. In the tkinter version, we had to set up a special variable to change the content of the entryKm line input field. This is not required with PyQt5. We can simply change the text displayed by the corresponding QLineEdit widget by calling its setText(…) method from the convert() function in line 6. Finally, connecting the “clicked” event of the button with our convert() event handler function happens as a separate command in line 31 rather than via a parameter when creating the button object. By writing \"convertButton.clicked.connect(convert)\" we are saying, in QT terminology, that the “clicked” signal of convertButton should be connected to our convert() function. It seems fair to say that from the perspective of the code, the differences between tkinter and PyQt5 are rather minor with, in some cases, one of them needing a bit more code, and in other cases, the other. However, this is partially due to this example being very simple and not involving more advanced and complex widgets and layouts. When you tried out both versions of our little tool or just closely compared the two figures above with screenshots of the produced GUIs, you may also have noticed that, in addition to the differences in the code, there are some differences in the produced layout and behavior. We didn’t make use of all available options to make the two versions appear very similarly and it is certainly possible to do so, but our personal impression is that just based on the default look and behavior, the layout produced by PyQt5 is a bit more visually appealing. However, the main reason why we are going to continue with QT5/PyQt5 for the remainder of this lesson are the following:\n• QT5 is a modern and widely used cross-platform and cross-language library; knowledge and skills acquired with QT can be applied in languages other than Python.\n• QT5 is efficient and smooth because of the compiled core library written in C++.\n• QT5 and PyQt5 provide a large collection of available widgets and can be expected to be under active development for the foreseeable future.\n• There exists very good tool support for the combination of QT5 and PyQt5\n• Finally and very importantly: In lesson 4 we will continue with the GUI development started in this lesson in the context of QGIS 3. QGIS and its interface for plugins have been developed for PyQt5. As a final note, if you want to run the converter tool code with PySide, you have to replace the import line with the following line: Of course, you will first have to install the PySide2 package in the ArcGIS Pro package manager to be able to run the code.\n\nIt is now time for a more systematic introduction to Python GUI development with QT5 and PyQt5. We will split this introduction into two parts, first showing you how to create GUI programmatically from Python code and then familiarizing you with the QT Designer tool for visually building GUIs and then translating them to Python code. In the walkthrough from Section 2.7, you will then work through a larger example of creating a GUI based application. To familiarize ourselves with PyQT5 and get to know the most common QT5 widgets, let’s go through three smaller examples. Let’s start by just producing a simple window that has a title and displays some simple text via a label widget as shown in the image below. Figure 2.13 First version of the Example 1 GUI with a QLabel widget located at fixed coordinates within the parent widget Thanks to PyQt5, the code for producing this window takes only a few lines: import sys from PyQt5.QtWidgets import QWidget, QApplication, QLabel app = QApplication(sys.argv) window = QWidget() window.resize(400,200) window.setWindowTitle(\"PyQt5 example 1\") label = QLabel(\"Just a window with a label!\", window) label.move(100,100) window.show() sys.exit(app.exec_()) Try out this example by typing or pasting the code into a new Python script and running it. You should get the same window as shown in the image above. Let’s briefly go through what is happening in the code:\n• First of all, for each Python program that uses PyQT5, we need to create an object of the QApplication class that takes care of the needed initializations and manages things in the background. This happens in line 4 and we store the resulting QApplication object in variable app. At the very end of the program after setting up the different GUI elements, we use app.exec_() to call the exec_() method of the application object to run the application and process user input. The return value is used to exit the script by calling the sys.exit(…) function from the Python standard library. These are things that will look identical in pretty much any PyQT application.\n• Most visible GUI elements (windows, button, text labels, input fields, etc.) in QT are derived in some way from the QWidget class and therefore called widgets. Widgets can be containers for other widgets, e.g. a window widget can contain a widget for a text label as in this example here. We are importing the different widgets we need here together with the QApplication class from the PyQt5.Widgets module in line 2. For our window, we directly use a QWidget object that we create in line 6 and store in variable window. In the following two lines, we invoke the resize(…) and setWindowTitle(…) methods to set the size of the window in terms of pixel width and height and to set the title shown at the top to “PyQt5 example 1”. After creating the other GUI elements, we call the show() method of the widget in line 13 to make the window appear on the screen.\n• The content of the window is very simple in this case and consists of a single QLabel widget that we create in line 10 providing the text it should display as a parameter. We then use a fixed coordinate to display the label widget at pixel position 100,100 within the local reference frame of the containing QWidget. These coordinates are measured from the top left corner of the widget’s content area. That’s all that’s needed! You will see that even if you resize the window, the label will always remain at the same fixed position. If you have trouble running this script (e.g., you get a \"Kernel died, restarting\" error), try this version of the code (modified lines highlighted): import sys from PyQt5.QtWidgets import QWidget, QApplication, QLabel from PyQt5.QtCore import Qt, QCoreApplication app = QCoreApplication.instance() if app is None: app = QApplication(sys.argv) app.aboutToQuit.connect(app.deleteLater) window = QWidget() window.resize(400,200) window.setWindowTitle(\"PyQt5 example 1\") label = QLabel(\"Just a window with a label!\", window) label.move(100,100) window.show() sys.exit(app.exec_()) This version of the code checks to see if there's already a QApplication object left existing in the current process -- only one of these objects is allowed. If an object exists, it's used; else, a new one is created. Line 9 then ensures that the application is deleted upon quitting. As we already pointed out in Section 2.4.2, using absolute coordinates has a lot of disadvantages and rarely happens when building GUIs. So let’s adapt the example code to use relative layouts and alignment properties to keep the label always nicely centered in the middle of the window. Here is the code with the main changes highlighted: import sys from PyQt5.QtWidgets import QWidget, QApplication, QLabel, QGridLayout from PyQt5.QtCore import Qt app = QApplication(sys.argv) window = QWidget() window.resize(400,200) window.setWindowTitle(\"PyQt5 example 1\") layout = QGridLayout(window) label = QLabel(\"Just a window with a label (now perfectly centered!)\") label.setAlignment(Qt.AlignCenter) layout.addWidget(label,0,0) window.show() sys.exit(app.exec_()) Try out this modified version and see whether you notice the change. Here is an explanation:\n• For this simple example, different layouts would have worked, but we here use a QGridLayout for the window content that allows for arranging the child elements in a table–like way with the rows and columns being resized automatically to arrange everything in an optimal way given the available space. The grid layout object is created in line 11 and stored in variable layout. By providing window as the parameter, it is directly applied to manage the child elements of our window widget.\n• The cells in the grid are accessed via their row and column indices starting from zero. In this example, we only have a single cell that will span the entire window. We add the label widget to this cell by calling the addWidget(…) method of the grid layout in variable layout and providing the coordinates 0,0 of the top left cell.\n• Without any further changes, the label would now appear vertically centered in the window because that is the default policy for the cells in a grid layout, but horizontally adjusted to the left. To also make the label appear horizontally centered, we use its setAlignment(…) method with the constant Qt.AlignCenter that is defined in the PyQt5.QtCore module which we are also importing at the beginning. If you tried out the modified example, you will have noticed that the label now always remains in the center independent of how you resize the window. That is the result of the grid layout manager working in the background to rearrange the child elements whenever the size is changed. As a further extension of this example, let us make things a bit more interesting and bring in some interactions by adding a button that can be used to close the application as an alternative to using the close icon at the top. The widget needed to implement such a button is called QPushButton. We will add the button to cell 1,0 which is the cell in row 1 and column 0, so below the cell containing the label. That means that the grid layout will now consist of one column and two rows. Here is the modified code with the main changes highlighted: import sys from PyQt5.QtWidgets import QWidget, QApplication, QLabel, QGridLayout, QPushButton from PyQt5.QtCore import Qt app = QApplication(sys.argv) window = QWidget() window.resize(400,200) window.setWindowTitle(\"PyQt5 example 1\") layout = QGridLayout(window) label = QLabel(\"Just a window with a label (now perfectly centered!)\") label.setAlignment(Qt.AlignCenter) layout.addWidget(label,0,0) button = QPushButton(\"Close me\") button.setToolTip('This is a QPushButton widget. Clicking it will close the program!') layout.addWidget(button,1,0) button.clicked.connect(app.quit) window.show() sys.exit(app.exec_()) Please note how the push button widget is created in line 17 providing the text it will display as a parameter. It is then added to the layout in line 19. In addition, we use the setToolTip(…) method to specify the text that should be displayed if you hover over the button with the mouse. This method can be used for pretty much any widget to provide some help text for the user. The interesting part happens in line 21: Here we specify what should actually happen when the button is pressed by, in QT terminology, “connecting a signal (button.clicked) of the button to a slot (app.quit) of the application object”. So if the button is clicked causing a “clicked” event, the method quit(…) of the application object is called and the program is terminated as a result. Give this example a try and test out the tooltip and button functionality. The produced window should look like in the image below: Figure 2.14 Third version of the Example 1 GUI, now with a button to close the application and tooltip information As you probably noticed, the button right now only takes up a fixed small amount of space in the vertical dimension, while most of the vertical space is taken by the cell containing the label which remains centered in this area. Horizontally, the button is expanded to always cover the entire available space. This is the result of the interplay between the layout policies of the containing grid layout and the button object itself. By default, the vertical policy of the button is set to always take up a fixed amount of space but the horizontal policy allows for expanding the button. Since the default of the grid layout is to expand the contained objects to cover the entire cell space, we get this very wide button. In the last version of this first example, we are therefore going to change things so that the button is not horizontally expanded anymore by adding a QHBoxLayout to the bottom cell of the grid layout. This is supposed to illustrate how different widgets and layouts can be nested to realize more complex arrangements of GUI elements. In addition, we change the code to not close the application anymore when the button is clicked but instead call our own function that counts how often the button has been clicked and displays the result with the help of our label widget. A screenshot of this new version and the modified code with the main changes highlighted are shown below. Figure 2.15 Fourth version of the Example 1 GUI with the button being part of a horizontal layout set up to keep it from horizontally expanding more than needed import sys from PyQt5.QtWidgets import QWidget, QApplication, QLabel, QGridLayout, QPushButton, QHBoxLayout from PyQt5.QtCore import Qt def buttonClickedHandler(c): global counter counter += 1 label.setText('Thank you for clicking the button ' + str(counter) + ' times!') app = QApplication(sys.argv) window = QWidget() window.resize(400,200) window.setWindowTitle(\"PyQt5 example 1\") layout = QGridLayout(window) label = QLabel(\"Just a window with a label (now perfectly centered!)\") label.setAlignment(Qt.AlignCenter) layout.addWidget(label,0,0) button = QPushButton(\"Click me\") button.setToolTip('This is a QPushButton widget. Click it!') horLayout = QHBoxLayout() horLayout.addStretch(1) horLayout.addWidget(button) horLayout.addStretch(1) layout.addLayout(horLayout,1,0) button.clicked.connect(buttonClickedHandler) counter = 0 window.show() sys.exit(app.exec_()) In addition to the highlighted changes, there are a few very minor changes to the text displayed on the button and its tooltip. Let us first look at the changes made to implement the counting when the button is pressed. Instead of directly connecting the button.clicked signal to the slot of another QT element, we are connecting it to our own function buttonClickedHandler(…) in line 32. In addition, we create a global variable counter for counting how often the button has been clicked. When it is clicked, the buttonClickedHandler(…) function defined in lines 6 to 9 will be called, which first increases the value of the global counter variable by one and then uses the setText(…) method of our label object to display a message which includes the number of button presses taken from variable counter. Very simple! Now regarding the changes to the layout to avoid that the button is expanded horizontally: In principle, the same thing could have been achieved by modifying the horizontal layout policy of the button. Instead, we add a new layout manager object of type QHBoxLayout to the bottom cell of the grid layout that allows for arranging multiple widgets in horizontal order. This kind of layout would also be a good choice if, for instance, we wanted to have several buttons at the bottom instead of just one, all next to each other. In line 26, we create the layout object and store it in variable horLayout. Later in line 30, we add the layout to the bottom cell of the grid layout instead of adding the button directly. This is done using the addLayout(…) method rather than addWidget(…). In between these two steps, we add the button to the new horizontal layout in horLayout in line 28. In addition, we add horizontal stretch objects to the layout before and after the button in lines 27 and 29. We can think of these objects as springs that try to take up as much space as possible without compressing other objects more than these allow. The number given to the addStretch(…) method is a weight factor that determines how multiple stretch objects split up available space between them. Since we use 1 for both calls of addStretch(…), the button will appear horizontally centered and just take up as much space as needed to display its text. If you want to have the button either centered to the left or to the right, you would have to comment out line 27 or line 29, respectively. What do you think would happen if you change the weight number in line 27 to 2, while keeping the one in line 29 as 1? Give it a try! We are now moving on to example 2, a completely new example that focuses on the menu bar and status bar widgets as well as on defining user actions that can be associated with different input widgets and some other useful features of QT5 that are commonly used in GUI-based programs. Often GUI-based programs provide many ways in which the user can trigger a particular action, e.g. the action for saving the currently opened file can typically be performed by choosing the corresponding entry from the menu bar at the top, by a keyboard shortcut like CTRL+S for instance, and potentially also by a tool button in a toolbar and by some entry in a so-called context menu that shows up when you click the right mouse button. PyQT5 provides the QAction class for defining actions and these actions can then be associated with or added to different GUI elements that are supposed to trigger the action. For instance, in the following example we will create an action for exiting the program with the following four lines of code: The QAction object for our exit action is created in the first line and then stored in variable exitAction. The first two parameters given to QAction(…) are an icon that will be associated with that action and the name. For the icon we use the SP_DialogCancelButton icon from the set of icons that comes with QT5. Of course, it is possible to use your own set of icons but we want to keep things simple here. The & symbol in the name of the action (&Exit) signals that it should be possible to use ALT+E as a keyboard shortcut to trigger the action when using the application’s menu bar. The last parameter is the parent object which needs be another QT object, the one for the application’s main window in this case (more on this in a moment). In the following two lines we define the keyboard shortcut (Ctrl+Q) that can be used at any moment to trigger the action and a message that should be shown in the status bar (the bar at the bottom of the application’s main window that is typically used for showing status messages) when hovering over a GUI element that would trigger this action. Finally, in the last line we connect the event that our exit action is triggered (by whatever GUI element) to the quit slot of our application. So this is the part where we specify what the action should actually do and as we have seen before, we can either connect the signal directly to a slot of another GUI element or to a function that we defined ourselves. We already briefly mentioned the “main window” of the application. In example 1 above, we used the QWidget object for the main window and container of the other GUI elements. In example 2, we will use the QMainWindow widget instead which represents a typical application window with potentially a menu bar and tool bar at the top, a large central area in the middle to display the main content of the app, and potentially a small status bar at the bottom. The image below shows how the main window we are going to create in example 2 will look. Figure 2.16 First version of the Example 2 GUI Once a QMainWindow object has been created and stored in variable mainWindow, its menu bar (an object of type QMenuBar that is created automatically) can be accessed via the menuBar() method, so with the expression mainWindow.menuBar(). A menu bar consists of one or more menus (= objects of the QMenu class) which in turn consist of several menu entries. The entries can be actions or submenus which again are QMenu objects. To add a new menu to a menu bar, you call its addMenu(…) method and provide the name of the menu, for instance ‘&File’. The method returns the newly created QMenu object as a result, so that you can use it to add menu entries to it. To add an action to a menu, you invoke a method called addAction(…) of the menu object, providing the action as a parameter. With that explanation, it should be relatively easy to follow the code below. We have highlighted the important parts related to creating the main window, setting up the menu bar, and adding the exit action to it. import sys from PyQt5.QtWidgets import QApplication, QMainWindow, QAction, QStyle app = QApplication(sys.argv) mainWindow = QMainWindow() mainWindow.resize(400,200) mainWindow.setWindowTitle(\"PyQt5 example 2\") fileMenu = mainWindow.menuBar().addMenu('&File') optionsMenu = mainWindow.menuBar().addMenu('&Options') exitAction = QAction(app.style().standardIcon(QStyle.SP_DialogCancelButton), '&Exit', mainWindow) exitAction.setShortcut('Ctrl+Q') exitAction.setStatusTip('Exit application') exitAction.triggered.connect(app.quit) fileMenu.addAction(exitAction) mainWindow.statusBar().showMessage('Waiting for your commands...') mainWindow.show() sys.exit(app.exec_()) The QMainWindow is created very similarly to the QWidget we used in example 1, meaning we can set the title and initial size of the widget (lines 8 and 9). The two menus ‘File’ and ‘Options’ are added to the menu bar of our main window in lines 11 and 12, and the QMenu objects returned are stored in variables fileMenu and optionsMenu, respectively. In line 19, we add the exit action we created with the code already discussed earlier (lines 14 to 17) to the ‘File’ menu. The icon and name we provided when creating the action will be used for the entry in the menu bar and selecting the entry will trigger the action and result in the quit() method of application being called. Please note that in line 21, we also added a command to show a message in the status bar at the bottom of the main window when the application is started. The status bar object is accessed via the statusBar() method of the QMainWindow, and then we directly call its showMessage(…) method specifying the text that should be displayed. We suggest that you run the program a few times, trying out the different ways to exit it via the menu entry (either by clicking the entry in the ‘File’ menu or using ALT+F followed by ALT+E) and the action's keyboard shortcut CTRL+Q that we defined. So far, our 'File' menu only has a single entry and the 'Options' menu is still completely empty. In the following, we are going to extend this example by adding ‘Open’ and ‘Save’ actions to the ‘File’ menu making it appear somewhat similar to what you often see in programs. We also add entries to the 'Options' menu, namely one with a checkbox next to it that we use for controlling whether the label displayed in our main window is shown or hidden, and one that is a QMenu object for a submenu with two additional entries. The two images below illustrate how our menu bar will look after these changes. Figure 2.17 Example 2 'File' menu with three actions Figure 2.18 Example 2 'Options' menu with a checkable entry and a submenu In addition to the changes to the menu bar, we will use the QFileDialog widget to display a dialog for selecting the file that should be opened and we use a QMessageBox widget to display a quick message to the user that the user has to confirm. Here is the code for the new version with main changes highlighted. Further explanation will follow below: import sys from PyQt5.QtWidgets import QApplication, QMainWindow, QAction, QStyle, QFileDialog, QMessageBox, QWidget, QGridLayout, QLabel, QMenu from PyQt5.QtCore import Qt def openFile(): fileName, _ = QFileDialog.getOpenFileName(mainWindow, \"Open file\", \"\", \"All files (*.*)\") if fileName: mainWindow.statusBar().showMessage('User has picked file ' + fileName) else: mainWindow.statusBar().showMessage('User canceled the file dialog.') def saveFile(): QMessageBox.information(mainWindow, 'Important information', 'Save file has not been implemented yet, sorry!', QMessageBox.Ok) def toggleLabel(state): if state: label.show() else: label.hide() app = QApplication(sys.argv) mainWindow = QMainWindow() mainWindow.resize(400,200) mainWindow.setWindowTitle(\"PyQt5 example 2\") mainWindow.setCentralWidget(QWidget()) layout = QGridLayout(mainWindow.centralWidget()) label = QLabel(\"Some text ...\") label.setAlignment(Qt.AlignCenter) layout.addWidget(label,0,0) fileMenu = mainWindow.menuBar().addMenu('&File') optionsMenu = mainWindow.menuBar().addMenu('&Options') openAction = QAction('&Open...', mainWindow) openAction.triggered.connect(openFile) fileMenu.addAction(openAction) saveAction = QAction('&Save', mainWindow) saveAction.triggered.connect(saveFile) fileMenu.addAction(saveAction) exitAction = QAction(app.style().standardIcon(QStyle.SP_DialogCancelButton), '&Exit', mainWindow) exitAction.setShortcut('Ctrl+Q') exitAction.setStatusTip('Exit application') exitAction.triggered.connect(app.quit) fileMenu.addAction(exitAction) toggleLabelAction = QAction('&Toggle label', mainWindow, checkable=True) toggleLabelAction.setChecked(True) toggleLabelAction.triggered.connect(toggleLabel) optionsMenu.addAction(toggleLabelAction) otherOptionsSubmenu = QMenu('&Other options', mainWindow) otherOption1Action = QAction('Other option &1', mainWindow, checkable=True) otherOption2Action = QAction('Other option &2', mainWindow, checkable=True) otherOptionsSubmenu.addAction(otherOption1Action) otherOptionsSubmenu.addAction(otherOption2Action) optionsMenu.addMenu(otherOptionsSubmenu) mainWindow.statusBar().showMessage('Waiting for your commands...') mainWindow.show() sys.exit(app.exec_()) In addition to importing some more widgets and other PyQT classes that we need, we define three functions at the beginning, openFile(), saveFile(), and toggleLabel(…). These will serve as the event handler functions for some of the new actions/menu entries that we are adding, and we will discuss them in more detail later. The next thing to note is that in lines 31 to 33 we are reintroducing our label object from the first example in the center of the main window. Since our window is based on QMainWindow, we first have to create a QWidget to fill the central area of the main window via its setCentralWidget(…) method (line 27), and then we add the needed layouts and QLabel object itself to this central widget exactly as in example 1 (lines 29 to 33). In lines 38 and 42, we create new QAction objects for the two actions we want to add to the ‘File’ menu in variable fileMenu. To keep the code from getting too long, we don’t set up icons, keyboard shortcuts, and status bar tips for these like we did for the exit action, but these could be easily added. They are set up to call the openFile() and saveFile() functions we defined when they are triggered (lines 39 and 43), and both actions are added to fileMenu via the addAction(…) method in lines 40 and 44. In lines 52 to 55, the action with the checkbox to toggle the label on and off is created and added to the ‘Options’ menu. The main difference to the other actions is that we use the additional keyword argument checkable=True when creating the action object in line 52, and then set the initial state to being checked in the following line. The \"triggered\" signal of the action is connected to the toggleLabel(…) function. Note how this function, in contrast to other event handler function we created before, has a parameter state that when called will be given the state of the action, meaning whether it is checked or unchecked, as a boolean. The code in the body of the function in lines 17 to 20 then simply checks whether this state is True for \"checked\" and if so, makes sure that the label is visible by calling its show() method. If state is False for \"unchecked\", it will call hide() instead and the label will become invisible. In lines 57 to 63, we create a submenu for the ‘Options’ menu with two more checkable actions that we simply call ‘Other option 1’ and ‘Other option 2’. This is just for illustrating how to create a submenu in a menu bar, so we don’t bother with linking these actions to some actual functionality as we might in a real-world situation. The important part starts with line 57 where we create a QMenu object called ‘Other options’ that we then add the actions to in line 61 and 62. In line 63, we then add this new menu to our ‘Options’ menu in variable optionsMenu. Since we are not adding an action but a submenu here, we have to use the addMenu(…) method for this. Now it is time to have a closer look at the openFile() and saveFile() functions that describe what should happen if the open or save actions are triggered. We are keeping things very simple in the saveFile() function, so let us start with that one: Since we are just creating a GUI framework here without real functionality, we only display a warning message to the user that no save file functionality has been implemented yet. We do this with the help of the QMessageBox widget that has the purpose of making, creating, and showing such message boxes as easily as possible. QMessageBox has several methods that can be invoked to display different kinds of messages such as simple information text or questions that require some user input. To just display some text and have an OK button that the user needs to click for confirmation, we use the information(…) method (line 14). We have to provide a parent QT object (mainWindow), a title, the information text, and the kind of buttons we want in the message box (QMessageBox.Ok) as parameters. Finally, let’s look at the openFile() function in lines 6 to 11: here we illustrate what would typically happen when the action to open a file is triggered. Among other things, you typically want to provide a file browser dialog that allows the user to pick the file that should be opened. Such a dialog is much more complicated than a simple message box, so we cannot use QMessageBox for this, but fortunately QT provides the QFileDialog widget for such purposes. Like QMessageBox, QFileDialog has multiple methods that one can call depending on whether one needs a dialog for opening an existing file, selecting a folder, or saving a file under a name chosen by the user. We here use QFileDialog.getOpenFileName (…) and provide a parent object (mainWindow), a title for the dialog, and a string that specifies what files can be selected based on their file extension as parameters. For the last parameter, we use \"*.*\" meaning that the user can pick any file. getOpenFileName (…) has a return value that indicates whether the user left the dialog via the Ok button or whether the user canceled the dialog. In the first case, the return value will be the name of the file selected, and in the second case it will be None. We capture this return value in variable fileName and then use an if-statement to distinguish both cases: In the first case, we use showMessage(…) of our status bar to display a message saying which file was selected. If the condition is False (so if fileName is None), we use the same message to inform that the dialog was canceled. This second version of example 2 has already gotten quite long and the same applies for our explanation. You should take a moment to run the actual application and test out the different actions we implemented, the message box display, the open file dialog, toggling the label on and off via the entry under the ‘Options’ menu, and so on. We are now leaving the world of menu bars behind and moving on to a third and final example of manually creating PyQT5 based programs which has the purpose of showing you the most common widgets used for getting input from the user as well as the following things:\n• how to build own dialog boxes from these widgets, similar to the open file dialog for example,\n• how to arrange widgets in more complex ways,\n• and how to use the created dialog boxes from the main code. We will keep the actual functionality we have to implement in this example to a minimum and mainly connect signals sent by the different widgets to slots of other widgets. As a result, the dialog box will operate in a somewhat weird way and we, hence, call this example “The world’s weirdest dialog box”. It still serves the purpose of illustrating the different event types and how to react to them. To understand the example, it is important to know that dialog boxes can be invoked in two different ways, modally and modelessly (also referred to as non-modal). Modal means that when the method for displaying the dialog to the user is called, it will only return from the call once the user closes the dialog (e.g. by pressing an Ok or Cancel button). That means the user cannot interact with any other parts of the program's GUI, only the dialog box. When a dialog is invoked in the modeless approach, the method for displaying the dialog will return immediately and the dialog will essentially be displayed in addition to the other windows of the program that still can be interacted with. The QDialog widget that we will use to build our own dialog box in this example, therefore, has two methods: exec_() for displaying the dialog modally, and show() for displaying it in the modeless way. In contrast to show(), exec_() has a return value that indicates whether the dialog was canceled or has been closed normally, e.g. by pressing an Ok button. You may wonder how our program would be informed about the fact that the dialog has been closed, and in which way, in the modeless option using show(). This happens via the signals accepted and rejected that the dialog will produce in this case and that we can connect to in the usual way. You will see an example of that later on but we first start with a modal version of our dialog box. The final version of example 3 will be even longer than that of example 2. We, therefore, added some comments to structure the code into different parts, e.g. for setting up the application and GUI, for defining the functions that realize the main functionality, for wiring things up by connecting signals to slots or functions, and so on. In case you run into any issues while going through the following steps to produce the final code for the example, the final script file can be downloaded here. In the first skeleton of the code shown below, some of the sections introduced by the comments are still empty but we will fill them while we move along. This first version only illustrates how to create an empty QDialog object for our dialog box and show it (modally) when a button located on the main window is clicked. The most important parts of the code are again highlighted. Figure 2.19 First version of the Example 3 with an empty dialog box that can be opened by clicking the button on the main window # imports import sys from PyQt5.QtWidgets import QApplication, QMainWindow, QPushButton, QGridLayout, QWidget, QDialog # set up app and GUI app = QApplication(sys.argv) mainWindow = QMainWindow() mainWindow.resize(400,200) mainWindow.setWindowTitle(\"PyQt5 example 3\") mainWindow.setCentralWidget(QWidget()) layout = QGridLayout(mainWindow.centralWidget()) button = QPushButton(\"Open dialog ...\") layout.addWidget(button,0,0) dialogBox = QDialog() dialogBox.setWindowTitle(\"The world's weirdest dialog box\") # functions for interactions # functions for modal version # functions for modeless version # connect signals and other initializations button.clicked.connect(dialogBox.exec_) # invoke dialog modal version # run the program mainWindow.show() sys.exit(app.exec_()) The QDialog widget is created in line 21 and it is stored in variable dialogBox. We can now add content (meaning other widgets) to it in a similar way as we did with QWidget objects in previous examples using the addWidget(…) and addLayout(…) methods. In lines 17 and 18, we create a simple push button and add it to our main window. In line 31, we connect the \"clicked\" signal of this button with the exec_() method of our (still empty) dialog box. As a result, when the button is pressed, exec_() will be called and the dialog box will be displayed on top of the main window in a modal way blocking the rest of the GUI. Run the application now and see whether the dialog shows up as expected when the button is clicked. We are now going to add the widgets to our dialog box in variable dialogBox. The result should look as in the image below: Figure 2.20 Second version of the Example 3 GUI with the dialog box populated with different widgets Please follow the steps below to create this new version of example 3: Step 1. Replace all the lines with import statements under the comment “# imports” and before the comment “# set up app and GUI” with the following lines. import sys, random from PyQt5.QtWidgets import QApplication, QMainWindow, QPushButton, QGridLayout, QWidget, QDialog, \\ QVBoxLayout, QGroupBox, QLabel, QLineEdit, QTextEdit, QHBoxLayout, QListView, QRadioButton, \\ QCheckBox, QComboBox, QDialogButtonBox from PyQt5.QtCore import Qt, QVariant from PyQt5.QtGui import QPixmap, QStandardItemModel, QStandardItem As you can see, we need to import quite a few more widget classes. In addition, using some of these will require additional auxiliary classes from the PyQt5.QtCore and PyQt5.QtGui modules. Step 2. Keep the code that is currently under the comment “# set up app and GUI” as this will not change. But then add the following code directly after it, still before the “# functions for interactions” comment. mainVerticalLayout = QVBoxLayout(dialogBox) nameGroupBox = QGroupBox(\"Name\") # row 1 of vertical layout mainVerticalLayout.addWidget(nameGroupBox) nameGridLayout = QGridLayout(nameGroupBox) firstNameLabel = QLabel(\"First name:\") nameGridLayout.addWidget(firstNameLabel, 0, 0) lastNameLabel = QLabel(\"Last name:\") nameGridLayout.addWidget(lastNameLabel, 1, 0) firstNameLineEdit = QLineEdit() nameGridLayout.addWidget(firstNameLineEdit, 0, 1) lastNameLineEdit = QLineEdit() nameGridLayout.addWidget(lastNameLineEdit, 1, 1) imageHorizontalLayout = QHBoxLayout() # row 2 mainVerticalLayout.addLayout(imageHorizontalLayout) imageLabel = QLabel() imageLabel.setPixmap(QPixmap(\"psu.PNG\").scaledToWidth(172)) imageHorizontalLayout.addWidget(imageLabel) textEdit = QTextEdit() textEdit.setText(\"<write whatever you want here>\") imageHorizontalLayout.addWidget(textEdit) listGridLayout = QGridLayout() # row 3 mainVerticalLayout.addLayout(listGridLayout) listView = QListView() listGridLayout.addWidget(listView, 0, 0, 4, 1) clearPushButton = QPushButton(\"Clear\") listGridLayout.addWidget(clearPushButton, 0, 1) hidePushButton = QPushButton(\"Hide\") listGridLayout.addWidget(hidePushButton, 1, 1) showPushButton = QPushButton(\"Show\") listGridLayout.addWidget(showPushButton, 2, 1) listWordsPushButton = QPushButton(\"List words\") listGridLayout.addWidget(listWordsPushButton, 3, 1) widgetGroupBox = QGroupBox() # row 4 mainVerticalLayout.addWidget(widgetGroupBox) widgetGridLayout = QGridLayout(widgetGroupBox) greatRadioButton = QRadioButton(\"I think this dialog box is great!\") greatRadioButton.setChecked(True) widgetGridLayout.addWidget(greatRadioButton, 0, 0) neutralRadioButton = QRadioButton(\"I am neutral towards this dialog box!\") widgetGridLayout.addWidget(neutralRadioButton, 1, 0) horribleRadioButton = QRadioButton(\"This dialog box is just horrible!\") widgetGridLayout.addWidget(horribleRadioButton, 2, 0) checkBox = QCheckBox(\"Check me out\") widgetGridLayout.addWidget(checkBox, 0, 1) comboBox = QComboBox() widgetGridLayout.addWidget(comboBox, 0, 2) widgetPushButton = QPushButton(\"I am a push button spanning two columns\") widgetGridLayout.addWidget(widgetPushButton, 2, 1, 1, 2) buttonBox = QDialogButtonBox() # row 5 buttonBox.setStandardButtons(QDialogButtonBox.Cancel | QDialogButtonBox.Ok) mainVerticalLayout.addWidget(buttonBox) This is the code for creating all the different widgets in our dialog box. You should be getting used to reading this kind of code, so we will just explain the most important points here:\n• The overall organization of the dialog box is illustrated in the previous figure. The widgets are organized into five rows. This happens with a QVBoxLayout that arranges items vertically, each item below the previous one. The layout is created in line 1 and by using dialogBox as the parameter of QVBoxLayout(…), we are directly adding it to our dialog box. Each of the five following blocks of code create one of the rows in this vertical layout.\n• The first block from line 3 to 13 is formed by a single QGroupBox item which in turn contains two QLabel and two QEditLine widgets. QEditLine widgets are used for allowing the user to enter a single line of text. The labels are just for describing what should be entered into the respective line edit widget. To make everything look tidy, we use a QGridLayout as in Example 1 or the miles-to-kilometers converter to arrange these items into two columns with the first one containing the labels and the second one containing the line edit widgets.\n• The second row created in lines 15 to 22 is formed by two widgets, a QLabel that we will use to display an image of the PSU logo and a QTextEdit widget that allows for entering multi-line text. The label doesn’t have any text assigned. Instead, we use the method setPixmap(…) to assign it an image that will be displayed instead of text. You will need to download the Penn State logo here and place it in the same folder as the script to be able to run the program. To have these elements placed neatly next to each other, we use a QHBoxLayout as in Example 1 for this row and add the two widgets to it.\n• Row 3 (lines 24 to 35) contains a QListView widget on the left and four QPushButtons arranged vertically on the right. The list view is intended for displaying a list of items, one per row, and potentially allowing the user to select one or multiple of these rows/items. We use another grid layout to arrange the items in this row. The grid has two columns and three rows (because of the four buttons) and what is new here is that we are setting up the list view widget to span all four rows. This happens in line 27 by providing two additional parameters to addWidget(…): 4 for the number of rows the widget should span and 1 for the number of columns.\n• For row 4 in lines 37 to 52, we again use a group box and a grid layout (3 rows x 4 columns) to arrange the widgets inside the group box, and we add a diverse collection of different widgets to it: The first column is filled by three QRadioButtons. Radio buttons allow for picking one of several choices and it is used here in our dialog box to state your opinion on this dialog box ranging from great over neutral to horrible. The radio buttons inside the same group box are automatically linked so that when you select one, all others will be deselected. In addition, we also add a QCheckBox that can be checked and unchecked and a QComboBox for selecting one item from multiple choices. Finally we have another QPushButton, this time one that spans columns 2 and 3 (see line 52).\n• The last row (lines 54 to 56) contains an “Ok” and a “Cancel” button. These are standard elements for a dialog box, so QT provides some easy way to set these up in the form of the QDialogButtonBox widget. We just have to tell the widget which buttons we want via the setStandardButtons(…) method in line 55. At this point, you can run the script and it should produce the GUI as shown in the previous figure. You can already type things into the different edit fields and use the checkbox and radio buttons. The other elements still need to be connected to some functionality to serve a purpose, which is what we will do next. Step 3. The next things we are going to add are two functions to put some content into the QListView widget in the third row and the QComboBox widget in the fourth row. Since we want to illustrate how different GUI elements can be connected to play together, we will use the list view to display a list of the words from the text that has been entered into the QTextEdit widget in the second row (variable textEdit). The combo box we will simply fill with a set of randomly generated numbers between 1 and 9. Then we will wire up these widgets as well as the push buttons from the third row and the QDialogButtonBox buttons from the fifth row. The following code needs to be placed directly under the comment “# functions for interactions”, before the comment “# functions for modal version”. def populateListView(): words = textEdit.toPlainText().split() m = QStandardItemModel() for w in words: item = QStandardItem(w) item.setFlags(Qt.ItemIsUserCheckable | Qt.ItemIsEnabled) item.setData(QVariant(Qt.Checked), Qt.CheckStateRole) m.appendRow(item) listView.setModel(m) def populateComboBoxWithRandomNumbers(): comboBox.clear() for i in range(5): comboBox.addItem(str(random.randrange(10))) The function populateListView() calls the method toPlainText() of the QTextEdit widget. The QTextEdit widget can contain rich text with styling but this method only gives us the plain text without styling markups as a string. We then use the string method split() to split this string into a list of strings at each space or other whitespace symbol. The resulting list of words is stored in variable words. The QListView is one of the widgets that needs a model behind it meaning some object that stores the actual list data to be displayed. Since we just need a list of simple string objects here, we use the QStandardItemModel class available for such cases and fill it with QStandardItem objects we create, one for each word in our words list (lines 3 to 8). The model created in this way is then given to the setModel() method of the list view, which will then display these items. In lines 6 and 7 we are setting up the list items to have a check box that is originally checked but can be unchecked by the user to only select a subset of the items. Populating the combo box with items the user can pick from is much simpler because we can directly add string items to it with the addItem(…) method (line 14). In the populateComboBoxWithRandomNumbers() function, we first clear the current content, then use a for-loop that creates the random numbers and adds them as string items to the combo box. In addition, you now need to place the following lines of code directly under the comment “# connect signals and other initializations”, before the line that is already there for opening the dialog when the button on the main window is clicked: The first line will only play a role later on, so we ignore it for the moment. In line 3, we call the populateComboBoxWithRandomNumbers() function to initialize the combo box so that it contains a list of numbers immediately when the dialog box is opened for the first time. Next we wire up the “Ok” and “Cancel” buttons for exiting the dialog (lines 5 and 6). This is not done via the \"clicked\" signals of the button themselves but via the \"accepted\" and \"rejected\" signals of the button box that contains them. We connect these signals to the accept() and reject() methods of our dialog box, and these will take care of producing the corresponding return values or trigger the corresponding signals depending on whether we called the dialog box modally or modeless. Finally, we connect the four push buttons from the third row (lines 7 to 10). The first three are used to invoke different methods of the text edit widget above them: The first clears the text area, the second hides the widget, and the third shows it again. The fourth button is set up to invoke our populateListView() function, so this is the button that needs to be clicked for a list of words to show up in the list view widget. Go ahead and run the script now. Enter a few lines of text into the text edit field and then click the “List words” button and observe the list of words that can now be selected via the little checkboxes. Then try out the other buttons and the combo box. Step 4. At this point, we still have a few widgets in our dialog box that do not do anything. Let’s make things really weird by adding the following commands to the “# connect signals and other initializations” section directly following the lines you just added and still before the line for opening the dialog when the button on the main window is clicked. Take a brief moment to read these commands and try to understand the functionality they are adding. Do you understand what is happening here? The first line is for finally giving some functionality to the large push button labeled “I am a push button spanning two row”. We connect this button to our function for populating the combo box with random numbers. So every time you click the button, the combo box will show a different selection of random numbers to pick from. Please note that we are not connecting the \"clicked\" signal here as we did with the other push buttons. Instead, we connect the \"pressed\" signal. What is the difference? Well, the \"clicked\" signal will only be sent out when the mouse button is released, while \"pressed\" is immediately sent when you press down the mouse button. When you run the dialog again, check out whether you notice the difference. In the second and third line, we do something that you would usually never do in a dialog box: We connect the \"textChanged\" signal of the line edit widget for entering your first name at the top to the \"toggle\" slot of our checkbox widget in the fourth row. This signal is emitted whenever the text in the field is changed, e.g. every time you press a key while editing this input field. So if you type in your first name, you will see the checkbox constantly toggle between its checked and unchecked states. We then connect the \"editingFinished\" signal of the line edit widget for the last name to the \"showPopup\" slot of our combo box for opening the drop down list with the different choices. The difference between \"textChanged\" and \"editingFinished\" is that \"editingFinished\" will only be emitted when you press TAB or the widget loses focus in another way, for instance when you click on a different widget. So if you enter your last name and press TAB, you will see the drop down list of the combo box appearing. Give this and the other weird things we just implemented a try by running the script! Step 5. It’s probably best if we stop wiring up our dialog box at this point, but feel free to keep experimenting with the different signals and connecting them to different slots later on after we have completed this example. We now want to focus on what typically happens if the dialog box is closed. Right now, nothing will happen because we have been connecting the push button on our main window directly to the exec_() method, so there is no own code yet that would be executed when returning from this method. Typically, you will have your own function that calls exec_() and that contains some additional code depending on whether the user closed the dialog via the “Ok” or “Cancel” button and the state or content of the different widgets. For this purpose, please first add the following function at the end of the “# functions for interactions” section, directly before “# functions for modal version”: def printResults(): for rb in radioButtons: if rb.isChecked(): print(\"Selected opinion: \" + rb.text()) print(\"Combo box has current value \" + comboBox.currentText()) print(\"Checkbox is \" + (\"checked\" if checkBox.isChecked() else \"unchecked\")) Then under \"#functions for modal version\" insert the following code: def openDialogModal(): result = dialogBox.exec_() if result == QDialog.Accepted: printResults() else: print(\"Exited dialog via cancel button or closing window\") Finally, change the line in which we set up the main window button to open the dialog from It should be clear that this last change means that instead of opening the dialog box directly, we are now calling our own function openDialogModal() when the button on the main window is clicked. Looking at the code of that function, the first thing that will happen then is that we call dialogBox.exec_() to open the dialog box, but here we also capture its return value in variable result. When the dialog box is closed, this return value will tell us whether the user accepted the dialog (the user clicked ok) or whether the user rejected the dialog (the user clicked cancel or closed the dialog in another way). The return value is a number but instead of bothering with how accepted and rejected are encoded, we compare result to the corresponding constants QDialog.Accepted and QDialog.Rejected defined in the QDialog class. When the return value is equal to QDialog.Accepted, we call the printResults() function we defined, else we just print out a message to the console saying that the dialog was canceled. The printResults() function illustrates how you can check the content or state of some of the widgets, once the dialog has been closed. Even though the dialog is not visible anymore, the widgets still exist and we just have to call certain methods to access the information about the widgets. We first look at the three radio buttons to figure out which of the three is selected and print out the corresponding text. At the beginning of the section “#connect signals and other initializations” in the code, we created a list of the three buttons in variable radioButtons. So we can just loop through this list and use the isChecked() method which gives us back a boolean value. If it is True, we get the label of the radio button via its text() method and print out a message about the user’s opinion on our dialog box. Next, we print out the item currently selected for our combo box: This is retrieved via the combo box’s currentText() method. The state of the check box widget can again be accessed via a method called isChecked(). The other widgets provide similar methods but the general idea should have gotten clear. You already saw the toPlainText() method of QTextEdit being used, and QLineEdit has a method called text() to retrieve the text the user entered into the widget. We will leave adding additional output for these and the other widgets as an “exercise for the reader”. Please run the script and open/close the dialog a few times after using the widgets in different ways and observe the output produced when dialog is closed. Change to modeless version. The last thing we are going to do in this section is coming back to the concept of modal and modeless dialog boxes and showing what a modeless version of our dialog box would look like. Please add the following three functions to the section “# functions for modeless version”: def openDialogModeless(): dialogBox.show() print(\"We are already back from calling dialogBox.show()\") def dialogAccepted(): printResults() def dialogRejected(): print(\"Exited dialog via cancel button or closing window\") by placing a # in front of it and then insert the following lines below it: We suggest you try out this new version immediately and observe the change. Note how the main window still can be interacted with after the dialog box has been opened. Also note the message in the console “We are already back from calling dialogBox.show()” appearing directly after the dialog window has appeared. Looking at the code, instead of calling openDialogModal(), we are now calling openDialogModeless(). This function uses dialogBox.show() to open a modeless version of our dialog rather than dialogBox.exec_() for the modal version. The message is produced by the print statement directly after this call, illustrating that indeed we return immediately from the function call, not just when the dialog box is closed. As a result, we need the two other functions to react when the dialog box has been closed. We connect the function dialogAccepted() to the \"accepted\" signal of dialogBox that is emitted when the dialog box is closed via the “Ok” button. The function simply calls printResults() and, hence, essentially corresponds to the if-case in function openDialogModal(). Similarly, the dialogRejected() function corresponds to the else-case of openDialogModal() and is connected to the \"rejected\" signal emitted when the dialog is canceled. As you can see, the change from modal to modeless is straightforward and involves changing from working with a return value to working with functions for the \"accepted\" and \"rejected\" signals. Which version to use is mainly a question of whether the dialog box is supposed to get important information from the user before being able to continue, or whether the dialog is a way for the user to provide input or change parameters at any time while the program is executed. One interesting observation if you revisit the code from the three examples in this section, in particular examples 2 and 3, is that while the script code can become rather long, most of this code is for creating the different widgets and arranging them in a nice way. Compared to that, there is not much code needed for wiring up the widgets and implementing the actual functionality. Admittedly, our toy examples didn’t have a lot of functionality included, but it still should be obvious that a lot of time and effort could be saved by using visual tools for producing the GUI layouts in an intuitive way and then automatically turning them into Python code. This is exactly what the next section will be about. While it’s good and useful to understand how to write Python code to create a GUI directly, it’s obviously a very laborious and time consuming approach that requires writing a lot of code. So together with the advent of early GUI frameworks, people also started to look into more visual approaches in which the GUI of a new software application is clicked and dragged together from predefined building blocks. The typical approach is that first the GUI is created within the graphical GUI building tool and then the tool translates the graphical design into code of the respective programming language that is then included into the main code of the new software application. The GUI building tool for QT that we are going to use in this lesson is called QT Designer. QT Designer is included in the PyQT5 Python package. The tool itself is platform and programming language independent. Instead of producing code from a particular programming language, it creates a .ui file with an xml description of the QT-based GUI. This .ui file can then be translated into Python code with the pyuic5 GUI compiler tool that also comes with PyQT5. There is also support for directly reading the .ui file from Python code in PyQT5 and then generating the GUI from its content, but we here will use the approach of creating the Python code with pyui5 because it is faster and allows us to see and inspect the Python code for our application. However, you will see an example of reading in the content of the .ui file directly in Lesson 4. In the following, we will take a quick look at how the QT Designer works. Since you already installed PyQt5 from the ArcGIS Pro package manager, the QT Designer executable will be in your ArcGIS Pro default Python environment folder, either under \"C:\\Users\\<username>\\AppData\\Local\\ESRI\\conda\\envs\\arcgispro-py3-clone\\Library\\bin\\designer.exe\" or under “C:\\Program Files\\ArcGIS\\Pro\\bin\\Python\\envs\\arcgispro-py3\\Library\\bin\\designer.exe”. It might be good idea to create a shortcut to this .exe file on your desktop for the duration of the course, allowing you to directly start the application. After starting, QT Designer will greet you as shown in the figure below: QT Designer allows for creating so-called “forms” which can be the GUI for a dialog box, a main window, or just a simple QWidget. Each form is saved as a single .ui file. To create a new form, you pick one of the templates listed in the “New Form” dialog. Go ahead and double-click the “Main Window” template. As a result, you will now see an empty main window form in the central area of the QT Designer window. Let’s quickly go through the main windows of QT Designer. On the left side, you see the “Widget Box” pane that lists all the widgets available including layout widgets and spacers. Adding a widget to the current form can be done by simply dragging the widget from the pane and dropping it somewhere on the form. Go ahead and place a few different widgets like push buttons, labels, and line edits somewhere on the main window form. When you do a right-click in an empty part of the central area of the main window form, you can pick “Lay out” in the context menu that pops up to set the layout that should be used to arrange the child widgets. Do this and pick “Lay out horizontally” which should result in all the widgets you added being arranged in a single row. See what happens if you instead change to a grid or vertical layout. You can change the layout of any widget that contains other widgets in this way. On the right side of QT Designer, there are three different panes. The one at the top called “Object Inspector” shows you the hierarchy of all the widgets of the current form. This currently should show you that you have a QMainWindow widget with a QWidget for its central area, which in turn has several child widgets, namely the widgets you added to it. You can pretty much perform the same set of operations that are available when interacting with a widget in the form (like changing its layout) with the corresponding entry in the “Object Inspector” hierarchy. You can also drag and drop widgets onto entries in the hierarchy to add new child widgets to these entries, which can sometimes be easier than dropping them on widgets in the form, e.g., when the parent widget is rather small. The “Object” column lists the object name for each widget in the hierarchy. This name is important because when turning a GUI form into Python code, the object name will become the name of the variable containing that widget. So if you need to access the widget from your main code, you need to know that name and it’s a good idea to give these widgets intuitive names. To change the object name to something that is easier to recognize and remember, you can double-click the name to edit it, or you can use “Change objectName” from the context menu when you right-click on the entry in the hierarchy or the widget itself. Below the “Object Inspector” window is the “Property Editor”. This shows you all the properties of the currently selected widget and allows you to change them. The yellow area lists properties that all widgets have, while the green and blue areas below it (you may have to scroll down to see these) list special properties of that widget class. For instance, if you select a push button you added to your main window form, you will find a property called “text” in the green area. This property specifies the text that will be displayed on the button. Click on the “Value” column for that property, enter “Push me”, and see how the text displayed on the button in the main window form changes accordingly. Some properties can also be changed by double-clicking the widget in the form. For instance, you can also change the text property of a push button or label by double-clicking it. If you double-click where it says “Type Here” at the top, you can add a menu to the menu bar of the main window. Give this a try and call the menu “File”. Figure 2.23 Adding a File menu to the menu bar by double-clicking on \"Type Here\" The last pane on the right side has three tabs below it. “Resource browser” allows for managing additional resources, like files containing icons to be used as part of the GUI. “Action editor” allows for creating actions for your GUI. Remember that actions are for things that can be initiated via different GUI elements. If you click the “New” button at the top, a dialog for creating a new action opens up. You can just type in “test” for the “Text” property and then press “OK”. The new action will now appear as actionTest in the list of actions. You can drag it and drop it on the File menu you created to make this action an entry in that menu. Figure 2.24 A new action created in the Action Editor window Finally, the “Signal/Slot Editor” tab allows for connecting signals of the widgets and actions created to slots of other widgets. We will mainly connect signals with event handler functions in our own Python code rather than in QT Designer, but if some widgets’ signals should be directly connected to slots of other widgets this can already be done here. You now know the main components of QT Designer and a bit about how to place and arrange widgets in a form. We cannot teach QT Designer in detail here but we will show you an example of creating a larger GUI in QT Designer as part of the following first walkthrough of this lesson. If you want to learn more, there exist quite a few videos explaining different aspects of how to use QT Designer on the web. For now, here is a short video (12:21min) that we recommend checking out to see a few more basic examples of the interactions we briefly described above before moving on to the walkthrough. What is goin' on everybody? Welcome to a tutorial covering the Qtdesigner. So, up until this point, we haven't really covered much in the way of layouts because we've been manually coding everything via pyqt and idol, so we haven't really covered layouts because probably the best way to do layouts is going to be via Qtdesigner. So, it's not so much programming here, as far as the layout is concerned, but this is going to save you tons of time. So it's pretty stupid not to use it, if you ask me. So, if you have pyqt installed and you did the full installation like I was showing you guys, you should have the Qtdesigner. Now, when you first open up the Qtdesigner, you'll have this choice here - generally, you're going to choose main window or widget. The main window is like a main window - it comes with the main menu and stuff - so that's kind of what we want most likely but- yeah, so we'll just choose that one. And then what you're given, once it pops up, is just a simple window to work with here. And, just to talk real briefly about how the Qtdesigner is actually laid out itself, on the left hand side here you've got all the widgets, right? So you've got some layout widgets, which we haven't talked about yet, but then a bunch of other stuff like spacers, and push buttons, and checkboxes, and calendar stuff, and labels here- just basically everything, right, that- that is a part of Qt. So, these are all of our options, and it's really as simple as click and drag - bam!: you've got a button. Bam!: you've got a checkbox. Want a horizontal spacer? You got it! So it’s a nice al-la-cart menus here. And, I don't know… let's add a label, too, while we're at it. Okay? So, you've got all this kind of stuff- and, so what it's allowing us to do is really just do the layout aspect. So, the functionality and the code of, you know, what happens when I push a button - we still have to handle that, but the layout we do with Qtdesigner, and this is really really great because, especially when we talk about layouts here in a moment, you'll see that, if you want to deal with those, it's going take so much longer to do it manually, especially if you change your mind. So once you have like a window kind of set up, what you can do is- obviously, like- you can kind of- I mean, this is basically the window- but if you really want to see the window - right? - like your horizontal spacer isn't going to look like that. So, what you can do is you can come to Form, and then Preview - either Preview, which is control r, or you can Preview in, and you can preview, like, the basic styles that you have access to- so you can preview like these specific things like this, or you can just control r and preview it, you know, like this. So we have this window, and, if we resize this window, though, we'll see kind of the same problem that we had had initially- is that the window- the stuff within the window doesn't resize as it ought to. So, that's what we use layouts for. So, you can apply a layout to the entire window itself by just right-clicking somewhere in open space and then coming down to layout and just choose a layout. So you got- let's do let's do a horizontal layout, so then it’ll just give us, like, columns; so this would be column 1, column 2, 3, and 4. So let's- this divider is basically worthless, so I’m going to delete it... at least I thought I was going to delete it- Get over here! I can't- I can't seem to- there- Oh my goodness- there we go. Okay, deleted it. Okay, so, we've got those, and then another example here is- actually let's do a layout- let's break that initial layout, and let's give this a grid layout, actually. There we go - layout and grid. Okay? So then we can, like, move things all around and it kind of shows us the valid places that we could stuff stuff. Now, the other nice thing is you can have the entire window as a grid layout, but then you can throw in another layout like, okay, we want one of the grid spots to be a vertical layout, right, and then we can kind of- well this one isn't going to let us change the size- but then we can, okay, throw in- let's throw in a push button in there, and then let's try to stuff something else in there - see if we get away with it. Yeah. So, as you can see, this is part of that grid layout that we just built, but, then, within that grid layer- layout, we have a vertical layout as well. So now, though, let's do control r, and we can see here, now, we can resize this, and everything resizes with it, right? And, so, that's pretty nice. So, some of the other things that we might have a problem with is, like, for example, this says text label, and this is push button, and checkbox, and all this stuff. Well, to change that, it's pretty simple - you just double-click on it, and you can put whatever you want. So we'll put 'hello there,' and then ‘push me,’ and then ‘or me,’ and then, 'but not me’ - okay? - something like that, and 'check here.' That's good enough. So, then, on this- that's kind of like this, the stuff that we have on the left-hand side here. But, now, looking on the right-hand side, we have Object Inspector, we've got a Property Editor, which I didn't mean to move, and then we have Resource Browser. Now, I don't really use Resource Browser - not really sure what its purpose is - but Object Inspector and Property Editor are pretty useful. So, the Object Enspector - this is like for your entire window - you know, what's going on here? You've got the main window, then you've got the central widget, which is this grid layout, you've got the stuff that is within the grid layout, and they've got this new vertical layout and the stuff that's contained within it - so that's kind of the structure of the application. Then, down here, you've got the Property Editor. Depending on what you select, will show up in this Property Editor. So we could click on this button, and we get- oh it's this 'push button'- and, mainly, these are just kind of the settings. You probably won't change these very- very often, but one thing you should definitely always change is the object name. So, the object name - here's 'push-button' - this is the object name, like, in your code, so this button is defined by 'push button.' This, one 'push-button three,' this one, 'push-button two'- that's not very useful, so, before we push this to python code, we definitely want to rename these. So, maybe this one would be, you know, 'but not mel’ right, to be kind of... going along with the name of the button itself, and then we could name this one, you know, ‘push me,’ and then this one could be ‘or me,’ right? Whoops - highlighted a little too much there. ‘or me.’ Okay? So you can do stuff like that. Also, if you ever wanted to change, like, the window's title, you can't- like, you can't really click on the window and it pop-up, but you can come over to the Object Inspector, click on main window, and then you come down here to window title, and you can change the window title. So, I don't know, 'Qt type' - that's what I’ll call it. So there's that. Also, if you want to add, like, a menu, you can totally do that - just double click there, start typing stuff, right? File, open, save, let's add a separator, bam, and then ‘exit.’ Okay? Instantly done. Right? That would have taken us, like, you know, I don't know, three or four minutes to do; we just did it, like, instantly. And then here, luckily for us, we've got Action Open, this one says Action Save, this one's Action at- Exit, so this one actually makes a little more sense automatically - you don't have to change the name - but you can if you want. So there's that. And then, obviously, if you wanted to add more items as you, kind of, do stuff here, right, if I added 'edit' here, it gives us a new option later, you know- So, as you add more to this menu bar, it just automatically adds stuff, you know? So, if you wanted to, you could. Now how do we actually get this to python code? So, if you're on windows and you go, say, Form, View Code, you might get this error. This is, like, a known error - it makes no sense to me why this error still is in existence, but it is. So, what we want to do, if that didn't work for you, is you can go File, Save As, and we can save this. I'm going to save it in this really deep directory, in testing, and we're going to call this pyqtdesigner, and it'll be a .ui file - that's just what it's being saved as. We'll go ahead and save that, no problem. So I have that file now - it's just right in here - and, what we want to do now is open up a console in there. So, open command window into there. So, make sure you're in the actual directory of that file, right? So that's where the file is - that's the path to this file. So, if you don't know how to do that, you can always hold shift, and right-click the directory, and you can open a command window there. So, once you've done that, now we have to enter in some code to get this to convert. So, if you- if you can, you could sometimes get away with just doing py uic - x for executable, and then we can change- we can say pyqtdesigner.ui- that's what I saved it as- yeah, and then dash O for the output file, and we're just- we'll say pyqtdesigner.py, but I don't think this will end up working for me. But it might work for you - we'll try it. Right. So, it's probably gonna come up and say it's not recognized as a command. So now we need to reference that py.uic file - it's like a batch file - so now let's reference that. So, it would be c colon slash python 34, or whatever version you're using, and then lib/ site -packages / pyqt4, or 5, or 6, or whatever is at the time that you're watching this, /piyuic4, or 5, or whatever .bat and then - same thing as before – x for executable - if you don't use the x it won't, like, actually create a window, it'll just be a bunch of definitions - you can run it but, it's not going to do anything, and then we want to do this pyqtdesigner.ui, and then we want to do the -o, and then we'll do the output to pyqtdesigner.py. Okay? So we'll do that, hit enter, and you should now have a new file there, right? It should be pyqtdesigner. We can open it- edit with idol. Here's all that code. Again, there's no real functionality to it - it's just the layout and just the ui only - but let's go ahead and run that. And,sure enough, here's our window. And that's that. So, you've got all the python code there, you did it in the designer, obviously this isn't really any advanced code, but, hey we built that in, like, 10 minutes, so- that would have taken us a lot longer than ten minutes to build all of that including- especially thinking about, like, the layouts that are involved here- and then, like, what happens when you're like, 'hmm, I want to change layouts' - well, that's a really- kind of a challenge, especially if you have, like, a lot of stuff inside your layouts - to kind of mentally go through what objects need to be moved to what place in your code - that's pretty hard. And, so, having the Qtdesigner there just- it makes it so much simpler. So, anyways, that's just a really quick introduction to Qtdesigner. Obviously there's a whole lot more to - it this was kind of a silly application, but, from here, all we really need to do is, you know, use connect to connect functions to these buttons, but we've already covered how to do that, so I’m not going to waste any time and do these simple connections to the buttons. But, hopefully you can see, now, how powerful just Qtdesigner is, because, really, as far as I know, there's no tk designer - but maybe I’m wrong. If I’m wrong, let me know. But Qtdesigner just makes things so much easier. So, anyways, that's it for this tutorial. If you have any questions or comments, go ahead and leave them below. Otherwise, as always, thanks for watching, thanks for all the support and subscriptions, and until next time. Once you have created the form(s) for the GUI of your program and saved them as .ui file(s), you can translate them into Python code with the help of the pyuic5 tool, e.g. by running a command like the following from the command line using the tool directly with Python : , depending on where your default Python environment is located (don't forget to replace <username> with your actual user name in the first version and if you get an error with this command try typing it in, not copying/pasting). mainwindow.ui, here, is the name of the file produced with QT Designer, and what follows the -o is the name of the output file that should be produced with the Python version of the GUI. If you want, you can do this for your own .ui file now and have a quick look at the produced .py file and see whether or not you understand some of the things happening in it. We will demonstrate how to use the produced .py file to create the GUI from your Python code as part of the walkthrough in the next section.\n\nIn this walkthrough, our main goal is to demonstrate how to build a small software application with a reasonably complex GUI in Python with the help of PyQt5 and the QT Designer. The software is supposed to work as a stand-alone application but also as a script tool inside ArcGIS Pro. Furthermore, while part of its functionality will require arcpy, we also want it to provide some functionality if arcpy is not available. Therefore, this walkthrough will also show how one can check whether a Python script is run inside ArcGIS or not, and whether arcpy is available or not. Finally, since the software will query some geographic web services that return JSON code, the walkthrough will be a continuation of what we started in Section 2.3 where you learned about Python packages that support dealing with URLs and web requests as well as working with JSON code. Note: Unfortunately there currently is an issue with the newest versions of ArcGIS Pro (version 2.8 and above) that will make the application from this walkthrough crash when it is run as a script tool inside ArcGIS. We have not yet been able to find a workaround for this issue that does not require re-designing the GUI of the app. The issue seems to be related to specific QT5 widgets (menu bar, status bar, etc.) used in the program. You will still be able to run the software as a stand-alone application though if you have one of these versions. The idea of the little software tool we are going to build is that sometimes you would like to be able to quickly create a feature class with points for certain places based on their names. Let’s say you want to produce a shapefile showing a few places in the city you are living in. What you could do is open a basemap in ArcGIS or some other GIS software and then digitize point features for these particular locations. Or you could look up the coordinates of the places in some external application such as Google Maps and then create new point features based on these coordinates manually or by exporting the coordinates in a format that can be imported by your GIS. Both these options are relatively time consuming and require several steps. We therefore want to exploit the fact that there exist many web services that allow for querying for geographic places based on name, type, and other properties, and getting back the coordinates. The two web services we are going to work with are the Nominatim query interface to OpenStreetMaps (OSM) and the place query interface of the online geographic gazetteer GeoNames. We will discuss these services in more detail below. Our tool should allow us to enter a query term such as a place name, pick a query service and set some additional query options, and then run the query to get a list of candidate places with coordinates. We can then look at the result list and pick one or more candidates from the list and either\n• add them to a layer currently open in ArcGIS Pro (assuming that the software is run as a script tool inside ArcGIS),\n• add them to a shapefile on disk, or\n• add the result to a CSV text file (basically an alternative that still works even when arcpy is not available). Figure 2.20 and the video below show the GUI of the software and further illustrate how the tool works. The use case in the shown example is that we use the tool to populate a layer open in ArcGIS Pro with some of the main sightseeing locations in Paris including the Eiffel Tower, the Louvre, etc. Figure 2.25 The interface of the Locations from Web Services tool Please watch the following video, Location from Web Service Tool Overview (5:25min): Hello. In this video, I'm quickly going to show you, or demonstrate to you, the tool that we are going to build in this walkthrough, the tools for querying different surfaces on the map to create point features, and then add them either to an open layer in ArcGIS, to a shape file on disk, or just to a CSV text file. And you can see the tool here on the right on the screen, I'm currently running it inside of ArcGIS Pro, and I've already used it to add a few places for different attractions in Paris. And, um, so the GUI is structured into four different parts. We have the part at the top, where the user can enter a query to a name of a place. Then we have an area where he can choose between different web services to query. Then an area where he will see the results of this query. And then an area where he can add the features he wants to from some data source. So let's demonstrate this by querying for Eiffel Tower. And I'm going to use the Nominatim query interface to OpenStreetMap. I'm not going to use any of the options for this first query-- just pick the Run Query button. And you see that then the result lists here is updated based on what you get back from this Nominatim web service. And we have this nice little map, which appear on the right, that shows us the different results on the map, which can also be very handy. Obviously, we are interested in the one here that is located in Paris. So we can actually click on that one, and then see, OK, this is the one called Eiffel Tower. So, basically the third one here from our list-- so what I can do is use the buttons below the results to clear the selection, and then to say, I just want this entry here. And, here at the bottom, you can see that I'm currently on the tab for adding the features to a layer in ArcGIS Pro. And I've selected the Paris example layer that I set up for this project, and the names of the features should be stored in the field called name of that layer. So I would just click the Add button now to add this one feature for the Eiffel Tower to this data set. And actually, for having it show up on the map, I need to zoom in and out a bit so the map gets updated. And then you see here now that this new point has been added. And, just to show you the rest of the interface-- we have another tab here for instead of Nominatim querying the geo name step service, with different options for that. And we have also the tab that allows us for directly entering features with name, latitude, and longitude. So let's say I have created this map for a friend, and now I also want to add my home as a place to that map. I could enter it here, my home, and then I would have to enter some coordinates. So let's hope that I'm going to find something that's at least somewhere in the area of Paris. It's still-- the button has to run code run query, but in principle it just creates a single point feature from what I entered here, that is shown here on the list. Looks like I actually at least - it's somewhere in Paris. And I can now also add that one to the layer here. So I'm not sure which one is in the place, I think it's the one up here-- that one here. So that's now-- I can click on it, yes, that's the place, my home. So you see now that the result has indeed been added to the layer. And just to look at the last steps here-- so the shape file tab would allow us to, instead, add the features a shape file on disk. And there's also the option to create a new shape file for that purpose that opens a separate dialog box, for which you also will have to create the graphical user interface. And the last one is the CSV tab, where it just can select a file to which the features will be added as, basically, name, latitude, longitude columns. And the buttons with the three dots on it are always for opening a file a dialogue for selecting a particular shape file or CSV file. OK, so much for this overview, and now we will move on to actually create the graphical user interface for this tool. The GUI is organized into four main parts:\n• The text field for entering the query term. We are currently querying for \"Eiffel tower\".\n• The section where you pick a web query service and set some additional options. The figure shows the interface for the Nominatim OSM service. In addition to Nominatim and GeoNames, we also have a “Direct Input” tab for adding places directly by providing a name and lat/lon coordinates.\n• Since the query has already been run, the \"Results\" section shows different candidate toponyms returned by the Nominatim service for our query. The third one looks like the result we want, so we selected just that one. The selection can be changed with the help of the buttons below or by directly checking or unchecking the checkboxes. Next to the result list is a browser widget that is used to display a Leaflet based web map of the results.\n• The final section is for adding the selected features to some dataset. The figure shows the tab for adding them to a currently open layer in ArcGIS Pro. We can run as many queries as we wish with the tool and collect the results we want to keep in one of the possible output options. While we will only present a basic version of the tool in this walkthrough supporting two different query interfaces and direct input, the tool could easily be extended to provide access to other web portals so that it can be used for running queries to, for instance, get locations of all Starbucks located in a particular city or create locations from a list of addresses. Before we continue with exploring the GUI and code of the application, let us talk about the two web services we are going to use: Nominatim – Surely, you know about OpenStreetMaps (OSM) and how it collects geographic data from volunteers all over the world to create a detailed map of the world. OSM data is freely available and can be directly exported from the OSM web site. In addition, there exist quite a few web services built around the OSM data, some of them created with the purpose of allowing for querying the data to only obtain information about particular features in the data. One such example is the Nominatim web service provided by OSM themselves. The website for Nominatim Open Street Maps provides an easy to use interface to the Nominatim query engine. You can type in a search term at the top and then will get to see a list of results displayed on the left side of the page and an OSM based map on the right that shows the currently selected entity from the result list. Give it a try, for instance by running a query for “Eiffel tower, France”. Note: With some recent changes, it seems Nominatim has become much more restrictive and will often only return a single result rather than multiple options. If you leave out the 'France' in the query, the only result returned will actually not be the Eiffel Tower in Paris. However, you will still get multiple results if you, for instance, enter 'Washington' as the query string. Due to these changes, the results you will get when using Nominatim in the Locations from Web Services Tool will partially deviate from what is shown in the figures and videos in this section (for instance, the list of options shown in Figure 2.25 when only querying for 'Eiffel tower' without country name. Nominatim provides an HTTP based web API that can be used for running queries from your own code and getting the results back, for instance as JSON or XML data. The web API is explained on this wiki page here. Query terms and additional parameters are encoded in a URL that has the general format: where parameters are specified as <parameter name>=<parameter value> pairs and multiple parameters have to be separated by an & symbol. The parameter name for the query string is simply 'q' (so q=...). To run the query, the client sends an HTTP GET request with this URL to the Nominatim server who processes the query and parameters, derives the result, and sends back the results to the client. The format parameter controls how the result is presented and encoded. Without specifying that parameter, you will get the kind of HTML page that you already saw above with the result list and map. When using format=json as we will do in the following, we get the result as a list of entities encoded as JSON. Here is an example query URL, querying for “Eiffel tower, France” again, that you can test out simply by clicking on the link to open the URL in your browser: Have a look at the result shown in your browser. As we explained at the beginning of the lesson, JSON uses [...] to denote lists of entities where each entity is described by its properties like in a Python dictionary: Due to the changes, we mentioned above, the result will be a list with just a single entity, looking like this ... We can see that the most important properties for us will be the ‘display_name’ property and the ‘lat’ and ‘lon’ properties (appearing in bold above) in order to create point features and add them to an existing data set with our tool. Feel free to compare this result to what you get when querying for 'Washington' where you will get a list of multiple results. The following query uses a few more parameters to query for places called London in Canada (countrycodes=CA) and asking for only a single entity be returned (limit=1). If you look at the result, you will see that it lists London in Ontario as the only result. Without using the ‘countrycodes’ parameter the result would have been London in the UK because Nominatim uses a ranking scheme to order entities by likelihood/prominence. Without the 'limit' parameter, we would get a list of multiple options in the JSON result. ‘format’, ‘countrycodes’ and ‘limit’ will be the only parameters we will be using in our tool but please have a look at the other parameters and examples given on the Nominatim wiki page to get an idea of what other kinds of queries could be implemented. GeoNames – You have already seen the Nominatim examples, so we can keep the section about GeoNames a bit shorter, since the URLs for running queries are somewhat similar. GeoNames is essentially an online geographic gazetteer, so a directory of geographic place names with associated information including coordinates. The main page can be used to type in queries directly but we will be using their REST web API that is documented here. Instead of a parameter for specifying the output format, the API uses a special URL for running queries that are replied to using JSON, as in the following example: Please note that a parameter (name=) is used to specify the query term. In addition, GeoNames requires a user name to be provided with the ‘username’ parameter. In case you tried out the link above, you probably got the reply that the daily request limit for user ‘demo’ has been reached. So you will have to create your own account at http://www.geonames.org/login and then use that user name instead of ‘demo’ in the query. The JSON sent back by GeoNames as the result will start like this: { \"totalResultsCount\": 3308, \"geonames\": [ { \"adminCode1\": \"IL\", \"lng\": \"-89.64371\", \"geonameId\": 4250542, \"toponymName\": \"Springfield\", \"countryId\": \"6252001\", \"fcl\": \"P\", \"population\": 116565, \"countryCode\": \"US\", \"name\": \"Springfield\", \"fclName\": \"city, village,...\", \"adminCodes1\": { \"ISO3166_2\": \"IL\" }, \"countryName\": \"United States\", \"fcodeName\": \"seat of a first-order administrative division\", \"adminName1\": \"Illinois\", \"lat\": \"39.80172\", \"fcode\": \"PPLA\" }, { \"adminCode1\": \"MO\", \"lng\": \"-93.29824\", \"geonameId\": 4409896, \"toponymName\": \"Springfield\", \"countryId\": \"6252001\", \"fcl\": \"P\", \"population\": 166810, \"countryCode\": \"US\", \"name\": \"Springfield\", \"fclName\": \"city, village,...\", \"adminCodes1\": { \"ISO3166_2\": \"MO\" }, \"countryName\": \"United States\", \"fcodeName\": \"seat of a second-order administrative division\", \"adminName1\": \"Missouri\", \"lat\": \"37.21533\", \"fcode\": \"PPLA2\" } ] } Here the list of entities is stored under the property called ‘geonames’. Each entity in the list has the properties ‘toponymName’ with the entity name, ‘lng’ with the longitude coordinate, and ‘lat’ with the latitude coordinate. Query parameters we will be using in addition to ‘name’ and ‘username’ are ‘maxRows’ to determine the number of results sent back, ‘country’ to restrict the search to a single country, and ‘featureClass’ to look only for features of a particular type (codes A,H,L,P,R,S,T,U,V of the GeoNames feature class codes defined here). The GUI of our software application is not too complex but still uses many of the most common GUI elements such as a toolbar with a tool button, normal push buttons, group boxes, tabs, labels, text input fields, checkboxes, combo boxes, list views, and a status bar. You already got to know most of these in Section 2.6 but there are also some new ones. The GUI consists of two parts, the GUI for the main window and the GUI for the dialog box that is shown when the user clicks on the “Create new shapefile…” button. Therefore, we will be producing two different .ui files with QT Designer called gui_main.ui and gui_newshapefile.ui. The GUI of the main window uses a vertical layout to organize the different elements into four different rows as shown in the figure below. Each of the rows is formed by a QGroupBox widget and then other widgets are arranged hierarchically within these group boxes using a combination of grid and horizontal layouts. The tool doesn’t have a menu bar but a toolbar at the top with a button to exit the program and a status bar at the bottom. When creating the GUI in QT Designer, it will be important to name the widgets we need to refer to from our main code as indicated by the orange labels in the two figures below. As we already pointed out, the object names given to the widgets in QT Designer will be the names of the variables used for storing the widgets when the .ui file is compiled into a .py file. Figure 2.26 Location from Web Services main GUI with labels showing the object names of the different widgets The series of videos linked below shows the process of creating the GUI in QT Designer. A zip file with the resulting .ui files is available for download here. We recommend that you work along with the video, pausing it as needed, to create the GUI yourself to get some more practice with QT Designer. The downloadable .ui files are mainly intended as a fallback position in case you experience any difficulties while creating the GUI or later on when compiling the .ui files and using the produced Python code. If you cannot replicate what is shown in the video, please ask for help on the discussion forums. Create the GUI along with this series of videos [~45 min of video materials] At this point, you either have saved your own two .ui files or, if you ran into any issues, will continue with these files downloaded from the link posted above. We now need to compile the files into Python code with pyuic5. We do this by running the ArcGIS Pro python.exe from the Windows command line with the pyuic module. The python.exe file is located in the folder “C:\\Users \\<username>\\AppData\\Local\\ESRI\\conda\\envs\\arcgispro-py3-clone\\\" (unless the ArcGIS Pro Python environment you are using is located in a different folder). So open a command shell, navigate to the folder containing the .ui files and then run the following two commands (again picking the correct version depending on where your default Python environment is installed and replacing <username> as needed): Figure 2.28 Pyuic5 commands to compile the two .ui files into Python files Note: If you get a file not found error such as after running the command, remove the \" - \" symbol from the m and o and type them again. These symbols may come across as a different encoding and cause the command to fail. The parameters given to pyuic5 are the name of the input .ui file and then –o followed by the name of the output file. You should now have the two files gui_main.py and gui_newshapefile.py in the project folder. Let us have a quick look at the produced code. Open the produced file gui_main.py in your preferred Python IDE and see whether you recognize and understand how the different elements are created and how their properties are set. Without going into the details, the code defines a class Ui_MainWindow with a method setupUi(…). The parameter MainWindow is for passing a QMainWindow widget to the method. The rest of the code of the method then either...\n• creates new widgets and layouts storing them as attributes of the Ui_MainWindow object and sets their properties, or\n• adds widgets to MainWindow or to other widgets to create the hierarchical organization of the widgets. class Ui_MainWindow(object): def setupUi(self, MainWindow): … MainWindow.resize(605, 685) # changes property of main window widget self.centralwidget = QtWidgets.QWidget(MainWindow) # creates child widgets and stores them in attributes of the Ui_MainWindow object … MainWindow.setCentralWidget(self.centralwidget) # adds widgets to main window … This all means that we can create a new QMainWindow widget in our code with ... ... create an object of the UI_MainWindow class with ... and then create the GUI for the main window by calling ui.setupUi(…) with mainWindow as the parameter: Whenever we need to access a widget created by setupUi(…), we can do so by using the expression ui.<object name of the widget> where the object name is the name we gave the widget in QT Designer, e.g. for the QLineEdit widget we created for entering the query term. 2.7.3 Main code of the tool and how it works 2.7.3 Main code of the tool and how it works Now we are going to develop the main code for our tool that imports the gui_main.py and gui_newshapefile.py files, sets up the application, and connects the different GUI elements with event handler functions and functions that realize the actual functionality of the tool. We will organize the code into several modules. In particular, we will keep the functions that realize the main functionality, such as querying the different web portals, creating a new shapefile, etc. in a separate Python script file called core_functions.py . These functions are completely independent of the GUI of our tool and the few global variables we will need, so we might want to use them in other projects. Separating the project cleanly into GUI dependent and GUI independent code fosters reusability of the GUI independent code. Overall, the project will consist of the following Python files:\n• gui_main.py – compiled version of gui_main.ui for setting up the GUI of the main window,\n• gui_newshapefile.py – compiled version of gui_newshapefile.ui for setting up the GUI of the dialog box for creating a new shapefile,\n• core_functions.py – contains definitions of functions for main functionality that are completely independent of GUI and global variables\n• main.py – contains the event handler functions and the code for wiring up the GUI as well as setting up and running the application In the following, we will focus on the code from main.py but we will start with a brief look at core_functions.py, so please download the file core_functions.py and open it so that you can read the code for the different functions. Most of the functions defined in the script should be rather easy to understand from the comments in the code and from your experience with using arcpy to work with shapefiles. Here is an overview of the functions with a few additional explanations:\n• queryNominatim(query, limit=10, countryCodes=''): The purpose of this function is to query the Nominatim query interface of OSM for a query string and parameters for the limit of results returned and country code for the country to search in as discussed in Section 2.7.1. The code should be easy to understand: urllib.parse(…) is used to encode the query string to be used as part of a URL, before the final query URL is put together. The get(…) method of the requests package is used to run the actual query and the returned result is translated into JSON before being returned. Since no error handling is done in this function, we will have to deal with potential exceptions raised within the function in the code that calls this function.\n• queryGeonames(query, maxRows = 10, username='', country='', featureClass=''): This function does the same as queryNominatim(...) but for GeoNames and for a different set of query parameters. Since GeoNames returns JSON code with the list of candidate features stored under the attribute 'geonames', we return json['geonames'] at the end.\n• getStringFieldsForDescribeObject(desc): This is the first of a few auxiliary functions for getting information from shapefiles and layers. An arcpy.Describe object of a data set needs to be passed to it and it then returns a list of all editable string fields of that layer.\n• getValidFieldsForShapefile(fileName): This function is used to get a list of editable string fields for a shapefile whose name is provided as a parameter. It relies on getStringFieldsForDescribeObject(…) to do most of the work but before that checks that the shapefile exists and is a Point vector data set. If not, it will return an empty list.\n• createPointWGS1984Shapefile(fileName, fieldName): This function creates a new Point shapefile with the name provided as parameter, using WGS 1984 coordinates, and with a single additional string field whose name is also provided as a parameter.\n• getPointLayersFromArcGIS(): This function is for getting a list of Layer objects for the layers currently open in ArcGIS Pro but only including Point layers.\n• importArcpyIfAvailable(): This function returns True if arcpy is available for import, else False. It attempts to import arcpy within a try-except construct so that, if the operation fails, the resulting exception is caught and False is returned.\n• runningAsScriptTool(): This function returns True if the program is run as a script tool inside ArcGIS, else False. This is accomplished by calling arcpy.mp.ArcGISProject(\"CURRENT\") and catching the resulting exception if this operation fails, meaning the program is run as a standalone program outside of ArcGIS.\n• webMapFromDictionaryList(features): This function produces and returns the HTML code for displaying the web map as part of the GUI. It gets the features that should be displayed on the map as parameter in the form of a list of dictionaries with name, lat, and lon attributes. Now that you know the functions we have available for realizing the different operations that we will need, let’s develop the code for main.py together. Open a new file main.py in your IDE, then follow the steps listed on the next few pages. We start by importing the different packages of the Python standard library and PyQt5 that we will need in this project. In addition, we import the gui_main.py and gui_newshapefile.py files so that the Ui_MainWindow and Ui_Dialog classes defined in them are available for creating the GUIs of the main window and dialog for creating a new shapefile, and of course the core_functions module. We are not importing arcpy here because we want the tool to be runnable even when arcpy is not available and that is why we defined the auxiliary function for testing its availability in core_functions.py. In addition, we are including some comments to define sections within the script for different purposes. We will fill in the code for these sections step-by-step in the following steps. At the very end, we already have the by-now-familiar code for showing the main window and starting the event processing loop of our application (even though we are not creating the application and main window objects yet). import sys, csv from PyQt5.QtWidgets import QApplication, QMainWindow, QStyle, QFileDialog, QDialog, QMessageBox, QSizePolicy from PyQt5.QtGui import QStandardItemModel, QStandardItem, QDoubleValidator, QIntValidator from PyQt5.QtCore import QVariant from PyQt5.Qt import Qt try: from PyQt5.QtWebEngineWidgets import QWebEngineView as WebMapWidget except: from PyQt5.QtWebKitWidgets import QWebView as WebMapWidget import gui_main import gui_newshapefile import core_functions # ======================================= # GUI event handler and related functions # ======================================= #========================================== # create app and main window + dialog GUI # ========================================= #========================================== # connect signals #========================================== #================================== # initialize global variables #================================== #============================================ # test availability and if run as script tool #============================================ #======================================= # run app #======================================= mainWindow.show() sys.exit(app.exec_()) You may be wondering what is happening in lines 8 to 10. The reason for the try/except construct is because we are using a web view widget in the \"Results\" part of the GUI to display a Leaflet-based web map of the results. There have been some changes with regard to the web view widget over the last versions of QT5 with the old class QWebView becoming deprecated and a new class QWebEngineView being added to replace it. The purpose of the code is to use QWebEngineView if it is available (meaning the code is run with a newer version of PyQt5) and otherwise fall back to using QWebView. The alias we assign the import to (WebMapWidget) is used to make sure that in both cases the imported class and functions is available under the same name in our code. If the application does not start and results in a \"\" error, you may have to pip install QtWebEngineWidgets in the Python Command Window (from earlier in the lesson) to install the package. Then comment out the try/except and adjust the from PyQt5.QtWebEngineWidgets import QWebEngineView as WebMapWidget line so it is correct. If this does not resolve the error, please let your instructor know. In the next step, we add the code for creating the QApplication and the QMainWindow and QDialog objects for the main window and the dialog for creating a new shapefile with their respective GUIs. For this, please paste the following code into your script directly under the comment “# create app and main window + dialog GUI”: app = QApplication(sys.argv) # set up main window mainWindow = QMainWindow() ui = gui_main.Ui_MainWindow() ui.setupUi(mainWindow) ui.actionExit.setIcon(app.style().standardIcon(QStyle.SP_DialogCancelButton)) ui.layerRefreshTB.setIcon(app.style().standardIcon(QStyle.SP_BrowserReload)) ui.directInputLatLE.setValidator(QDoubleValidator()) ui.directInputLonLE.setValidator(QDoubleValidator()) ui.nominatimLimitLE.setValidator(QIntValidator()) ui.geonamesLimitLE.setValidator(QIntValidator()) mapWV = WebMapWidget() mapWV.page().profile().setHttpAcceptLanguage(\"en-US\") mapWV.setHtml(core_functions.webMapFromDictionaryList([])) ui.resultsListAndMapHBL.addWidget(mapWV) mapWV.setFixedSize(300,200) mapWV.setSizePolicy(QSizePolicy(QSizePolicy.Fixed,QSizePolicy.Fixed)) # set up new shapefile dialog createShapefileDialog = QDialog(mainWindow) createShapefileDialog_ui = gui_newshapefile.Ui_Dialog() createShapefileDialog_ui.setupUi(createShapefileDialog) In lines 4 to 6, we are creating the mainWindow object and then its GUI by calling the ui.SetupUi(…) method of an object we created from the Ui_MainWindow class defined in gui_main.py. The same happens in lines 23 to 25 for the dialog box for creating a new shapefile. The rest of the code is for creating some additional elements or setting some properties of GUI elements that we couldn’t take care of in QT Designer:\n• Lines 8 and 9: Here we set the icons for the exit and refresh tool buttons in the GUI taking icons from the QT standard icon set.\n• Lines 11 to 14: What happens here is something that we did not discuss before. QT provides some way to set up so-called Validator objects for determining what the user is allowed to enter into a line edit widget. We use QDoubleValidator and QIntValidator objects to restrict the input for Latitude and Longitude widgets of the “Direct Input” tab to floating point numbers and for the Limit widgets of the Nominatim and GeoNames query tabs to integer numbers, respectively.\n• Line 16 to 20 are for creating the web view widget next to the list view widget in the third row of our main window layout. Remember how we explained in the previous section that we are defining the name WebMapWidget as an alias for the web widget that is available in the version of PyQt5 that is being used. In QT Designer, we created a QHBoxLayout for this row which is now accessible in ui.resultsListAndMapHBL, so we add the new widget to that layout and make some changes to its layout related attributes to give the widget a constant size that matches the size of the web map produced by the function webMapFromDictionaryList(…) from the core_functions.py module.\n• At this point, you can actually run the code and it should already produce the desired GUI for the main window. You just won’t be able to do much with it, since we have not defined any event handlers yet. We now add some code to initialize some global variables that we will need. Please add the following code directly under the comment “# initialize global variables”: # dictionary mapping tabs from services tab widget to event handler functions queryHandler = { ui.nominatimTab: runNominatimQuery, ui.geonamesTab: runGeonamesQuery, ui.directInputTab: runDirectInput } # dictionary mapping tabs from add feature tab widget to event handler functions addFeaturesHandler = { ui.layerTab: addFeaturesToLayer, ui.shapefileTab: addFeaturesToShapefile, ui.csvTab: addFeaturesToCSV } result = [] # global variable for storing query results as list of dictionaries arcValidLayers= {} # dictionary mapping layer names to layer objects arcpyAvailable = False # indicates whether is available for import runningAsScriptTool = False # indicates whether script is run as script tool inside ArcGIS The first two variables defined, queryHandler and addFeaturesHandler, are dictionaries that contain the information of which event handler functions should be called when the “Run query” button and “Add features” button are clicked, respectively, depending on which of the tabs of the two different tab widgets are currently selected. Line 2, for instance, says that if currently the tab ui.nominatimTab is open in the Services section, then the function runNominatimQuery(…) should be called. So far we have not defined that function yet, hence, you will not be able to run the program at the moment but it shows you that functions in Python are treated like other kinds of objects, meaning they can, for instance, be stored in a dictionary. You will hear more about this in Lesson 3. The other global variables we define in this piece of code are for keeping track of the results currently displayed in the Results list view widget of our GUI, of the currently open Point layers in ArcGIS when being run as a script tool, of whether the arcpy module is available, and of whether the program is being run as a script tool or not. We will add code to initialize the last two of these variables correctly in a moment To now initialize the variables arcpyAvailable and runningAsScriptTool correctly and potentially disable some GUI elements, please add the following code directly under the comment “# test availability and if run as script tool”: arcpyAvailable = core_functions.importArcpyIfAvailable() if not arcpyAvailable: ui.addFeaturesTW.setCurrentWidget(ui.csvTab) ui.addFeaturesTW.setTabEnabled(ui.addFeaturesTW.indexOf(ui.shapefileTab),False) ui.addFeaturesTW.setTabEnabled(ui.addFeaturesTW.indexOf(ui.layerTab),False) ui.statusbar.showMessage('arcpy not available. Adding to shapefiles and layers has been disabled.') else: import arcpy if core_functions.runningAsScriptTool(): runningAsScriptTool = True updateLayers() else: ui.addFeaturesTW.setTabEnabled(ui.addFeaturesTW.indexOf(ui.layerTab),False) ui.statusbar.showMessage(ui.statusbar.currentMessage() + 'Not running as a script tool. Adding to layer has been disabled.') What happens here is that we first use importArcpyIfAvailable() from the core_functions module to check whether we can import arcpy. If this is not the case, we make the “CSV” tab the current and only selectable tab from the Add Features tab widget by disabling the “Shapefile” and “Layer” tabs. In the else-part (so if arcpy is available), we further use the runningAsScriptTool() function to check if the program is being run as a script tool inside ArcGIS. If not, we just disable the “Layer” tab and make the “Shapefile” tab the currently selected one. In addition, some warning message in the statusbar is produced if either the “Layer” or both the “Layer” and “Shapefile” tabs had to be disabled. Time to get back to the GUI and implement the required event handler functions for the different GUI elements, in particular the different buttons. This will be quite a bit of code, so we will go through the event handler functions individually. Please add each function in the order they are listed below to the section labeled “# GUI event handler and related functions”: # query and direct input functions def runQuery(): \"\"\"run one of the different query services based on which tab is currently open\"\"\" queryString = ui.queryTermLE.text() activeTab = ui.queryServicesTW.currentWidget() queryHandler[activeTab](queryString) # call a function from the dictionary in queryHandler This is the event handler function for when the “Run query” button is clicked. We already mentioned the global variable queryHandler that maps tab widgets to functions. So we here first get the text the user entered into the queryTermLE widget, then get the currently selected tab from the queryServicesTW tab widget, and finally in the last line we call the corresponding function for querying Nominatim, GeoNames, or providing direct input. These functions still need to be defined. def setListViewFromResult(r): \"\"\"populate list view with checkable entries created from result list in r\"\"\" m = QStandardItemModel() for item in r: item = QStandardItem(item['name'] + ' ('+item['lat'] + ',' + item['lon'] + ')') item.setFlags(Qt.ItemIsUserCheckable | Qt.ItemIsEnabled) item.setData(QVariant(Qt.Checked), Qt.CheckStateRole) m.appendRow(item) ui.resultsLV.setModel(m) setListViewFromResult(…) is an auxiliary function for populating the resultsLV list view widget with the result from a query or a direct input. It will be called from the functions for querying the different web services or providing direct input that will be defined next. The given parameter needs to contain a list of dictionaries with name, lat, and lon properties that each represent one item from the result. The for-loop goes through these items and creates list items for the QStandardItemModel from them. Finally, the resulting model is used as the list model for the resultsLV widget. def runNominatimQuery(query): \"\"\"query nominatim and update list view and web map with results\"\"\" ui.statusbar.showMessage('Querying Nominatim... please wait!') country = ui.nominatimCountryCodeLE.text() if ui.nominatimCountryCodeCB.isChecked() else '' limit = ui.nominatimLimitLE.text() try: items = core_functions.queryNominatim(query, limit, country) # run query # create result list from JSON response and store in global variable result global result result = [(lambda x: {'name': x['display_name'],'lat': x['lat'], 'lon': x['lon']})(i) for i in items] # update list view and map with results setListViewFromResult(result) mapWV.setHtml(core_functions.webMapFromDictionaryList(result)) ui.statusbar.showMessage('Querying done, ' + str(len(result)) + ' results returned!') except Exception as e: QMessageBox.information(mainWindow, 'Operation failed', 'Querying Nominatim failed with '+ str(e.__class__) + ': ' + str(e), QMessageBox.Ok ) ui.statusbar.clearMessage() This is the function that will be called from function runQuery() defined above when the currently selected “Service” tab is the Nominatim tab. It gathers the required information from the line edit widgets on the Nominatim query tab, taking into account the status of the corresponding checkboxes for the optional elements (using the \"... if ... else ...\" ternary operator). Then it calls the queryNominatim(…) function from the core_functions module to perform the actual querying (line 9) and translates the returned JSON list into a result list of dictionaries with name, lat, and lon properties that will be stored in the global variable result. Note that we are using list comprehension here to realize this translation of one list into another. The resultLV list view and mapWV web map widget will then be updated accordingly. This happens inside a try-except block to catch exceptions when something goes wrong with querying the web service or interpreting the results. Statusbar messages are used to keep the user informed about the progress and a message box is shown if an exceptions occurs to inform the user. def runGeonamesQuery(query): \"\"\"query geonames and update list view and web map with results\"\"\" ui.statusbar.showMessage('Querying GeoNames... please wait!') username = ui.geonamesUsernameLE.text() country = ui.geonamesCountryCodeLE.text() if ui.geonamesCountryCodeCB.isChecked() else '' fclass = ui.geonamesFeatureClassLE.text() if ui.geonamesFeatureClassCB.isChecked() else '' limit = ui.geonamesLimitLE.text() try: items = core_functions.queryGeonames(query, limit, username, country, fclass ) # run query # create result list from JSON response and store in global variable result global result result = [(lambda x: {'name': x['toponymName'],'lat': x['lat'], 'lon': x['lng']})(i) for i in items] # update list view and map with results setListViewFromResult(result) mapWV.setHtml(core_functions.webMapFromDictionaryList(result)) ui.statusbar.showMessage('Querying done, ' + str(len(result)) + ' results returned!') except Exception as e: QMessageBox.information(mainWindow, 'Operation failed', 'Querying GeoNames failed with '+ str(e.__class__) + ': ' + str(e), QMessageBox.Ok) ui.statusbar.clearMessage() This function that will be called from runQuery() if the currently selected “Service” tab is the GeoNames tab works exactly like the previous function for Nominatim, just the query parameters extracted in lines 5 to 8 are different and the translation into a result list looks a little bit different because GeoNames uses other property names (\"toponymName\" instead of \"display_name\" and \"lng\" instead of \"lon\"). def runDirectInput(query): \"\"\"create single feature and update list view and web map with results\"\"\" name = ui.directInputNameLE.text() lon = ui.directInputLonLE.text() lat = ui.directInputLatLE.text() # create result list with single feature and store in global variable result global result result = [{ 'name': name, 'lat': lat, 'lon': lon }] # update list view and map with results setListViewFromResult(result) mapWV.setHtml(core_functions.webMapFromDictionaryList(result)) ui.statusbar.showMessage('Direct input has been added to results list!') This function will be called from runQuery() if the currently selected “Service” tab is the Direct Input tab. Again, we are collecting the relevant information from the input widgets (line 3 to 5) but here we directly produce the result consisting of just a single item (line 9). The rest works in the same way as in the previous two functions. These were the functions required for the query section of our tool. So we can now move on to the Results section where we just need the three event handler functions for the three buttons located below the list view widget. # list view selection functions def selectAll(): \"\"\"select all items of the list view widget\"\"\" for i in range(ui.resultsLV.model().rowCount()): ui.resultsLV.model().item(i).setCheckState(Qt.Checked) def clearSelection(): \"\"\"deselect all items of the list view widget\"\"\" for i in range(ui.resultsLV.model().rowCount()): ui.resultsLV.model().item(i).setCheckState(Qt.Unchecked) def invertSelection(): \"\"\"invert current selection of the list view widget\"\"\" for i in range(ui.resultsLV.model().rowCount()): currentValue = ui.resultsLV.model().item(i).checkState() ui.resultsLV.model().item(i).setCheckState(Qt.Checked if currentValue == Qt.Unchecked else Qt.Unchecked) These three functions all work very similarly: We go through all items in the list model underlying the resultsLV list view widget. In selectAll(), the check state of each item is set to “Checked”, while in clearSelection() it is set to “Unchecked” for each item. In invertSelection(), we take the item’s current state and either change it from “Checked” to “Unchecked” or vice versa (using the ternary \"... if ... else ...\" operator once more). # adding features functions def addFeatures(): \"\"\"run one of the different functions for adding features based on which tab is currently open\"\"\" activeTab = ui.addFeaturesTW.currentWidget() addFeaturesHandler[activeTab]() # call a function from the dictionary in addFeatureHandler We have now arrived at the last row of our main window graphical interface for adding the selected result features to a layer, shapefile, or csv file. The addFeatures() function corresponds to the runQuery() function from the beginning in that it invokes the right function depending on which tab of the addFeaturesTW tab widget is currently selected. This is based on the global variable addFeaturesHandler that map tabs to functions. def updateShapefileFieldCB(): \"\"\"update shapefileFieldCB combo box with field names based on shapefile name\"\"\" ui.shapefileFieldCB.clear() fileName = ui.shapefileAddLE.text() ui.shapefileFieldCB.addItems(core_functions.getValidFieldsForShapefile(fileName)) updateShapefileFieldCB() is an auxiliary function for updating the content of the shapefileFieldCB combo box whenever the name of the shapefile in the shapefileAddLE line edit widget changes so that the combo always displays the editable string fields of that shapefile. def selectShapefile(): \"\"\"open file dialog to select exising shapefile and if accepted, update GUI accordingly\"\"\" fileName, _ = QFileDialog.getOpenFileName(mainWindow,\"Select shapefile\", \"\",\"Shapefile (*.shp)\") if fileName: ui.shapefileAddLE.setText(fileName) updateShapefileFieldCB() When the shapefileOpenFileTB tool button is clicked, we want to display a file dialog for picking the shapefile. Opening the dialog and processing the result happens in the function selectShapefile(). When a file name is returned (meaning the dialog wasn’t cancelled by the user), the name is put into the shapefileAddLE line edit field and updateShapefieldCB() is called to update the combo box with the field names of that file. def addFeaturesToShapefile(): \"\"\"add selected features from list view to shapefile\"\"\" fieldName = ui.shapefileFieldCB.currentText() fileName = ui.shapefileAddLE.text() ui.statusbar.showMessage('Adding entities has started... please wait!') try: with arcpy.da.InsertCursor(fileName, (\"SHAPE@\",fieldName)) as cursor: for i in range(ui.resultsLV.model().rowCount()): # go through all items in list view if ui.resultsLV.model().item(i).checkState() == Qt.Checked: point = arcpy.Point( result[i]['lon'], result[i]['lat']) cursor.insertRow( (point, result[i]['name'][:30]) ) # name shortened to 30 chars ui.statusbar.showMessage('Adding entities has finished.') except Exception as e: QMessageBox.information(mainWindow, 'Operation failed', 'Writing to shapefile failed with '+ str(e.__class__) + ': ' + str(e), QMessageBox.Ok ) ui.statusbar.clearMessage() This function contains the code for writing the selected features from the results list in global variable result to the shapefile with the help of an arcpy insert cursor. We first read the relevant information from the shapefileAddLE and shapefileFieldCB widgets and then in the for-loop go through the items in the resultsLV list view to see whether they are checked or not. If an item is checked, an arcpy.Point object is created from the corresponding dictionary in variable result and then written to the shapefile together with the name of the location. Statusbar messages are used to inform on the progress or a message box will be shown if an exception occurs while trying to write to the shapefile. def updateLayerFieldCB(): \"\"\"update layerFieldCB combo box with field names based on selected layer\"\"\" ui.layerFieldCB.clear() layer = ui.layerPickLayerCB.currentText() try: ui.layerFieldCB.addItems(core_functions.getStringFieldsForDescribeObject(arcpy.Describe(arcValidLayers[layer]))) except Exception as e: QMessageBox.information(mainWindow, 'Operation failed', 'Obtaining field list failed with '+ str(e.__class__) + ': ' + str(e), QMessageBox.Ok ) ui.statusbar.clearMessage() This is the corresponding function to updateShapefileFieldCB() but for the layerFieldCB combo box widget part of the Layer tab. def updateLayers(): \"\"\"refresh layers in global variable arcValidLayers and layerPickLayerCB combo box\"\"\" layers = [] global arcValidLayers arcValidLayers = {} ui.layerPickLayerCB.clear() ui.layerFieldCB.clear() try: layers = core_functions.getPointLayersFromArcGIS() # get all point layers for l in layers: # add layers to arcValidLayers and GUI arcValidLayers[l.name] = l ui.layerPickLayerCB.addItem(l.name) updateLayerFieldCB() except Exception as e: QMessageBox.information(mainWindow, 'Operation failed', 'Obtaining layer list from ArcGIS failed with '+ str(e.__class__) + ': ' + str(e), QMessageBox.Ok ) ui.statusbar.clearMessage() ui.shapefileFieldCB.clear() This function is for populating the layerPickLayerCB and arcValidLayer global variable with the Point vector layers currently open in ArcGIS. It uses the getPointLayersFrom ArcGIS() function from core_functions.py to get the list of layers and then in the for-loop stores the layer objects under their layer name in the arcValidLayers dictionary and just the names as items in the combo box. If something goes wrong with getting the layers from ArcGIS, the corresponding exception will be caught and a message box will warn the user about the failure of the operation. def addFeaturesToLayer(): \"\"\"add selected features from list view to layer\"\"\" layer = ui.layerPickLayerCB.currentText(); fieldName = ui.layerFieldCB.currentText() ui.statusbar.showMessage('Adding entities has started... please wait!') try: with arcpy.da.InsertCursor(arcValidLayers[layer], (\"SHAPE@\",fieldName)) as cursor: for i in range(ui.resultsLV.model().rowCount()): # go through all items in list view if ui.resultsLV.model().item(i).checkState() == Qt.Checked: point = arcpy.Point( float(result[i]['lon']), float(result[i]['lat'])) cursor.insertRow( (point, result[i]['name'][:30]) ) # name shortened to 30 chars ui.statusbar.showMessage('Adding entities has finished.') except Exception as e: QMessageBox.information(mainWindow, 'Operation failed', 'Writing to layer failed with '+ str(e.__class__) + ': ' + str(e), QMessageBox.Ok ) ui.statusbar.clearMessage() This is the analogous function to the previously defined function addFeaturesToShapefile() but for a currently open layer and based on the information in the widgets of the Layer tab. def selectCSV(): \"\"\"open file dialog to select exising csv/text file and if accepted, update GUI accordingly\"\"\" fileName, _ = QFileDialog.getOpenFileName(mainWindow,\"Select CSV file\", \"\",\"(*.*)\") if fileName: ui.csvAddToFileLE.setText(fileName) Similarly to selectShapefile(), this function opens a file dialog to select a csv file to append the features to. def addFeaturesToCSV(): \"\"\"add selected features from list view to csv/text file\"\"\" fileName = ui.csvAddToFileLE.text() ui.statusbar.showMessage('Adding entities has started... please wait!') try: with open(fileName, 'a', newline='') as csvfile: csvWriter = csv.writer(csvfile) for i in range(ui.resultsLV.model().rowCount()): # go through all items in list view if ui.resultsLV.model().item(i).checkState() == Qt.Checked: csvWriter.writerow( [ result[i]['name'], result[i]['lon'], result[i]['lat'] ]) ui.statusbar.showMessage('Adding entities has finished.') except Exception as e: QMessageBox.information(mainWindow, 'Operation failed', 'Writing to csv file failed with '+ str(e.__class__) + ': ' + str(e), QMessageBox.Ok ) ui.statusbar.clearMessage() Working similarly to addFeaturesToShapefile() and addFeaturesToLayer(), this function writes the selected features as rows to a text file using the csv.writer class from the csv module of the Python standard library. def selectNewShapefile(): \"\"\"open file dialog to creaete new shapefile and if accepted, update GUI accordingly\"\"\" fileName, _ = QFileDialog.getSaveFileName(mainWindow,\"Save new shapefile as\", \"\",\"Shapefile (*.shp)\") if fileName: createShapefileDialog_ui.newShapefileLE.setText(fileName) The final two functions are for creating a new shapefile. selectNewShapefile() is called when the newShapefileBrowseTB button that is part of the dialog box for creating a new shapefile is clicked and displays a file dialog for saving a file under a new name. The chosen name is used to set the text of the newShapefileBrowseTB line edit widget. def createNewShapefile(): \"\"\"create new shapefile and adds field based on info in dialog GUI\"\"\" if createShapefileDialog.exec_() == QDialog.Accepted: file = createShapefileDialog_ui.newShapefileLE.text() field = createShapefileDialog_ui.fieldForNameLE.text() try: core_functions.createPointWGS1984Shapefile(file,field) ui.shapefileAddLE.setText(file) updateShapefileFieldCB() ui.shapefileFieldCB.setCurrentIndex(ui.shapefileFieldCB.findText(field)) ui.statusbar.showMessage('New shapefile has been created.') except Exception as e: QMessageBox.information(mainWindow, 'Operation failed', 'Creating new shapefile failed with '+ str(e.__class__) + ': ' + str(e), QMessageBox.Ok ) ui.statusbar.clearMessage() ui.shapefileFieldCB.clear() This function is called when the “Create new shapefile” button on the Shapefile tab is clicked. It first displays the createShapefileDialog dialog box modally by calling its exec_() method. If the dialog is accepted (= closed by clicking Ok), the function creates the new shapefile with the help of the createPointWGS1984Shapefile() function from core_functions.py and based on the input fields in the dialog box for creating a new shapefile (newShapefileLE and fieldForNameLE). If no exception is raised, the file name and field name from the dialog box will be used to change the text of the shapefileAddLE line edit widget and the shapefileFieldCB combo box. At this point, we are almost done. The last thing that has to happen is connecting the widgets’ relevant signals to the corresponding slots or event handler functions. For this, please add the following code under the comment “# connect signals”: Lines 1 to 9 and line 13 all connect “clicked” signals of different buttons in our GUI to the different event handler functions defined previously and should be easy to understand. In line 10, the “editingFinished” signal of the text field for entering the name of a shapefile is connected with the updateShapefileFieldCB() function so that, whenever the name of the shapefile is changed, the list of the fields in the combo box is updated accordingly. In line 11, we connect the “activated” signal of the combo box for selecting a layer with the upateLayerFields() function. As a result, the second combo box with the field names will be updated whenever the layer selected in the first combo box on the Layer tab is changed. That’s it. The program is finished and can be tested and used either as a standalone application (writing features either to a shapefile or to a .csv file) or as an ArcGIS script tool. Give it a try yourself and think about which parts of the code are being executed when performing different operations. In case you want to run it as a script tool inside ArcGIS Pro, setting up the script tool for it should be straightforward. You just have to create a new script tool without specifying any parameters and provide the path to the main.py script for the source. If you have any problems running the code with your own script, the entire code can be downloaded via this link to the Locations from Web Services Complete zip file. If something in the code above is unclear to you, please ask about it on the course forums. Obviously, the tool is still somewhat basic and could be extended in many ways including:\n• providing more query options for the currently implemented query services\n• allowing for multiple query terms as input (e.g. list of place names or addresses); it could also be useful to be able to paste some longer text into the tool and then highlight place names in the text that should be queried\n• supporting other geometries, not just points\n• … (add your own ideas to the list) Moreover, while we included some basic error handling with try-except, the program is not completely bullet proof and in some cases it would be desirable to provide more direct and specific feedback to the user, for instance if the user enters something into the feature class field of the GeoNames query tab that is not a valid feature class code. We are also quietly assuming that the shapefile or layer we are adding to is using a WGS1984 geographical coordinate system. Adding reprojection of the input features to the CRS of the destination would certainly be a good thing to do. Still, the tool can be useful for creating point feature classes of locations of interest very quickly and in a rather convenient way. More importantly, this walkthrough should have provided you with a better understanding of how to create Python programs with a GUI by roughly separating the code into a part for setting up the GUI elements, a part for realizing the actual functionality (in this case the part defining the different event handler functions (GUI dependent) with the help of the core functions from core_functions.py (GUI independent)), and a part that makes the connection between the other two parts based on GUI events. You will practice creating GUIs and PyQt5 based Python programs yourself in this lesson’s homework assignment and also again in lesson 4. But for now, we will continue with looking at another aspect of creating and publishing Python applications, namely that of package management and packaging Python programs so that they can easily be shared with others.\n\nYou have already used a number of packages in Python, primarily the arcpy package, but you are likely to have encountered others, such as sys, csv, which are a part of the Python standard library, or perhaps numpy and matplotlib, which are auxiliary libraries. In the previous section of this lesson, you learned about the tkinter and PyQT libraries as we built a Python graphical User Interface (GUI). In order to use these packages you had to use the import statement to make the additional methods they provide available to your code, for example: You also created modules of your own that you imported into other scripts. You simply constructed a .py file and used the import statement in order to use it, and that is all Python requires for a module to be created. Creating such a module is straightforward - all your code was contained in a single .py file, you placed the file in the same folder as the program that would use it, and you imported into that program and used its functions. You may be wondering how a module is different from a package, since they are imported the same way. The difference is that a package is a collection of modules set up for easier distribution. While some projects may consist of one simple module, you will find that if you are building a project of any complexity, more than one .py file will be required, and potentially other files as well, such as configuration files or images. In the next section, we will look at what exactly can be imported into Python. Later in the lesson, we will demonstrate the pip and conda package and environment managers as well as the Anaconda Python distribution based on conda. The section contains several optional subsections in which we package the Locations From Web Services application from the walkthrough and upload it to distribution sites. As in Lesson 1, we recommend that you only perform what is described in these optional sections yourself if you have time left at the end of the lesson. As was mentioned earlier, when you use the import statement you can import a single .py file. In addition, the import statement can point to a folder containing a set of .py files, or a library written in a different programming language, such as C++. You may be wondering how Python finds the module or package you specified since you only specify the name. Your own modules may have been in the current directory with the program using it, but arcpy, for example, isn’t. What happens is that Python has a list of locations that it uses in order to find the necessary packages. It traverses the list in the specific order, and, once it finds all the packages it needs, it stops looking. Here is the search order1 that Python uses:\n• The home directory where the currently executing .py file is located\n• PYTHONPATH directories: PYTHONPATH is a variable that is optionally set in the operating system. For example, on a Windows machine you would set it in Environmental Variables in System Settings.\n• Standard library directories: The location where all standard libraries are installed on the local machine – if you have ArcGIS 10.6 Desktop installed to a default location the standard libraries can be found at C:\\Python27\\ArcGIS10.6\\Lib. Browse to the folder, and take a quick look of all the packages that are installed.\n• The contents of any .pth files: These are text files that can be created to add additional library paths; this option is used by ArcGIS Desktop 10.6. In a standard installation you can find the .pth file at C:\\Python27\\ArcGIS10.6\\Lib\\site-packages\\Desktop10.6.pth. ArcGIS pro has its own .pth file: C:\\Users\\<username>\\AppData\\Local\\ESRI\\conda\\envs\\arcgispro-py3-clone\\Lib\\site-packages\\ArcGISPro.pth or C:\\Program Files\\ArcGIS\\Pro\\bin\\Python\\envs\\arcgispro-py3\\Lib\\site-packages\\ArcGISPro.pth depending on your version of Pro.\n• The site-package home or third-party extensions: Packages placed in Libs\\site-packages directory. In a standard install of ArcGIS 10.6 Desktop that would be in the C:\\Python27\\ArcGIS10.6\\Lib\\site-packages folder. Because of the way Python finds the code it needs to import, you need to be careful how you name your modules and packages, and where you place them. For example, if you were to create an arcpy.py module and put it in the home directory, the ArcGIS arcpy package would not be loaded. This list above may look intimidating, but the good news is that packages you are likely to need will be packaged with special Python utilities (either pip or conda) and thus setup to place themselves in the appropriate paths without any manual intervention on your part, beyond the installation step. The other good news is that both pip and conda are fairly straightforward to use when it comes to installing packages and managing Python environments. Creating your own pip or conda packages can be a bit more involved though as you will also see in this section but still provides a convenient way for deploying and sharing your own Python applications. There are many Python packages available for use, and there are a couple of different ways to effectively manage (install, uninstall, update) packages. The two package managers that are commonly used are pip and conda. In the following sections, we will discuss each of them in more detail. At the end of the section, we will discuss the merits of the two tools and make recommendations for their use. We will be doing some more complicated technical \"stuff\" here so the steps might not work as planned because everyone’s PC is configured a little differently. If you get stuck please check in with the instructor sooner rather than later. A quick troubleshooting / debugging process can involve testing to see if running the command or Command Prompt as Administrator resolves the issue, trying the Windows Command prompt instead of the Python Command prompt (or vice versa), and, if none of that has helped, trying the tech support staple of restarting your PC. As already mentioned, pip is a Python package manager. It allows for an easier install, uninstall and update of packages. Pip comes installed with Python, and if you have multiple versions of Python you will have a different version of pip for each. To make sure we are using the version of pip that comes installed with ArcGIS Pro, we will go to the directory where pip is installed. Go to the Windows Start Menu and open the Python Command Prompt as before. In the command window that now opens, you will again be located in the default Python environment folder of your ArcGIS Pro installation. For newer versions of Pro this will be C:\\Users\\<username>\\AppData\\Local\\ESRI\\conda\\envs\\arcgispro-py3-clone\\. Pip is installed in the Scripts subfolder of that location, so type in: Now you can run a command to check that pip is in the directory – type in: The resulting output will show you all occurrences of files that start with pip. in the current folder, in this case, there is only one file found – pip.exe. Next, let’s run our first pip command, type in: The output shows you the current version of pip. Pip allows you to see what packages have been installed. To look at the list type in: The output will show (Figure 31) the list of packages and their respective versions. To install a package, you run the pip command with the install option and provide the name of the package, for example, try: Pip will run for a few seconds and show you a progress bar as it is searching for the numpy package online and installing it. When you run pip install, the packages are loaded from an online repository named PyPI, short for Python Package Index. You can browse available packages at Python's Package Index page. If the installation has been successful you will see a message stating the same, which you can confirm by running pip list again. In order to find out if any packages are outdated you can run the pip list with the outdated option: If you find that there are packages you want to update, you run the install with the upgrade option, for example: This last command will either install a newer version of numpy or inform you that you already have the latest version installed. If you wanted to uninstall a package you would run pip with the uninstall option, for example: You will be asked to confirm that you want the package uninstalled, and, if you do (better not to do this or you will have to install the package again!), the package will be removed. The packages installed with pip are placed in the Lib\\site-packages folder of the Python environment you are using. You will recall that that was one of the search locations Python uses in order to find the packages you import. Important note: While knowing how to create packages from your Python code to disseminate it is an important skill for a Python programmer, the procedure described in this section is a bit complex and error-prone due to system and installation differences. It is also not required to have performed these steps successfully yourself to finish the lesson and the rest of the course. Therefore, this section is provided for interest only. We recommend that you just read through it or skip over it completely and you can then loop back to it at the end of the lesson if you have free time or after the end of the class. If you decide to go through the steps yourself and find yourself stuck with some errors, please feel free to ask about them on the course forums but don't let such issues keep you from reading through the rest of the section and finishing the lesson. Now that we covered the basic operation of pip, we will create a pip package for the Locations From Web Services you developed in this lesson. Creating the pip package will involve the following steps:\n• Creating an account on PyPI (you need to set up an account only once)\n• Publishing the package and the source to PyPI We will walk through all these steps and create the necessary files and folders. For reference, as you are reading on, your final package folder and file structure should look like this for pip: Let’s start by creating a separate folder and copying the existing code files into it. Create a pip directory in a location of your choice. Then create a folder named <yourinitialsdate>locationsfromwebservices within it. Replace the <yourinitialsdate> part of the folder name with the combination of your initials and current date and leave out the <>. From now on in the lesson wherever you see that string, replace it with your own combination. Pip packages have to have unique names, otherwise you will not be able to upload them to the repository. Within that folder create another <yourinitialsdate>locationsfromwebservices folder. Copy all the code files you created (or downloaded) for the GUI walkthrough for the Locations from Web Services example in the previous section into this latest (inner) <yourinitialsdate>locationsfromwebservices folder. Once the folder is set up use your Python editor or other text editor of choice to create the __init__.py file and place it in the same directory. The file is used by Python to indicate folders that are Python packages. We will leave the file blank – only its presence in the folder is required. The file need not be blank, however. It is a special file that gets executed once the package is imported into another package. It is written in standard Python, so it can contain regular code, and is often used to import other packages, so other modules in the package can import it from the package instead. Let’s proceed to the second step – creating the setup.py file. The file needs to be located in the folder above the code, in the top level <yourinitialsdate>locationsfromwebservices folder. If that is confusing refer back to the folder tree diagram above. Type in the following content into the file: Now we are ready to install the package. Please make sure that there are no other Python processes running; this includes quitting ArcGIS and/or spyder if they are currently running. In the Python Command Prompt window navigate to the location of your project, specifically the folder containing the setup.py file. Once there, type in and run this command (note the '.' at the end of the command which is important): You will receive some status update messages ending with the notification that the package has been successfully installed. You may get a notification you are using an outdated version of pip. Please do not update pip or any other package, as then your set up would be out of sync with the class material. In order to upload the source to PyPI, the Python Package Index, we need to create a source distribution. To do so type in and run this command: The sdist option creates a new folder in your project named dist and packages all the necessary files for upload into a tar.gz file, which is a compressed file type. Now that we have everything ready for upload, go to the Python Package Index page and click on Register (top right corner), and proceed to create an account. You will need to log into your e-mail account and click the link to verify the account before you can make any uploads. Once you have an account enter the following in the Command Prompt window: You will be asked for your user credentials (or at least your password). Please enter them and the upload will start. It is very likely you will get an error \"error: Upload failed (403): Invalid or non-existent authentication information\" that means your username wasn't specified. The solution to this issue is twofold: First you need to create a file called .pypirc in your home directory (that is c:\\Users\\<your user name>). You can download this sample configuration file, place it in your home directory, and then edit it to put in your user credentials. Second, you need to install another package called twine: will use twine to upload the zipped package in the dist folder to your repository (assuming you modified your username and password in the .pypirc file). Once complete go back to your PyPI account and check the list of your projects to confirm the upload was successful. Please delete the project, as projects need to have unique names and another student attempting this process will get an error if your project remains in PyPI (although our attempt at generating a unique name with the date and our initials should minimize that chance). You need to click on Manage, then Settings and then Delete next to the project name (and type in the project name to confirm). The package we created is a barebones package, it has absolute minimum elements to be uploaded. Two other elements you should definitely consider adding to your packages are a README and a LICENSE file. The README file would contain some information about the project – who created it, what it does, and any other notes you would like to leave for the users. The LICENSE file should spell out the license agreement for using your package. We will leave the pip package as is but will be adding a LICENSE file to our conda package. Another option for packaging and distributing your Python programs is to use conda (we will discuss Anaconda a bit later in the lesson). Just like pip, it is a package manager. In addition, it is also an environment manager. What that means is that you can use conda to create virtual environments for Python, while specifying the packages you want to have available in that environment. A little more about that in a moment. Conda comes installed with ArcGIS Pro. While conda should be installed if you were able to install spyder in Lesson 1, we can doublecheck that it is by opening the Python Command Prompt and then typing in: The output should show the conda version. In order to find out what packages are installed type in: Your output should look something like Figure 2.34: The first column shows the package name, the second the version of the package. The third column provides clues on how the package was installed. You will see that for some of the packages installed, Esri is listed, showing they are related to the Esri installation. The list option of conda is useful, not only to find out if the package you need is already installed but also to confirm that you have the appropriate version. Conda has the functionality to create different environments. Think of an environment as a sandbox – you can set up the environment with a specific Python version and different packages. That allows you to work in environments with different packages and Python versions without affecting other applications. The default environment used by conda is called base environment. We do not need to create a new environment, but, should you need to, the process is simple – here is an example: the –n flag is followed by the name of the environment (in this case gisenv), then you would choose the Python version which matches the one you already have installed (3.10, 3.11 etc.) and follow that up with a list of packages you want to add to it. If you later find out you need other packages to be added, you could use the install option of conda, for example: To activate an environment, you would run: And to deactivate an environment, simply: There are other options you can use with environments – you can clone them and delete them, for example. A great resource for the different options is Conda's Managing Environments page. Important note: While knowing how to create packages from your Python code to disseminate it is an important skill for a Python programmer, the procedure described in this section and section 2.8.3.2 is a bit complex and error-prone due to system and installation differences. It is also not required to have performed these steps successfully yourself to finish the lesson and the rest of the course. Therefore, this section is provided for interest only. We recommend that you just read through it or skip over it completely and you can then loop back to it at the end of the lesson if you have free time or after the end of the class. If you decide to go through the steps yourself and find yourself stuck with some errors, please feel free to ask about them on the course forums but don't let such issues keep you from reading through the rest of the section and finishing the lesson. Before we can create a conda package of our own we do need to install the conda-build package. We will use conda to install the conda Build package, just as you did with the PyQT5 package. Use the Python Command Prompt and type in: What we are doing is running conda with the install option, and asking it to install the conda-build package. A search and analysis will be performed by conda to find the package, determine its dependencies and you will be informed of all the packages that will be installed. Type in y to allow the install to proceed, and you will get progress messages for the installation of conda-build and all packages it is dependent on. You could install other packages as well in a similar fashion (just as with pip), by changing the name conda-build to the appropriate package name. In order to know if a package you are looking for is available to be installed from conda, you can run conda with a search option, for example: The output will show if the package is available, and if so from which channels. Channels are different repositories that have been set up by users and organizations. Important note: As the previous section, this section is provided for interest only. We recommend that you just read through it or skip over it completely and you can then loop back to it at the end of the lesson if you have free time or after the end of the class. If you decide to go through the steps yourself and find yourself stuck with some errors, please feel free to ask about them on the course forums but don't let such issues keep you from reading through the rest of the section and finishing the lesson. Now that we know conda is installed and working, we will proceed to building your first conda package. Before we begin create a copy of your pip folder and rename it to conda. Delete the \"dist\" and \"locationsfromwebservices.egg-info\" folders. Creating a conda package will involve the following steps:\n• Creating a setup.py file (we already created it while building the pip package) We will walk through all these steps and create the necessary files and folders, just as we did for pip. For reference, as you are reading on, your final package folder and file structure should look like this for conda: The next step is to create a file named meta.yaml in the original (outer) <yourinitialsdate>locationsfromwebservices folder. You can create the file in any text editor. Make sure the name and extension match exactly. Type in the following into the file. Some of the elements will be left empty, but it is a good idea to use this template, to make sure all the elements you need are there: The package section of the file simply contains the package name and the version. The name can only contain lowercase letters and dashes. The source sections point to the source of the data. In this case, we are pointing to the source on the local drive, but the source could be git or a compressed (.zip or .tar file), along with a few other options. The requirements specify what tools are necessary to build the package, and the run section specifies what packages are necessary for running the package. Since we made the arcpy an optional part of the project we will not include it under the requirements. Setuptools is a package that helps with building Python projects. Please note that in conda the pyqt5 package is just called pyqt. The about section provides more information about the package, such as the website it may be found on and license specification. We set the license to BSD, which is a very permissive license type. Other licenses you may want to consider are GPL (General Public License) and LGPL (Lesser General Public License). A summary of these open source license types and a few others can be found at: choosealicense.com. It is a good idea to include a license with your package distribution. The name of the license file is specified in the about – license_file section, and it is typically named just license. You can download a sample license file here to be included with your distribution, or you can use the Binpress license generator and specify your own terms. Place the LICENSE file in the outer <yourinitialsdate>locationsfromwebservices folder where the meta.yaml file is located. The version of the meta.yaml file we created is rather simple. There are other options you can set if necessary. Find the complete guide here. Now we also need to create two build script files – build.sh and bld.bat. The .bat file works in the Windows environment, but, if the project is built on a Linux or a macOS environment (unlikely for arcpy type projects), we need the build.sh file as well. Type in the following content into the bld.bat file: Here is the content for the build.sh file: As you may have gathered from the batch files we created, the setup.py file is required by conda. Since we created it in setting up the pip package we do not need to recreate it here – just copy it from its location in your pip folder to the <yourinitialsdate>locationsfromwebservices folder within your conda folder. Copy the LICENSE file into the <yourinitialsdate>locationsfromwebservices folder as well. Now that we have the package set up, we will use the Python Command Prompt to build the package. Make sure you are in the folder that contains the outer <yourinitialsdate>locationsfromwebservices and run the following command: After a long process and verbose output, towards the end you should see a line that gives you the command to upload your package to anaconda. More on this later. For now, just look at this output and note where the compressed tar.bz2 archive with your package has been created: # If you want to upload package(s) to anaconda.org later, type: anaconda upload c:\\Users\\<user name>\\AppData\\Local\\ESRI\\conda\\envs\\arcgispro-py3-clone\\conda-bld\\win-64\\<yourinitialsdate>locationsfromwebservicescomplete-1.0-py35hc17e43c_0.tar.bz2 If you were watching the conda-build output very closely you might have seen a couple of errors displaying \"The system cannot find the path specified\" for some Visual Studio tools – that is okay and you do not need to be concerned by those. That brings us to the next section of the lesson where we discuss Anaconda. Leave the Python Command Prompt window open, as we will be using it shortly to upload the package to the Anaconda Cloud. Anaconda is a Python distribution that includes the most popular data science package and conda in its distribution. Anaconda makes it easy to create a Python setup conducive to data analytics that also facilitates package management (updates, installs), packaging projects, managing environments and sharing packages. It is build on top of conda but provides a graphical interface for managing Python environments and packages. Figure 40 obtained from the Anaconda website shows the Anaconda components. If you investigate further you will learn that the conda portion of Anaconda contains a repository of packages maintained by Anaconda (Anaconda Repository), but also the Anaconda Cloud, which users and organizations can contribute to. If we were to upload the package created in the previous optional section with the command conda presented to us, it would be uploaded to the Anaconda Cloud. We will use Anaconda in Lesson 3 to work in a fresh Python environment outside the ArcGIS Pro installation. You should therefore perform the steps in this section to install Anaconda on your computer. Setting up a user account for Anaconda Cloud will be described in the following optional section. You won't need this unless you want try uploading the conda package from the previous optional section to the cloud yourself. To download and install Anaconda you would normally go to anaconda.com, pick the Individual Edition option (or one of the other options if you prefer), and then click Download to get to the page where you can download the Anaconda installers (Figure 41; Anaconda frequently updates their website design, but you get the idea). However, we are here providing a direct link to download the Windows 64-bit installer to make sure we all are using the same version, one that we have tested the Lesson 3 content with: https://repo.anaconda.com/archive/Anaconda3-2024.06-1-Windows-x86_64.exe . Once downloaded, double-click on the .exe file to run the installer. Use all the default install options. If asked, you can choose to skip installing Microsoft Visual Studio Code. After the installation, Anaconda will be located in a folder called Anaconda3 of your user's home directory, so C:\\Users\\<user name>\\Anaconda3. This is the root environment (also called base environment) installed by Anaconda. If you create further environments or clone existing environments, these will be located in the envs subfolder of the Anaconda3 directory. The easiest way to interact with Anaconda is via the Anaconda Navigator program that provides a graphical user interface for managing the installation, starting programs, etc. Just type the first letters into the Windows search and you should be able to find the program and run it (if not, it is located in the Scripts subfolder of the Anaconda3 directory). Here is a quick overview of the Navigator interface: As shown in the image below, the Navigator has a vertical main menu on the left side of the window. We are only interested in the Home and Environments entries at the moment. The Home screen simply shows you a number of applications that are either installed and can be launched in your currently active Python environment or that you may want to install. You can switch to a different environment using the dropdown menu box at the top. In the image below, the currently active environment is the root environment installed by Anaconda. If you now switch to the Environments screen, you will see that it has two main sections: the one on the left is for managing Python environments and the one on the right is for managing packages in the currently active environment. Anaconda will also see potential environments located under C:\\Users\\<user name>\\AppData\\Local\\ESRI\\conda\\envs, so, if that's the location where your ArcGIS Pro installation has stored its default Python environment, it should appear in the environments list as well. Clicking on a environment in the list will activate that environment and update the package manager view on the right accordingly. The buttons below the environment list can be used to easily create, clone or delete environments. The graphical package manager on the right is also relatively intuitive to use. At the top, you can (among other options) select whether it should list the current, not installed, or all available packages. Selecting an uninstalled package by clicking the box on the very left of the entry will allow you to install that package. Packages for which newer versions are available are shown with a blue arrow next to the version number on the right. Clicking that arrow will allow you to update the package. Both the graphical environment manager and package manager are visual front-ends to conda. So whenever you perform some activity, like installing a package, the corresponding conda command will be executed in the background. This was really just a very brief introduction to the main elements of the Anaconda Navigator and Anaconda in general. However, you will get the chance to further use it and learn more details in Lesson 3. Important note: This section uses the conda package created in optional section 2.8.3.2. While knowing how to create packages from your Python code to disseminate it is an important skill for a Python programmer, it is not required to have performed the steps required in this section successfully yourself to finish the lesson and the rest of the course. Therefore, this section is provided for interest only. We recommend that you just read through it or skip over it completely and you can then loop back to it at the end of the lesson if you have free time or after the end of the class. If you decide to go through the steps yourself and find yourself stuck with some errors, please feel free to ask about them on the course forums but don't let such issues keep you from reading through the rest of the section and finishing the lesson. After the installation, the next step to publishing our conda package from Section 2.8.3.2 is creating a user account. In order to obtain one, you need to go to anaconda.org and use the dialog on the right side of the screen to create an account. Finally, we are ready to upload our package to Anaconda. In the Command Prompt window, run the following command to log into the Anaconda Cloud (note that the path might be one of the following two options depending on where Anaconda is installed): You will be asked to provide your user credentials and will be greeted with a message that confirms that your login was successful. The next step is to upload your package – run the following command (remembering to use the path to where Anaconda was installed), but replace the tar.bz2 file with the file name conda provided you at the completion of the package build. If you are using an older version of Pro, you will also have to replace the first part of the path to the .tar.bz2 file with \"c:\\Program Files\\ArcGIS\\Pro\\bin\\Python\\envs\\arcgispro-py3\\conda-bld\\win-64\\\". You will receive messages that keep you updated on the upload status, and then you will be notified that the upload is complete. Log into the Anaconda Cloud and look at your Dashboard (Figure 43) – the package is now listed, and located in your own Anaconda Cloud Channel. If you click on the package name you will receive information on how it can be installed with conda. If you worked or read through the exercises we worked through for packaging our application in the optional parts of this section, you might have gotten the impression that pip is easier to use than conda, and, since they both facilitate software packaging and distribution, why bother packaging your applications with conda? Here are a number of reasons:\n• Conda further aids in package installs as it not only checks for dependencies but installs any dependent packages\n• Conda is closely bound with Anaconda and Anaconda Cloud, which is set up to use different channels, providing a finer-grained package organization. For example, if you are interested in packages ESRI has published, you can go to the company’s channel - https://anaconda.org/esri.\n• While pip can only be used with Python, conda can be used with other languages as well – so if you decided to develop something with R, conda can work with it too. If you are interested in a more detailed comparison of the two tools, a great article to reference is Conda Myths and Misconceptions."
    },
    {
        "link": "https://yashvaantlakham73.medium.com/python-graphical-user-interface-introduction-to-pyqt5-and-qt-designer-tool-edf5499884ff",
        "document": "In our previously launched sections building modern GUIs with tkinter and Python, we learned\n\nhow to create GUI forms using the Tk interface library. Now, we will be looking at another\n\n\n\napproach to create the same GUI forms using one of the most popular cross-platform\n\nlibraries, known as PyQt5 library which was developed by Riverbank Computing. A robust\n\nand cross platform graphical toolkit called Qt has a Python binding called PyQt5. Python is\n\na well known and simple-to-learn programming language, and with PyQt5 developers, we\n\ncan simply construct GUI applications using Python. With PyQt5, a visual layout tool called\n\nQt Designer is included. Without having to write any code explicitly, it enables developers\n\nto construct GUI layouts quickly and easily by dragging and dropping widgets onto a\n\ncanvas. Additionally, Qt Designer offers a selection of editable widgets that may be used to\n\ndesign distinctive user interfaces with eye catching visuals.\n\nThere are numerous Qt classes in a set of Python modules which are compatible with\n\nmany operating systems such as iOS, Windows, Linux, Unix, Android and so on, which is a\n\npart of the top-level Python package, that is PyQt5 library. Qt5 in PyQt5 stands for Qt\n\n\n\nversion 5. This library provides us the advantage of Python binding with the Qt C++\n\ntoolkit. An important point to note is that under the GNU General Public License (GNU or GPL) v3 license, the PyQt5 license is being released. One may wonder that if we\n\nhave already learned about tkinter then why we should learn about PyQt5 as well. To\n\nbetter understand this, let us check the advantages of PyQt5 over other libraries\n\nsuch as tkinter.\n• Flexibility in coding: In order to establish simple communication between objects there is a concept of signals and slots which gives us flexibility for GUI programming\n\nusing PyQt5, when dealing with events.\n• More than GUI toolkit: Using PyQt5 we can build entire applications using its\n\ngraphics, printer support, networking, database access and so on. It is like an\n\napplication framework.\n• Numerous UI components: PyQt5 offers numerous widgets such as QLabel, QButton,\n\n\n\nQCombobox and so on such that each widget has some basic image well suited in all the\n\n\n\nplatforms. Numerous advanced widgets are also available on the topic in this library.\n• Numerous study resources: If there is no documentation then you might wonder\n\nwhat the point of learning is. PyQt5 comes with a rich array of documentation since it\n\nis one of the most commonly used Python packages for GUI creation.\n• Easy to understand: We can easily use previous knowledge of either Python, Qt or\n\nC++, thus making PyQt5 easy to understand.\n• Preferred choice of GUI developers: Due to simplicity and ease of use, many GUI\n\n\n\ndevelopers opt for functionalities that come with PyQt5 to develop their own\n\n\n\napplications.\n• GUI widget appearance: The appearance of PyQt5 is nice and pleasing to the eyes.\n\nNow, we may wonder which library to choose to create GUI forms using PyQt5 or tkinter.\n\n\n\nThis generally depends on user application and the willingness to learn and explore. Table\n\n\n\n1.1 further shows the differences between the libraries.\n\nYou can decide which library to choose to create GUI forms, depending on your application.\n\n\n\nWe will later discuss how to create a UI form using Qt Designer in detail as well as the\n\nwidgets associated with it and the Python code with logic written by importing the auto-code generated by creating the UI form in detail.\n• The Python version we will be using for discussing PyQt5 will be 3.7.3. You can try working\n\n\n\nwith new version as on today that is 3.11.5 dated Aug 24, 2023 from the location where\n\nwe have installed our Python first type the command python --version to check the version\n\ninstalled and then type the command below to install pyqt5.\n\n2. Once installed, we can verify the installation of PyQt5 under the Python site packages folder that you see in the screenshot below.\n\n3. We can check some of the modules present in PyQt5. If we do not get any error then we\n\ncan again cross verify that PyQt5 is successfully installed.\n\nNow, we shall see a basic UI form creation using PyQt5 without using class. This is quite\n\n\n\nimportant. As you might have realized most of the UI forms which we will be creating will\n\n\n\nbe using the concept of class and object. It is highly recommended that you go through the\n\n\n\nconcept of class before moving further in this section. It is well explained in our previous\n\n\n\nsections, programming techniques using Python and Python for Everyone. Here, we will only\n\n\n\nfocus on our basic UI form creation. So, without any further delay, let us start. Refer to the\n\n\n\nfollowing code which can be checked in some IDE’s like VSCode, Spyder, Anaconda and so\n\n\n\non.\n\nYou will be surprised that by writing few lines of code, we can create our GUI form and that\n\n\n\ntoo, as fully functional. Now let us see the explanation of this code line by line.\n• In L1, we are first importing the sys module for accessing the command line arguments.\n• In L2, we are importing from class, which creates desktop style UIs of PyQt5 package, that\n\n\n\nis, Qt Widgets. QWidget is used for creating an empty GUI and QApplication is nothing but an\n\n\n\napplication handler. We can see that from the above statement, we are importing the\n\n\n\nmodules for creating the GUI form.\n• In L3, we are creating an instance, that is, object of QApplication class using the variable\n\nname myapp and passing command line parameters list sys.argv to the application. When we\n\nare sure that we will be passing command line parameters to control Qt form through shell\n\n\n\nlaunching or during the course of interface automating, we can pass this as an argument to\n\n\n\nQApplication class or else we can pass as an empty list as.\n• In L4, we are creating an object of QWidget class using the variable name mywindow. This QWidget\n\nclass is the parent class of all the User Interface objects in Qt. The top level window is\n\ncreated by not passing any parameter to the QWidget class.\n• In L5, in order to make the widgets visible after creating the object of QWidget class, we must\n\ncall show() method with the object. Now, you may wonder what will happen if we do not call\n\nthis show method. Since after running the application, there is no way to close or quit it,\n\nshow() will be called to simply display widgets.\n• In L6, for implementing parallel execution, PyQt5 uses an event loop mechanism as it is\n\nlargely written in C++, So, to start up the event loop mechanism, we are calling\n\n\n\nmyapp.exec_() method which will be held by the application object. Some will even think that\n\nat some places, we have seen myapp.exec. This exec was a reserved word in Python 2. So, to\n\navoid the naming conflict with this reserved word we are using exec_() in PyQt5. Therefore when there will be a requirement by the user to close the GUI, this myapp.exec_() will allow\n\n\n\nthe control to pass over to Qt to terminate the application. Just try using Ctrl + C to\n\n\n\nterminate the application as done in our Python programs. You will find out that the\n\n\n\napplication will not be terminated. Now, if we want our code to return gracefully and not to\n\nraise SystemExit exception, this event loop mechanism functionality is to be wrapped in a\n\nfunction and should return from the place where we intend to use sys.exit. Therefore, any\n\nexceptions that may be thrown or might occur, must exit cleanly using the following\n\nstatement.\n\nYou will be wondering that in the above code, many classes start with a capital letter Q so\n\nthat it can be distinguished from other namespaces.\n\nWe can resize the window, drag it around to any conformable place, maximize it or close it.\n\nJust make sure that you do not use the following, as it is best to avoid wild imports.\n\nOne important point to observe is that the GUI form comes up with the default title Python\n\nand with default size.\n\nNow, let us put some of our own title text in Python GUI form.\n\nIn BG1, we are calling setWindowTitle() method from QWidget object and passing parameter as\n\nBasic GUI Form. Therefore, we can see that our GUI form has a title that we wanted to\n\n\n\ndisplay at the top left. The rest of the code is the same as previous program.\n\nNow, we can also specify the size of our GUI form that is, by specifying width and height\n\n\n\nby calling the resize method as shown.\n\nIn RS1, we are calling the resize() method using the QWidget object and passing parameters as\n\n\n\n400 and 300. So, here we are setting width as 400 and height as 300, which sets our GUI\n\nform.\n\n\n\nTherefore, we have learned the basic structure of creating a GUI form using PyQt5 without\n\n\n\nthe usage of class.\n\nNow, we will learn similar examples, with usage of classes and objects concept.\n\nTill now, we have seen that for any package we want to install, we will be using the pip\n\ncommand. But Qt Designer cannot be installed in your system using pip command like this\n\npip install pyQt Designer. So, you can either download it from source forge or install it using\n\npip install pyqt5-tools.\n\n\n\nAfter this, run the designer from the following path.\n\nLaunch the Qt Designer application and on executing, the following GUI window, as shown\n\n\n\nin Figure 1.2, will be displayed to the user. Here, we can create our own GUI forms as per\n\nour need.\n\nLet us see some insights of Qt Designer. From Figure 1.2, we can see that there is an open\n\ndialog box with title as New Form, prompting the user to select any of the templates, forms or\n\nwidgets on launching the designer. The widgets selection is shown in Figure 1.3.\n• Dialog with Buttons Bottom: Using this template, a GUI form will be created with\n\n2 buttons, that is, OK and Cancel at the bottom-right position, as shown in Figure 1.4.\n\nThe widget present is QDialogButtonBox.\n• Dialog with Buttons Right: Using this template, a GUI form will be created with\n\n\n\npresence of two buttons, that is, OK and Cancel, at top-right position, as shown in the\n\n\n\nfollowing Figure 1.5. The widget present is QDialogButtonBox.\n• Dialog without Buttons: Using this template, an empty GUI form will be created\n\nwith superclass as QDialog, where the user can place widgets and create applications\n\nas per their own requirement.\n• Main Window: Using this template, the main application GUI form will be created\n\n\n\nwith superclass as QMainWindow, along with the presence of menu bar and toolbar for the\n\nuser. The user may use it or may delete it as per the need.\n• Widget: Using this template an empty GUI form will be created with superclass as\n\nQWidget.\n\nThese QDialog, QMainWindow and QWidget classes have their own importance.\n• Suppose there is a requirement to create a GUI form by choosing dialog template. In that\n\ncase, all the widgets used will be inherited from the superclass QDialog.\n• Suppose there is a requirement to create a GUI form by choosing the main window template.\n\nThen, all the widgets used will be inherited from the superclass QMainWindow.\n• Suppose there is a requirement to create a GUI form by choosing widget template. Here,\n\nall the widgets used will be inherited from the superclass QWidget.\n• Moreover, the screen size is selected as Default size, as shown in Figure 1.6. We can select\n\nthe screen size from the list of items mentioned in the combo box.\n\nWe will see all the components inside Qt Designer in a nutshell now. There are some\n\nnumbers present across each arrow mark in Figure 1.7. We will be discussing them one by\n\none.\n\nHere are the different numerically marked components:\n• Menubar: The first thing which we noticed at the top will be nothing but the menu bar\n\n\n\nof Qt Designer for GUI managing. It has File, Edit, Form View, Settings, Window and the\n\nHelp options for interacting with the user.\n• Toolbar: What we can manage using Menu bar can also be replicated using Toolbar.\n\n\n\nThe icons are placed instead of text for user interaction. It provides shortcut icons for\n\n\n\nmost useful functions. There are options like Edit Widgets, Edit Signals/Slots, Edit Buddies\n\n\n\nand Edit Tab order, in this toolbar of Qt Designer. We will be using all these features with\n\n\n\ndemonstration of some examples.\n• Widget Box: This is one of the most important areas of Qt Designer. It is located on\n\n\n\nthe left side of the Qt Designer window. There is a list of widgets and layouts which\n\n\n\nprovides flexibility to create wonderful GUI forms, and you can access it by using the\n\n\n\ndrag and drop to any location of our GUI. We will study about all these widgets and\n\nlayouts in detail.\n• Object Inspector (OI): OI is located on the right side of Qt Designer window, which\n\n\n\ndisplays the list of objects used in the form along with their layout display in\n\nhierarchical manner.\n• Property Editor: Under OI, there is a Property Editor dock widget. In this dock\n\nwidget, we can change the property of a widget, layout or of a window as per our\n\nrequirement.\n• Action Editor: Under Property Editor, there is Signals/Slot Editor , Action editor and\n\n\n\nResource browser.\n• In Signals/Slot Editor, signals and slots between the objects can be created,\n\ndeleted or edited as per our requirement. It may be noted that while using the\n\nwidget, complete configuration will not be possible as it requires possible amount\n\nof coding by the user to get the end result.\n• In Action editor, we can create new actions, and delete actions. Moreover, there\n\nis a checkable option for Used column, we can write text under “Text column”,\n\nprovide a shortcut key under “Shortcut column”, make checkable under “Checkable\n\n\n\ncolumn” as well as a tooltip that has been provided under “Tooltip column”. This\n\naction editor will allow us to work with Actions.\n• Whenever there will be a requirement to manage resources like images, icons,\n\n\n\ntranslation files and any binary files in our application, then we will be using Resource Browser. We will be learning this with examples.\n\nFinally, let us see the first example of Qt Designer. We will be creating a user credentials\n\napplication where the username and password will be prompted from the user. If they both\n\nmatch, then we will display some message. This example is quite important to understand\n\nbecause first we will simply display them by just dragging and dropping without using\n\nthe concept of layout and spacers. Then we will learn the concept of layouts and\n\nspacers.\n• We have selected the new template as Widget for creating the user credentials app\n\n\n\nGUI form.\n• First drag 2 Label widgets under display widgets dock and drop it on the GUI form. We\n\nare changing a few properties of these Label widgets. First is the text property of\n\nwhich we have changed the text to Enter your username and Enter your password\n\nrespectively. Next, we have changed the font property. Moreover, we have also\n\nchanged their object names as mylbl_username and mylbl_password using the objectName\n\nproperty.\n• Then drag 2 Line Edit widgets from the widget box and drop it on the GUI form. Using\n\n\n\nobjectName property, their names have been changed to lineEdit_username and\n\n\n\nlineEdit_password.\n• Finally drag a Push Button widget into the GUI form and change its text to Confirm using\n\nits text property. Then, using objectName property, its name has been changed to\n\n\n\nmybtn_confirm.\n• Now, we are saving this GUI form with name as “user_credential_app.ui”. This .ui file is\n\nnothing but an XML file which depicts form information, that is, widgets, layouts and\n\nso on. In simple ways, we can understand that Qt Designer is independent of any\n\n\n\nprogramming language and does not generate code in any of the programming\n\nlanguages but generates a XML based .ui file as it is easy to understand.\n\nThe data contents inside user_credential_app.ui file is as follows:\n\nSome important observations from user_credential_app.ui file are:\n• We can see that whatever property we have changed such as text, font and\n\nobjectName all have been reflected in their respective widgets.\n• Moreover, default geometry property with x, y, width and height is mentioned\n\nwith values for each widget.\n• Just observe the Qt Designer property for each widget. The property whose color is\n\n\n\nblack object with bold text property will be displayed in the .ui file.\n\nLet us now move on to the next step in creating the User Credentials App.\n\nOur next task is to convert this XML based .ui file to Python scripting with the help of\n\ncommand utility pyuic5. It is a dev tool to make the conversion of Qt Designer .ui file\n\nto Python .py file. A good thing is that it is tied together with PyQt5. Therefore, we go to the folder where we have saved this “user_credential_app.ui” file which is saved in\n\nthe folder “Enter your file path\\User Credential app” as shown in the following\n\n\n\nFigure 1.9 by opening the command prompt window.\n• Therefore, after opening of command window and navigating to the folder, we are\n\n\n\nwriting the following command.\n\nAfter execution of the above command, we can see from Figure 1.10 that\n\nuser_credential_app.py file has been created and the python code inside this file is as\n\n\n\nfollows.\n\nSo, here we can convert a .ui file into .py file.\n\nThis ‘-o’ in pyuic5 command which we had run here, stands for - -output, that is, writing\n\nthe generated Python code to the user_credential_app.py file.\n\nOne of the most important points to note after converting .ui file to .py file, is that the\n\nmodification of the Python code generated must not be done manually. This\n\nis since any modification done will be overwritten the next time we will be creating .py\n\nfile from .ui file, when running using pyuic5 command.\n• It is now time to create a new Python file called run_user_credential_app.py. Here, we will\n\nbe importing user_credential_app.py file and write some code into it such that when\n\nusername and password is matched/unmatched some message will be displayed to\n\nthe user.\n• Let us now understand the explanation of the source code.\n\n\n\nIn RUCA1, after importing the sys module for accessing the command line arguments, we are\n\nimporting from class, which creates desktop style UIs of PyQt5 package, that is, QtWidgets.\n\nQWidget is used for creating an empty GUI and an application handler, that is, QApplication. In\n\naddition to it, we are also importing a widget for creating dialogs, which is, QMessageBox. We\n\nwill be learning about this later. For your information right now, we are displaying a pop up\n\nwindow with some informative text to the user.\n• We have created a new Python file run_user_credential_app.py to utilize Ui_Form class, which\n\n\n\nwas created using pyuic5 command from the Qt Designer .ui file . Here, MyWidget class will inherit\n\n\n\nfrom Ui_Form class. So in RUCA2 from user_credential_app Python file, we are importing all the\n\n\n\nmembers of a module.\n• In RUCA3, we are creating an instance of the Ui_Form class.\n• For representing organization of widgets in a UI, a widget tree is built on the parent widget\n\n\n\nForm by the method setupUi of the class Ui_Form. This generated class contains a method\n\ncalled setupUi that configures the widgets and layout in accordance with the data in the .ui\n\nfile. When the Python code is run, the instance of the top-level widget class receives a call\n\nto the setupUi method, which initialises all the widgets and configures the layout in\n\naccordance with the data in the .ui file. The graphical user interface of the application is\n\nessentially created using this method. There is also a retranslateUi method for translating\n\n\n\nthe interface, that is, for multi language support logic handling, regarding how the text is to\n\nbe displayed in the GUI. In RUCA4, we are passing a single positional argument self.\n• In RUCA5, we are using the concept of signals and slots. Here, when the whenmybtn_confirmbutton\n\n\n\nis clicked (click event | signal), myuser_credentials_check method (slot) will be invoked. We will\n\nstudy about signals and slots in detail later in this section. Just understand the flow of\n\nconcepts right now.\n• In RUCA6, we are displaying widgets by calling the show() method with the object.\n• Now, we shall see what exactly we are doing inside myuser_credentials_check method which is\n\nevent handling for the mybtn_confirmbutton.\n• In RUCA7, we are first checking whether the text inside the line Edit_username is empty or not. If it is\n\nempty, then a message is being displayed Username cannot be empty as informative text, in new\n\nwindow, when you click on the confirm button.\n\nThe control will be then returned after clicking the Ok button. This message on the new\n\nwindow is possible due to the QMessageBox widget.\n\nIn RUCA8, we are then checking whether text inside the line Edit_password is empty or not. This\n\nindicates that the line Edit_username is not empty. If the line Edit_password is empty, then the message\n\npassword cannot be empty. is displayed as informative text in a new window, on clicking the\n\nconfirm button.\n\nWe can see that the text hello is written in line Edit_username widget. The control will be then\n\n\n\nreturned after clicking the Ok button.\n\nIn RUCA9, we are checking whether text of line Edit_username and line Edit_password matches or\n\n\n\nnot. If it matches, then the text with the Welcome message will pop up in the new window.\n\nIf the text is not matched, then Credentials does not match message will pop up in a new\n\n\n\nwindow.\n• In RUCA10, we are creating an instance, that is, object of QApplication class using the variable\n\nname myapp and passing command line parameters list sys.argv to the application.\n• In RUCA11, we are creating an object of MyWidget class using the variable name mywindow.\n• In RUCA12, for starting up the event loop mechanism, we are calling myapp.exec_() method,\n\n\n\nwhich will hold by the application object. If we want our code to return gracefully and not to\n\nraise SystemExit exception, this event loop mechanism functionality is to be wrapped in a\n\nfunction and should return from the place where we intend to use sys.exit. So, any\n\nexceptions thrown or might occur must exit cleanly using the statement.\n\nWe can see that we have created an application user credentials app without the usage of\n\nany layout management, that is, without any arranging of widgets in our UI form. Now, in\n\nthe next section, we will study how to create the same application by using layout\n\n\n\nmanagement."
    },
    {
        "link": "https://stackoverflow.com/questions/62686787/creating-a-custom-signal-slot-in-qt-pyqt5",
        "document": "You make a dict somewhere. And you always refer it. I don't know how long you expand the key & value connections, but you now set the same key & value anywhere directly.It is verbose , you may as well always get the key from one object as much as you can. And if you do so, whatever you add new keys& values in the dict, the changes reflect without changing other codes. When you want to expand your key & value, all you have to do is to rewrite the data of only once. Fortunately, dict can conserve the order of keys from ... You can use keys like a list. Please, append 'D': 'You choose D' or other datas and try it! I'm glad my answer is what you want.\n\nSimply, can you achieve your purpose by this code?\n\nWhat I understood from your question is to set the first item on the lineedit at the first time.\n\nI don't know what you want to set actually, but, textActivated() since (PyQt5.14) (I could do it activated() because my version is 5.9.x) ...\n\nBecause you have connected (signal) with (slot), so, if you set the currentText() for object when it is emitted, the setText catch the object.If you connect the signal to three , all of the lineedits set text by the same information.\n\nBefore emitting, you must make a connection except for default settings.\n\nI think you don't need to make a custom signal & slot if my answer is what you want.\n\nYou can connect signal/slots out of the init(). But it is often very convenient to make a connection in that place. For the most part, there is no chance to disconnect.And if you don't want to connect, you can block the connection by using method.\n\nSo, for the evidence of it, you may try to write test code somewhere to make a connection after . For example, a signal&slot for making a signal&slot.\n\nrun a loop but not run over and over again. is waiting for user input, eventHandler, for example, , . Especially, for showing the GUI. init is only called once. The variables of it are allotted into your computer's address of memory.\n\nTo call init over and over again means that the memory is rewritten over and over again.Memory is mainly necessary for avoiding this waste.\n\nIf you change the contents of variables after usage of your application by or , or signal&slot mechanism, it is that you rewrite the allotted addresses of the memory to other things.\n\nI think update is called after that change. This is for updating the GUI surface information according to the new variables."
    },
    {
        "link": "https://discuss.huggingface.co/t/tokenizer-decoding-using-bert-roberta-xlnet-gpt2/1128",
        "document": "I’ve been using BERT and am fairly familiar with it at this point. I’m now trying out RoBERTa, XLNet, and GPT2. When I try to do basic tokenizer encoding and decoding, I’m getting unexpected output.\n\nHere is an example of using BERT for tokenization and decoding:\n\nI understand the special tokens like and the wordpiece tokens like .\n\nHowever, when I try other models, I get crazy output.\n\nWhere are those characters coming from?\n\nWhy are there underscore characters?\n\nAgain, where are those characters coming from?\n\nI understand there are different subword tokenization schemes used by each. I also have the original research papers. Can someone please explain how the Huggingface Transformers implementation is producing these different outputs?"
    },
    {
        "link": "https://huggingface.co/docs/transformers/en/main_classes/tokenizer",
        "document": "and get access to the augmented documentation experience\n\nA tokenizer is in charge of preparing the inputs for a model. The library contains tokenizers for all the models. Most of the tokenizers are available in two flavors: a full python implementation and a “Fast” implementation based on the Rust library 🤗 Tokenizers. The “Fast” implementations allows:\n• a significant speed-up in particular when doing batched tokenization and\n• additional methods to map between the original string (character and words) and the token space (e.g. getting the index of the token comprising a given character or the span of characters corresponding to a given token).\n\nThe base classes PreTrainedTokenizer and PreTrainedTokenizerFast implement the common methods for encoding string inputs in model inputs (see below) and instantiating/saving python and “Fast” tokenizers either from a local file or directory or from a pretrained tokenizer provided by the library (downloaded from HuggingFace’s AWS S3 repository). They both rely on PreTrainedTokenizerBase that contains the common methods, and SpecialTokensMixin.\n\nPreTrainedTokenizer and PreTrainedTokenizerFast thus implement the main methods for using all the tokenizers:\n• Tokenizing (splitting strings in sub-word token strings), converting tokens strings to ids and back, and encoding/decoding (i.e., tokenizing and converting to integers).\n• Adding new tokens to the vocabulary in a way that is independent of the underlying structure (BPE, SentencePiece…).\n• Managing special tokens (like mask, beginning-of-sentence, etc.): adding them, assigning them to attributes in the tokenizer for easy access and making sure they are not split during tokenization.\n\nBatchEncoding holds the output of the PreTrainedTokenizerBase’s encoding methods ( , and ) and is derived from a Python dictionary. When the tokenizer is a pure python tokenizer, this class behaves just like a standard python dictionary and holds the various model inputs computed by these methods ( , …). When the tokenizer is a “Fast” tokenizer (i.e., backed by HuggingFace tokenizers library), this class provides in addition several advanced alignment methods which can be used to map between the original string (character and words) and the token space (e.g., getting the index of the token comprising a given character or the span of characters corresponding to a given token).\n\nApart from that each tokenizer can be a “multimodal” tokenizer which means that the tokenizer will hold all relevant special tokens as part of tokenizer attributes for easier access. For example, if the tokenizer is loaded from a vision-language model like LLaVA, you will be able to access to obtain the special image token used as a placeholder.\n\nTo enable extra special tokens for any type of tokenizer, you have to add the following lines and save the tokenizer. Extra special tokens do not have to be modality related and can ne anything that the model often needs access to. In the below code, tokenizer at will have direct access to three more special tokens.\n\nThe PreTrainedTokenizerFast depend on the tokenizers library. The tokenizers obtained from the 🤗 tokenizers library can be loaded very simply into 🤗 transformers. Take a look at the Using tokenizers from 🤗 tokenizers page to understand how this is done."
    },
    {
        "link": "https://pypi.org/project/transformers/2.1.0",
        "document": "A required part of this site couldn’t load. This may be due to a browser extension, network issues, or browser settings. Please check your connection, disable any ad blockers, or try using a different browser."
    },
    {
        "link": "https://pypi.org/project/transformers/2.0.0",
        "document": "A required part of this site couldn’t load. This may be due to a browser extension, network issues, or browser settings. Please check your connection, disable any ad blockers, or try using a different browser."
    },
    {
        "link": "https://machinelearningmastery.com/a-gentle-introduction-to-transformers-library",
        "document": "Transformers is an architecture of machine learning models that uses the attention mechanism to process data. Many models are based on this architecture, like GPT, BERT, T5, and Llama. A lot of these models are similar to each other. While you can build your own models in Python using PyTorch or TensorFlow, Hugging Face released a library that makes it easier to create these models and provides many pre-trained models you can use. The name of the library is uninteresting, just . In this article, you will learn how to use this library.\n\nWhat is the transformers library?\n\nThe transformers library is a Python library that provides a unified interface for working with different transformer models. Not exhaustively, but it defined many well-known open-source models, like GPT, BERT, T5, and Llama. While it is not the official library for many of these models, the architectures are the same. The beauty of this library is that it unified the interface for different models. For example, you know that BERT and T5 can both generate text; you don’t need to know the architectural differences between the two but still use them via the same function call.\n\nHugging Face Hub is a repository of resources for machine learning, including the pre-trained models. As a user of the models, you can download and use them in your projects without knowing much about the mechanisms behind them. If you want to use a model, such as GPT, you can simply find the name of the model in the hub and use it in the transformers library. The library will download the model, figure out what architecture it is using, then create the model and load the weights for you, all in one line of code.\n\nThe transformers library makes it easy to use the transformer models in your projects without requiring you to become an expert in these machine learning models.\n\nThe installation is straightforward. You can install the library using pip:\n\nThis will install the library and all the dependencies. The supported models are usually built with three frameworks: PyTorch, TensorFlow, and JAX/Flax. You can decide to use one of them when calling the library. Most of the models default to PyTorch.\n\nThis is enough to start a project, such as creating and training a new model on your own data. However, some of the pre-trained models on Hugging Face Hub would require you to have a Hugging Face account. You can sign up for one for free. Moreover, some models are “gated,” meaning you need to request access to use them. Using these models from the transformers library would require you to authenticate yourself with an access token.\n\nTo sign up for a Hugging Face account, visit the website https://huggingface.co/join. Once you have an account, you can create an access token. You can do this by going to the access tokens page. Once you have the token, you should remember it, as it is displayed only once when you create the token.\n\nThe library is very easy to use. Let’s see how to use it to load a pre-trained model.\n\nThis is not the shortest code to use the transformers library, but it shows the main idea. It created a tokenizer that converts the input text into integer tokens, then created a model to process these tokens and return the output.\n\nAll pre-trained models are identified by a model ID. When you create a tokenizer that a pre-trained model requires, it will check with the pre-trained model’s config to instantiate the correct tokenizer object, similarly, for the model. Therefore, you just need to use and instead of the specific classes, such as and . Knowing how a transformer model usually works, you should expect the core model to take the input tokens and output logit tensors. Therefore, you used above to convert the logits to token IDs and convert the IDs to strings using the tokenizer’s method.\n\nHowever, you must provide the access token if you want to use a gated model with the above code. The way to set up the access token is to use some environment variables. You can find all environment variables that matter to the transformers library in the documentation; the most important ones are:\n• : The directory to store the cached models.\n\nYou should either set this as environment variables before you run your script or do it like the following:\n\nNote that environment variables should be set to before you import the transformers library. The model used above, , is an example of a gated model that you need to request for access and authenticate yourself with an access token before using it.\n\nIf the pre-trained model can help you work on a text generation task, why would you care about the details, such as the tokenizer and the logit output? Therefore, the library provides a function to perform different tasks with a pre-trained model, hiding all such details. Below is an example of using the function to perform a sentiment analysis task:\n\nThe function will create the model and tokenizer, load them with the pre-trained weights, and run the task you specified. All in one line of code. You don’t need to care about how the different components work together.\n\nThe first argument to the function is the task name. Only a few tasks are supported by the library, some of which are related to image and audio processing. The most common ones in the domain of text processing are:\n• : To generate text in auto-complete style. This is probably the most commonly used task.\n• : Sentiment analysis, usually to predict “positive” or “negative” sentiment for a given text. The task is the same as this task.\n• : Zero-shot classification. That is, provide a sentence and a set of labels to the model and ask the model to predict the label that best describes the sentence.\n• : Question answering. This is not to be confused with the task, which can generate answers to open-ended questions. This generates the answer for a given question based on the provided context.\n\nYou can launch a pipeline with just the task name. All tasks will have a default model. If you prefer to use a different model, you can specify the model ID, as in the example above.\n\nIf you’re interested, you can investigate the pipeline object to see what kind of models it is using. For example, the object above uses a model. You can check it using the following:\n\nThe output will be:\n\nYou can find from the above output that the model is and the tokenizer is . You can indeed create the model and tokenizer directly using the code below:\n\nHowever, you would need to process the input text and run the model yourself. In this aspect, the pipeline function is a convenience.\n\nBelow are some of the articles that you may find useful.\n\nIn this article, you have learned how to use the transformers library to load a pre-trained model and use it to perform a task. In particular, you learned:\n• How to use the transformers library to create a model and use it to perform a task.\n• Using the function to perform different tasks with a pre-trained model.\n• How to investigate the pipeline object to see what kind of models it is using."
    }
]