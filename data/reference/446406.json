[
    {
        "link": "https://mui.com/material-ui/react-autocomplete?srsltid=AfmBOoqxYN0h3Ww_PgRZOyMDzVOGvwsH_LVsiDo10wnVvSnqpP7TJEj7",
        "document": "The autocomplete is a normal text input enhanced by a panel of suggested options. The widget is useful for setting the value of a single-line textbox in one of two types of scenarios:\n• The value for the textbox must be chosen from a predefined set of allowed values, for example a location field must contain a valid location name: combo box.\n• The textbox may contain any arbitrary value, but it is advantageous to suggest possible values to the user, for example a search field may suggest similar or previous searches to save the user time: free solo. It's meant to be an improved version of the \"react-select\" and \"downshift\" packages.\n\nBy default, the component accepts the following options structures: However, you can use different structures by providing a prop. If your options are objects, you must provide the prop to ensure correct selection and highlighting. By default, it uses strict equality to compare options with the current value. Each of the following examples demonstrates one feature of the Autocomplete component.\n\nIf you control the , make sure it's referentially stable between renders. In other words, the reference to the value shouldn't change if the value itself doesn't change. In the first example, is called and returns a new array every render. The fix includes memoizing the value, so it changes only when needed. Set to true so the textbox can contain any arbitrary value. The prop is designed to cover the primary use case of a search input with suggestions, for example Google search or react-autowhatever.\n\nIf your logic is fetching new options on each keystroke and using the current value of the textbox to filter on the server, you may want to consider throttling requests. Additionally, you will need to disable the built-in filtering of the component by overriding the prop: A customized UI for Google Maps Places Autocomplete. For this demo, we need to load the Google Maps JavaScript and Google Places API.\n\nTo globally customize the Autocomplete options for all components in your app, you can use the theme default props and set the property in the key. The property takes the as the fourth parameter, which includes props and internal component state. To display the label, you can use the prop from the . This approach enables different options for each Autocomplete component while keeping the options styling consistent.\n\nThe component exposes a factory to create a filter method that can be provided to the prop. You can use it to change the default option filter behavior.\n• (number [optional]): Default to null. Limit the number of suggested options to be shown. For example, if is , only the first matching options are shown. It can be useful if a lot of options match and virtualization wasn't set up.\n• (func [optional]): Controls how an option is converted into a string so that it can be matched against the input text fragment. : the returned filter method can be provided directly to the prop of the component, or the parameter of the same name for the hook. In the following demo, the options need to start with the query prefix:\n\nIf you would like to prevent the default key handler behavior, you can set the event's property to : Browsers have heuristics to help the user fill in form inputs. However, this can harm the UX of the component. By default, the component disables the input autocomplete feature (remembering what the user has typed for a given field in a previous session) with the attribute. Google Chrome does not currently support this attribute setting (Issue 41239842). A possible workaround is to remove the to have the component generate a random one. In addition to remembering past entered values, the browser might also propose autofill suggestions (saved login, address, or payment details). In the event you want the avoid autofill, you can try the following:\n• None Name the input without leaking any information the browser can use. For example instead of . If you leave the id empty, the component uses a random id.\n• None Set (some browsers will suggest a strong password for inputs with this attribute setting): Read the guide on MDN for more details. VoiceOver on iOS Safari doesn't support the attribute very well. You can work around the issue with the prop. If you provide a custom prop, you need to make sure that the intended scroll container has the attribute set to . This ensures the correct behavior of the scroll, for example when using the keyboard to navigate. We encourage the usage of a label for the textbox. The component implements the WAI-ARIA authoring practices."
    },
    {
        "link": "https://mui.com/material-ui/api/autocomplete?srsltid=AfmBOopivpS-If3osDi7Rq1ok0dSwiQLMf5LgP9vyhc63WyqpJxc7Uyw",
        "document": "If , the selected option becomes the value of the input when the Autocomplete loses focus unless the user chooses a different option or changes the character string in the input.\n\nWhen using the mode, the typed value will be the input value if the Autocomplete loses focus without highlighting an option."
    },
    {
        "link": "https://refine.dev/blog/material-ui-autocomplete-component",
        "document": "This article was last updated on July 03, 2024, to add sections for Accessibility Features, Security Considerations, and Formik Integration with AutoComplete to Material UI AutoComplete.\n\nMaterial UI provides a unique set of components and utilities to help developers have a better creative experience with web applications. One such component is the Material UI component. This article will dive deep into the Material UI Autocomplete component, highlight its accompanied features and explore a potential use case in a real-world application.\n\nDeveloped in 2014, Material UI is a React framework that provides adequate tools(components and utilities) to create a web application. Material UI enables the use of various customizable components to create a UI for a company's web and mobile apps. Many developers now use Material UI to structure their projects because it makes web design more straightforward and effective.\n\nMaterial UI offers several component categories, including Navigations components, Input components, Data Display components, Feedback components, e.t.c. The Material UI Autocomplete component is a prime example of the Input components.\n\nYou can install Material UI into your React project with:\n\nThe Material UI component can be identified as an improved React text input that includes several suggested options for better optimization. It is an enhanced version of or packages.\n\nThe component is best used for modifying single-line textbox values to accommodate more options. The component’s is obtained from a predetermined range of acceptable values/options.\n\nHere’s how to structure your option values:\n\nBelow is a simple illustration of Material UI Autocomplete in play:\n\nThe code above showcases an input text field that displays 5 songs as predefined option values.\n\nThe prop allows you to customize the rendered input to display the option values in whatever form you please.\n\nConsider the code below:\n\nThe code above illustrates the use of the prop. Take special note of the and keys.\n\nis used to display the text in the dropdown menu.\n\nThe is used to determine the selected value of a specified array.\n\nWhen you add the prop to the component, it enables the text field to accept undetermined values. The prop's primary purpose is to provide suggestions for a search like Google search does.\n\nYou can sort the Material UI Autocomplete options with the prop. To do this, you must ensure that the values are sorted systematically in the same dimension as they are grouped to avoid duplicate headers.\n\nThe code above illustrates the use of the prop in the . It groups an array containing 100 movies, displays them alphabetically and highlights the first letter of the movie title when scrolling through.\n\nThe component has two manageable states:\n\nThe state represents the value chosen by the user by clicking or pressing “Enter.” The value represents the value displayed in the textbox.\n\nThe code showcases how the values of the component can be controlled and altered in state.\n\nMaterial UI Autocomplete comes with a headless hook which can serve as an alternative search input to the component. It accepts nearly the same option props as the Autocomplete component without the ones about DOM rendering.\n\nYou can import this hook into your React project like this:\n\nConsider the code below:\n\nThe code above showcases a simple use case for the hook. It helps display songs in an array as search options without using the component.\n\nThe component can display search input options with two different asynchronous requests:\n\nLoad on open: It waits until the component is interacted with before loading the options. It displays a progress bar when your local network is pending/loading Search as you type: Each keystroke generates a new request..\n\nConsider the code below:\n\nThe code above showcases an asynchronous DOM display of the Material UI Autocomplete component illustrating the “Load on open” feature.\n\nMaterial UI Autocomplete also provides a feature for users to select more than one value. You can do that by calling the prop inside the component. You can also set a default option value like this:\n\nIn a scenario where you want a fixed default tag that cannot be deleted or removed you can set the chips .\n\nThe code above illustrates how you can set a fixed default value on the component that cannot be deleted or removed.\n\nWhen using the Material UI component, you can choose to use checkboxes as search input option values. This helps you choose your options definitively and makes for a better user experience.\n\nConsider the code below:\n\nI have added a new section to the article about our Material-UI AutoComplete component that addresses accessibility features. This section explains how to treat accessibility in general and gives some specific examples of how ARIA attributes might be implemented in a product, along with keyboard navigation.\n\nIntroduction: It is essential that we make our applications accessible to every user. ARIA, or Accessible Rich Internet Applications, attributes help increase accessibility within our components.\n\nExample: Make the AutoComplete component more accessible by adding in ARIA attributes as shown below:\n• If possible, use , , or to describe the input for accessible purposes.\n• : Describes the role of the AutoComplete input.\n• Be sure to use to let users know if the dropdown is opened or closed.\n• Use and to manage announcements about dropdown changes made visible to screen readers.\n\nIntroduction: It is important to make sure that the functionality of our AutoComplete component can also be accessed by using the keyboard so that it could be operated even without a pointing device. This will require that we handle keyboard events in such a way that a user could interact with our component only through the use of the keyboard.\n\nBelow are some code snippets and tips to improve keyboard navigation:\n• Use to implement navigation with the arrow keys, selection with Enter, and closing the dropdown with Escape.\n• Ensure that it behaves responsibly concerning focus with the dropdown open and closed.\n• Use to control the tabbing order of dropdown items.\n\nThese accessibility features ensure all users can use our AutoComplete component without issue, including screen reader users and keyboard navigators.\n\nThe majority of products incorporate search inputs into various elements of their web applications. Google's Home page layout illustrates how search inputs might be used in typical real-world application. For the sake of this tutorial, we will use React and Material UI Autocomplete to replicate Google's home page layout.\n\nHeuristics are built into browsers to assist users in filling out form inputs, but tend to hurt the component's UX. With the attribute, the component disables the input feature (remembering what the user wrote for a specific field in a previous session). One possible fix is removing the id and letting the component generate one randomly.\n\nIn addition to remembering previously entered information, the browser may make autofill suggestions (saved login, address, or username). If you wish to avoid autofill, you can attempt the following: Name the input without revealing any information that the browser can utilize. id=\"field1\" instead of id=\"country\" If you leave the id field empty, the component generates a random id. Set . Some browsers will recommend a secure password for inputs with this attribute set.\n\nI've added a new section on integrating the Material UI AutoComplete component with Formik. In this section, I will give an overview of how integration can be done without actual code snippets.\n\nFormik is an already well-known library for managing form states in React. Since Material-UI's AutoComplete component is integrated with Formik, it will provide us with all the good features of Formik in terms of validation and state management for the robust form, and, in parallel, it would allow user input.\n\nThe following shows how you can use the Material UI AutoComplete component in combination with Formik:\n• Setup: The first thing you need to do is install Formik and Yup if you haven't done so yet.\n• Custom AutoComplete Component:\n• Use the hook from Formik to sync your AutoComplete component with the form state from Formik.\n• Define a validation schema using Yup, which enforces the validation requirement on the AutoComplete field.\n• Handle form submission and validations with the help of Formik's components like Form and Field.\n\nBy following these steps, you can now easily use the Material UI AutoComplete component in combination with Formik in a way that maintains the state and validates form elements.\n\nIn this article, we discussed the Material UI Autocomplete component, its 'option' props, functionalities and variations. We then moved on to clone Google's Home page using the Autocomplete component. . Despite its limitations, Material UI Autocomplete assists developers in generating a responsive and interactive search input for any web interface. I hope you find this post useful."
    },
    {
        "link": "https://stackoverflow.com/questions/71989798/how-to-style-list-option-in-autocomplete-material-ui-with-use-of-renderoption",
        "document": "I am trying hard to customize option elements in autocomplete list. I want to do this by use of renderOptions prop, where i can create DOM elements. Then, i can pretty easly add styles with sx or styled components.\n\nBut something is wrong. When i try to render options list elements wrapped in divs, the names of the movies are hidden (?) They are rendered, because i can still choose option, and after that it is showned as selected, but the input list is still broken, and CSS styles are not applied.\n\nWhat I am missing ? Autocomplete and its styling is new for me."
    },
    {
        "link": "https://stackoverflow.com/questions/62110017/material-ui-autocomplete-custom-renderinput",
        "document": "The 4.10.1 release of Material-UI (on June 1, 2020) included a new example in the documentation for this exact case: https://material-ui.com/components/autocomplete/#custom-input.\n\nThe most useful example to look at in the documentation is the Customized Autocomplete example which uses instead of . This example contains the following code for :\n\nThe passed to are placed on a div that wraps the , so most of those props are not appropriate to put directly on the element as you were. In the code above from the documentation example, you can see that it only uses one thing from which is the . This ref is used for controlling the anchor element for the listbox of options. A ref is also placed on the itself, but that is used for very different purposes. With your code, only one of those refs was getting used.\n\nBelow is a working example (based on the Combo Box example since your sandbox has a lot of other customizations that aren't directly related to this question) that uses instead of :"
    },
    {
        "link": "https://styled-components.com/docs/basics",
        "document": "styled-components is the result of wondering how we could enhance CSS for styling React component systems. By focusing on a single use case we managed to optimize the experience for developers as well as the output for end users.\n\nApart from the improved experience for developers, styled-components provides:\n• Automatic critical CSS: styled-components keeps track of which components are rendered on a page and injects their styles and nothing else, fully automatically. Combined with code splitting, this means your users load the least amount of code necessary.\n• No class name bugs: styled-components generates unique class names for your styles. You never have to worry about duplication, overlap or misspellings.\n• Easier deletion of CSS: it can be hard to know whether a class name is used somewhere in your codebase. styled-components makes it obvious, as every bit of styling is tied to a specific component. If the component is unused (which tooling can detect) and gets deleted, all its styles get deleted with it.\n• Simple dynamic styling: adapting the styling of a component based on its props or a global theme is simple and intuitive without having to manually manage dozens of classes.\n• Painless maintenance: you never have to hunt across different files to find the styling affecting your component, so maintenance is a piece of cake no matter how big your codebase is.\n• Automatic vendor prefixing: write your CSS to the current standard and let styled-components handle the rest.\n\nYou get all of these benefits while still writing the CSS you know and love, just bound to individual components.\n\nInstalling styled-components only takes a single command and you're ready to roll:\n\nIf you use a package manager like yarn that supports the \"resolutions\" package.json field, we also highly recommend you add an entry to it as well corresponding to the major version range. This helps avoid an entire class of problems that arise from multiple versions of styled-components being installed in your project.\n\nIt removes the mapping between components and styles. This means that when you're defining your styles, you're actually creating a normal React component, that has your styles attached to it.\n\nThis example creates two simple components, a wrapper and a title, with some styles attached to it:\n\nThis is a live editor, so play around with the code to get a feel for what it's like to work with styled-components!\n\nYou can pass a function (\"interpolations\") to a styled component's template literal to adapt it based on its props.\n\nThis button component has a primary state that changes its color. When setting the prop to true, we are swapping out its background and text color.\n\nQuite frequently you might want to use a component, but change it slightly for a single case. Now, you could pass in an interpolated function and change them based on some props, but that's quite a lot of effort for overriding the styles once.\n\nTo easily make a new component that inherits the styling of another, just wrap it in the constructor. Here we use the button from the last section and create a special one, extending it with some color-related styling:\n\nWe can see that the new still resembles , while we have only added two new rules.\n\nIn some cases you might want to change which tag or component a styled component renders. This is common when building a navigation bar for example, where there are a mix of anchor links and buttons but they should be styled identically.\n\nFor this situation, we have an escape hatch. You can use the to dynamically swap out the element that receives the styles you wrote:\n\nThis works perfectly fine with custom components too!\n\nThe method works perfectly on all of your own or any third-party component, as long as they attach the passed prop to a DOM element.\n\nIf the styled target is a simple element (e.g. ), styled-components passes through any known HTML attribute to the DOM. If it is a custom React component (e.g. ), styled-components passes through all props.\n\nThis example shows how all props of the Input component are passed on to the DOM node that is mounted, as with React elements.\n\nNote how the prop is not passed to the DOM, but and are? The function is smart enough to filter non-standard attributes automatically for you.\n\nHow do Styled Components work within a component?\n\nIf you're familiar with importing CSS into your components (e.g. like CSSModules) you'll be used to doing something like this:\n\nBecause a Styled Component is the combination of the element and the rules that style it, we'd write like this:\n\nNote that we added a \"Styled\" prefix to so that the React component and the Styled Component don't clash names but remain easily identifiable in the React Developer Tools and Web Inspector.\n\nDefine Styled Components outside of the render method\n\nIt is important to define your styled components outside of the render method, otherwise it will be recreated on every single render pass. Defining a styled component within the render method will thwart caching and drastically slow down rendering speed, and should be avoided.\n\nWrite your styled components the recommended way:\n\nRecommended reading: Talia Marcassa wrote a great review of real-world usage, featuring lots of solid practical insights and comparisons with alternatives, in Styled Components: To Use or Not to Use?\n\nThe preprocessor we use, stylis, supports scss-like syntax for automatically nesting styles.\n\nThrough this preprocessing, styled-components supports some advanced selector patterns:\n• a single ampersand refers to all instances of the component; it is used for applying broad overrides: background: tomato; // <Thing> as a sibling of <Thing>, but maybe not directly next to it background: orange; // <Thing> tagged with an additional CSS class \".something\" const Thing = styled.div.attrs((/* props */) => ({ tabIndex: 0 }))` color: blue; &:hover { color: red; // <Thing> when hovered } & ~ & { background: tomato; // <Thing> as a sibling of <Thing>, but maybe not directly next to it } & + & { background: lime; // <Thing> next to <Thing> } &.something { background: orange; // <Thing> tagged with an additional CSS class \".something\" } .something-else & { border: 1px solid; // <Thing> inside another element labeled \".something-else\" } ` render( <React.Fragment> <Thing>Hello world!</Thing> <Thing>How ya doing?</Thing> <Thing className=\"something\">The sun is shining...</Thing> <div>Pretty nice day today.</div> <Thing>Don't you think?</Thing> <div className=\"something-else\"> <Thing>Splendid.</Thing> </div> </React.Fragment> )\n• a double ampersand refers to an instance of the component; this is useful if you're doing conditional styling overrides and don't want a style to apply to all instances of a particular component:\n• a double ampersand alone has a special behavior called a \"precedence boost\"; this can be useful if you are dealing with a mixed styled-components and vanilla CSS environment where there might be conflicting styles:\n\nIf you put selectors in without the ampersand, they will refer to children of the component.\n\nTo avoid unnecessary wrappers that just pass on some props to the rendered component or element, you can use the constructor. It allows you to attach additional props (or \"attributes\") to a component.\n\nThis way you can for example attach static props to an element or pass a third-party prop like to React Router's Link component. Furthermore, you can also attach more dynamic props to a component. The object also takes functions, that receive the props that the component receives. The return value will be merged into the resulting props as well.\n\nHere we render an component and attach some dynamic and static attributes to it:\n\nAs you can see, we get access to our newly created props in the interpolations, and the attribute is passed down to the element.\n\nNotice that when wrapping styled components, are applied from the innermost styled component to the outermost styled component.\n\nThis allows each wrapper to override nested uses of , similarly to how CSS properties defined later in a stylesheet override previous declarations.\n\n's are applied first, and then 's :\n\nThis is why is of a type, but still uses the attribute from .\n\nCSS animations with aren't scoped to a single component but you still don't want them to be global to avoid name collisions. This is why we export a helper which will generate a unique instance that you can use throughout your app:\n\nKeyframes are lazily injected when they're used, which is how they can be code-split, so you have to use the helper for shared style fragments:\n\nstyled-components can be used with React Native in the same way and with the same import. Try this example with Snack by Expo.\n\nWe also support more complex styles (like ), which would normally be an array, and shorthands (e.g. for ) thanks to !\n\nImagine how you'd write the property in React Native, guess how you'd transfer it to CSS, and you're probably right:\n\nSome of the differences to the web-version are, that you cannot use the and helpers since React Native doesn't support keyframes or global styles. We will also warn you if you use media queries or nest your CSS.\n\nIf you'd prefer to just import instead of , you can add a configuration that includes . This used to be supported in metro by default (and currently does work in haul) but appears to have been removed at some point."
    },
    {
        "link": "https://styled-components.com/docs/api",
        "document": "This is the default export. This is a low-level factory we use to create the helper methods.\n\nReturns a function that accepts a tagged template literal and turns it into a .\n\nYou can see this method being introduced in the Getting started section.\n\nThis is what you pass into your styled calls – a tagged template literal. This is an ES6 language feature. You can learn more about them in the Tagged Template Literals section.\n\nRead more about how to adapt styling based on props in the Adapting based on props section.\n\nThe properties that are passed into an interpolated function get attached a special property, , which is injected by a higher level component. Check the section on Theming for more information on this.\n\nYou can also return objects from interpolations or input objects directly, and they'll be treated as inline styles. However this is highly discouraged, as the CSS syntax has support for pseudo selectors, media queries, nesting, etc., which the object syntax doesn't.\n\nA styled React component. This is returned when you call or with styles.\n\nThis component can take any prop. It passes it on to the HTML node if it's a valid attribute, otherwise it only passes it into interpolated functions. (see Tagged Template Literal)\n\nYou can pass an arbitrary classname to a styled component without problem and it will be applied next to the styles defined by the styled call. (e.g. )\n\nThis is a chainable method that attaches some props to a styled component. The first and only argument is an object that will be merged into the rest of the component's props. The object accepts the following values:\n\nLearn more about this constructor in the Attaching Additional Props section.\n\nIf you want to keep all the styling you've applied to a component but just switch out what's being ultimately rendered (be it a different HTML tag or a different custom component), you can use the prop to do this at runtime.\n\nThis sort of thing is very useful in use cases like a navigation bar where some of the items should be links and some just buttons, but all be styled the same way.\n\nIf you choose to wrap another component with the HOC that also accepts an prop, use to pass along the desired prop to the wrapped component.\n\nIf you want to prevent props meant to be consumed by styled components from being passed to the underlying React node or rendered to the DOM element, you can prefix the prop name with a dollar sign ( ), turning it into a transient prop.\n\nIn this example, isn't rendered to the DOM like is.\n\nThis is a more dynamic, granular filtering mechanism than transient props. It's handy in situations where multiple higher-order components are being composed together and happen to share the same prop name. works much like the predicate callback of . A prop that fails the test isn't passed down to underlying components, just like a transient prop.\n\nKeep in mind that, as in this example, other chainable methods should always be executed after .\n\nOptionally, can take a second parameter that provides access to the default validator function. This function can be used as a fallback, and of course, it also works like a predicate, filtering based on known HTML attributes.\n\nA helper component for theming. Injects the theme into all styled components anywhere beneath it in the component tree, via the context API. Check the section on Theming.\n\nAdding to or replacing an outer theme using nested :\n\nSometimes you don't want to create an extra component just to apply a bit of styling. The prop is a convenient way to iterate on your components without settling on fixed component boundaries yet. It works on both normal HTML tags as well as components, and supports everything any styled component supports, including adapting based on props, theming and custom components.\n\nUnder the hood, the Babel plugin turns any element with a prop into a styled component. For example, the above code becomes:\n\nNote that you don't even have to add the import, the Babel plugin does that automatically! (unless you're using the Babel macro, see below)\n\nYou can use the Babel macro to make this work in . Unfortunately, Babel macros only run when imported so the import can not be added automatically. The above code works perfectly if you add the import to the macro manually:\n\nTo prevent TypeScript errors on the prop on arbitrary elements, install and add the following import once in your project:\n\nSee https://github.com/DefinitelyTyped/DefinitelyTyped/issues/31245#issuecomment-446011384 for more information.\n\nIf you're using a higher version than v6, you do not need to install . Instead, you can directly import the in your project like this:\n\nA helper function to generate a special that handles global styles. Normally, styled components are automatically scoped to a local CSS class and therefore isolated from other components. In the case of , this limitation is removed and things like CSS resets or base stylesheets can be applied.\n\nReturns a that does not accept children. Place it at the top of your React tree and the global styles will be injected when the component is \"rendered\".\n\nSince the component is a , that means it also has access to theming from the component if provided.\n\nA helper function to generate CSS from a template literal with interpolations. You need to use this if you return a template literal with functions inside an interpolation due to how tagged template literals work in JavaScript.\n\nIf you're interpolating a string you do not need to use this, only if you're interpolating a function.\n\nReturns an array of interpolations, which is a flattened data structure that you can pass as an interpolation itself.\n\nIf you leave off the css your function will be ed and you'll not get the results you expected.\n\nReturns a Keyframes model, to be used in your animation declarations. You can use the API on the returned model if you wish to obtain the generated animation name.\n\nIf you are composing your style rule as a partial, make sure to use the helper.\n\nYou can learn more about using animations with styled-components in the Animations section.\n\nA helper component for modifying how your styles are processed. For a given subtree involving styled-components, you can customize various behaviors like how the CSS runtime processor (stylis) handles styles via userland plugins and option overrides.\n\nFor example if your app is intended for legacy browsers, you may want to enable vendor prefixing for your styles:\n\nAnother example would be enabling right-to-left translation for your styles via the userland plugin:\n\nReturns true if the passed function is a valid styled components-wrapped component class. It can be useful for determining if a component needs to be wrapped such that it can be used as a component selector:\n\nThis is a higher order component factory to get the current theme from a and pass it to your component as a prop.\n\nReturns the passed component inside a wrapper (higher order component). The passed component will receive a prop with the current theme object.\n\nThis is a custom hook to get the current theme from a .\n\nThis is the \"consumer\" component created by as the companion component to . It uses the render prop pattern to allow for dynamic access to the theme during rendering.\n\nIt passes the current theme (based on a higher in your component tree) as an argument to the child function. From this function, you may return further JSX or nothing.\n\nA convenience method to find a single instance of a styled component's rendered DOM node within a given DOM root.\n\nA convenience method to find all instances of a styled component's rendered DOM node within a given DOM root.\n\nA convenience method for finding instances of a particular styled component within an enzyme wrapper.\n\nWithin a styled component, we support all of CSS plus nesting. Since we generate an actual stylesheet and not inline styles, whatever works in CSS works in styled-components!\n\nAmpersands ( ) get replaced by our generated, unique classname for that styled component, making it easy to have complex logic.\n\nstyled-components provides TypeScript definitions which empowers the editing experience in IDEs and increases type safety for TypeScript projects.\n\nTypeScript definitions for styled-components can be extended by using declaration merging since version of the definitions.\n\nSo the first step is creating a declarations file. Let's name it for example.\n\nis being used as an interface of out of the box. By default the interface is empty so that's why we need to extend it.\n\nNow we can create a theme just by using the declared at the step above.\n\nThat's it! We're able to use styled-components just by using any original import.\n\nIf you are adapting the styles based on props, and those props are not part of the base tag / component props, you can tell TypeScript what those extra custom props are, with type arguments like this (TypeScript is required):\n\nNote: if you style a standard tag (like in above example), styled-components will not pass the custom props (to avoid the Unknown Prop Warning).\n\nHowever, it will pass all of them to a custom React component:\n\nIf the customColor property should not be transferred to the Header component, you can leverage transient props, by prefixing it with a dollar sign ($):\n\nDepending on your use case, you can achieve a similar result by extracting the custom props yourself:\n\nWhen defining a component you will need to mark as optional in your Props interface:\n\nTo use function components and have typechecking for the props you'll need to define the component alongside with its type. This is not special to styled-components, this is just how React works:\n\nThis is a method that creates a new and extends its rules.\n\nReturns a new with the new rules merged into the ones of the component this method was called on.\n\nA helper method to write global CSS. It does not return a component, but adds the styles to the stylesheet directly.\n\nWe do not encourage the use of this. Try to use it once per app at most, if you must, contained in a single file. This is an escape hatch. Only use it for the rare definition or body styling.\n\nPassing a prop to a styled component will give you an instance of the wrapper, but not to the underlying DOM node. This is due to how refs work. It's not possible to call DOM methods, like , on our wrappers directly.\n\nTo get a ref to the actual, wrapped DOM node, pass the callback to the prop instead.\n\nThis example uses to save a ref to the styled input and focuses it once the user hovers over it.\n\nThis is a method that creates a new with a different tag or component applied to it, but all the same rules of the one it's called on.\n\nReturns a new with the new tag / component being applied when it's used."
    },
    {
        "link": "https://styled-components.com/docs/faqs",
        "document": "What do I need to do to migrate to v6?\n\nFirst, let's start by updating the necessary packages to their latest versions.\n\nAs styled-components now provides its own types, there's no longer a need for community ones.\n\nGood news for TypeScript enthusiasts – styled-components is now natively written in TypeScript! Even if you haven't used TypeScript before, it's recommended for improving the reliability of your project as it can alert you when you're using an unknown prop or if a prop has a different value than expected.\n\nHowever, if you don't use TypeScript in your project, don't worry! IDEs like VS Code will still pick up the types and provide hints as you write your code.\n\nis no longer provided by default\n\nIf haven't migrated your styling to use transient props ( ), you might notice React warnings about styling props getting through to the DOM in v6. To restore the v5 behavior, use :\n\nAs the web and browsers have matured significantly by 2023, vendor prefixing is often unnecessary. Therefore, for the v6 release, we've decided to omit automatic prefixing by default to reduce the amount of CSS delivered to a page. If you prefer the v5 behavior, you can restore it via :\n\nTo accommodate this change, the original prop was inverted to ; if you have set, you can now remove it as it's the new default.\n\nstyled-components v6 uses the newer stylis v4; if you are providing to , ensure the plugins are up-to-date. For instance, released a new version to support the updated stylis.\n\nWith the stylis v4 upgrade came a change to how nested selectors are handled which now correctly mirrors browser behavior. Specifically, pseudoselectors (e.g. ) that do not start with will not have the ampersand implicitly added anymore.\n\nTransient and props have been dropped\n\nTo reduce confusion around application order, we've dropped the transient and props. Please use the regular and props instead.\n\nThis change has been a long time coming. The API is no longer supported, so please use the prop instead. You can specify at definition time via or at runtime:\n\nIn line with the maintenance schedule for Node, we now support v16 as the oldest runtime that's still receiving security patches.\n\nWhat do I need to do to migrate to v5?\n\nIf you're using React Native, you'll need at least v0.59 (the first version to support hooks.)\n\nstyled-components v5 does not introduce any breaking public API changes, and adds the following:\n• Total rewrite of the core stylesheet engine, tuned for performance\n• \n• \n• try it with for your bidi needs!\n\nCheck out the official announcement post for more information and to learn about what went into v5!\n\nAt this time we do not recommend using within cGS due to some issues with how browsers process via the CSSOM APIs. Instead it's best to place these in your core file (generated or static) within a typical tag.\n\nWhat do I need to do to migrate to v4?\n\nThis is a pretty big release with lots of changes both under the hood and at the API level. As the beta progresses, we will try to release codemods to make the items below simpler. Also, if you find any issues with the steps below, please leave constructive feedback!\n• Make sure your application is using >= 16.3; internally we are using the new API and new context APIs if you wish to try and polyfill for older React version support\n• If you are using the API, switch your components to use instead.\n\nA codemod is available to expedite this.\n\nSee the \"extending styles\" documentation for more examples.\n• If you were using the API to add global styles to your page, use the new helper component instead.\n\nA codemod is available to expedite this.\n\nSee the documentation for to see all the cool stuff you can do with it that wasn't possible before with !\n• If you were using the prop, change it to a normal .\n• If you're using the component in a partial without the helper, you'll need to use the helper now. In general, always use the css helper when composing styling partials to be interpolated into a styled component.\n• If you're using and some of the attributes you pass to it is a Function, it's recommended to switch to the new syntax instead for easier and more powerful composition.\n• If you're using TypeScript, the typings are now located in DefinitelyTyped:\n\nThat's it! Aside from migrating, we also highly recommend reading up on the new which is intended to replace the in the future.\n\nYes: nesting is a feature intentionally ported from Sass. Used sparingly it's a great way to lighten your code by reducing the need to create explicit classes for every element.\n\nIt can also be used by parent components to define contextual constraints that aren't properly a concern of the affected children:\n\nIt's also incredibly convenient to co-locate media queries, since we can see at a glance exactly how the component will respond at any resolution.\n\nIntegrating an existing CSS framework with styled-components is really easy! You can use its existing class names alongside your components.\n\nFor example, imagine you have an existing app with two classes you want to use again: and . If you want the class to always be attached to the component, you should use the method to attach it. If you want to attach it only in some cases you can use the props like you always have!\n\nIf the framework has a bunch of raw global CSS that needs to be included on the page, you can add it using the API. This is also useful for things like CSS resets.\n\nHow can I override styles with higher specificity?\n\nThe way to override styles with a high specificity is to simply increase the specificity of your own styles. This could be done using , but that's error prone and generally not a good idea.\n\nWe recommend the following technique:\n\nEach gets replaced with the generated class, so the injected CSS then looks like this:\n\nThe repeated class bumps the specificity high enough to override the source order without being very tedious to write!\n\nInline styles will always take precedence over external CSS, so you cannot override it by simply increasing specificity.\n\nThere is a neat trick however, which is to use the style CSS Selector in conjunction with :\n\nWhy do my DOM nodes have two classes?\n\nEach node actually has two classes connected to it: one is static per component, meaning each element of a styled component has this class. It hasn't any style attached to it. Instead, it's used to quickly identify which styled component a DOM objects belongs to or to make minor changes in the DevTools. It's also used for component selectors. The static class probably will look something like: .\n\nThe other is dynamic, meaning it will be different for every element of your styled component with different props, based on what the interpolations result in. It will probably look like (note the lack of \"sc\" prefix.)\n\nFor example, the styled component would render with the same static class every time. If the styles are changed using interpolations, like , then the dynamic class will be a different one, while the static class would remain the same.\n\nWhen to use attrs?\n\nYou can pass in attributes to styled components using attrs, but it is not always sensible to do so.\n\nThe rule of thumb is to use when you want every instance of a styled component to have that prop, and pass props directly when every instance needs a different one:\n\nThe same goes for props that can be inferred based on the \"mode\" of another prop. In this case you can set a property on to a function that computes that prop based on other props.\n\nI am a library author. Should I bundle with my library?\n\nIf you are a library author, we recommend that you should not bundle and ship module with your library. There are two steps that you need to do to achieve this:\n• Marking as external in your package dependencies\n\nMarking as external in your package dependencies\n\nTo do this, you will need to move it from to and include it in the list in your file:\n\nMoving to will guarantee that it wouldn't be installed along with your library ( or will ignore when a library is installed).\n\nAdding to will signal your library consumers that is not included with the library and they need to install it themselves.\n\nAlso, note that in the section the version string has been made a more permissive . This allows future versions of styled-components to work automatically and you can simply narrow the range with a patch update to your library if a breaking change is eventually added.\n\nIf you are bundling your library before shipping it, make sure that you are not bundling along with it. Here are some examples of how to do this with some popular module bundling tools:\n\nIf you are using Microbundle, it will handle this step automatically. Microbundle treats every dependency in the list as external and excludes it from the build for you.\n\nIf you are using Rollup.js, you should provide an option in your config:\n\nAnother approach is to use the rollup-plugin-peer-deps-external plugin which will automatically add the in the option array for you.\n\nIf you are using Webpack, you should provide an option in your config:\n\nWhy am I getting a warning about several instances of module on the page?\n\nIf you are seeing a warning message in the console like the one below, you probably have several instances of initialized on the page.\n\nThis may cause dynamic styles not working properly or even errors during rehydration if you are using server-side rendering.\n\nThere are several common reasons for this to happen:\n• You have several applications that are using running on the same page (e.g., several entry points in webpack are loaded on the same page)\n• You have another library somewhere in your dependencies\n• You have a monorepo structure for your project (e.g, lerna, yarn workspaces) and module is a dependency in more than one package (this one is more or less the same as the previous one)\n\nIf you have several applications running on one page, consider using one module for all of them. If you are using webpack, you can use CommonsChunkPlugin to create an explicit vendor chunk, that will contain the module:\n\nIf you think that the issue is in duplicated module somewhere in your dependencies, there are several ways to check this. You can use , or commands in your application folder.\n\nIf none of these commands identified the duplication, try analyzing your bundle for multiple instances of . You can just check your bundle source, or use a tool like source-map-explorer or webpack-bundle-analyzer.\n\nIf you identified that duplication is the issue that you are encountering there are several things you can try to solve it:\n\nIf you are using you can try running . This command searches the local dependencies and tries to simplify the structure by moving common dependencies further up the tree.\n\nIf you are using webpack, you can change the way it will resolve the module. You can overwrite the default order in which webpack will look for your dependencies and make your application more prioritized than default node module resolution order:\n\nOne possible fix to get styled-components to run in a Lerna monorepo across packages, is to hoist shared dependencies to the root of your monorepo file. Try running the bootstrap option with the --hoist flag.\n\nAlternatively, you can remove from your file and hoist it manually to your top-level package.json file.\n\nExample of a package.json file in a Lerna root folder\n\nWhy should I avoid declaring styled components in the render method?\n\nBy declaring a styled component inside the render method of a react component, you are dynamically creating a new component on every render. This means that React will have to discard and re-calculate that part of the DOM subtree on each subsequent render, instead of just calculating the difference of what changed between them. This leads to performance bottlenecks and unpredictable behavior.\n\nWhy am I getting HTML attribute warnings?\n\nThe warning message below indicates that non-standard attributes are being attached to HTML DOM elements such as or . If you are seeing this warning message, it is likely that you or a library you are using is attaching props as attributes to HTML DOM elements.\n\nIf you're seeing this warning you are probably passing where would be appropriate. It's likely that this comes from a property, or from a completely unrelated prop that you're passing to a component.\n\nTo learn more about how props are passed, see this section.\n\nReact will warn on non-standard attributes being attached such as \"red\" and \"text\", which are not valid HTML attributes for the element.\n\nTo fix this, you can use transient props or destructure props:\n\nYou can use transient props to fix this:\n\nIf you use a version < 5.1 or if you can't use transient props, you can use argument destructuring to pull out those known styling props:\n\nWhen you use argument destructuring, any variables pulled out of the props object will not be included when spread-applying the remaining props ( );\n\nstyled-components supports the same set of browsers as the current React version.\n\nEvergreen browsers include Chrome and Firefox (and derivatives) as they can be updated regardless of operating system version. Edge and Safari should both also work fine since all versions for the last several years support the relevant APIs.\n\nHow do I use styled-components with ?\n\nThe basic functionality of the library should work out of the box like any other library.\n\nHowever, if you want to do server-side rendering or take advantage of some of the advanced capabilities of the styled-components babel plugin without ejecting you'll need to set up and .\n\nHow can I fix issues when using or ?\n\nLocal linking can be a useful tool to co-develop projects simultaneously. However, it creates chaotic situations with libraries that are meant to be used as singletons like react and styled-components since each of your local projects likely has a full set of development dependencies downloaded (and bundlers prefer local versions of dependencies by default.)\n\nThe solution is to add aliasing. Here's an example config for webpack:\n\nThis ensures that for your build the same copy of the library will always be used, even across symlinked projects.\n\nIf you are using the function on a project with linked components you will end up in a complex scenario. Basically what's happening is that because of v4 new static context API different styled-component modules are now managing their own list of styled-components to render, from the host app it appears as though there's nothing to extract because no styled components have been created in that scope they were created from the linked package scope.\n\nHow do I solve it?\n\nOne solution is to add an alias to the module path resolution to always point to the 'host' application. Hopefully there are a bunch of libraries to do that we will use for this example . At the very top of your SSR index file add:\n\nThis will tell node to resolve all import/require's of styled-components to\n\nHow do I fix flickering text after server side rendering?\n\nWhen using global styling APIs like or the former , adding and removing certain styles from the DOM like definitions can cause momentary flickering of text on the page. This typically happens during the rehydration phase of server-side rendering. We're still tweaking how these behaviors work to avoid the issue long-term.\n\nHowever, there is a CSS solution to the problem in the CSS rule. By setting the rule to \"fallback\" mode, once a font has been loaded it will not be reloaded. This eliminates the flicker.\n\nIf you're getting the error message:\n\nIn a React Native project using TypeScript, it is because you need to add ."
    },
    {
        "link": "https://stackoverflow.com/questions/47077210/using-styled-components-with-props-and-typescript",
        "document": "This answer is outdated, the most current answer is here: https://stackoverflow.com/a/52045733/1053772\n\nAs far as I can tell there is no official way (yet?) to do this, but you can solve it with a bit of trickery. First, create a file with the following content:\n\nNow, inside your files, use it like this:\n\nAnd you should be good to go. It's definitely not ideal and hopefully there will be a way to provide generics to template literals soon in TS, but I guess that for now this is your best option.\n\nCredit is given where credit is due: I copypasted this from here"
    },
    {
        "link": "https://medium.com/bungalow-garage/adopting-styled-components-with-typescript-in-react-native-c57078cd818f",
        "document": "In the past year I’ve gained exposure to React Native, before briefly being exposed to React for the web. As a mobile developer, I didn’t stay in the React web world for too long, but one of the lasting impressions on me was the use of styled-components vs React Native’s more ubiquitous StyleSheet library. Recently my mobile lead at Bungalow and I have been integrating it into the codebase, while trying to figure out an optimal way to use it in Typescript. We were previously already using StyleSheet, so we’re taking an iterative approach to it — mostly on new features. Most of the examples we’ve found along the way have been in Javascript. So we thought it would be a good idea to share some knowledge about how we use styled components in Typescript. There are a few gotchas or alternative ways you can implement it — like in most languages, and Typescript is no different. So I’ll try to address some of those along the way.\n\nFirst up, the official docs describes how to integrate it, so we’ll skip that part. This will focus less on how to set up and use , and more of how we use it at Bungalow, and how to use it in Typescript. To give credit where it’s due, they touch on Typescript a little bit. But we use a growing amount of functional components, and there’s not much in their docs apart from one simple example. So I’m going to continue on their good work and expand on that example a little bit. The example they give is one of a component, which has the following attributes: First of all, let’s do 2 things:\n• Replace that tag with something more aligned to React Native. If this looks like more code, it’s because I’ve included the import statements and exported the component to help make this more of a complete example, as if this belonged in a real file somewhere in your directory named . We’re not using the hypothetical theme they have for padding and colors yet, , but we’ll get back to that below. We’ve removed the attribute for because we don’t need that anymore.\n• We don’t need that because we’re declaring our styled components to be composed within our main component, rather than the opposite approach in the original example of wrapping around the container component.\n• This way we can use many styled components in our exportable component, and we also want to continue to use styled with the same advantages that StyleSheet offers — to abstract all of the styling out of our JSX. What about retaining for testing? Because we’re taking care of the styles internally to the module, I assume the original example was using for automated tests or analytics. Removing still checks out if we instead inherit most of our interfaces from , which includes the attribute we can use in place of . Got to love Typescript.\n\nA major appeal about styled is how much it cleans up the detail in your main JSX component. If we decided we’d like an with a margin of 10 px smaller vertically and horizontally to the outer box dimensions, we just create another style based on and simply nest the style tag within the style tag: Back to addressing our padding values from . We can spread out props into the sytled component via , instead of explicitly setting them via individual attributes like . Notice that the attribute is still able to be set from a value in our prop, just like in the original example. You may also be able to use props when styling StyleSheet with a simple arrow function, but it seems more inline with Typescript to use type assertion via , to let the styled component know what properties it can expect. This is immensely convenient. If you’re a good advocate of atomic design, you can ensure that a particular style only gets what it needs. Say for example if our was quite extensive, perhaps it has some animation values, rounded corners, border thickness, background and gradient colors, etc. The individual may not need to access all of that, it may only need the background color. The example below takes our component to the extreme to demonstrate this: Alternatively, because shares props with the main component’s interface, we could just define the shared props in and inherit from there instead of .\n\nWhen using StyleSheet, we found that a lot of our props were for the actual style. Therefore we used a lot to define default values. Now that we use styled components, it’s reduced the need for it a lot — our are now just used exclusively for anything related to a component, instead of the styles that a component uses. Because we can now reference props right from within our styles, we use default values right in line with those style definitions. Say for example, if we wanted our to set to a default color based on the theme. But also allow the owning component to set it to a color of its choice if it wanted to. With the previous modifications, we can do that by using the prop on the public interface, and the prop will be passed into the style via the spread. We’ve set our default to transparent. We’ve also set some default values for width, height, and padding. Alternatively, you can still use exactly the same way to how you’d regularly use it with a functional component, and it can simplify your inline conditionals within the actual styled component: Our component can now simply be customized by setting these props (or just the theme prop, seeing as the remaining attributes are optional) like so:\n\nI touched on using inheritance above, in regards to how we define our interfaces. But we can also apply it to overall styled components. A lot of react projects have a typography file (or a theme interface) to specify their font attributes. Bungalow is no different. Let’s say that you have a base font style that you want to set up for related components. At Bungalow we’ve been defining our font styles that apply to our theme in one file, that exports styled-components. We have one overall style that defines basic attributes that are common enough to be used in all labels. Then we inherit this style from our H1 to H6 styles that we define (or any other styles that need it) This isn’t exactly what we have, but this is a simplified example that builds on the context of the examples above:"
    }
]