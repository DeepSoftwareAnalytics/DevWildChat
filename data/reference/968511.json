[
    {
        "link": "https://defold.com/manuals/lua",
        "document": "Getting Started - Introduction - Installing Defold - Glossary - Defold for Flash users - Getting help Project Setup - Creating a project - Project settings - Sharing projects Editor - Overview - Code editor - Custom project templates - Editor scripts - Editor scripts: UI - Debugger - Keyboard shortcuts - Preferences - Refactoring - Styling Core Concepts - Building blocks - Addressing - Message passing - Application lifecycle Assets and Resources - Importing assets - Caching assets - Importing 2D graphics - Importing 3D models - Adapting to different screen sizes - Live update - Atlas - Buffer - Font - Runtime TTF Font - Resource management - Tile source - Texture filtering - Texture compression Animations - Overview - Flipbook Animation - Model animation - Property animation (tweens) - Rive animation - Spine animation Components - Overview - Collection factory - Collection proxy - Collision object - Camera - Factory - Label - Mesh - Model - Particle FX - Rive - Sound - Spine - Sprite - Tilemap GUI - GUI overview - Box nodes - Text nodes - Pie nodes - Spine nodes - ParticleFX nodes - Template nodes - Scripts - Clipping - Layouts Physics - Physics overview - Collision objects - Collision shapes - Collision groups - Collision messages - Collision events listener - Resolving collisions - Ray casts - Joints and constraints Sound - Sound - Sound Streaming - FMOD Input - Overview - Key and text input - Mouse and touch - Gamepads Game logic - Scripts - Properties - Script properties - Lua in Defold - Source code obfuscation - Modules - Debugging - Writing code Files - Working with files Network Connections - Overview - HTTP Requests - Socket connections - WebSocket connections - Online services Rendering - Render - Material - Compute - Shader - Texture filtering Workflow - Application security - Bundling an application - Caching assets - Command line tools - Hot reloading - Porting guidelines - Refactoring - The mobile dev app - Version control - Writing code - Working offline Debugging - Debugging game logic - Debugging native code - Debugging native code on Android - Debugging native code on iOS - Reading game and system logs Optimization - Optimizing an application - Optimize game size - Optimize runtime performance - Optimize battery usage - Optimize memory usage - Profiling Monetization - Ads - In-app purchases Android - Introduction - Advertising Info - AdMob ads - Android Device Performance Framework - App review and ratings - Camera - Facebook - Firebase Analytics - Firebase Remote Config - Google Play Game Services - Google Play Instant - Inter-app communication - IronSource ad mediation - Push notifications - Safe Area - Webview - The mobile dev app iOS - Introduction - Advertising Info - AdMob ads - App review and ratings - Camera - Facebook - Firebase Analytics - Firebase Remote Config - Inter-app communication - IronSource ad mediation - Push notifications - Safe Area - Webview - The mobile dev app Consoles - Nintendo Switch - PlayStation®4 - PlayStation®5 - Microsoft Xbox HTML5 - Introduction - CrazyGames - Facebook - Facebook Instant Games - Poki Desktop - Linux - macOS - Windows Engine extensions - Introduction - Defold SDK - Gradle dependencies - Cocoapod dependencies - Adding auto-complete definition - Best Practices - Debugging - Extension Manifests - App Manifests - Manifest Merging - The Lua C API (external) - Setup local build server - Available Docker images to run Extender\n\nThe Defold engine has the Lua language embedded for scripting. Lua is a lightweight dynamic language that is powerful, fast, and easy to embed. It is widely used as a videogame scripting language. Lua programs are written in a simple procedural syntax. The language is dynamically typed and is run by a bytecode interpreter. It features automatic memory management with incremental garbage collection.\n\nThis manual will give a quick introduction to the basics of Lua programming in general and what you need to consider when working with Lua in Defold. If you have some experience with Python, Perl, Ruby, Javascript, or a similar dynamic language you will get going pretty quickly. If you are new to programming you might want to start with a Lua book aimed at beginners. There are plenty to choose from.\n\nDefold uses LuaJIT, a highly optimized version of Lua suitable for use in games and other performance-critical software. It is fully upwards compatible with Lua 5.1 and supports all standard Lua library functions and the full set of Lua/C API functions.\n\nLuaJIT also adds several language extensions and some Lua 5.2 and 5.3 features.\n\nWe aim to keep Defold the same across all platforms, but we currently have a few minor discrepancies in the Lua language version between platforms:\n• iOS does not allow JIT compilation.\n• Nintendo Switch does not allow JIT compilation.\n• HTML5 uses Lua 5.1.4 instead of LuaJIT.\n\nDefold includes all of the Lua 5.1 standard libraries as well as a socket and a bit operation library:\n\nAll libraries are documented in the reference API documentation.\n• Programming in Lua (first edition) Later editions are available in print.\n• Programming in Lua - Programming in Lua is the official book about the language, providing a solid base to any programmer who wants to use Lua. Authored by Roberto Ierusalimschy, the chief architect of the language.\n• Lua programming gems - This collection of articles records some of the existing wisdom and practice on how to program well in Lua.\n• Lua 5.1 reference manual - Also available online (see above)\n\nPrograms have simple, easy-to-read syntax. Statements are written one on each line and there is no need to mark the end of a statement. You can optionally use semicolons to separate statements. Blocks of code are keyword delimited, ending with the keyword. Comments can be either written in a block or until the end of the line:\n\nLua is dynamically typed, meaning variables do not have types, but values do. Unlike in statically typed languages, you can assign any value to any variable as you like.\n\nThere are eight basic types in Lua:\n\nLua provides the usual set of flow control constructs.\n\nAll variables that you declare are by default global, meaning that they are available through all parts of the Lua runtime context. You can explicitly declare variables , meaning that the variable will only exist within the current scope.\n\nEach Lua source file defines a separate scope. Local declarations on the topmost level in a file mean the variable is local to the Lua script file. Each function creates another nested scope and each control structure block creates additional scopes. You can explicitly create a scope with the and keywords. Lua is lexically scoped, meaning that a scope has full access to local variables from the enclosing scope. Note that the local variables must be declared before their use.\n\nNote that if you declare functions in a script file (which is generally a good idea) you need to watch out how you order the code. You can use forward declarations if you have functions that mutually call each other.\n\nIf you write a function enclosed in another function, it too has full access to local variables from the enclosing function. This is a very powerful construct.\n\nLocal variables declared in a block will shadow variables from a surrounding block with the same name.\n\nFunctions execute from beginning to end and there is no way to stop them midway through. Coroutines allow you to do that, which can be very convenient in some cases. Suppose we want to create a very specific frame-by-frame animation where we move a game object from y position to some very specific y positions from frame 1 to frame 5. We could solve that with a counter in the function (see below) and a list of the positions. However, with a coroutine, we get a very clean implementation that is easy to extend and work with. All state is contained within the coroutine itself.\n\nWhen a coroutine yields it returns control back to the caller but remembers its execution point so it can continue from there later on.\n\nAll variables that you declare are by default global, meaning that they are available through all parts of the Lua runtime context. Defold has a setting shared_state setting in game.project that controls this context. If the option is set, all scripts, GUI scripts, and the render script are evaluated in the same Lua context and global variables are visible everywhere. If the option is not set, the engine executes scripts, GUI scripts, and the render script in separate contexts.\n\nDefold allows you to use the same script file in several separate game object components. Any locally declared variables are shared between components that run the same script file.\n\nIn a high-performance game that is intended to run at a smooth 60 FPS small performance mistakes can have a large impact on the experience. There are some simple general things to consider and some things that might not seem problematic.\n\nBeginning with the simple things. It is generally a good idea to write straightforward code that does not contain unnecessary loops. Sometimes you do need to iterate over lists of things, but be careful if the list of things is sufficiently large. This example runs in slightly over 1 millisecond on a pretty decent laptop, which can make all the difference if each frame is only 16 milliseconds long (at 60 FPS) and with the engine, render script, physics simulation, and so forth eating up a chunk of that.\n\nUse the value returned from (seconds since system epoch) to benchmark suspect code.\n\nLua’s garbage collection runs automatically in the background by default and reclaims memory that the Lua runtime has allocated. Collecting lots of garbage can be a time-consuming task so it is good to keep down the number of objects that need to be garbage collected:\n• Local variables are in themselves free and will not generate garbage. (i.e. )\n• Each new unique string creates a new object. Writing will create a new object and assign to it. The local itself will not generate garbage, but the string object will. Using the same string multiple times adds no additional memory cost.\n• Each time a table constructor is executed ( ) a new table is created.\n• Vararg functions ( ) create a table for the ellipsis each time the function is called (in Lua before version 5.2, or if not using LuaJIT).\n\nThere are many cases where you can avoid creating new objects and instead reuse the ones you already have. For example. The following is common at the end of each :\n\nIt’s easy to forget that each call to creates a new object. Let’s find out how much memory one uses:\n\n70 bytes has been added between the calls to , but this includes allocations for more than the object. Each printing of the result from builds a string which in itself adds 22 bytes of garbage:\n\nSo a weighs in at 70-22=48 bytes. That is not much, but if you create one each frame in a 60 FPS game it’s suddenly 2.8 kB of garbage per second. With 360 script components that each create one every frame we’re looking at 1 MB of garbage generated per second. The numbers can add up very quickly. When the Lua runtime collects garbage it may eat up many precious milliseconds—especially on mobile platforms.\n\nOne way to avoid allocations is to create a and then keep working with the same object. For instance, to reset a we can use the following construct:\n\nThe default garbage-collecting scheme may not be optimal for some time-critical applications. If you see a stutter in your game or app, you might want to tune how Lua collects garbage through the Lua function. You can, for instance, run the collector for a short time every frame with a low value. To get an idea how much memory your game or app is eating, you can print the current amount of garbage bytes with:\n\nA common implementation design consideration is how to structure code for shared behaviors. Several approaches are possible."
    },
    {
        "link": "https://defold.com/ref/go",
        "document": "This is a callback-function, which is called by the engine when a script component is finalized (destroyed). It can be used to e.g. take some last action, report the finalization to other game object instances, delete spawned objects or release user input focus (see release_input_focus).\n\nThis is a callback-function, which is called by the engine at fixed intervals to update the state of a script component. The function will be called if 'Fixed Update Frequency' is enabled in the Engine section of game.project. It can for instance be used to update game logic with the physics simulation if using a fixed timestep for the physics (enabled by ticking 'Use Fixed Timestep' in the Physics section of game.project).\n\nThis is only supported for numerical properties. If the node property is already being animated, that animation will be canceled and replaced by the new one. If a (lua function) is specified, that function will be called when the animation has completed. By starting a new animation in that function, several animations can be sequenced together. See the examples for more information. If you call from a game object's function, any passed will be ignored and never called upon animation completion. See the properties guide for which properties can be animated and the animation guide for how them.\n\nAnimate the position of a game object to x = 10 during 1 second, then y = 20 during 1 second:Animate the y position of a game object using a crazy custom easing curve:\n\nBy calling this function, all or specified stored property animations of the game object or component will be canceled. See the properties guide for which properties can be animated and the animation guide for how to animate them.\n\nCancel the animation of the position of a game object:Cancel all property animations of the current game object:Cancel all property animations of the sprite component of the current game object:\n\nDelete one or more game objects identified by id. Deletion is asynchronous meaning that the game object(s) are scheduled for deletion which will happen at the end of the current frame. Note that game objects scheduled for deletion will be counted against in \"game.project\" until they are actually removed. Deleting a game object containing a particle FX component emitting particles will not immediately stop the particle FX from emitting particles. You need to manually stop the particle FX using . Deleting a game object containing a sound component that is playing will not immediately stop the sound from playing. You need to manually stop the sound using .\n\nThis example demonstrates how to delete game objectsThis example demonstrates how to delete a game objects and their children (child to parent order)\n\ncheck if the specified game object exists\n\ngets a named property of the specified game object or component\n\nReturns or constructs an instance identifier. The instance id is a hash of the absolute path to the instance.\n• If is specified, it can either be absolute or relative to the instance of the calling script.\n• If is not specified, the id of the game object instance the script is attached to will be returned.\n\nFor the instance with path, the following calls are equivalent:\n\nGet the parent for a game object instance.\n\nGet parent of the instance containing the calling script:Get parent of the instance with id \"x\":\n\nThe position is relative the parent (if any). Use go.get_world_position to retrieve the global world position.\n\nGet the position of the game object instance the script is attached to:Get the position of another game object instance \"my_gameobject\":\n\nThe rotation is relative to the parent (if any). Use go.get_world_rotation to retrieve the global world rotation.\n\nGet the rotation of the game object instance the script is attached to:Get the rotation of another game object instance with id \"x\":\n\nThe scale is relative the parent (if any). Use go.get_world_scale to retrieve the global world 3D scale factor.\n\nGet the scale of the game object instance the script is attached to:Get the scale of another game object instance with id \"x\":\n\nThe uniform scale is relative the parent (if any). If the underlying scale vector is non-uniform the min element of the vector is returned as the uniform scale factor.\n\nGet the scale of the game object instance the script is attached to:Get the uniform scale of another game object instance with id \"x\":\n\nThe function will return the world position calculated at the end of the previous frame. Use go.get_position to retrieve the position relative to the parent.\n\nGet the world position of the game object instance the script is attached to:Get the world position of another game object instance with id \"x\":\n\nThe function will return the world rotation calculated at the end of the previous frame. Use go.get_rotation to retrieve the rotation relative to the parent.\n\nGet the world rotation of the game object instance the script is attached to:Get the world rotation of another game object instance with id \"x\":\n\nThe function will return the world 3D scale factor calculated at the end of the previous frame. Use go.get_scale to retrieve the 3D scale factor relative to the parent. This vector is derived by decomposing the transformation matrix and should be used with care. For most cases it should be fine to use go.get_world_scale_uniform instead.\n\nGet the world 3D scale of the game object instance the script is attached to:Get the world scale of another game object instance \"x\":\n\nThe function will return the world scale factor calculated at the end of the previous frame. Use go.get_scale_uniform to retrieve the scale factor relative to the parent.\n\nGet the world scale of the game object instance the script is attached to:Get the world scale of another game object instance with id \"x\":\n\nThe function will return the world transform matrix calculated at the end of the previous frame.\n\nGet the world transform of the game object instance the script is attached to:Get the world transform of another game object instance with id \"x\":\n\nThis function defines a property which can then be used in the script through the self-reference. The properties defined this way are automatically exposed in the editor in game objects and collections which use the script. Note that you can only use this function outside any callback-functions like init and update.\n\nThis example demonstrates how to define a property called \"health\" in a script. The health is decreased whenever someone sends a message called \"take_damage\" to the script.\n\nsets a named property of the specified game object or component, or a material constant\n\nSets the parent for a game object instance. This means that the instance will exist in the geometrical space of its parent, like a basic transformation hierarchy or scene graph. If no parent is specified, the instance will be detached from any parent and exist in world space. This function will generate a message. It is not until the message has been processed that the change actually takes effect. This typically happens later in the same frame or the beginning of the next frame. Refer to the manual to learn how messages are processed by the engine.\n\nAttach myself to another instance \"my_parent\":Attach an instance \"my_instance\" to another instance \"my_parent\":Detach an instance \"my_instance\" from its parent (if any):\n\nThe position is relative to the parent (if any). The global world position cannot be manually set.\n\nSet the position of the game object instance the script is attached to:Set the position of another game object instance with id \"x\":\n\nThe rotation is relative to the parent (if any). The global world rotation cannot be manually set.\n\nSet the rotation of the game object instance the script is attached to:Set the rotation of another game object instance with id \"x\":\n\nThe scale factor is relative to the parent (if any). The global world scale factor cannot be manually set. Physics are currently not affected when setting scale from this function.\n\nSet the scale of the game object instance the script is attached to:Set the scale of another game object instance with id \"x\":\n\nThe function uses world transformation calculated at the end of previous frame.\n\nConvert position of \"test\" game object into coordinate space of \"child\" object.\n\nThe function uses world transformation calculated at the end of previous frame.\n\nConvert transformation of \"test\" game object into coordinate space of \"child\" object.\n\nThis is a callback-function, which is called by the engine when a script component is initialized. It can be used to set the initial state of the script.\n\nThis is a callback-function, which is called by the engine when user input is sent to the game object instance of the script. It can be used to take action on the input, e.g. move the instance according to the input. For an instance to obtain user input, it must first acquire input focus through the message . Any instance that has obtained input will be put on top of an input stack. Input is sent to all listeners on the stack until the end of stack is reached, or a listener returns to signal that it wants input to be consumed. See the documentation of acquire_input_focus for more information. The parameter is a table containing data about the input mapped to the . For mapped actions it specifies the value of the input and if it was just pressed or released. Actions are mapped to input in an input_binding-file. Mouse movement is specifically handled and uses as its . The only contains positional parameters in this case, such as x and y of the pointer. Here is a brief description of the available table fields:\n\nThis example demonstrates how a game object instance can be moved as a response to user input.\n\nThis is a callback-function, which is called by the engine whenever a message has been sent to the script component. It can be used to take action on the message, e.g. send a response back to the sender of the message. The parameter is a table containing the message data. If the message is sent from the engine, the documentation of the message specifies which data is supplied.\n\nThis example demonstrates how a game object instance, called \"a\", can communicate with another instance, called \"b\". It is assumed that both script components of the instances has id \"script\". Script of instance \"a\":Script of instance \"b\":\n\nThis is a callback-function, which is called by the engine when the script component is reloaded, e.g. from the editor. It can be used for live development, e.g. to tweak constants or set up the state properly for the instance.\n\nThis example demonstrates how to tweak the speed of a game object instance that is moved on user input.\n\nThis is a callback-function, which is called by the engine every frame to update the state of a script component. It can be used to perform any kind of game related tasks, e.g. moving the game object instance.\n\nThis example demonstrates how to move a game object instance through the script component:\n\nPost this message to a game object instance to make that instance acquire the user input focus. User input is distributed by the engine to every instance that has requested it. The last instance to request focus will receive it first. This means that the scripts in the instance will have first-hand-chance at reacting on user input, possibly consuming it (by returning from ) so that no other instances can react on it. The most common case is for a script to send this message to itself when it needs to respond to user input. A script belonging to an instance which has the user input focus will receive the input actions in its callback function. See on_input for more information on how user input can be handled.\n\nThis example demonstrates how to acquire and act on user input.\n\nThis message disables the receiving component. All components are enabled by default, which means they will receive input, updates and be a part of the simulation. A component is disabled when it receives the message. Components that currently supports this message are:\n\nThis message enables the receiving component. All components are enabled by default, which means they will receive input, updates and be a part of the simulation. A component is disabled when it receives the message. Components that currently supports this message are:\n\nPost this message to an instance to make that instance release the user input focus. See acquire_input_focus for more information on how the user input handling works.\n\nWhen this message is sent to an instance, it sets the parent of that instance. This means that the instance will exist in the geometrical space of its parent, like a basic transformation hierarchy or scene graph. If no parent is specified, the instance will be detached from any parent and exist in world space. A script can send this message to itself to set the parent of its instance.\n\nAttach myself to another instance \"my_parent\":Attach an instance \"my_instance\" to another instance \"my_parent\":Detach an instance \"my_instance\" from its parent (if any):\n\nThe rotation of the game object expressed in Euler angles. Euler angles are specified in degrees in the interval (-360, 360). The type of the property is vector3.\n\nHow to set a game object's rotation with euler angles, either as a vector3 or selecting a specific dimension:\n\nThe position of the game object. The type of the property is vector3.\n\nHow to query a game object's position, either as a vector3 or selecting a specific dimension:\n\nThe rotation of the game object. The type of the property is quaternion.\n\nThe uniform scale of the game object. The type of the property is number."
    },
    {
        "link": "https://github.com/defold/tutorial-movement",
        "document": "This is a tutorial for beginners. It walks you through the steps of creating a player controlled space ship that moves in a natural manner when you give keyboard input. After having completed this tutorial you will know the answers to the following questions:\n• How can you use vectors to represent positions, velocity and acceleration?\n• How do you use this to create a game embryo that you can experiment with and develop further?\n\nIt is assumed that you have basic understanding of physics concepts such as velocity and acceleration. You will also need some basic understanding of Lua programming.\n\nThis project is prepared in advance for you so there is no setup to bother about. Run the game to get an overview of what you have to work with:\n• It include graphics: an animated spaceship and a background.\n• Input is set up for arrow keys and mouse clicks.\n• There is a \"spaceship\" game object that has a script attached to it.\n• The script has code in place to react to player input. Initially, it only prints messages to the console as a reaction to input.\n\nWith the game running, try pressing the arrow buttons, or click in the game window, then check the editor console for input results. Notice that different text is printed in the console depending on which button you pressed:\n\nBefore digging into any details, let's first make a simple experiment and give the spaceship motion.\n\nOpen \"spaceship.script\" and scroll down to the beginning of the function where you find this code:\n\nRemove the line with the statement and edit the code so the beginning of the function instead looks like this:\n\nRun the game again and press the arrow key and see how the spaceship moves up. The code is very simple, but let's look at it line by line to get a proper idea of what's going on:\n\nThe input bindings that are set up in the project (in the file \"/input/game.input_binding\") binds each of the arrow keys to action named \"up\", \"down\", \"left\" and \"right\". The game runs at 60 frames per second and each frame you push , the hashed \"up\" action name is sent to the function. Holding the button down will thus make the code between the statement and the first execute 60 times each second.\n\nThe function gets the position of a game object. Since the function is called without any arguments, the position of the current game object is returned. This code belongs to the spaceship game object so the position of the spaceship is returned.\n\nThe position is assigned to a local variable called so it is possible to manipulate it. The position object is a , which is a vector that holds three values.\n\nThe object in describes a point in 3D space, consisting of an X coordinate, an Y coordinate and a Z coordinate. Since pressing the button should move the ship in the positive direction of the Y axis, the component of the position is increased by 1.\n\nFinally, the new changed position value is written back to the current game object.\n\nBefore moving on, try changing the value added to from 1 to 5 and run the game again. Notice how the ship now moves much faster.\n\nFinally, add a line below to print the value of :\n\nRun the game again and see how the engine print the value of the position vector each frame. Notice that the second value of the vector changes as the spaceship moves:\n\nA vector is a mathematical entity that has a direction and a magnitude (length). A vector describes a specific point in a vector space. In practice, a vector consists of a set of numbers that give the coordinates to the point. In a two dimensional space (a plane), two numbers are necessary to describe vectors: one value for the X axis and one for the Y axis:\n\nIn a three dimensional space, you need three numbers: one for the X axis, one for the Y axis and one for the Z axis:\n\nThe magnitude, or length, of a vector v is calculated using the Pythagorean theorum:\n\nEven though Defold has a toolset tailored for 2D games, the engine is truly a 3D engine. All game objects and components are positioned in 3D space with positions expressed as objects. When you view your game in 2D, the X and Y value determine the position of an object along the \"width\" and \"height\" axis, and the Z position determines the position along the \"depth\" axis. The Z position allows you to control the visibility of overlapping objects: a sprite with a Z value of 1 will appear in front of a sprite at Z position 0. By default, Defold uses a coordinate system allowing Z values between -1 and 1:\n\nThe Defold Lua library contains functions to create and manipulate objects:\n\nVectors in higher dimensions than 3 are also possible. Defold uses objects with four components to encode colors. The first three components give the amount of red, green, and blue, and the last component give the amount of translucency, also called \"alpha\".\n\nIn everyday life you are used to do arithmetic with scalar values, real numbers that describe points on the number line. We use scalars to mean many different things. The number 12 could mean a number of meters, kilograms, pounds, seconds, meters per second, volts or dollars. The same is true for vectors. You have already seen how vectors can be used to describe a position of an object. They are also very good for describing an object's motion through space.\n\nTo describe motion on a computer screen (a 2D plane) you need two values: The speed along the X axis and the speed along the Y axis. You can very well use two separate scalar values and add the speed values to the X and Y positions separately:\n\nThis is roughly what you did when you previously made the spaceship move upwards, and there is nothing wrong calculating motion like this. Vectors, however, allow you to express motion clearer and more concise. Since a vector describe a direction and a magnitude they are an intuitive fit for motion: the direction of the vector equals the direction of motion, and the magnitude describes the amount of motion:\n\nAs long as the and values are expressed as vectors in the same space you can add and subtract them, and scale them by multiplying them with scalar values. These operations are a central part of vector algebra.\n\nVector algebra defines mathematical operations on vectors. Beginning with the simplest, negation, addition and subtraction.\n\nNegation : Negating a vector v, denoted by -v, negates each component of the vector. This makes a vector that points in the opposite direction of the original vector, with the same magnitude:\n\nAddition : Adding vector u to vector v, denoted by u + v, adds each component of u to v. The result is a new vector:\n\nVectors are often drawn displaced from the coordinate system which brings clarity to the operations:\n\nSubtraction : Subtracting vector v from vector u, denoted by u - v, is equal to adding the negation of v to u. So u - v = u + (-v):\n\nMultiplication with scalar : Multiplying a vector v with a real number r produces a new vector with the magnitude scaled: the vector is streched out by a factor r. Multiplying with a negative r flips the orientation 180 degrees:\n\nThese were the basic operations on vectors that you will use all the time. In addition, there are two special operations that come in handy if you, for instance, want to check if two vectors are parallel or at right angles of each other:\n\nDot product : The dot product of two vectors u and v, denoted by u ∙ v, is a scalar value. It is defined as:\n• ‖u‖ is the magnitude of vector u.\n• ‖v‖ is the magnitude of vector v.\n• θ is the angle between the vectors.\n\nIf the vectors are orthogonal (the angle between them is 90 degrees), then the dot product is zero.\n\nCross product : The cross product of two vectors u and v, denoted by u × v, is a vector that is perpendicular to both u and v:\n\nThe resulting vector is a zero vector if:\n• Either one or both of the input vectors are zero vectors, (u = 0 or v = 0)\n• The two input vectors are parallel (θ = 0°)\n• The two input vectors are antiparallel (θ = 180°)\n\nUsing vector algebra, you can now rewrite the spaceship's movement in a straightforward way.\n\nOpen \"spaceship.script\" and modify the , and functions:\n• Create a new zero for storing the input direction. It is placed it in the current script instance ( ) so it can be used throughout the lifetime of the spaceship game object.\n• Retrieve the position of the current game object (the spaceship). The position is a .\n• Set the position of the current game object to plus the movement vector.\n• Zero the input vector. The function is called each frame before and has the responsibility to set the input vector.\n• Set the x or y component of the input vector depending on player input. If the player presses and at the same time, the function will be called twice and both components are set, resulting in a diagonal input direction.\n\nThere are two issues with this code:\n\nFirst, the input vector has length 1 if you move vertically or horizontally, but diagonally the length is 1.4142 (square root of 2) so diagonal movement is faster. You probably don't want that.\n\nSecond, the units of velocity is expressed in pixels/frame, no matter the frame length. It's set to 3 pixels of movement each frame (or about 4.2 diagonally). To make the ship go faster, change the 3 to a higher value. If you want it to go slower, decrease the value. It would be better if you could express velocity in pixels/second.\n\nThe first problem is easy to fix, just normalize the input vector so the input length is always 1:\n• If the squared length of the input vector is larger than 1, normalize the vector so it is of magnitude 1. Compare against square length since it's faster than comparing against length.\n\nThe second problem requires the use of a time step value.\n\nEach frame the Defold engine calls the function of each script. A Defold game usually runs at 60 frames per second, so each frame is 0.016666 seconds long. That is the time elapsed between each call to . A velocity vector with a magnitude of 3 will then represent a speed of 3 * 60 = 180 pixels per second (with the regular render script), as long as there really are 60 frames each second. What would happen if there, for whatever reason, is a hitch in the framerate? With the current code movement will be uneven and unpredictable.\n\nWorking with pixels per second allows you to use variable framerate properly, you would also be able to measure your game with a stopwatch and reason about distances and timings in a better way.\n\nDefold provides a time step argument value to the function. The argument is usually called (for \"delta time\") and its value is the number of seconds that elapsed since the last frame. If you scale velocity against you will get proper units:\n• The velocity is now 150 pixels per second. The screen is 1280 pixels wide so it should take the ship 8.53 seconds to fly across. You can check that with a stopwatch.\n\nRun the game again and try the movement code. At this stage it works but it's stiff and not very dynamic. To give a sense of weight to the spaceship a good way is to have the player's input control movement by altering acceleration instead of the velocity.\n\nIn the above code, velocity was set to a constant value, meaning that the resulting movement, or translation, of the velocity acting over the time step ( ) could be calculated by multiplying the velocity with the time step: movement = velocity * dt, or the orange area in the following diagram:\n\nAcceleration defines how fast something changes speed and direction. The acceleration is acting over the frame time step ( ) and then added to the velocity. The velocity acts over the frame and the resulting movement is added to the position. Since velocity changes over time the movement has to be calculated as the area under a curve. In mathematics, this is called integration over time.\n\nWith a small enough time step a good geometric approximation of the area can be calculated by assuming that the acceleration acting between v0 and v1 is constant, meaning that the velocity changes linearly between the two points. By that assumption v1 can be calculated as v0 + acceleration * dt and the resulting movement becomes:\n\nYou can now write the final code for and (the code for is kept as is):\n• Acceleration is set to 200 pixels per second in the direction of player input.\n• v0 is set to the velocity from the previous time step.\n• v1 is v0 plus the change of velocity this time step.\n• Calculate how much the ship shall move this time step.\n• Store the v1 velocity so it can be used in next time step.\n\nNow it's time to take your new heavy spaceship for a spin.\n\nCongratulations! You have completed the tutorial. But don't stop here. to continue experimenting with the code.\n\nHere are some ideas what you can try:\n• Make the spaceship bounce off the edges of the screen.\n• Allow mouse clicks to dictate the input direction.\n\nCheck out the documentation pages for more examples, tutorials, manuals and API docs.\n\nIf you run into trouble, help is available in our forum.\n\nThis project is released under the Creative Commons CC0 1.0 Universal license.\n\nYou’re free to use these assets in any project, personal or commercial. There’s no need to ask permission before using these. Giving attribution is not required, but is greatly appreciated! Full license text"
    },
    {
        "link": "https://defold.com/manuals/render",
        "document": "Getting Started - Introduction - Installing Defold - Glossary - Defold for Flash users - Getting help Project Setup - Creating a project - Project settings - Sharing projects Editor - Overview - Code editor - Custom project templates - Editor scripts - Editor scripts: UI - Debugger - Keyboard shortcuts - Preferences - Refactoring - Styling Core Concepts - Building blocks - Addressing - Message passing - Application lifecycle Assets and Resources - Importing assets - Caching assets - Importing 2D graphics - Importing 3D models - Adapting to different screen sizes - Live update - Atlas - Buffer - Font - Runtime TTF Font - Resource management - Tile source - Texture filtering - Texture compression Animations - Overview - Flipbook Animation - Model animation - Property animation (tweens) - Rive animation - Spine animation Components - Overview - Collection factory - Collection proxy - Collision object - Camera - Factory - Label - Mesh - Model - Particle FX - Rive - Sound - Spine - Sprite - Tilemap GUI - GUI overview - Box nodes - Text nodes - Pie nodes - Spine nodes - ParticleFX nodes - Template nodes - Scripts - Clipping - Layouts Physics - Physics overview - Collision objects - Collision shapes - Collision groups - Collision messages - Collision events listener - Resolving collisions - Ray casts - Joints and constraints Sound - Sound - Sound Streaming - FMOD Input - Overview - Key and text input - Mouse and touch - Gamepads Game logic - Scripts - Properties - Script properties - Lua in Defold - Source code obfuscation - Modules - Debugging - Writing code Files - Working with files Network Connections - Overview - HTTP Requests - Socket connections - WebSocket connections - Online services Rendering - Render - Material - Compute - Shader - Texture filtering Workflow - Application security - Bundling an application - Caching assets - Command line tools - Hot reloading - Porting guidelines - Refactoring - The mobile dev app - Version control - Writing code - Working offline Debugging - Debugging game logic - Debugging native code - Debugging native code on Android - Debugging native code on iOS - Reading game and system logs Optimization - Optimizing an application - Optimize game size - Optimize runtime performance - Optimize battery usage - Optimize memory usage - Profiling Monetization - Ads - In-app purchases Android - Introduction - Advertising Info - AdMob ads - Android Device Performance Framework - App review and ratings - Camera - Facebook - Firebase Analytics - Firebase Remote Config - Google Play Game Services - Google Play Instant - Inter-app communication - IronSource ad mediation - Push notifications - Safe Area - Webview - The mobile dev app iOS - Introduction - Advertising Info - AdMob ads - App review and ratings - Camera - Facebook - Firebase Analytics - Firebase Remote Config - Inter-app communication - IronSource ad mediation - Push notifications - Safe Area - Webview - The mobile dev app Consoles - Nintendo Switch - PlayStation®4 - PlayStation®5 - Microsoft Xbox HTML5 - Introduction - CrazyGames - Facebook - Facebook Instant Games - Poki Desktop - Linux - macOS - Windows Engine extensions - Introduction - Defold SDK - Gradle dependencies - Cocoapod dependencies - Adding auto-complete definition - Best Practices - Debugging - Extension Manifests - App Manifests - Manifest Merging - The Lua C API (external) - Setup local build server - Available Docker images to run Extender\n\nEvery object that is shown on screen by the engine: sprites, models, tiles, particles or GUI nodes, are drawn by a renderer. At the heart of the renderer is a render script that controls the render pipeline. By default, every 2D object is drawn with the correct bitmap with the specified blending and at the correct Z depth—so you might not have to ever think about rendering beyond ordering and simple blending. For most 2D games, the default pipeline functions well, but your game might have special requirements. If that is the case, Defold allows you to write a tailor-made rendering pipeline.\n\nRender pipeline - What, when and where?\n\nThe render pipeline controls what to render, when to render it and also where to render it. What to render is controlled by render predicates. When to render a predicate is controlled in the render script and where to render a predicate is controlled by the view projection. The render pipeline can also cull the graphics, drawn by a render predicate, which lies outside of a defined bounding box or frustum. This process is called frustum culling.\n\nThe render file contains a reference to the current render script as well as custom materials that should be made available in the render script (use with )\n\nAt the heart of the rendering pipeline is the render script. This is a Lua script with the functions , and and it is primarily used to interact with the underlying graphics API. The render script has a special place in the lifecycle of your game. Details can be found in the Application lifecycle documentation.\n\nIn the “Builtins” folder of your projects you can find the default render resource (“default.render”) and the default render script (“default.render_script”).\n• Copy the files “default.render” and “default.render_script” to a location in your project hierarchy. You can, of course, create a render script from scratch but it is a good idea to start with a copy of the default script, especially if you are new to Defold and/or graphics programming.\n• Edit your copy of the “default.render” file and change the Script property to refer to your copy of the render script.\n• Change the Render property (under bootstrap) in the game.project settings file to refer to your copy of the “default.render” file.\n\nTo be able to control the draw order of objects, you create render predicates. A predicate declares what should be drawn based on a selection of material tags.\n\nEach object that is drawn onto the screen has a material attached to it that controls how the object should be drawn to the screen. In the material, you specify one or more tags that should be associated with the material.\n\nIn your render script, you can then create a render predicate and specify which tags should belong to that predicate. When you tell the engine to draw the predicate, each object with a material containing all of the tags specified for the predicate will be drawn.\n\nA detailed description on how materials work can be found in the Material documentation.\n\nThe default render script is configured to use an orthographic projection suitable for 2D games. It provides three different orthographic projections: (default), and . As an alternative to the orthographic projections in the default render script you also have the option to use the projection matrix provided by a camera component.\n\nThe stretch projection will always draw an area of your game that is equal to the dimensions set in game.project, even when the window is resized. If the aspect ratio changes it will result in game content being stretched either vertically or horizontally:\n\nThe stretch projection is the default projection but if you have changed from it and need to switch back you do it by sending a message to the render script:\n\nJust like the stretch projection the fixed fit projection will always show an area of the game that is equal to the dimensions set in game.project, but if the window is resized and the aspect ratio changes the game content will retain the original aspect ratio and additional game content will be shown vertically or horizontally:\n\nFixed fit projection with the window reduced to 50% of original size\n\nYou enable the fixed fit projection by sending a message to the render script:\n\nThe fixed projection will retain the original aspect ratio and render your game content with a fixed zoom level. This means that it if the zoom level is set to something other than 100% it will show more or less than the area of the game defined by the dimensions in game.project:\n\nFixed projection with zoom set to 2 and window reduced to 50% of original size\n\nYou enable the fixed projection by sending a message to the render script:\n\nWhen using the default render script and there are enabled Camera components available in the project, they will take precedence over any other view / projections set in the render script. To read more about how to work with camera components in render scripts, please consult the Camera documentation.\n\nThe render API in Defold lets developers perform something called frustum culling. When frustum culling is enabled any graphics that lies outside of a defined bounding box or frustum will be ignored. In a large game world where only a portion is visible at a time, frustum culling can dramatically reduce the amount of data that needs to be sent to the GPU for rendering, thus increasing performance and saving battery (on mobile devices). It is common to use the view and projection of the camera to create the bounding box. The default render script uses the view and projection (from the camera) to calculate a frustum.\n\nFrustum culling is implemented in the engine per component type. Current status (Defold 1.9.0):\n\n1 = Mesh bounding box needs to be set by the developer. Learn more.\n\nWhen components are rendered you usually talk of in which coordinate system the components are rendered. In most games you have some components drawn in world space and some in screen space.\n\nGUI components and their nodes are usually drawn in the screen space coordinate, with the bottom left corner of the screen having coordinate (0,0) and the top right corner is (screen width, screen height). The screen space coordinate system is never offset or in some other way translated by a camera. This will keep the GUI nodes always drawn on screen regardless of how the world is rendered.\n\nSprites, tilemaps and other components used by game objects that exist in your game world are usually drawn in the world space coordinate system. If you make no modifications to your render script and use no camera component to change the view projection this coordinate system is the same as the screen space coordinate system, but as soon as you add a camera and either move it around or change the view projection the two coordinate systems will deviate. When the camera is moving the lower left corner of the screen will be offset from (0, 0) so that other parts of the world is rendered. If the projection changes the coordinates will be both translated (ie offset from 0, 0) and modified by a scale factor.\n\nBelow is the code for a custom render script that is a slightly modified version of the built-in one.\n\nSo far this is a simple and straightforward render script. It draws in the same manner every single frame. However, it is sometimes desirable to be able to introduce state into the render script and perform different operations depending on the state. It may also be desirable to communicate with the render script from other parts of the game code.\n\nHowever, any script of GUI script can send messages to the render script though the special socket:\n\nTo pass in certain engine resources into the render script, you can add these into the table in the .render file assigned to the project:\n\nUsing these resources in a render script:\n\nTextures in Defold are represented internally as a handle, which essentially equates to a number that should uniquely identify a texture object anywhere in the engine. This means that you can bridge the gameobject world with the rendering world by passing these handles between the render system and a gameobject script. For example, a script can create a dynamic texture in a script attached to a gameobject and send this to the renderer to be used as a global texture in a draw command.\n\nThe Defold render script API translates render operations into the following graphics APIs:\n\nThe visual profiler accessible through the message sent to the socket is not part of the scriptable renderer. It is drawn separate from your render script.\n\nA draw call is the term used to describe the process of setting up the GPU to draw an object to the screen using a texture and a material with optional additional settings. This process is usually resource intensive and it is recommended that the number of draw calls are as few as possible. You can measure the number of the draw calls and the time it takes to render them using the built-in profiler.\n\nDefold will try to batch render operation to reduce the number of draw calls according to a set of rules defined below. The rules differ between GUI components and all other component types.\n\nRendering is done based on z-order, from low to high. The engine will start by sorting the list of things to draw and iterate from low to high z-values. Each object in the list will be grouped into the same draw call as the previous object if the following conditions are met:\n• Belongs to the same collection proxy\n• Is of the same component type (sprite, particle fx, tilemap etc)\n• Uses the same texture (atlas or tile source)\n• Has the same material\n• Has the same shader constants (such as tint)\n\nThis means that if two sprite components in the same collection proxy has adjacent or the same z-value (and thus comes next to each other in the sorted list), use the same texture, material and constants they will be grouped into the same draw call.\n\nRendering of the nodes in a GUI component are done from top to bottom of the node list. Each node in the list will be grouped into the same draw call as the previous node if the following conditions are met:\n• Is of the same type (box, text, pie etc)\n• Uses the same texture (atlas or tile source)\n• Has the same blend mode.\n• Has the same font (only for text nodes)\n• Has the same stencil settings\n\nThe ability to arrange nodes in hierarchies makes it easy to group nodes into manageable units. But hierarchies can effectively break batch rendering if you mix different node types. It is possible to more effectively batch GUI nodes while maintaining node hierarchies using GUI layers. You can read more about GUI layers and how they affect draw calls in the GUI manual."
    },
    {
        "link": "https://stackoverflow.com/questions/53289289/lua-avoiding-passing-by-reference",
        "document": "Defold provides a number of special data structures that are all very useful in game development:\n• vector3 - vmath.vector3(x,y,z), useful for describing positions or direction in a 3D coordinate system\n• vector4 - vmath.vector4(x,y,z,w), used for color, tint etc (red, green, blue, alpha)\n• matrix4 - vmath.matrix4() a 4x4 matrix of values. Useful for view and projection matrices among other things\n\nAll of the above are used by the Defold game engine, but you'll find the same kind of data structures in other game engines as well.\n\nThe data structures above have one thing in common: They are of the Lua type\n\nUser data is passed by reference always and that is why you're seeing the behaviour that you describe. Defold does provide ways to make copies though:\n\nlocal copy = vmath.vector3(original) -- copy the vector3 'original' local copy = vmath.vector4(original) -- copy the vector4 'original' local copy = vmath.quat(original) -- copy the quaternion 'original' local copy = vmath.matrix4(original) -- copy the matrix4 'original'"
    },
    {
        "link": "https://forum.defold.com/t/discussion-ideal-collision-algorithm/69097",
        "document": "In this post I would like to share some of my thoughts about collision handling. I’ll first state the final effect that I want (the goal), then list a few different schemes (including some that I have seen and I have come up with on my own) and compare them with the requirements (e.g. point out the problems), during that and at last ask a couple of questions.\n\nI am going to develop a pixel 2D platform game and have already many ideas. One of them is that I wish it can hold a principe of “freedom”. There are some examples that satisfy this principe:\n\nRequirement 1. The objects in a map should be able to have continuous coordinates - One can move every object pixel by pixel (unlike the tile map). Also every object should be able to own a script so that we can customize the behavior of it and the possibility is extended in a far way.\n\nRequirement 2. The objects can have arbitrary sizes (for now we don’t consider the shape of the hit-box).\n\nRequirement 3. The player can have an arbitrary speed, especially a pretty large one (this is a little unusual but I want it to be possible).\n\nThe first requirement seemed to be solved: See Free/Flexible tile map?. The difficulty of solving the other two is, the collision should still work perfectly while those points are achieved.\n\nBy the way, in the whole discussion we firstly assume that the hit-box shape of the player is a rectangle.\n\nNow we have a look at some different collision handling schemes and evaluate them.\n\nI think this is the most classical idea to handle collisions. In each frame it uses the messages that contain the information of collisions among kinematic collision objects to make a calculation to correct the player’s position when he goes into blocks. For details see for example Resolving collisions.\n\nThere are two problems:\n\nProblem 1.1. Sometimes the collision direction (a vector) is determined differently from what people hope (see this explain), what can cause bugs like, that the player gets stuck on the wall (Wall-clipping collision issue) and that the player falls suddenly when walking on one-directional platforms (Directional platforms help). At the moment I don’t know if we can avoid such problems when the correction method is still used.\n\nQuestion 1. Is it possible to solve the bugs mentioned above if we insist on using this algorithm? If yes, how?\n\nklaytonkowalski advised using raycast instead, what we are going to analyze below. As he also mentioned, in Asset Portal there’re some modules made from others. Currently I have looked through the codes from platypus, Defold Simple Platformer (deleted?) as well as True Tile Collisions. The first two use raycast. It looks like - I’m not sure - the third one uses tile map and limit the tiles into specific formats. After a glance I think it describes collisions mathematically instead of using collision shapes. More important is, I would like to write the code from this part on my own since collision handling is a very basic core part in a game so I must understand the theory.\n\nProblem 1.2. If the speed of the player is too large, it’s possible that it runs through the wall.\n\nThis may happen because when the player is really fast, at the frame after the frame where he started to move, he has already reached the the opposite. So no collisions between the player and the wall are detected, and that contradicts Requirement 3.\n\nIt detects the collisions by drawing linear rays from the player’s center out and finding the intersections. See physics.raycast() from API reference. In the two examples above, platypus and Defold Simple Platformer, this method is used. It avoids the Problem 1.1 and Problem 1.2, but another bug may appear:\n\nProblem 2.1. Sometimes the rays don’t intersect the obstacles.\n\nTwo reasons could cause this problem: The first is pretty small objects. Since the rays are only lines, “gaps” between them can’t be avoided. And if there’re objects that are smaller than the gap, they won’t be detected. The following figure shows the situation.\n\nIf we meet some sharp corner a similar problem will also occur:\n\nI actually made a thin tile and a slope in platypus and got the expected result from the test:\n\n(The correct effect should be that the player can stand on them stably.) That contradicts Requirement 2.\n\nThe second factor, again, is the possibly too large speed of the player. The distance between the rays becomes big when we look at a place far away from the player, and an obstacle may be missed by the rays even if its size is normal. This doesn’t matter when the player is not so fast, because the player can’t directly move so far, and when he approaches that obstacle the gap becomes small, then the rays are able to catch it. But if the speed is too large, the player may skip the obstacle.\n\nOf course we can add more rays, but it doesn’t solve the problem perfectly.\n\nNow I’m going to give a few approaches from my own thoughs.\n\nThis method uses raycast too, but instead of drawing 8 rays from the center of the player, it draws rays from the player to the place where the player is going to reach at the next frame. For instance, as the figure below shows, we can use rays to connect the corresponding vertexes of the player’s shape at the current frame and the shape that we plan to reach at the next frame, find the nearest intersection point on each ray, calculate the distances of these points on their rays, and find out the shortest one (the green segment in the figure). At last we calculate a new vector by reducing the length of player’s current velocity to this distance, and move the player by that vector.\n\nIn general this method solves the “high-speed problem” because the rays are parallel, but the problem with small obstacles still can’t be avoided. Again, we can add more rays (e.g. starting with the mid-points of the four sides) to make the detection more precise, but gaps always exist (extremely speaking, we want to be able to deal with a 1px × 1px obstacle). (I think this algorithm is good enough if we don’t require so small objects, though.)\n\nHowever, what if we add so many rays, that from every pixel point on the sides a ray starts? The gaps won’t exist any more actually. It’s crazy, since so many calculations must be done every frame! But when we observe how the rays look like, we will find that parallelograms are formed.\n\nHere is the scheme that I think could be the final solution:\n\nGaps always appear because the rays are one-dimensional. In order to continuously catch every point we need two-dimensional models. Thus I’m considering if the rays can be extended to have a width; or, if we can use parallelograms to detect intersections. If so, then we’ll be able to have a great algorithm. Like the figure below, we draw parallelograms between the current and the target place, and use them to get collision information.\n\nThis method can be considered as “natural”. It looks like as if we try to move the player to the target place pixel by pixel, and after every small step the collision is tested. If we think of the pixels as very tiny, then it’s like a continuous physical process in our real world (at least from a macro perspective). It won’t meet any high-speed problem or small-obstacle problem.\n\nBut at the moment it’s only an idea and I don’t know if it’s actually good and if it’s realizable. That’s where I need your help:\n\nQuestion 2. Is it possible to realize this method, which uses parallelograms to detect intersections? And concretely, how would we use it - would the result of the collision detection be a set of sides (since there’re so many intersection points) or something else?\n\nQuestion 3. Is there any other problem? How difficult would the calculation be (this is relevant to the running fluency of the game)?\n\nAnd, in the end, two general questions:\n\nQuestion 4. Are there mistakes or points that I didn’t explain well in my statements? And would you like to add something?\n\nQuestion 5. Do you know any other methods (especially a method that can achieve my goal)?"
    },
    {
        "link": "https://forum.defold.com/t/how-to-test-if-point-collides-with-collision-object-solved/66114",
        "document": "Defold is a free and open game engine used for development of console, desktop, mobile and web games."
    },
    {
        "link": "https://stackoverflow.com/questions/16503219/manual-collision-detection-in-lua",
        "document": "So Im working on a simple rectangle rectangle collision for my game in Lua. I have an algorithm i was using for other projects for this type of collision but its in C++ and I know it works. The issue is that it uses the center of the rectangle. While easy to calculate im having issues keeping the center, in the center as the sprite is moving. Here what Im doing\n\nThe sprite is moving like it should but the property \"self.boundingBox.centerY\" isn't and Im not sure what would be the best way to handle this situation. please help Thanks"
    },
    {
        "link": "https://defold.com/manuals/physics-objects",
        "document": "Getting Started - Introduction - Installing Defold - Glossary - Defold for Flash users - Getting help Project Setup - Creating a project - Project settings - Sharing projects Editor - Overview - Code editor - Custom project templates - Editor scripts - Editor scripts: UI - Debugger - Keyboard shortcuts - Preferences - Refactoring - Styling Core Concepts - Building blocks - Addressing - Message passing - Application lifecycle Assets and Resources - Importing assets - Caching assets - Importing 2D graphics - Importing 3D models - Adapting to different screen sizes - Live update - Atlas - Buffer - Font - Runtime TTF Font - Resource management - Tile source - Texture filtering - Texture compression Animations - Overview - Flipbook Animation - Model animation - Property animation (tweens) - Rive animation - Spine animation Components - Overview - Collection factory - Collection proxy - Collision object - Camera - Factory - Label - Mesh - Model - Particle FX - Rive - Sound - Spine - Sprite - Tilemap GUI - GUI overview - Box nodes - Text nodes - Pie nodes - Spine nodes - ParticleFX nodes - Template nodes - Scripts - Clipping - Layouts Physics - Physics overview - Collision objects - Collision shapes - Collision groups - Collision messages - Collision events listener - Resolving collisions - Ray casts - Joints and constraints Sound - Sound - Sound Streaming - FMOD Input - Overview - Key and text input - Mouse and touch - Gamepads Game logic - Scripts - Properties - Script properties - Lua in Defold - Source code obfuscation - Modules - Debugging - Writing code Files - Working with files Network Connections - Overview - HTTP Requests - Socket connections - WebSocket connections - Online services Rendering - Render - Material - Compute - Shader - Texture filtering Workflow - Application security - Bundling an application - Caching assets - Command line tools - Hot reloading - Porting guidelines - Refactoring - The mobile dev app - Version control - Writing code - Working offline Debugging - Debugging game logic - Debugging native code - Debugging native code on Android - Debugging native code on iOS - Reading game and system logs Optimization - Optimizing an application - Optimize game size - Optimize runtime performance - Optimize battery usage - Optimize memory usage - Profiling Monetization - Ads - In-app purchases Android - Introduction - Advertising Info - AdMob ads - Android Device Performance Framework - App review and ratings - Camera - Facebook - Firebase Analytics - Firebase Remote Config - Google Play Game Services - Google Play Instant - Inter-app communication - IronSource ad mediation - Push notifications - Safe Area - Webview - The mobile dev app iOS - Introduction - Advertising Info - AdMob ads - App review and ratings - Camera - Facebook - Firebase Analytics - Firebase Remote Config - Inter-app communication - IronSource ad mediation - Push notifications - Safe Area - Webview - The mobile dev app Consoles - Nintendo Switch - PlayStation®4 - PlayStation®5 - Microsoft Xbox HTML5 - Introduction - CrazyGames - Facebook - Facebook Instant Games - Poki Desktop - Linux - macOS - Windows Engine extensions - Introduction - Defold SDK - Gradle dependencies - Cocoapod dependencies - Adding auto-complete definition - Best Practices - Debugging - Extension Manifests - App Manifests - Manifest Merging - The Lua C API (external) - Setup local build server - Available Docker images to run Extender\n\nA collision object is a component you use to give a game object physical behaviour. A collision object has physical properties like weight, restitution and friction and its spatial extension is defined by one or more shapes that you attach to the component. Defold supports the following types of collision objects:\n\nA collision object component has a set of Properties that sets its type and physics properties. It also contains one or more Shapes that define the whole shape of the physics object.\n• In the Outline view, the game object and select from the context menu. This creates a new component with no shapes.\n• the new component and select . This adds a new shape to the collision object component. You can add any number of shapes to the component. You can also use a tilemap or a convex hull to define the shape of the physics object.\n• Use the move, rotate and scale tools to edit the shapes.\n• Select the component in the Outline and edit the collision object’s Properties.\n\nA collision component can either use several primitive shapes or a single complex shape. Learn more about the various shapes and how to add them to a collision component in the Collision Shapes manual.\n\nThis means that if one of the objects has zero friction then the contact between them will have zero friction.\n\nWhen a shape develops multiple contacts, restitution is simulated approximately because Box2D uses an iterative solver. Box2D also uses inelastic collisions when the collision velocity is small to prevent bounce-jitter\n\nA physics object has a number of different properties that can be read and changed using and :"
    },
    {
        "link": "https://gamedev.stackexchange.com/questions/211567/predictive-rectangle-collision-resolution-corner-snagging",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    }
]