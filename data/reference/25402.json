[
    {
        "link": "https://spring.io/guides/gs/scheduling-tasks",
        "document": "How to Complete This Guide Like most Spring Getting Started guides you can start from scratch and complete each step, or you can jump straight to the solution, by viewing the code in this repository. To see the end result in your local environment, you can do one of the following:\n• Download and unzip the source repository for this guide\n• Fork the repository which let you request changes to this guide through submission of a pull request\n\nYou can use this pre-initialized project and click Generate to download a ZIP file. This project is configured to fit the examples in this guide.\n• Navigate to https://start.spring.io. This service pulls in all the dependencies you need for an application and does most of the setup for you.\n• Choose either Gradle or Maven and the language you want to use. This guide assumes that you chose Java and Gradle.\n• Download the resulting ZIP file, which is an archive of an application that is configured with your choices. If your IDE has the Spring Initializr integration, you can complete this process from your IDE.\n\nAlthough scheduled tasks can be embedded in web applications, the simpler approach (shown in this guide) creates a standalone application. To do so, package everything in a single, executable JAR file, driven by a Java main() method. The following snippet (from ) shows the application class: Spring Initializr adds the annotation to our main class. is a convenience annotation that adds all of the following:\n• : Tags the class as a source of bean definitions for the application context.\n• : Spring Boot attempts to automatically configure your Spring application based on the dependencies that you have added.\n• : Tells Spring to look for other components, configurations, and services. If specific packages are not defined, recursive scanning begins with the package of the class that declares the annotation.\n\nYou should now be able to run the application by executing the main method in . You can run the program from your IDE, or by executing the following Gradle command in the project root directory: Doing so starts the application, and the method annotated with @Scheduled runs. You should see log messages similar to: 20yy-mm-ddT07:23:01.665-04:00 INFO 19633 --- [ scheduling-1] c.e.schedulingtasks.ScheduledTasks : The time is now 07:23:01 20yy-mm-ddT07:23:06.663-04:00 INFO 19633 --- [ scheduling-1] c.e.schedulingtasks.ScheduledTasks : The time is now 07:23:06 20yy-mm-ddT07:23:11.663-04:00 INFO 19633 --- [ scheduling-1] c.e.schedulingtasks.ScheduledTasks : The time is now 07:23:11 This example uses scheduling, so the application runs indefinitely until you interrupt it manually."
    },
    {
        "link": "https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/scheduling/annotation/Scheduled.html",
        "document": "Annotation that marks a method to be scheduled. For periodic tasks, exactly one of the , or attributes must be specified, and additionally an optional . For a one-time task, it is sufficient to just specify an\n\nThe annotated method must not accept arguments. It will typically have a return type; if not, the returned value will be ignored when called through the scheduler.\n\nMethods that return a reactive or a type which can be adapted to by the default are supported. The must support multiple subsequent subscriptions. The returned is only produced once, and the scheduling infrastructure then periodically subscribes to it according to configuration. Values emitted by the publisher are ignored. Errors are logged at level, which doesn't prevent further iterations. If a fixed delay is configured, the subscription is blocked in order to respect the fixed delay semantics.\n\nKotlin suspending functions are also supported, provided the coroutine-reactor bridge ( ) is present at runtime. This bridge is used to adapt the suspending function to a which is treated the same way as in the reactive method case (see above).\n\nProcessing of annotations is performed by registering a . This can be done manually or, more conveniently, through the XML element or annotation.\n\nThis annotation can be used as a repeatable annotation. If several scheduled declarations are found on the same method, each of them will be processed independently, with a separate trigger firing for each of them. As a consequence, such co-located schedules may overlap and execute multiple times in parallel or in immediate succession.\n\nThis annotation may be used as a meta-annotation to create custom composed annotations with attribute overrides."
    },
    {
        "link": "https://baeldung.com/spring-scheduled-tasks",
        "document": "In this tutorial, we’ll illustrate how the Spring @Scheduled annotation can be used to configure and schedule tasks.\n\nThe simple rules that we need to follow to annotate a method with @Scheduled are:\n• the method should typically have a void return type (if not, the returned value will be ignored)\n• the method should not expect any parameters\n\nTo enable support for scheduling tasks and the @Scheduled annotation in Spring, we can use the Java enable-style annotation:\n\nConversely, we can do the same in XML:\n\nLet’s start by configuring a task to run after a fixed delay:\n\nIn this case, the duration between the end of the last execution and the start of the next execution is fixed. The task always waits until the previous one is finished.\n\nThis option should be used when it’s mandatory that the previous execution is completed before running again.\n\nLet’s now execute a task at a fixed interval of time:\n\nThis option should be used when each execution of the task is independent.\n\nNote that scheduled tasks don’t run in parallel by default. So even if we used fixedRate, the next task won’t be invoked until the previous one is done.\n\nIf we want to support parallel behavior in scheduled tasks, we need to add the @Async annotation:\n\nNow this asynchronous task will be invoked each second, even if the previous task isn’t done.\n\nWe can run a scheduled task using Spring’s @Scheduled annotation, but based on the properties fixedDelay and fixedRate, the nature of execution changes.\n\nThe fixedDelay property makes sure that there is a delay of n millisecond between the finish time of an execution of a task and the start time of the next execution of the task.\n\nThis property is specifically useful when we need to make sure that only one instance of the task runs all the time. For dependent jobs, it is quite helpful.\n\nThe fixedRate property runs the scheduled task at every n millisecond. It doesn’t check for any previous executions of the task.\n\nThis is useful when all executions of the task are independent. If we don’t expect to exceed the size of the memory and the thread pool, fixedRate should be quite handy.\n\nAlthough, if the incoming tasks do not finish quickly, it’s possible they end up with “Out of Memory exception”.\n\nNext, let’s schedule a task with a delay (in milliseconds):\n\nNote how we’re using both fixedDelay as well as initialDelay in this example. The task will be executed the first time after the initialDelay value, and it will continue to be executed according to the fixedDelay.\n\nThis option is convenient when the task has a setup that needs to be completed.\n\nSometimes delays and rates are not enough, and we need the flexibility of a cron expression to control the schedule of our tasks:\n\nNote that in this example, we’re scheduling a task to be executed at 10:15 AM on the 15th day of every month.\n\nBy default, Spring will use the server’s local time zone for the cron expression. However, we can use the zone attribute to change this timezone:\n\nWith this configuration, Spring will schedule the annotated method to run at 10:15 AM on the 15th day of every month in Paris time.\n\nHardcoding these schedules is simple, but we usually need to be able to control the schedule without re-compiling and re-deploying the entire app.\n\nWe’ll make use of Spring Expressions to externalize the configuration of the tasks, and we’ll store these in properties files.\n\nSpring also provides an XML way of configuring the scheduled tasks. Here is the XML configuration to set these up:\n\nNormally, all the properties of the @Scheduled annotation are resolved and initialized only once at Spring context startup.\n\nTherefore, changing the fixedDelay or fixedRate values at runtime isn’t possible when we use @Scheduled annotation in Spring.\n\nHowever, there is a workaround. Using Spring’s SchedulingConfigurer provides a more customizable way to give us the opportunity of setting the delay or rate dynamically.\n\nAs we notice, with the help of the ScheduledTaskRegistrar#addTriggerTask method, we can add a Runnable task and a Trigger implementation to recalculate the nextExecutionTime after the end of each execution.\n\nAdditionally, we annotate our DynamicSchedulingConfig with @EnableScheduling to make the scheduling work.\n\nAs a result, we scheduled the TickService#tick method to run it after each amount of delay, which is determined dynamically at runtime by the getDelay method.\n\nBy default, Spring uses a local single-threaded scheduler to run the tasks. As a result, even if we have multiple @Scheduled methods, they each need to wait for the thread to complete executing a previous task.\n\nIf our tasks are truly independent, it’s more convenient to run them in parallel. For that, we need to provide a TaskScheduler that better suits our needs:\n\nIn the above example, we configured the TaskScheduler with a pool size of five, but keep in mind that the actual configuration should be fine-tuned to one’s specific needs.\n\nIf we use Spring Boot, we can make use of an even more convenient approach to increase the scheduler’s pool size.\n\nIt’s simply enough to set the spring.task.scheduling.pool.size property:\n\n\n\nIn this article, we discussed the way to configure and use the @Scheduled annotation.\n\nWe covered the process to enable scheduling, and various ways of configuring scheduling task patterns. We also showed a workaround to configure the delay and rate dynamically."
    },
    {
        "link": "https://medium.com/@alxkm/mastering-task-scheduling-in-spring-boot-a-comprehensive-guide-to-scheduled-with-asyc-761bb6193fc6",
        "document": "In Java, the @Scheduled annotation is used in Spring Framework to schedule tasks to be executed at a specific time or at regular intervals. This annotation can be applied to methods within Spring-managed beans to indicate when those methods should be invoked.\n\nYou apply the @Scheduled annotation to the method you want to schedule. You typically configure scheduling in the Spring application context XML file or through Java configuration classes. This configuration defines the scheduling details like when the method should run. When the application starts, Spring initializes the beans and checks for methods annotated with @Scheduled. It then schedules the execution of these methods based on the specified timing or interval. The @Scheduled annotation supports cron expressions, fixed delays, and fixed rates. You can use a cron expression for more complex scheduling, or specify fixed delays or fixed rates for simpler periodic tasks.\n\nIn this scenario, while the heavy job takes 3 seconds to execute, the second job doesn’t run at all because the single thread is occupied.\n\nThis could pose a problem in a commercial project, as it may take a significant amount of time to understand why your @Scheduled method isn’t executing at the specified time.\n\nTo solve this you can use two approaches:\n• Explicitly delegate the execution of code to a separate thread, for instance, using the @Async annotation.\n• Configure the @Scheduled annotation so that a method marked with this annotation always executes in a separate thread.\n\nTo avoid blocking the execution of task1() due to the potentially long-running task2(), you can configure them to run in separate threads. You can achieve this by setting the @Async annotation on the methods. Here’s how you can modify your code:\n\nBy adding the @Async annotation, Spring will execute these methods in separate threads, allowing them to run concurrently without waiting for each other to finish. This way, task1() will not be blocked by the potentially long-running task2().\n\nWhen using the @Async annotation, Spring by default creates an Executor that has no limit on the number of threads it can create. As a result, if your job is triggered more frequently than it completes, it may lead to memory leaks due to continuously created threads.\n\nAlso we can customize @Async(“jobExecutor”). This is more efficient way to manage your resources. By default, Spring uses a default TaskExecutor bean for executing asynchronous methods. However, you can specify a custom Executor bean to be used instead by providing its bean name as an argument to @Async. You need to configure a custom Executor bean with the specified bean name (in this case, \"jobExecutor\") elsewhere in your Spring configuration.\n\nYou can customize your executor for example in such way below. But this is tricky topic with a lot of hidden details:\n\nBut this is tricky topic with a lot of hidden details.\n\nIn such way we create ScheduledThreadPoolExecutor with pool size of 10 threads.\n• Quick Setup: Requires minimal configuration and can be applied directly to methods.\n• Default Executor: By default, Spring creates an Executor without a limit on the number of threads, which can lead to memory leaks if tasks are triggered more frequently than they complete.\n• Limited Control: Limited control over the thread pool configuration, potentially leading to inefficient resource usage.\n• Fine-Grained Control: Allows customization of the thread pool configuration, including core pool size, maximum pool size, queue capacity, and thread names.\n• Resource Management: Enables efficient resource management by setting appropriate limits on the number of threads.\n• Flexibility: Offers flexibility to tailor the thread pool configuration to match specific application requirements.\n• Configuration Overhead: Requires additional configuration code to set up and manage the ThreadPoolTaskExecutor bean.\n• Complexity: May introduce complexity, especially for developers unfamiliar with configuring thread pools.\n• @Async Annotation: Best suited for simple scenarios where quick setup and minimal configuration are sufficient. However, careful attention is needed to avoid potential memory leaks due to default Executor settings.\n• Custom Configuration of ThreadPoolTaskExecutor: Provides more control and flexibility, making it suitable for applications with specific resource management requirements. Although it requires more configuration overhead, it offers better resource utilization and scalability in the long run.\n\nIn summary, the choice between using @Async annotation and custom configuration of ThreadPoolTaskExecutor depends on the complexity of your application, resource management requirements, and the level of control you need over the thread pool configuration. For simple cases, @Async may suffice, but for more demanding scenarios, custom configuration offers better control and scalability.\n\nYou can find some examples at Github."
    },
    {
        "link": "https://docs.spring.io/spring-framework/reference/integration/scheduling.html",
        "document": "Executors are the JDK name for the concept of thread pools. The “executor” naming is due to the fact that there is no guarantee that the underlying implementation is actually a pool. An executor may be single-threaded or even synchronous. Spring’s abstraction hides implementation details between the Java SE and Jakarta EE environments. Spring’s interface is identical to the interface. In fact, originally, its primary reason for existence was to abstract away the need for Java 5 when using thread pools. The interface has a single method ( ) that accepts a task for execution based on the semantics and configuration of the thread pool. The was originally created to give other Spring components an abstraction for thread pooling where needed. Components such as the , JMS’s , and Quartz integration all use the abstraction to pool threads. However, if your beans need thread pooling behavior, you can also use this abstraction for your own needs. Spring includes a number of pre-built implementations of . In all likelihood, you should never need to implement your own. The variants that Spring provides are as follows:\n• : This implementation does not run invocations asynchronously. Instead, each invocation takes place in the calling thread. It is primarily used in situations where multi-threading is not necessary, such as in simple test cases.\n• : This implementation does not reuse any threads. Rather, it starts up a new thread for each invocation. However, it does support a concurrency limit that blocks any invocations that are over the limit until a slot has been freed up. If you are looking for true pooling, see , later in this list. This will use JDK 21’s Virtual Threads, when the \"virtualThreads\" option is enabled. This implementation also supports graceful shutdown through Spring’s lifecycle management.\n• : This implementation is an adapter for a instance. There is an alternative ( ) that exposes the configuration parameters as bean properties. There is rarely a need to use directly. However, if the is not flexible enough for your needs, is an alternative.\n• : This implementation is most commonly used. It exposes bean properties for configuring a and wraps it in a . If you need to adapt to a different kind of , we recommend that you use a instead. It also provides a pause/resume capability and graceful shutdown through Spring’s lifecycle management.\n• : This implementation uses a JNDI-obtained in a JSR-236 compatible runtime environment (such as a Jakarta EE application server), replacing a CommonJ WorkManager for that purpose. Spring’s implementations are commonly used with dependency injection. In the following example, we define a bean that uses the to asynchronously print out a set of messages: class TaskExecutorExample(private val taskExecutor: TaskExecutor) { private inner class MessagePrinterTask(private val message: String) : Runnable { override fun run() { println(message) } } fun printMessages() { for (i in 0..24) { taskExecutor.execute( MessagePrinterTask( \"Message$i\" ) ) } } } As you can see, rather than retrieving a thread from the pool and executing it yourself, you add your to the queue. Then the uses its internal rules to decide when the task gets run. To configure the rules that the uses, we expose simple bean properties: Most implementations provide a way to automatically wrap tasks submitted with a . Decorators should delegate to the task it is wrapping, possibly implementing custom behavior before/after the execution of the task. Let’s consider a simple implementation that will log messages before and after the execution or our tasks: We can then configure our decorator on a instance: In case multiple decorators are needed, the can be used to execute sequentially multiple decorators.\n\nIn addition to the abstraction, Spring has a SPI with a variety of methods for scheduling tasks to run at some point in the future. The following listing shows the interface definition: The simplest method is the one named that takes only a and an . That causes the task to run once after the specified time. All of the other methods are capable of scheduling tasks to run repeatedly. The fixed-rate and fixed-delay methods are for simple, periodic execution, but the method that accepts a is much more flexible. The interface is essentially inspired by JSR-236. The basic idea of the is that execution times may be determined based on past execution outcomes or even arbitrary conditions. If these determinations take into account the outcome of the preceding execution, that information is available within a . The interface itself is quite simple, as the following listing shows: The is the most important part. It encapsulates all of the relevant data and is open for extension in the future, if necessary. The is an interface (a implementation is used by default). The following listing shows the available methods for implementations. Spring provides two implementations of the interface. The most interesting one is the . It enables the scheduling of tasks based on cron expressions. For example, the following task is scheduled to run 15 minutes past each hour but only during the 9-to-5 \"business hours\" on weekdays: The other implementation is a that accepts a fixed period, an optional initial delay value, and a boolean to indicate whether the period should be interpreted as a fixed-rate or a fixed-delay. Since the interface already defines methods for scheduling tasks at a fixed rate or with a fixed delay, those methods should be used directly whenever possible. The value of the implementation is that you can use it within components that rely on the abstraction. For example, it may be convenient to allow periodic triggers, cron-based triggers, and even custom trigger implementations to be used interchangeably. Such a component could take advantage of dependency injection so that you can configure such externally and, therefore, easily modify or extend them. As with Spring’s abstraction, the primary benefit of the arrangement is that an application’s scheduling needs are decoupled from the deployment environment. This abstraction level is particularly relevant when deploying to an application server environment where threads should not be created directly by the application itself. For such scenarios, Spring provides a that delegates to a JSR-236 in a Jakarta EE environment. Whenever external thread management is not a requirement, a simpler alternative is a local setup within the application, which can be adapted through Spring’s . As a convenience, Spring also provides a , which internally delegates to a to provide common bean-style configuration along the lines of . These variants work perfectly fine for locally embedded thread pool setups in lenient application server environments, as well — in particular on Tomcat and Jetty. As of 6.1, provides a pause/resume capability and graceful shutdown through Spring’s lifecycle management. There is also a new option called which is aligned with JDK 21’s Virtual Threads, using a single scheduler thread but firing up a new thread for every scheduled task execution (except for fixed-delay tasks which all operate on a single scheduler thread, so for this virtual-thread-aligned option, fixed rates and cron triggers are recommended).\n\nSpring provides annotation support for both task scheduling and asynchronous method execution. To enable support for and annotations, you can add and to one of your classes, or element, as the following example shows: You can pick and choose the relevant annotations for your application. For example, if you need only support for , you can omit . For more fine-grained control, you can additionally implement the interface, the interface, or both. See the and javadoc for full details. Note that, with the preceding XML, an executor reference is provided for handling those tasks that correspond to methods with the annotation, and the scheduler reference is provided for managing those methods annotated with . The default advice mode for processing annotations is which allows for interception of calls through the proxy only. Local calls within the same class cannot get intercepted that way. For a more advanced mode of interception, consider switching to mode in combination with compile-time or load-time weaving. You can add the annotation to a method, along with trigger metadata. For example, the following method is invoked every five seconds (5000 milliseconds) with a fixed delay, meaning that the period is measured from the completion time of each preceding invocation. @Scheduled(fixedDelay = 5000) public void doSomething() { // something that should run periodically } By default, milliseconds will be used as the time unit for fixed delay, fixed rate, and initial delay values. If you would like to use a different time unit such as seconds or minutes, you can configure this via the attribute in . For example, the previous example can also be written as follows. @Scheduled(fixedDelay = 5, timeUnit = TimeUnit.SECONDS) public void doSomething() { // something that should run periodically } If you need a fixed-rate execution, you can use the attribute within the annotation. The following method is invoked every five seconds (measured between the successive start times of each invocation): @Scheduled(fixedRate = 5, timeUnit = TimeUnit.SECONDS) public void doSomething() { // something that should run periodically } For fixed-delay and fixed-rate tasks, you can specify an initial delay by indicating the amount of time to wait before the first execution of the method, as the following example shows: @Scheduled(initialDelay = 1000, fixedRate = 5000) public void doSomething() { // something that should run periodically } For one-time tasks, you can just specify an initial delay by indicating the amount of time to wait before the intended execution of the method: @Scheduled(initialDelay = 1000) public void doSomething() { // something that should run only once } If simple periodic scheduling is not expressive enough, you can provide a cron expression. The following example runs only on weekdays: @Scheduled(cron=\"*/5 * * * * MON-FRI\") public void doSomething() { // something that should run on weekdays only } You can also use the attribute to specify the time zone in which the cron expression is resolved. Notice that the methods to be scheduled must have void returns and must not accept any arguments. If the method needs to interact with other objects from the application context, those would typically have been provided through dependency injection. can be used as a repeatable annotation. If several scheduled declarations are found on the same method, each of them will be processed independently, with a separate trigger firing for each of them. As a consequence, such co-located schedules may overlap and execute multiple times in parallel or in immediate succession. Please make sure that your specified cron expressions etc do not accidentally overlap. As of Spring Framework 4.3, methods are supported on beans of any scope. Make sure that you are not initializing multiple instances of the same annotation class at runtime, unless you do want to schedule callbacks to each such instance. Related to this, make sure that you do not use on bean classes that are annotated with and registered as regular Spring beans with the container. Otherwise, you would get double initialization (once through the container and once through the aspect), with the consequence of each method being invoked twice. The annotation on Reactive methods or Kotlin suspending functions As of Spring Framework 6.1, methods are also supported on several types of reactive methods:\n• methods with a return type (or any concrete implementation of ) like in the following example:\n• methods with a return type that can be adapted to via the shared instance of the , provided the type supports deferred subscription like in the following example: The class is an example of a type that can typically be adapted to but doesn’t support deferred subscription. Its in the registry denotes that by having the method return .\n• Kotlin suspending functions, like in the following example: @Scheduled(fixedDelay = 500) suspend fun something() { // do something asynchronous }\n• methods that return a Kotlin or instance, like in the following example: @Scheduled(fixedDelay = 500) fun something(): Flow<Void> { flow { // do something asynchronous } } All these types of methods must be declared without any arguments. In the case of Kotlin suspending functions, the bridge must also be present to allow the framework to invoke a suspending function as a . The Spring Framework will obtain a for the annotated method once and will schedule a in which it subscribes to said . These inner regular subscriptions occur according to the corresponding / / configuration. If the emits signal(s), these are ignored and discarded (the same way return values from synchronous methods are ignored). In the following example, the emits , every 5 seconds, but these values are unused: If the emits an signal, it is logged at level and recovered. Because of the asynchronous and lazy nature of instances, exceptions are not thrown from the task: this means that the contract is not involved for reactive methods. As a result, further scheduled subscription occurs despite the error. In the following example, the subscription fails twice in the first five seconds. Then subscriptions start succeeding, printing a message to the standard output every five seconds: When destroying the annotated bean or closing the application context, Spring Framework cancels scheduled tasks, which includes the next scheduled subscription to the as well as any past subscription that is still currently active (for example, for long-running publishers or even infinite publishers). You can provide the annotation on a method so that invocation of that method occurs asynchronously. In other words, the caller returns immediately upon invocation, while the actual execution of the method occurs in a task that has been submitted to a Spring . In the simplest case, you can apply the annotation to a method that returns , as the following example shows: @Async void doSomething() { // this will be run asynchronously } Unlike the methods annotated with the annotation, these methods can expect arguments, because they are invoked in the “normal” way by callers at runtime rather than from a scheduled task being managed by the container. For example, the following code is a legitimate application of the annotation: @Async void doSomething(String s) { // this will be run asynchronously } Even methods that return a value can be invoked asynchronously. However, such methods are required to have a -typed return value. This still provides the benefit of asynchronous execution so that the caller can perform other tasks prior to calling on that . The following example shows how to use on a method that returns a value: @Async Future<String> returnSomething(int i) { // this will be run asynchronously } methods may not only declare a regular return type but also Spring’s or, as of Spring 4.2, JDK 8’s , for richer interaction with the asynchronous task and for immediate composition with further processing steps. You can not use in conjunction with lifecycle callbacks such as . To asynchronously initialize Spring beans, you currently have to use a separate initializing Spring bean that then invokes the annotated method on the target, as the following example shows: There is no direct XML equivalent for , since such methods should be designed for asynchronous execution in the first place, not externally re-declared to be asynchronous. However, you can manually set up Spring’s with Spring AOP, in combination with a custom pointcut. By default, when specifying on a method, the executor that is used is the one configured when enabling async support, i.e. the “annotation-driven” element if you are using XML or your implementation, if any. However, you can use the attribute of the annotation when you need to indicate that an executor other than the default should be used when executing a given method. The following example shows how to do so: @Async(\"otherExecutor\") void doSomething(String s) { // this will be run asynchronously by \"otherExecutor\" } In this case, can be the name of any bean in the Spring container, or it may be the name of a qualifier associated with any (for example, as specified with the element or Spring’s annotation). When an method has a -typed return value, it is easy to manage an exception that was thrown during the method execution, as this exception is thrown when calling on the result. With a return type, however, the exception is uncaught and cannot be transmitted. You can provide an to handle such exceptions. The following example shows how to do so: By default, the exception is merely logged. You can define a custom by using or the XML element.\n\nAs of version 3.0, Spring includes an XML namespace for configuring and instances. It also provides a convenient way to configure tasks to be scheduled with a trigger. The following element creates a instance with the specified thread pool size: The value provided for the attribute is used as the prefix for thread names within the pool. The element is relatively straightforward. If you do not provide a attribute, the default thread pool has only a single thread. There are no other configuration options for the scheduler. As with the scheduler shown in the previous section, the value provided for the attribute is used as the prefix for thread names within the pool. As far as the pool size is concerned, the element supports more configuration options than the element. For one thing, the thread pool for a is itself more configurable. Rather than only a single size, an executor’s thread pool can have different values for the core and the max size. If you provide a single value, the executor has a fixed-size thread pool (the core and max sizes are the same). However, the element’s attribute also accepts a range in the form of . The following example sets a minimum value of and a maximum value of : In the preceding configuration, a value has also been provided. The configuration of the thread pool should also be considered in light of the executor’s queue capacity. For the full description of the relationship between pool size and queue capacity, see the documentation for . The main idea is that, when a task is submitted, the executor first tries to use a free thread if the number of active threads is currently less than the core size. If the core size has been reached, the task is added to the queue, as long as its capacity has not yet been reached. Only then, if the queue’s capacity has been reached, does the executor create a new thread beyond the core size. If the max size has also been reached, then the executor rejects the task. By default, the queue is unbounded, but this is rarely the desired configuration, because it can lead to if enough tasks are added to that queue while all pool threads are busy. Furthermore, if the queue is unbounded, the max size has no effect at all. Since the executor always tries the queue before creating a new thread beyond the core size, a queue must have a finite capacity for the thread pool to grow beyond the core size (this is why a fixed-size pool is the only sensible case when using an unbounded queue). Consider the case, as mentioned above, when a task is rejected. By default, when a task is rejected, a thread pool executor throws a . However, the rejection policy is actually configurable. The exception is thrown when using the default rejection policy, which is the implementation. For applications where some tasks can be skipped under heavy load, you can instead configure either or . Another option that works well for applications that need to throttle the submitted tasks under heavy load is the . Instead of throwing an exception or discarding tasks, that policy forces the thread that is calling the submit method to run the task itself. The idea is that such a caller is busy while running that task and not able to submit other tasks immediately. Therefore, it provides a simple way to throttle the incoming load while maintaining the limits of the thread pool and queue. Typically, this allows the executor to “catch up” on the tasks it is handling and thereby frees up some capacity on the queue, in the pool, or both. You can choose any of these options from an enumeration of values available for the attribute on the element. The following example shows an element with a number of attributes to specify various behaviors: Finally, the setting determines the time limit (in seconds) for which threads may remain idle before being stopped. If there are more than the core number of threads currently in the pool, after waiting this amount of time without processing a task, excess threads get stopped. A time value of zero causes excess threads to stop immediately after executing a task without remaining follow-up work in the task queue. The following example sets the value to two minutes: The most powerful feature of Spring’s task namespace is the support for configuring tasks to be scheduled within a Spring Application Context. This follows an approach similar to other “method-invokers” in Spring, such as that provided by the JMS namespace for configuring message-driven POJOs. Basically, a attribute can point to any Spring-managed object, and the attribute provides the name of a method to be invoked on that object. The following listing shows a simple example: The scheduler is referenced by the outer element, and each individual task includes the configuration of its trigger metadata. In the preceding example, that metadata defines a periodic trigger with a fixed delay indicating the number of milliseconds to wait after each task execution has completed. Another option is , indicating how often the method should be run regardless of how long any previous execution takes. Additionally, for both and tasks, you can specify an 'initial-delay' parameter, indicating the number of milliseconds to wait before the first execution of the method. For more control, you can instead provide a attribute to provide a cron expression. The following example shows these other options:\n\nAll Spring cron expressions have to conform to the same format, whether you are using them in annotations, elements, or someplace else. A well-formed cron expression, such as , consists of six space-separated time and date fields, each with its own range of valid values: ┌───────────── second (0-59) │ ┌───────────── minute (0 - 59) │ │ ┌───────────── hour (0 - 23) │ │ │ ┌───────────── day of the month (1 - 31) │ │ │ │ ┌───────────── month (1 - 12) (or JAN-DEC) │ │ │ │ │ ┌───────────── day of the week (0 - 7) │ │ │ │ │ │ (0 or 7 is Sunday, or MON-SUN) │ │ │ │ │ │ * * * * * * There are some rules that apply:\n• A field may be an asterisk ( ), which always stands for “first-last”. For the day-of-the-month or day-of-the-week fields, a question mark ( ) may be used instead of an asterisk.\n• Commas ( ) are used to separate items of a list.\n• Two numbers separated with a hyphen ( ) express a range of numbers. The specified range is inclusive.\n• Following a range (or ) with specifies the interval of the number’s value through the range.\n• English names can also be used for the month and day-of-week fields. Use the first three letters of the particular day or month (case does not matter).\n• The day-of-month and day-of-week fields can contain an character, which has a different meaning.\n• In the day-of-month field, stands for the last day of the month. If followed by a negative offset (that is, ), it means th-to-last day of the month.\n• In the day-of-week field, stands for the last day of the week. If prefixed by a number or three-letter name ( or ), it means the last day of week ( or ) in the month.\n• The day-of-month field can be , which stands for the nearest weekday to day of the month . If falls on Saturday, this yields the Friday before it. If falls on Sunday, this yields the Monday after, which also happens if is and falls on a Saturday (that is: stands for the first weekday of the month).\n• If the day-of-month field is , it means the last weekday of the month.\n• The day-of-week field can be (or ), which stands for the th day of week (or ) in the month. top of every hour of every day 8, 9 and 10 o’clock of every day 6:00 AM and 7:00 PM every day last day of the month at midnight third-to-last day of the month at midnight last Friday of the month at midnight last Thursday of the month at midnight first weekday of the month at midnight last weekday of the month at midnight the second Friday in the month at midnight the first Monday in the month at midnight Expressions such as are hard for humans to parse and are, therefore, hard to fix in case of bugs. To improve readability, Spring supports the following macros, which represent commonly used sequences. You can use these macros instead of the six-digit value, thus: .\n\nQuartz uses , , and objects to realize scheduling of all kinds of jobs. For the basic concepts behind Quartz, see the Quartz Web site. For convenience purposes, Spring offers a couple of classes that simplify using Quartz within Spring-based applications. Quartz objects contain all the information needed to run a job. Spring provides a , which provides bean-style properties for XML configuration purposes. Consider the following example: The job detail configuration has all the information it needs to run the job ( ). The timeout is specified in the job data map. The job data map is available through the (passed to you at execution time), but the also gets its properties from the job data mapped to properties of the job instance. So, in the following example, the contains a bean property named , and the has it applied automatically: package example; public class ExampleJob extends QuartzJobBean { private int timeout; /** * Setter called after the ExampleJob is instantiated * with the value from the JobDetailFactoryBean. */ public void setTimeout(int timeout) { this.timeout = timeout; } protected void executeInternal(JobExecutionContext ctx) throws JobExecutionException { // do the actual work } } All additional properties from the job data map are available to you as well. By using the and properties, you can modify the name and the group of the job, respectively. By default, the name of the job matches the bean name of the ( in the preceding example above). Often you merely need to invoke a method on a specific object. By using the , you can do exactly this, as the following example shows: The preceding example results in the method being called on the method, as the following example shows: public class ExampleBusinessObject { // properties and collaborators public void doIt() { // do the actual work } } By using the , you need not create one-line jobs that merely invoke a method. You need only create the actual business object and wire up the detail object. By default, Quartz Jobs are stateless, resulting in the possibility of jobs interfering with each other. If you specify two triggers for the same , it is possible that the second one starts before the first job has finished. If classes implement the interface, this does not happen: the second job does not start before the first one has finished. To make jobs resulting from the be non-concurrent, set the flag to , as the following example shows: By default, jobs will run in a concurrent fashion. Wiring up Jobs by Using Triggers and We have created job details and jobs. We have also reviewed the convenience bean that lets you invoke a method on a specific object. Of course, we still need to schedule the jobs themselves. This is done by using triggers and a . Several triggers are available within Quartz, and Spring offers two Quartz implementations with convenient defaults: and . Triggers need to be scheduled. Spring offers a that exposes triggers to be set as properties. schedules the actual jobs with those triggers. The following listing uses both a and a : <bean id=\"simpleTrigger\" class=\"org.springframework.scheduling.quartz.SimpleTriggerFactoryBean\"> <!-- see the example of method invoking job above --> <property name=\"jobDetail\" ref=\"jobDetail\"/> <!-- 10 seconds --> <property name=\"startDelay\" value=\"10000\"/> <!-- repeat every 50 seconds --> <property name=\"repeatInterval\" value=\"50000\"/> </bean> <bean id=\"cronTrigger\" class=\"org.springframework.scheduling.quartz.CronTriggerFactoryBean\"> <property name=\"jobDetail\" ref=\"exampleJob\"/> <!-- run every morning at 6 AM --> <property name=\"cronExpression\" value=\"0 0 6 * * ?\"/> </bean> The preceding example sets up two triggers, one running every 50 seconds with a starting delay of 10 seconds and one running every morning at 6 AM. To finalize everything, we need to set up the , as the following example shows: More properties are available for the , such as the calendars used by the job details, properties to customize Quartz with, and a Spring-provided JDBC DataSource. See the javadoc for more information. also recognizes a file in the classpath, based on Quartz property keys, as with regular Quartz configuration. Please note that many settings interact with common Quartz settings in the properties file; it is therefore not recommended to specify values at both levels. For example, do not set an \"org.quartz.jobStore.class\" property if you mean to rely on a Spring-provided DataSource, or specify an variant which is a full-fledged replacement for the standard ."
    },
    {
        "link": "https://spring.io/blog/2020/11/10/new-in-spring-5-3-improved-cron-expressions",
        "document": "Tanzu Spring offers support and binaries for OpenJDK™, Spring, and Apache Tomcat® in one simple subscription."
    },
    {
        "link": "https://stackoverflow.com/questions/42217691/how-to-scheduling-multiple-task-through-cron-expression-using-springboot",
        "document": "I want to schedules multiple task using @schedule annotation using cron expression. I have three job which require to execute at fixed time. For example,Job-1 has been schedule every day at 11:PM, Job-2 has been scheduled every day 7AM-9PM in 1 hour interval and Job-3 has been schedule in every 1 hour. All the 3 schedule tasks are part of the same application.\n\nI have tried the same but all three scheduling is not happening. My application is SpringBoot application.I am not new scheduling.Kindly help me out. Below is he my approach"
    },
    {
        "link": "https://spring.io/guides/gs/scheduling-tasks",
        "document": "How to Complete This Guide Like most Spring Getting Started guides you can start from scratch and complete each step, or you can jump straight to the solution, by viewing the code in this repository. To see the end result in your local environment, you can do one of the following:\n• Download and unzip the source repository for this guide\n• Fork the repository which let you request changes to this guide through submission of a pull request\n\nYou can use this pre-initialized project and click Generate to download a ZIP file. This project is configured to fit the examples in this guide.\n• Navigate to https://start.spring.io. This service pulls in all the dependencies you need for an application and does most of the setup for you.\n• Choose either Gradle or Maven and the language you want to use. This guide assumes that you chose Java and Gradle.\n• Download the resulting ZIP file, which is an archive of an application that is configured with your choices. If your IDE has the Spring Initializr integration, you can complete this process from your IDE.\n\nAlthough scheduled tasks can be embedded in web applications, the simpler approach (shown in this guide) creates a standalone application. To do so, package everything in a single, executable JAR file, driven by a Java main() method. The following snippet (from ) shows the application class: Spring Initializr adds the annotation to our main class. is a convenience annotation that adds all of the following:\n• : Tags the class as a source of bean definitions for the application context.\n• : Spring Boot attempts to automatically configure your Spring application based on the dependencies that you have added.\n• : Tells Spring to look for other components, configurations, and services. If specific packages are not defined, recursive scanning begins with the package of the class that declares the annotation.\n\nYou should now be able to run the application by executing the main method in . You can run the program from your IDE, or by executing the following Gradle command in the project root directory: Doing so starts the application, and the method annotated with @Scheduled runs. You should see log messages similar to: 20yy-mm-ddT07:23:01.665-04:00 INFO 19633 --- [ scheduling-1] c.e.schedulingtasks.ScheduledTasks : The time is now 07:23:01 20yy-mm-ddT07:23:06.663-04:00 INFO 19633 --- [ scheduling-1] c.e.schedulingtasks.ScheduledTasks : The time is now 07:23:06 20yy-mm-ddT07:23:11.663-04:00 INFO 19633 --- [ scheduling-1] c.e.schedulingtasks.ScheduledTasks : The time is now 07:23:11 This example uses scheduling, so the application runs indefinitely until you interrupt it manually."
    },
    {
        "link": "https://stackoverflow.com/questions/40929161/spring-boot-one-scheduled-task-using-multiple-cron-expressions-from-yaml-file",
        "document": "I like to have an implementation of one job using different configuration properties of file.\n\nMeans in my yaml file I describe the as a list:\n\nI read those values out using Configuration and created a named :\n\nIn my Job class I want to start the execution of one method but for both of the schedules in my configuration.\n\nWith this solution the application creates an error: (more or less clear)\n\nIs there a way to configure the same scheduled job method with multiple declarations of cron expressions?\n\nAfter some try I just used a second annotation on the executer method.\n\nThis solution works but is not really dynamic. Is there also a way to make this dynamic?"
    },
    {
        "link": "https://medium.com/@bectorhimanshu/how-to-create-a-scheduled-task-using-a-cron-job-in-spring-boot-a1987e679d60",
        "document": "In many applications, there’s a need to execute certain tasks at specified intervals. Spring Boot provides a convenient way to achieve this by scheduling tasks using a cron expression. A cron expression is a string representing a schedule based on time.\n\nIn this tutorial, we’ll walk through the steps to create a service class that performs a task at regular intervals using a cron job in Spring Boot.\n\nStart by creating a service class named ‘DemoService’ that will contain the logic for the task you want to execute.\n\nIn this example, we’ll create a simple service class with a method that prints a message."
    }
]