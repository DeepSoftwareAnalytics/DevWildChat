[
    {
        "link": "https://legacy.reactjs.org/docs/hooks-reference.html",
        "document": "Hooks are a new addition in React 16.8. They let you use state and other React features without writing a class.\n\nThis page describes the APIs for the built-in Hooks in React.\n\nIf you’re new to Hooks, you might want to check out the overview first. You may also find useful information in the frequently asked questions section.\n\nReturns a stateful value, and a function to update it.\n\nDuring the initial render, the returned state ( ) is the same as the value passed as the first argument ( ).\n\nThe function is used to update the state. It accepts a new state value and enqueues a re-render of the component.\n\nDuring subsequent re-renders, the first value returned by will always be the most recent state after applying updates.\n\nIf the new state is computed using the previous state, you can pass a function to . The function will receive the previous value, and return an updated value. Here’s an example of a counter component that uses both forms of :\n\nThe ”+” and ”-” buttons use the functional form, because the updated value is based on the previous value. But the “Reset” button uses the normal form, because it always sets the count back to the initial value.\n\nIf your update function returns the exact same value as the current state, the subsequent rerender will be skipped completely.\n\nThe argument is the state used during the initial render. In subsequent renders, it is disregarded. If the initial state is the result of an expensive computation, you may provide a function instead, which will be executed only on the initial render:\n\nIf you update a State Hook to the same value as the current state, React will bail out without rendering the children or firing effects. (React uses the comparison algorithm.)\n\nNote that React may still need to render that specific component again before bailing out. That shouldn’t be a concern because React won’t unnecessarily go “deeper” into the tree. If you’re doing expensive calculations while rendering, you can optimize them with .\n\nReact may group several state updates into a single re-render to improve performance. Normally, this improves performance and shouldn’t affect your application’s behavior.\n\nBefore React 18, only updates inside React event handlers were batched. Starting with React 18, batching is enabled for all updates by default. Note that React makes sure that updates from several different user-initiated events — for example, clicking a button twice — are always processed separately and do not get batched. This prevents logical mistakes.\n\nIn the rare case that you need to force the DOM update to be applied synchronously, you may wrap it in . However, this can hurt performance so do this only where needed.\n\nMutations, subscriptions, timers, logging, and other side effects are not allowed inside the main body of a function component (referred to as React’s render phase). Doing so will lead to confusing bugs and inconsistencies in the UI.\n\nInstead, use . The function passed to will run after the render is committed to the screen. Think of effects as an escape hatch from React’s purely functional world into the imperative world.\n\nBy default, effects run after every completed render, but you can choose to fire them only when certain values have changed.\n\nOften, effects create resources that need to be cleaned up before the component leaves the screen, such as a subscription or timer ID. To do this, the function passed to may return a clean-up function. For example, to create a subscription:\n\nThe clean-up function runs before the component is removed from the UI to prevent memory leaks. Additionally, if a component renders multiple times (as they typically do), the previous effect is cleaned up before executing the next effect. In our example, this means a new subscription is created on every update. To avoid firing an effect on every update, refer to the next section.\n\nUnlike and , the function passed to fires after layout and paint, during a deferred event. This makes it suitable for the many common side effects, like setting up subscriptions and event handlers, because most types of work shouldn’t block the browser from updating the screen.\n\nHowever, not all effects can be deferred. For example, a DOM mutation that is visible to the user must fire synchronously before the next paint so that the user does not perceive a visual inconsistency. (The distinction is conceptually similar to passive versus active event listeners.) For these types of effects, React provides one additional Hook called . It has the same signature as , and only differs in when it is fired.\n\nAdditionally, starting in React 18, the function passed to will fire synchronously before layout and paint when it’s the result of a discrete user input such as a click, or when it’s the result of an update wrapped in . This behavior allows the result of the effect to be observed by the event system, or by the caller of .\n\nEven in cases where is deferred until after the browser has painted, it’s guaranteed to fire before any new renders. React will always flush a previous render’s effects before starting a new update.\n\nThe default behavior for effects is to fire the effect after every completed render. That way an effect is always recreated if one of its dependencies changes.\n\nHowever, this may be overkill in some cases, like the subscription example from the previous section. We don’t need to create a new subscription on every update, only if the prop has changed.\n\nTo implement this, pass a second argument to that is the array of values that the effect depends on. Our updated example now looks like this:\n\nNow the subscription will only be recreated when changes.\n\nThe array of dependencies is not passed as arguments to the effect function. Conceptually, though, that’s what they represent: every value referenced inside the effect function should also appear in the dependencies array. In the future, a sufficiently advanced compiler could create this array automatically.\n\nAccepts a context object (the value returned from ) and returns the current context value for that context. The current context value is determined by the prop of the nearest above the calling component in the tree.\n\nWhen the nearest above the component updates, this Hook will trigger a rerender with the latest context passed to that provider. Even if an ancestor uses or , a rerender will still happen starting at the component itself using .\n\nDon’t forget that the argument to must be the context object itself:\n\nA component calling will always re-render when the context value changes. If re-rendering the component is expensive, you can optimize it by using memoization.\n\nPutting it together with Context.Provider\n\nThis example is modified for hooks from a previous example in the Context Advanced Guide, where you can find more information about when and how to use Context.\n\nThe following Hooks are either variants of the basic ones from the previous section, or only needed for specific edge cases. Don’t stress about learning them up front.\n\nAn alternative to . Accepts a reducer of type , and returns the current state paired with a method. (If you’re familiar with Redux, you already know how this works.)\n\nis usually preferable to when you have complex state logic that involves multiple sub-values or when the next state depends on the previous one. also lets you optimize performance for components that trigger deep updates because you can pass down instead of callbacks.\n\nHere’s the counter example from the section, rewritten to use a reducer:\n\nThere are two different ways to initialize state. You may choose either one depending on the use case. The simplest way is to pass the initial state as a second argument:\n\nYou can also create the initial state lazily. To do this, you can pass an function as the third argument. The initial state will be set to .\n\nIt lets you extract the logic for calculating the initial state outside the reducer. This is also handy for resetting the state later in response to an action:\n\nIf you return the same value from a Reducer Hook as the current state, React will bail out without rendering the children or firing effects. (React uses the comparison algorithm.)\n\nNote that React may still need to render that specific component again before bailing out. That shouldn’t be a concern because React won’t unnecessarily go “deeper” into the tree. If you’re doing expensive calculations while rendering, you can optimize them with .\n\nPass an inline callback and an array of dependencies. will return a memoized version of the callback that only changes if one of the dependencies has changed. This is useful when passing callbacks to optimized child components that rely on reference equality to prevent unnecessary renders (e.g. ).\n\nPass a “create” function and an array of dependencies. will only recompute the memoized value when one of the dependencies has changed. This optimization helps to avoid expensive calculations on every render.\n\nRemember that the function passed to runs during rendering. Don’t do anything there that you wouldn’t normally do while rendering. For example, side effects belong in , not .\n\nIf no array is provided, a new value will be computed on every render.\n\nYou may rely on as a performance optimization, not as a semantic guarantee. In the future, React may choose to “forget” some previously memoized values and recalculate them on next render, e.g. to free memory for offscreen components. Write your code so that it still works without — and then add it to optimize performance.\n\nreturns a mutable ref object whose property is initialized to the passed argument ( ). The returned object will persist for the full lifetime of the component.\n\nA common use case is to access a child imperatively:\n\nEssentially, is like a “box” that can hold a mutable value in its property.\n\nYou might be familiar with refs primarily as a way to access the DOM. If you pass a ref object to React with , React will set its property to the corresponding DOM node whenever that node changes.\n\nHowever, is useful for more than the attribute. It’s handy for keeping any mutable value around similar to how you’d use instance fields in classes.\n\nThis works because creates a plain JavaScript object. The only difference between and creating a object yourself is that will give you the same ref object on every render.\n\nKeep in mind that doesn’t notify you when its content changes. Mutating the property doesn’t cause a re-render. If you want to run some code when React attaches or detaches a ref to a DOM node, you may want to use a callback ref instead.\n\ncustomizes the instance value that is exposed to parent components when using . As always, imperative code using refs should be avoided in most cases. should be used with :\n\nIn this example, a parent component that renders would be able to call .\n\nThe signature is identical to , but it fires synchronously after all DOM mutations. Use this to read layout from the DOM and synchronously re-render. Updates scheduled inside will be flushed synchronously, before the browser has a chance to paint.\n\nPrefer the standard when possible to avoid blocking visual updates.\n\ncan be used to display a label for custom hooks in React DevTools.\n\nFor example, consider the custom Hook described in “Building Your Own Hooks”:\n\nIn some cases formatting a value for display might be an expensive operation. It’s also unnecessary unless a Hook is actually inspected.\n\nFor this reason accepts a formatting function as an optional second parameter. This function is only called if the Hooks are inspected. It receives the debug value as a parameter and should return a formatted display value.\n\nFor example a custom Hook that returned a value could avoid calling the function unnecessarily by passing the following formatter:\n\naccepts a value and returns a new copy of the value that will defer to more urgent updates. If the current render is the result of an urgent update, like user input, React will return the previous value and then render the new value after the urgent render has completed.\n\nThis hook is similar to user-space hooks which use debouncing or throttling to defer updates. The benefits to using is that React will work on the update as soon as other work finishes (instead of waiting for an arbitrary amount of time), and like , deferred values can suspend without triggering an unexpected fallback for existing content.\n\nonly defers the value that you pass to it. If you want to prevent a child component from re-rendering during an urgent update, you must also memoize that component with or :\n\nMemoizing the children tells React that it only needs to re-render them when changes and not when changes. This caveat is not unique to , and it’s the same pattern you would use with similar hooks that use debouncing or throttling.\n\nReturns a stateful value for the pending state of the transition, and a function to start it.\n\nlets you mark updates in the provided callback as transitions:\n\nindicates when a transition is active to show a pending state:\n\nis a hook for generating unique IDs that are stable across the server and client, while avoiding hydration mismatches.\n\nFor a basic example, pass the directly to the elements that need it:\n\nFor multiple IDs in the same component, append a suffix using the same :\n\nThe following Hooks are provided for library authors to integrate libraries deeply into the React model, and are not typically used in application code.\n\nis a hook recommended for reading and subscribing from external data sources in a way that’s compatible with concurrent rendering features like selective hydration and time slicing.\n\nThis method returns the value of the store and accepts three arguments:\n• : function to register a callback that is called whenever the store changes.\n• : function that returns the current value of the store.\n• : function that returns the snapshot used during server rendering.\n\nThe most basic example simply subscribes to the entire store:\n\nHowever, you can also subscribe to a specific field:\n\nWhen server rendering, you must serialize the store value used on the server, and provide it to . React will use this snapshot during hydration to prevent server mismatches:\n\nThe signature is identical to , but it fires synchronously before all DOM mutations. Use this to inject styles into the DOM before reading layout in . Since this hook is limited in scope, this hook does not have access to refs and cannot schedule updates."
    },
    {
        "link": "https://react.dev/reference/react/useState",
        "document": "Suppose the is . This handler calls three times: However, after one click, will only be rather than ! This is because calling the function does not update the state variable in the already running code. So each call becomes . To solve this problem, you may pass an updater function to instead of the next state: Here, is your updater function. It takes the pending state and calculates the next state from it. React puts your updater functions in a queue. Then, during the next render, it will call them in the same order:\n• will receive as the pending state and return as the next state.\n• will receive as the pending state and return as the next state.\n• will receive as the pending state and return as the next state. There are no other queued updates, so React will store as the current state in the end. By convention, it’s common to name the pending state argument for the first letter of the state variable name, like for . However, you may also call it like or something else that you find clearer. React may call your updaters twice in development to verify that they are pure. You might hear a recommendation to always write code like if the state you’re setting is calculated from the previous state. There is no harm in it, but it is also not always necessary. In most cases, there is no difference between these two approaches. React always makes sure that for intentional user actions, like clicks, the state variable would be updated before the next click. This means there is no risk of a click handler seeing a “stale” at the beginning of the event handler. However, if you do multiple updates within the same event, updaters can be helpful. They’re also helpful if accessing the state variable itself is inconvenient (you might run into this when optimizing re-renders). If you prefer consistency over slightly more verbose syntax, it’s reasonable to always write an updater if the state you’re setting is calculated from the previous state. If it’s calculated from the previous state of some other state variable, you might want to combine them into one object and use a reducer.\n\nReact saves the initial state once and ignores it on the next renders. Although the result of is only used for the initial render, you’re still calling this function on every render. This can be wasteful if it’s creating large arrays or performing expensive calculations. To solve this, you may pass it as an initializer function to instead: Notice that you’re passing , which is the function itself, and not , which is the result of calling it. If you pass a function to , React will only call it during initialization. React may call your initializers twice in development to verify that they are pure.\n\nUsually, you will update state in event handlers. However, in rare cases you might want to adjust state in response to rendering — for example, you might want to change a state variable when a prop changes. In most cases, you don’t need this:\n• If the value you need can be computed entirely from the current props or other state, remove that redundant state altogether. If you’re worried about recomputing too often, the Hook can help.\n• If you want to reset the entire component tree’s state, pass a different to your component.\n• If you can, update all the relevant state in the event handlers. In the rare case that none of these apply, there is a pattern you can use to update state based on the values that have been rendered so far, by calling a function while your component is rendering. Here’s an example. This component displays the prop passed to it: Say you want to show whether the counter has increased or decreased since the last change. The prop doesn’t tell you this — you need to keep track of its previous value. Add the state variable to track it. Add another state variable called to hold whether the count has increased or decreased. Compare with , and if they’re not equal, update both and . Now you can show both the current count prop and how it has changed since the last render.\n\nNote that if you call a function while rendering, it must be inside a condition like , and there must be a call like inside of the condition. Otherwise, your component would re-render in a loop until it crashes. Also, you can only update the state of the currently rendering component like this. Calling the function of another component during rendering is an error. Finally, your call should still update state without mutation — this doesn’t mean you can break other rules of pure functions. This pattern can be hard to understand and is usually best avoided. However, it’s better than updating state in an effect. When you call the function during render, React will re-render that component immediately after your component exits with a statement, and before rendering the children. This way, children don’t need to render twice. The rest of your component function will still execute (and the result will be thrown away). If your condition is below all the Hook calls, you may add an early to restart rendering earlier. Calling the function does not change state in the running code: This is because states behaves like a snapshot. Updating state requests another render with the new state value, but does not affect the JavaScript variable in your already-running event handler. If you need to use the next state, you can save it in a variable before passing it to the function: React will ignore your update if the next state is equal to the previous state, as determined by an comparison. This usually happens when you change an object or an array in state directly: You mutated an existing object and passed it back to , so React ignored the update. To fix this, you need to ensure that you’re always replacing objects and arrays in state instead of mutating them: I’m getting an error: “Too many re-renders” You might get an error that says: Too many re-renders. React limits the number of renders to prevent an infinite loop. Typically, this means that you’re unconditionally setting state during render, so your component enters a loop: render, set state (which causes a render), render, set state (which causes a render), and so on. Very often, this is caused by a mistake in specifying an event handler: If you can’t find the cause of this error, click on the arrow next to the error in the console and look through the JavaScript stack to find the specific function call responsible for the error. In Strict Mode, React will call some of your functions twice instead of once: This is expected and shouldn’t break your code. This development-only behavior helps you keep components pure. React uses the result of one of the calls, and ignores the result of the other call. As long as your component, initializer, and updater functions are pure, this shouldn’t affect your logic. However, if they are accidentally impure, this helps you notice the mistakes. For example, this impure updater function mutates an array in state: Because React calls your updater function twice, you’ll see the todo was added twice, so you’ll know that there is a mistake. In this example, you can fix the mistake by replacing the array instead of mutating it: Now that this updater function is pure, calling it an extra time doesn’t make a difference in behavior. This is why React calling it twice helps you find mistakes. Only component, initializer, and updater functions need to be pure. Event handlers don’t need to be pure, so React will never call your event handlers twice. I’m trying to set state to a function, but it gets called instead You can’t put a function into state like this: Because you’re passing a function, React assumes that is an initializer function, and that is an updater function, so it tries to call them and store the result. To actually store a function, you have to put before them in both cases. Then React will store the functions you pass."
    },
    {
        "link": "https://telerik.com/blogs/guide-new-hooks-react-18",
        "document": "In this blog post, we won’t just describe what React hooks do, but we’ll also get our hands dirty and cover how to use them in the code.\n\nReact 18 is a major release that comes with new features, such as concurrent rendering, automated batching, transitions, new APIs and hooks. In this tutorial, we will cover the five new hooks that arrived in React 18:\n\nHowever, instead of just describing what they do and how to use them, we will get our hands dirty and cover how to actually use them in the code. For that, we will create contrived state management and CSS-in-JS solutions. Let’s dive in!\n\nYou can find full code examples for this project in this GitHub repository. Below you can also find an interactive StackBlitz.\n\nIf you would like to follow this tutorial, you can quickly scaffold a new React project using Vite by running the command below:\n\nAfter the project is scaffolded, move into it, install all libraries and start the dev server.\n\nWe will use Tailwind for styles, but instead of going through the whole setup process, we will take advantage of the CDN version. Just update the file and add the script below.\n\nThat’s it for the setup. Let’s have a look at the first new hook— .\n\nThe times when React ran only on client-side are long gone. With frameworks like Next.js, Gatsby or Remix and new features like server components, React is used on both client- and server-side.\n\nUntil version 18, React did not offer any good way to generate unique IDs that could be used for server- and client-rendered content. The important thing to remember is that the HTML markup that was rendered on the client should match the one rendered on the server. Otherwise, you will be welcomed with a React server hydration mismatch error.\n\nHere’s a situation in which it could happen: Let’s say we have a form with an input field for which we need to generate a unique id.\n\nThe component above would have ids generated once on the server, and new ones would be generated on the client-side. This would result in a mismatch in the DOM. That’s where the hook comes into play.\n\nThe hook can be used to generate unique IDs that will be the same on the server- and client-side and thus help to avoid the mismatch error.\n\nIf we have more fields than one, we can always use string interpolation and add a prefix or a suffix to the unique id. You can create a new file called with the code below.\n\nNext, update the component to render the .\n\nThe image below shows what you should see. React generates a unique id with a colon as a prefix and suffix.\n\nWith the new concurrent renderer, React can interrupt and pause renders. This means that if a new high-priority render is scheduled, React can stop the current low-priority rendering process and handle the upcoming one first.\n\nA high-priority render could be caused by a user’s click or input. React provides two new React hooks that can be used to indicate low-priority updates— and . This provides a new way of optimizing React apps, as developers can now specify which state updates are low priority.\n\nFirst, let’s have a look at the hook. Below we have a simple feature that allows a user to search for meals.\n\nWhen a user types something into the query input, the state is updated. However, instead of passing it directly to the component, it is passed to the hook instead. The hook returns a value, which then is passed to the component. We let React decide when exactly should the state change to the latest value.\n\nNote that the component is wrapped with to make sure it only re-renders when changes and not . The hook is similar to how bouncing or throttling works, but the difference is that instead of waiting until a specified amount of time has passed, React can start the work immediately when it’s done with higher priority work.\n\nNow we need to add the component in the file.\n\nThe GIF below shows what the search functionality should look like.\n\nNext, let’s have a look at the hook.\n\nThe hook is quite similar to , but we have more control over when to start a low-priority update. The hook returns a tuple with the value that indicates whether a transition is currently happening and the method.\n\nLet’s replace the hook from our previous example and use the hook instead.\n\nInstead of having a deferred state for the value, we wrap the update with the instead.\n\nIf React would be in the middle of processing the update but a higher priority update, like a user click, would be scheduled, the update would be paused.\n\nThe is a hook that was created for state management libraries. Its purpose is to provide an ability to read and subscribe from external data sources in a way that works with concurrent rendering features like selective hydration and time slicing.\n\nAn external store needs to provide at least two arguments—subscribe and get state snapshot methods. The former allows React to subscribe to any store changes, and the latter returns the store state. Here’s a simple example of how to use the hook.\n\nThe method returns the whole external state, but we can also pass a function that returns only a part of it. For instance, if the store has a field called , we could get just the value from the store state.\n\nThe can also accept a third argument, which can be used to provide a state snapshot that was created if the React app was server-side rendered. We won’t be diving into it in this article, as server-side rendering comes with its own rules and setup that is out of the scope for this article.\n\nThat’s a nice explanation so far, but how could we use it in practice? Fortunately, creating a state management library doesn’t necessarily have to be extremely complicated, and Zustand is a good example of that. Here’s a mini Zustand implementation utilizing the hook.\n\nFirst, we need store creation logic.\n\nThe creates a new state and a few methods:\n• – adds a new listener that will be notified when the state changes\n• – updates the state in an immutable way by utilizing immer and notifies all subscribers\n• – a wrapper around that can be used to consume the store state\n\nNow we can use the method to create a new store. Below, we create a count store with methods to increment, decrement, divide and multiply the count.\n\nFinally, add the component in the file.\n\nHere’s how our implementation looks in action.\n\nNote that the store creation code isn’t really optimized, so if you like this approach to an using external state, just use the Zustand library.\n\nThe should only be used by CSS-in-JS libraries to dynamically insert styles into the DOM. This hook has an identical signature to , but it runs synchronously before all DOM mutations. Thus, if you’re not injecting any CSS styles into the DOM, you shouldn’t use it.\n\nI wondered whether I should create a practical example of how to use the since I never really looked under the hood of CSS-in-JS libraries, but here it is. A naive, contrived and totally unoptimized CSS-in-JS implementation—meaning don’t use it at home.\n\nFirst, we have the hook that accepts an object with styles and props.\n\nIn the , a unique hashed class name is generated for each object style property, and the object with styles is converted to a CSS string using the library. Each rule is pushed into the array.\n\nIn the , we create a new element, loop through the style rules and insert each of them into the stylesheet.\n\nLast but not least, the stylesheet is removed from the DOM in the cleanup function.\n\nNow we can use our hook, so create a new file called and copy the code below into it.\n\nWe have the object with styles for the buttons that are then passed to the hook. The hook returns an object with classes that look something like this:\n\nThe class is passed to a element, while the class to and buttons.\n\nThe state changes every time one of the buttons is clicked. When that happens, the old styles are removed, and new ones are created and inserted into the DOM again inside of the .\n\nNext, we need to render the component.\n\nThe GIF below shows what the should look like.\n\nWe have covered the new hooks that were added in React 18. Interestingly enough, you might actually find yourself not using any of them.\n\nand are specifically designed for library authors who work on state management and CSS-in-JS solutions. The hook is useful if your React app runs on both client and server, so if your React app runs only on the client-side, you won’t really need it.\n\nFurthermore, and can be used to mark some state updates as less important and defer, but this isn’t something that all applications will necessarily need.\n\nNevertheless, all of these hooks are a great addition, and I can’t wait to see what else React will bring in the future. If you would like to read more about React 18, make sure to read the official blog page that covers new features."
    },
    {
        "link": "https://react.dev/reference/react/hooks",
        "document": "State lets a component “remember” information like user input. For example, a form component can use state to store the input value, while an image gallery component can use state to store the selected image index.\n\nTo add state to a component, use one of these Hooks:\n• declares a state variable that you can update directly.\n\nContext lets a component receive information from distant parents without passing it as props. For example, your app’s top-level component can pass the current UI theme to all components below, no matter how deep.\n\nRefs let a component hold some information that isn’t used for rendering, like a DOM node or a timeout ID. Unlike with state, updating a ref does not re-render your component. Refs are an “escape hatch” from the React paradigm. They are useful when you need to work with non-React systems, such as the built-in browser APIs.\n• declares a ref. You can hold any value in it, but most often it’s used to hold a DOM node.\n• lets you customize the ref exposed by your component. This is rarely used.\n\nEffects let a component connect to and synchronize with external systems. This includes dealing with network, browser DOM, animations, widgets written using a different UI library, and other non-React code.\n\nEffects are an “escape hatch” from the React paradigm. Don’t use Effects to orchestrate the data flow of your application. If you’re not interacting with an external system, you might not need an Effect.\n\nThere are two rarely used variations of with differences in timing:\n• fires before the browser repaints the screen. You can measure layout here.\n• fires before React makes changes to the DOM. Libraries can insert dynamic CSS here.\n\nA common way to optimize re-rendering performance is to skip unnecessary work. For example, you can tell React to reuse a cached calculation or to skip a re-render if the data has not changed since the previous render.\n\nTo skip calculations and unnecessary re-rendering, use one of these Hooks:\n• lets you cache the result of an expensive calculation.\n• lets you cache a function definition before passing it down to an optimized component.\n\nSometimes, you can’t skip re-rendering because the screen actually needs to update. In that case, you can improve performance by separating blocking updates that must be synchronous (like typing into an input) from non-blocking updates which don’t need to block the user interface (like updating a chart).\n\nTo prioritize rendering, use one of these Hooks:\n• lets you mark a state transition as non-blocking and allow other updates to interrupt it.\n• lets you defer updating a non-critical part of the UI and let other parts update first.\n\nThese Hooks are mostly useful to library authors and aren’t commonly used in the application code.\n• lets you customize the label React DevTools displays for your custom Hook.\n• lets a component associate a unique ID with itself. Typically used with accessibility APIs.\n• allows you to manage state of actions.\n\nYou can also define your own custom Hooks as JavaScript functions."
    },
    {
        "link": "https://legacy.reactjs.org/docs/hooks-state.html",
        "document": "Hooks are a new addition in React 16.8. They let you use state and other React features without writing a class.\n\nThe introduction page used this example to get familiar with Hooks:\n\nWe’ll start learning about Hooks by comparing this code to an equivalent class example.\n\nIf you used classes in React before, this code should look familiar:\n\nThe state starts as , and we increment when the user clicks a button by calling . We’ll use snippets from this class throughout the page.\n\nAs a reminder, function components in React look like this:\n\nYou might have previously known these as “stateless components”. We’re now introducing the ability to use React state from these, so we prefer the name “function components”.\n\nHooks don’t work inside classes. But you can use them instead of writing classes.\n\nOur new example starts by importing the Hook from React:\n\nWhat is a Hook? A Hook is a special function that lets you “hook into” React features. For example, is a Hook that lets you add React state to function components. We’ll learn other Hooks later.\n\nWhen would I use a Hook? If you write a function component and realize you need to add some state to it, previously you had to convert it to a class. Now you can use a Hook inside the existing function component. We’re going to do that right now!\n\nIn a class, we initialize the state to by setting to in the constructor:\n\nIn a function component, we have no , so we can’t assign or read . Instead, we call the Hook directly inside our component:\n\nWhat does calling do? It declares a “state variable”. Our variable is called but we could call it anything else, like . This is a way to “preserve” some values between the function calls — is a new way to use the exact same capabilities that provides in a class. Normally, variables “disappear” when the function exits but state variables are preserved by React.\n\nWhat do we pass to as an argument? The only argument to the Hook is the initial state. Unlike with classes, the state doesn’t have to be an object. We can keep a number or a string if that’s all we need. In our example, we just want a number for how many times the user clicked, so pass as initial state for our variable. (If we wanted to store two different values in state, we would call twice.)\n\nWhat does return? It returns a pair of values: the current state and a function that updates it. This is why we write . This is similar to and in a class, except you get them in a pair. If you’re not familiar with the syntax we used, we’ll come back to it at the bottom of this page.\n\nNow that we know what the Hook does, our example should make more sense:\n\nWe declare a state variable called , and set it to . React will remember its current value between re-renders, and provide the most recent one to our function. If we want to update the current , we can call .\n\nWhen we want to display the current count in a class, we read :\n\nIn a function, we can use directly:\n\nIn a class, we need to call to update the state:\n\nIn a function, we already have and as variables so we don’t need :\n\nLet’s now recap what we learned line by line and check our understanding.\n• Line 1: We import the Hook from React. It lets us keep local state in a function component.\n• Line 4: Inside the component, we declare a new state variable by calling the Hook. It returns a pair of values, to which we give names. We’re calling our variable because it holds the number of button clicks. We initialize it to zero by passing as the only argument. The second returned item is itself a function. It lets us update the so we’ll name it .\n• Line 9: When the user clicks, we call with a new value. React will then re-render the component, passing the new value to it.\n\nThis might seem like a lot to take in at first. Don’t rush it! If you’re lost in the explanation, look at the code above again and try to read it from top to bottom. We promise that once you try to “forget” how state works in classes, and look at this code with fresh eyes, it will make sense.\n\nTip: What Do Square Brackets Mean?\n\nYou might have noticed the square brackets when we declare a state variable:\n\nThe names on the left aren’t a part of the React API. You can name your own state variables:\n\nThis JavaScript syntax is called “array destructuring”. It means that we’re making two new variables and , where is set to the first value returned by , and is the second. It is equivalent to this code:\n\nWhen we declare a state variable with , it returns a pair — an array with two items. The first item is the current value, and the second is a function that lets us update it. Using and to access them is a bit confusing because they have a specific meaning. This is why we use array destructuring instead.\n\nDeclaring state variables as a pair of is also handy because it lets us give different names to different state variables if we want to use more than one:\n\nIn the above component, we have , , and as local variables, and we can update them individually:\n\nYou don’t have to use many state variables. State variables can hold objects and arrays just fine, so you can still group related data together. However, unlike in a class, updating a state variable always replaces it instead of merging it.\n\nWe provide more recommendations on splitting independent state variables in the FAQ.\n\nOn this page we’ve learned about one of the Hooks provided by React, called . We’re also sometimes going to refer to it as the “State Hook”. It lets us add local state to React function components — which we did for the first time ever!\n\nWe also learned a little bit more about what Hooks are. Hooks are functions that let you “hook into” React features from function components. Their names always start with , and there are more Hooks we haven’t seen yet.\n\nNow let’s continue by learning the next Hook: . It lets you perform side effects in components, and is similar to lifecycle methods in classes."
    },
    {
        "link": "https://axios-http.com/docs/intro",
        "document": "Promise based HTTP client for the browser and node.js\n\nAxios is a promise-based HTTP Client for and the browser. It is isomorphic (= it can run in the browser and nodejs with the same codebase). On the server-side it uses the native node.js module, while on the client (browser) it uses XMLHttpRequests.\n• Progress capturing for browsers and node.js with extra info (speed rate, remaining time)\n\nPrebuilt CommonJS modules for direct importing with require (if your module bundler failed to resolve them automatically)"
    },
    {
        "link": "https://circleci.com/blog/making-http-requests-with-axios",
        "document": "Axios is a promise-based HTTP library that lets developers make requests to either their own server or a third-party server to fetch data. It offers different ways of making requests such as , , , and .\n\nIn this tutorial, you will learn how Axios interacts with applications, how Axios structures requests and responses, and how to use Axios to make requests to an API. You’ll also learn how to write tests for your Axios requests and how to automate them with CircleCI for fast, seamless feedback on your changes.\n\nTo follow along with the tutorial, make sure that you have:\n\nAxios helps developers make HTTP requests from NodeJS or XMLHttpRequests from a browser. If the request is successful, you will receive a with the data requested. If the request fails, you will get an error. You can also the requests and responses and transform or modify them. I will go into more detail about that later in this tutorial.\n\nThis diagram represents how Axios interacts with an application.\n\nAxios is able to determine whether the request is made from the browser or from NodeJS. Once this is established, it then identifies the proper way to make the API requests and returns a transformed response back to the client that made the request.\n\nMaking a basic request in Axios is easy because the only option required is the . However, you can configure other options depending on the kind of request that you want to make.\n\nHere is an example request:\n\nThe first example uses for a simple GET request where you can add additional configurations. The second example uses the full method, allowing you to specify more options such as the request method, URL, and parameters.\n\nAxios provides great flexibility to configure your requests. You can decide to call Axios with the JavaScript dot notation format. Or you can use the object literal format to bundle all the Axios request properties into an object that can be used as properties of making the Axios request.\n\nThere are several methods that Axios supports for making requests. They include:\n\nHere’s another code snippet that shows how to make a simple request sent to a sample API using Axios.\n\nOnce you send a request with Axios, you expect to have a response returned. This snippet shows the data structure of an Axios response:\n\nIn this response, you get an object of the data that you are expecting, the status code sent back by the server, a , response headers, the config object set by Axios, and the request object that was used to generate the response. You can then consume the responses on your client-side application depending on the data that you need.\n\nNow that you’ve mastered some of the background, move on to the next section where I will show you exactly how to make HTTP requests with Axios.\n\nIn this section, you will make and requests and observe concurrent requests. You will be using a free “fake” API: JSONPlaceholder.\n\nYou will also use an application that will help you make your requests and get a better view of what is happening under the hood.\n\nBefore you get started though, you need to clone the GitHub repository for the tutorial. Run these commands:\n\nNow you should have the files you need for this tutorial. Your next step is to install both Axios and Jest as dependencies. Run this command:\n\nOpen the file on the browser to review your Axios demo webpage.\n\nThere are three buttons for each request. Clicking a button should display a response after the Axios request has been made and data returned to the browser.\n\nIn the file of your cloned repository, there is an event listener that displays the data returned by Axios. This file also has functions you will use to make your requests. Get started by making your first request.\n\nA basic request to our sample API looks like this:\n\nThis code snippet sends a request to the JSON API. Because the request returns a promise, we use the block to handle the responses. We also need to use the method to log any errors to the console.\n\nThis code snippet is already in the function in the file.\n\nNow that you understand what is happening behind the scenes, go to the browser and click the button. Below it, new content should appear, displaying details of the response.\n\nThis response from the API is broken into a few sections based on the data we have from Axios. The sections of the received Axios response are:\n• The section, which displays the status code of the response. In this case it is , which means that the request was successful.\n• The section, which contains all the HTTP headers that the server responds with.\n• The section, which contains the payload or the information that was requested from the server. In this case, it is all the information about .\n• The section, which contains all the configuration that was passed to Axios for the request.\n\nAs shown in the request, Axios behaves like the traditional library. Considering that this is a request, you do not need to pass a body with a request. Next I will show you how to do that in a request using Axios.\n\nA request is a little different because you often need to pass some data in the request to the server. In the sample application, we have a request that creates a user and passes in details for that user. The code snippet for the request looks like this:\n\nThe Axios request uses an object after the request URL to define the properties you want to create for your user. Once the operation has been completed, there will be a response from the server. To verify that your code is working, go back to the application browser window and click the POST button. This snippet is part of the function in the file.\n• The section has a status code of , which means a resource has been created. In this case, a new user has been created.\n• The section has a property for the length of the data we sent. It also specifies where the data will be stored: .\n• The section contains the information that was sent to the server.\n• The section contains the configuration that was sent along with the request. This involves the , , and being sent.\n\nYou can verify that the data defined in your request is the exact response received from the server as a created resource.\n\nIn this section, you learned how to make an Axios request, and you explored the basic structure of an Axios request and its the expected responses. In the next section, you will learn how to use request interception to verify data before it is sent to Axios as a request.\n\nIn Axios, requests or responses can be intercepted before they are handled by the or blocks. For example, say you want to check that all the requests going through to a client have a valid JWT token. To do that, you can set up a request interceptor to make sure that all the calls made to the server have that valid token. If a call does not have a valid token, the users of the system would have to go back to the login page and be reauthenticated.\n\nIn the interest of time, I will lead you through a less complicated use case, writing a logger for your current application.\n\nThe logger will log when a request was made, the URL for the request, and the time when the request was triggered. This code snippet is what the sample application uses:\n\nAxios will access the section of your requests to display the request method, URL, and time. This code snippet is part of the file in the function of the sample project.\n\nTo observe the behavior of the Axios interceptor, open the Chrome browser console. Click the method that fetches the first user in the API.\n\nFor the interceptors to work, they need to be called as concurrent requests to the API. The next code snippet shows Axios methods that implement the requests and responses:\n\nThe Chrome DevTools image shows that when you make any request, you can modify or inspect it before it is sent by Axios to the API server. Axios interceptors are not only powerful, but they also give developers the ability to control requests and the behavior of their responses.\n\nNow you have learned how to use interceptors to modify or inspect your Axios requests and responses. Great work! Your next task is writing tests for your Axios implementation.\n\nSoftware testing is an integral process in the development of virtually every application. Tests help make sure your application works as intended and that quality is consistent throughout the development process. In this section of the tutorial, you will use the version of Axios. Since you already installed Jest while installing dependencies, you can start writing tests right away.\n\nIn the root directory, there are two files named and . We use for requests and for tests.\n\nIn the file, we use to make requests in . This method uses the same request structure as the browser method does:\n\nThis snippet makes a request to the same URL used earlier and then saves the response to the variable. It then returns the response to make it accessible to other methods or functions that may need it — like our tests. The snippet exports the method to make it accessible outside the file.\n\nTo write a test for this, we import the method into the test file. Then we write the test as shown here:\n\nUsing this test and the sample response object, you can verify that the data called from the Axios endpoint was in fact returned and that your API call was successful.\n\nIn the same file, we have all three tests:\n\nNow that you understand how the tests work, run them:\n\nNow that you have written Axios requests and tested them, you can build a continuous integration(CI) pipeline for them. Using a CI/CD tool like CircleCI keeps everyone informed when changes break the pipeline and cause the tests to fail. This kind of feedback loop provides the insight and transparency needed in a successful software development process.\n\nThe sample project contains a folder and inside it, a file named . This is CircleCI’s configuration file. In the file, we have the configuration for our project:\n\nThis configuration defines your , then tells CircleCI to use a Node image to execute your tests. Once that is set up, it checks for any stored cache for the project. If there is one, it needs to be restored before doing a new dependencies install. The cache is saved after installing new dependencies, tests are executed, and any artifacts that were generated are saved.\n\nTo run the project in CircleCI, it needs to exist as a repository on your GItHub. First, create an empty repository on GitHub. Next, change the origin URL to your repo:\n\nOnce this is done, log into the CircleCI dashboard. In the Organization homepage, click Create Project. Select GitHub, then pick your project and give it a meaningful name. Finally, click Create Project.\n\nCircleCI will automatically detect your configuration file, but it won’t run the pipeline. To trigger a pipeline build, push a small, meaningless commit.\n\nYou have a successful pipeline build! Review details by clicking Jobs then build.\n\nClick the steps you want more detail about; for example the step.\n\nCircleCI detects changes every time you push to the GitHub repository in your branch. The CircleCI pipeline will execute again and make sure that your test suite runs, ensuring a successful continuous integration process.\n\nI enjoyed creating this tutorial for you, and I hope you found it valuable. Until next time, keep coding!"
    },
    {
        "link": "https://blog.logrocket.com/http-requests-axios",
        "document": "Editor’s note: This article was last updated by Rahul Chhodde on 27 November 2024 to introduce Axios interceptors and how to use them to handle API error responses, as well as to cover how to post a file from a form using Axios.\n\nAxios is a client HTTP API based on the interface provided by browsers. In this tutorial, we’ll demonstrate how to make HTTP requests using Axios with clear examples, including how to make an Axios POST request with , how to send multiple requests simultaneously with , and much more.\n\nIf you’re more of a visual learner, check out the video tutorial below. Note that it is a few years old and may not reflect the most current information:\n\nThe most common way for frontend programs to communicate with servers is through the HTTP protocol. You are probably familiar with the Fetch API and the interface, which allows you to fetch resources and make HTTP requests.\n\nIf you’re using a JavaScript library, chances are it comes with a client HTTP API. jQuery’s function, for example, has been particularly popular with frontend developers. But as developers move away from such libraries in favor of native APIs, dedicated HTTP clients have emerged to fill the gap.\n\nAs with Fetch, Axios is promise-based. However, it provides a more powerful and flexible feature set. Why use Axios over the native Fetch API?\n\nYou can install Axios using the following command for npm, Yarn, and pnpm, respectively:\n\nTo install Axios using a content delivery network (CDN), run the following:\n\nHow to make an Axios POST request\n\nMaking an HTTP request is as easy as passing a config object to the function. You can make a POST request using Axios to “post” data to a given endpoint and trigger events. To perform an HTTP POST request in Axios, call .\n\nMaking a POST request in Axios requires two parameters: the URI of the service endpoint and an object that contains the properties you wish to send to the server.\n\nFor a simple Axios POST request, the config object must have a property. If no method is provided, will be used as the default value.\n\nLet’s look at a simple Axios POST example:\n\nThis should look familiar to those who have worked with jQuery’s function. This code instructs Axios to send a POST request to with an object of key-value pairs as its data. Axios will automatically convert the data to JSON and send it as the request body.\n\nAxios also provides a set of shorthand methods for performing different types of requests. The methods include:\n\nFor example, the following code shows how the previous example could be written using the method:\n\nOnce an HTTP POST request is made, Axios returns a promise that is either fulfilled or rejected, depending on the response from the backend service.\n\nTo handle the result, you can use the method, like this:\n\nIf the promise is fulfilled, the first argument of will be called; if the promise is rejected, the second argument will be called. According to the Axios documentation, the fulfillment value is an object containing the following properties:\n\nAs an example, here’s how the response looks when requesting data from the GitHub API:\n\nUsing Axios with and\n\nThe and syntax is syntactic sugar around the Promise API. It helps you write cleaner, more readable, and maintainable code. With and , your codebase feels synchronous and easier to think about.\n\nWhen using and , you invoke or one of its request methods inside an asynchronous function, like in the example below:\n\nWhen using the and syntax, it’s standard practice to wrap your code in a block. Doing so will ensure you appropriately handle errors and provide feedback for a better user experience.\n\nYou can use Axios with to make multiple requests in parallel by passing an iterable of promises to it. The static method returns a single promise object that fulfills only when all input promises have been fulfilled.\n\nHere’s a simple example of how to use to make simultaneous HTTP requests:\n\nThis code makes two requests to the GitHub API and then logs the value of the property of each response to the console. Keep in mind that if any of the input promises are rejected, the entire promise will immediately be rejected, returning the error from the first promise that encountered a rejection.\n\nSending custom headers with Axios is straightforward. Simply pass an object containing the headers as the last argument. For example:\n\nWhen making a network request to a server, it is not uncommon to experience delays when the server takes too long to respond. It is standard practice to timeout an operation and provide an appropriate error message if a response takes too long. This ensures a better user experience when the server is experiencing downtime or a higher load than usual.\n\nWith Axios, you can use the property of your object to set the waiting time before timing out a network request. Its value is the waiting duration in milliseconds. The request is aborted if Axios doesn’t receive a response within the timeout duration. The default value of the property is milliseconds (no timeout).\n\nYou can check for the error code and take appropriate action when the request times out:\n\nYou can also timeout a network request using the static method. It takes the timeout as an argument in milliseconds and returns an instance. You need to set it as the value of the property.\n\nThe network request aborts when the timeout expires. Axios sets the value of to and to :\n\nAxios automatically serializes JavaScript objects to JSON when passed to the function as the second parameter. This eliminates the need to serialize POST bodies to JSON.\n\nAxios also sets the header to . This enables web frameworks to automatically parse the data:\n\nIf you want to send a preserialized JSON string to JSON, you’ll need to make sure the header is set:\n\nAlthough Axios automatically converts requests and responses to JSON by default, it also allows you to override the default behavior and define a different transformation mechanism. This is particularly useful when working with an API that accepts only a specific data format, such as XML or CSV.\n\nTo change request data before sending it to the server, set the property in the config object. Note that this method only works for , , , and request methods.\n\nHere’s an example of how to use in Axios to transform JSON data into XML data and post it:\n\nTo modify the data before passing it to or , you can set the property. Leveraging both the and , here’s an example that transforms JSON data to CSV, posts it, and then turns the received response into JSON to use on the client:\n\nHTTP interception is a popular feature of Axios. With this feature, you can examine and change HTTP requests from your program to the server and vice versa, which is very useful for a variety of implicit tasks, such as logging and authentication.\n\nAxios interceptors are functions that can be executed before a request is sent or after a response is received through Axios. There are two types of interceptor methods in Axios: request and response.\n\nAt first glance, interceptors look very much like transforms, but they differ in one key way: unlike transforms, which only receive the data and headers as arguments, interceptors receive the entire response object or request config.\n\nYou can declare a request interceptor in Axios like this:\n\nThis code logs a message to the console whenever a request is sent and then waits until it gets a response from the server, at which point it prints the time the account was created at GitHub to the console. One advantage of using interceptors is that you no longer have to implement tasks for each HTTP request separately.\n\nAxios also provides a response interceptor, which allows you to transform the responses from a server on their way back to the application. For example, here’s how to catch errors in an interceptor with Axios:\n\nCross-site request forgery (or XSRF for short) is a method of attacking a web-hosted app in which the attacker disguises themself as a legal and trusted user to influence the interaction between the app and the user’s browser. There are many ways to execute such an attack, including .\n\nFortunately, Axios is designed to protect against XSRF by allowing you to embed additional authentication data when making requests. This enables the server to discover requests from unauthorized locations.\n\nHere’s how this can be done with Axios:\n\nAnother interesting feature of Axios is the ability to monitor request progress. This is especially useful when downloading or uploading large files. The example provided in the Axios documentation gives you a good idea of how that can be done. But for the sake of simplicity and style, we are going to use the Axios Progress Bar module in this tutorial.\n\nThe first thing we need to do to use this module is to include the related style and script:\n\nThen we can implement the progress bar like this:\n\nTo change the default styling of the progress bar, we can override the following style rules:\n\nIn some situations, you may no longer care about the result and want to cancel a request that’s already been sent. This can be done by using . You can create an instance and set its corresponding instance as the value of the property of the config object.\n\nAxios also has a built-in function for canceling requests. However, the built-in functionality is deprecated. You may still encounter it in legacy codebase, but it is not advisable to use it in new projects.\n\nBelow is a basic example:\n\nYou can also create a cancel token by passing an executor function to the constructor, as shown below:\n\nAn HTTP request may succeed or fail. Therefore, it is important to handle errors on the client side and provide appropriate feedback for a better user experience.\n\nPossible causes of error in a network request may include server errors, authentication errors, missing parameters, and requesting non-existent resources.\n\nAxios, by default, rejects any response with a status code that falls outside the successful 2xx range. However, you can modify this feature to specify what range of HTTP codes should throw an error using the config option, like in the example below:\n\nThe error object that Axios passes to the block has several properties, including the following:\n\nIn addition to the properties highlighted above, if the request was made and the server responded with a status code that falls outside the 2xx range, the error object will also have the object.\n\nOn the other hand, if the request was made but no response was received, the error object will have an object. Depending on the environment, the object is an instance of in the browser environment and an instance of in Node.\n\nYou need to check for and objects in your callback to determine the error you are dealing with so that you can take appropriate action:\n\nHow to use Axios interceptors to handle API error responses\n\nSometimes, duplicating the code above in the callback for each request can become tedious and time-consuming. You can instead intercept the error and handle it globally like so:\n\nA more granular, centralized error-handling approach is maintaining the API globally and managing all response and request errors with a dedicated handler function.\n\nLet’s understand it with a simple React app that shows toast messages when a request or response error occurs. Start by creating a file called in the directory of your React app and use the method to create a custom Axios instance.\n\nIn this example, I’m using a placeholder API to demonstrate and use one of its endpoints as the base URL of our Axios instance:\n\nNext, let’s define a handler function and call it in the same file. This function takes one argument — expected to be the error object when we implement this with Axios interceptors. With this error object, we can categorize errors based on their type (e.g., response, request, setup) and display appropriate user feedback using a React toast library:\n\nNow, we can add a response interceptor to our custom Axios instance to provide automatic success notifications for successful API responses and delegate error handling to the function:\n\nWe can then use this custom Axios instance in a component where we want to consume the API (the placeholder API in this case) and let it handle errors by itself. Here’s the complete setup of our React app with HTTP error feedback following a centralized error-handling approach.\n\nHow to post a file from a form with Axios\n\nWe can use Axios with the object to streamline a file upload. To simplify the demonstration, I’m using React again to create a file upload component with basic error handling.\n\nN.B., we are assuming that a backend API is available to support the file upload in this example. This will make more sense with a test backend API in your local development setup.\n\nLet’s use React’s Hook to manage the file selection and its upload status. Let’s also create a handler function ( ) to manage the file selection, which basically updates the state to the file chosen by the user:\n\nWe should now define a handler function ( ) for file upload, which creates a object if a file is selected. The selected file is then appended to this object, which will be sent in an Axios POST request. Uploading a file is a heavy operation, therefore this handler function should execute asynchronously to allow other operations to continue without blocking the UI thread.\n\nN.B., if your use case allows, you may also use an Axios PUT request to upload a file, which takes a similar approach but may also require you to add some additional steps.\n\nTo the same function, i.e., , we can add a block with a custom Axios instance pointing to our backend API’s endpoint, which is responsible for the file upload. Because it is a file upload, we must set the to to have our file properly parsed at the backend.\n\nWe may also reflect the upload progress in the frontend using the property of our custom Axios instance. If the request is successful, we set the to something positive, which we can also show through a toast message later. Otherwise, we set a negative message to the state:\n\nFinally, we should add some JSX to structure our file upload box and use the states, selection handlers, and file upload handlers appropriately, as shown below:\n\nAs an assignment, you may try adding previously discussed Axios interceptors-based error handling to this example. Find the code for this example in this StackBlitz demo.\n\nAxios’ rise in popularity among developers has resulted in a rich selection of third-party libraries that extend its functionality. From testers to loggers, there’s a library for almost any additional feature you may need when using Axios. Here are some libraries that are currently available:\n• axios-cache-plugin: Helps you cache GET requests when using Axios\n• axios-curlirize: Logs any Axios request as a curl command in the console\n• axios-mock-adapter: Axios adapter that allows you to easily mock requests\n• axios-debug-log: Axios interceptor of logging request and response with debug library\n• axiosist: Axios-based supertest that converts the Node.js request handler to an Axios adapter; used for Node.js server unit test\n\nThere’s a good reason Axios is so popular among developers: it’s packed with useful features. In this post, we took a look at several key features of Axios and learned how to use them in practice. But there are still many aspects of Axios that we haven’t discussed. Be sure to check out the Axios GitHub page to learn more.\n\nDo you have any tips on using Axios? Let us know in the comments!"
    },
    {
        "link": "https://geeksforgeeks.org/how-to-make-get-call-to-an-api-using-axios-in-javascript",
        "document": "How to Make GET call to an API using Axios in JavaScript?\n\nAxios is a promise-based HTTP client designed for Node.js and browsers. With Axios, we can easily send asynchronous HTTP requests to REST APIs and perform create, read, update and delete operations. It is an open-source collaboration project hosted on GitHub. It can be imported in plain JavaScript or with any library accordingly. There are two methods to use the AXIOS which are as follows:\n\nThe following script-src will include axios.js in the head section of your HTML code\n\nWhen we send a request to the API using Axios, it returns a response. The response object consists of:\n• data: the data returned from the server.\n• status: the HTTP code returned from the server.\n• statusText: the HTTP status returned by the server.\n\n\n\nFor the purpose of demonstration, we will be hosting an API on the localhost:\n\nInclude axios.js and the corresponding JS file in the HTML file. In the JS file, write the following code which makes a GET request using Axios to the API. A GET request to the API requires the path to the API method. \n\nExample: To demonstrate making a GET request using Axios to the API in JavaScript.\n\nOutput: It will call the API with a GET request. The response will be obtained on the console window.\n\nAxios is a popular JavaScript library used for making HTTP requests in both Node.js and browser environments. It simplifies the process of sending asynchronous HTTP requests to REST APIs, allowing developers to perform various operations like fetching data, sending data, updating data, and deleting data\n\nFirst, install Axios in your project using npm (Node Package Manager). Open your terminal or command prompt and run the following command:\n\nIn your JavaScript file where you want to make API calls, import Axios using either `require` or `import` syntax, depending on your project setup.\n\nTo make a GET request to an API endpoint using Axios, you need to specify the URL of the endpoint you want to fetch data from. Use the `axios.get()` method and pass the URL as an argument.\n\nExample: To demonstrate making the get call to an API using Axios in JavaScript.\n\nOutput: The output will include the data that is fetched after hitting the end point of the API."
    },
    {
        "link": "https://medium.com/@reggiecheston/a-beginners-guide-to-using-axios-in-node-js-simplifying-http-requests-441291fef064",
        "document": "In web development, it’s essential to understand how data is exchanged between clients (users interacting with the application) and servers (where data is stored for applications). Hypertext Transfer Protocol (HTTP) requests facilitate this exchange. In this article, we delve into the world of HTTP requests, specifically exploring Axios and how it simplifies how we structure code when defining these requests.\n\nDisclaimer: You should have a basic understanding of HTML, CSS, JavaScript, and APIs for this article.\n\nWhat is an HTTP Request?\n\nAn HTTP request refers to a communication protocol utilized by web servers and client-side applications for exchanging data over the Internet. Operating based on the Hypertext Transfer Protocol, this protocol enables users to initiate requests from their client-side applications to web servers. Upon receiving these requests, the server processes them and generates appropriate responses. This interaction facilitates various actions, including retrieving, modifying, sending, and deleting data stored on the server. These actions are defined in Axios as GET, POST, PUT, and DELETE requests respectively.\n\nThese HTTP requests can range from simple tasks such as signing into a user profile or adding an item to your favorites, to more complex actions like updating contact information or deleting a playlist from your library. In response, the server performs corresponding actions such as retrieving profile information, updating database records, or deleting relevant data tables.\n\nAxios is a popular JavaScript library used for making HTTP requests from the client-side. It offers a concise and intuitive way to send asynchronous HTTP requests to web servers, enabling developers to avoid having to write hundreds of lines of code to accomplish the same thing. The main advantages of Axios include ease of use, built-in features, and compatibility with both browser and Node.js environments.\n\nHow to Use Axios?\n\nStart by installing Axios using one of the following terminal commands, depending on whether you use npm or yarn.\n\nThen you need to import it into your working file using the traditional ‘require’ syntax or the ES6 ‘import’ syntax.\n\nOnce you’ve installed and imported Axios into your working file, you can use Axios’ simple syntax to make a request. For example, making a GET request to fetch data from an API endpoint.\n\nThis GET request starts by accessing the API via the “/data” endpoint. Once it reaches the endpoint it would ideally retrieve that raw data and log it to the console. However, if it is unable to reach the endpoint, it logs an error to the console. In the context of a real application, logging the raw data to the console could more practically be something like storing that data into a variable to later render a profile homepage with a user’s information that matches a set of login credentials.\n\nAs a comparison, this is what a GET request looks like without the use of Axios:\n\nAxios also supports other HTTP methods like POST, PUT, and DELETE, enabling you to perform a wide range of operations with ease. To follow the example from earlier of a user profile, you might use a POST request to change data like updating a user’s bio or editing a post they made. A PUT request adds data and may be used to add a new post or add something to favorites. Lastly, a DELETE request, as you might imagine, deletes data, which could be used for deleting a post or even deleting a user’s profile altogether.\n\nUnderstanding HTTP requests is essential for building robust and efficient web applications. By leveraging tools like Axios, developers can streamline the process of making requests and efficiently handle responses. Mastery of HTTP requests and utilizing Axios and libraries like it will equip you with the tools to create modern and dynamic web applications.\n\nYou can find the original Axios documentation here."
    }
]