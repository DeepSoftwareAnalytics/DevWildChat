[
    {
        "link": "https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-tsts/a11e7129-685b-4535-8d37-21d4596ac057",
        "document": "This browser is no longer supported.\n\nUpgrade to Microsoft Edge to take advantage of the latest features, security updates, and technical support."
    },
    {
        "link": "https://learn.microsoft.com/en-us/windows/win32/apiindex/windows-api-list",
        "document": "The following is a list of the reference content for the Windows application programming interface (API) for desktop and server applications.\n\nUsing the Windows API, you can develop applications that run successfully on all versions of Windows while taking advantage of the features and capabilities unique to each version. (Note that this was formerly called the Win32 API. The name Windows API more accurately reflects its roots in 16-bit Windows and its support on 64-bit Windows.)\n\nThe Windows UI API creates and uses windows to display output, prompt for user input, and carry out the other tasks that support interaction with the user. Most applications create at least one window.\n\nThe Diagnostics API enable you to troubleshoot application or system problems and monitor performance.\n\nThe Graphics, multimedia, audio, and video APIs enable applications to incorporate formatted text, graphics, audio, and video.\n\nThe System Services APIs give applications access to the resources of the computer and the features of the underlying operating system, such as memory, file systems, devices, processes, and threads.\n\nThe Security and Identity APIs enable password authentication at logon, discretionary protection for all sharable system objects, privileged access control, rights management, and security auditing.\n\nThe System administration interfaces enable you to install, configure, and service applications or systems.\n\nThe Networking APIs enable communication between applications over a network. You can also create and manage access to shared resources, such as directories and network printers.\n\nThe following are technologies and APIs that are outdated or have been replaced or deprecated from the Windows client and server operating systems.\n• Microsoft UDDI SDK is now included with Microsoft BizTalk Server."
    },
    {
        "link": "https://en.wikipedia.org/wiki/Windows_API",
        "document": "The Windows API, informally WinAPI, is the foundational application programming interface (API) that allows a computer program to access the features of the Microsoft Windows operating system in which the program is running. Programs can access API functionality via shared-library technologies or via system-file access.[disputed – discuss]\n\nEach major version of the Windows API has a distinct name that identifies a compatibility aspect of that version. For example, Win32 is the major version of Windows API that runs on 32-bit systems. The name, Windows API, collectively refers to all versions of this capability of Windows.\n\nMicrosoft provides developer support via a software development kit, Microsoft Windows SDK, which includes documentation and tools for building software based on the Windows API.\n\nThis section lists notable services provided by the Windows API.[1]\n\nBase services include features such as the file system, devices, processes, threads, and error handling. These functions reside in , or files on 16-bit Windows, and on 32 and 64 bit Windows. These files reside in the folder on all versions of Windows.[2]\n\nAdvanced services include features beyond the kernel like the Windows registry, shutdown/restart the system (or abort), start/stop/create a Windows service, manage user accounts. These functions reside in and on 32-bit Windows.\n\nThe Graphics Device Interface (GDI) component provides features to output graphics content to monitors, printers, and other output devices. It resides in on 16-bit Windows, and on 32-bit Windows in user-mode. Kernel-mode GDI support is provided by which communicates directly with the graphics driver.[3][4]\n\nThe User Interface component provides features to create and manage screen windows and most basic controls, such as buttons and scrollbars, receive mouse and keyboard input, and other functions associated with the graphical user interface (GUI) part of Windows. This functional unit resides in on 16-bit Windows, and on 32-bit Windows. Since Windows XP versions, the basic controls reside in , together with the common controls (Common Control Library).[5]\n\nThe Common Dialog Box Library provides standard dialog boxes to open and save files, choose color and font, etc. The library resides in a file called on 16-bit Windows, and on 32-bit Windows. It is grouped under the User Interface category of the API.[6]\n\nThe Common Control Library provides access to advanced user interface controls include things like status bars, progress bars, toolbars and tabs. The library resides in a DLL file called on 16-bit Windows, and on 32-bit Windows. It is grouped under the User Interface category of the API.[7]\n\nThe Windows Shell component provides access to the operating system shell. The component resides in on 16-bit Windows, and on 32-bit Windows. The Shell Lightweight Utility Functions are in . It is grouped under the User Interface category of the API.[8][9]\n\nNetwork Services provide access to the various networking abilities of the operating system. Its subcomponents include NetBIOS, Winsock, NetDDE, remote procedure call (RPC) and many more. This component resides in on 32-bit Windows.[10]\n\nThe Internet Explorer (IE) web browser exposes APIs and as such could be considered part of the Windows API. IE has been included with the operating system since Windows 95 OSR2 and has provided web-related services to applications since Windows 98.[11]\n\nThe Windows API is a C language-based API.[12] Functions and data structures are consumable via C syntax by including windows.h, but the API can be consumed via any programming language that can inter-operate with the API data structures and calling conventions for function calls and callbacks.\n\nOf note, the implementation of API functions has been developed in several languages other than C.[a]\n\nDespite the fact that C is not an object-oriented programming (OOP) language, the Windows API is somewhat object-oriented due to its use of handles. Various other technologies from Microsoft and others make this object-oriented aspect more apparent by using an OOP language such as C++ — see Microsoft Foundation Class Library (MFC), Visual Component Library (VCL), GDI+. Of note, Windows 8 provides the Windows API and the WinRT API, which is implemented in C++[13] and is object-oriented by design.[13]\n\nWindows.pas is a Delphi unit that exposes the features of Windows API – the Pascal equivalent of windows.h.[14]\n\nMany Microsoft technologies use the Windows API -- as most software running on Windows does. As middle-ware between Windows API and an application, the following technologies provide some access to Windows API. Some technologies are described as wrapping Windows API, but this is debatable since they don't provide or expose all of the capabilities of Windows API.\n• Microsoft Foundation Class Library (MFC) exposes some of Windows API functionality in C++ classes, and thus allows a more object-oriented way to interact with the API\n• Active Template Library (ATL) is a C++ template library that provides some Windows API access\n• Windows Template Library (WTL) was developed as an extension to ATL, and intended as a smaller alternative to MFC\n• Most application frameworks for Windows provide some access to Windows API; including .NET runtime and Java virtual machine and any other programming languages targeting Windows\n• Various technologies for communicating between components and applications – starting with Dynamic Data Exchange (DDE), which was superseded by Object Linking and Embedding (OLE) and later by the Component Object Model (COM), Automation Objects, ActiveX controls, and the .NET Framework\n\nAlthough almost all Windows programs use the Windows API, on the Windows NT line of operating systems, programs that start early in the Windows startup process use the Native API instead.[15]\n\nThe Windows API has always exposed a large part of the underlying structure of the Windows systems to programmers. This had the advantage of giving them much flexibility and power over their applications, but also creates great responsibility in how applications handle various low-level, sometimes tedious, operations that are associated with a graphical user interface.\n\nFor example, a beginning C programmer will often write the simple \"hello world\" as their first assignment. The working part of the program is only a single printf line within the main subroutine. The overhead for linking to the standard I/O library is also only one line:\n\nCharles Petzold, who wrote several books about programming for the Windows API, said: \"The original hello world program in the Windows 1.0 SDK was a bit of a scandal. HELLO.C was about 150 lines long, and the HELLO.RC resource script had another 20 or so more lines. (...) Veteran programmers often curled up in horror or laughter when encountering the Windows hello-world program.\"[16] Petzold explains that while it was the first Windows sample programs developers were introduced to, it was quite \"fancy\" and more complex than needed. Tired of people ridiculing the length of the sample, he eventually reduced it to a simple MessageBox call.[17]\n\nOver the years, various changes and additions were made to Windows systems, and the Windows API changed and grew to reflect this.[18] The Windows API for Windows 1.0 supported fewer than 450 function calls, whereas modern versions of the Windows API support thousands. However, in general, the interface remained fairly consistent, and an old Windows 1.0 application will still look familiar to a programmer who is used to the modern Windows API.[19]\n\nMicrosoft has made an effort to maintain backward compatibility. To achieve this, when developing new versions of Windows, Microsoft sometimes implemented workarounds[20] to allow compatibility with third-party software that used the prior version in an undocumented or even inadvisable way. Raymond Chen, a Microsoft developer who works on the Windows API, has said: \"I could probably write for months solely about bad things apps do and what we had to do to get them to work again (often in spite of themselves). Which is why I get particularly furious when people accuse Microsoft of maliciously breaking applications during OS upgrades. If any application failed to run on Windows 95, I took it as a personal failure.\"[21]\n\nOne of the largest changes to the Windows API was the transition from Win16 (shipped in Windows 3.1 and older) to Win32 (Windows NT and Windows 95 and up). While Win32 was originally introduced with Windows NT 3.1 and Win32s allowed use of a Win32 subset before Windows 95, it was not until Windows 95 that widespread porting of applications to Win32 began. To ease the transition, in Windows 95, for developers outside and inside Microsoft, a complex scheme of API thunks was used that could allow 32-bit code to call into 16-bit code (for most of Win16 APIs) and vice versa. Flat thunks allowed 32-bit code to call into 16-bit libraries, and the scheme was used extensively inside Windows 95's libraries to avoid porting the whole OS to Win32 in one batch. In Windows NT, the OS was pure 32-bit, except parts for compatibility with 16-bit applications, and only generic thunks were available to thunk from Win16 to Win32, as for Windows 95. The Platform SDK shipped with a compiler that could produce the code needed for these thunks. Versions of 64-bit Windows are also able to run 32-bit applications via WoW64. The SysWOW64 folder located in the Windows folder on the OS drive contains several tools to support 32-bit applications.[22]\n\nEach version of Microsoft Windows contains a version of Windows API, and almost every new version of Microsoft Windows has introduced additions and changes to the Windows API.[23]\n\nThe name, Windows API, refers to essentially the same capability in each version of Windows, but there is another name for this capability that is based on major architectural aspects of the Windows version that contains it. When there was only one version, it was simply called Windows API. Then, when the first major update was made, Microsoft gave it the name Win32 and gave the first version the name Win16. The term Windows API refers to both versions and all subsequently developed major versions.[24]\n• Win16 is in the 16-bit versions of Windows. The functions reside mainly in core files of the OS: kernel.exe (or krnl286.exe or krnl386.exe), user.exe and gdi.exe. Despite the file extension of , such a file is accessed as a DLL.\n• Win32 is in the 32-bit versions of Windows (NT, 95, and later). The functions are implemented in system DLL files including kernel32.dll, user32.dll, and gdi32.dll. Win32 was introduced with Windows NT. In Windows 95, it was initially referred to as Win32c, with c meaning compatibility. This term was later abandoned by Microsoft in favor of Win32.\n• Win32s is an extension for the Windows 3.1x family of Microsoft Windows that implemented a subset of the Win32 API for these systems. The \"s\" stands for \"subset\".\n• Win64 is the version in the 64-bit platforms of the Windows architecture (as of 2021 , x86-64 and AArch64). b 25 26 Both 32-bit and 64-bit versions of an application can be compiled from one codebase, although some older API functions have been deprecated, and some of the API functions that were deprecated in Win32 were removed. All memory pointers are 64-bit by default (the LLP64 model), so porting Win32-compatible source code includes updating for 64-bit pointer arithmetic. 27\n• WinCE is the version in the Windows CE operating system.\n\nThe Wine project provides a Win32 API compatibility layer for Unix-like platforms, between Linux kernel API and programs written for the Windows API. ReactOS goes a step further and aims to implement the full Windows operating system, working closely with the Wine project to promote code re-use and compatibility. DosWin32 and HX DOS Extender are other projects which emulate the Windows API to allow executing simple Windows programs from a DOS command line. Odin is a project to emulate Win32 on OS/2, superseding the original Win-OS/2 emulation which was based on Microsoft code. Other minor implementations include the MEWEL and Zinc libraries which were intended to implement a subset of the Win16 API on DOS (see List of platform-independent GUI libraries).\n\nWindows Interface Source Environment (WISE) was a licensing program from Microsoft which allowed developers to recompile and run Windows-based applications on Unix and Macintosh platforms. WISE SDKs were based on an emulator of the Windows API that could run on those platforms.[28]\n\nEfforts toward standardization included Sun's Public Windows Interface (PWI) for Win16 (see also: Sun Windows Application Binary Interface (Wabi)), Willows Software's Application Programming Interface for Windows (APIW) for Win16 and Win32 (see also: Willows TWIN), and ECMA-234, which attempted to standardize the Windows API bindingly.\n\nTo develop software that uses the Windows API, a compiler must be able to use the Microsoft-specific DLLs listed above (COM-objects are outside Win32 and assume a certain vtable layout). The compiler must either handle the header files that expose the interior API function names, or supply such files.\n\nFor the language C++, Zortech (later Symantec, then Digital Mars), Watcom and Borland have all produced well known commercial compilers that have been used often with Win16, Win32s, and Win32. Some of them supplied memory extenders, allowing Win32 programs to run on Win16 with Microsoft's redistributable Win32s DLL. The Zortech compiler was probably one of the first stable and usable C++ compilers for Windows programming, before Microsoft had a C++ compiler.\n\nFor certain classes of applications, the compiler system should also be able to handle interface description language (IDL) files. Collectively, these prerequisites (compilers, tools, libraries, and headers) are known as the Microsoft Platform SDK. For a time, the Microsoft Visual Studio and Borland's integrated development system were the only integrated development environments (IDEs) that could provide this (although, the SDK is downloadable for free separately from the entire IDE suite, from Microsoft Windows SDK for Windows 7 and .NET Framework 4).\n\nAs of 2016 , the MinGW and Cygwin projects also provide such an environment based on the GNU Compiler Collection (GCC), using a stand-alone header file set, to make linking against the Win32-specific DLLs simple. LCC-Win32 is a C compiler maintained by Jacob Navia, freeware for non-commercial use. Pelles C is a freeware C compiler maintained by Pelle Orinius. Free Pascal is a free software Object Pascal compiler that supports the Windows API. The MASM32 package is a mature project providing support for the Windows API under Microsoft Macro Assembler (MASM) by using custom made or converted headers and libraries from the Platform SDK. Flat assembler FASM allows building Windows programs without using an external linker, even when running on Linux.\n\nWindows specific compiler support is also needed for Structured Exception Handling (SEH). This system serves two purposes: it provides a substrate on which language-specific exception handling can be implemented, and it is how the kernel notifies applications of exceptional conditions such as dereferencing an invalid pointer or stack overflow. The Microsoft/Borland C++ compilers had the ability to use this system as soon as it was introduced in Windows 95 and NT, however the actual implementation was undocumented and had to be reverse engineered for the Wine project and free compilers. SEH is based on pushing exception handler frames onto the stack, then adding them to a linked list stored in thread-local storage (the first field of the thread environment block). When an exception is thrown, the kernel and base libraries unwind the stack running handlers and filters as they are encountered. Eventually, every exception unhandled by the application will be dealt with by the default backstop handler, which pops up the Windows common crash dialog.\n• Linux kernel API – An overview and comparison of the Linux kernel API and ABI.\n• ECMA-234 – ECMA standard for a subset of the Windows API"
    },
    {
        "link": "https://docs.azure.cn/en-us/entra/identity-platform/v2-oauth2-client-creds-grant-flow",
        "document": "The OAuth 2.0 client credentials grant flow permits a web service (confidential client) to use its own credentials, instead of impersonating a user, to authenticate when calling another web service. The grant specified in RFC 6749, sometimes called two-legged OAuth, can be used to access web-hosted resources by using the identity of an application. This type is commonly used for server-to-server interactions that must run in the background, without immediate interaction with a user, and is often referred to as daemons or service accounts.\n\nIn the client credentials flow, permissions are granted directly to the application itself by an administrator. When the app presents a token to a resource, the resource enforces that the app itself has authorization to perform an action since there is no user involved in the authentication. This article covers both the steps needed to:\n• Authorize an application to call an API\n• How to get the tokens needed to call that API.\n\nThis article describes how to program directly against the protocol in your application. When possible, we recommend you use the supported Microsoft Authentication Libraries (MSAL) instead to acquire tokens and call secured web APIs. You can also refer to the sample apps that use MSAL. As a side note, refresh tokens will never be granted with this flow as and (which would be required to obtain a refresh token) can be used to obtain an access token instead.\n\nFor a higher level of assurance, the Microsoft identity platform also allows the calling service to authenticate using a certificate or federated credential instead of a shared secret. Because the application's own credentials are being used, these credentials must be kept safe. Never publish that credential in your source code, embed it in web pages, or use it in a widely distributed native application.\n\nThe entire client credentials flow looks similar to the following diagram. We describe each of the steps later in this article.\n\nAn app typically receives direct authorization to access a resource in one of two ways:\n• Through an access control list (ACL) at the resource\n\nThese two methods are the most common in Microsoft Entra ID and we recommend them for clients and resources that perform the client credentials flow. A resource can also choose to authorize its clients in other ways. Each resource server can choose the method that makes the most sense for its application.\n\nA resource provider might enforce an authorization check based on a list of application (client) IDs that it knows and grants a specific level of access to. When the resource receives a token from the Microsoft identity platform, it can decode the token and extract the client's application ID from the and claims. Then it compares the application against an access control list (ACL) that it maintains. The ACL's granularity and method might vary substantially between resources.\n\nA common use case is to use an ACL to run tests for a web application or for a web API. The web API might grant only a subset of full permissions to a specific client. To run end-to-end tests on the API, you can create a test client that acquires tokens from the Microsoft identity platform and then sends them to the API. The API then checks the ACL for the test client's application ID for full access to the API's entire functionality. If you use this kind of ACL, be sure to validate not only the caller's value but also validate that the value of the token is trusted.\n\nFor data owned by organizations, we recommend that you get the necessary authorization through application permissions.\n\nIn order to enable this ACL-based authorization pattern, Microsoft Entra ID doesn't require that applications be authorized to get tokens for another application. Thus, app-only tokens can be issued without a claim. Applications that expose APIs must implement permission checks in order to accept tokens.\n\nIf you'd like to prevent applications from getting role-less app-only access tokens for your application, ensure that assignment requirements are enabled for your app. This will block users and applications without assigned roles from being able to get a token for this application.\n\nInstead of using ACLs, you can use APIs to expose a set of application permissions. These are granted to an application by an organization's administrator, and can be used only to access data owned by that organization and its employees. For example, Microsoft Graph exposes several application permissions to do the following:\n• Read and write mail in all mailboxes\n\nTo use app roles (application permissions) with your own API (as opposed to Microsoft Graph), you must first expose the app roles in the API's app registration in the Microsoft Entra admin center. Then, configure the required app roles by selecting those permissions in your client application's app registration. If you haven't exposed any app roles in your API's app registration, you won't be able to specify application permissions to that API in your client application's app registration in the Microsoft Entra admin center.\n\nWhen authenticating as an application (as opposed to with a user), you can't use delegated permissions because there is no user for your app to act on behalf of. You must use application permissions, also known as app roles, that are granted by an admin or by the API's owner.\n\nFor more information about application permissions, see Permissions and consent.\n\nRecommended: Sign the admin into your app to have app roles assigned\n\nTypically, when you build an application that uses application permissions, the app requires a page or view on which the admin approves the app's permissions. This page can be part of the app's sign-in flow, part of the app's settings, or a dedicated connect flow. It often makes sense for the app to show this connect view only after a user has signed in with a work or school Microsoft account.\n\nIf you sign the user into your app, you can identify the organization to which the user belongs to before you ask the user to approve the application permissions. Although not strictly necessary, it can help you create a more intuitive experience for your users. To sign the user in, follow the Microsoft identity platform protocol tutorials.\n\nWhen you're ready to request permissions from the organization's admin, you can redirect the user to the Microsoft identity platform admin consent endpoint.\n\nPro tip: Try pasting the following request in a browser.\n\nAt this point, Microsoft Entra ID enforces that only a tenant administrator can sign in to complete the request. The administrator will be asked to approve all the direct application permissions that you have requested for your app in the app registration portal.\n\nIf the admin approves the permissions for your application, the successful response looks like this:\n\nIf the admin does not approve the permissions for your application, the failed response looks like this:\n\nAfter you've received a successful response from the app provisioning endpoint, your app has gained the direct application permissions that it requested. Now you can request a token for the resource that you want.\n\nAfter you've acquired the necessary authorization for your application, proceed with acquiring access tokens for APIs. To get a token by using the client credentials grant, send a POST request to the Microsoft identity platform. There are a few different cases:\n\nThe parameters for the certificate-based request differ in only one way from the shared secret-based request: the parameter is replaced by the and parameters.\n\nEverything in the request is the same as the certificate-based flow, with the crucial exception of the source of the . In this flow, your application does not create the JWT assertion itself. Instead, your app uses a JWT created by another identity provider. This is called workload identity federation, where your apps identity in another identity platform is used to acquire tokens inside the Microsoft identity platform. This is best suited for cross-cloud scenarios, such as hosting your compute outside Azure but accessing APIs protected by Microsoft identity platform. For information about the required format of JWTs created by other identity providers, read about the assertion format.\n\nA successful response from any method looks like this:\n\nAn error response (400 Bad Request) looks like this:\n\nNow that you've acquired a token, use the token to make requests to the resource. When the token expires, repeat the request to the endpoint to acquire a fresh access token.\n\nTry the following command in your terminal, ensuring to replace the token with your own.\n\nRead the client credentials overview documentation from the Microsoft Authentication Library"
    },
    {
        "link": "https://docs.azure.cn/en-us/entra/identity-platform/quickstart-desktop-app-wpf-sign-in",
        "document": "Quickstart: Sign in users and call Microsoft Graph in a Windows desktop app\n\nIn this quickstart, you download and run a code sample that demonstrates how a Windows Presentation Foundation (WPF) application can sign in users and get an access token to call the Microsoft Graph API. The desktop app you build uses the authorization code flow paired with the Proof Key for Code Exchange (PKCE) standard.\n\nSee How the sample works for an illustration.\n\nYou have two options to start your quickstart application:\n• [Express] Option 1: Register and auto configure your app and then download your code sample\n• [Manual] Option 2: Register and manually configure your application and code sample\n\nOption 1: Register and auto configure your app and then download your code sample\n• Go to the Microsoft Entra admin center - App registrationsquickstart experience.\n• Enter a name for your application and select Register.\n• Follow the instructions to download and automatically configure your new application with just one click.\n\nOption 2: Register and manually configure your application and code sample\n\nTo register your application and add the app's registration information to your solution manually, follow these steps:\n• Sign in to the Microsoft Entra admin center.\n• If you have access to multiple tenants, use the Settings icon in the top menu to switch to the tenant in which you want to register the application from the Directories + subscriptions menu.\n• Enter a Name for your application, for example . Users of your app might see this name, and you can change it later.\n• In the Supported account types section, select Accounts in any organizational directory.\n• In the Redirect URIs section, select and in Custom redirect URIs add where is the application (client) ID of your application (the same GUID that appears in the checkbox).\n• None Extract the zip file to a local folder close to the root of the disk, for example, C:\\Azure-Samples.\n• None Edit App.Xaml.cs and replace the values of the fields and with the following code:\n• None - is the Application (client) ID for the application you registered. To find the value of Application (client) ID, go to the app's Overview page in the Microsoft Entra admin center.\n• None - is set to one of the following options:\n• None If your application supports Accounts in this organizational directory, replace this value with the Tenant Id or Tenant name (for example, contoso.microsoft.com)\n• None If your application supports Accounts in any organizational directory, replace this value with To find the values of Directory (tenant) ID and Supported account types, go to the app's Overview page in the Microsoft Entra admin center.\n\nTo build and run the sample application in Visual Studio, select the Debug menu > Start Debugging, or press the F5 key. Your application's MainWindow is displayed.\n\nWhen the app's main window appears, select the Call Microsoft Graph API button. You'll be prompted to sign in using your Microsoft Entra account (work or school account) credentials.\n\nIf you're running the application for the first time, you'll be prompted to provide consent to allow the application to access your user profile and sign you in. After consenting to the requested permissions, the application displays that you've successfully logged in. You should see some basic token information and user data obtained from the call to the Microsoft Graph API.\n\nMSAL (Microsoft.Identity.Client) is the library used to sign in users and request tokens used to access an API protected by Microsoft identity platform. You can install MSAL by running the following command in Visual Studio's Package Manager Console:\n\nYou can add the reference for MSAL by adding the following code:\n\nThen, initialize MSAL using the following code:\n\nMSAL has two methods for acquiring tokens: and .\n\nSome situations require forcing users interact with the Microsoft identity platform through a pop-up window to either validate their credentials or to give consent. Some examples include:\n• The first time users sign in to the application\n• When users may need to reenter their credentials because the password has expired\n• When your application is requesting access to a resource that the user needs to consent to\n• When two factor authentication is required\n\nYou don't want to require the user to validate their credentials every time they need to access a resource. Most of the time you want token acquisitions and renewal without any user interaction. You can use the method to obtain tokens to access protected resources after the initial method:\n\nIf you need help, want to report an issue, or want to learn about your support options, see Help and support for developers.\n\nTry out the Windows desktop tutorial for a complete step-by-step guide on building applications and new features, including a full explanation of this quickstart."
    },
    {
        "link": "https://learn.microsoft.com/en-us/windows-hardware/drivers/kernel/using-ntstatus-values",
        "document": "Many kernel-mode standard driver routines and driver support routines use the NTSTATUS type for return values. Additionally, drivers provide an NTSTATUS-typed value in an IRP's IO_STATUS_BLOCK structure when completing IRPs. The NTSTATUS type is defined in Ntdef.h, and system-supplied status codes are defined in Ntstatus.h. (Vendors can also define private status codes, although they rarely need to. For more information, see Defining New NTSTATUS Values.)\n\nNTSTATUS values are divided into four types: success values, informational values, warnings, and error values.\n\nNumerous values are assigned to each type. A common mistake, when testing for a successful return from a routine, is to compare the routine's return value with STATUS_SUCCESS. This comparison checks for only one of several success values.\n\nWhen testing a return value, you should use one of the following system-supplied macros (defined in Ntdef.h):\n\nFor example, suppose a driver calls IoRegisterDeviceInterface to register a device interface. If the driver checks the return value using the NT_SUCCESS macro, the macro evaluates to TRUE if the routine returns STATUS_SUCCESS, which indicates no errors, or if it returns the informational status STATUS_OBJECT_NAME_EXISTS, which indicates that the device interface is already registered.\n\nAs another example, suppose a driver calls ZwEnumerateKey to enumerate the subkeys of a specified registry key. If the NT_SUCCESS macro evaluates to FALSE, it might be because the routine returned STATUS_INVALID_PARAMETER, which is an error code, or because the routine returned STATUS_NO_MORE_ENTRIES, which is a warning code.\n\nAs a final example, suppose a driver sends an IRP that causes a lower-level driver to read information from a device. If the requesting driver specifies a buffer that is too small to receive any information, the lower-level driver might respond by returning STATUS_BUFFER_TOO_SMALL, which is an error code. If the first driver specifies a buffer that can receive some, but not all, of the requested information, the lower-level driver might respond by supplying as much data as possible and then returning STATUS_BUFFER_OVERFLOW, which is a warning code. If the first driver tests the status value using NT_SUCCESS or NT_ERROR incorrectly, it might inadvertently drop some of the information received."
    },
    {
        "link": "https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-erref/596a1078-e883-4972-9bbc-49e60bebca55",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/5023809/api-signature-from-the-running-process",
        "document": "No, the IAT must contain either the API name or function ordinal - otherwise the loader can't match up the imported function with an export from the DLL you've loaded. If you have the name it'll be an offset to a narrow string in your own process image; if it's the ordinal then you may be able to look up the function name from the ordinal in the imported DLL's export table, but it's not always supplied.\n\nUnless your API name is a C++ mangled name you won't get the signature from here. You might be able to query the debug resource directory for a PDB and then use the PDB APIs to read the signature from that, if there's a PDB available."
    },
    {
        "link": "https://codemachine.com/downloads/win71/ntstatus.h",
        "document": ""
    },
    {
        "link": "https://github.com/MicrosoftDocs/windows-driver-docs/blob/staging/windows-driver-docs-pr/kernel/using-ntstatus-values.md",
        "document": "Many kernel-mode standard driver routines and driver support routines use the NTSTATUS type for return values. Additionally, drivers provide an NTSTATUS-typed value in an IRP's IO_STATUS_BLOCK structure when completing IRPs. The NTSTATUS type is defined in Ntdef.h, and system-supplied status codes are defined in Ntstatus.h. (Vendors can also define private status codes, although they rarely need to. For more information, see Defining New NTSTATUS Values.)\n\nNTSTATUS values are divided into four types: success values, informational values, warnings, and error values.\n\nNumerous values are assigned to each type. A common mistake, when testing for a successful return from a routine, is to compare the routine's return value with STATUS_SUCCESS. This comparison checks for only one of several success values.\n\nWhen testing a return value, you should use one of the following system-supplied macros (defined in Ntdef.h):\n\nFor example, suppose a driver calls IoRegisterDeviceInterface to register a device interface. If the driver checks the return value using the NT_SUCCESS macro, the macro evaluates to TRUE if the routine returns STATUS_SUCCESS, which indicates no errors, or if it returns the informational status STATUS_OBJECT_NAME_EXISTS, which indicates that the device interface is already registered.\n\nAs another example, suppose a driver calls ZwEnumerateKey to enumerate the subkeys of a specified registry key. If the NT_SUCCESS macro evaluates to FALSE, it might be because the routine returned STATUS_INVALID_PARAMETER, which is an error code, or because the routine returned STATUS_NO_MORE_ENTRIES, which is a warning code.\n\nAs a final example, suppose a driver sends an IRP that causes a lower-level driver to read information from a device. If the requesting driver specifies a buffer that is too small to receive any information, the lower-level driver might respond by returning STATUS_BUFFER_TOO_SMALL, which is an error code. If the first driver specifies a buffer that can receive some, but not all, of the requested information, the lower-level driver might respond by supplying as much data as possible and then returning STATUS_BUFFER_OVERFLOW, which is a warning code. If the first driver tests the status value using NT_SUCCESS or NT_ERROR incorrectly, it might inadvertently drop some of the information received."
    }
]