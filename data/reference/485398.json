[
    {
        "link": "https://realpython.com/primer-on-python-decorators",
        "document": "Python decorators allow you to modify or extend the behavior of functions and methods without changing their actual code. When you use a Python decorator, you wrap a function with another function, which takes the original function as an argument and returns its modified version. This technique provides a simple way to implement higher-order functions in Python, enhancing code reusability and readability.\n\nBy the end of this tutorial, you’ll understand that:\n• Practical use cases for decorators include logging, enforcing access control, caching results, and measuring execution time.\n• Custom decorators are written by defining a function that takes another function as an argument, defines a nested wrapper function, and returns the wrapper.\n• Multiple decorators can be applied to a single function by stacking them before the function definition.\n• The order of decorators impacts the final output since each decorator wraps the next, influencing the behavior of the decorated function.\n\nYou can find all the examples from this tutorial by downloading the accompanying materials below:\n\nIn order to understand decorators, you must first understand some finer points of how functions work. There are many aspects to functions, but in the context of decorators, a function returns a value based on the given arguments. Here’s a basic example: In general, functions in Python may also have side effects rather than just turning an input into an output. The function is an example of this: it returns while having the side effect of outputting something to the console. However, to understand decorators, it’s enough to think about functions as tools that turn given arguments into values. In functional programming, you work almost entirely with pure functions that don’t have side effects. While not a purely functional language, Python supports many functional programming concepts, including treating functions as first-class objects. This means that functions can be passed around and used as arguments, just like any other object like , , , , and so on. Consider the following three functions: , together we're the awesomest!\" Here, and are regular functions that expect a name given as a string. The function, however, expects a function as its argument. You can, for example, pass it the or the function. To test your functions, you can run your code in interactive mode. You do this with the flag. For example, if your code is in a file named , then you run : 'Yo Bob, together we're the awesomest!' Note that refers to two functions, and , but in different ways. The function is named without parentheses. This means that only a reference to the function is passed. The function isn’t executed. The function, on the other hand, is written with parentheses, so it will be called as usual. This is an important distinction that’s crucial for how functions work as first-class objects. A function name without parentheses is a reference to a function, while a function name with trailing parentheses calls the function and refers to its return value. It’s possible to define functions inside other functions. Such functions are called inner functions. Here’s an example of a function with two inner functions: What happens when you call the function? Think about this for a minute. Then run in interactive mode to try it out. The output will be as follows: Note that the order in which the inner functions are defined does not matter. Like with any other functions, the printing only happens when the inner functions are executed. Furthermore, the inner functions aren’t defined until the parent function is called. They’re locally scoped to , meaning they only exist inside the function as local variables. Try calling . You’ll get an error: : name 'first_child' is not defined Whenever you call , the inner functions and are also called. But because of their local scope, they aren’t available outside of the function. Python also allows you to return functions from functions. In the following example, you rewrite to return one of the inner functions: Note that you’re returning without the parentheses. Recall that this means that you’re returning a reference to the function . In contrast, with parentheses refers to the result of evaluating the function. You can see this in the following example: The somewhat cryptic output means that the variable refers to the local function inside of , while points to . You can now use and as if they’re regular functions, even though you can’t directly access the functions they point to: You recognize the return values of the inner functions that you defined inside of . Finally, note that in the earlier example, you executed the inner functions within the parent function—for example, . However, in this last example, you didn’t add parentheses to the inner functions, such as , upon returning. That way, you got a reference to each function that you could call in the future.\n\nNow that you’ve seen that functions are just like any other object in Python, you’re ready to move on and see the magical beast that is the Python decorator. You’ll start with an example: \"Something is happening before the function is called.\" \"Something is happening after the function is called.\" Here, you’ve defined two regular functions, and , and one inner function. Then you redefined to apply to the original . Can you guess what happens when you call ? Try it in a REPL. Instead of running the file with the flag, you can also import the function manually: Something is happening before the function is called. Something is happening after the function is called. To understand what’s going on here, look back at the earlier examples. You’re applying everything that you’ve learned so far. The so-called decoration happens at the following line: In effect, the name now points to the inner function. Remember that you return as a function when you call : However, has a reference to the original as , and it calls that function between the two calls to . Before moving on, have a look at a second example. Because is a regular Python function, the way a decorator modifies a function can change dynamically. So as not to disturb your neighbors, the following example will only run the decorated code during the day: If you try to call after bedtime, nothing will happen: Here, doesn’t print any output. That’s because the test failed, so the wrapper didn’t call , the original . Look back at the code that you wrote in . The way you decorated is a little clunky. First of all, you end up typing the name three times. Additionally, the decoration gets hidden away below the definition of the function. Instead, Python allows you to use decorators in a simpler way with the symbol, sometimes called the pie syntax. The following example does the exact same thing as the first decorator example: \"Something is happening before the function is called.\" \"Something is happening after the function is called.\" So, is just a shorter way of saying . It’s how you apply a decorator to a function. Recall that a decorator is just a regular Python function. All the usual tools for reusability are available. Now, you’ll create a module where you store your decorators and that you can use in many other functions. Create a file called with the following content: The decorator calls the decorated function twice. You’ll soon see the effect of this in several examples. Note: You can name your inner function whatever you want, and a generic name like is usually okay. You’ll see a lot of decorators in this tutorial. To keep them apart, you’ll name the inner function with the same name as the decorator but with a prefix. You can now use this new decorator in other files by doing a regular import: When you run this example, you should see that the original is executed twice: There are two Whee! exclamations printed, confirming that does what it says on the tin. Free Bonus: Click here to get access to a free \"The Power of Python Decorators\" guide that shows you three advanced decorator patterns and techniques you can use to write cleaner and more Pythonic programs. Say that you have a function that accepts some arguments. Can you still decorate it? Give it a try: You now apply to , which expects a name. Unfortunately, calling this function raises an error: : wrapper_do_twice() takes 0 positional arguments but 1 was given The problem is that the inner function doesn’t take any arguments, but you passed to it. You could fix this by letting accept one argument, but then it wouldn’t work for the function that you created earlier. The solution is to use and in the inner wrapper function. Then it’ll accept an arbitrary number of positional and keyword arguments. Rewrite as follows: The inner function now accepts any number of arguments and passes them on to the function that it decorates. Now both your and examples work. Start a fresh REPL: You use the same decorator, , to decorate two different functions. This hints at one of the powers of decorators. They add behavior that can apply to many different functions. What happens to the return value of decorated functions? Well, that’s up to the decorator to decide. Say you decorate a simple function as follows: Oops, your decorator ate the return value from the function. Because the doesn’t explicitly return a value, the call ends up returning . To fix this, you need to make sure the wrapper function returns the return value of the decorated function. Change your file: Now you return the return value of the last call of the decorated function. Check out the example again: A great convenience when working with Python, especially in the interactive shell, is its powerful introspection ability. Introspection is the ability of an object to know about its own attributes at runtime. For instance, a function knows its own name and documentation: Help on built-in function print in module builtins: When you inspect , you can see its name and documentation. The introspection works for functions that you define yourself as well: Help on function wrapper_do_twice in module decorators: However, after being decorated, has gotten very confused about its identity. It now reports being the inner function inside the decorator. Although technically true, this isn’t very useful information. To fix this, decorators should use the decorator, which will preserve information about the original function. Update again: You don’t need to change anything about the decorated function, but you need to restart your REPL to see the effect: Help on function say_whee in module whee: Much better! Now is still itself after decoration. Note: The decorator uses to update special attributes like and that are used in the introspection. You’ve now learned the basics of how to create a decorator. However, isn’t a very exciting decorator, and there aren’t a lot of use cases for it. In the next section, you’ll implement several decorators that illustrate what you know so far and that you can use in your own code.\n\nYou’ll now look at a few more useful examples of decorators. You’ll notice that they’ll mainly follow the same pattern that you’ve learned so far: This formula is a good boilerplate template for building more complex decorators. You’ll continue to store your decorators in . Recall that you can download all the examples in this tutorial: Get Your Code: Click here to download the free sample code that shows you how to create and use Python decorators. You’ll start by creating a decorator. It’ll measure the time a function takes to execute and then print the duration to the console. Here’s the code: \"\"\"Print the runtime of the decorated function\"\"\" This decorator works by storing the time just before the function starts running in line 10 and just after the function finishes in line 12. The runtime of the function is then the difference between the two, calculated in line 13. You use , which does a good job of measuring time intervals. Now, add as an example of a function that spends some time, so that you can test . Here are some examples of timings: Run it yourself. Work through the definition of line by line. Make sure you understand how it works. Don’t worry if you don’t get everything, though. Decorators are advanced beings. Try to sleep on it or make a drawing of the program flow. Note: The decorator is great if you just want to get an idea about the runtime of your functions. If you want to do more precise measurements of code, then you should instead consider the module in the standard library. It temporarily disables garbage collection and runs multiple trials to strip out noise from short function calls. If you’re interested in learning more about timing functions, then have a look at Python Timer Functions: Three Ways to Monitor Your Code. The following decorator will print a function’s arguments and its return value every time you call the function: \"\"\"Print the function signature and return value\"\"\" The signature is created by joining the string representations of all the argument:\n• Line 9: You create a list of the positional arguments. Use to get a nice string representing each argument.\n• Line 10: You create a list of the keyword arguments. The f-string formats each argument as , and again, you use to represent the value.\n• Line 11: You join together the lists of positional and keyword arguments to one signature string with each argument separated by a comma.\n• Line 14: You print the return value after the function is executed. It’s time to see how the decorator works in practice by applying it to a simple function with one positional and one keyword argument: Note how the decorator prints the signature and return value of the function: This example might not seem immediately useful since the decorator just repeats what you wrote. It’s more powerful when applied to small convenience functions that you don’t call directly yourself. The following example calculates an approximation of the mathematical constant e: Here, you also apply a decorator to a function that has already been defined. In line 4, you decorate from the standard library. You can’t use the pie syntax, but you can still manually apply the decorator. The approximation of e is based on the following series expansion: When calling the function, you can see the decorator at work: In this example, you get a decent approximation of the true value e ≈ 2.718281828, adding only five terms. In this section, you’ll create a decorator that slows down your code. This might not seem very useful. Why would you want to slow down your Python code? Probably the most common use case is that you want to rate-limit a function that continuously checks whether a resource—like a web page—has changed. The decorator will sleep one second before it calls the decorated function: \"\"\"Sleep 1 second before calling the function\"\"\" In , you call to have your code take a pause before calling the decorated function. To see how the decorator works, you create a function. To see the effect of slowing down the code, you should run the example yourself: In , you check if is smaller than one. In that case, you print Liftoff!. If not, then you print the number and keep counting. Note: The function is a recursive function. In other words, it’s a function calling itself. To learn more about recursive functions in Python, see Thinking Recursively in Python. The decorator always sleeps for one second. Later, you’ll see how to control the rate by passing an argument to the decorator. Decorators don’t have to wrap the function that they’re decorating. They can also simply register that a function exists and return it unwrapped. You can use this, for example, to create a lightweight plugin architecture: The decorator only stores a reference to the decorated function in the global dictionary. Note that you don’t have to write an inner function or use in this example because you’re returning the original function unmodified. You can now register functions as follows: , together we're the awesomest!\" Note that the dictionary already contains references to each function object that’s registered as a plugin: Python applies decorators when you define a function, so and are immediately registered. You can then use to call these functions: The function randomly chooses one of the registered functions to use. In the f-string, you use the flag. This has the same effect as calling . The main benefit of this simple plugin architecture is that you don’t need to maintain a list of which plugins exist. That list is created when the plugins register themselves. This makes it trivial to add a new plugin: just define the function and decorate it with . If you’re familiar with in Python, then you might see some similarities to how the plugin architecture works. With , you get access to all global variables in the current scope, including your plugins: {..., # Many variables that aren't not shown here. Using the decorator, you can create your own curated list of interesting names, effectively hand-picking some functions from . The final example before moving on to some fancier decorators is commonly used when working with a web framework. In this example, you’ll use Flask to set up a web page that should only be visible to users that are logged in or otherwise authenticated: \"\"\"Make sure user is logged in before proceeding\"\"\" While this gives an idea about how to add authentication to your web framework, you should usually not write these types of decorators yourself. For Flask, you can use the Flask-Login extension instead, which adds more security and functionality.\n\nSo far, you’ve seen how to create simple decorators. You already have a pretty good understanding of what decorators are and how they work. Feel free to take a break from this tutorial to practice everything that you’ve learned. In the second part of this tutorial, you’ll explore more advanced features, including how to do the following:\n• Add several decorators to one function\n• Create decorators that can optionally take arguments Ready to dive in? Here you go! There are two different ways that you can use decorators on classes. The first one is very close to what you’ve already done with functions: you can decorate the methods of a class. This was one of the motivations for introducing decorators back in the day. Some commonly used decorators are even built-ins in Python, including , , and . The and decorators are used to define methods inside a class namespace that aren’t connected to a particular instance of that class. The decorator is used to customize getters and setters for class attributes. Expand the box below for an example using these decorators: The following definition of a class uses the , , and decorators: \"\"\"Get value of radius\"\"\" \"\"\"Calculate volume of cylinder with circle as base\"\"\" \"\"\"Value of π, could use math.pi instead though\"\"\" Inside you can see several different kinds of methods. Decorators are used to distinguish them:\n• is a mutable property. It can be set to a different value. However, by defining a setter method, you do some error testing to make sure isn’t set to a nonsensical negative number. Properties are accessed as attributes without parentheses.\n• is an immutable property. Properties without methods can’t be changed. Even though it’s defined as a method, it can be retrieved as an attribute without parentheses.\n• is a class method. It’s not bound to one particular instance of . Class methods are often used as factory methods that can create specific instances of the class.\n• is a static method. It’s not really dependent on the class, except that it’s part of its namespace. You can call static methods on either an instance or the class. You can use as follows: In these examples, you explore the different methods, attributes, and properties of . Next, define a class where you decorate some of its methods using the and decorators from earlier: Using this class, you can see the effect of the decorators: When you create a new instance of , Python calls under the hood, as your use of reveals. The decorator helps you monitor how much time is spent on . The other way to use decorators on classes is to decorate the whole class. This is, for example, done in the module: The meaning of the syntax is similar to the function decorators. In the example above, you could’ve decorated the class by writing . A common use of class decorators is to be a simpler alternative to some use cases of metaclasses. In both cases, you’re changing the definition of a class dynamically. Writing a class decorator is very similar to writing a function decorator. The only difference is that the decorator will receive a class and not a function as an argument. In fact, all the decorators that you saw above will work as class decorators. When you’re using them on a class instead of a function, their effect might not be what you want. In the following example, the decorator is applied to a class: Decorating a class doesn’t decorate its methods. Recall that is just shorthand for . Here, only measures the time that it takes to instantiate the class: The output from is only shown as is created. The call to isn’t timed. Later, you’ll see an example defining a proper class decorator, namely , which ensures that there’s only one instance of a class. You can apply several decorators to a function at once by stacking them on top of each other: Think about this as the decorators being executed in the order they’re listed. In other words, calls , which calls , or : The greeting is printed twice because of . However, the output from is only shown once, since it’s called before the decorator. Observe the difference if you change the order of and : Here, is applied to as well. You can see that both calls to are annotated with debugging information. Sometimes, it’s useful to pass arguments to your decorators. For instance, could be extended to a decorator. The number of times to execute the decorated function could then be given as an argument. If you define , you could do something like this: Think about how you’d implement . So far, the name written after the has referred to a function object that can be called with another function. To be consistent, you then need to return a function object that can act as a decorator. Luckily, you already know how to return functions! In general, you want something like the following: Typically, the decorator creates and returns an inner wrapper function, so writing the example out in full will give you an inner function within an inner function. While this might sound like the programming equivalent of the Inception, you’ll untangle it all in a moment: It looks a little messy, but you’ve only put the same decorator pattern that you’ve seen many times by now inside one additional that handles the arguments to the decorator. First, consider the innermost function: This function takes arbitrary arguments and returns the value of the decorated function, . This wrapper function also contains the loop that calls the decorated function times. This is no different from the earlier wrapper functions that you’ve seen, except that it’s using the parameter that must be supplied from the outside. One step out, you’ll find the decorator function: Again, looks exactly like the decorator functions that you’ve written earlier, except that it’s named differently. That’s because you reserve the base name— —for the outermost function, which is the one the user will call. As you’ve already seen, the outermost function returns a reference to the decorator function: There are a few subtle things happening in the function:\n• Defining as an inner function means that will refer to a function object, . Earlier, you used decorators like without parentheses. Now, you need to add parentheses when setting up the decorator, as in . This is necessary in order to add arguments.\n• The argument is seemingly not used in itself. But by passing , a closure is created where the value of is stored until uses it later. With everything set up, test your code to see if the results are as expected: That’s just the result that you were aiming for. With a little bit of care, you can also define decorators that can be used both with and without arguments. Most likely, you don’t need this, but it is nice to have the flexibility. Like Winnie-the-Pooh says: Both—but don’t bother about the bread, please. (Source) As you saw in the previous section, when a decorator uses arguments, you need to add an extra outer function. The challenge now is for your code to figure out if you’ve called the decorator with or without arguments. Since the function to decorate is only passed in directly if the decorator is called without arguments, the function must be an optional argument. This means that the decorator arguments must all be specified by keyword. You can enforce this with the special asterisk ( ) syntax, which means that all the following parameters are keyword-only: Here, the argument acts as a marker, noting whether the decorator has been called with arguments or not:\n• Line 1: If you’ve called without arguments, then the decorated function will be passed in as . If you’ve called it with arguments, then will be , and some of the keyword arguments may have been changed from their default values. The asterisk in the argument list means that you can’t call the remaining arguments as positional arguments.\n• Line 6: In this case, you called the decorator with arguments. Return a decorator function that takes a function as an argument and returns a wrapper function.\n• Line 8: In this case, you called the decorator without arguments. Apply the decorator to the function immediately. Using this boilerplate on the decorator in the previous section, you can write the following: Compare this with the original . The only changes are the added parameter and the … block at the end. Recipe 9.6 of the excellent Python Cookbook shows an alternative solution using . You can now apply to different functions to test that you can now use it with or without arguments: Recall that the default value of is , so using without any arguments is equivalent to using : Here, Whee! is repeated twice since that’s the default behavior of . As specified by the argument, the greeting is repeated three times. Sometimes, it’s useful to have a decorator that can keep track of state. As an example, you’ll create a decorator that counts the number of times a function is called. Note: In the beginning of this guide, you learned about pure functions returning a value based on given arguments. Stateful decorators are quite the opposite, where the return value will depend on the current state, as well as the given arguments. In the next section, you’ll see how to use classes to keep state. But in simple cases, you can also get away with using function attributes: The state—the number of calls to the function—is stored in the function attribute on the wrapper function. Here’s the effect of using it: You apply to your old friend, . Each time you call the function, you see that the call count increases. You can also manually query the attribute. The typical way to maintain state in Python is by using classes. In this section, you’ll see how to rewrite the example from the previous section to use a class as a decorator. Recall that the decorator syntax is just a quicker way of saying . Therefore, if is a class, it needs to take as an argument in its initializer. Furthermore, the class instance needs to be callable so that it can stand in for the decorated function. Note: Up until now, all the decorators that you’ve seen have been defined as functions. This is how you most often will create decorators. However, you can use any callable expression as a decorator. For a class instance to be callable, you implement the special method: The method is executed each time you try to call an instance of the class: Each time you call , the state changes as the count increases. Therefore, a typical implementation of a decorator class should implement and : The method must store a reference to the function, and it can do any other necessary initialization. The method will be called instead of the decorated function. It does essentially the same thing as the function in your earlier examples. Note that you need to use the function instead of . This decorator works the same as the one in the previous section: Each call to is counted and noted. In the next section, you’ll look at more examples of decorators.\n\nYou’ve come a long way now, having figured out how to create all kinds of decorators. You’ll wrap it up, putting your newfound knowledge to use by creating a few more examples that might be useful in the real world. As noted earlier, your previous implementation of always sleeps for one second. Now you know how to add parameters to decorators, so you can rewrite using an optional argument that controls how long it sleeps: \"\"\"Sleep given amount of seconds before calling the function\"\"\" You’re using the boilerplate introduced in the Creating Decorators With Optional Arguments section to make callable both with and without arguments. The same recursive function as earlier now sleeps two seconds between each count: As before, you must run the example yourself to see the effect of the decorator: There’ll be a two second pause between each number in the countdown. A singleton is a class with only one instance. There are several singletons in Python that you use frequently, including , , and . The fact that is a singleton allows you to compare for using the keyword, like you did when creating decorators with optional arguments: Using returns only for objects that are the exact same instance. The following decorator turns a class into a singleton by storing the first instance of the class as an attribute. Later attempts at creating an instance simply return the stored instance: As you see, this class decorator follows the same template as your function decorators. The only difference is that you’re using instead of as the parameter name to indicate that it’s meant to be a class decorator. Check it out in practice: By comparing object IDs and checking with the keyword, you confirm that is indeed the exact same instance as . Note: Singleton classes aren’t really used as often in Python as in other languages. The effect of a singleton is usually better implemented as a global variable inside a module. Class decorators are less common than function decorators. You should document these well, so that your users know how to apply them. Decorators can provide a nice mechanism for caching and memoization. As an example, look at a recursive definition of the Fibonacci sequence: While this implementation is straightforward, its runtime performance is terrible: To calculate the tenth Fibonacci number, you should only need to calculate the preceding Fibonacci numbers, but this implementation somehow needs a whopping 177 calculations. It gets worse quickly: 21,891 calculations are needed for and almost 2.7 million calculations for the thirtieth number. This is because the code keeps recalculating Fibonacci numbers that are already known. The usual solution is to implement Fibonacci numbers using a loop and a lookup table. However, caching the calculations will also do the trick. First add a decorator to your module: The cache works as a lookup table, as it stores calculations in a dictionary. You can add it to : You still use to monitor the performance of your calculations. With the cache, only does the necessary calculations once: Note that in the call to , no new calculations were needed since the eighth Fibonacci number had already been calculated for . In the standard library, a Least Recently Used (LRU) cache is available as . Additionally, you can use a regular cache with . These decorators have more features than the one you saw above. You should use or instead of writing your own cache decorator. In the next example, you don’t return the result immediately. Instead, you add a call to to see when a result is calculated and not just retrieved from the cache: The parameter specifies how many recent calls are cached. The default value is 128, but you can specify to cache all function calls. Using has the same effect as . However, be aware that this can cause memory problems if you’re caching many large objects. You can use the method to see how the cache performs, and you can tune it if needed. In your example, you used an artificially small to see the effect of elements being removed from the cache: In these examples, you calculate a few Fibonacci numbers. Your cache only holds four calculations at a time. For example, after calculating , it holds the seventh, eight, ninth, and tenth number. Therefore, you’re able to find without doing any recalculations. Then you ask for , but that fifth number has been deleted from the cache. It therefore needs to be calculated from scratch. In most applications, you don’t need to constrain your cache and can use directly. The following example is somewhat similar to the registering plugins example from earlier, in that it doesn’t really change the behavior of the decorated function. Instead, it simply adds as a function attribute: The following example calculates the volume of a cylinder based on its radius and height in centimeters: You’ve added information to that the result should be interpreted as cubic centimeters. You can later access the function attribute when needed: Note that you could’ve achieved something similar using function annotations: However, since annotations are used for type hints, it’s a bit clunky to combine such units as annotations with static type checking. Units become even more powerful and fun when connected with a library that can convert between units. One such library is . With installed ( ), you can convert the volume to cubic inches or gallons, for example: You use to create a quantity that has both a magnitude and a unit. By calling , you convert to other units. For example, the example cylinder is about 141 cubic centimeters, which translates to approximately 8.63 cubic inches and 0.0373 gallons. You could also modify the decorator to return a directly. Such a is made by multiplying a value with the unit. In , units must be looked up in a . You can store the registry as a function attribute on the decorator to avoid cluttering the namespace: \"\"\"Have a function return a Quantity with given unit\"\"\" With the decorator, converting units is practically effortless: When Usain Bolt ran 100 meters in 9.58 seconds at the 2009 world championships, he had an average speed of 10.4 meters per second. This translates to about 37.6 kilometers per hour and 23.4 miles per hour. You’ll now look at one last use case. Take a quick look at the following Flask route handler: Here you ensure that the key is part of the request. Although this validation works, it doesn’t really belong in the function itself. Additionally, there may be other routes that use the same validation. So, to keep it DRY, you can abstract out any unnecessary logic with a decorator. The following decorator will do the job: In the above code, the decorator takes a variable-length list as an argument so that you can pass in as many string arguments as necessary, each representing a key used to validate the JSON data:\n• Line 4: The list of keys that must be present in the JSON is given as arguments to the decorator.\n• Line 9: The wrapper function validates that each expected key is present in the JSON data. The route handler can then focus on its real job—updating grades—as it can safely assume that the JSON data are valid: You apply , which simplifies the logic inside ."
    },
    {
        "link": "https://geeksforgeeks.org/decorators-in-python",
        "document": "In Python, decorators are a powerful and flexible way to modify or extend the behavior of functions or methods, without changing their actual code. A decorator is essentially a function that takes another function as an argument and returns a new function with enhanced functionality.\n\nDecorators are often used in scenarios such as logging, authentication and memorization, allowing us to add additional functionality to existing functions or methods in a clean, reusable way.\n• None decorator takes the greet function as an argument.\n• None It returns a new function (wrapper) that first prints a message, calls greet() and then prints another message.\n• None The @decorator syntax is a shorthand for greet = decorator(greet).\n• decorator_name: This is the name of the decorator function.\n• func: This parameter represents the function being decorated. When you use a decorator, the decorated function is passed to this parameter.\n• wrapper: This is a nested function inside the decorator. It wraps the original function, adding additional functionality.\n• *args: This collects any positional arguments passed to the decorated function into a tuple.\n• **kwargs: This collects any keyword arguments passed to the decorated function into a dictionary.\n• None The wrapper function allows the decorator to handle functions with any number and types of arguments.\n• None This syntax applies the decorator to the function_to_decorate function. It is equivalent to writing function_to_decorate = decorator_name(function_to_decorate).\n\nIn Python, higher-order functions are functions that take one or more functions as arguments, return a function as a result or do both. Essentially, a higher-order function is a function that operates on other functions. This is a powerful concept in functional programming and is a key component in understanding how decorators work.\n• Taking functions as arguments : A higher-order function can accept other functions as parameters.\n• Returning functions : A higher-order function can return a new function that can be called later.\n\nIn this example, first function fun is a higher-order function because it takes another function f as an argument and applies it to the value x.\n\nDecorators in Python are a type of higher-order function because they take a function as input, modify it, and return a new function that extends or changes its behavior. Understanding higher-order functions is essential for working with decorators since decorators are essentially functions that return other functions.\n\nIn Python, functions are first-class objects, meaning that they can be treated like any other object, such as integers, strings, or lists. This gives functions a unique level of flexibility and allows them to be passed around and manipulated in ways that are not possible in many other programming languages.\n\nWhat Does It Mean for Functions to Be First-Class Objects?\n• Can be assigned to variables : Functions can be assigned to variables and used just like any other value.\n• Can be passed as arguments : Functions can be passed as arguments to other functions.\n• Can be returned from other functions : Functions can return other functions, which is a key concept in decorators.\n• Can be stored in data structures : Functions can be stored in lists, dictionaries, or other data structures.\n• None The greet function is assigned to the say_hi variable, which is used to print a greeting for “Alice”.\n• None Another function, apply, takes a function and a value as arguments, applies the function to the value, and returns the result.\n• None apply is demonstrated by passing say_hi and “Bob”, printing a greeting for “Bob”.\n• None The make_mult function creates a multiplier function based on a given factor.\n• None Decorators receive the function to be decorated as an argument. This allows the decorator to modify or enhance the function’s behavior.\n• None Decorators return a new function that wraps the original function. This new function adds additional behavior before or after the original function is called.\n• None When a function is decorated, it is assigned to the variable name of the original function. This means the original function is replaced by the decorated (wrapped) function.\n\nThe most common type of decorator, which takes a function as input and returns a new function. The example above demonstrates this type.\n• simple_decorator(func): This decorator takes the function greet as an argument (func) and returns a new function (wrapper) that adds some functionality before and after calling the original function.\n• @simple_decorator: This is the decorator syntax. It applies the simple_decorator to the greet function.\n• Calling greet(): When greet() is called, it doesn’t just execute the original function but first runs the added behavior from the wrapper function.\n\nUsed to decorate methods within a class. They often handle special cases, such as the argument for instance methods.\n• method_decorator(func): The decorator takes the method (say_hello) as an argument (func). It returns a wrapper function that adds behavior before and after calling the original method.\n• wrapper(self, *args, **kwargs): The wrapper must accept self because it is a method of an instance. self is the instance of the class and *args and **kwargs allow for other arguments to be passed if needed.\n• @method_decorator: This applies the method_decorator to the say_hello method of MyClass.\n• Calling obj.say_hello(): The say_hello method is now wrapped with additional behavior.\n\nClass decorators are used to modify or enhance the behavior of a class. Like function decorators, class decorators are applied to the class definition. They work by taking the class as an argument and returning a modified version of the class.\n• add_class_name(cls): This decorator adds a new attribute, class_name, to the class cls. The value of class_name is set to the name of the class (cls.__name__).\n• @add_class_name: This applies the add_class_name decorator to the Person class.\n• Result: When the Person class is defined, the decorator automatically adds the class_name attribute to it.\n• print(Person.class_name): Accessing the class_name attribute that was added by the decorator prints the name of the class, Person.\n\nPython provides several built-in decorators that are commonly used in class definitions. These decorators modify the behavior of methods and attributes in a class, making it easier to manage and use them effectively. The most frequently used built-in decorators are , , and .\n\nThe decorator is used to define a method that doesn’t operate on an instance of the class (i.e., it doesn’t use ). Static methods are called on the class itself, not on an instance of the class.\n• None add is a static method defined with the @staticmethod decorator.\n• None It can be called directly on the class MathOperations without creating an instance.\n\nThe @classmethod decorator is used to define a method that operates on the class itself (i.e., it uses cls). Class methods can access and modify class state that applies across all instances of the class.\n• None set_raise_amount is a class method defined with the @classmethod decorator.\n• None It can modify the class variable raise_amount for the class Employee and all its instances.\n\nThe @property decorator is used to define a method as a property, which allows you to access it like an attribute. This is useful for encapsulating the implementation of a method while still providing a simple interface.\n• None radius and area are properties defined with the @property decorator.\n• None The radius property also has a setter method to allow modification with validation.\n• None These properties provide a way to access and modify private attributes while maintaining encapsulation.\n\nWhen should you use decorators in Python?\n\nWhat is function vs decorators in Python?\n\nWhat is __init__ in Python?\n\nWhat is the difference between decorator and annotation in Python?\n\nWhat is the difference between wrapper and decorator in Python?"
    },
    {
        "link": "https://datacamp.com/tutorial/decorators-python",
        "document": "Learn the art of writing your own functions in Python, as well as key concepts like scoping and error handling."
    },
    {
        "link": "https://programiz.com/python-programming/decorator",
        "document": "In Python, a decorator is a design pattern that allows you to modify the functionality of a function by wrapping it in another function.\n\nThe outer function is called the decorator, which takes the original function as an argument and returns a modified version of it.\n\nBefore we learn about decorators, we need to understand a few important concepts related to Python functions. Also, remember that everything in Python is an object, even functions are objects.\n\nWe can include one function inside another, known as a nested function. For example,\n\nHere, we have created the function inside the function.\n\nWe can pass a function as an argument to another function in Python. For Example,\n\nIn the above example, the function takes a function as its argument. While calling , we are passing the function as the argument.\n\nIn the function, arguments: , , become , , and respectively.\n\nAnd hence, becomes which returns 10.\n\nIn Python, we can also return a function as a return value. For example,\n\nIn the above example, the statement returns the inner function. This function is now assigned to the variable.\n\nThat's why, when we call as a function, we get the output.\n\nAs mentioned earlier, A Python decorator is a function that takes in a function and returns it by adding some functionality.\n\nIn fact, any object which implements the special method is termed callable. So, in the most basic sense, a decorator is a callable that returns a callable.\n\nBasically, a decorator takes in a function, adds some functionality and returns it.\n\nHere, we have created two functions:\n• that takes a function as its argument and has a nested function named , and returns the inner function.\n\nWe are calling the function normally, so we get the output . Now, let's call it using the decorator function.\n\nIn the example shown above, is a decorator. Notice the code,\n• We are now passing the function as the argument to the .\n• The function returns the inner function, and it is now assigned to the variable.\n\nHere, we are actually calling the function, where we are printing\n\nInstead of assigning the function call to a variable, Python provides a much more elegant way to achieve this functionality using the symbol. For example,\n\nHere, the function is decorated with the decorator using the syntax, which is equivalent to calling .\n\nThe above decorator was simple and it only worked with functions that did not have any parameters. What if we had functions that took in parameters like:\n\nThis function has two parameters, and . We know it will give an error if we pass in as 0.\n\nNow let's make a decorator to check for this case that will cause the error.\n\nHere, when we call the function with the arguments (2,5), the function defined in the decorator is called instead.\n\nThis function calls the original function with the arguments 2 and 5 and returns the result, which is 0.4.\n\nSimilarly, When we call the function with the arguments (2,0), the function checks that is equal to 0 and prints an error message before returning .\n\nMultiple decorators can be chained in Python.\n\nTo chain decorators in Python, we can apply multiple decorators to a single function by placing them one after the other, with the most inner decorator being applied first.\n\nThe above syntax of,\n\nThe order in which we chain decorators matter. If we had reversed the order as,\n\nThe output would be:"
    },
    {
        "link": "https://freecodecamp.org/news/the-python-decorator-handbook",
        "document": "Python decorators provide an easy yet powerful syntax for modifying and extending the behavior of functions in your code.\n\nA decorator is essentially a function that takes another function, augments its functionality, and returns a new function – without permanently modifying the original function itself.\n\nThis tutorial will walk you through 11 handy decorators to help add functionality like timing execution, caching, rate limiting, debugging and more. Whether you want to profile performance, improve efficiency, validate data, or manage errors, these decorators have got you covered!\n\nThe examples here focus on the common usage patterns and utilities of decorators that can come in handy in your day-to-day programming and save you a lot of effort. Understanding the flexibility of decorators will help you write clean, resilient, and optimized application code.\n\nHere are the decorators covered in this tutorial:\n• None Log Arguments and Return Value of a Function\n• None Get the Execution Time of a Function\n• None Convert Function Return Value to a Specified Data Type\n\nBut first, a little introduction.\n\nBefore diving in, let's understand some key benefits of decorators in Python:\n• None Enhancing functions without invasive changes: Decorators augment functions transparently without altering the original code, keeping the core logic clean and maintainable.\n• None Reusing functionality across places: Common capabilities like logging, caching, and rate limiting can be built once in decorators and applied wherever needed.\n• None Readable and declarative syntax: The syntax simply conveys functionality enhancement at the definition site.\n• None Modularity and separation of concerns: Decorators promote loose coupling between functional logic and secondary capabilities like performance, security, logging etc.\n\nThe takeaway is that decorators unlock simple yet flexible ways of transparently enhancing Python functions for improved code organization, efficiency, and reuse without introducing complexity or redundancy.\n\nHere is a basic example of decorator syntax in Python with annotations:\n\nA decorator in Python is a function that takes another function as an argument and extends its behavior without modifying it. The decorator function wraps the original function by defining a wrapper function inside of it. This wrapper function executes code before and after calling the original function.\n\nSpecifically, when defining a decorator function such as in the example, it takes a function as an argument, which we generally call . This will be the actual function that is decorated under the hood.\n\nThe wrapper function inside can execute arbitrary code before and after calling , which invokes the original function. When applying before the definition of , it passes as an argument to , so func refers to in that context.\n\nThe wrapper function then returns the enhanced wrapped function. So now has been decorated by . When it is later called, the wrapper code inside executes before and after runs. This allows decorators to transparently extend the behavior of a function, without needing to modify the function itself.\n\nAnd as you'll recall, the original remains unchanged, keeping decorators non-invasive and flexible.\n\nWhen is decorated with , it is automatically enhanced. The function here returns a wrapper function. This wrapper function gets executed when the is called now.\n\nFirst, the wrapper prints before actually calling the original function being decorated. Then, after executes, it prints .\n\nSo, additional behavior and printed messages are added before and after the execution in the wrapper, without directly modifying itself. The decorator allows you to extend in a transparent way without affecting its core logic, as the wrapper handles the enhanced behavior.\n\nSo let's start exploring the top 11 practical decorators that every Python developer should know.\n\nLog Arguments and Return Value of a Function\n\nThe Log Arguments and Return Value decorator tracks the input parameters and output of functions. This supports debugging by logging a clear record of data flow through complex operations.\n\nIn this example, the decorator function is named and accepts a function, , as its argument. Within , a nested function called is defined. This function is what the decorator returns and effectively replaces the original function.\n\nWhen the function is invoked, it prints logging statements pertaining to the function call. Then it calls the original function, , captures its result, prints the outcome, and returns the result.\n\nThe syntax above the function is a Python convention to apply the as a decorator to the function. So when is invoked, it's actually invoking the function returned by . Therefore, acts as a wrapper, introducing logging statements before and after the execution of the original function.\n\nThis decorator is widely adopted in application development for adding runtime logging without interfering with business logic implementation.\n\nFor example, consider a banking application that processes financial transactions. The core transaction processing logic resides in functions like and . To monitor these transactions, logging can be added by including above each function.\n\nThen when transactions are triggered by calling , you can print the function name, arguments like the sender, receiver, and amount before the actual transfer. Then after the function returns, you can print the whether the transfer succeeded or failed.\n\nThis type of logging with decorators allows you to track transactions without adding any code to core functions like . The logic stays clean while debuggability and observability improves. Logging messages can be directed to a monitoring dashboard or log analytics system as well.\n\nGet the Execution Time of a Function\n\nThis decorator is your ally in the quest for performance optimization. By measuring and logging the execution time of a function, this decorator facilitates a deep dive into the efficiency of your code, helping you pinpoint bottlenecks and streamline your application's performance.\n\nIt's ideal for scenarios where speed is crucial, such as real-time applications or large-scale data processing. And it allows you to identify and address performance bottlenecks systematically.\n\nThis code showcases a decorator that's designed to measure the execution duration of functions.\n\nThe decorator takes a function, , and defines an inner function, , to wrap the original function. Upon invocation, records the start time, calls the original function, records the end time, calculates the duration, and prints it.\n\nThe syntax applies this decorator to functions below it, such as . Consequently, when is called, it invokes the wrapper, which logs the duration alongside the function result.\n\nThis example illustrates how decorators seamlessly augment existing functions with additional functionality, like timing, without direct modification.\n\nThis decorator is helpful in profiling functions to identify performance bottlenecks in applications. For example, consider an e-commerce site with several backend functions like , , and so on. By decorating them with , you can monitor their runtime.\n\nWhen is invoked in a user session, the decorator will time its execution duration by recording a start and end timestamp. After execution, it will print the time taken before returning recommendations.\n\nDoing this systematically across applications and analyzing outputs will show you the functions that are taking an unusually long time. The development team can then optimize such functions through caching, parallel processing, and other techniques to improve overall application performance.\n\nWithout such timing decorators, finding optimization candidates would require tedious logging code additions. Decorators provide visibility easily without contaminating business logic.\n\nConvert Function Return Value to a Specified Data Type\n\nThe Convert Return Value Type decorator enhances data consistency in functions by automatically converting the return value to a specified data type, promoting predictability and preventing unexpected errors. It is particularly useful for downstream processes that require consistent data types, reducing runtime errors.\n\nThe above code example shows a decorator that's designed to convert the return value of a function to a specified data type.\n\nThe decorator, named , takes the target data type as a parameter and returns a decorator named . Within this decorator, a function is defined to call the original function, convert its return value to the target type using , and subsequently return the converted result.\n\nThe syntax that's applied above a function (such as ) utilizes this decorator to convert the return value to an integer. Similarly, for , passing formats the return value as a string.\n\nThis example also showcases how decorators seamlessly modify function outputs to desired formats without altering the core logic of the functions.\n\nThis return value transformation decorator proves useful in applications where you need to automatically adapt functions to expected data formats.\n\nFor instance, you could use it in a weather API that returns temperatures by default in decimal format like 23.456 degrees. But the consumer front-end application expects an integer value to display.\n\nInstead of changing the API function to return an integer, just decorate it with . This will seamlessly convert the decimal temperature to the integer , in this example, before returning to the client app. Without any API function modification, you've reformatted the return value.\n\nSimilarly for backend processing expecting JSON, return values can be converted using the decorator. The core logic stays unchanged while the presentation format adapts based on your use case's needs. This avoids duplication of format handling code across functions.\n\nDecorators externally impose required data representations for seamless integration and reusability across application layers with mismatched formats.\n\nThis decorator optimizes performance by storing and retrieving function results, eliminating redundant computations for repeated inputs, and improving application responsiveness, especially for time-consuming computations.\n\nThis code sample showcases a decorator that's designed to cache and reuse function call results efficiently.\n\nThe function takes another function and returns a wrapper. Within this wrapper, a cache dictionary ( ) stores unique call parameters and their corresponding results.\n\nBefore executing the actual function, the checks if the result for the current parameters is already in the cache. If so, it retrieves and returns the cached result – otherwise, it calls the function, stores the result in the cache, and returns it.\n\nThe syntax applies this caching logic to any function, such as . This ensures that, upon subsequent calls with the same arguments, the cached result is reused, preventing redundant calculations.\n\nIn essence, the decorator enhances functionality by optimizing performance through result caching.\n\nCaching decorators like this are extremely useful in application development for optimizing performance of repetitive function calls.\n\nFor example, consider a recommendation engine calling predictive model functions to generate user suggestions. prepares the input data and feeds into the model for every user request.Instead of re-running computations, it can be decorated with to introduce caching layer.\n\nNow the first time unique user parameters are passed, the model runs and the result caches. Subsequent calls with the same inputs directly return the cached model outputs, skipping the model recalculation.\n\nThis drastically improves latency for responding to user requests by avoiding duplicate model inferences. You can monitor cache hit rates to justify scaling down model server infrastructure costs.\n\nDecoupling such optimization concerns through caching decorators rather than mixing them inside function logic improves modularity, readability and allows rapid performance gains. Caches will be configured, invalidated separately without intruding business functions.\n\nThis one checks if input arguments meet predefined criteria before execution, enhancing function reliability and preventing unexpected behavior. It is useful for parameters requiring positive integers or non-empty strings.\n\nThis code showcases how you can implement a decorator for validating function arguments.\n\nThe is a decorator factory that generates an decorator. This validator, when applied with above the function, checks if the condition (in this case, that the argument should be greater than 0) holds true for the passed arguments.\n\nIf the condition is met, the decorated function is executed – otherwise, a exception is raised.\n\nThis succinct example illustrates how decorators serve as a mechanism for validating function arguments before their execution, ensuring adherence to specified conditions.\n\nSuch parameter validation decorators are extremely useful in applications to help enforce business rules, security constraints, and so on.\n\nFor example, an insurance claims processing system would have a function that takes details like claim id, approver name, and so on. Certain business rules dictate who can approve claims.\n\nRather than cluttering the function logic itself, you can decorate it with which validates if the approver role matches the claim amount. If a junior agent tries approving a large claim (thus violating the rules), this decorator would catch it by raising exception even before executes.\n\nSimilarly, input data validation constraints for security and compliance can be imposed without touching individual functions. Decorators externally ensure that violated arguments never reach application risks.\n\nCommon validation patterns should be reused across multiple functions. This improves security and promotes separation of concerns by isolating constraints from core logic flow in a modular way.\n\nThis decorator comes handy when you want to automatically retry a function after failure, enhancing its resilience in situations involving transient failures. It is used for external services or network requests prone to intermittent failures.\n\nThis example introduces a decorator that's designed for retrying function executions in the event of failures. It has a specified maximum attempt count and delay between retries.\n\nThe is a decorator factory, taking parameters for maximum retry count and delay, and returning a that manages the retry logic.\n\nWithin the function, the decorated function undergoes execution in a loop, attempting a specified maximum number of times.\n\nIn case of an exception, it prints an error message, introduces a delay specified by , and retries. If all attempts fail, it raises an exception indicating that the maximum attempts have been exceeded.\n\nThe applied above integrates this retry logic, allowing for up to 3 retries with a 2-second delay between each attempt in case the database connection encounters failures.\n\nThis demonstrates the utility of decorators in seamlessly incorporating retry capabilities without altering the core function code.\n\nThis retry decorator can prove extremely useful in application development for adding resilience against temporary or intermittent errors.\n\nFor instance, consider a flight booking app that calls a payment gateway API to handle customer transactions. Sometimes network blips or high loads at payment provider end could cause transient errors in API response.\n\nRather than directly showing failures to customers, the function can be decorated with to handle such scenarios implicitly. Now when a payment fails once, it will seamlessly retry sending the request up to 3 times before finally reporting the error if it persists.\n\nThis provides shielding from temporary hiccups without exposing users to unreliable infrastructure behavior directly.The application also remains available reliably even if dependent services fail occasionally.\n\nThe decorator helps confine the retry logic neatly without spreading it across the API's code. Failures beyond the app's control are handled gracefully rather than directly impacting users by application faults. This demonstrates how decorators lend better resilience without complicating business logic.\n\nBy controlling the frequency of functions called, the Enforce Rate Limits decorator ensures effective resource management and guards against misuse. It is especially helpful in scenarios like API misuse or resource conservation where restricting function calls is essential.\n\nThis code showcases the implementation of a rate-limiting mechanism for function calls using a decorator.\n\nThe function, specified with maximum calls and a period in seconds to reset the count, serves as the core of the rate-limiting logic. The decorator, , employs a wrapper to manage the rate limits by resetting the count if the period has elapsed. It checks if the count has reached the maximum allowed, and then either raises an exception or increments the count and executes the function accordingly.\n\nApplied to using , it restricts the function to six calls within any 10-second period. This introduces rate limiting without changing the function logic, ensuring that calls adhere to limits and preventing excessive use within set intervals.\n\nRate limiting decorators like this are very useful in application development for controlling usage of APIs and preventing abuse.\n\nFor instance, a travel booking application may rely on third party Flight Search API for checking live seat availability across airlines. While most usage is legitimate, some users could potentially call this API excessively, degrading overall service performance.\n\nBy decorating the API integration module like , the application can restrict excessive calls internally, too. This would limit the booking module to make only 100 Flight API calls per minute. Additional calls get rejected directly through the decorator without even reaching actual API.\n\nThis saves downstream service from overuse enabling fairer distribution of capacity for general application functionality.\n\nDecorators provide easy rate control for both internal and external facing APIs without changing functional code. This means you don't have to account for usage quotas while safeguarding services, infrastructure, and bounding adoption risk. And it's all thanks to application-side controls using wrappers.\n\nThe Handle Exceptions decorator is a safety net for functions, gracefully handling exceptions and providing default responses when they occur. It shields the application from crashing due to unforeseen circumstances, ensuring smooth operation.\n\nThis code showcases exception handling in functions using decorators.\n\nThe decorator factory, accepting a default response, produces . This decorator, when applied to functions, attempts to execute the original function. If an exception arises, it prints error details, and returns the specified default response.\n\nThe syntax above a function incorporates this exception-handling logic. For instance, in , division by zero triggers an exception, which the decorator catches, preventing a crash and returning the default \"An error occurred!\" response.\n\nEssentially, these decorators adeptly capture exceptions in functions, providing a seamless means of incorporating handling logic and preventing crashes.\n\nException handling decorators greatly simplify application error management and help hide unreliable behavior from users.\n\nFor example, an e-commerce website may rely on payment, inventory, and shipping services to complete orders. Instead of complex exception blocks everywhere, core order processing function like can be decorated to achieve resilience.\n\nThe decorator applied above it would absorb any third party service outage or intermittent issue during order finalization. On exception, it logs errors for debugging while serving a graceful \"Order failed, please try again later\" message to the customer. This avoids expose complex failure root causes like payment timeouts to end user.\n\nDecorators shield customers from unreliable service issues without changing business code. They provide friendly default responses when errors happen. This improves customer experience\n\nAlso, decorators give developers visibility into those errors behind the scenes. So they can focus on systematically fixing the root causes of failures. This separation of concerns through decorators reduces complexity. Customers see more reliability, and you get actionable insights into faults – all while keeping business logic untouched.\n\nThe Enforce Type Checking decorator ensures data integrity by verifying function arguments conform to specified data types, preventing type-related errors, and promoting code reliability. It is particularly useful in situations where strict data type adherence is crucial.\n\nThe decorator validates whether the arguments passed to a function match the specified type annotations.\n\nInside the , it examines the signature of the decorated function, retrieves parameter names and type annotations, and ensures that the provided arguments align with the expected types. This includes checking positional arguments against their order, and keyword arguments against parameter names. If a type mismatch is detected, a TypeError is raised.\n\nThis decorator is exemplified by its application to the function, where arguments are annotated as integers. Attempting to pass a string results in an exception, while passing integers executes the function without issues. This type checking is enforced without altering the original function body.\n\nType checking decorators are applied to detect issues early and improve reliability. For example, consider a web application backend with a data access layer function annotated to expect integer user IDs. Its queries would fail if string IDs flow into it from frontend code.\n\nRather than add explicit checks and raise exceptions locally, you can use this decorator. Now any upstream or consumer code passing invalid types will be automatically caught during function execution. The decorator examines annotations versus argument types and throws errors accordingly before reaching the database layer.\n\nThis runtime protection for components through decorators ensures that only valid data shapes flow across layers, preventing obscure errors. Type safety is imposed without extra checks cluttering cleaner logic.\n\nWhen it comes to large dataset-intensive applications or resource-constrained environments, the Measure Memory Usage Decorator is a memory detective that offers insights into function memory consumption. It does this by optimising memory usage.\n\nThis code showcases a decorator, , designed to measure the memory consumption of functions.\n\nThe decorator, when applied, initiates memory tracking before the original function is called. Once the function completes its execution, a memory snapshot is taken and the top 5 lines consuming the most memory are printed.\n\nIllustrated through the example of , the decorator allows you to monitor memory usage without altering the function itself, offering valuable insights for optimization purposes.\n\nIn essence, it provides a straightforward means to assess and analyze the memory consumption of any function during its runtime.\n\nMemory measurement decorators like these are extremely valuable in application development for identifying and troubleshooting memory bloat or leak issues.\n\nFor example, consider a data streaming pipeline with critical ETL components like that processes large volumes of information. Though the process seems fine during regular loads, high volume data like Black Friday sales could cause excessive memory usage and crashes.\n\nRather than manual debugging, decorating processors like @measure_memory_usage can reveal useful insights. It will print the top memory intensive lines during peak data flow without any code change.\n\nYou should aim to pinpoint specific stages eating up memory rapidly and address through better algorithms or optimization.\n\nSuch decorators help bake diagnostics perspectives across critical paths to recognize abnormal consumption trends early. Instead of delayed production issues, problems can be preemptively identified through profiling before release. They reduce debugging headaches and minimize runtime failures via easier instrumentation for memory tracking.\n\nSpecifically designed for outdated data, the Cache Function Results with Expiration Time Decorator is a tool that combines caching with a time-based expiration feature to make sure that cached data is regularly refreshed to prevent staleness and maintain relevance.\n\nThis code showcases a caching decorator that has an automatic cache expiration time.\n\nThe function generates a decorator that, when applied, utilizes a dictionary called to store function results and their corresponding timestamps. The function checks if the result for the current arguments is in the cache. If present and within the expiry time, it returns the cached result – otherwise, it calls the function.\n\nIllustrated using , the decorator initially calculates and caches the result. Subsequent calls retrieve the cached result until the expiry period, at which point the cache is refreshed through a recalculation.\n\nIn essence, this implementation prevents redundant calculations while automatically refreshing results after the specified expiry period.\n\nAutomatic cache expiry decorators are very useful in application development for optimizing performance of data fetching modules.\n\nFor example, consider a travel website that calls backend API to show live prices to users. While caches reduce calls to expensive flight data sources, static caching leads to displaying stale prices.\n\nInstead, you can use to auto-refresh every minute. Now, the first user call fetches live prices and caches them, while subsequent requests in a 60s window efficiently reuse the cached pricing. But caches automatically invalidate after the expiry period to guarantee fresh data.\n\nThis allows your to optimize flows without worrying about corner cases related to outdated representations. This decorator handles the situation reliably, keeping caches in sync with upstream changes through configurable refreshing. There's zero redundancy of recalculations, and you still get the best possible updated information to end users. Common caching patterns get packaged conveniently for reuse across codebase with customized expiry rules.\n\nPython decorators continue to see widespread usage in application development for cleanly inserting common cross-cutting concerns. Authentications, monitoring, and restrictions are some standard examples of use cases that use decorators in frameworks like Django and Flask.\n\nThe popularity of web APIs has also lead to common adoption of rate limiting and caching decorators for performance.\n\nDecorators have actually been around since early Python releases. Guido van Rossum wrote about enhancement with decorators in a 1990 paper on Python. Later when function decorators syntax stabilized in Python 2.4 in 2004, it opened the doors for elegant solutions through oriented programming. From web to data science, they continue to empower abstraction and modularity across Python domains.\n\nThe examples in this handbook only scratch the surface of what custom tailored decorators can enable. Based on any specific objective like security, throttling user requests, transparent encryption, and so on, you can create innovative decorators to address your needs. Structuring logic processing pipelines using a composition of specialized single-responsibility decorators also encourages reuse over redundancy.\n\nUnderstanding decorators not only improves development skills but unlocks ways to dictate program behaviour flexibly. I encourage you to assess common needs across your codebases that can be abstracted into standalone decorators. With some practice, it becomes easy to spot cross-cutting concerns and extend functions efficiently without breaking a sweat.\n\nIf you liked this lesson and would like to explore more insightful tech content, including Python, Django, and System Design reads, check out my Blog. You can also view my projects with proof of work on GitHub and connect with me on LinkedIn for a chat."
    },
    {
        "link": "https://realpython.com/primer-on-python-decorators",
        "document": "Python decorators allow you to modify or extend the behavior of functions and methods without changing their actual code. When you use a Python decorator, you wrap a function with another function, which takes the original function as an argument and returns its modified version. This technique provides a simple way to implement higher-order functions in Python, enhancing code reusability and readability.\n\nBy the end of this tutorial, you’ll understand that:\n• Practical use cases for decorators include logging, enforcing access control, caching results, and measuring execution time.\n• Custom decorators are written by defining a function that takes another function as an argument, defines a nested wrapper function, and returns the wrapper.\n• Multiple decorators can be applied to a single function by stacking them before the function definition.\n• The order of decorators impacts the final output since each decorator wraps the next, influencing the behavior of the decorated function.\n\nYou can find all the examples from this tutorial by downloading the accompanying materials below:\n\nIn order to understand decorators, you must first understand some finer points of how functions work. There are many aspects to functions, but in the context of decorators, a function returns a value based on the given arguments. Here’s a basic example: In general, functions in Python may also have side effects rather than just turning an input into an output. The function is an example of this: it returns while having the side effect of outputting something to the console. However, to understand decorators, it’s enough to think about functions as tools that turn given arguments into values. In functional programming, you work almost entirely with pure functions that don’t have side effects. While not a purely functional language, Python supports many functional programming concepts, including treating functions as first-class objects. This means that functions can be passed around and used as arguments, just like any other object like , , , , and so on. Consider the following three functions: , together we're the awesomest!\" Here, and are regular functions that expect a name given as a string. The function, however, expects a function as its argument. You can, for example, pass it the or the function. To test your functions, you can run your code in interactive mode. You do this with the flag. For example, if your code is in a file named , then you run : 'Yo Bob, together we're the awesomest!' Note that refers to two functions, and , but in different ways. The function is named without parentheses. This means that only a reference to the function is passed. The function isn’t executed. The function, on the other hand, is written with parentheses, so it will be called as usual. This is an important distinction that’s crucial for how functions work as first-class objects. A function name without parentheses is a reference to a function, while a function name with trailing parentheses calls the function and refers to its return value. It’s possible to define functions inside other functions. Such functions are called inner functions. Here’s an example of a function with two inner functions: What happens when you call the function? Think about this for a minute. Then run in interactive mode to try it out. The output will be as follows: Note that the order in which the inner functions are defined does not matter. Like with any other functions, the printing only happens when the inner functions are executed. Furthermore, the inner functions aren’t defined until the parent function is called. They’re locally scoped to , meaning they only exist inside the function as local variables. Try calling . You’ll get an error: : name 'first_child' is not defined Whenever you call , the inner functions and are also called. But because of their local scope, they aren’t available outside of the function. Python also allows you to return functions from functions. In the following example, you rewrite to return one of the inner functions: Note that you’re returning without the parentheses. Recall that this means that you’re returning a reference to the function . In contrast, with parentheses refers to the result of evaluating the function. You can see this in the following example: The somewhat cryptic output means that the variable refers to the local function inside of , while points to . You can now use and as if they’re regular functions, even though you can’t directly access the functions they point to: You recognize the return values of the inner functions that you defined inside of . Finally, note that in the earlier example, you executed the inner functions within the parent function—for example, . However, in this last example, you didn’t add parentheses to the inner functions, such as , upon returning. That way, you got a reference to each function that you could call in the future.\n\nNow that you’ve seen that functions are just like any other object in Python, you’re ready to move on and see the magical beast that is the Python decorator. You’ll start with an example: \"Something is happening before the function is called.\" \"Something is happening after the function is called.\" Here, you’ve defined two regular functions, and , and one inner function. Then you redefined to apply to the original . Can you guess what happens when you call ? Try it in a REPL. Instead of running the file with the flag, you can also import the function manually: Something is happening before the function is called. Something is happening after the function is called. To understand what’s going on here, look back at the earlier examples. You’re applying everything that you’ve learned so far. The so-called decoration happens at the following line: In effect, the name now points to the inner function. Remember that you return as a function when you call : However, has a reference to the original as , and it calls that function between the two calls to . Before moving on, have a look at a second example. Because is a regular Python function, the way a decorator modifies a function can change dynamically. So as not to disturb your neighbors, the following example will only run the decorated code during the day: If you try to call after bedtime, nothing will happen: Here, doesn’t print any output. That’s because the test failed, so the wrapper didn’t call , the original . Look back at the code that you wrote in . The way you decorated is a little clunky. First of all, you end up typing the name three times. Additionally, the decoration gets hidden away below the definition of the function. Instead, Python allows you to use decorators in a simpler way with the symbol, sometimes called the pie syntax. The following example does the exact same thing as the first decorator example: \"Something is happening before the function is called.\" \"Something is happening after the function is called.\" So, is just a shorter way of saying . It’s how you apply a decorator to a function. Recall that a decorator is just a regular Python function. All the usual tools for reusability are available. Now, you’ll create a module where you store your decorators and that you can use in many other functions. Create a file called with the following content: The decorator calls the decorated function twice. You’ll soon see the effect of this in several examples. Note: You can name your inner function whatever you want, and a generic name like is usually okay. You’ll see a lot of decorators in this tutorial. To keep them apart, you’ll name the inner function with the same name as the decorator but with a prefix. You can now use this new decorator in other files by doing a regular import: When you run this example, you should see that the original is executed twice: There are two Whee! exclamations printed, confirming that does what it says on the tin. Free Bonus: Click here to get access to a free \"The Power of Python Decorators\" guide that shows you three advanced decorator patterns and techniques you can use to write cleaner and more Pythonic programs. Say that you have a function that accepts some arguments. Can you still decorate it? Give it a try: You now apply to , which expects a name. Unfortunately, calling this function raises an error: : wrapper_do_twice() takes 0 positional arguments but 1 was given The problem is that the inner function doesn’t take any arguments, but you passed to it. You could fix this by letting accept one argument, but then it wouldn’t work for the function that you created earlier. The solution is to use and in the inner wrapper function. Then it’ll accept an arbitrary number of positional and keyword arguments. Rewrite as follows: The inner function now accepts any number of arguments and passes them on to the function that it decorates. Now both your and examples work. Start a fresh REPL: You use the same decorator, , to decorate two different functions. This hints at one of the powers of decorators. They add behavior that can apply to many different functions. What happens to the return value of decorated functions? Well, that’s up to the decorator to decide. Say you decorate a simple function as follows: Oops, your decorator ate the return value from the function. Because the doesn’t explicitly return a value, the call ends up returning . To fix this, you need to make sure the wrapper function returns the return value of the decorated function. Change your file: Now you return the return value of the last call of the decorated function. Check out the example again: A great convenience when working with Python, especially in the interactive shell, is its powerful introspection ability. Introspection is the ability of an object to know about its own attributes at runtime. For instance, a function knows its own name and documentation: Help on built-in function print in module builtins: When you inspect , you can see its name and documentation. The introspection works for functions that you define yourself as well: Help on function wrapper_do_twice in module decorators: However, after being decorated, has gotten very confused about its identity. It now reports being the inner function inside the decorator. Although technically true, this isn’t very useful information. To fix this, decorators should use the decorator, which will preserve information about the original function. Update again: You don’t need to change anything about the decorated function, but you need to restart your REPL to see the effect: Help on function say_whee in module whee: Much better! Now is still itself after decoration. Note: The decorator uses to update special attributes like and that are used in the introspection. You’ve now learned the basics of how to create a decorator. However, isn’t a very exciting decorator, and there aren’t a lot of use cases for it. In the next section, you’ll implement several decorators that illustrate what you know so far and that you can use in your own code.\n\nYou’ll now look at a few more useful examples of decorators. You’ll notice that they’ll mainly follow the same pattern that you’ve learned so far: This formula is a good boilerplate template for building more complex decorators. You’ll continue to store your decorators in . Recall that you can download all the examples in this tutorial: Get Your Code: Click here to download the free sample code that shows you how to create and use Python decorators. You’ll start by creating a decorator. It’ll measure the time a function takes to execute and then print the duration to the console. Here’s the code: \"\"\"Print the runtime of the decorated function\"\"\" This decorator works by storing the time just before the function starts running in line 10 and just after the function finishes in line 12. The runtime of the function is then the difference between the two, calculated in line 13. You use , which does a good job of measuring time intervals. Now, add as an example of a function that spends some time, so that you can test . Here are some examples of timings: Run it yourself. Work through the definition of line by line. Make sure you understand how it works. Don’t worry if you don’t get everything, though. Decorators are advanced beings. Try to sleep on it or make a drawing of the program flow. Note: The decorator is great if you just want to get an idea about the runtime of your functions. If you want to do more precise measurements of code, then you should instead consider the module in the standard library. It temporarily disables garbage collection and runs multiple trials to strip out noise from short function calls. If you’re interested in learning more about timing functions, then have a look at Python Timer Functions: Three Ways to Monitor Your Code. The following decorator will print a function’s arguments and its return value every time you call the function: \"\"\"Print the function signature and return value\"\"\" The signature is created by joining the string representations of all the argument:\n• Line 9: You create a list of the positional arguments. Use to get a nice string representing each argument.\n• Line 10: You create a list of the keyword arguments. The f-string formats each argument as , and again, you use to represent the value.\n• Line 11: You join together the lists of positional and keyword arguments to one signature string with each argument separated by a comma.\n• Line 14: You print the return value after the function is executed. It’s time to see how the decorator works in practice by applying it to a simple function with one positional and one keyword argument: Note how the decorator prints the signature and return value of the function: This example might not seem immediately useful since the decorator just repeats what you wrote. It’s more powerful when applied to small convenience functions that you don’t call directly yourself. The following example calculates an approximation of the mathematical constant e: Here, you also apply a decorator to a function that has already been defined. In line 4, you decorate from the standard library. You can’t use the pie syntax, but you can still manually apply the decorator. The approximation of e is based on the following series expansion: When calling the function, you can see the decorator at work: In this example, you get a decent approximation of the true value e ≈ 2.718281828, adding only five terms. In this section, you’ll create a decorator that slows down your code. This might not seem very useful. Why would you want to slow down your Python code? Probably the most common use case is that you want to rate-limit a function that continuously checks whether a resource—like a web page—has changed. The decorator will sleep one second before it calls the decorated function: \"\"\"Sleep 1 second before calling the function\"\"\" In , you call to have your code take a pause before calling the decorated function. To see how the decorator works, you create a function. To see the effect of slowing down the code, you should run the example yourself: In , you check if is smaller than one. In that case, you print Liftoff!. If not, then you print the number and keep counting. Note: The function is a recursive function. In other words, it’s a function calling itself. To learn more about recursive functions in Python, see Thinking Recursively in Python. The decorator always sleeps for one second. Later, you’ll see how to control the rate by passing an argument to the decorator. Decorators don’t have to wrap the function that they’re decorating. They can also simply register that a function exists and return it unwrapped. You can use this, for example, to create a lightweight plugin architecture: The decorator only stores a reference to the decorated function in the global dictionary. Note that you don’t have to write an inner function or use in this example because you’re returning the original function unmodified. You can now register functions as follows: , together we're the awesomest!\" Note that the dictionary already contains references to each function object that’s registered as a plugin: Python applies decorators when you define a function, so and are immediately registered. You can then use to call these functions: The function randomly chooses one of the registered functions to use. In the f-string, you use the flag. This has the same effect as calling . The main benefit of this simple plugin architecture is that you don’t need to maintain a list of which plugins exist. That list is created when the plugins register themselves. This makes it trivial to add a new plugin: just define the function and decorate it with . If you’re familiar with in Python, then you might see some similarities to how the plugin architecture works. With , you get access to all global variables in the current scope, including your plugins: {..., # Many variables that aren't not shown here. Using the decorator, you can create your own curated list of interesting names, effectively hand-picking some functions from . The final example before moving on to some fancier decorators is commonly used when working with a web framework. In this example, you’ll use Flask to set up a web page that should only be visible to users that are logged in or otherwise authenticated: \"\"\"Make sure user is logged in before proceeding\"\"\" While this gives an idea about how to add authentication to your web framework, you should usually not write these types of decorators yourself. For Flask, you can use the Flask-Login extension instead, which adds more security and functionality.\n\nSo far, you’ve seen how to create simple decorators. You already have a pretty good understanding of what decorators are and how they work. Feel free to take a break from this tutorial to practice everything that you’ve learned. In the second part of this tutorial, you’ll explore more advanced features, including how to do the following:\n• Add several decorators to one function\n• Create decorators that can optionally take arguments Ready to dive in? Here you go! There are two different ways that you can use decorators on classes. The first one is very close to what you’ve already done with functions: you can decorate the methods of a class. This was one of the motivations for introducing decorators back in the day. Some commonly used decorators are even built-ins in Python, including , , and . The and decorators are used to define methods inside a class namespace that aren’t connected to a particular instance of that class. The decorator is used to customize getters and setters for class attributes. Expand the box below for an example using these decorators: The following definition of a class uses the , , and decorators: \"\"\"Get value of radius\"\"\" \"\"\"Calculate volume of cylinder with circle as base\"\"\" \"\"\"Value of π, could use math.pi instead though\"\"\" Inside you can see several different kinds of methods. Decorators are used to distinguish them:\n• is a mutable property. It can be set to a different value. However, by defining a setter method, you do some error testing to make sure isn’t set to a nonsensical negative number. Properties are accessed as attributes without parentheses.\n• is an immutable property. Properties without methods can’t be changed. Even though it’s defined as a method, it can be retrieved as an attribute without parentheses.\n• is a class method. It’s not bound to one particular instance of . Class methods are often used as factory methods that can create specific instances of the class.\n• is a static method. It’s not really dependent on the class, except that it’s part of its namespace. You can call static methods on either an instance or the class. You can use as follows: In these examples, you explore the different methods, attributes, and properties of . Next, define a class where you decorate some of its methods using the and decorators from earlier: Using this class, you can see the effect of the decorators: When you create a new instance of , Python calls under the hood, as your use of reveals. The decorator helps you monitor how much time is spent on . The other way to use decorators on classes is to decorate the whole class. This is, for example, done in the module: The meaning of the syntax is similar to the function decorators. In the example above, you could’ve decorated the class by writing . A common use of class decorators is to be a simpler alternative to some use cases of metaclasses. In both cases, you’re changing the definition of a class dynamically. Writing a class decorator is very similar to writing a function decorator. The only difference is that the decorator will receive a class and not a function as an argument. In fact, all the decorators that you saw above will work as class decorators. When you’re using them on a class instead of a function, their effect might not be what you want. In the following example, the decorator is applied to a class: Decorating a class doesn’t decorate its methods. Recall that is just shorthand for . Here, only measures the time that it takes to instantiate the class: The output from is only shown as is created. The call to isn’t timed. Later, you’ll see an example defining a proper class decorator, namely , which ensures that there’s only one instance of a class. You can apply several decorators to a function at once by stacking them on top of each other: Think about this as the decorators being executed in the order they’re listed. In other words, calls , which calls , or : The greeting is printed twice because of . However, the output from is only shown once, since it’s called before the decorator. Observe the difference if you change the order of and : Here, is applied to as well. You can see that both calls to are annotated with debugging information. Sometimes, it’s useful to pass arguments to your decorators. For instance, could be extended to a decorator. The number of times to execute the decorated function could then be given as an argument. If you define , you could do something like this: Think about how you’d implement . So far, the name written after the has referred to a function object that can be called with another function. To be consistent, you then need to return a function object that can act as a decorator. Luckily, you already know how to return functions! In general, you want something like the following: Typically, the decorator creates and returns an inner wrapper function, so writing the example out in full will give you an inner function within an inner function. While this might sound like the programming equivalent of the Inception, you’ll untangle it all in a moment: It looks a little messy, but you’ve only put the same decorator pattern that you’ve seen many times by now inside one additional that handles the arguments to the decorator. First, consider the innermost function: This function takes arbitrary arguments and returns the value of the decorated function, . This wrapper function also contains the loop that calls the decorated function times. This is no different from the earlier wrapper functions that you’ve seen, except that it’s using the parameter that must be supplied from the outside. One step out, you’ll find the decorator function: Again, looks exactly like the decorator functions that you’ve written earlier, except that it’s named differently. That’s because you reserve the base name— —for the outermost function, which is the one the user will call. As you’ve already seen, the outermost function returns a reference to the decorator function: There are a few subtle things happening in the function:\n• Defining as an inner function means that will refer to a function object, . Earlier, you used decorators like without parentheses. Now, you need to add parentheses when setting up the decorator, as in . This is necessary in order to add arguments.\n• The argument is seemingly not used in itself. But by passing , a closure is created where the value of is stored until uses it later. With everything set up, test your code to see if the results are as expected: That’s just the result that you were aiming for. With a little bit of care, you can also define decorators that can be used both with and without arguments. Most likely, you don’t need this, but it is nice to have the flexibility. Like Winnie-the-Pooh says: Both—but don’t bother about the bread, please. (Source) As you saw in the previous section, when a decorator uses arguments, you need to add an extra outer function. The challenge now is for your code to figure out if you’ve called the decorator with or without arguments. Since the function to decorate is only passed in directly if the decorator is called without arguments, the function must be an optional argument. This means that the decorator arguments must all be specified by keyword. You can enforce this with the special asterisk ( ) syntax, which means that all the following parameters are keyword-only: Here, the argument acts as a marker, noting whether the decorator has been called with arguments or not:\n• Line 1: If you’ve called without arguments, then the decorated function will be passed in as . If you’ve called it with arguments, then will be , and some of the keyword arguments may have been changed from their default values. The asterisk in the argument list means that you can’t call the remaining arguments as positional arguments.\n• Line 6: In this case, you called the decorator with arguments. Return a decorator function that takes a function as an argument and returns a wrapper function.\n• Line 8: In this case, you called the decorator without arguments. Apply the decorator to the function immediately. Using this boilerplate on the decorator in the previous section, you can write the following: Compare this with the original . The only changes are the added parameter and the … block at the end. Recipe 9.6 of the excellent Python Cookbook shows an alternative solution using . You can now apply to different functions to test that you can now use it with or without arguments: Recall that the default value of is , so using without any arguments is equivalent to using : Here, Whee! is repeated twice since that’s the default behavior of . As specified by the argument, the greeting is repeated three times. Sometimes, it’s useful to have a decorator that can keep track of state. As an example, you’ll create a decorator that counts the number of times a function is called. Note: In the beginning of this guide, you learned about pure functions returning a value based on given arguments. Stateful decorators are quite the opposite, where the return value will depend on the current state, as well as the given arguments. In the next section, you’ll see how to use classes to keep state. But in simple cases, you can also get away with using function attributes: The state—the number of calls to the function—is stored in the function attribute on the wrapper function. Here’s the effect of using it: You apply to your old friend, . Each time you call the function, you see that the call count increases. You can also manually query the attribute. The typical way to maintain state in Python is by using classes. In this section, you’ll see how to rewrite the example from the previous section to use a class as a decorator. Recall that the decorator syntax is just a quicker way of saying . Therefore, if is a class, it needs to take as an argument in its initializer. Furthermore, the class instance needs to be callable so that it can stand in for the decorated function. Note: Up until now, all the decorators that you’ve seen have been defined as functions. This is how you most often will create decorators. However, you can use any callable expression as a decorator. For a class instance to be callable, you implement the special method: The method is executed each time you try to call an instance of the class: Each time you call , the state changes as the count increases. Therefore, a typical implementation of a decorator class should implement and : The method must store a reference to the function, and it can do any other necessary initialization. The method will be called instead of the decorated function. It does essentially the same thing as the function in your earlier examples. Note that you need to use the function instead of . This decorator works the same as the one in the previous section: Each call to is counted and noted. In the next section, you’ll look at more examples of decorators.\n\nYou’ve come a long way now, having figured out how to create all kinds of decorators. You’ll wrap it up, putting your newfound knowledge to use by creating a few more examples that might be useful in the real world. As noted earlier, your previous implementation of always sleeps for one second. Now you know how to add parameters to decorators, so you can rewrite using an optional argument that controls how long it sleeps: \"\"\"Sleep given amount of seconds before calling the function\"\"\" You’re using the boilerplate introduced in the Creating Decorators With Optional Arguments section to make callable both with and without arguments. The same recursive function as earlier now sleeps two seconds between each count: As before, you must run the example yourself to see the effect of the decorator: There’ll be a two second pause between each number in the countdown. A singleton is a class with only one instance. There are several singletons in Python that you use frequently, including , , and . The fact that is a singleton allows you to compare for using the keyword, like you did when creating decorators with optional arguments: Using returns only for objects that are the exact same instance. The following decorator turns a class into a singleton by storing the first instance of the class as an attribute. Later attempts at creating an instance simply return the stored instance: As you see, this class decorator follows the same template as your function decorators. The only difference is that you’re using instead of as the parameter name to indicate that it’s meant to be a class decorator. Check it out in practice: By comparing object IDs and checking with the keyword, you confirm that is indeed the exact same instance as . Note: Singleton classes aren’t really used as often in Python as in other languages. The effect of a singleton is usually better implemented as a global variable inside a module. Class decorators are less common than function decorators. You should document these well, so that your users know how to apply them. Decorators can provide a nice mechanism for caching and memoization. As an example, look at a recursive definition of the Fibonacci sequence: While this implementation is straightforward, its runtime performance is terrible: To calculate the tenth Fibonacci number, you should only need to calculate the preceding Fibonacci numbers, but this implementation somehow needs a whopping 177 calculations. It gets worse quickly: 21,891 calculations are needed for and almost 2.7 million calculations for the thirtieth number. This is because the code keeps recalculating Fibonacci numbers that are already known. The usual solution is to implement Fibonacci numbers using a loop and a lookup table. However, caching the calculations will also do the trick. First add a decorator to your module: The cache works as a lookup table, as it stores calculations in a dictionary. You can add it to : You still use to monitor the performance of your calculations. With the cache, only does the necessary calculations once: Note that in the call to , no new calculations were needed since the eighth Fibonacci number had already been calculated for . In the standard library, a Least Recently Used (LRU) cache is available as . Additionally, you can use a regular cache with . These decorators have more features than the one you saw above. You should use or instead of writing your own cache decorator. In the next example, you don’t return the result immediately. Instead, you add a call to to see when a result is calculated and not just retrieved from the cache: The parameter specifies how many recent calls are cached. The default value is 128, but you can specify to cache all function calls. Using has the same effect as . However, be aware that this can cause memory problems if you’re caching many large objects. You can use the method to see how the cache performs, and you can tune it if needed. In your example, you used an artificially small to see the effect of elements being removed from the cache: In these examples, you calculate a few Fibonacci numbers. Your cache only holds four calculations at a time. For example, after calculating , it holds the seventh, eight, ninth, and tenth number. Therefore, you’re able to find without doing any recalculations. Then you ask for , but that fifth number has been deleted from the cache. It therefore needs to be calculated from scratch. In most applications, you don’t need to constrain your cache and can use directly. The following example is somewhat similar to the registering plugins example from earlier, in that it doesn’t really change the behavior of the decorated function. Instead, it simply adds as a function attribute: The following example calculates the volume of a cylinder based on its radius and height in centimeters: You’ve added information to that the result should be interpreted as cubic centimeters. You can later access the function attribute when needed: Note that you could’ve achieved something similar using function annotations: However, since annotations are used for type hints, it’s a bit clunky to combine such units as annotations with static type checking. Units become even more powerful and fun when connected with a library that can convert between units. One such library is . With installed ( ), you can convert the volume to cubic inches or gallons, for example: You use to create a quantity that has both a magnitude and a unit. By calling , you convert to other units. For example, the example cylinder is about 141 cubic centimeters, which translates to approximately 8.63 cubic inches and 0.0373 gallons. You could also modify the decorator to return a directly. Such a is made by multiplying a value with the unit. In , units must be looked up in a . You can store the registry as a function attribute on the decorator to avoid cluttering the namespace: \"\"\"Have a function return a Quantity with given unit\"\"\" With the decorator, converting units is practically effortless: When Usain Bolt ran 100 meters in 9.58 seconds at the 2009 world championships, he had an average speed of 10.4 meters per second. This translates to about 37.6 kilometers per hour and 23.4 miles per hour. You’ll now look at one last use case. Take a quick look at the following Flask route handler: Here you ensure that the key is part of the request. Although this validation works, it doesn’t really belong in the function itself. Additionally, there may be other routes that use the same validation. So, to keep it DRY, you can abstract out any unnecessary logic with a decorator. The following decorator will do the job: In the above code, the decorator takes a variable-length list as an argument so that you can pass in as many string arguments as necessary, each representing a key used to validate the JSON data:\n• Line 4: The list of keys that must be present in the JSON is given as arguments to the decorator.\n• Line 9: The wrapper function validates that each expected key is present in the JSON data. The route handler can then focus on its real job—updating grades—as it can safely assume that the JSON data are valid: You apply , which simplifies the logic inside ."
    },
    {
        "link": "https://stackoverflow.com/questions/5929107/decorators-with-parameters",
        "document": "but unfortunately, this statement does not work. Perhaps maybe there is better way to solve this problem.\n\nI have a problem with the transfer of the variable insurance_mode by the decorator. I would do it by the following decorator statement:\n\nEdit : for an in-depth understanding of the mental model of decorators, take a look at this awesome Pycon Talk. well worth the 30 minutes. One way of thinking about decorators with arguments is So if the decorator had arguments, is a function which accepts a custom argument and which returns the actual decorator (that will be applied to the decorated function). I use a simple trick with partials to make my decorators easy from functools import partial def _pseudo_decor(fun, argument): def ret_fun(*args, **kwargs): #do stuff here, for eg. print (\"decorator arg is %s\" % str(argument)) return fun(*args, **kwargs) return ret_fun real_decorator = partial(_pseudo_decor, argument=arg) @real_decorator def foo(*args, **kwargs): pass One effect of decorating a function is that the name is overridden upon decorator declaration. is \"overridden\" by whatever is returned by . In this case, a new function object. All of 's metadata is overridden, notably docstring and function name. functools.wraps gives us a convenient method to \"lift\" the docstring and name to the returned function. from functools import partial, wraps def _pseudo_decor(fun, argument): # magic sauce to lift the name and doc of the function @wraps(fun) def ret_fun(*args, **kwargs): # pre function execution stuff here, for eg. print(\"decorator argument is %s\" % str(argument)) returned_value = fun(*args, **kwargs) # post execution stuff here, for eg. print(\"returned value is %s\" % returned_value) return returned_value return ret_fun real_decorator1 = partial(_pseudo_decor, argument=\"some_arg\") real_decorator2 = partial(_pseudo_decor, argument=\"some_other_arg\") @real_decorator1 def bar(*args, **kwargs): pass >>> print(bar) <function __main__.bar(*args, **kwargs)> >>> bar(1,2,3, k=\"v\", x=\"z\") decorator argument is some_arg returned value is None\n\nThis is a template for a function decorator that does not require if no parameters are to be given and supports both positional and keyword parameters (but requires cheching on to find out if the first parameter is the function to be decorated or not): import functools def decorator(x_or_func=None, *decorator_args, **decorator_kws): def _decorator(func): @functools.wraps(func) def wrapper(*args, **kws): if 'x_or_func' not in locals() \\ or callable(x_or_func) \\ or x_or_func is None: x = ... # <-- default `x` value else: x = x_or_func return func(*args, **kws) return wrapper return _decorator(x_or_func) if callable(x_or_func) else _decorator an example of this is given below: def multiplying(factor_or_func=None): def _decorator(func): @functools.wraps(func) def wrapper(*args, **kwargs): if 'factor_or_func' not in locals() \\ or callable(factor_or_func) \\ or factor_or_func is None: factor = 1 else: factor = factor_or_func return factor * func(*args, **kwargs) return wrapper return _decorator(factor_or_func) if callable(factor_or_func) else _decorator @multiplying def summing(x): return sum(x) print(summing(range(10))) # 45 @multiplying() def summing(x): return sum(x) print(summing(range(10))) # 45 @multiplying(10) def summing(x): return sum(x) print(summing(range(10))) # 450 Alternatively, if one does not need positional arguments, one can relax the need for checking on the first parameter within the (thus removing the need to use ): import functools def decorator(func_=None, **decorator_kws): def _decorator(func): @functools.wraps(func) def wrapper(*args, **kws): return func(*args, **kws) return wrapper if callable(func_): return _decorator(func_) elif func_ is None: return _decorator else: raise RuntimeWarning(\"Positional arguments are not supported.\") an example of this is given below: import functools def multiplying(func_=None, factor=1): def _decorator(func): @functools.wraps(func) def wrapper(*args, **kwargs): return factor * func(*args, **kwargs) return wrapper if callable(func_): return _decorator(func_) elif func_ is None: return _decorator else: raise RuntimeWarning(\"Positional arguments are not supported.\") @multiplying def summing(x): return sum(x) print(summing(range(10))) # 45 @multiplying() def summing(x): return sum(x) print(summing(range(10))) # 45 @multiplying(factor=10) def summing(x): return sum(x) print(summing(range(10))) # 450 @multiplying(10) def summing(x): return sum(x) print(summing(range(10))) # RuntimeWarning Traceback (most recent call last) # .... # RuntimeWarning: Positional arguments are not supported.\n\nIt is well known that the following two pieces of code are nearly equivalent: A common mistake is to think that simply hides the leftmost argument. It would be much easier to write decorators if the above is how worked. Unfortunately, that’s not the way things are done. Consider a decorator which haults program execution for a few seconds. If you don't pass in a Wait-time then the default value is 1 seconds. Use-cases are shown below. When has an argument, such as , then the call is executed before anything else happens. That is, the following two pieces of code are equivalent if `Wait` has no arguments: `Wait` is the decorator. else: # `Wait` receives arguments `Wait` is not the decorator itself. Instead, `Wait` ***returns*** the decorator One solution is shown below: Let us begin by creating the following class, : class DelayedDecorator: def __init__(i, cls, *args, **kwargs): print(\"Delayed Decorator __init__\", cls, args, kwargs) i._cls = cls i._args = args i._kwargs = kwargs def __call__(i, func): print(\"Delayed Decorator __call__\", func) if not (callable(func)): import io with io.StringIO() as ss: print( \"If only one input, input must be callable\", \"Instead, received:\", repr(func), sep=\"\n\n\", file=ss ) msg = ss.getvalue() raise TypeError(msg) return i._cls(func, *i._args, **i._kwargs) Now we can write things like:\n• does not not accept multiple arguments.\n• None only accepts the function to be wrapped. import inspect class PolyArgDecoratorMeta(type): def call(Wait, *args, **kwargs): try: arg_count = len(args) if (arg_count == 1): if callable(args[0]): SuperClass = inspect.getmro(PolyArgDecoratorMeta)[1] r = SuperClass.call(Wait, args[0]) else: r = DelayedDecorator(Wait, *args, **kwargs) else: r = DelayedDecorator(Wait, *args, **kwargs) finally: pass return r The following two pieces of code are equivalent: We can print to the console very slowly, as follows: It may look like a lot of code, but you don't have to write the classes and every-time. The only code you have to personally write something like as follows, which is fairly short:\n\nIt worth checking Making decorators with optional arguments and its duplicates for more comprehensive answers. A generic decorator skeleton code with comments and tests which tries to summarize all possible use cases: from functools import wraps def my_decorator(*args_or_func, **decorator_kwargs): \"\"\"Originally from: https://stackoverflow.com/questions/5929107/decorators-with-parameters/65512042#65512042 with hints from: https://stackoverflow.com/questions/3888158/making-decorators-with-optional-arguments/24617244#24617244\"\"\" def _decorator(func): @wraps(func) # See: https://docs.python.org/3/library/functools.html#functools.wraps def wrapper(*args, **kwargs): # Do things before executing the function print(\"Available inside the wrapper:\", decorator_args, decorator_kwargs) # Execute the original function with its args result = func(*args, **kwargs) # Do more things after executing the function return result return wrapper # TODO If you need only @my_decorator() or @my_decorator(...) use the else branch only # TODO To mitigate TypeError on single callable positional argument allow only keyword arguments: # def my_decorator(func=None, *, decorator_kwarg1='value1', decorator_kwarg2='value2'): # No **kwargs possible! # and below: if func is not None: _decorator(func) else: _decorator # To allow @my_decorator (i.e. without parentheses) WARNING: Use keyword argument for single callable parameter! if len(args_or_func) == 1 and len(decorator_kwargs) == 0 and callable(args_or_func[0]): # Here you can set default values for positional arguments decorator_args = () return _decorator(args_or_func[0]) else: decorator_args = args_or_func # This \"global\" variable is used inside _decorator() which is defined above return _decorator # Hint: The function's implementation is evaluated when the function executed @my_decorator def func_1(arg): print(arg) func_1(\"test1\") # Available inside the wrapper: () {} # test1 @my_decorator() def func_2(arg): print(arg) func_2(\"test2\") # Available inside the wrapper: () {} # test2 # Single callable positional argument. BAD INVOCATION! -> TypeError @my_decorator(lambda x: 42) def func_3(arg): print(arg) try: func_3(\"Single callable positional argument. BAD INVOCATION! -> TypeError\") except TypeError as e: print(\"test3\") print(f\"Catched TypeError: TypeError: {e}\") # test3 # Catched TypeError: TypeError: 'int' object is not callable @my_decorator(lambda x: 42, \"any arg\") def func_4(arg): print(arg) func_4(\"test4\") # Available inside the wrapper: (<function <lambda> at 0x7f96d94ed870>, 'any arg') {} # test4 @my_decorator(lambda x: 42, kw=\"any arg\") def func_5(arg): print(arg) func_5(\"test5\") # Available inside the wrapper: (<function <lambda> at 0x7f2dbae3d870>,) {'kw': 'any arg'} # test5 @my_decorator(\"arg_1\", 2, [3, 4, 5], kwarg_1=1, kwarg_2=\"2\") def func_6(arg): print(arg) func_6(\"test6\") # Available inside the wrapper: ('arg_1', 2, [3, 4, 5]) {'kwarg_1': 1, 'kwarg_2': '2'} # test6 @my_decorator @my_decorator() @my_decorator(\"stacked\") @my_decorator(\"arg_1\", 2, [3, 4, 5], kwarg_1=1, kwarg_2=\"2\") def func_7(arg): print(arg) func_7(\"test7\") # Available inside the wrapper: () {} # Available inside the wrapper: () {} # Available inside the wrapper: ('stacked',) {} # Available inside the wrapper: ('arg_1', 2, [3, 4, 5]) {'kwarg_1': 1, 'kwarg_2': '2'} # test7\n\nDecoration with parameters in an anonymous setting. Among of the many possibilities two variations of a \"nested\" syntactic sugar decoration are presented. They differ from each other by the order of execution wrt to the target function and their effects are, in general, independent (non interacting). The decorators allow an \"injection\" a of custom function either before or after the execution of the target function. The calls of both functions take place in a . As default, the return value is the result of the target function. The syntactic sugar decoration required version >= 3.9, see PEP 614 Relaxing Grammar Restrictions On Decorators. Used to keep the doc-string of the target function.\n• None composition decorators, such as pull-back and push-forward (maybe in a more Computer Science terminology: co- and resp. contra-variant decorator), could more useful but need ad-hoc care, for example composition rules, check which parameters go where, etc\n• None syntactic sugar acts as a kind of of the target function: once decorated there is no way back (without extra imports) but it is not mandatory, a decorator can be used also in its extended forms, i.e.\n• None the results of a workbench with which compare the classical and decoration shows that are almost equivalent:\n• None naturally an non-anonymous counterpart is possible and provides more flexibility"
    },
    {
        "link": "https://geeksforgeeks.org/decorators-in-python",
        "document": "In Python, decorators are a powerful and flexible way to modify or extend the behavior of functions or methods, without changing their actual code. A decorator is essentially a function that takes another function as an argument and returns a new function with enhanced functionality.\n\nDecorators are often used in scenarios such as logging, authentication and memorization, allowing us to add additional functionality to existing functions or methods in a clean, reusable way.\n• None decorator takes the greet function as an argument.\n• None It returns a new function (wrapper) that first prints a message, calls greet() and then prints another message.\n• None The @decorator syntax is a shorthand for greet = decorator(greet).\n• decorator_name: This is the name of the decorator function.\n• func: This parameter represents the function being decorated. When you use a decorator, the decorated function is passed to this parameter.\n• wrapper: This is a nested function inside the decorator. It wraps the original function, adding additional functionality.\n• *args: This collects any positional arguments passed to the decorated function into a tuple.\n• **kwargs: This collects any keyword arguments passed to the decorated function into a dictionary.\n• None The wrapper function allows the decorator to handle functions with any number and types of arguments.\n• None This syntax applies the decorator to the function_to_decorate function. It is equivalent to writing function_to_decorate = decorator_name(function_to_decorate).\n\nIn Python, higher-order functions are functions that take one or more functions as arguments, return a function as a result or do both. Essentially, a higher-order function is a function that operates on other functions. This is a powerful concept in functional programming and is a key component in understanding how decorators work.\n• Taking functions as arguments : A higher-order function can accept other functions as parameters.\n• Returning functions : A higher-order function can return a new function that can be called later.\n\nIn this example, first function fun is a higher-order function because it takes another function f as an argument and applies it to the value x.\n\nDecorators in Python are a type of higher-order function because they take a function as input, modify it, and return a new function that extends or changes its behavior. Understanding higher-order functions is essential for working with decorators since decorators are essentially functions that return other functions.\n\nIn Python, functions are first-class objects, meaning that they can be treated like any other object, such as integers, strings, or lists. This gives functions a unique level of flexibility and allows them to be passed around and manipulated in ways that are not possible in many other programming languages.\n\nWhat Does It Mean for Functions to Be First-Class Objects?\n• Can be assigned to variables : Functions can be assigned to variables and used just like any other value.\n• Can be passed as arguments : Functions can be passed as arguments to other functions.\n• Can be returned from other functions : Functions can return other functions, which is a key concept in decorators.\n• Can be stored in data structures : Functions can be stored in lists, dictionaries, or other data structures.\n• None The greet function is assigned to the say_hi variable, which is used to print a greeting for “Alice”.\n• None Another function, apply, takes a function and a value as arguments, applies the function to the value, and returns the result.\n• None apply is demonstrated by passing say_hi and “Bob”, printing a greeting for “Bob”.\n• None The make_mult function creates a multiplier function based on a given factor.\n• None Decorators receive the function to be decorated as an argument. This allows the decorator to modify or enhance the function’s behavior.\n• None Decorators return a new function that wraps the original function. This new function adds additional behavior before or after the original function is called.\n• None When a function is decorated, it is assigned to the variable name of the original function. This means the original function is replaced by the decorated (wrapped) function.\n\nThe most common type of decorator, which takes a function as input and returns a new function. The example above demonstrates this type.\n• simple_decorator(func): This decorator takes the function greet as an argument (func) and returns a new function (wrapper) that adds some functionality before and after calling the original function.\n• @simple_decorator: This is the decorator syntax. It applies the simple_decorator to the greet function.\n• Calling greet(): When greet() is called, it doesn’t just execute the original function but first runs the added behavior from the wrapper function.\n\nUsed to decorate methods within a class. They often handle special cases, such as the argument for instance methods.\n• method_decorator(func): The decorator takes the method (say_hello) as an argument (func). It returns a wrapper function that adds behavior before and after calling the original method.\n• wrapper(self, *args, **kwargs): The wrapper must accept self because it is a method of an instance. self is the instance of the class and *args and **kwargs allow for other arguments to be passed if needed.\n• @method_decorator: This applies the method_decorator to the say_hello method of MyClass.\n• Calling obj.say_hello(): The say_hello method is now wrapped with additional behavior.\n\nClass decorators are used to modify or enhance the behavior of a class. Like function decorators, class decorators are applied to the class definition. They work by taking the class as an argument and returning a modified version of the class.\n• add_class_name(cls): This decorator adds a new attribute, class_name, to the class cls. The value of class_name is set to the name of the class (cls.__name__).\n• @add_class_name: This applies the add_class_name decorator to the Person class.\n• Result: When the Person class is defined, the decorator automatically adds the class_name attribute to it.\n• print(Person.class_name): Accessing the class_name attribute that was added by the decorator prints the name of the class, Person.\n\nPython provides several built-in decorators that are commonly used in class definitions. These decorators modify the behavior of methods and attributes in a class, making it easier to manage and use them effectively. The most frequently used built-in decorators are , , and .\n\nThe decorator is used to define a method that doesn’t operate on an instance of the class (i.e., it doesn’t use ). Static methods are called on the class itself, not on an instance of the class.\n• None add is a static method defined with the @staticmethod decorator.\n• None It can be called directly on the class MathOperations without creating an instance.\n\nThe @classmethod decorator is used to define a method that operates on the class itself (i.e., it uses cls). Class methods can access and modify class state that applies across all instances of the class.\n• None set_raise_amount is a class method defined with the @classmethod decorator.\n• None It can modify the class variable raise_amount for the class Employee and all its instances.\n\nThe @property decorator is used to define a method as a property, which allows you to access it like an attribute. This is useful for encapsulating the implementation of a method while still providing a simple interface.\n• None radius and area are properties defined with the @property decorator.\n• None The radius property also has a setter method to allow modification with validation.\n• None These properties provide a way to access and modify private attributes while maintaining encapsulation.\n\nWhen should you use decorators in Python?\n\nWhat is function vs decorators in Python?\n\nWhat is __init__ in Python?\n\nWhat is the difference between decorator and annotation in Python?\n\nWhat is the difference between wrapper and decorator in Python?"
    },
    {
        "link": "https://freecodecamp.org/news/python-decorators-explained-with-examples",
        "document": "Python decorators allow you to change the behavior of a function without modifying the function itself.\n\nIn this article I will show you how to create and use decorators. You will see how easy it is to use this advanced Python feature.\n\nIn this article I will discuss the following topics:\n• When to use a decorator in Python\n• Building blocks you use to create a decorator\n\nWhen to Use a Decorator in Python\n\nYou'll use a decorator when you need to change the behavior of a function without modifying the function itself. A few good examples are when you want to add logging, test performance, perform caching, verify permissions, and so on.\n\nYou can also use one when you need to run the same code on multiple functions. This avoids you writing duplicating code.\n\nHere are the building blocks used to create Python decorators\n\nTo get a better understanding of how decorators work, you should understand a few concepts first.\n• A function is an object. Because of that, a function can be assigned to a variable. The function can be accessed from that variable.\n• A function can be nested within another function.\n\nNote that the is not available outside the . If I try to execute the outside of the I receive a NameError exception.\n• Since a function can be nested inside another function it can also be returned.\n• A function can be passed to another function as an argument.\n\nTo create a decorator function in Python, I create an outer function that takes a function as an argument. There is also an inner function that wraps around the decorated function.\n\nHere is the syntax for a basic Python decorator:\n\nTo use a decorator ,you attach it to a function like you see in the code below. We use a decorator by placing the name of the decorator directly above the function we want to use it on. You prefix the decorator function with an symbol.\n\nHere is a simple example. This decorator logs the date and time a function is executed:\n\nHow to Add Arguments to Decorators in Python\n\nDecorators can have arguments passed to them. To add arguments to decorators I add and to the inner functions.\n• will take an unlimited number of arguments of any type, such as , , or .\n• will take an unlimited number of keyword arguments, such as , , or .\n\nHere is a decorator with arguments:\n\nDecorators hide the function they are decorating. If I check the or method we get an unexpected result.\n\nTo fix this issue I will use . Functools wraps will update the decorator with the decorated functions attributes.\n\nNow I receive the output I am expecting.\n\nExample of a Python Decorator in Action\n\nI have created a decorator that will measure memory and speed of a function.\n\nWe'll use the decorator to test the performance list generation using four methods: range, list comprehension, append, and concatenation.\n\nYou can use decorators with classes as well. Let's see how you use decorators with a Python class.\n\nIn this example, notice there is no character involved. With the method the decorator is executed when an instance of the class is created.\n\nThis class keeps track of the number of times a function to query to an API has been run. Once it reaches the limit the decorator stops the function from executing.\n\nThis class will keep track of the state of the class.\n\nIn this article I talked about how to pass a function to a variable, nested functions, returning functions, and passing a function to another function as an argument.\n\nI also showed you how to create and use Python decorators along with a few real-world examples. Now I hope that you will able to add decorators to your projects."
    },
    {
        "link": "https://datacamp.com/tutorial/decorators-python",
        "document": "Learn the art of writing your own functions in Python, as well as key concepts like scoping and error handling."
    }
]