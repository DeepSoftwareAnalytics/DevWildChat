[
    {
        "link": "https://github.com/Elfansoer/dota-2-lua-abilities/blob/master/scripts/vscripts/lua_abilities/dark_willow_bramble_maze_lua/dark_willow_bramble_maze_lua.lua",
        "document": "To see all available qualifiers, see our documentation .\n\nSaved searches Use saved searches to filter your results more quickly\n\nWe read every piece of feedback, and take your input very seriously.\n\nYou signed in with another tab or window. Reload to refresh your session.\n\nYou signed out in another tab or window. Reload to refresh your session.\n\nYou switched accounts on another tab or window. Reload to refresh your session."
    },
    {
        "link": "https://moddota.com/scripting-introduction",
        "document": "Part 2 of Getting Started With Dota 2 Modding, this tutorial is meant to explain the basics of programming Dota 2 custom mods.\n\nSo now you have your freshly created gamemode running and have played around the map editor a bit, it’s time to move into the programming realm of Dota 2 custom maps.\n\nGo into your < addonName > /scripts/ folder. The 2 main script folders are npc and vscripts. The first holds the following .txt files:\n• npc_abilities_custom.txt - Contains all the custom abilities of the gamemode.\n• npc_heroes_custom.txt - Heroes with its abilities and stats\n• npc_items_custom.txt - Items are abilities that go into a units inventory\n• npc_units_custom.txt - All the data for non-hero units like buildings or creatures.\n• herolist.txt - List of the heroes available for picking.\n\nThese files are defined using KeyValues (KV) and are the core of the the DataDriven system. While they fulfill the definition of a programming language, it’s more like a big table containing all the possible data in a static document. it uses a relatively simple syntax whose only special characters are curly braces and quotes, with alternating sets of \"Key\" and \"Value\" or \"Key\" {table} pairs, where table is another set of KeyValues.\n\nKV will define the data of abilities/items/units, while more elaborate behavior is handled with Lua or TypeScript.\n\nEach .txt file contains its particular KVs, and when the game starts, each client (and server) will interpret them. Changes to these files won’t take effect until the game is started again, so be very aware of the syntax, as any extra/missing or will usually make all the keyvalues that come after this error unusable. Consistent indentation is a good practice to learn early! KV is case-sensitive, so also pay attention to write everything like the game expects you to write. If your KV is not working, try putting it into the KV checker to look for errors.\n\nNow it’s a good time to get your environment ready to write Dota Scripts. For this, the best way is getting Visual Studio Code. Use VSCode to open your addon root directory using File > Open Folder...\n\nOnce your environment is set up you can try to run your addon. Open the workshop tools (if you can't find them, they are in , bookmark this) and select your addon.\n\nOnce the asset browser has launched, open the Console from the buttons at the top. To launch your addon simply type the following command into the bottom of the console:\n\nIf you have not done so, you will first need to build your map using Hammer before you can launch your game on it. You can also run your game on the default Dota 2 map using:\n\nAfter this command, you will enter a game with your addon rules. If you want to restart the game to reload the scripts, simply repeat the launch command (by pressing the up arrow in Console), or by typing in console.\n\nGoing back to the game/scripts folder, there’s the vscripts folder. Here is the place where all the Lua/TypeScript scripts are placed.\n\nIn every single gamemode, a file named addon_game_mode.lua must be present. While it is possible to add the game logic to this file (and in fact, valve did so in their holdout example), it is recommended that you reserve this file only for these 2 functions:\n• , when the game starts and players pick their heroes, the engine will try to load the associated models/particles/sounds to those heroes. If we’re dynamically using a resource in Lua before preloading it won’t be displayed properly.\n• , creates the base game mode entity and calls the initialize function.\n\nUsing our barebones, you don’t need to touch this file apart from very specific situations, and all the core game logic will be coded in gamemode.lua (for older versions it's barebones.lua), which has been already required. We’ll call this your main lua file from now on.\n\nAfter addon_game_mode & are finished, the first function to be executed in the barebones.lua file is .\n\nIn here the game starts by initializing all sorts of rules and functions, which are registered over the GameRules and GameMode entities. For this, many variables are defined in settings.lua file to help organizing options like gold settings, kills, custom levels, etc.\n\nThis is the syntax of a function applied over GameRules, with one bool parameter:\n\nJust as KV, Lua is Case Sensitive. Also the placement of the functions within your main Lua file doesn’t generally matter. All the script lines within a function call will be run one after another, potentially on the same frame; one frame in Dota is 1/30 of a second.\n\nNote the use of colon before the function. In Lua, this is how we access the various Game API functions. We say that is an HScript or a handle. Handles are basically huge tables, with all the pertinent info of the entity. Over the Scripting API page you’ll see many different types of functions which can use different handles\n\nGlobal functions don’t need any handle prefix. Heroes, Creatures, Abilities and Items all have their different handle classes and attempting to call a function over an incompatible class will cause a VScript error, as pink text in console and red text on the gamescreen.\n\nYou can access the game console by pressing the ` key.\n\nThis will provide tons of useful information for debugging. The different colors represent the various “channels” of information. By default all the channels are in the same Log: Default tab. It’s very recommended that you make your own tabs to split the log viewer.\n\nFor Lua Scripting, we want to have a VScript Tab. Messages about the DataDriven system are in the General channel in yellow along with some other info, make a separate viewer for this too.\n\nThe console will notify whenever a Lua scripting error happens, either when the game is being loaded (a syntax-compilation error) or at runtime. In this error, I wrote GameRules.SetHeroRespawnEnabled with instead of\n\nYou can then trace the error to that line and attempt to solve it, writing script_reload in the console to reload the script and check if it was actually fixed.\n\nA DataDriven syntax error will usually look like this:\n\nThe second segment of the InitGameMode function is the Listeners:\n\nThe structure of this ListenToGameEvent is read as:\n\nWhenever the dota_player_gained_level event is triggered, execute the scripts inside the OnPlayerLevelUp function.\n\nand (or in updated version) are just the names of the function and main class name we came up with, normally you don’t need to worry about them, all Listeners and functions are already available in barebones, ready to be expanded. is a function to ensure that the command also reloads the listeners. restarts lua scripts at runtime, unlike DataDriven files which require the game to be fully restarted. As you can see on the barebones example there are tons of possible events, and not all of them are listed there, those are just the most used ones.\n\nThe 3rd and last part of the in simplified Barebones are self defined variables to track info. These use the entity, which is a local reference to the GameMode entity, seen through all the functions inside the main lua file. Adding information to an entity like is loosely called “indexing” and is basically adding another entry to the big table of that entity. This is very useful because this information is stored under the entity handle visible everywhere, and won’t change until we reassign it or destroy it.\n\nEnough theory, let’s see how this all comes together. Let's take a look at OnNPCSpawned function, which is the listener for and triggers every time a unit or hero entity is added to the map.\n\nLet’s analyze the contents of the default function:\n\nFirst line will print the string in the VConsole. The print function is native to Lua, and accepts multiple parameters separated by commas.\n\nis a Global Valve-made function which will display the information of the table passed. For keys in this case, it will be the .entindex and .splitscreenplayer. The entity index is a very important number to reference the entity. Ignore splitscreenplayer, it’s just legacy source stuff and never used in Dota 2.\n\nThe next line defines a local variable. In Lua local variables have their scope limited to the block where they are declared. It is good programming style to use local variables whenever possible. Local variables help you avoid cluttering the global environment with unnecessary names. Moreover, access to local variables is faster than to global ones.\n\nThis is basically reading the information that is provided by the event, and storing it into a local variable within that function call. In this example all the Listener and their functions have already been processed, but for reference you can always check the Built-In_Engine_Events wiki page to know exactly what parameters are carried by each event.\n\nThe npc local variable is an HScript, of handle type. All changes done into the npc variable will reflect on spawned unit.\n\nThe next line is a conditional, first it checks if the npc is a real hero (this excludes illusions) and it also checks if the .bFirstSpawned index (a self-defined variable) has not been assigned yet. If both conditions are true, changes the boolean value to true and calls the OnHeroInGame function.\n\nTo finish this basic Dota Lua tutorial, let’s modify the OnNPCSpawned function so that if a unit named npc_dota_neutral_kobold is spawned, wait 1 seconds and then kill itself. Added to the first if statement there’s this else-if condition:\n\nHere we make use of the Timers library for a simple 1.0 second delay, there are many different timer functions included and explained in timers.lua. The bool on ForceKill is to enable the death animation.\n\nTables are the most important structure we will have to use. As mentioned before, all the info on entities can be seen as a table (even though it's technically a pointer to a C++ object), and you Get and Set the values through the various Game API functions.\n\nThere are some functions in the API that return a table of entity handles.\n\nLet say you want to find all the units near the spawned kobold unit and kill them. The function can be used for this purpose, and takes a lot of parameters with different types which is worth explaining:\n\nThe parameters Have to be in this order. This function is a global, so no needed, but we need to keep the table under a variable, like this:\n\nFor the teamNumber, finding out which team an entity is in can be done with on the npc handle. As for the other Filter parameters, instead of real integers, we use a bunch of Constants that represent different number values. The complete list of Constants is found on this wiki page.\n\nA Vector is represented as Vector(x,y,z) coordinates. The function to get the position of particular unit is called and takes a npc handle.\n\nAs for the cache parameters, just leave it nil and false, they aren't of much use generally.\n\nThe complete function call to get the heroes in 500 radius from the spawned kobold would be:\n\nThe use of extra break lines is just to make it more readable. Now we want to iterate over the entities of this table, which is done like this:\n\nThe and are the chosen names to refer to the position and value inside the units table, which will be read in pairs. Using as the name of the key is a good convention when you want to make it clear that the first parameter won't be used. The 2nd parameter, unit, is used to iterate handles of the units found.\n\nThere is one more thing to consider: the \"wait one frame\" issue. Because all units are actually spawned at the (0,0,0) coordinates and then moved to the desired position, many times you'll need to create a 0 second timer (executes next frame) for some scripts to work, and this is one of those cases.\n\nSo, is looking like this:\n\nThere are plenty of examples spread all across GitHub and with the contents of this guide you should now be able to understand the scripting flow of game logic and scripted abilities. The best GitHub repo to look for Dota 2 spells is Elfansoer's dota 2 abilities library.\n\nIf you want to check the scripts of a certain game on the Custom Games Workshop which hasn't made their source public on GitHub (because they are fools), just follow these steps:\n• Subscribe to the game. Download Valve Resource Viewer if you haven't done so yet.\n• Go to your Steam folder -> SteamApps -> workshop -> content -> 570 (this is the dota folder)\n• Open the .vpk file with GCFScape or VRF and extract its contents anywhere you want. Now you can access its scripts and compiled models/particles/sounds.\n\nWhenever you have a doubt about how to use a particular GameAPI function, its possible to find examples all over GitHub by just writing the name of it, additionally filtering by lua like this:\n\nJust make sure it's actually Dota Lua and not another game API, as some of the functions might share names with other engines.\n\nThat's all for the Scripting basics. I expect you to have more questions than when you started reading, feel free to drop all your doubts at the community's Discord channel, you'll find help there 24/7."
    },
    {
        "link": "https://github.com/Elfansoer/dota-2-lua-abilities/blob/master/scripts/vscripts/lua_abilities/pangolier_swashbuckle_lua/pangolier_swashbuckle_lua.lua",
        "document": "To see all available qualifiers, see our documentation .\n\nSaved searches Use saved searches to filter your results more quickly\n\nWe read every piece of feedback, and take your input very seriously.\n\nYou signed in with another tab or window. Reload to refresh your session.\n\nYou signed out in another tab or window. Reload to refresh your session.\n\nYou switched accounts on another tab or window. Reload to refresh your session."
    },
    {
        "link": "https://developer.valvesoftware.com/wiki/Dota_2_Workshop_Tools/Scripting/API",
        "document": "This page outdated, use moddota.com/api instead\n\nWhile Lua is dynamically typed, the DOTA 2 engine is written primarily in C++, which is statically typed. Thus, you'll need to be conscious of your data types when calling the API. (If you try to pass the wrong type to an API function, you'll get an error message in Vconsole telling you what you passed and what it was expecting.)\n\nGlobal functions. These can be called without any class.\n\nReturns the number of degrees difference between two yaw angles AppendToLogFile is deprecated. Print to the console for logging instead. (vector,float) constructs a quaternion representing a rotation by angle around the specified vector axis Compute the closest point on the OBB of an entity. Compute the distance between two entity OBB. A negative return value indicates an input error. A return value of zero indicates that the OBBs are overlapping. Create all I/O events for a particular entity (hInflictor, hAttacker, flDamage) - Allocate a damageinfo object, used as an argument to TakeDamage(). Call DestroyDamageInfo( hInfo ) to free the object. Creates a DOTA hero by its dota_npc_units.txt name and sets it as the given player's controlled hero Create illusions of the passed hero that belong to passed unit using passed modifier data. ( hOwner, hHeroToCopy, hModiiferKeys, nNumIllusions, nPadding, bScramblePosition, bFindClearSpace ) Create a physical item at a given location, can start in air (but doesn't clear a space) Create a modifier not associated with an NPC. ( hCaster, hAbility, modifierName, paramTable, vOrigin, nTeamNumber, bPhantomBlocker ) Create a scene entity to play the specified scene. Create a temporary tree, specifying the tree model name. (vLocation, flDuration, szModelName). CreateTriggerRadiusApproximate( vecOrigin, flRadius ) : Creates and returns an AABB trigger thats bigger than the radius provided Creates a DOTA unit by its dota_npc_units.txt name Creates a DOTA unit by its dota_npc_units.txt name Creates a DOTA unit by its dota_npc_units.txt name from a table of entity key values and a position to spawn at. Try to clear all the debug overlay info Free a damageinfo object that was created with CreateDamageInfo(). #ScriptAssert:Asserts the passed in value. Prints out a message and brings up the assert dialog. #UniqueString:Generate a string guaranteed to be unique across the life of the script VM, with an optional root string. Useful for adding data to tables when not sure what keys are already in use in that table. Emit an announcer sound for all players. Emit an announcer sound for a team at a specific location. Play named sound only on the client for the passed in player Emit a sound on a location from a unit, only for players allied with that unit (vLocation, soundName, hCaster Turn an entity index integer to an HScript representing that entity's script instance. Smooth curve decreasing slower as it approaches zero Finds a clear random position around a given target unit, using the target unit's padded collision radius. Place a unit somewhere not already occupied. Find units that intersect the given line with the given flags. Finds the units in a given radius with the given flags. Fire Entity's Action Input with passed String - you own the memory Fire Entity's Action Input with passed Vector - you own the memory Fire a game event without broadcasting to the client. Get the time spent on the server in the last frame Get the enity index for a tree id specified as the entindex_target of a DOTA_UNIT_ORDER_CAST_TARGET_TREE. Returns the supplied position moved to the ground. Second parameter is an NPC for measuring movement collision hull offset. Get the cost of an item by name. Get the local player on a listen server. Get the name of the map. Get the longest delay for all events attached to an output Get Angular Velocity for VPHYS or normal object. Returns a vector of the axis of rotation, multiplied by the degrees of rotation per second. Get Velocity for VPHYS or normal object Given and entity index of a tree, get the tree id for use for use with with unit orders. InitLogFile is deprecated. Print to the console for logging instead. Returns true if this is lua running from the client.dll. Returns true if this server is a dedicated server. Returns true if this is lua running within tools mode. Ask fog of war if a location is visible to a certain team (nTeamNumber, vLocation). Returns true if the entity is valid and marked for deletion. Returns true if this is lua running from the server.dll. Checks to see if the given hScript is a valid entity (vector,vector,float) lerp between two vectors by a float factor returning new vector Set the limit on the pathfinding search space. Link a lua-defined modifier with the associated class ( className, fileName, LuaModifierType). Register as a listener for a game event from script. Creates a table from the specified keyvalues text file Creates a table from the specified keyvalues string Checks to see if the given hScript is a valid entity Get a script instance of a player by index. Precache an entity from KeyValues in table Asynchronously precaches a DOTA item by its dota_npc_items.txt name, provides a callback when it's finished. Precaches a DOTA item by its dota_npc_items.txt name Asynchronously precaches a DOTA unit by its dota_npc_units.txt name, provides a callback when it's finished. Precaches a DOTA unit by its dota_npc_units.txt name Get a random 2D vector of the given length. Remove the C proxy for a script-based spawn group filter Check and fix units that have been assigned a position inside collision radius of other NPCs. (quaternion,vector,float) rotates a quaternion by the specified angle around the specified vector axis Find the delta between two QAngles. Have Entity say string, and teamOnly or not Start a screenshake with the following parameters. vecCenter, flAmplitude, flFrequency, flDuration, flRadius, eCommand( SHAKE_START = 0, SHAKE_STOP = 1 ), bAirShake ( DOTAPlayer sendToPlayer, int iMessageType, Entity targetEntity, int iValue, DOTAPlayer sourcePlayer ) - sendToPlayer and sourcePlayer can be nil - iMessageType is one of OVERHEAD_ALERT_* Send a string to the console as a client command Send a string to the console as a server command Sets an opvar value for all players Sets an opvar value for a single player Set Angular Velocity for VPHYS or normal object, from a vector of the axis of rotation, multiplied by the degrees of rotation per second. Hierarchically spawn an entity group from a set of spawn tables. Asynchronously spawn an entity group from a list of spawn tables. A callback will be triggered when the spawning is complete Synchronously spawn an entity group from a list of spawn tables. (quaternion,quaternion,float) very basic interpolation of v0 to v1 over t on [0,1] (vector,vector,float) very basic interpolation of v0 to v1 over t on [0,1] Stop listening to all game events within a specific context. Returns the number of degrees difference between two yaw angles Sends colored text to all clients. (Valid context keys: player_id, value, team_id) Sends colored text to one client. (Valid context keys: player_id, value, team_id) Clear all message text on one client. Clear all message text from all clients. Get Qangles (with no roll) for a Vector. Gets the value of the given cvar, as a float. Sets the value of the given cvar, as a float. Commit the result of QueryBestResponse back to the given entity to play. Call with params (entity, airesponse) Retrieve a table of all available expresser targets, in the form { name : handle, name: handle }. Params: (entity, query) : tests 'query' against entity's response system and returns the best response found (or null if none found)."
    },
    {
        "link": "https://developer.valvesoftware.com/wiki/Dota_2_Workshop_Tools/Lua_Abilities_and_Modifiers",
        "document": "Lua is now capable of specifying abilities and modifiers entirely in Lua; this is appropriate if you're familiar with Lua and the abilities/modifiers you want to make may have more advanced logic in their effects. Lua-derived abilities and modifiers behave similarly to their in-game counterparts, calling out to certain virtual functions at certain times. As an author of a Lua ability or modifier, you have the choice of overriding those functions in your script.\n\nTo setup a Lua ability, you'll want to start with these steps:\n\n\n\n At a minimum, you'll want these three lines to enable the Lua-based ability.\n\n\n\n Next, in your directory, you'll want to make a new file with the same name as the \"ScriptFile\" entry in the npc_abilities_custom.txt file. In this example, the file name would be test_lua_ability.lua.\n\n\n\n At the top of the new file, declare a new Lua class using the same name you've been using:\n\n\n\n You've now correctly setup a function Lua-based ability. To give it functionality, begin by overriding functions exposed on the Ability_Lua class ( you can see the full list of these by using script_help2 ). Because these functions are communicating with our engine, they expect certain return types and parameters. Some common examples are below.\n\nThe engine calls these functions at certain points during an ability. Add them to your script if your ability wants to have functionality at those times.\n\n-- When cast time ends, resources have been spent - most abilities begin to do their work in this function. No return type, no parameters. -- When cast time begins, resources have not been spent. Return true for successful cast, or false for unsuccessful, no parameters. -- When cast time is cancelled for any reason. No return type, no parameters. -- If this ability has created a projectile, this function will be called many times while the projectile is travelling. vLocation is the current projectile location. No return type. -- When a projectile has travelled its max distance OR collided with an NPC that fits its targeting type. If hTarget is null, it means the projectile has expired. Return true to destroy the particle, return false to continue the projectile ( this applies for linear projectiles that can hit multiple NPCs, like Dragon Slave. If the projectile has reached its end, it will expire even if false is passed ) -- Return \"modifier_name\" of the modifier that is passively added by this ability. -- When channel finishes, bInterrupted parameter notifies if the channel finished or not. No return type. -- When the ability is leveled up. No parameters, no return type.\n\nLike normal abilities, ability_lua will read in the npc_abilities_custom.txt to determine a lot of its properties, such as targeting type, mana cost, flags, team, and behavior. If you have an ability that operates in different ways under different conditions, you can override the default behaviors by adding certain functions in your script.\n\n\n\n When using the functions above, often you will want to return the default behavior under certain conditions. An example of this is Vengeful Spirit's Nether Swap; this ability only wants special GetCooldown() behavior if the caster has Aghanim's Scepter. In these cases, you can call the \"BaseClass\" to do what the function would normally do had you not overriden it in your script.\n\n\n\n Some abilities may want to generate custom cast errors that are more expressive than the default flags will allow. This is called a CastFilter. Based on the casting Behavior of the ability, you'll want to choose one of the following function pairs:\n\n\n\n Here is an example of a CastFilter from Vengeful Spirit's Nether Swap. Nether Swap's casting behavior allows creeps, but only if the caster has Aghanim's Scepter. Nether Swap also cannot be cast on Vengeful herself. Note that CastFilterResult and GetCustomCastError are shared functions, meaning they run on both server and client.\n\nThere are also several properties abilities have that are not exposed in npc_abilities_custom.txt. In general, you only want to override these functions if your ability wants special behavior different from the default. Some examples:\n\nHere is the full script for a lua version of Vengeful Spirit's Nether Swap.\n\nModifiers work much in the same way as the Lua Abilities, but the setup is slightly different. Similar to the Lua Abilities, start with a .lua file named appropriate to the name. Here is an example from Sven's Warcry. At the top of that file, create a class with the same name as the file. In this case, modifier_sven_warcry_lua .\n\n\n\n There is an additional step that is unique to lua modifiers; you must register their use with the engine before creating them. A good place to do this is in the related ability file. Typically, modifiers are created by abilities, but not always; if that is the case, you can call them in your base game mode script. The only requirement is that it is called before any instances of the modifier are created. Because modifier_sven_warcry_lua is related to the Warcry ability, it can be registered there. Note that this is found in the \"sven_warcry_lua.lua\" file, which is different than the file the modifier is defined in.\n\n\n\n The first parameter is the name (also the script file name) of the modifier you're registering; the second parameter is an enum type LuaModifierType, which is used to establish which, if any, motion controller type the modifier will apply on its parent. The different types are as follows:\n\n\n\n The modifier is now setup and can be added via the normal methods of adding modifiers. Note that new in this update, Modifiers (CDOTA_Buff) is an understood type in Lua, so you can create locals from them and call functions on them (see script_help2 for a full list), which is useful when defining your own modifier. Much like Abilities, the lua Modifier is overriding function calls from the engine. Many modifiers call a similar set of functions that are unrelated to their specific function and useful for basic setup and declaring variables. Here are some examples:\n\n\n\n Note that these functions will be called separately on the client and the server. In general, it is best to perform game logic only on the server. Client functionality on modifiers is typically only used for tooltip reasons (so that bonuses show correctly in the HUD). If you are getting Lua errors when creating your modifier in the game, but the modifier still performs its game logic correctly, this is usually a sign of trying to do game logic on the client.\n\nA function many lua modifiers want to use is DeclareFunctions(). This function should return a table of events and properties that your modifier wants to affect. The full list of the enum and function values is quite extensive, and can be seen by typing script_help2 in the game. Here is an example from Sven's Warcry modifier. This modifier wants to affect its parent's armor and movement speed, so in DeclareFunctions it must return the related enum values.\n\n\n\n The second step in affecting the above properties is to override their associated functions. Each property expects a specific function name.\n\n\n\n The params parameter is common to all property and event related functions. It is a table loaded with contents that are specific to the event happening at the time. Using a loop and Msg() function, you can print the contents of the table. Warcry's property functions are quite simple, so here is an example from Sven's Great Cleave where this is used. Note that property functions are Client and Server, so gameplay logic is only being performed on the Server.\n\nSome modifiers want to perform gameplay logic on certain intervals. You can do this by calling StartIntervalThink() on the modifier. Once the interval has been started, the engine will look for the function OnIntervalThink(), which will be called each time the think interval happens. The think can be stopped by calling StartIntervalThink() with -1 as the parameter. Lina's Fiery Soul makes use of these functions, here is an example:\n\nSometimes modifiers want to do their gameplay effects around a location instead of around an NPC. In this situation you want to use a \"thinker.\" Thinker modifiers are effectively invisible, invulnerable units with a modifier. Their structure is no different on the modifier side, but the creation is slightly different. Lina's Light Strike Array creates a delayed effect on an area, so a modifier thinker is used in this situation. Here's the example of how it is created:\n\nOne thing to remember with a thinker is that it is important to remove the dummy unit once the Thinker has expired. UTIL_Remove( self:GetParent() ) is a good way to do this. Doing this will also remove the modifier.\n\nSeparate from properties and events, modifiers can apply \"state.\" Some examples of state include being stunned, being invisible, being phased, etc. The full list is detailed in script_help2 in the modifierstate enum. State is applied by adding the function CheckState() in your modifier. A common case is to apply a stun. Note that the syntax is slightly different from that of DeclareFunctions().\n\nHere is an example of the stun modifier that is applied from Light Strike Array."
    },
    {
        "link": "https://developer.valvesoftware.com/wiki/Dota_2_Workshop_Tools/Scripting/API",
        "document": "This page outdated, use moddota.com/api instead\n\nWhile Lua is dynamically typed, the DOTA 2 engine is written primarily in C++, which is statically typed. Thus, you'll need to be conscious of your data types when calling the API. (If you try to pass the wrong type to an API function, you'll get an error message in Vconsole telling you what you passed and what it was expecting.)\n\nGlobal functions. These can be called without any class.\n\nReturns the number of degrees difference between two yaw angles AppendToLogFile is deprecated. Print to the console for logging instead. (vector,float) constructs a quaternion representing a rotation by angle around the specified vector axis Compute the closest point on the OBB of an entity. Compute the distance between two entity OBB. A negative return value indicates an input error. A return value of zero indicates that the OBBs are overlapping. Create all I/O events for a particular entity (hInflictor, hAttacker, flDamage) - Allocate a damageinfo object, used as an argument to TakeDamage(). Call DestroyDamageInfo( hInfo ) to free the object. Creates a DOTA hero by its dota_npc_units.txt name and sets it as the given player's controlled hero Create illusions of the passed hero that belong to passed unit using passed modifier data. ( hOwner, hHeroToCopy, hModiiferKeys, nNumIllusions, nPadding, bScramblePosition, bFindClearSpace ) Create a physical item at a given location, can start in air (but doesn't clear a space) Create a modifier not associated with an NPC. ( hCaster, hAbility, modifierName, paramTable, vOrigin, nTeamNumber, bPhantomBlocker ) Create a scene entity to play the specified scene. Create a temporary tree, specifying the tree model name. (vLocation, flDuration, szModelName). CreateTriggerRadiusApproximate( vecOrigin, flRadius ) : Creates and returns an AABB trigger thats bigger than the radius provided Creates a DOTA unit by its dota_npc_units.txt name Creates a DOTA unit by its dota_npc_units.txt name Creates a DOTA unit by its dota_npc_units.txt name from a table of entity key values and a position to spawn at. Try to clear all the debug overlay info Free a damageinfo object that was created with CreateDamageInfo(). #ScriptAssert:Asserts the passed in value. Prints out a message and brings up the assert dialog. #UniqueString:Generate a string guaranteed to be unique across the life of the script VM, with an optional root string. Useful for adding data to tables when not sure what keys are already in use in that table. Emit an announcer sound for all players. Emit an announcer sound for a team at a specific location. Play named sound only on the client for the passed in player Emit a sound on a location from a unit, only for players allied with that unit (vLocation, soundName, hCaster Turn an entity index integer to an HScript representing that entity's script instance. Smooth curve decreasing slower as it approaches zero Finds a clear random position around a given target unit, using the target unit's padded collision radius. Place a unit somewhere not already occupied. Find units that intersect the given line with the given flags. Finds the units in a given radius with the given flags. Fire Entity's Action Input with passed String - you own the memory Fire Entity's Action Input with passed Vector - you own the memory Fire a game event without broadcasting to the client. Get the time spent on the server in the last frame Get the enity index for a tree id specified as the entindex_target of a DOTA_UNIT_ORDER_CAST_TARGET_TREE. Returns the supplied position moved to the ground. Second parameter is an NPC for measuring movement collision hull offset. Get the cost of an item by name. Get the local player on a listen server. Get the name of the map. Get the longest delay for all events attached to an output Get Angular Velocity for VPHYS or normal object. Returns a vector of the axis of rotation, multiplied by the degrees of rotation per second. Get Velocity for VPHYS or normal object Given and entity index of a tree, get the tree id for use for use with with unit orders. InitLogFile is deprecated. Print to the console for logging instead. Returns true if this is lua running from the client.dll. Returns true if this server is a dedicated server. Returns true if this is lua running within tools mode. Ask fog of war if a location is visible to a certain team (nTeamNumber, vLocation). Returns true if the entity is valid and marked for deletion. Returns true if this is lua running from the server.dll. Checks to see if the given hScript is a valid entity (vector,vector,float) lerp between two vectors by a float factor returning new vector Set the limit on the pathfinding search space. Link a lua-defined modifier with the associated class ( className, fileName, LuaModifierType). Register as a listener for a game event from script. Creates a table from the specified keyvalues text file Creates a table from the specified keyvalues string Checks to see if the given hScript is a valid entity Get a script instance of a player by index. Precache an entity from KeyValues in table Asynchronously precaches a DOTA item by its dota_npc_items.txt name, provides a callback when it's finished. Precaches a DOTA item by its dota_npc_items.txt name Asynchronously precaches a DOTA unit by its dota_npc_units.txt name, provides a callback when it's finished. Precaches a DOTA unit by its dota_npc_units.txt name Get a random 2D vector of the given length. Remove the C proxy for a script-based spawn group filter Check and fix units that have been assigned a position inside collision radius of other NPCs. (quaternion,vector,float) rotates a quaternion by the specified angle around the specified vector axis Find the delta between two QAngles. Have Entity say string, and teamOnly or not Start a screenshake with the following parameters. vecCenter, flAmplitude, flFrequency, flDuration, flRadius, eCommand( SHAKE_START = 0, SHAKE_STOP = 1 ), bAirShake ( DOTAPlayer sendToPlayer, int iMessageType, Entity targetEntity, int iValue, DOTAPlayer sourcePlayer ) - sendToPlayer and sourcePlayer can be nil - iMessageType is one of OVERHEAD_ALERT_* Send a string to the console as a client command Send a string to the console as a server command Sets an opvar value for all players Sets an opvar value for a single player Set Angular Velocity for VPHYS or normal object, from a vector of the axis of rotation, multiplied by the degrees of rotation per second. Hierarchically spawn an entity group from a set of spawn tables. Asynchronously spawn an entity group from a list of spawn tables. A callback will be triggered when the spawning is complete Synchronously spawn an entity group from a list of spawn tables. (quaternion,quaternion,float) very basic interpolation of v0 to v1 over t on [0,1] (vector,vector,float) very basic interpolation of v0 to v1 over t on [0,1] Stop listening to all game events within a specific context. Returns the number of degrees difference between two yaw angles Sends colored text to all clients. (Valid context keys: player_id, value, team_id) Sends colored text to one client. (Valid context keys: player_id, value, team_id) Clear all message text on one client. Clear all message text from all clients. Get Qangles (with no roll) for a Vector. Gets the value of the given cvar, as a float. Sets the value of the given cvar, as a float. Commit the result of QueryBestResponse back to the given entity to play. Call with params (entity, airesponse) Retrieve a table of all available expresser targets, in the form { name : handle, name: handle }. Params: (entity, query) : tests 'query' against entity's response system and returns the best response found (or null if none found)."
    },
    {
        "link": "https://developer.valvesoftware.com/wiki/Dota_2_Workshop_Tools/Scripting/API/Global.CreateUnitByName",
        "document": "has no to other VDC articles. Please help improve this article by adding links that are relevant to the context within the existing text. \n\nJanuary 2024 This articlePlease help improve this article by adding linkswithin the existing text.January 2024\n\nNote: This page is automatically generated. Any changes may be overwritten\n\nCreates a DOTA unit by its dota_npc_units.txt name ( szUnitName, vLocation, bFindClearSpace, hNPCOwner, hUnitOwner, iTeamNumber )"
    },
    {
        "link": "https://github.com/ModDota/API/blob/master/dump/script_help2.lua",
        "document": "[[ DoUniqueString #UniqueString:Generate a string guaranteed to be unique across the life of the script VM, with an optional root string. Useful for adding data to tables when not sure what keys are already in use in that table. ]]"
    },
    {
        "link": "https://docs.moddota.com/lua_server",
        "document": "A Project by ModDota to have automated documenation of all aspects of Custom Games, with more coming over time."
    },
    {
        "link": "https://github.com/ModDota/API/blob/master/examples/vscript/declarations/dota-api.d.ts",
        "document": "To see all available qualifiers, see our documentation .\n\nSaved searches Use saved searches to filter your results more quickly\n\nWe read every piece of feedback, and take your input very seriously.\n\nYou signed in with another tab or window. Reload to refresh your session.\n\nYou signed out in another tab or window. Reload to refresh your session.\n\nYou switched accounts on another tab or window. Reload to refresh your session."
    }
]