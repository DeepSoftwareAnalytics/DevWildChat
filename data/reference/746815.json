[
    {
        "link": "https://stackoverflow.com/questions/59980269/infinite-horizontal-scrolling-image-loop",
        "document": "so I'm trying to create an infinite scroll animation on my website, but I've been really struggling. The original tutorial is here, and uses 6 images, with 4 repeating at the end to make the transition seamless.\n\nThe problem is that when I add more images, the animation doesn't work. I know that's because I need to increase the width and other variables. In the original, it looks like since she has 10 images (6 original and 4 repeats) that are each 350px, and the photobanner is 3550px, the formula should be 10 times the image width plus 50px for the margin. So I tried doing that to start.\n\nI've been adjusting how much the banner moves relentlessly, but the tutorial doesn't explain how I need to calculate the distance that the banner needs to move without it looping. Looking online there are tons of people with the same problem, and I haven't found any clear answers except copying and pasting someone's code. Is there a better guide that I could be using, or could anyone let me know what variables I need to be adjusting?\n\nAlso if I change the container width from 1000px to something larger, will I have to adjust the other numbers as well? If so, how do I calculate that? Surely there must be a better way than rewatching the loop 1000 times, and slightly changing the number each time until the pixels line up perfectly? If so that's going to take me an extremely long time since my loop is so long.\n\nIf it helps, each image is 800px by 308px. Here is the HTML. Any help or even a source to learn how to figure it out myself would be really appreciated.\n\nAnd here is the CSS"
    },
    {
        "link": "https://smashingmagazine.com/2024/04/infinite-scrolling-logos-html-css",
        "document": "When I was asked to make an auto-scrolling logo farm, I had to ask myself: “You mean, like a ?” It’s not the weirdest request, but the thought of a conjures up the “old” web days when Geocities ruled. What was next, a repeating sparkling unicorn GIF background?\n\nIf you’re tempted to reach for the element, don’t. MDN has a stern warning about it right at the top of the page:\n\nThat’s fine because whatever infinite scrolling feature is offered, we can most certainly pull off in CSS. But when I researched examples to help guide me, I was surprised to find very little on it. Maybe auto-scrolling elements aren’t the rage these days. Perhaps the sheer nature of auto-scrolling behavior is enough of an accessibility red flag to scare us off.\n\nWhatever the case, we have the tools to do this, and I wanted to share how I went about it. This is one of those things that can be done in lots of different ways, leveraging lots of different CSS features. Even though I am not going to exhaustively explore all of them, I think it’s neat to see someone else’s thought process, and that’s what you’re going to get from me in this article.\n\nBut first, here’s an example of the finished result:\n\nThe idea is fairly straightforward. We want some sort of container, and in it, we want a series of images that infinitely scroll without end. In other words, as the last image slides in, we want the first image in the series to directly follow it in an infinite loop.\n\nSo, here’s the plan: We’ll set up the HTML first, then pick at the container and make sure the images are correctly positioned in it before we move on to writing the CSS animation that pulls it all together.\n\nLike I mentioned, I tried searching for some ideas. While I didn’t find exactly what I was looking for, I did find a few demos that provided a spark of inspiration. What I really wanted was to use CSS only while not having to “clone” the marquee items.\n\nGeoff Graham’s “Sliding Background Effect” is close to what I wanted. While it is dated, it did help me see how I could intentionally use to allow images to “slide” out of the container and an animation that loops forever. It’s a background image, though, and relies on super-specific numeric values that make it tough to repurpose in other projects.\n\nThere’s another great example from Coding Journey over at CodePen:\n\nThe effect is what I’m after for sure, but it uses some JavaScript, and even though it’s just a light sprinkle, I would prefer to leave JavaScript out of the mix.\n\nRyan Mulligan’s “CSS Marquee Logo Wall” is the closest thing. Not only is it a logo farm with individual images, but it demonstrates how CSS masking can be used to hide the images as they slide in and out of the container. I was able to integrate that same idea into my work.\n\nBut there’s still something else I’m after. What I would like is the smallest amount of HTML possible, namely markup that does not need to be duplicated to create the impression that there’s an unending number of images. In other words, we should be able to create an infinite-scrolling series of images where the images are the only child elements in the “marquee” container.\n\nI did find a few more examples in other places, but these were enough to point me in the right direction. Follow along with me.\n\nLet’s set up the HTML structure first before anything else. Again, I want this to be as “simple” as possible, meaning very few elements with the shortest family tree possible. We can get by with nothing but the “marquee” container and the logo images in it.\n\nThis keeps things as “flat” as possible. There shouldn’t be anything else we need in here to make things work.\n\nFlexbox might be the simplest approach for establishing a row of images with a gap between them. We don’t even need to tell it to flow in a row direction because that’s the default.\n\nI already know that I plan on using absolute positioning on the image elements, so it makes sense to set relative positioning on the container to, you know, contain them. And since the images are in an absolute position, they have no reserved height or width dimensions that influence the size of the container. So, we’ll have to declare an explicit (the logical equivalent to ). We also need a maximum width so we have a boundary for the images to slide in and out of view, so we’ll use (the logical equivalent to ):\n\nNotice I’m using a couple of CSS variables in there: one that defines the marquee’s height based on the height of one of the images ( ) and one that defines the marquee’s maximum width ( ). We can give the marquee’s maximum width a value now, but we’ll need to formally register and assign a value to the image height, which we will do in a bit. I just like knowing what variables I am planning to work with as I go.\n\nNext up, we want the images to be hidden when they are outside of the container. We’ll set the horizontal overflow accordingly:\n\nAnd I really like the way Ryan Mulligan used a CSS mask. It creates the impression that images are fading in and out of view. So, let’s add that to the mix:\n\nHere’s what we have so far:\n\nAbsolute positioning is what allows us to yank the images out of the document flow and manually position them so we can start there.\n\nThat makes it look like the images are completely gone. But they’re there — the images are stacked directly on top of one another.\n\nRemember that CSS variable for our container, ? Now, we can use it to match the marquee item height:\n\nTo push marquee images outside the container, we need to define a , but that calculation is not trivial, so we will learn how to do it in the next section. We know what the needs to be: something that moves linearly for a certain duration after an initial delay, then goes on infinitely. Let’s plug that in with some variables as temporary placeholders.\n\nTo animate the marquee items infinitely, we have to define two CSS variables, one for the duration ( ) and one for the delay ( ). The duration can be any length you want, but the delay should be calculated, which is what we will figure out in the next section.\n\nFinally, we will translate the marquee item by horizontally. This small “hack” handles situations when the image sizes are uneven.\n\nTo make the animation work, we need the following information:\n\nLet’s use the following configurations for our set of variables:\n\nNote: I’m using the BEM modifier to define the animation of the eight logos. We can define the animation keyframes now that we know the value.\n\nThe animation moves the marquee item from right to left, allowing each one to enter into view from the right as it travels out of view over on the left edge and outside of the marquee container.\n\nNow, we need to define the . We want to push the marquee item all the way to the right side of the marquee container, opposite of the animation end state.\n\nYou might think the offset should be , but that would make the logos overlap on smaller screens. To prevent that, we need to know the minimum width of all logos combined. We do that in the following way:\n\nBut that is not enough. If the marquee container is too big, the logos would take less than the maximum space, and the offset would be within the container, which makes the logos visible inside the marquee container. To prevent that, we will use the function like the following:\n\nThe function checks which of the two values in its arguments is bigger, the overall width of all logos or the maximum width of the container plus the single logo width, which we defined earlier. The latter will be true on bigger screens and the former on smaller screens.\n\nFinally, we will define the complicated animation delay ( ) with this formula:\n\nThe delay equals the animation duration divided by a quadratic polynomial (that’s what ChatGPT tells me, at least). The quadratic polynomial is the following part, where we multiply the number of items and number of items minus the current item index:\n\nNote that we are using a negative delay ( ) to make the animation start in the “past,” so to speak. The only remaining variable to define is the (the current marquee item position):\n\nHere’s that final demo once again:\n\nWhile the animation isn’t exactly the most complex and wild thing you’ll find, it still could be a trigger for those with motion sensitivities due to a vestibular disorder. We can slow or eliminate the animation with the media query:\n\nThis does the job, but we could do a little better to make sure more of the logos are visible when the animation is off.\n\nA more heavy-handed approach would be to add a button or some other control that toggles between play and pasued states, but whether or not you go that route will depend on your project requirements and whether the animation is essential to your interface.\n\nThis solution could be better, especially when the logos are not equal widths. To adjust the gaps between inconsistently sized images, we could calculate the delay of the animation more precisely. That is possible because the animation is linear. I’ve tried to find a formula, but I think it needs more fine-tuning, as you can see:\n\nAnother improvement we can get with a bit of fine-tuning is to prevent big gaps on wide screens. To do that, set the and declare on the container:\n\nWhat do you think? Is this something you can see yourself using on a project? Would you approach it differently? I am always happy when I land on something with a clean HTML structure and a pure CSS solution. You can see the final implementation on the Heyflow website.\n• Infinite Scroll UX Done Right: Guidelines and Best Practices, Vitaly Friedman"
    },
    {
        "link": "https://geeksforgeeks.org/how-to-create-infinite-scrolling-using-onscroll-event-in-javascript",
        "document": "We have seen many shopping sites that list some limited number of products(using a back-end API) when we open the website and scroll down to the bottom, we see that more products are fetched and displayed, and as we scroll even further even more products are loaded and fetched and it keeps happening till there are no more products to be displayed. This is something that we call Infinite Scrolling. We will implement this similar feature in Javascript using the onScroll event.\n• pageNum and initialize its value as 1\n• div element class container , inside this div we will show all the results fetched from an API. We will use a paginated API with endpoint https://api.github.com/repositories/1300192/issues?page=${pageNum}\n• fetchData which will be responsible for fetching data from the API.\n• container onscroll event and we will check that when we have reached the end of the container pageNum 1 and fetch more data by calling the function fetchData . We will check that if Math.ceil(container.clientHeight + container.scrollTop) >= container.scrollHeight then it means that we have reached the end of the container\n\nExplanation: For the first time some result is fetched and displayed and as we scroll down further more data is fetched and displayed."
    },
    {
        "link": "https://stackoverflow.com/questions/65908655/how-do-i-create-an-infinite-scrolling-image-gallery",
        "document": "As the images can have different aspect ratios it is quite messy to move just one image at a time to the back of the queue, and would require JavaScript intervention.\n\nA similar method is to have exactly two copies of the images, to animate permas div element to move to the left by 50% of its width, i.e. to get all 10 images out of the way to the left, and have the viewport filled by the start of the second set.\n\nThen get permas back to where it was initially and repeat.\n\nThere was some worry expressed in the comments that too much work would be needed. I have tested 10 images of different sizes and different content as well as the image given in the question and have found the GPU usage on my reasonably powerful laptop with Windows 10 to be pretty consistent around 20%. Of course, with lots more images (and possibly if some have natural dimensions very large, though I haven't tested that) there might be more processor time needed.\n\nI haven't seen any jerkiness. You do have to be confident that the 10 images will more than cover the viewport width - but that assumption was also made in the question.\n\nHere's the snippet with the original image:"
    },
    {
        "link": "https://javascript.plainenglish.io/effortless-infinite-scrolling-a-guide-to-dynamic-image-loading-3ff6e7a4a608",
        "document": "Recently, I found myself aimlessly scrolling through Instagram, as I often do when boredom strikes. As I continued to scroll, I noticed that posts seemed to load endlessly. This made me wonder: Do they really load all at once? That’s a significant amount of data to fetch simultaneously, and trying to do so could potentially crash my website.\n\nCurious, I switched to my desktop, opened Instagram, and activated the developer tools to inspect the API calls being made. To my surprise, I discovered numerous requests to the endpoint every time I scrolled.\n\nThis revelation led me to an intriguing concept: infinite scrolling. I found it fascinating and thought it might pique the interest of fellow tech enthusiasts. While I’m not yet a seasoned developer capable of creating a full-fledged app like Instagram, I figured I could at least build a simple prototype that mimics this functionality.\n\nTo create our prototype, follow these simple steps:\n• Create a Project Folder: Open up your PC and create an empty folder. Inside, add two files: and .\n• Set Up Your HTML: Open and include the following code snippet in the HTML boilerplate:\n\n3. Add Some Basic Styling: Incorporate the following CSS for basic styling:\n\n4. Link Your JavaScript File: Ensure you include the script file at the end of your HTML, just before the closing tag:\n\nLet’s build some functionality into it:\n\nNow, let’s dive into the file and implement the core functionality. First, we’ll set up some variables to help us manage our data:\n• : References the container div where images will be appended.\n• : References the loading div for displaying the \"Loading...\" message.\n• : Tracks the current page number, starting at 1 and incrementing for each new fetch.\n• : Defines the number of images fetched per page from the API.\n\nNext, we need a function to fetch images and display them on the screen:\n\nNow, let’s create a function to display the fetched images:\n\nTo trigger API calls when the user scrolls near the bottom of the page, we’ll add an event listener:\n\nFinally, make the initial call to fetch images when the page loads:\n\nHold on! I spotted a little hiccup in the code. Can you guess what it is? If not, let me explain: the API calls are firing multiple times as I scroll to the bottom. This happens due to the rapid mouse scroll events. To fix this issue, we need to implement a debounce function on our scroll event listener. This will ensure that we only trigger a new API call after a brief pause in scrolling. Let’s update the code accordingly!\n\nNow, let’s modify our scroll event listener to use debounce:\n\nGreat news! Everything should be working smoothly now — no more hiccups!\n\nWhat a journey! It had its ups and downs, but we made it through together.\n\nAnd there you have it! With just a few lines of code, you’ve created a simple infinite scrolling image gallery. This exercise demonstrates not only how to implement a popular UI feature but also offers a glimpse into the efficient handling of API calls. Feel free to experiment and expand upon this basic functionality!\n\nThank you for being a part of the In Plain English community! Before you go:\n• Be sure to clap and follow the writer ️👏️️"
    },
    {
        "link": "https://dev.to/tqbit/how-to-efficiently-handle-window-scroll-events-in-javascript-261f",
        "document": "Not properly handling these scroll events can lead to serious performance issues:\n• If you rely on scroll events for heavier computations, you will inevitably cause memory leaks to occur and degrade your web app further\n\nThe practices introduced in this post are especially relevant for heavily interactive websites. They'll help you make your scroll events more efficient in a central space. Let's dive in.\n\nTL:DR\n\n You can find the Code Sandbox for this article here\n\nWhile not directly improving our app's performance directly, it's a good idea to collect all scroll events as part of a single function or class. It makes management and debugging of events easier and the code more readable.\n\n\n\nThe browser will still run all functions at every scroll event so there's still some optimization ahead of us.\n\nWhen a scroll event's callback function is fired, the browser always waits for all functions to be executed. Collecting all event handlers in a single entity, therefore, introduces a potentially huge performance degradation. Fortunately, we can mitigate it by using a queue.\n\nBy using , we give the browser time to handle other tasks before the next function in the queue is called. However, the queue still does not solve the problem of every event being fired every time a user scrolls. There are two ways of handling this matter.\n\nInstead of calling every function on every scroll, providing a fixed rate per second is better. This is what throttling is about.\n\nWe can build on our previous two approaches and implement a throttle feature that listens to scroll events every time but only executes them once every 200ms.\n\n\n\nThe maximum amount of function calls is therefore limited to 5 per second. You can adjust the limit by changing the second argument of .\n\nThrottling in combination with efficient queue structures is a great way to mitigate the browser's blocking process. There's an alternative approach, however, if you would like to limit function execution even more.\n\nAn alternative approach to throttling is debouncing. In this context, this means waiting till the user finishes scrolling. While less interactive compared to throttling, it's a great alternative and, depending on the use case, also more efficient.\n\nAll we have to do is implement a timeout that is called 200ms after the initial scroll event is registered.\n\n\n\nWhenever a user scrolls, the event will now only be fired when the scrolling stops for a significant amount of time.\n\nYou can even go a step further and combine these methods with other browser features, say the Observer API, to capture your user's interest or execute asynchronous operations."
    },
    {
        "link": "https://medium.com/@francesco.saviano87/mastering-javascript-events-how-to-handle-user-actions-with-ease-9c50f29816b8",
        "document": "JavaScript events are the backbone of making modern websites interactive. They allow developers to capture user actions like clicking a button, scrolling through a page, or submitting a form. Mastering event handling is key to creating responsive web applications that enhance user experience. Whether you’re building a simple form validation or a complex web game, understanding how events work will save you time and allow you to build dynamic, engaging user interfaces.\n\nIn this post, we’ll dive into JavaScript events — what they are, how to use them, and why they’re crucial for modern web development. You’ll learn the different types of events, how to capture them, and best practices for handling user actions. This guide is perfect for beginner developers looking to take their JavaScript skills to the next level.\n\nBy the end, you’ll be confident in using events to build more interactive and engaging web applications.\n\nPlease note that this content was crafted with the assistance of ChatGPT, an artificial intelligence language model developed by OpenAI. The author has overseen and refined AI’s contributions to ensure adherence to editorial standards and the accurate reflection of the intended messaging.\n\nWhat Are JavaScript Events and Why Do They Matter?\n\nAt the heart of every interactive web application are JavaScript events. These events are actions or occurrences — like clicking a button, typing into a form, or resizing a window — that happen in the browser and are detected by JavaScript. By responding to these events, you can create dynamic websites that provide instant feedback to users.\n\nIn JavaScript, events can be triggered by both users and the browser itself. For example, a user may trigger a mouse event by clicking on a button, or the browser might trigger a window event when a page finishes loading. JavaScript events make it possible to capture these actions and execute code that modifies the page without needing to reload it.\n\nThe significance of events lies in their ability to make web pages feel more responsive. Without event handling, websites would function as static documents where every interaction requires a full page reload — much like the web of the late 90s. By learning how to handle events in JavaScript, you can dramatically enhance the user experience, making your web applications more fluid and engaging.\n\nHow Do You Listen for Events in JavaScript?\n\nIn JavaScript, the most common way to interact with events is by listening for them. Listening for an event means waiting for a specific action to occur, like a button click, a keypress, or a mouse hover, and then executing a function in response. There are two main methods for adding event listeners in JavaScript:\n\nInline event handlers involve embedding the event-handling function directly in the HTML element. For example, you might use the attribute to trigger an event when a button is clicked:\n\nWhile this method is simple and easy to understand, it has several drawbacks. Inline event handlers mix HTML and JavaScript code, which can make your code harder to maintain and debug as your project grows. Additionally, inline event handlers are less flexible, as you can only bind one event handler per element.\n\nThe recommended and more flexible approach to event handling is using the method. This method allows you to attach multiple event handlers to a single element and keeps your JavaScript code separate from your HTML.\n\nHere’s an example using :\n\nWith , you can attach as many event listeners as you need to any element, making it ideal for complex, interactive web applications. It also provides better control over when and how events are triggered, and allows for more efficient event delegation, which we’ll cover later in this post.\n\nDifferent Types of Events You Can Handle\n\nJavaScript events come in various forms, each triggered by different user actions or browser behaviors. Understanding these event types is essential for crafting dynamic web applications that can react to anything the user does. Let’s dive into some of the most common categories of events and what they represent:\n\nMouse events are some of the most frequently used in web development. They are triggered by actions like clicking, hovering, or dragging with the mouse. Examples include:\n• : Fired when a user clicks on an element.\n• : Occurs when the mouse pointer moves over an element.\n• : Fires when the pointer leaves an element.\n\nThese events are invaluable for creating interactive UI components like buttons, image galleries, and navigation menus.\n\nKeyboard events are triggered when a user interacts with their keyboard. These are especially useful for handling form inputs or creating keyboard shortcuts:\n• : Fires when a key is pressed down.\n• : Deprecated, but was used to detect keypresses.\n\nWith keyboard events, you can create rich interactions like form validation, shortcuts, or even entire games controlled by keyboard input.\n\nForm elements like input fields, text areas, and select boxes often need special attention. Form events are used to capture and respond to changes in these elements:\n• : Triggered when the value of an input element changes.\n• : Fires when an element gains focus (e.g., when a user clicks on a text box).\n\nForm events make it easy to create interactive forms that validate data on the fly, ensuring that user input meets your application’s requirements before submission.\n\nWindow events are triggered by actions that involve the browser window or document. These are particularly useful when building responsive layouts or when detecting user actions like resizing or scrolling:\n• : Fired when the entire page has finished loading.\n• : Triggered when the browser window is resized.\n• : Fired when the user scrolls within the document.\n\nWindow events are crucial for implementing features like lazy loading of images, sticky headers, or infinite scrolling.\n\nEach of these event categories offers unique ways to interact with users, enabling you to make your web applications more dynamic and responsive.\n\nHow to Use Event Listeners: The Method\n\nThe method is the most powerful and flexible way to handle events in JavaScript. It allows you to attach one or more event handlers to any DOM element without mixing JavaScript directly into your HTML. Unlike inline event handlers, which only allow one function per event, lets you assign multiple functions to a single event, making it the preferred choice for modern web development.\n\nThe basic syntax of is:\n• : The type of event to listen for, like , , or .\n• : The function to execute when the event is triggered.\n• (optional): A boolean that defines whether the event should be captured or bubbled. We’ll discuss this more in the event propagation section.\n\nHere’s a simple example where an event listener is added to a button element:\n\nIn this example, when the button is clicked, the event triggers the anonymous function, which displays an alert message.\n\nWhy Use Over Inline Handlers?\n\nThere are several advantages to using over older methods like inline event handlers:\n• Multiple Event Handlers: With , you can attach several event listeners to the same element and event type. For example, you could log a message in the console and change a button’s color with two different functions.\n\n2. Separation of Concerns: By keeping your JavaScript and HTML separate, your code becomes easier to read, maintain, and debug. This approach is more scalable for larger applications.\n\n3. Capturing and Bubbling Phases: You can control when the event is triggered during its propagation through the DOM. More on this when we discuss event propagation.\n\nUsing is considered a best practice because it keeps your HTML clean, allows for multiple handlers, and provides greater control over how events are processed in your application.\n\nWhen you click on an element in a web page, the event doesn’t just stop there — it can travel through multiple elements. This movement of an event through different layers of the DOM is known as event propagation. In JavaScript, event propagation occurs in two main phases: bubbling and capturing. Understanding these phases is crucial for managing event behavior in complex layouts or nested elements.\n\nBy default, most events in JavaScript follow the bubbling phase, which means the event starts from the target element (the one that was clicked or interacted with) and “bubbles up” through its parent elements, all the way to the root of the document.\n\nFor instance, if you have a button inside a , and the button is clicked, the event will first be handled by the button, then by its parent , and eventually by the of the document.\n\nIf you click on the button, both the button’s and the div’s event listeners will trigger, logging messages to the console in that order. This is because the event bubbles from the button to the parent .\n\nThe capturing phase, also known as trickle-down, occurs before the bubbling phase. During this phase, the event starts at the document’s root and moves down toward the target element. By default, JavaScript events don’t use the capturing phase unless explicitly specified.\n\nYou can enable capturing by passing a third argument ( ) to :\n\nIn this case, the would catch the event before the button does, because the event is captured as it \"trickles down\" through the DOM.\n\nLet’s demonstrate the difference with both phases enabled:\n\nWhen you click the button, the console will log:\n\nThis shows how the event travels down the DOM during the capturing phase and then bubbles up after reaching the target.\n\nWhen to Use Bubbling and Capturing\n\nEvent bubbling is generally used more often because it’s the default behavior, and it works well for most cases. However, event capturing can be useful when you need more control over how events are processed, especially in complex layouts or when dealing with nested elements.\n\nIn many cases, when a user triggers an event — like submitting a form or clicking a link — the browser will automatically carry out a default action. For instance, submitting a form refreshes the page, and clicking a link takes the user to a new URL. However, there are situations where you want to stop these default behaviors from happening. That’s where comes in handy.\n\nWhat Does Do?\n\nThe method is used to stop the browser’s default action for a specific event. Instead of allowing the form to submit or a link to follow its attribute, this method cancels the default action, giving you full control over what happens next.\n\nLet’s say you have a form, and you want to validate the user’s input before submitting it. Using allows you to stop the form from submitting until the validation is successful:\n\nIn this example, if the input field is empty, the form will not submit, and an alert will prompt the user to fill out the required field. Without , the form would submit and refresh the page, making it harder for the user to correct their mistake.\n\nImagine you want to prevent a link from navigating to a new page under certain conditions. For example, you might want to warn the user before they leave the current page:\n\nIn this scenario, if the user clicks “Cancel” in the confirmation dialog, the link won’t be followed, allowing them to stay on the current page. Without , the browser would follow the link immediately after the click.\n• Form Validation: To prevent form submissions when inputs are incomplete or invalid.\n• Link Overrides: To control when and how links are followed, especially in single-page applications (SPAs).\n• Context Menus: To prevent the browser’s default context menu from appearing on right-click.\n\ngives developers more flexibility and control, making it essential for handling advanced event behaviors and improving user experience.\n\nWhen an event is triggered in JavaScript, it creates an event object that contains important information about the event. This object is automatically passed to the event handler function, allowing developers to access properties like the event type, the element that triggered the event, and even the mouse coordinates at the time of the event. By utilizing this information, you can create more interactive and dynamic user experiences.\n\nHere are some of the most commonly used properties of the event object:\n• : This property returns the type of event that was triggered (e.g., , ). It's useful for determining what action took place.\n• : This property provides a reference to the element that triggered the event. You can use to modify the element that was clicked or interacted with.\n• and : These properties return the X and Y coordinates of the mouse pointer when the event was triggered. This is useful for detecting where on the page a user clicked.\n• , , and : These boolean properties return if the Alt, Ctrl, or Shift key was pressed during the event. They can be used to detect keyboard modifiers in conjunction with other events.\n\nExample: Accessing the Event Object in a Click Event\n\nLet’s walk through a practical example where we capture several properties from the event object when a button is clicked:\n\nIn this example:\n• will log , since that’s the event being listened for.\n• will refer to the button that was clicked.\n• and will return the exact mouse coordinates at the time of the click, which can be useful in scenarios like creating custom tooltips or menus that appear at the click location.\n\nUsing the Event Object to Modify Elements\n\nThe event object can also be used to directly modify the appearance or behavior of elements based on user interactions. For example, you could change the background color of a clicked button:\n\nIn this case, the property refers to the button that was clicked, and the property is used to change its color dynamically.\n\nYou can also use the event object to detect whether a modifier key (e.g., Alt, Ctrl, Shift) was pressed during the event. For example, you can modify the behavior of a click event when the Alt key is held:\n\nThis allows you to add custom behavior for keyboard modifiers, which can be useful for creating shortcuts or enhancing accessibility features.\n\nUsing Event Delegation for Better Performance\n\nAs your web applications grow, you may find yourself attaching event listeners to multiple elements. While this works, it can lead to performance issues, especially if your page has many elements or dynamically generated content. This is where event delegation comes in — a technique that lets you handle events efficiently by attaching a single event listener to a parent element instead of each individual child element.\n\nEvent delegation leverages event bubbling, a process where an event triggered on a child element propagates up to its parent elements. Instead of adding separate event listeners to every child, you can attach one listener to the parent element, which will handle events for all its children. This technique is particularly useful when dealing with lists, tables, or dynamically created elements.\n\nLet’s say you have a list of items, and you want to handle click events for each item. Without event delegation, you would need to attach a listener to each list item like this:\n\nWhile this works, it becomes inefficient if the list contains many items. Instead, you can attach the event listener to the parent element:\n\nIn this example, the click event bubbles up from the clicked list item to the parent . By checking if the event’s target is a element, you ensure that the click event is only handled when a list item is clicked.\n• Performance Improvement: Instead of adding multiple event listeners, you can reduce memory usage by attaching just one listener to a parent element. This is especially useful in scenarios where elements are dynamically added or removed.\n• Simpler Code: With event delegation, you don’t have to worry about attaching or removing event listeners for dynamically created elements. The single parent listener handles it all.\n• Scalability: Whether you’re working with a few elements or thousands, event delegation scales well because the number of event listeners remains constant.\n\nImagine a to-do list where users can add new tasks. Instead of attaching event listeners to each task item when it’s created, you can delegate the event to the parent list:\n\nIn this example, the parent manages all clicks on its child elements, even for new items added dynamically. This demonstrates how event delegation simplifies event management and improves scalability.\n\nUnlock your JavaScript potential with ’50 Real-World JavaScript Apps for Beginners and Intermediates.’ Now available for download on both Gumroad and Ko-fi! Start building amazing projects today!\n\nWhile adding event listeners is essential for handling user interactions, it’s equally important to know how to remove them. Attaching too many event listeners or forgetting to remove them when they are no longer needed can lead to memory leaks and performance issues. Fortunately, JavaScript provides the method, which allows you to remove specific event listeners that were added via .\n\nThe syntax for removing an event listener is nearly identical to adding one:\n• : The event type you want to remove (e.g., ).\n• : The exact function that was initially passed to . This must be the same, meaning you cannot remove anonymous functions.\n• : The same value (either or ) that was used when attaching the event listener, specifying whether the listener was added in the capturing or bubbling phase.\n\nConsider the following example where a click event is added to a button and then removed after it is triggered once:\n\nIn this case, the function is passed to both and . As a result, the button will no longer respond to click events once the listener is removed.\n\nOne limitation of is that it requires the exact reference to the function used in . This means if you attached an event using an anonymous function, you won’t be able to remove it:\n\nIn the example above, even though the anonymous functions look identical, they are different in memory, so cannot match them.\n• Store Functions in Variables: To avoid issues with anonymous functions, store your event-handling functions in variables so you can remove them when needed.\n\n2. Remove Unnecessary Event Listeners: It’s a good practice to remove event listeners when they are no longer needed. For instance, in single-page applications, you may want to remove listeners when navigating away from a specific page.\n\n3. Use Option: If you only need an event to trigger once, consider using the option in :\n\nThis automatically removes the event listener after the first trigger, so you don’t need to manually remove it.\n\nFailing to remove unused event listeners can lead to memory leaks, especially when listeners are added to elements that are later removed from the DOM. Always remember to remove event listeners when they are no longer necessary, particularly in long-running applications.\n\nis a critical tool for managing the lifecycle of event listeners in your application. By efficiently adding and removing listeners, you can avoid performance bottlenecks and ensure your web applications run smoothly.\n\nAs you become more comfortable with JavaScript event handling, it’s important to adopt best practices to ensure that your code is efficient, scalable, and maintainable. Poor event handling can lead to performance issues, memory leaks, or hard-to-maintain code, especially as your projects grow in complexity. By following a few key practices, you can prevent these problems and build more robust web applications.\n\nWhile inline event handlers (e.g., using directly in HTML) might seem simple, they mix HTML and JavaScript, leading to less maintainable code. It’s generally best to keep your JavaScript logic separate from your HTML to ensure better organization and easier debugging. Here’s an example of an inline handler you should avoid:\n\nInstead, opt for the method in your JavaScript:\n\nThis approach allows you to keep your HTML clean and your JavaScript in one place, making your code easier to manage and understand.\n\n2. Use Event Delegation When Appropriate\n\nAs we discussed earlier, event delegation allows you to handle events efficiently by attaching a single event listener to a parent element rather than individual listeners to every child element. This not only reduces the number of event listeners in your application but also allows you to handle dynamically added elements without extra code.\n\nThis technique is especially useful when dealing with large datasets or when your page structure is complex. For instance, managing events for a long list of items is much more efficient when using event delegation rather than individual event listeners for each item.\n\nOne of the most common issues with JavaScript event handling is memory leaks caused by forgotten or unnecessary event listeners. If your web application adds a lot of event listeners, it’s crucial to remove them when they’re no longer needed — especially for elements that are removed from the DOM. This ensures that your application doesn’t hold onto memory unnecessarily, which can slow down performance over time.\n\nUse to clean up unused event listeners, particularly when navigating between different views in a single-page application (SPA) or when removing elements dynamically.\n\n4. Use Passive Event Listeners for Scroll and Touch Events\n\nScroll and touch events are fired frequently and can cause performance bottlenecks, especially on mobile devices. By using passive event listeners, you inform the browser that the event handler will not call , allowing the browser to optimize scrolling performance.\n\nHere’s how you can use a passive event listener:\n\nThis small change can result in smoother scrolling and better performance, particularly in mobile browsers.\n\nAccessing the DOM (Document Object Model) is relatively slow, so it’s best to minimize how often you query the DOM inside event handlers. Instead, try caching elements outside the event handler and reusing them:\n\nBy reducing repeated DOM access, you can improve the overall performance of your application, especially if the event handler is triggered frequently, such as with scroll or mouse movement events.\n\n6. Use Throttling or Debouncing for High-Frequency Events\n\nFor events that trigger frequently — such as scroll, resize, or mousemove — it’s best to use throttling or debouncing to limit how often your event handler runs. This ensures that the handler doesn’t run too often, which can affect the performance of your page.\n• Debouncing delays the execution of the event handler until the event stops firing.\n\nIn this example, the event handler only fires 200 milliseconds after the user has finished resizing the window.\n\nBy following these best practices, you’ll write more efficient and maintainable event-driven JavaScript applications. Proper use of , event delegation, and performance optimization techniques will ensure that your code scales effectively as your projects grow in complexity.\n\nJavaScript events are the foundation of creating dynamic and responsive web applications. By mastering event handling, you’ll be able to create interactive user experiences, improve your code efficiency, and ensure scalability in your projects. From understanding event propagation to utilizing event delegation, applying best practices will elevate your development skills.\n\nTo further expand your knowledge on JavaScript events and front-end development, here are some excellent resources:\n• Udemy Web Development Bootcamp: A full-stack course that covers everything from JavaScript to building complete web applications.\n\nWith these tools, you’ll be well-equipped to build robust, interactive web applications. Keep exploring and experimenting with event handling, and you’ll find countless ways to enhance your projects."
    },
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/API/Document/scroll_event",
        "document": "Since events can fire at a high rate, the event handler shouldn't execute computationally expensive operations such as DOM modifications. Instead, it is recommended to throttle the event using , , or a , as follows.\n\nNote, however, that input events and animation frames are fired at about the same rate, and therefore the optimization below is often unnecessary. This example optimizes the event for ."
    },
    {
        "link": "https://wesbos.com/javascript/06-serious-practice-exercises/scroll-events-and-intersection-observer",
        "document": "In this video we will learn about scroll events.\n\nA scroll event is when someone goes ahead and scrolls on the page or the inside of an element.\n\nOne thing you are likely to encounter in your career as a developer is building a terms and conditions scroll to accept.\n\nThat is where the user is forced to scroll all the way to the bottom of the text before the accept button will work.\n\nFirst we are just going to dive into scroll events, and then Wes will show us why a scroll event is maybe not what you want, and there is this newer thing in the browser called intersection observer which actually might be what we want.\n\nIn the directory, find the folder and open up the HTML page.\n\nYou should see \"IT WORKS\" in the browser.\n\nIn the example shown in the gif above, you can see it's not a window or document scroll.\n\nIf you want to listen for a window scroll event you just listen for .\n\nIf it's the case of another element that has an overflow scroll set on it, like Wess has done in the following style that is on the 👇\n\nSelect that element and listen for a scroll on it by selecting the class\n\nAdd an event listener to terms on the scroll event and just log the event with the handler. 👇\n\nIf you refresh the page, you will see the following error in your console\n\nThis is a problem you will run into often. What it means is that the selector is null.\n\nGo ahead and log to see whether anything is returned for our selector.\n\nAs you can see, it did not find anything. When that is the case, your selector is probably wrong.\n\nAnother issue you might run into is that it's pretty common to have some JavaScript that only runs on specific pages.\n\nIf you were to run this code on your homepage for example, it will break.\n\nWhat do you do about that?\n\nWes deals with that scenario like this: he creates a function like and he puts all of his code inside of that function.\n\nThen within that function, after he grabs the selector, he will check if that element exists using a bang, and if it doesn't, he will return so the function exits.\n\nWhat that will do is check whether something is found by the , and if it is, the rest of the code will run as expected and if not, you return from the function which will stop it from running and then it will never run.\n\nIf you try screwing up your query selector now, you won't get an error because the function will exit instead of running the code.\n\nOpen up the scroll event that you are logging in the console.\n\nThe is at this point but if you were to log it, you would see it.\n\nPreviously, to figure out if an element has scrolled all the way to the bottom, we used or .\n\nEither of them work in this case because a scroll event does not bubble like a regular click would. So if you scroll on the terms and conditions element, you are not unintentionally scrolling anything else.\n\nUse , then you can take the value which is a property on elements that will tell you how far you have scrolled from the top.\n\nHow do you know if you are scrolled to the bottom? How would you know that 1,828 pixels is the bottom for example?\n\nYou need to also grab the to figure that out.\n\nThe scroll height will tell you how high the scrolling thing is.\n\nNow when you log that, you will see how far from the top you are scrolled and the second number is how high the actual scroll-able div is.\n\nWhen you reach the very end, you should see the values are close.\n\nThey are not perfectly close and that is because the elements have different CSS styles, one of them has margins and padding.\n\nThat becomes a pain to work with because you have to work with offset heights and that is a thing of the past.\n\nYou do not need to do it that way anymore.\n\nThe way to do it now is called Intersection Observer. Rather than figuring out how far along the page the user has scrolled, you can use intersection observer to figure out if something is currently viewable on the page.\n\nYou can do that with the div but first let's go over a simple example first to demonstrate how that works.\n\nInside of the HTML, between one of the paragraphs, Wes will add a strong tag with a class of\n\nWe want to know when that strong tag is visible on the page.\n\nGrab the watch element at the top of the file.\n\nNext we need to create this thing called an Intersection Observer. An intersection observer will watch if an element is on or off or partway on or off the page.\n\nDo not worry about the keyword for now, we will talk about it in future lessons.\n\nThe intersection observer is going to take a callback, which is a function that gets called at a certain point.\n\nIt is different than a click callback or a scroll callback because this callback will be fired every single time that it needs to check if something is running on the page.\n\nNow that is not going to do anything if you refresh the page yet because the intersection observer is just a watcher and we haven't told it to watch any elements yet. It works a bit differently than our click handlers.\n\nLet's get rid of the scroll event listener that you have on this page as well.\n\nTake the observer and call the method on it, and then you pass it something to watch for, such as the strong tag.\n\nNow, every time we go ahead and scroll, you will notice that you get this IntersectionObserver entity logged.\n\nAs you can see, it is full of information about all of the items that have come our way.\n\nYou will notice that after a bit of time when you scroll, it doesn't fire every time, it only fires when there is new information to be given to us.\n\nRight on page load, it tells us that the strong tag is off the page. But then as soon as you start to see it, even when it's just peeking out, the intersection observer entry is logged.\n\nIf you take a look at what is in there, you will see some interesting things like the time that has passed from when you started observing it. That can be handy for games.\n\nThere is also the boolean which will tell you if it is on the page or off.\n\nThere is other information about the size of the element and what size it is on the page.\n\nThat is helpful information in helping us determine whether that thing is on the page or not.\n\nTake that strong tag which is the first thing in the because you can watch for multiple items. 👇\n\nNow if you refresh the page and scroll the strong tag into view, you will see that an IntersectionObserverEntry is logged.\n\nOn that object there is a property , which is a boolean.\n\nAs you can see it tells us when it is on or off the page.\n\nWhat is cool about that is it will also tell us how much on the page it currently is by looking at the property.\n\nAs you can see, the properties value changes based on what percentage of the element that is being watched is visible on the page.\n\n0 means not visible at all and 1 is visible. When it's partially visible it's 0.068402.\n\nYou can make use of that ratio to tell you if you have scrolled all the way to the bottom of the terms.\n\nHow will you know if you scrolled to the bottom?\n\nTake the terms and conditions and try to find out what the last thing inside of that is, because you want to wait for that element to be 100% on the screen before enabling the button.\n\nThat is how you will know if the user has scrolled to the bottom.\n\nStop watching for the strong tag, and instead watch the last paragraph on the like so\n\nNow you are observing the last paragraph in the terms div.\n\nIf you refresh the page and scroll to the bottom of the page with the console open, you should see something like the following 👇\n\nHow do you get it to tell us when it is 100% on the page?\n\nYou can pass a second argument to our , which can be an objects and you need to tell it 2 things.\n• that the root of the thing you are scrolling with is the terms and conditions (by default it will be the )\n• the threshold, which you can either give an array like which would then tell you when its off, halfway on and the on, or you can say only tell me when it is fully on the page, like so 👇\n\nIf you refresh and open the console, you will see 0 which tells us it is off the page and if you scroll to the bottom... uh-oh, we have an issue here.\n\nEven when we scroll to the very bottom it's not firing.\n\nIf you change the threshold to something like 0.11497, it will fire.\n\nWhat is happening here is if you give it a threshold of 1, but we are so cramped on the screen because Wes has to fit the browser and editor into one video, what is happening is the paragraph is so tall it's never 100% on the page because by the time you get to the bottom, part of it is already being hidden.\n\nA way to solve that is by putting another element at the bottom of the page like an or an . Anything that will be small enough to fit even on the smallest scrolling viewport.\n\nSet the threshold to 1 and within the , instead of logging the ratio, add an if statement that checks whether the intersectionRatio is 1.\n\nAt the top of the file and select the button 👇\n\nNow within that if statement, you can remove the disabled attribute from the button.\n\nThe CSS for the disabled attribute on the button gives it an opacity of 0.1.\n\nYou don't have to do anything with pointer events here because HTML will prevent the button from being clickable due to the disabled attribute.\n\nWes has also put a transition on the button of two seconds so it fades in once you hit it.\n\nAdd a log after you disable the button, like so 👇\n\nNow if you scroll to the bottom, you will see it runs.\n\nBut if you scroll back up and down a couple of times it keeps getting triggered.\n\nThat is good for some use cases.\n\nLet's demonstrate by modifying the CSS like so 👇\n\nAdd an if statement to disable the button when it's not fully scrolled.\n\nThat might be what you want.\n\nBut in our case once it is accepted, we don't care so we will stop observing the button.\n\nThat will stop it from doing any unnecessary work.\n\nThat is scroll to accept.\n\nYou don't see the observer pattern too much.\n\nThe only 2 ways currently in the browser is which tells you when something is currently scrolled into view, and another one called which will tell you when an element is resized."
    },
    {
        "link": "https://stackoverflow.com/questions/45304710/best-practice-for-event-handling-with-javascript",
        "document": "What's the best practice for an event handler? I'm unsure if I should put the buttons with the function to trigger or if I should, like jQuery, wait for the button's on click event.\n\nUsually you can do this:\n\nOr just add on the button the"
    }
]