[
    {
        "link": "https://geeksforgeeks.org/program-for-least-recently-used-lru-page-replacement-algorithm",
        "document": "Prerequisite: Page Replacement Algorithms\n\nIn operating systems that use paging for memory management, page replacement algorithm are needed to decide which page needed to be replaced when new page comes in. Whenever a new page is referred and not present in memory, page fault occurs and Operating System replaces one of the existing pages with newly needed page. Different page replacement algorithms suggest different ways to decide which page to replace. The target for all algorithms is to reduce number of page faults.\n\nIn Least Recently Used (LRU) algorithm is a Greedy algorithm where the page to be replaced is least recently used. The idea is based on locality of reference, the least recently used page is not likely \n\nLet say the page reference string 7 0 1 2 0 3 0 4 2 3 0 3 2 . Initially we have 4 page slots empty. \n\nInitially all slots are empty, so when 7 0 1 2 are allocated to the empty slots —> 4 Page faults \n\n0 is already there so —> 0 Page fault. \n\nwhen 3 came it will take the place of 7 because it is least recently used —>1 Page fault \n\n0 is already in memory so —> 0 Page fault. \n\n4 will takes place of 1 —> 1 Page Fault \n\nNow for the further page reference string —> 0 Page fault because they are already available in the memory.\n\n\n\nGiven memory capacity (as number of pages it can hold) and a string representing pages to be referred, write a function to find number of page faults.\n\n\n\nBelow is implementation of above steps.\n• Time Complexity : average time complexity of set and map operations is O(1) and the worst-case time complexity is O(n) but O(n) is the dominant term.\n• Space Complexity : O(capacity) which is a constant and depends on the size of the input array and the size of the memory buffer.\n\nAnother approach: (Without using HashMap)\n\nFollowing are the steps to solve this problem :\n• Using a deque data structure, the program implements the page replacement algorithm.\n• A predetermined number of pages are kept in memory by the algorithm, and they are replaced as new pages are requested.\n• Using an integer array to stimulate page requests, the code keeps track the number of page faults that occur throughout the simulation.\n• The deque data structure, which is built using STL in C++, is used to maintain the pages in memory.\n• The total number of page faults that occurred throughout the simulation is given as output by the code.\n\n\n\nBelow is the implementation of the above approach :\n• Time Complexity : O(n), as it performs a constant amount of work for each page request.\n• Space Complexity : O(n+4), where n is the size of the input array and 4 is the size of the memory buffer.\n\nNote : We can also find the number of page hits. Just have to maintain a separate count. \n\nIf the current page is already in the memory then that must be count as Page-hit.\n\nWe will discuss other Page-replacement Algorithms in further sets."
    },
    {
        "link": "https://geeksforgeeks.org/page-replacement-algorithms-in-operating-systems",
        "document": "In an operating system that uses paging for memory management, a page replacement algorithm is needed to decide which page needs to be replaced when a new page comes in. Page replacement becomes necessary when a page fault occurs and no free page frames are in memory. in this article, we will discuss different types of page replacement algorithms.\n\nPage replacement algorithms are techniques used in operating systems to manage memory efficiently when the physical memory is full. When a new page needs to be loaded into physical memory, and there is no free space, these algorithms determine which existing page to replace.\n\nIf no page frame is free, the virtual memory manager performs a page replacement operation to replace one of the pages existing in memory with the page whose reference caused the page fault. It is performed as follows: The virtual memory manager uses a page replacement algorithm to select one of the pages currently in memory for replacement, accesses the page table entry of the selected page to mark it as “not present” in memory, and initiates a page-out operation for it if the modified bit of its page table entry indicates that it is a dirty page.\n• None First In First Out (FIFO)\n\nFirst In First Out (FIFO)\n\nThis is the simplest page replacement algorithm. In this algorithm, the operating system keeps track of all pages in the memory in a queue, the oldest page is in the front of the queue. When a page needs to be replaced page in the front of the queue is selected for removal.\n\nExample 1: Consider page reference string 1, 3, 0, 3, 5, 6, 3 with 3-page frames. Find the number of page faults using FIFO Page Replacement Algorithm.\n\nIn this algorithm, pages are replaced which would not be used for the longest duration of time in the future.\n\nExample: Consider the page references 7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 3 with 4-page frame. Find number of page fault using Optimal Page Replacement Algorithm.\n\nNow for the further page reference string —> 0 Page fault because they are already available in the memory. Optimal page replacement is perfect, but not possible in practice as the operating system cannot know future requests. The use of Optimal Page replacement is to set up a benchmark so that other replacement algorithms can be analyzed against it.\n\nIn this algorithm, page will be replaced which is least recently used.\n\nExample Consider the page reference string 7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 3 with 4-page frames. Find number of page faults using LRU Page Replacement Algorithm.\n• None Program for Least Recently Used (LRU) Page Replacement algorithm\n\nIn this algorithm, page will be replaced which has been used recently. Belady’s anomaly can occur in this algorithm.\n\nExample 4: Consider the page reference string 7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 3 with 4-page frames. Find number of page faults using MRU Page Replacement Algorithm.\n\nInitially, all slots are empty, so when 7 0 1 2 are allocated to the empty slots —> 4 Page faults 0 is already their so–> 0 page fault when 3 comes it will take place of 0 because it is most recently used —> 1 Page fault when 0 comes it will take place of 3 —> 1 Page fault when 4 comes it will take place of 0 —> 1 Page fault 2 is already in memory so —> 0 Page fault when 3 comes it will take place of 2 —> 1 Page fault when 0 comes it will take place of 3 —> 1 Page fault when 3 comes it will take place of 0 —> 1 Page fault when 2 comes it will take place of 3 —> 1 Page fault when 3 comes it will take place of 2 —> 1 Page fault\n\nIn summary, page replacement algorithms are essential for managing a computer’s memory efficiently. They help ensure that the system runs smoothly by reducing the number of times it needs to fetch data from slower storage. Different algorithms, like FIFO and LRU, have their own pros and cons, and choosing the right one depends on the specific needs of the system. Understanding these algorithms can help improve system performance and make our computers faster and more efficient.\n\nPracticing the following questions will help you test your knowledge. All questions have been asked in GATE in previous years or in GATE Mock Tests. It is highly recommended that you practice them."
    },
    {
        "link": "https://japp.io/algorithms/page-replacement/lru-page-replacement-algorithm-program-in-c-c",
        "document": "In a computer operating system that uses paging for virtual memory management, page replacement algorithms decide which memory pages to page out, sometimes called swap out, or write to disk when a page of memory needs to be allocated. Page replacement happens when a requested page is not in memory (page fault) and a free page cannot be used to satisfy the allocation, either because there are none, or because the number of free pages is lower than some threshold.\n\nIn this post, we will discuss the Least Recently Used (LRU) Page Replacement Algorithm and also write a program for the Least Recently Used (LRU) Page Replacement algorithm. In this algorithm, the operating system keeps track of all pages in the memory in a queue, the oldest page is in the front of the queue. When a page needs to be replaced, the page which is least recently used is replaced by the incoming page.\n\nWe will use C++ to write this algorithm due to the standard template library support. Hence, we will write the program of LRU Page Replacement Algorithm in C++, although, it’s very similar to C.\n\nINPUT:\n\nThe first line is the number of frames(n).\n\nThe second line is the number of processes (m).\n\nThe third line is an array of processes (p[m]).\n\nOUTPUT:\n\nPrint the matrix for processes and frames.\n\nAlso, print the hit and page fault.\n\nThe following is the LRU page replacement program in C++.\n\nLet us know in the comments if you are having any questions regarding this LRU page replacement Algorithm.\n\nAnd if you found this post helpful, then please help us by sharing this post with your friends. Thank You"
    },
    {
        "link": "https://prepinsta.com/operating-systems/page-replacement-algorithms/least-recently-used-lru-algorithm/lru-page-replacement-algorithm-in-c",
        "document": "In this algorithm, we replace the element which is the current least recently used element in the current stack.\n\nThat is, when we look to the left of the table, that we have created we choose the further most page to get replaced."
    },
    {
        "link": "https://cs.unc.edu/~porter/courses/cse306/s15/slides/16.PageReplacementAlgos.pdf",
        "document": ""
    },
    {
        "link": "https://stackoverflow.com/questions/15961582/calculating-number-of-page-faults-for-2-d-array",
        "document": "Suppose your systems allocated Two Frames for your process such that of matrix can be keep in memory at a time. And allocation for matrix happens in Row Major Order.\n\nAt each iteration Row changes and allocation is in row major and each row takes one page. so code will causes page fault for each alternative access so total number of page faults are = 100 * 100 / 2) = 5000.\n\nWhere as second code :\n\nloop access memory cells for matrix row-wise on each iteration, like:\n\nAccess row wise (columns changes at read read row changes only after 100 read), One row loaded at time so page fault happens when row changes (for outer loop) and for each alternative row access a page fault happens so number of page faults = 100/2 = 50.\n\nwe can understand it another ways like:\n\n In row major, Number of times row index changes we need new page to access because number of pages are small it page fault on each alternative index change in first A loop row index changes 100*100 times where as in B loop row index changes 100 times so page fault ration in both A/B = 100*100/100 = 100, and if number of page faults happens in A = 50,00 then in B number of page faults = 50,00/100 = 50.\n\nSimilarly you can calculate number of page-faults for Column-major order and because matrix has equal numbers of rows and cols result will be same.\n\nThe similar example is given in my book:\n\n Download a pdf: operating system book Galvin Read chapter 9: Virtual Memory Section: 9.9.5 Program Structure."
    },
    {
        "link": "https://stackoverflow.com/questions/3721086/page-fault-count-within-two-arrays",
        "document": "where A[0][0] is at location 500 in a paged memory system with pages of size 500 (a little unrealistic -- not 512). A small process that manipulates the matrix resides in page 0 (locations 0 to 499). Thus, every instruction fetch will be from an instruction currently stored in page 0.\n\nAssuming there are only five page frames, including page 0, how many page faults are generated by the following array-initialization loops, using LRU replacement and assuming that page frame 0 contains the process and the other four are initially empty?\n\nWhere do I begin to figure this out? I have went through my text but haven't found much of it to be useful. I threw some numbers around and I found:\n\nA) 20,000 (80*250) because every other loop causes a page fault?\n\nB) 80 (One for each page, 40,000/500 = 80)?\n\nAm I on the right track? Any advice? Hints?"
    },
    {
        "link": "https://geeksforgeeks.org/memory-layout-of-c-program",
        "document": "The memory layout of a program refers to how the program’s data is stored in the computer memory during its execution. Understanding this layout helps developers manage memory more efficiently and avoid issues such as segmentation faults and memory leaks.\n\nA C program’s memory is organized into specific regions (segments) as shown in the below image, each serving distinct purposes for program execution.\n\nThe text segment (also known as code segment) is where the executable code of the program is stored. It contains the compiled machine code of the program’s functions and instructions. This segment is usually read-only and stored in the lower parts of the memory to prevent accidental modification of the code while the program is running.\n\nThe size of the text segment is determined by the number of instructions and the complexity of the program.\n\nThe data segment stores global and static variables that are created by the programmer. It is present just above the code segment of the program. It can be further divided into two parts:\n\nAs the name suggests, it is the part of the data segment that contains global and static variables that have been initialized by the programmer. For example,\n\nThe above variables a and b will be stored in the Initialized Data Segment.\n\nUninitialized data segment often called the “bss” segment, named after an ancient assembler operator, that stood for “Block Started by Symbol” contains global and static variables that are not initialized by the programmer. These variables are automatically initialized to zero at runtime by the operating system. For example, the below shown variables will be stored in this segment:\n\nHeap segment is where dynamic memory allocation usually takes place. The heap area begins at the end of the BSS segment and grows towards the larger addresses from there. It is managed by functions such as malloc(), realloc(), and free() which in turn may use the brk and sbrk system calls to adjust its size.\n\nThe heap segment is shared by all shared libraries and dynamically loaded modules in a process. For example, the variable pointed by ptr will be stored in the heap segment:\n\nThe stack is a region of memory used for local variables and function call management. Each time a function is called, a stack frame is created to store local variables, function parameters, and return addresses. This stack frame is stored in this segment.\n\nThe stack segment is generally located in the higher addresses of the memory and grows opposite to heap. They adjoin each other so when stack and heap pointer meet, free memory of the program is said to be exhausted.\n\nExample of data stored in stack segment:\n\nThe size(1) command in MinGW reports the sizes (in bytes) of the text, data, and bss segments of a binary file.\n\n1. Check the following simple C program\n\n2. Let us add one global variable in the program, now check the size of bss\n\n3. Let us add one static variable which is also stored in bss.\n\n4. Let us initialize the static variable which will then be stored in the Data Segment (DS)\n\n5. Let us initialize the global variable which will then be stored in the Data Segment (DS)\n\nExample to Verify the Memory Layout\n\nComparing above addresses, we can see than it roughly matches the memory layout discussed above."
    },
    {
        "link": "https://quora.com/How-do-we-calculate-a-2D-array-address",
        "document": "Something went wrong. Wait a moment and try again."
    },
    {
        "link": "https://geeksforgeeks.org/cpp-multidimensional-array",
        "document": "A multidimensional array is an array with more than one dimension. It means that it can grow in different directions i.e. instead of changing the length only, it can also change in width, depth or more. It is the homogeneous collection of items where each element is accessed using multiple indices.\n\nwhere s1, s2,…, sn is the size of each dimension.\n\nFor 1D array, the length of the array is simply its size too. But multidimensional arrays have extra dimensions. So, the size of each dimension is considered separately. The number of elements is the product of all its dimensions’ size. It is similar to calculating area in 2D and volume in 3D.\n\nFor example, consider the below array:\n• None The size in bytes can be calculated by multiplying the number of elements by size of each element or we can just use sizeof operator.\n• None In this case, size in bytes = 4*8 = 32 bytes\n\nTo verify the above calculation, we can use sizeof() method to find the size of an array.\n\nWe can have any number of dimensions in an array as per requirement, but the complexity of handling them also increases exponentially. That is why, the most widely used multidimensional arrays are:\n\nA two-dimensional array in C++ is a collection of elements organized the form of rows and columns. It can be visualized as a table or a grid, where each element is accessed using two indices: one for the row and one for the column. Like a one-dimensional array, two-dimensional array indices also range from 0 to n-1 for both rows and columns.\n\nLike 1D arrays, 2D arrays can also be initialized using a list of values enclosed inside {} curly brackets, but as 2D arrays have two dimensions, the list is nested inside another list to initialize each dimension one by one. It means that each row values are nested inside one big list.\n\nNesting can also be omitted, and values will still be assigned sequentially.\n\nThe above array has 2 rows and 4 columns. The elements are filled in a way that the first 4 elements are filled in the first row and the next 4 elements are filled in the second row. The values will be initialized sequentially.\n\nIt is to be noted that the number of values should not exceed the total number of elements an array can store. It can have less values (partial initialization) but cannot have more values.\n\nIf all the elements are to be initialized to 0, then this syntax can be used:\n\nThis can be only done for 0, not for any other value.\n\nElements of a 2-dimensional array have to be accessed using row and column indices. It is similar to matrix element position, but the only difference is that here indexing starts from 0.\n\nwhere, i is the index of row and j is the index of the column. The range of indexes should be:\n\nAny values other than that leads to the segmentation fault.\n\nThe value at any index can be updated by using = assignment operator.\n\nThe new_value should be of same data type.\n\nTwo loops nested inside each other are needed to traverse a 2D array, one for moving though each dimension. First loop is used to move though the rows of 2D array, while other is used to move though columns in each row to access all the elements of the row.\n\nA three-dimensional array in C++ is a collection of elements organized in a 3D cuboid-like structure. It can be visualized as a series of two-dimensional arrays stacked on top of each other. Each element is accessed using three indices: one for the depth, one for the row, and one for the column.\n\nTo declare a 3D array in C++, we need to specify its third dimension along with 2D dimensions.\n\nwhere depth is the number of 2D arrays in it.\n\nLike 2D arrays, 3D arrays can also be initialized using a list of values enclosed inside {} curly brackets. However, in a 3D array, the values are grouped into 2D arrays, and each 2D array is nested inside another set of curly brackets.\n\nAlternatively, nesting can be omitted, and the values will still be filled sequentially:\n\nThis array has 2 layers (depth), 2 rows per layer, and 3 columns per row. The values are filled sequentially across the layers.\n\nIt is important to note that the number of values should not exceed the total number of elements the array can store. If fewer values are provided, the rest of the array is initialized to 0 (partial initialization).\n\nIf all the elements are to be initialized to 0, then this syntax can be used:\n\nThis can be only done for 0, not for any other value.\n\nThe elements of a 3D array are accessed using three indices: depth, row, and column. These indices must be within the following ranges:\n\nTo update a value at any index of a 3D array, use the assignment operator = while accessing the element:\n\nTo traverse a 3D array, you need three nested loops: one for each dimension (depth, row, column).\n\nIn C++, you can pass multidimensional arrays to functions. Since multidimensional arrays have more than one dimension, the function signature needs to account for all dimensions.\n\nTo pass a 2D array to a function, you can specify the number of columns (or other dimensions) in the function signature. The number of rows can be deduced automatically.\n\nTo pass a 3D array to a function, you need to specify the size of the second and third dimensions."
    }
]