[
    {
        "link": "https://docs.unity3d.com/6000.0/Documentation/Manual/execution-order.html",
        "document": "Event functions are a set of built-in events that your MonoBehaviour scriptsA piece of code that allows you to create your own Components, trigger game events, modify Component properties over time and respond to user input in any way you like. More info\n\nSee in Glossary can optionally subscribe to by implementing the appropriate methods, often referred to as callbacks. The callbacks correspond to events in core Unity subsystems like physics, rendering, and user input, or to stages of the script’s own lifecycle such as its creation, activation, frame-dependent and frame-independent updates, and destruction. When the event occurs, Unity invokes the associated callback on your script, giving you the opportunity to implement logic in response to the event.\n\nTo the extent that Unity raises these events and calls the associated MonoBehaviour callbacks in a predetermined order, the order is documented here. It’s important to understand the execution order so you don’t try to use one callback to do work which depends on another callback that hasn’t been invoked yet. However, bear in mind that some callbacks are for events, such as those triggered by user inputs, which can occur at any time while your game is running. You should consult this page in combination with the MonoBehaviour script reference (where the event callbacks are listed under Messages) for a complete understanding of each event’s meaning and limitations.\n\nThe diagram below summarizes how Unity orders and repeats event functions over a script’s lifetime.\n\nFor more information about the various event functions, see the following sections:\n• Before the first frame update\n• When the object is destroyed\n\nThe scope of the flowchart below is limited to the built-in event functions that you can subscribe to on any MonoBehaviour script by implementing the appropriate callbacks documented under Messages in the MonoBehaviour scripting reference. Some additional internal methods local to the subsystems that raise the events are also shown for context.\n\nIn addition to these built-in event functions there are a number of other events you can potentially subscribe to in your scripts. Several major classes such as Application, SceneManager, and CameraA component which creates an image of a particular viewpoint in your scene. The output is either drawn to the screen or captured as a texture. More info\n\nSee in Glossary offer delegates that you can register your own callback methods with. Method attributes like RuntimeInitializeOnLoadMethodAttribute can also be used to execute methods at certain stages of the sceneA Scene contains the environments and menus of your game. Think of each unique Scene file as a unique level. In each Scene, you place your environments, obstacles, and decorations, essentially designing and building your game in pieces. More info\n\nSee in Glossary. Refer to the scripting reference for the component or subsystem you’re interested in to see what event callbacks you can subscribe to and details of their execution order.\n\nNote: Some browsers do not support SVG image files. If the image above does not display properly (for example, if you cannot see any text), please try another browser, such as Google Chrome or Mozilla Firefox.\n\nIn general, you should not rely on the order in which the same event function is invoked for different GameObjectsThe fundamental object in Unity scenes, which can represent characters, props, scenery, cameras, waypoints, and more. A GameObject’s functionality is defined by the Components attached to it. More info\n\nSee in Glossary — except when the order is explicitly documented or settable. If you need a more fine-grained control of the player loop, you can use the PlayerLoop API.\n\n You cannot specify the order in which an event function is called for different instances of the same MonoBehaviour subclass. For example, the function of one MonoBehaviour might be called before or after the function for the same MonoBehaviour on another GameObject — including its own parent or child GameObjects.\n\nYou can specify that the event functions of one MonoBehaviour subclass should be invoked before those of a different subclass using the Script Execution Order panel of the Project SettingsA broad collection of settings which allow you to configure how Physics, Audio, Networking, Graphics, Input and many other areas of your project behave. More info\n\nSee in Glossary window. For example, if you had two scripts, EngineBehaviour and SteeringBehaviour, you could set the Script Execution Order such that EngineBehaviours always update before SteeringBehaviours. If loading multiple scenes additively, the configured script execution order is applied in full one scene at a time, rather than partially across scenes, so EngineBehaviours and SteeringBehaviours would both update on one scene before they updated on the next one.\n\nThese functions get called when a scene starts (once for each object in the scene).\n• : First lifecycle function called when a new instance of an object is created. Always called before any functions. If a GameObject is inactive during start up, is not called until it is made active.\n• : Called when the object becomes enabled and active, always after (on the same object) and before any .\n\nFor objects that are part of a scene asset, and functions for all scripts are called before and subsequent functions are called for any of them. However, this can’t be enforced when you instantiate an object at runtime.\n\nis only guaranteed to be called before in the scope of each individual object. Across multiple objects the order is not deterministic and you can’t rely on one object’s being called before another object’s . Any work that depends on having been called for all objects in the scene should be done in .\n\nNot shown in the diagram above are the SceneManager.sceneLoaded and SceneManager.sceneUnloaded events which allow you to receive callbacks when a scene has loaded and unloaded respectively. Refer to the relevant scripting reference pages for details and example usage. You can expect to receive the notification after but before for all objects in the scene. Refer to Details of disabling Domain and Scene reload for a diagram that includes scene load as part of the execution flow.\n\nYou can also use the RuntimeInitializeOnLoadMethodAttribute and its types BeforeSceneLoad and AfterSceneLoad to make your methods run before or after scene load respectively. Refer to the RuntimeInitializeOnLoadMethodAttribute scripting reference main page for execution order information for methods marked with these types.\n• : called to initialize the script’s properties when it is first attached to an object and also when the Reset command is used.\n• : called whenever the script’s properties are set, including when an object is deserialized, which can occur at various times, such as when you open a scene in the Editor and after a domain reload.\n\nBefore the first frame update\n• : called before the first frame update only if the script instance is enabled.\n\nFor objects that are part of a scene asset, the function is called on all scripts before is called for any of them. However, this cannot be enforced when you instantiate an object during gameplay. For example, if you instantiate an object from another object’s function, the instantiated object’s can’t be called until runs for the first time on the original object.\n• : This is called at the end of the frame where the pause is detected, effectively between the normal frame updates. One extra frame will be issued after is called to allow the game to show graphics that indicate the paused state.\n\nWhen you’re keeping track of game logic and interactions, animations, camera positions, etc., there are a few different events you can use. The common pattern is to perform most tasks inside the function, but there are also other functions you can use.\n• None happens at fixed intervals of in-game time rather than per frame. Since these updates are fixed and frame rate is variable, there may be no fixed update during a frame when frame rate is high, or multiple fixed updates per frame when frame rate is low. All physics calculations and updates occur immediately after and because it’s frame-rate independent you don’t need to multiply values by Time.deltaTime when calculating movement in a . The interval at which fixed updates happen is defined by Time.fixedDeltaTime, which can be set directly in scripts or via the Fixed TimestepA customizable frame-rate-independent interval that dictates when physics calculations and FixedUpdate() events are performed. More info\n\nSee in Glossary property in the Editor’s Time settings. For more information, including the time calculations used to determine whether to perform an or a , refer to Time.\n• None is called once per frame and is the main function for frame updates.\n• None is called once per frame, after has finished. Any calculations performed in will have completed when begins. A common use for would be a following third-person camera. If you make your character move and turn inside , you can perform all camera movement and rotation calculations in . This will ensure that the character has moved completely before the camera tracks its position.\n\nThe following Animation loop callbacks shown in the flowchart above are called on scripts that derive from MonoBehaviour:\n\nAdditional animation-related event functions are called on scripts that derive from StateMachineBehaviour:\n\nFor the meaning and limitations of these callbacks, refer to the relevant scripting reference pages.\n\nOther animation functions shown in the flowchart are internal to the animation system and are provided for context. These functions have associated Profiler markers so you can use the ProfilerA window that helps you to optimize your game. It shows how much time is spent in the various areas of your game. For example, it can report the percentage of time spent rendering, animating, or in your game logic. More info\n\nSee in Glossary to see when in the frame Unity calls them. Knowing when Unity calls these functions can help you understand exactly when the Event functions you do call are executed. For a full execution order of animation functions and profiler markers, refer to Profiler markersPlaced in code to describe a CPU or GPU event that is then displayed in the Unity Profiler window. Added to Unity code by default, or you can use ProfilerMarker API to add your own custom markers. More info\n\nSee in Glossary.\n\nThis execution order applies for the Built-in Render Pipeline only. For details of execution order in render pipelinesA series of operations that take the contents of a Scene, and displays them on a screen. Unity lets you choose from pre-built render pipelines, or write your own. More info\n\nSee in Glossary based on the Scriptable Render Pipeline, refer to the relevant sections of the documentation for the Universal Render Pipeline or the High Definition Render Pipeline. If you want to do work immediately prior to rendering, refer to Application.onBeforeRender.\n• : Called before the camera culls the scene. Culling determines which objects are visible to the camera. is called just before culling takes place.\n• / : Called when an object becomes visible/invisible to any camera. is not shown in the flow chart above since an object may become invisible at any time.\n• : Called once for each camera if the object is visible.\n• : Called before the camera starts rendering the scene.\n• : Called after all regular scene rendering is done. You can use GL class or Graphics.DrawMeshNow to draw custom geometry at this point.\n• : Called after scene rendering is complete to allow post-processing \n\n A process that improves product visuals by applying filters and effects before the image appears on screen. You can use post-processing effects to simulate physical camera and film properties, for example Bloom and Depth of Field. More info of the image, see Post-processing Effects.\n• : Called multiple times per frame in response to GUI events. The Layout and Repaint events are processed first, followed by a Layout and keyboard/mouse event for each input event.\n• Used for drawing Gizmos \n\n A graphic overlay associated with a GameObject in a Scene, and displayed in the Scene View. Built-in scene tools such as the move tool are Gizmos, and you can create custom Gizmos using textures or scripting. Some Gizmos are only drawn when the GameObject is selected, while other Gizmos are drawn by the Editor regardless of which GameObjects are selected. More info in the scene view \n\n An interactive view into the world you are creating. You use the Scene View to select and position scenery, characters, cameras, lights, and all other types of Game Object. More info for visualisation purposes.\n\nNote: OnPreCull, OnPreRender, OnPostRender, and OnRenderImage are built-in Unity event functions that are called on MonoBehaviour scripts but only if those scripts are attached to the same object as an enabled Camera component. If you want to receive the equivalent callbacks for , , and on a MonoBehaviour attached to a different object, you must use the equivalent delegates (note the lowercase in the names) Camera.onPreCull, Camera.onPreRender, and Camera.onPostRender as shown in the code examples in the relevant pages of the scripting reference.\n\nNormal coroutine updates are run after the function returns. A coroutine is a function that can suspend its execution ( ) until the given YieldInstruction finishes.\n\nDifferent uses of coroutines:\n• The coroutine will continue after all functions have been called on the next frame.\n• Continue after a specified time delay, after all functions have been called for the frame.\n• Continue after all has been called on all scripts. If the coroutine yielded before , then it resumes after in the current frame.\n• Chains the coroutine so that if a theoretical coroutine starts another with then pauses and waits for to finish before continuing. For an example, refer to MonoBehaviour.StartCoroutine.\n\nWhen the Object is destroyed\n• : This function is called after all frame updates for the last frame of the object’s existence (the object might be destroyed in response to Object.Destroy or at the closure of a scene).\n\nThese functions get called on all the active objects in your scene:\n• : This function is called on all game objects before the application is quit. In the editor it is called when the user stops playmode.\n• : This function is called when the behaviour becomes disabled or inactive."
    },
    {
        "link": "https://discussions.unity.com/t/general-performance-optimization-tips-for-unity/616926",
        "document": ""
    },
    {
        "link": "https://docs.unity3d.com/6000.0/Documentation/Manual/best-practice-guides.html",
        "document": "Use this page to discover and learn production-tested best practices from Unity experts. The Technical Content Marketing team at Unity created the guides listed on this page together with industry experts, and engineers and technical artists from Unity R&D and the Accelerate Games Solutions teams.\n\nBest practices for project organization and version control This guide explains the key concepts of version controlA system for managing file changes. You can use Unity in conjunction with most common version control tools, including Perforce, Git, Mercurial and PlasticSCM. More info\n\nSee in Glossary, compares some of the different version control systems available, and provides an introduction to additional Unity DevOps tools like Unity Asset Manager and Build AutomationA continuous integration service for Unity projects that automates the process of creating builds on Unity’s servers. More info\n\nSee in Glossary."
    },
    {
        "link": "https://unity.com/how-to/best-practices-for-profiling-game-performance",
        "document": ""
    },
    {
        "link": "https://unity.com/how-to/advanced-programming-and-code-architecture",
        "document": ""
    },
    {
        "link": "https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/member-access-operators",
        "document": "Member access operators and expressions - the dot, indexer, and invocation operators.\n\nYou use several operators and expressions to access a type member. These operators include member access ( ), array element or indexer access ( ), index-from-end ( ), range ( ), null-conditional operators ( and ), and method invocation ( ). These include the null-conditional member access ( ), and indexer access ( ) operators.\n• (member access): to access a member of a namespace or a type\n• (array element or indexer access): to access an array element or a type indexer\n• and (null-conditional operators): to perform a member or element access operation only if an operand is non-null\n• (invocation): to call an accessed method or invoke a delegate\n• (index from end): to indicate that the element position is from the end of a sequence\n• (range): to specify a range of indices that you can use to obtain a range of sequence elements\n\nYou use the token to access a member of a namespace or a type, as the following examples demonstrate:\n• Use to access a nested namespace within a namespace, as the following example of a directive shows:\n• Use to form a qualified name to access a type within a namespace, as the following code shows:\n\nUse a directive to make the use of qualified names optional.\n• Use to access type members, static and nonstatic, as the following code shows:\n\nYou can also use to access an extension method.\n\nSquare brackets, , are typically used for array, indexer, or pointer element access. Beginning with C# 12, encloses a collection expression.\n\nThe following example demonstrates how to access array elements:\n\nIf an array index is outside the bounds of the corresponding dimension of an array, an IndexOutOfRangeException is thrown.\n\nAs the preceding example shows, you also use square brackets when you declare an array type or instantiate an array instance.\n\nFor more information about arrays, see Arrays.\n\nThe following example uses the .NET Dictionary<TKey,TValue> type to demonstrate indexer access:\n\nIndexers allow you to index instances of a user-defined type in the similar way as array indexing. Unlike array indices, which must be integer, the indexer parameters can be declared to be of any type.\n\nFor more information about indexers, see Indexers.\n\nFor information about pointer element access, see the Pointer element access operator [] section of the Pointer related operators article. For information about collection expressions, see the collection expressions article.\n\nYou also use square brackets to specify attributes:\n\nAdditionally, square brackets can be used to designate list patterns for use in pattern matching or testing.\n\nA null-conditional operator applies a member access ( ) or element access ( ) operation to its operand only if that operand evaluates to non-null; otherwise, it returns . In other words:\n• None If evaluates to , the result of or is .\n• None If evaluates to non-null, the result of or is the same as the result of or , respectively. If or throws an exception, or would throw the same exception for non-null . For example, if is a non-null array instance and is outside the bounds of , would throw an IndexOutOfRangeException.\n\nThe null-conditional operators are short-circuiting. That is, if one operation in a chain of conditional member or element access operations returns , the rest of the chain doesn't execute. In the following example, isn't evaluated if evaluates to and isn't evaluated if or evaluates to :\n\nIf might be null but and wouldn't be null if A isn't null, you only need to apply the null-conditional operator to :\n\nIn the preceding example, isn't evaluated and isn't called if is null. However, if the chained member access is interrupted, for example by parentheses as in , short-circuiting doesn't happen.\n\nThe following examples demonstrate the usage of the and operators:\n\nThe first of the preceding two examples also uses the null-coalescing operator to specify an alternative expression to evaluate in case the result of a null-conditional operation is .\n\nIf or is of a non-nullable value type , or is of the corresponding nullable value type . If you need an expression of type , apply the null-coalescing operator to a null-conditional expression, as the following example shows:\n\nIn the preceding example, if you don't use the operator, evaluates to when is .\n\nThe null-conditional member access operator is also known as the Elvis operator.\n\nUse the operator to check if a delegate is non-null and invoke it in a thread-safe way (for example, when you raise an event), as the following code shows:\n\nThat code is equivalent to the following code:\n\nThe preceding example is a thread-safe way to ensure that only a non-null is invoked. Because delegate instances are immutable, no thread can change the object referenced by the local variable. In particular, if the code executed by another thread unsubscribes from the event and becomes before is invoked, the object referenced by remains unaffected.\n\nUse parentheses, , to call a method or invoke a delegate.\n\nThe following example demonstrates how to call a method, with or without arguments, and invoke a delegate:\n\nYou also use parentheses when you invoke a constructor with the operator.\n\nYou also use parentheses to adjust the order in which to evaluate operations in an expression. For more information, see C# operators.\n\nCast expressions, which perform explicit type conversions, also use parentheses.\n\nIndex and range operators can be used with a type that is countable. A countable type is a type that has an property named either or with an accessible accessor. Collection expressions also rely on countable types.\n\nThe operator indicates the element position from the end of a sequence. For a sequence of length , points to the element with offset from the start of a sequence. For example, points to the last element of a sequence and points to the first element of a sequence.\n\nAs the preceding example shows, expression is of the System.Index type. In expression , the result of must be implicitly convertible to .\n\nYou can also use the operator with the range operator to create a range of indices. For more information, see Indices and ranges.\n\nBeginning with C# 13, the Index from the end operator can be used in an object initializer.\n\nThe operator specifies the start and end of a range of indices as its operands. The left-hand operand is an inclusive start of a range. The right-hand operand is an exclusive end of a range. Either of the operands can be an index from the start or from the end of a sequence, as the following example shows:\n\nAs the preceding example shows, expression is of the System.Range type. In expression , the results of and must be implicitly convertible to Int32 or Index.\n\nYou can omit any of the operands of the operator to obtain an open-ended range:\n\nThe following table shows various ways to express collection ranges:\n\nThe following example demonstrates the effect of using all the ranges presented in the preceding table:\n\nFor more information, see Indices and ranges.\n\nThe token is also used for the spread element in a collection expression.\n\nThe , , , and operators can't be overloaded. The operator is also considered a non-overloadable operator. Use indexers to support indexing with user-defined types.\n\nFor more information, see the following sections of the C# language specification:\n\nFor more information about indices and ranges, see the feature proposal note."
    },
    {
        "link": "https://stackoverflow.com/questions/40992457/c-sharp-6-0-multiple-identical-null-conditional-operator-checks-vs-single-tradit",
        "document": "Short answer: Performance about null-checks will never be an issue in a normal application. It's only a matter of readability and maintainability.\n\nYes, you have 3 \"explicit\" checks against 1. But you must keep in mind that:\n• The system performs an \"implicit\" null-check every time you reference an object instance, as explained here, and afaik the JIT doesn't optimize null-checks at all. So in your case the rate is not just 3 against 1.\n• A null-check is a very (really, very) cheap operation, compared with most operations you do in a normal software flow (instance heap allocation, mathematic calculations, a linq query, graphic object rendering, string parsing, ...).\n\nI see only a remote possibility of significant performance differences: if or or are not local variables or simple plain properties, but methods and properties with very long execution time. For example, a method that takes 2 sec to execute. Can you see a realistic scenario for that? I can't. Even if that's the case, you can call one single time and assign it to a local variable, then call 3 times.\n\nA single initial allows to mentally separate different chunks of code. Pretend to be the reader of the code, without knowing anything else: ask yourself if is it simpler to read \"if child is not null do all this operations and stuffs, otherwise just move on\", or \"if child is not null check the Name. If again child is not null check the Mother. If the Mother is not null get the Mother's Name. Then if again child is not null check the Father. If Father is not null... ... ... \".\n\nAka, in this case, the DRY principle. For example, why would you repeat the null-check 3 times? Pretend that at a certain point in the future your boss asks to you a code change: it is required not only to check the nullity of a child, but also if its is 0 (things like that happen very frequently in any software development process). In your first code section you should correct 3 lines. In your second code section you should correct only 1 line: the initial .\n\nFor a discussion about thread-safety on the null conditional operator, see this question."
    },
    {
        "link": "https://unity3d.college/2017/08/16/unity3d-net-4-6-string-interpolation-and-null-conditional-operator",
        "document": ""
    },
    {
        "link": "https://embrace.io/blog/understanding-null-reference-exceptions-unity",
        "document": "Understanding null reference exceptions in Unity is essential for any successful Unity developer. Failure to comprehend this can result in poorly written code and a frequently crashing game. Crashes are not something you should risk in your game build, as they can lead to frustrated players, high user churn, and a subsequent loss of revenue. The proper knowledge of null in Unity can alleviate stress in the process of game development, free up more time for innovation, and produce a successful mobile game.\n\nIn this blog post, we’ll answer the following questions:\n• What is null in Unity?\n• What are the key ways to prevent null reference exceptions in your Unity games?\n• How can you solve null reference exceptions?\n\nWhat is null in Unity?\n\nIn Unity, null is a value that shows that an object or component in the game doesn’t refer to anything in the game’s memory. While null in Unity is similar to null in other programming languages in that it does represent the absence of an object, it’s different in a key way.\n\nImproper understanding of how Unity treats null can cause a hard to debug . This exception is a runtime error that happens when the code attempts to access an object or component that is null. This can occur if a variable isn’t initialized or if a or component is destroyed or not found in the scene.\n\nThis can differ from expectations because Unity overrides the operator. Unity provides their own definition for the operator. This has precedence over the standard operator and can create unexpected behavior. When you write code like , that code checks if the C# wrapper object is null or the backing C++ object has been destroyed. However, for the operator, this has not been overridden. What this means is that it’s possible for one method of checking for nullity to disagree with another method. This can lead to some hard to debug issues, burning precious development time.\n\nWhile null reference exceptions are an issue that many Unity developers encounter, the result of errors and unexpected behavior in your game are not outcomes many developers can afford. This is why it’s important to understand how null works in Unity, how to prevent null reference exceptions, and how to solve null reference exceptions.\n\nWhat are the key ways to prevent null reference exceptions in your Unity games?\n\nNull reference exceptions occur in Unity code in scripts when you attempt to access an object that is null. To prevent this, you’ll need to follow important best practices when writing your code. We’ll walk through a few effective methods below.\n\nThe null-conditional operator ( ) allows you to access members of an object if the object isn’t null. After accessing this object, if the object is null (and the code therefore invalid), the rest of the line is harmlessly skipped. Here is how you can use it to prevent null reference exceptions.\n\nTo avoid null reference exceptions in Unity, you should initialize your variables to default values when they are declared. Here is an example of code you can use to do so.\n\nThe idea behind lazy initialization is that, rather than initializing a variable when it is created, you initialize it the first time you need it; we recommend doing this with custom getter properties in order to enforce the necessary intermediary steps. You can use the code below for this initialization.\n\nHow can you solve null reference exceptions?\n\nIf you’re past the point of prevention and you’re attempting to solve null reference exceptions, then it’s imperative that you understand all the issues that affect your game. This includes the ability to spot issues in both the native and Unity layers.\n\nHaving the right data to solve your issues is vital. Not only does it make the process of problem solving more efficient, it also prevents other issues from occurring. For example, if you’re solving your null reference exceptions properly, then in most cases, argument null exceptions in Unity won’t occur. This frees up valuable developer time.\n\nEach coding language differs in its classification of what defines an exception. This is why you need detailed data about your mobile game. You also need the ability to pull from a variety of data sources, metrics, and user behaviors to reproduce what led to the exception. Make sure you have the following:\n\nWhen a null reference exception occurs in C#, the stack trace from this provides vital information to get to the root of your issue.\n\nYou should know which function the exception comes from. That way, you can note every place in the function where the code accesses a member of a reference type. This will give you all the potential sites where the occurs.\n\nFrom here, you can begin an educated trial and error process where you check the origin of the references to note if any are guaranteed to be non-null.\n\nIt’s important not only to have the crash stack trace but also to understand the user journey that led to the crash. This will give you valuable insight into the frustrations that users are experiencing, the user actions that led to the issue, and help you recognize patterns that may be related to the null reference exception.\n\nYou should be able to look up any session for an in-depth view of the user experience. You should also be able to note important metrics like the speed of your game’s startup, the success of your network calls, and the frequency of errors and app freezes. In addition to this, you should have insight into other important factors like screen taps, low memory warnings, connectivity switches, and more all at a glance.\n\nUnderstanding null reference exceptions in Unity is crucial. It can be the difference between a successful game that delights users and a failing game that frustrates them.\n\nBeyond just understanding null reference exceptions in Unity, it’s important to understand your game as a whole. Without the ability to monitor your game in detail, you’ll run into unexpected problems like errors, crashes, and ANRs. This can all lead to a loss of users, decreased revenue, and a poor business outcome. If you’re seeking mobile game success, start with a sound understanding of null and a holistic monitoring platform that suits your needs.\n\nInterested in solving your issues with null reference exceptions today? You can get started for free"
    },
    {
        "link": "https://discussions.unity.com/t/unity-2017-and-null-conditional-operators/674817",
        "document": ""
    }
]