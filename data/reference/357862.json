[
    {
        "link": "https://khronos.org/opengl/wiki/Image_Libraries",
        "document": "Loading images from files is outside the scope of the OpenGL specification. It is handled by user-made code or one of the image handling libraries below.\n• lodepng: Very small library for loading PNG files without any dependencies.\n• libpng: The official library for loading PNG files. It is very widely used. Many other libraries use this to handle PNG.\n• libspng: An alternative to libpng with a simple C API.\n• libjpg: A library for loading JPEG (or JPG) files. As with libpng, other libraries use libjpg to handle JPEG.\n• libktx: Library for the KTX file format. The KTX format is closely related to OpenGL, but not used by most tools. LibKTL also has functions to take a loaded KTX image and convert it into an OpenGL texture.\n\nGLI (OpenGL Image) is a small cross-platform C++ image library able to load DDS textures (DDS9 and DDS10), compressed or uncompressed.\n\nIt is licensed under the MIT license.\n\nUnofficial OpenGL SDK has an image loading component called GL Image. This is a C++ library for loading images. It currently supports DDS9 textures (and compression), PNG, JPEG, TGA, BMP, and GIF formats.\n\nIt has functions to load images into OpenGL textures, either user-created ones or ones created by the system itself. It supports creating immutable storage for textures as well as those with mutable storage. It even supports direct state access, to minimize state changes when creating them.\n\nIt is licensed under the MIT license.\n\nSAIL (Squirrel Abstract Image Library) is a fast C/C++ image decoding library providing simple and powerful APIs, from one-liners to complex use cases with custom I/O sources.\n\nIt does not have functions to load images directly into OpenGL textures.\n\nSupported image formats: AVIF, BMP, GIF, JPEG, PNG, TIFF, WEBP and more. Work to add more image formats is ongoing.\n\nIt is released under the MIT license.\n\nDevIL stands for Developers Image Library (it once was called \"OpenIL\", but that was trademarked, so they had to change it). It supports many image formats for reading and writing, it supports several compilers and OS (Win, Linux, Mac OSX). The library has a OpenGL-like syntax.\n\nIt does have functions to load images directly (more or less) into OpenGL textures, though these are part of \"ilut\" and not \"il\" proper.\n\nFreeImage is an cross-platform image-loading library, with very wide support for image formats (including some HDR formats like OpenEXR).\n\nIt does not have functions to load images directly into OpenGL textures.\n\nIt is released under multiple licenses, GPL 2 and 3, as well as their own FreeImage Public License.\n\nGLraw is an utility that converts Qt-supported images into various OpenGL-compatible raw formats. glraw reduces the process of loading textures at run-time to a minimum: A file-content dump into GPU memory.\n\nImage to OpenGL texture conversion can be done either by glraw's command line interface, e.g., within an existing tool-chain, or at run-time with glraw linked as asset library (requires linking Qt). For loading image files, just source copy the minimal Raw-File reader or integrate the dependency free, C++ loader library.\n\nIt is licensed under the MIT license.\n\nDO NOT USE THIS! This is a very old library that should not be used anymore. Most people who encounter GLAUX are people who see the NeHe tutorials which haven't been updated in years. NeHe uses auxDIBImageLoad() in order to read BMP files. GLAUX is no longer available."
    },
    {
        "link": "https://stackoverflow.com/questions/17125843/how-do-i-load-textures-to-opengl-using-freeimage-library",
        "document": "I'm learning OpenGL in C++ using NeHe tutorials, but I'm trying to do them with FreeImage library, instead of Glaux or SOIL. The good point I see in using FreeImage is thar it's last update was in October last year, while SOIL hasn't been updated in 5 years. The problem I have is that I'm not able to load textures correctly.\n\nHere is my code:\n\nUsing this code, the texture I get is wrong: it's black, with coloured dots and strips, and changing the image gives the same result, so I assume I'm not loading the texture correctly.\n\nI've tried to swap the red and blue bits (read that FreeImage loads in BGR) with no better result. Finally, if I change the *FreeImage_ConvertTo32Bits(bitmap)* by *FreeImage_GetBits(bitmap)* I get a segfault."
    },
    {
        "link": "https://stackoverflow.com/questions/40821369/freeimage-loading-image-into-opengl",
        "document": "Previously, I have been loading bitmaps (.bmp) using a loader into an OpenGL texture using a tutorial bmp loader, but I want to be able to load different textures, so trying FreeImage.\n\nI am trying remove gamma correction, but with FreeImage the image isn't displayed correctly.\n\nThe problem is that using FreeImage, I am getting a really 'flat' light from it. Is there a way to effectively reproduce what I have previously done in FreeImage?\n\nThank you in advance ;)"
    },
    {
        "link": "https://community.khronos.org/t/freeimage-example-code/54505",
        "document": "I’ve post before about that, look at the end of this thread: It’s good to make a search in this forums before make a question, just use the right side panel.\n\nIn that sample code I converted BGR to RGB in the CPU. It’s faster if you do that in a shader.\n\n Bye! Certainly not ! why would you want to always swizzle your texture accesses just because of a small hypothetical performance hit for the texture creation… Moreover you can tell OpenGL that your data is in BGRA format ::\n\nI tried using your code RGHP for loading a texture using freeImage. It only work with standard opengl image size. I am trying to load an image that is 39x35. Is there a way I can copy that image to a standard opengl image size with transparency for the new image. #include <windows.h> #include <gl\\gl.h> #include <gl\\glu.h> #include <SDL\\SDL.h> #include <fmod.hpp> #include <FreeImage.h> //The attributes of the screen const int SCREEN_WIDTH = 640; const int SCREEN_HEIGHT = 480; const int SCREEN_BPP = 32; //The surfaces that will be used SDL_Surface *screen = NULL; void InitGL(int Width, int Height) // We call this right after our OpenGL window is created. { glViewport(0, 0, Width, Height); glClearColor(0.0f, 0.0f, 0.0f, 0.0f); // This Will Clear The Background Color To Black glClearDepth(1.0); // Enables Clearing Of The Depth Buffer glDepthFunc(GL_LESS); // The Type Of Depth Test To Do glEnable(GL_DEPTH_TEST); // Enables Depth Testing glShadeModel(GL_SMOOTH); // Enables Smooth Color Shading glEnable(GL_TEXTURE_2D); glMatrixMode(GL_PROJECTION); glLoadIdentity(); // Reset The Projection Matrix gluPerspective(45.0f,(GLfloat)Width/(GLfloat)Height,0.1f,100.0f); // Calculate The Aspect Ratio Of The Window glMatrixMode(GL_MODELVIEW); } /* The main drawing function. */ int main( int argc, char* args[] ) { //Initialize all SDL subsystems if( SDL_Init(SDL_INIT_VIDEO) != 0 ) { return 1; } SDL_GL_SetAttribute( SDL_GL_DOUBLEBUFFER, 1 ); //Set up the screen screen = SDL_SetVideoMode( 640, 480, 32, SDL_OPENGL); //If there was an error in setting up the screen if( screen == NULL ) { return 1; } //Set the window caption SDL_WM_SetCaption( \"Hello World\", NULL ); /* FMOD::System *system; FMOD::System_Create(&system); system->init(100, FMOD_INIT_NORMAL, 0); FMOD::Sound *sound; system->createStream(\"music.mp3\", FMOD_DEFAULT, 0, &sound); FMOD::Channel *channel; system->playSound(FMOD_CHANNEL_FREE, sound, false, &channel); */ InitGL(640, 480); FREE_IMAGE_FORMAT formato = FreeImage_GetFileType(\"image.png\",0);//Automatocally detects the format(from over 20 formats!) FIBITMAP* imagen = FreeImage_Load(formato, \"image.png\"); FIBITMAP* temp = imagen; imagen = FreeImage_ConvertTo32Bits(imagen); FreeImage_Unload(temp); int w = FreeImage_GetWidth(imagen); int h = FreeImage_GetHeight(imagen); //cout<<\"The size of the image is: \"<<textureFile<<\" es \"<<w<<\"*\"<<h<<endl; //Some debugging code GLubyte* textura = new GLubyte[4*w*h]; char* pixeles = (char*)FreeImage_GetBits(imagen); //FreeImage loads in BGR format, so you need to swap some bytes(Or use GL_BGR). for(int j= 0; j<w*h; j++){ textura[j*4+0]= pixeles[j*4+2]; textura[j*4+1]= pixeles[j*4+1]; textura[j*4+2]= pixeles[j*4+0]; textura[j*4+3]= pixeles[j*4+3]; //cout<<j<<\": \"<<textura[j*4+0]<<\"**\"<<textura[j*4+1]<<\"**\"<<textura[j*4+2]<<\"**\"<<textura[j*4+3]<<endl; } //Now generate the OpenGL texture object GLuint texturaID; glGenTextures(1, &texturaID); glBindTexture(GL_TEXTURE_2D, texturaID); glTexImage2D(GL_TEXTURE_2D,0,GL_RGBA, w, h, 0, GL_RGBA,GL_UNSIGNED_BYTE,(GLvoid*)textura ); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); glLoadIdentity(); glTranslatef(-3.0f,0.0f,-6.0f); glBegin (GL_QUADS); glTexCoord2f (0.0, 0.0); glVertex3f (0.0, 0.0, 0.0); glTexCoord2f (1.0, 0.0); glVertex3f (1.0, 0.0, 0.0); glTexCoord2f (1.0, 1.0); glVertex3f (1.0, 1.0, 0.0); glTexCoord2f (0.0, 1.0); glVertex3f (0.0, 1.0, 0.0); glEnd (); SDL_GL_SwapBuffers(); int done = 0; while ( ! done ) { /* This could go in a separate function */ { SDL_Event event; while ( SDL_PollEvent(&event) ) { if ( event.type == SDL_QUIT ) { done = 1; } if ( event.type == SDL_KEYDOWN ) { if ( event.key.keysym.sym == SDLK_ESCAPE ) { done = 1; } } } } } //Quit SDL SDL_Quit(); return 0; }\n\nInstead of using the non-power of two extension which is not supported by all video cards. I want to find a easy way to copy the non-power of two image into another image that is a power of two. The padding in the image I want to make transparent. I’m looking through the freeImage doucment and I don’t see a way I can set the transparency bit for the new image. Is there a easy way I can do this using FreeImage? Psuedo code\n\n 1)Load image and check if image is a power of two.\n\n 2)if the image is not a power of two create a new power of two image using FreeImage.\n\n 3) set all bits in the new image to transparent.\n\n 4)copy the non power of two image into new image.\n\nWell… to conserve more data from the original image you must store the aspect atio too.\n\n Have you downloaded then FreeImage guide? there are functions like FreeImage_Rescale() in the part Unsampling/downSampling. For make a transparent image you need to convert it to 32 bits( 8 bits per channel, if the image have already transparency nothing is added).\n\n You need to delete all temporary results eh!, like I did in the sample code with he FreeImageBITMAP t. the new size(width or height) should be like: By the way about using RGB or BGR in graphics card, there is a white paper at Nvidia Developer Website called “Fast texture transfers” that you should read, of course it’s for Nvidia hardware. What’s your graphics card model?\n\nI’m still having problem displaying my image correctly in opengl. The image with transparency has little black lines on the right side and bottom of the image. I know FreeImage is working correctly because I save the image using FreeImage and the image looks good. I think there is something wrong with this routine for swapping bit to GL_BGR format but I can’t figure out what. Please help. GLubyte* textura = new GLubyte[4*w*h]; char* pixeles = (char*)FreeImage_GetBits(bitmap2); //FreeImage loads in BGR format, so you need to swap some bytes(Or use GL_BGR). for(int j= 0; j<w*h; j++){ textura[j*4+0]= pixeles[j*4+2]; textura[j*4+1]= pixeles[j*4+1]; textura[j*4+2]= pixeles[j*4+0]; textura[j*4+3]= pixeles[j*4+3]; } #include <windows.h> #include <gl\\gl.h> #include <gl\\glu.h> #include <SDL\\SDL.h> #include <fmod.hpp> #include <FreeImage.h> //The attributes of the screen const int SCREEN_WIDTH = 640; const int SCREEN_HEIGHT = 480; const int SCREEN_BPP = 32; //The surfaces that will be used SDL_Surface *screen = NULL; void InitGL(int Width, int Height) // We call this right after our OpenGL window is created. { glViewport(0, 0, Width, Height); glClearColor(1.0f, 1.0f, 1.0f, 0.0f); // This Will Clear The Background Color To Black glClearDepth(1.0); // Enables Clearing Of The Depth Buffer glDepthFunc(GL_LESS); // The Type Of Depth Test To Do glEnable(GL_DEPTH_TEST); // Enables Depth Testing glShadeModel(GL_SMOOTH); // Enables Smooth Color Shading glEnable(GL_TEXTURE_2D); glEnable (GL_BLEND); glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); glMatrixMode(GL_PROJECTION); glLoadIdentity(); // Reset The Projection Matrix gluPerspective(45.0f,(GLfloat)Width/(GLfloat)Height,0.1f,100.0f); // Calculate The Aspect Ratio Of The Window glMatrixMode(GL_MODELVIEW); } int power_of_two(int input) { int value = 1; while ( value < input ) { value <<= 1; } return value; } FIBITMAP* GenericLoader(const char* lpszPathName, int flag = 0) { FREE_IMAGE_FORMAT fif = FIF_UNKNOWN; // check the file signature and deduce its format // (the second argument is currently not used by FreeImage) fif = FreeImage_GetFileType(lpszPathName, 0); if(fif == FIF_UNKNOWN) { // no signature ? // try to guess the file format from the file extension fif = FreeImage_GetFIFFromFilename(lpszPathName); } // check that the plugin has reading capabilities ... if((fif != FIF_UNKNOWN) && FreeImage_FIFSupportsReading(fif)) { // ok, let's load the file FIBITMAP *dib = FreeImage_Load(fif, lpszPathName, flag); // unless a bad file format, we are done ! return dib; } return NULL; } int main( int /*argc*/, char ** argv) { //Initialize all SDL subsystems if( SDL_Init(SDL_INIT_VIDEO) != 0 ) { return 1; } SDL_GL_SetAttribute( SDL_GL_DOUBLEBUFFER, 1 ); //Set up the screen screen = SDL_SetVideoMode( 640, 480, 32, SDL_OPENGL); //If there was an error in setting up the screen if( screen == NULL ) { return 1; } //Set the window caption SDL_WM_SetCaption( \"SDL\", NULL ); /* FMOD::System *system; FMOD::System_Create(&system); system->init(100, FMOD_INIT_NORMAL, 0); FMOD::Sound *sound; system->createStream(\"music.mp3\", FMOD_DEFAULT, 0, &sound); FMOD::Channel *channel; system->playSound(FMOD_CHANNEL_FREE, sound, false, &channel); */ InitGL(640, 480); FIBITMAP *bitmap = GenericLoader(\"image.png\"); int w = power_of_two(FreeImage_GetWidth(bitmap)); int h = power_of_two(FreeImage_GetHeight(bitmap)); FIBITMAP *bitmap2 = FreeImage_Allocate(w, h, 32); FreeImage_Paste(bitmap2, bitmap, 0, 0, 255); FreeImage_Save(FIF_PNG, bitmap2, \"mybitmap.png\", 0); GLubyte* textura = new GLubyte[4*w*h]; char* pixeles = (char*)FreeImage_GetBits(bitmap2); //FreeImage loads in BGR format, so you need to swap some bytes(Or use GL_BGR). for(int j= 0; j<w*h; j++){ textura[j*4+0]= pixeles[j*4+2]; textura[j*4+1]= pixeles[j*4+1]; textura[j*4+2]= pixeles[j*4+0]; textura[j*4+3]= pixeles[j*4+3]; } GLuint texturaID; glGenTextures(1, &texturaID); glBindTexture(GL_TEXTURE_2D, texturaID); glTexImage2D(GL_TEXTURE_2D,0,GL_RGBA, w, h, 0, GL_RGBA,GL_UNSIGNED_BYTE,(GLvoid*)textura ); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); glLoadIdentity(); glTranslatef(2.0f,0.0f,-6.0f); glBegin (GL_QUADS); glTexCoord2f (0.0, 0.0); glVertex3f (0.0, 0.0, 0.0); glTexCoord2f (1.0, 0.0); glVertex3f (1.0, 0.0, 0.0); glTexCoord2f (1.0, 1.0); glVertex3f (1.0, 1.0, 0.0); glTexCoord2f (0.0, 1.0); glVertex3f (0.0, 1.0, 0.0); glEnd (); SDL_GL_SwapBuffers(); int done = 0; while ( ! done ) { SDL_Event event; while ( SDL_PollEvent(&event) ) { if ( event.type == SDL_QUIT ) { done = 1; } if ( event.type == SDL_KEYDOWN ) { if ( event.key.keysym.sym == SDLK_ESCAPE ) { done = 1; } } } } //Quit SDL SDL_Quit(); return 0; } picture with ghost and two black lines on the right and bottom of the ghost that is not suppose to be there.\n\n http://www.keepandshare.com/photo/view.php?u=142005\n\nIm not setting TexEnvf() to anything. My orginal image is the ghost with a transparent background. I made a copy of the image with FreeImage and made it a power of two. I open the image in photoshop and it looks good, no black lines on the right side or bottom of the image but when I display it with opengl I see the black lines. I can’t figure out why and I review the code you posted and it looks good. I’m not familiar with how opengl saves it bitmap. Is their any header information in the file that is causing the black lines. Can you try my code I posted above and see if you have the same problem. Comment out the fmod include line and everthing else should be standard opengl, sdl and FreeImage.\n\nI tried out GL_CLAMP_TO_EDGE and it didn’t compile, I look through the opengl documentation and this works.\n\n glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);\n\n glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP); Thanks for all your help. #include <windows.h> #include <gl\\gl.h> #include <gl\\glu.h> #include <SDL\\SDL.h> //#include <fmod.hpp> #include <FreeImage.h> //The attributes of the screen const int SCREEN_WIDTH = 640; const int SCREEN_HEIGHT = 480; const int SCREEN_BPP = 32; //The surfaces that will be used SDL_Surface *screen = NULL; void InitGL(int Width, int Height) // We call this right after our OpenGL window is created. { glViewport(0, 0, Width, Height); glClearColor(1.0f, 1.0f, 1.0f, 1.0f); // This Will Clear The Background Color To Black glClearDepth(1.0); // Enables Clearing Of The Depth Buffer glDepthFunc(GL_LESS); // The Type Of Depth Test To Do glEnable(GL_DEPTH_TEST); // Enables Depth Testing glShadeModel(GL_SMOOTH); // Enables Smooth Color Shading glEnable(GL_TEXTURE_2D); glEnable (GL_BLEND); glBlendFunc (GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA); glMatrixMode(GL_PROJECTION); glLoadIdentity(); // Reset The Projection Matrix gluPerspective(45.0f,(GLfloat)Width/(GLfloat)Height,0.1f,100.0f); // Calculate The Aspect Ratio Of The Window glMatrixMode(GL_MODELVIEW); //glOrtho(0, 640, 480, 0, -1, 1); } //returns the closest power of two value int power_of_two(int input) { int value = 1; while ( value < input ) { value <<= 1; } return value; } FIBITMAP* GenericLoader(const char* lpszPathName, int flag = 0) { FREE_IMAGE_FORMAT fif = FIF_UNKNOWN; // check the file signature and deduce its format // (the second argument is currently not used by FreeImage) fif = FreeImage_GetFileType(lpszPathName, 0); if(fif == FIF_UNKNOWN) { // no signature ? // try to guess the file format from the file extension fif = FreeImage_GetFIFFromFilename(lpszPathName); } // check that the plugin has reading capabilities ... if((fif != FIF_UNKNOWN) && FreeImage_FIFSupportsReading(fif)) { // ok, let's load the file FIBITMAP *dib = FreeImage_Load(fif, lpszPathName, flag); // unless a bad file format, we are done ! return dib; } return NULL; } int main( int /*argc*/, char ** argv) { //Initialize all SDL subsystems if( SDL_Init(SDL_INIT_VIDEO) != 0 ) { return 1; } SDL_GL_SetAttribute( SDL_GL_DOUBLEBUFFER, 1 ); //Set up the screen screen = SDL_SetVideoMode( 640, 480, 32, SDL_OPENGL); //If there was an error in setting up the screen if( screen == NULL ) { return 1; } //Set the window caption SDL_WM_SetCaption( \"SDL\", NULL ); /* FMOD::System *system; FMOD::System_Create(&system); system->init(100, FMOD_INIT_NORMAL, 0); FMOD::Sound *sound; system->createStream(\"music.mp3\", FMOD_DEFAULT, 0, &sound); FMOD::Channel *channel; system->playSound(FMOD_CHANNEL_FREE, sound, false, &channel); */ InitGL(640, 480); FIBITMAP *bitmap = GenericLoader(\"image.png\"); int w = power_of_two(FreeImage_GetWidth(bitmap)); int h = power_of_two(FreeImage_GetHeight(bitmap)); FIBITMAP *bitmap2 = FreeImage_Allocate(w, h, 32); FreeImage_Paste(bitmap2, bitmap, 0, 0, 255); FreeImage_Save(FIF_PNG, bitmap2, \"mybitmap.png\", 0); FreeImage_Unload(bitmap); GLubyte* textura = new GLubyte[4*w*h]; char* pixeles = (char*)FreeImage_GetBits(bitmap2); //FreeImage loads in BGR format, so you need to swap some bytes(Or use GL_BGR). for(int j= 0; j<w*h; j++){ textura[j*4+0]= pixeles[j*4+2]; textura[j*4+1]= pixeles[j*4+1]; textura[j*4+2]= pixeles[j*4+0]; textura[j*4+3]= pixeles[j*4+3]; } FreeImage_Unload(bitmap2); GLuint texturaID; glGenTextures(1, &texturaID); glBindTexture(GL_TEXTURE_2D, texturaID); // glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST); // glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP); glTexImage2D(GL_TEXTURE_2D,0,GL_RGBA, w, h, 0, GL_RGBA,GL_UNSIGNED_BYTE,(GLvoid*)textura ); int done = 0; while ( ! done ) { SDL_Event event; while ( SDL_PollEvent(&event) ) { if ( event.type == SDL_QUIT ) { done = 1; } if ( event.type == SDL_KEYDOWN ) { if ( event.key.keysym.sym == SDLK_ESCAPE ) { done = 1; } } } glLoadIdentity(); glTranslatef(0.0f,0.0f,-10.0f); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); glBegin (GL_QUADS); glTexCoord2f (0.0, 0.0); glVertex3f (0, 0, 0); glTexCoord2f (1.0, 0.0); glVertex3f (1, 0, 0); glTexCoord2f (1.0, 1.0); glVertex3f (1, 1, 0); glTexCoord2f (0.0, 1.0); glVertex3f (0, 1, 0); glEnd (); SDL_GL_SwapBuffers(); } //Quit SDL SDL_Quit(); return 0; }"
    },
    {
        "link": "https://freeimage.sourceforge.io/features.html",
        "document": "The library has been designed to be extremely simple in use. Our motto is: make difficult things simple instead of simple things difficult. Not limited to the local PC The unique FreeImageIO structure makes it possible to load your images from virtually anywhere. Possibilities include standalone files, memory, database and the Internet, all this without recompiling the library! The internal engine is made completely modular using a clever plugin system. Easily write new plugins and store them in DLL files or embed the plugins directly into your application! FreeImage provides many functions to convert a bitmap from one bitdepth to another. The library supports 1-, 4-, 8-, 16, 24- and 32-bit standard images, as well as integer, real and complex images. Provides basic image manipulation routines such as rotation, resizing, flipping or color adjustments, as well as lossless JPEG transformations. Functions are provided which allow you to directly access the bitmap palette (if available) and bitmap bits. Parse common metadata models attached to your bitmap. FreeImage supports Comments, Exif (including GPS and maker notes), IPTC, Adobe XMP, GeoTIFF and GIF animation metadata models. FreeImage supports RGB float images as well a 48-bit HDR images and provides tone mapping operators to convert these images to 24-bit LDR images. FreeImage can load RAW files from digital photo cameras (CRW/CR2, NEF, RAF, DNG, MOS, KDC, DCR, etc), virtually all RAW formats are supported. Written in portable C++, the library should compile on all 32-bit or 64-bit Windows, Linux and Mac OSX systems.\n\n FreeImage also includes comprehensive documentation to help you work with and learn about the code provided. You can choose the license that has the most advantages for you: Use the liberal FreeImage Public License to use FreeImage commercially or the GNU General Public License to use FreeImage into your open source project. Only a minimum of programming is necessary to store a FreeImage bitmap into a DirectDraw surface or to use FreeImage to load your Direct3D/OpenGL textures. Provides test programs to \"show-off\" the library, compilable and startable on Windows 95, 98, NT, 2000 or on Linux.\n\n* only grayscale\n\n ** only via external plugin, might require a commercial license"
    },
    {
        "link": "https://stackoverflow.com/questions/17125843/how-do-i-load-textures-to-opengl-using-freeimage-library",
        "document": "I'm learning OpenGL in C++ using NeHe tutorials, but I'm trying to do them with FreeImage library, instead of Glaux or SOIL. The good point I see in using FreeImage is thar it's last update was in October last year, while SOIL hasn't been updated in 5 years. The problem I have is that I'm not able to load textures correctly.\n\nHere is my code:\n\nUsing this code, the texture I get is wrong: it's black, with coloured dots and strips, and changing the image gives the same result, so I assume I'm not loading the texture correctly.\n\nI've tried to swap the red and blue bits (read that FreeImage loads in BGR) with no better result. Finally, if I change the *FreeImage_ConvertTo32Bits(bitmap)* by *FreeImage_GetBits(bitmap)* I get a segfault."
    },
    {
        "link": "https://community.khronos.org/t/freeimage-example-code/54505",
        "document": "I’ve post before about that, look at the end of this thread: It’s good to make a search in this forums before make a question, just use the right side panel.\n\nIn that sample code I converted BGR to RGB in the CPU. It’s faster if you do that in a shader.\n\n Bye! Certainly not ! why would you want to always swizzle your texture accesses just because of a small hypothetical performance hit for the texture creation… Moreover you can tell OpenGL that your data is in BGRA format ::\n\nI tried using your code RGHP for loading a texture using freeImage. It only work with standard opengl image size. I am trying to load an image that is 39x35. Is there a way I can copy that image to a standard opengl image size with transparency for the new image. #include <windows.h> #include <gl\\gl.h> #include <gl\\glu.h> #include <SDL\\SDL.h> #include <fmod.hpp> #include <FreeImage.h> //The attributes of the screen const int SCREEN_WIDTH = 640; const int SCREEN_HEIGHT = 480; const int SCREEN_BPP = 32; //The surfaces that will be used SDL_Surface *screen = NULL; void InitGL(int Width, int Height) // We call this right after our OpenGL window is created. { glViewport(0, 0, Width, Height); glClearColor(0.0f, 0.0f, 0.0f, 0.0f); // This Will Clear The Background Color To Black glClearDepth(1.0); // Enables Clearing Of The Depth Buffer glDepthFunc(GL_LESS); // The Type Of Depth Test To Do glEnable(GL_DEPTH_TEST); // Enables Depth Testing glShadeModel(GL_SMOOTH); // Enables Smooth Color Shading glEnable(GL_TEXTURE_2D); glMatrixMode(GL_PROJECTION); glLoadIdentity(); // Reset The Projection Matrix gluPerspective(45.0f,(GLfloat)Width/(GLfloat)Height,0.1f,100.0f); // Calculate The Aspect Ratio Of The Window glMatrixMode(GL_MODELVIEW); } /* The main drawing function. */ int main( int argc, char* args[] ) { //Initialize all SDL subsystems if( SDL_Init(SDL_INIT_VIDEO) != 0 ) { return 1; } SDL_GL_SetAttribute( SDL_GL_DOUBLEBUFFER, 1 ); //Set up the screen screen = SDL_SetVideoMode( 640, 480, 32, SDL_OPENGL); //If there was an error in setting up the screen if( screen == NULL ) { return 1; } //Set the window caption SDL_WM_SetCaption( \"Hello World\", NULL ); /* FMOD::System *system; FMOD::System_Create(&system); system->init(100, FMOD_INIT_NORMAL, 0); FMOD::Sound *sound; system->createStream(\"music.mp3\", FMOD_DEFAULT, 0, &sound); FMOD::Channel *channel; system->playSound(FMOD_CHANNEL_FREE, sound, false, &channel); */ InitGL(640, 480); FREE_IMAGE_FORMAT formato = FreeImage_GetFileType(\"image.png\",0);//Automatocally detects the format(from over 20 formats!) FIBITMAP* imagen = FreeImage_Load(formato, \"image.png\"); FIBITMAP* temp = imagen; imagen = FreeImage_ConvertTo32Bits(imagen); FreeImage_Unload(temp); int w = FreeImage_GetWidth(imagen); int h = FreeImage_GetHeight(imagen); //cout<<\"The size of the image is: \"<<textureFile<<\" es \"<<w<<\"*\"<<h<<endl; //Some debugging code GLubyte* textura = new GLubyte[4*w*h]; char* pixeles = (char*)FreeImage_GetBits(imagen); //FreeImage loads in BGR format, so you need to swap some bytes(Or use GL_BGR). for(int j= 0; j<w*h; j++){ textura[j*4+0]= pixeles[j*4+2]; textura[j*4+1]= pixeles[j*4+1]; textura[j*4+2]= pixeles[j*4+0]; textura[j*4+3]= pixeles[j*4+3]; //cout<<j<<\": \"<<textura[j*4+0]<<\"**\"<<textura[j*4+1]<<\"**\"<<textura[j*4+2]<<\"**\"<<textura[j*4+3]<<endl; } //Now generate the OpenGL texture object GLuint texturaID; glGenTextures(1, &texturaID); glBindTexture(GL_TEXTURE_2D, texturaID); glTexImage2D(GL_TEXTURE_2D,0,GL_RGBA, w, h, 0, GL_RGBA,GL_UNSIGNED_BYTE,(GLvoid*)textura ); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); glLoadIdentity(); glTranslatef(-3.0f,0.0f,-6.0f); glBegin (GL_QUADS); glTexCoord2f (0.0, 0.0); glVertex3f (0.0, 0.0, 0.0); glTexCoord2f (1.0, 0.0); glVertex3f (1.0, 0.0, 0.0); glTexCoord2f (1.0, 1.0); glVertex3f (1.0, 1.0, 0.0); glTexCoord2f (0.0, 1.0); glVertex3f (0.0, 1.0, 0.0); glEnd (); SDL_GL_SwapBuffers(); int done = 0; while ( ! done ) { /* This could go in a separate function */ { SDL_Event event; while ( SDL_PollEvent(&event) ) { if ( event.type == SDL_QUIT ) { done = 1; } if ( event.type == SDL_KEYDOWN ) { if ( event.key.keysym.sym == SDLK_ESCAPE ) { done = 1; } } } } } //Quit SDL SDL_Quit(); return 0; }\n\nInstead of using the non-power of two extension which is not supported by all video cards. I want to find a easy way to copy the non-power of two image into another image that is a power of two. The padding in the image I want to make transparent. I’m looking through the freeImage doucment and I don’t see a way I can set the transparency bit for the new image. Is there a easy way I can do this using FreeImage? Psuedo code\n\n 1)Load image and check if image is a power of two.\n\n 2)if the image is not a power of two create a new power of two image using FreeImage.\n\n 3) set all bits in the new image to transparent.\n\n 4)copy the non power of two image into new image.\n\nWell… to conserve more data from the original image you must store the aspect atio too.\n\n Have you downloaded then FreeImage guide? there are functions like FreeImage_Rescale() in the part Unsampling/downSampling. For make a transparent image you need to convert it to 32 bits( 8 bits per channel, if the image have already transparency nothing is added).\n\n You need to delete all temporary results eh!, like I did in the sample code with he FreeImageBITMAP t. the new size(width or height) should be like: By the way about using RGB or BGR in graphics card, there is a white paper at Nvidia Developer Website called “Fast texture transfers” that you should read, of course it’s for Nvidia hardware. What’s your graphics card model?\n\nI’m still having problem displaying my image correctly in opengl. The image with transparency has little black lines on the right side and bottom of the image. I know FreeImage is working correctly because I save the image using FreeImage and the image looks good. I think there is something wrong with this routine for swapping bit to GL_BGR format but I can’t figure out what. Please help. GLubyte* textura = new GLubyte[4*w*h]; char* pixeles = (char*)FreeImage_GetBits(bitmap2); //FreeImage loads in BGR format, so you need to swap some bytes(Or use GL_BGR). for(int j= 0; j<w*h; j++){ textura[j*4+0]= pixeles[j*4+2]; textura[j*4+1]= pixeles[j*4+1]; textura[j*4+2]= pixeles[j*4+0]; textura[j*4+3]= pixeles[j*4+3]; } #include <windows.h> #include <gl\\gl.h> #include <gl\\glu.h> #include <SDL\\SDL.h> #include <fmod.hpp> #include <FreeImage.h> //The attributes of the screen const int SCREEN_WIDTH = 640; const int SCREEN_HEIGHT = 480; const int SCREEN_BPP = 32; //The surfaces that will be used SDL_Surface *screen = NULL; void InitGL(int Width, int Height) // We call this right after our OpenGL window is created. { glViewport(0, 0, Width, Height); glClearColor(1.0f, 1.0f, 1.0f, 0.0f); // This Will Clear The Background Color To Black glClearDepth(1.0); // Enables Clearing Of The Depth Buffer glDepthFunc(GL_LESS); // The Type Of Depth Test To Do glEnable(GL_DEPTH_TEST); // Enables Depth Testing glShadeModel(GL_SMOOTH); // Enables Smooth Color Shading glEnable(GL_TEXTURE_2D); glEnable (GL_BLEND); glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); glMatrixMode(GL_PROJECTION); glLoadIdentity(); // Reset The Projection Matrix gluPerspective(45.0f,(GLfloat)Width/(GLfloat)Height,0.1f,100.0f); // Calculate The Aspect Ratio Of The Window glMatrixMode(GL_MODELVIEW); } int power_of_two(int input) { int value = 1; while ( value < input ) { value <<= 1; } return value; } FIBITMAP* GenericLoader(const char* lpszPathName, int flag = 0) { FREE_IMAGE_FORMAT fif = FIF_UNKNOWN; // check the file signature and deduce its format // (the second argument is currently not used by FreeImage) fif = FreeImage_GetFileType(lpszPathName, 0); if(fif == FIF_UNKNOWN) { // no signature ? // try to guess the file format from the file extension fif = FreeImage_GetFIFFromFilename(lpszPathName); } // check that the plugin has reading capabilities ... if((fif != FIF_UNKNOWN) && FreeImage_FIFSupportsReading(fif)) { // ok, let's load the file FIBITMAP *dib = FreeImage_Load(fif, lpszPathName, flag); // unless a bad file format, we are done ! return dib; } return NULL; } int main( int /*argc*/, char ** argv) { //Initialize all SDL subsystems if( SDL_Init(SDL_INIT_VIDEO) != 0 ) { return 1; } SDL_GL_SetAttribute( SDL_GL_DOUBLEBUFFER, 1 ); //Set up the screen screen = SDL_SetVideoMode( 640, 480, 32, SDL_OPENGL); //If there was an error in setting up the screen if( screen == NULL ) { return 1; } //Set the window caption SDL_WM_SetCaption( \"SDL\", NULL ); /* FMOD::System *system; FMOD::System_Create(&system); system->init(100, FMOD_INIT_NORMAL, 0); FMOD::Sound *sound; system->createStream(\"music.mp3\", FMOD_DEFAULT, 0, &sound); FMOD::Channel *channel; system->playSound(FMOD_CHANNEL_FREE, sound, false, &channel); */ InitGL(640, 480); FIBITMAP *bitmap = GenericLoader(\"image.png\"); int w = power_of_two(FreeImage_GetWidth(bitmap)); int h = power_of_two(FreeImage_GetHeight(bitmap)); FIBITMAP *bitmap2 = FreeImage_Allocate(w, h, 32); FreeImage_Paste(bitmap2, bitmap, 0, 0, 255); FreeImage_Save(FIF_PNG, bitmap2, \"mybitmap.png\", 0); GLubyte* textura = new GLubyte[4*w*h]; char* pixeles = (char*)FreeImage_GetBits(bitmap2); //FreeImage loads in BGR format, so you need to swap some bytes(Or use GL_BGR). for(int j= 0; j<w*h; j++){ textura[j*4+0]= pixeles[j*4+2]; textura[j*4+1]= pixeles[j*4+1]; textura[j*4+2]= pixeles[j*4+0]; textura[j*4+3]= pixeles[j*4+3]; } GLuint texturaID; glGenTextures(1, &texturaID); glBindTexture(GL_TEXTURE_2D, texturaID); glTexImage2D(GL_TEXTURE_2D,0,GL_RGBA, w, h, 0, GL_RGBA,GL_UNSIGNED_BYTE,(GLvoid*)textura ); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); glLoadIdentity(); glTranslatef(2.0f,0.0f,-6.0f); glBegin (GL_QUADS); glTexCoord2f (0.0, 0.0); glVertex3f (0.0, 0.0, 0.0); glTexCoord2f (1.0, 0.0); glVertex3f (1.0, 0.0, 0.0); glTexCoord2f (1.0, 1.0); glVertex3f (1.0, 1.0, 0.0); glTexCoord2f (0.0, 1.0); glVertex3f (0.0, 1.0, 0.0); glEnd (); SDL_GL_SwapBuffers(); int done = 0; while ( ! done ) { SDL_Event event; while ( SDL_PollEvent(&event) ) { if ( event.type == SDL_QUIT ) { done = 1; } if ( event.type == SDL_KEYDOWN ) { if ( event.key.keysym.sym == SDLK_ESCAPE ) { done = 1; } } } } //Quit SDL SDL_Quit(); return 0; } picture with ghost and two black lines on the right and bottom of the ghost that is not suppose to be there.\n\n http://www.keepandshare.com/photo/view.php?u=142005\n\nIm not setting TexEnvf() to anything. My orginal image is the ghost with a transparent background. I made a copy of the image with FreeImage and made it a power of two. I open the image in photoshop and it looks good, no black lines on the right side or bottom of the image but when I display it with opengl I see the black lines. I can’t figure out why and I review the code you posted and it looks good. I’m not familiar with how opengl saves it bitmap. Is their any header information in the file that is causing the black lines. Can you try my code I posted above and see if you have the same problem. Comment out the fmod include line and everthing else should be standard opengl, sdl and FreeImage.\n\nI tried out GL_CLAMP_TO_EDGE and it didn’t compile, I look through the opengl documentation and this works.\n\n glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);\n\n glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP); Thanks for all your help. #include <windows.h> #include <gl\\gl.h> #include <gl\\glu.h> #include <SDL\\SDL.h> //#include <fmod.hpp> #include <FreeImage.h> //The attributes of the screen const int SCREEN_WIDTH = 640; const int SCREEN_HEIGHT = 480; const int SCREEN_BPP = 32; //The surfaces that will be used SDL_Surface *screen = NULL; void InitGL(int Width, int Height) // We call this right after our OpenGL window is created. { glViewport(0, 0, Width, Height); glClearColor(1.0f, 1.0f, 1.0f, 1.0f); // This Will Clear The Background Color To Black glClearDepth(1.0); // Enables Clearing Of The Depth Buffer glDepthFunc(GL_LESS); // The Type Of Depth Test To Do glEnable(GL_DEPTH_TEST); // Enables Depth Testing glShadeModel(GL_SMOOTH); // Enables Smooth Color Shading glEnable(GL_TEXTURE_2D); glEnable (GL_BLEND); glBlendFunc (GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA); glMatrixMode(GL_PROJECTION); glLoadIdentity(); // Reset The Projection Matrix gluPerspective(45.0f,(GLfloat)Width/(GLfloat)Height,0.1f,100.0f); // Calculate The Aspect Ratio Of The Window glMatrixMode(GL_MODELVIEW); //glOrtho(0, 640, 480, 0, -1, 1); } //returns the closest power of two value int power_of_two(int input) { int value = 1; while ( value < input ) { value <<= 1; } return value; } FIBITMAP* GenericLoader(const char* lpszPathName, int flag = 0) { FREE_IMAGE_FORMAT fif = FIF_UNKNOWN; // check the file signature and deduce its format // (the second argument is currently not used by FreeImage) fif = FreeImage_GetFileType(lpszPathName, 0); if(fif == FIF_UNKNOWN) { // no signature ? // try to guess the file format from the file extension fif = FreeImage_GetFIFFromFilename(lpszPathName); } // check that the plugin has reading capabilities ... if((fif != FIF_UNKNOWN) && FreeImage_FIFSupportsReading(fif)) { // ok, let's load the file FIBITMAP *dib = FreeImage_Load(fif, lpszPathName, flag); // unless a bad file format, we are done ! return dib; } return NULL; } int main( int /*argc*/, char ** argv) { //Initialize all SDL subsystems if( SDL_Init(SDL_INIT_VIDEO) != 0 ) { return 1; } SDL_GL_SetAttribute( SDL_GL_DOUBLEBUFFER, 1 ); //Set up the screen screen = SDL_SetVideoMode( 640, 480, 32, SDL_OPENGL); //If there was an error in setting up the screen if( screen == NULL ) { return 1; } //Set the window caption SDL_WM_SetCaption( \"SDL\", NULL ); /* FMOD::System *system; FMOD::System_Create(&system); system->init(100, FMOD_INIT_NORMAL, 0); FMOD::Sound *sound; system->createStream(\"music.mp3\", FMOD_DEFAULT, 0, &sound); FMOD::Channel *channel; system->playSound(FMOD_CHANNEL_FREE, sound, false, &channel); */ InitGL(640, 480); FIBITMAP *bitmap = GenericLoader(\"image.png\"); int w = power_of_two(FreeImage_GetWidth(bitmap)); int h = power_of_two(FreeImage_GetHeight(bitmap)); FIBITMAP *bitmap2 = FreeImage_Allocate(w, h, 32); FreeImage_Paste(bitmap2, bitmap, 0, 0, 255); FreeImage_Save(FIF_PNG, bitmap2, \"mybitmap.png\", 0); FreeImage_Unload(bitmap); GLubyte* textura = new GLubyte[4*w*h]; char* pixeles = (char*)FreeImage_GetBits(bitmap2); //FreeImage loads in BGR format, so you need to swap some bytes(Or use GL_BGR). for(int j= 0; j<w*h; j++){ textura[j*4+0]= pixeles[j*4+2]; textura[j*4+1]= pixeles[j*4+1]; textura[j*4+2]= pixeles[j*4+0]; textura[j*4+3]= pixeles[j*4+3]; } FreeImage_Unload(bitmap2); GLuint texturaID; glGenTextures(1, &texturaID); glBindTexture(GL_TEXTURE_2D, texturaID); // glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST); // glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP); glTexImage2D(GL_TEXTURE_2D,0,GL_RGBA, w, h, 0, GL_RGBA,GL_UNSIGNED_BYTE,(GLvoid*)textura ); int done = 0; while ( ! done ) { SDL_Event event; while ( SDL_PollEvent(&event) ) { if ( event.type == SDL_QUIT ) { done = 1; } if ( event.type == SDL_KEYDOWN ) { if ( event.key.keysym.sym == SDLK_ESCAPE ) { done = 1; } } } glLoadIdentity(); glTranslatef(0.0f,0.0f,-10.0f); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); glBegin (GL_QUADS); glTexCoord2f (0.0, 0.0); glVertex3f (0, 0, 0); glTexCoord2f (1.0, 0.0); glVertex3f (1, 0, 0); glTexCoord2f (1.0, 1.0); glVertex3f (1, 1, 0); glTexCoord2f (0.0, 1.0); glVertex3f (0, 1, 0); glEnd (); SDL_GL_SwapBuffers(); } //Quit SDL SDL_Quit(); return 0; }"
    },
    {
        "link": "https://stackoverflow.com/questions/12969971/is-it-possible-to-manually-create-image-data-for-opengl-texture-use",
        "document": "I'm learning about textures in the OpenGL environment. I see there's no conventional way of acquiring the actual image data before passing it to video memory.\n\nOut of curiosity, is it possible to create my own matrix of pixel data and fill it in with arbitrary information instead of actually reading a bitmap or an image file?"
    },
    {
        "link": "https://gamedev.stackexchange.com/questions/19193/how-do-i-manage-textures-in-memory-in-opengl",
        "document": "Stack Exchange network consists of 183 Q&A communities including Stack Overflow, the largest, most trusted online community for developers to learn, share their knowledge, and build their careers."
    },
    {
        "link": "https://learnopengl.com/Getting-started/Textures",
        "document": "We learned that to add more detail to our objects we can use colors for each vertex to create some interesting images. However, to get a fair bit of realism we'd have to have many vertices so we could specify a lot of colors. This takes up a considerable amount of extra overhead, since each model needs a lot more vertices and for each vertex a color attribute as well.\n\nWhat artists and programmers generally prefer is to use a . A texture is a 2D image (even 1D and 3D textures exist) used to add detail to an object; think of a texture as a piece of paper with a nice brick image (for example) on it neatly folded over your 3D house so it looks like your house has a stone exterior. Because we can insert a lot of detail in a single image, we can give the illusion the object is extremely detailed without having to specify extra vertices.\n\nBelow you'll see a texture image of a brick wall mapped to the triangle from the previous chapter.\n\nIn order to map a texture to the triangle we need to tell each vertex of the triangle which part of the texture it corresponds to. Each vertex should thus have a associated with them that specifies what part of the texture image to sample from. Fragment interpolation then does the rest for the other fragments.\n\nTexture coordinates range from to in the and axis (remember that we use 2D texture images). Retrieving the texture color using texture coordinates is called . Texture coordinates start at for the lower left corner of a texture image to for the upper right corner of a texture image. The following image shows how we map texture coordinates to the triangle:\n\nWe specify 3 texture coordinate points for the triangle. We want the bottom-left side of the triangle to correspond with the bottom-left side of the texture so we use the texture coordinate for the triangle's bottom-left vertex. The same applies to the bottom-right side with a texture coordinate. The top of the triangle should correspond with the top-center of the texture image so we take as its texture coordinate. We only have to pass 3 texture coordinates to the vertex shader, which then passes those to the fragment shader that neatly interpolates all the texture coordinates for each fragment.\n\nThe resulting texture coordinates would then look like this:\n\nTexture sampling has a loose interpretation and can be done in many different ways. It is thus our job to tell OpenGL how it should sample its textures.\n\nTexture coordinates usually range from to but what happens if we specify coordinates outside this range? The default behavior of OpenGL is to repeat the texture images (we basically ignore the integer part of the floating point texture coordinate), but there are more options OpenGL offers:\n• : The default behavior for textures. Repeats the texture image.\n• : Same as but mirrors the image with each repeat.\n• : Clamps the coordinates between and . The result is that higher coordinates become clamped to the edge, resulting in a stretched edge pattern.\n• : Coordinates outside the range are now given a user-specified border color.\n\nEach of the options have a different visual output when using texture coordinates outside the default range. Let's see what these look like on a sample texture image (original image by Hólger Rezende):\n\nEach of the aforementioned options can be set per coordinate axis ( , (and if you're using 3D textures) equivalent to , , ) with the function:\n\nThe first argument specifies the texture target; we're working with 2D textures so the texture target is . The second argument requires us to tell what option we want to set and for which texture axis; we want to configure it for both the and axis. The last argument requires us to pass in the texture wrapping mode we'd like and in this case OpenGL will set its texture wrapping option on the currently active texture with .\n\nIf we choose the option we should also specify a border color. This is done using the equivalent of the function with as its option where we pass in a float array of the border's color value:\n\nTexture coordinates do not depend on resolution but can be any floating point value, thus OpenGL has to figure out which texture pixel (also known as a ) to map the texture coordinate to. This becomes especially important if you have a very large object and a low resolution texture. You probably guessed by now that OpenGL has options for this as well. There are several options available but for now we'll discuss the most important options: and .\n\n(also known as or filtering) is the default texture filtering method of OpenGL. When set to , OpenGL selects the texel that center is closest to the texture coordinate. Below you can see 4 pixels where the cross represents the exact texture coordinate. The upper-left texel has its center closest to the texture coordinate and is therefore chosen as the sampled color:\n\n(also known as ) takes an interpolated value from the texture coordinate's neighboring texels, approximating a color between the texels. The smaller the distance from the texture coordinate to a texel's center, the more that texel's color contributes to the sampled color. Below we can see that a mixed color of the neighboring pixels is returned:\n\nBut what is the visual effect of such a texture filtering method? Let's see how these methods work when using a texture with a low resolution on a large object (texture is therefore scaled upwards and individual texels are noticeable):\n\nresults in blocked patterns where we can clearly see the pixels that form the texture while produces a smoother pattern where the individual pixels are less visible. produces a more realistic output, but some developers prefer a more 8-bit look and as a result pick the option.\n\nTexture filtering can be set for and operations (when scaling up or downwards) so you could for example use nearest neighbor filtering when textures are scaled downwards and linear filtering for upscaled textures. We thus have to specify the filtering method for both options via . The code should look similar to setting the wrapping method:\n\nImagine we had a large room with thousands of objects, each with an attached texture. There will be objects far away that have the same high resolution texture attached as the objects close to the viewer. Since the objects are far away and probably only produce a few fragments, OpenGL has difficulties retrieving the right color value for its fragment from the high resolution texture, since it has to pick a texture color for a fragment that spans a large part of the texture. This will produce visible artifacts on small objects, not to mention the waste of memory bandwidth using high resolution textures on small objects.\n\nTo solve this issue OpenGL uses a concept called that is basically a collection of texture images where each subsequent texture is twice as small compared to the previous one. The idea behind mipmaps should be easy to understand: after a certain distance threshold from the viewer, OpenGL will use a different mipmap texture that best suits the distance to the object. Because the object is far away, the smaller resolution will not be noticeable to the user. OpenGL is then able to sample the correct texels, and there's less cache memory involved when sampling that part of the mipmaps. Let's take a closer look at what a mipmapped texture looks like:\n\nCreating a collection of mipmapped textures for each texture image is cumbersome to do manually, but luckily OpenGL is able to do all the work for us with a single call to after we've created a texture.\n\nWhen switching between mipmaps levels during rendering OpenGL may show some artifacts like sharp edges visible between the two mipmap layers. Just like normal texture filtering, it is also possible to filter between mipmap levels using and filtering for switching between mipmap levels. To specify the filtering method between mipmap levels we can replace the original filtering methods with one of the following four options:\n• : takes the nearest mipmap to match the pixel size and uses nearest neighbor interpolation for texture sampling.\n• : takes the nearest mipmap level and samples that level using linear interpolation.\n• : linearly interpolates between the two mipmaps that most closely match the size of a pixel and samples the interpolated level via nearest neighbor interpolation.\n• : linearly interpolates between the two closest mipmaps and samples the interpolated level via linear interpolation.\n\nJust like texture filtering we can set the filtering method to one of the 4 aforementioned methods using :\n\nA common mistake is to set one of the mipmap filtering options as the magnification filter. This doesn't have any effect since mipmaps are primarily used for when textures get downscaled: texture magnification doesn't use mipmaps and giving it a mipmap filtering option will generate an OpenGL error code.\n\nThe first thing we need to do to actually use textures is to load them into our application. Texture images can be stored in dozens of file formats, each with their own structure and ordering of data, so how do we get those images in our application? One solution would be to choose a file format we'd like to use, say and write our own image loader to convert the image format into a large array of bytes. While it's not very hard to write your own image loader, it's still cumbersome and what if you want to support more file formats? You'd then have to write an image loader for each format you want to support.\n\nAnother solution, and probably a good one, is to use an image-loading library that supports several popular formats and does all the hard work for us. A library like .\n\nis a very popular single header image loading library by Sean Barrett that is able to load most popular file formats and is easy to integrate in your project(s). can be downloaded from here. Simply download the single header file, add it to your project as , and create an additional C++ file with the following code:\n\nBy defining the preprocessor modifies the header file such that it only contains the relevant definition source code, effectively turning the header file into a file, and that's about it. Now simply include somewhere in your program and compile.\n\nFor the following texture sections we're going to use an image of a wooden container. To load an image using we use its function:\n\nThe function first takes as input the location of an image file. It then expects you to give three as its second, third and fourth argument that will fill with the resulting image's width, height and number of color channels. We need the image's width and height for generating textures later on.\n\nLike any of the previous objects in OpenGL, textures are referenced with an ID; let's create one:\n\nThe function first takes as input how many textures we want to generate and stores them in a array given as its second argument (in our case just a single ). Just like other objects we need to bind it so any subsequent texture commands will configure the currently bound texture:\n\nNow that the texture is bound, we can start generating a texture using the previously loaded image data. Textures are generated with :\n\nThis is a large function with quite a few parameters so we'll walk through them step-by-step:\n• The first argument specifies the texture target; setting this to means this operation will generate a texture on the currently bound texture object at the same target (so any textures bound to targets or will not be affected).\n• The second argument specifies the mipmap level for which we want to create a texture for if you want to set each mipmap level manually, but we'll leave it at the base level which is .\n• The third argument tells OpenGL in what kind of format we want to store the texture. Our image has only values so we'll store the texture with values as well.\n• The 4th and 5th argument sets the width and height of the resulting texture. We stored those earlier when loading the image so we'll use the corresponding variables.\n• The next argument should always be (some legacy stuff).\n• The 7th and 8th argument specify the format and datatype of the source image. We loaded the image with values and stored them as s (bytes) so we'll pass in the corresponding values.\n• The last argument is the actual image data.\n\nOnce is called, the currently bound texture object now has the texture image attached to it. However, currently it only has the base-level of the texture image loaded and if we want to use mipmaps we have to specify all the different images manually (by continually incrementing the second argument) or, we could call after generating the texture. This will automatically generate all the required mipmaps for the currently bound texture.\n\nAfter we're done generating the texture and its corresponding mipmaps, it is good practice to free the image memory:\n\nThe whole process of generating a texture thus looks something like this:\n\nFor the upcoming sections we will use the rectangle shape drawn with from the final part of the Hello Triangle chapter. We need to inform OpenGL how to sample the texture so we'll have to update the vertex data with the texture coordinates:\n\nSince we've added an extra vertex attribute we again have to notify OpenGL of the new vertex format:\n\nNote that we have to adjust the stride parameter of the previous two vertex attributes to as well.\n\nNext we need to alter the vertex shader to accept the texture coordinates as a vertex attribute and then forward the coordinates to the fragment shader:\n\nThe fragment shader should then accept the output variable as an input variable.\n\nThe fragment shader should also have access to the texture object, but how do we pass the texture object to the fragment shader? GLSL has a built-in data-type for texture objects called a that takes as a postfix the texture type we want e.g. , or in our case . We can then add a texture to the fragment shader by simply declaring a that we later assign our texture to.\n\nTo sample the color of a texture we use GLSL's built-in function that takes as its first argument a texture sampler and as its second argument the corresponding texture coordinates. The function then samples the corresponding color value using the texture parameters we set earlier. The output of this fragment shader is then the (filtered) color of the texture at the (interpolated) texture coordinate.\n\nAll that's left to do now is to bind the texture before calling and it will then automatically assign the texture to the fragment shader's sampler:\n\nIf you did everything right you should see the following image:\n\nIf your rectangle is completely white or black you probably made an error along the way. Check your shader logs and try to compare your code with the application's source code.\n\nTo get a little funky we can also mix the resulting texture color with the vertex colors. We simply multiply the resulting texture color with the vertex color in the fragment shader to mix both colors:\n\nThe result should be a mixture of the vertex's color and the texture's color:\n\nI guess you could say our container likes to disco.\n\nYou probably wondered why the variable is a uniform if we didn't even assign it some value with . Using we can actually assign a location value to the texture sampler so we can set multiple textures at once in a fragment shader. This location of a texture is more commonly known as a . The default texture unit for a texture is which is the default active texture unit so we didn't need to assign a location in the previous section; note that not all graphics drivers assign a default texture unit so the previous section may not have rendered for you.\n\nThe main purpose of texture units is to allow us to use more than 1 texture in our shaders. By assigning texture units to the samplers, we can bind to multiple textures at once as long as we activate the corresponding texture unit first. Just like we can activate texture units using passing in the texture unit we'd like to use:\n\nAfter activating a texture unit, a subsequent call will bind that texture to the currently active texture unit. Texture unit is always by default activated, so we didn't have to activate any texture units in the previous example when using .\n\nWe still however need to edit the fragment shader to accept another sampler. This should be relatively straightforward now:\n\nThe final output color is now the combination of two texture lookups. GLSL's built-in function takes two values as input and linearly interpolates between them based on its third argument. If the third value is it returns the first input; if it's it returns the second input value. A value of will return of the first input color and of the second input color, resulting in a mixture of both our textures.\n\nWe now want to load and create another texture; you should be familiar with the steps now. Make sure to create another texture object, load the image and generate the final texture using . For the second texture we'll use an image of your facial expression while learning OpenGL:\n\nNote that we now load a image that includes an alpha (transparency) channel. This means we now need to specify that the image data contains an alpha channel as well by using ; otherwise OpenGL will incorrectly interpret the image data.\n\nTo use the second texture (and the first texture) we'd have to change the rendering procedure a bit by binding both textures to the corresponding texture unit:\n\nWe also have to tell OpenGL to which texture unit each shader sampler belongs to by setting each sampler using . We only have to set this once, so we can do this before we enter the render loop:\n\nBy setting the samplers via we make sure each uniform sampler corresponds to the proper texture unit. You should get the following result:\n\nYou probably noticed that the texture is flipped upside-down! This happens because OpenGL expects the coordinate on the y-axis to be on the bottom side of the image, but images usually have at the top of the y-axis. Luckily for us, can flip the y-axis during image loading by adding the following statement before loading any image:\n\nAfter telling to flip the y-axis when loading images you should get the following result:\n\nIf you see one happy container, you did things right. You can compare it with the source code.\n\nTo get more comfortable with textures it is advised to work through these exercises before continuing.\n• Make sure only the happy face looks in the other/reverse direction by changing the fragment shader: solution.\n• Experiment with the different texture wrapping methods by specifying texture coordinates in the range to instead of to . See if you can display 4 smiley faces on a single container image clamped at its edge: solution, result. See if you can experiment with other wrapping methods as well.\n• Try to display only the center pixels of the texture image on the rectangle in such a way that the individual pixels are getting visible by changing the texture coordinates. Try to set the texture filtering method to to see the pixels more clearly: solution.\n• Use a uniform variable as the function's third parameter to vary the amount the two textures are visible. Use the up and down arrow keys to change how much the container or the smiley face is visible: solution."
    }
]