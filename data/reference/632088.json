[
    {
        "link": "https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/linear-gradient",
        "document": "A linear gradient is defined by an axis—the gradient line—and two or more color-stop points. Each point on the axis is a distinct color; to create a smooth gradient, the function draws a series of colored lines perpendicular to the gradient line, each one matching the color of the point where it intersects the gradient line.\n\nThe gradient line is defined by the center of the box containing the gradient image and by an angle. The colors of the gradient are determined by two or more points: the starting point, the ending point, and, in between, optional color-stop points.\n\nThe starting point is the location on the gradient line where the first color begins. The ending point is the point where the last color ends. Each of these two points is defined by the intersection of the gradient line with a perpendicular line passing from the box corner which is in the same quadrant. The ending point can be understood as the symmetrical point of the starting point. These somewhat complex definitions lead to an interesting effect sometimes called magic corners: the corners nearest to the starting and ending points have the same color as their respective starting or ending points.\n\nBy adding more color-stop points on the gradient line, you can create a highly customized transition between multiple colors. A color-stop's position can be explicitly defined by using a or a . If you don't specify the location of a color, it is placed halfway between the one that precedes it and the one that follows it. The following two gradients are equivalent.\n\nBy default, colors transition smoothly from the color at one color-stop to the color at the subsequent color-stop, with the midpoint between the colors being the halfway point between the color transition. You can move this midpoint to any position between two color-stops by adding an unlabelled % color hint between the two colors to indicate where the middle of the color transition should be. The following example is solid red from the start to the 10% mark and solid blue from 90% to the end. Between 10% and 90% the color transitions from red to blue, however, the midpoint of the transition is at the 30% mark rather than 50% as would have happened without the 30% color hint.\n\nIf two or more color-stops are at the same location, the transition will be a hard line between the first and last colors declared at that location.\n\nColor-stops should be listed in ascending order. Subsequent color-stops of lower value will override the value of the previous color-stop creating a hard transition. The following changes from red to yellow at the 40% mark, and then transitions from yellow to blue over 25% of the gradient:\n\nMulti-position color-stops are allowed. A color can be declared as two adjacent color-stops by including both positions in the CSS declaration. The following three gradients are equivalent:\n\nBy default, if there is no color with a stop, the first color declared will be at that point. Similarly, the last color will continue to the mark, or be at the mark if no length has been declared on that last stop."
    },
    {
        "link": "https://stackoverflow.com/questions/31460515/div-with-a-gradient-placement-possibilities",
        "document": "I'm wondering if there was I could have done this a better way...check out this test link: link to developer site\n\nI made the black gradient box on the image (I cheated) was there a way I could have done this with css? Like could I have made a div with a gradient that was somehow pushed down to the bottom of the image, yet still have my text show up in there the way it is? Would be great because then I could change up the gradient box or even remove it without changing the picture...?\n\nHere is the code for the containing the block\n\nHere is the Css:"
    },
    {
        "link": "https://stackoverflow.com/questions/52755535/how-can-i-make-my-gradient-background-cover-the-whole-div",
        "document": "I'm working on making a website better to read. I succeeded in covering my photos with background gradients to make the letters more visible. The problem is that the background gradient doesn't cover the entire div/image.\n\nHere is the code:"
    },
    {
        "link": "https://blog.frankmtaylor.com/2012/01/23/html5-contenteditable-and-css",
        "document": "My absolute favorite HTML5 attribute is . It makes the contents of the element editable. It’s an incredibly simple feature that has tons of potential for your website.In fact, I’ve already seen it paired with localStorage or Web SQL APIs to capture data and create browser-side interactivity.\n\n\n\nEven better, Chris Coyier actually figured out that you could use “contenteditable” to edit your styles in real-time. How’s that for mind-blowing?\n\nSo, on the heels of the absolute awesomeness of your ability to edit content and styles on a page, I’m going to give some basic CSS pointers for handling and those elements which are ordinarily hidden(e.g.: , , , and even )\n\nWhen you’re actually editing, a gray border gets drawn around the element in Chrome. I find this annoying.So\n\nthe first thing we do is eliminate any browser defaults.\n\nI still think it’s polite to tell a user that they’re editing something, though. If you know me, you know I love feedback.\n\nWhy not be more direct with using and ? Let’s make sure that a user knows when they’ve hovered or focused something .\n\nOf course, be sure to set font-sizing, margins, and floats appropriately. The and pseudo-elements are inline with the element. Unless you shift that content out, the user will think the element has added text.\n\nFirst, I want to state that inline styles and stylesheets are generally bad. An external stylesheet is usually the proper way to style content. But if you’re looking for a cool factor, let’s add this to the CSS so that a user can edit the inline stylesheet — only when they’re actually editing the element. This is also useful for component-based frameworks like React or Vue where you might have styles scoped to a particular component.\n\nAfter getting our inline style to display, now it’s just a matter of making it look good. So let’s push it off to the right, make the text preformatted and blue (so it looks code-y).\n\nThat’s it. If it’s an element, you can make it editable with . If it’s an element which is set to by default, set it to . Now you have a webpage you can edit to your heart’s content, without hitting refresh.\n\nOf course, here’s your demo. If you don’t like it, change it!\n\nYep, you can edit these words right now. Just go crazy and type whatever you want. The only thing you can’t do is create new HTML elements; everything you type into contenteditable is a text string.\n\n[UPDATE for 3.3.18:]\n\nThere’s a sort of followup post to this, where I’ve added additional explanations and included details on the attribute, You may want to read this, instead:"
    },
    {
        "link": "https://css-tricks.com/expanding-images-html5",
        "document": "HTML5 has a new attribute, , which can be applied to any element which allows it to be edited directly in the browser window. Think of text input with a predefined value, but it can literally be any element. Form elements like text inputs support the :focus pseudo class, which allow us to style those elements when they are clicked upon or otherwise navigated to. Giving an element the attribute means it also now supports the :focus pseudo class, which opens up some interesting possibilities!\n\nWe’ll exploit this little trick to make an expanding image (like a lightbox without the overlay) right within some content.\n\nWe just give the figure element tabindex, so that it can be in focus.\n\nGive each subsequent figure a value one higher and the images will be able to be tabbed through nicely from the keyboard!\n\nThe images will be “full size”.\n\nThis means they will be scaled down for regular display on the page, and scaled up when we do our magical CSS expanding. Potentially a waste of bandwidth for the browsers that don’t support this. The tradeoff is your call.\n\nThe :focus part of this isn’t CSS3, the but shadows, transforms, and transitions are. The hover state will rotate the image a bit, and the :focus style (when the image is clicked on), will expand it, rotate it again, and make sure it’s on top with z-index.\n\nThe HTML5 attribute is supported in Firefox 3.6+, Safari 4+, Chrome, and Opera (10.6 only tested). Note that the attribute will cascade down to all child elements. In our demo, having the image and figure caption be editable doesn’t make much sense, so we can turn it off individually on them.\n\nIf you forget to turn off the editablity of the images, Firefox can look a bit funky giving you resize handles for images. Update: another reason to use instead.\n\nOpera respects the child elements not being editable, but still runs the spellchecker on them and will red-underline words it finds misspelled which can be a bit weird.\n\nOur demo also relies upon transforms to “work” though, which are only supported in current WebKit browsers and Firefox 4+. Firefox 3.6 supports the transform but not the transition.\n\nThe fallback is that the images just don’t expand though, which is of course no big deal.\n• If you are looking for a pure CSS lightbox, including the overlay, check out Stu Nicholls version.\n• If you need your lightbox to be fully cross browser compatible, use JavaScript like the Colorbox plugin for jQuery.\n\nBig thanks to Adrian Sinclair who contacted me about this idea and helped with everything."
    },
    {
        "link": "https://stackoverflow.com/questions/6249095/how-to-set-the-caret-cursor-position-in-a-contenteditable-element-div",
        "document": "Most answers you find on contenteditable cursor positioning are fairly simplistic in that they only cater for inputs with plain vanilla text. Once you using html elements within the container the text entered gets split into nodes and distributed liberally across a tree structure.\n\nTo set the cursor position I have this function which loops round all the child text nodes within the supplied node and sets a range from the start of the initial node to the chars.count character:\n\nI then call the routine with this function:\n\nThe range.collapse(false) sets the cursor to the end of the range. I've tested it with the latest versions of Chrome, IE, Mozilla and Opera and they all work fine.\n\nPS. If anyone is interested I get the current cursor position using this code:\n\nThe code does the opposite of the set function - it gets the current window.getSelection().focusNode and focusOffset and counts backwards all text characters encountered until it hits a parent node with id of containerId. The isChildOf function just checks before running that the suplied node is actually a child of the supplied parentId.\n\nThe code should work straight without change, but I have just taken it from a jQuery plugin I've developed so have hacked out a couple of this's - let me know if anything doesn't work!"
    },
    {
        "link": "https://stackoverflow.com/questions/3972014/get-contenteditable-caret-position",
        "document": "What I want to do is know the caret position within a div on keyup . So, when the user is typing text, I can, at any point, know the caret position within the contentEditable element.\n\nI'm finding tons of good, cross-browser answers on how to set the caret position in a contentEditable element, but none on how to get the caret position in the first place.\n\nKinda late to the party, but in case anyone else is struggling. None of the Google searches I've found for the past two days have come up with anything that works, but I came up with a concise and elegant solution that will always work no matter how many nested tags you have: <div contenteditable>some text here <i>italic text here</i> some other text here <b>bold text here</b> end of text</div> It selects all the way back to the beginning of the paragraph and then counts the length of the string to get the current position and then undoes the selection to return the cursor to the current position. If you want to do this for an entire document (more than one paragraph), then change to or whatever granularity for your case. Check out the API for more details. Cheers! :)\n\nAs this took me forever to figure out using the new window.getSelection API I am going to share for posterity. Note that MDN suggests there is wider support for window.getSelection, however, your mileage may vary. const getSelectionCaretAndLine = () => { // our editable div const editable = document.getElementById('editable'); // collapse selection to end window.getSelection().collapseToEnd(); const sel = window.getSelection(); const range = sel.getRangeAt(0); // get anchor node if startContainer parent is editable let selectedNode = editable === range.startContainer.parentNode ? sel.anchorNode : range.startContainer.parentNode; if (!selectedNode) { return { caret: -1, line: -1, }; } // select to top of editable range.setStart(editable.firstChild, 0); // do not use 'this' sel anymore since the selection has changed const content = window.getSelection().toString(); const text = JSON.stringify(content); const lines = (text.match(/\\\n\n/g) || []).length + 1; // clear selection window.getSelection().collapseToEnd(); // minus 2 because of strange text formatting return { caret: text.length - 2, line: lines, } } Here is a jsfiddle that fires on keyup. Note however, that rapid directional key presses, as well as rapid deletion seems to be skip events.\n\nThis one builds on @alockwood05's answer and provides both get and set functionality for a caret with nested tags inside the contenteditable div as well as the offsets within nodes so that you have a solution that is both serializable and de-serializable by offsets as well. I'm using this solution in a cross-platform code editor that needs to get the caret start/end position prior to syntax highlighting via a lexer/parser and then set it back immediately afterward. function countUntilEndContainer(parent, endNode, offset, countingState = {count: 0}) { for (let node of parent.childNodes) { if (countingState.done) break; if (node === endNode) { countingState.done = true; countingState.offsetInNode = offset; return countingState; } if (node.nodeType === Node.TEXT_NODE) { countingState.offsetInNode = offset; countingState.count += node.length; } else if (node.nodeType === Node.ELEMENT_NODE) { countUntilEndContainer(node, endNode, offset, countingState); } else { countingState.error = true; } } return countingState; } function countUntilOffset(parent, offset, countingState = {count: 0}) { for (let node of parent.childNodes) { if (countingState.done) break; if (node.nodeType === Node.TEXT_NODE) { if (countingState.count <= offset && offset < countingState.count + node.length) { countingState.offsetInNode = offset - countingState.count; countingState.node = node; countingState.done = true; return countingState; } else { countingState.count += node.length; } } else if (node.nodeType === Node.ELEMENT_NODE) { countUntilOffset(node, offset, countingState); } else { countingState.error = true; } } return countingState; } function getCaretPosition() { let editor = document.getElementById('editor'); let sel = window.getSelection(); if (sel.rangeCount === 0) { return null; } let range = sel.getRangeAt(0); let start = countUntilEndContainer(editor, range.startContainer, range.startOffset); let end = countUntilEndContainer(editor, range.endContainer, range.endOffset); let offsetsCounts = { start: start.count + start.offsetInNode, end: end.count + end.offsetInNode }; let offsets = { start: start, end: end, offsets: offsetsCounts }; return offsets; } function setCaretPosition(start, end) { let editor = document.getElementById('editor'); let sel = window.getSelection(); if (sel.rangeCount === 0) { return null; } let range = sel.getRangeAt(0); let startNode = countUntilOffset(editor, start); let endNode = countUntilOffset(editor, end); let newRange = new Range(); newRange.setStart(startNode.node, startNode.offsetInNode); newRange.setEnd(endNode.node, endNode.offsetInNode); sel.removeAllRanges(); sel.addRange(newRange); return true; }\n\nI used John Ernest's excellent code, and reworked it a bit for my needs:\n• Using TypeScript (in an Angular application); And while working on it, I stumbled on the little known (or little used) TreeWalker, and simplified the code further, as it allows to get rid of recursivity. A possible optimization could be to walk the tree once to find both start node and end node, but:\n• I doubt the speed gain would be perceptible by the user, even at the end of a huge, complex page;\n• It would make the algorithm more complex and less readable. Instead, I treated the case where the start is the same as the end (just a caret, no real selection). [EDIT] It seems that range's nodes are always of Text type, so I simplified code a bit more, and it allows to get the node length without casting it. export type CountingState = { countBeforeNode: number; offsetInNode: number; node?: Text; // Always of Text type }; export type RangeOffsets = { start: CountingState; end: CountingState; offsets: { start: number; end: number; } }; export function isTextNode(node: Node): node is Text { return node.nodeType === Node.TEXT_NODE; } export function getCaretPosition(container: Node): RangeOffsets | undefined { const selection = window.getSelection(); if (!selection || selection.rangeCount === 0) { return undefined; } const range = selection.getRangeAt(0); const start = countUntilEndNode(container, range.startContainer as Text, range.startOffset); const end = range.collapsed ? start : countUntilEndNode(container, range.endContainer as Text, range.endOffset); const offsets = { start: start.countBeforeNode + start.offsetInNode, end: end.countBeforeNode + end.offsetInNode }; const rangeOffsets: RangeOffsets = { start, end, offsets }; return rangeOffsets; } export function setCaretPosition(container: Node, start: number, end: number): boolean { const selection = window.getSelection(); if (!selection) { return false; } const startState = countUntilOffset(container, start); const endState = start === end ? startState : countUntilOffset(container, end); const range = document.createRange(); // new Range() doesn't work for me! range.setStart(startState.node!, startState.offsetInNode); range.setEnd(endState.node!, endState.offsetInNode); selection.removeAllRanges(); selection.addRange(range); return true; } function countUntilEndNode( parent: Node, endNode: Text, offset: number, countingState: CountingState = { countBeforeNode: 0, offsetInNode: 0 }, ): CountingState { const treeWalker = document.createTreeWalker(parent, NodeFilter.SHOW_TEXT); while (treeWalker.nextNode()) { const node = treeWalker.currentNode as Text; if (node === endNode) { // We found the target node, memorize it. countingState.node = node; countingState.offsetInNode = offset; break; } // Add length of text nodes found in the way, until we find the target node. countingState.countBeforeNode += node.length; } return countingState; } function countUntilOffset( parent: Node, offset: number, countingState: CountingState = { countBeforeNode: 0, offsetInNode: 0 }, ): CountingState { const treeWalker = document.createTreeWalker(parent, NodeFilter.SHOW_TEXT); while (treeWalker.nextNode()) { const node = treeWalker.currentNode as Text; if (countingState.countBeforeNode <= offset && offset < countingState.countBeforeNode + node.length) { countingState.offsetInNode = offset - countingState.countBeforeNode; countingState.node = node; break; } countingState.countBeforeNode += node.length; } return countingState; }\n\nSo based off of the answer provided by Chris Sullivan, I managed to create a version of it that wouldn't reset when a selection was made via keyboard and was able to detect both the column and the line number. In this method, you first have to figure out a solution to fetching all of the text up to the carat. You can do this by getting the current selection (which is the caret), cloning the first range of it, collapsing it, then changing the start node of the range to be the beginning of your element. From there, you can extract all the text up to the carat by simply running a toString on the range. Now that you have the text, we can perform some simple calculations on it to determine the line number and column. For the line number, you simply need to calculate the number of newlines in the string of text. This can be done using some simple regexp, which can be seen in the code below. For the column number, there's three ways to get a \"column number.\"\n• The \"relative column\" to the line number, similar to how Windows Notepad calculates it, is the easiest to calculate. This is simply the range's end offset ( ).\n• The actual position of the caret relative to the number of arrow-key presses you would need to press to get to that position. This can be calculated by replacing all of the newlines in the text, and then getting the length of it.\n• The actual position of the caret relative to the actual text; this you can fetch by just getting the length of the text. Enough talk, now time for some show: // Caret function getCaretPosition(element) { // Check for selection if (window.getSelection().type == \"None\") { return { \"ln\": -1, \"col\": -1 } } // Copy range var selection = window.getSelection(); var range = selection.getRangeAt(0).cloneRange(); // Collapse range range.collapse(); // Move range to encompass everything range.setStart(element.firstChild, 0); // Calculate position var content = range.toString(); var text = JSON.stringify(content); var lines = (text.match(/\\\n\n/g) || []).length + 1; // Return caret position (col - 2 due to some weird calculation with regex) return { \"ln\": lines, // \"col\": range.endOffset + 1 // Method 1 \"col\": text.replace(/\\\n\n/g, \" \").length - 2 // Method 2 // \"col\": text.length -2 // Method 3 } } Now through this method, if you wanted, you can get the caret position every time the selection is updated: I hope this helps someone, I was pulling my hair out for hours trying to figure out how to do this!\n\nThe code below counts the caret position by taking the offset at the current element and then navigating back all the elements inside the and counting the total number of characters. If you encounter an issue please let me know so I can update the code. function getRowTextLength(currentNode) { let previousSibling; let textLength = 0; //this means we are outside our desired scope if (currentNode?.contentEditable == \"true\") { return textLength; } while (currentNode) { //get the previous element of the currentNode previousSibling = currentNode.previousSibling || //UNFORMATTED text case //avoid targetting the contenteditable div itself (currentNode.parentNode.nodeName != \"DIV\" ? currentNode.parentNode.previousSibling //FORMATTED text case : null); //count the number of characters in the previous element, if exists textLength = previousSibling ? textLength + previousSibling.textContent.length : textLength; //set current element as previous element currentNode = previousSibling; //continue looping as long as we have a previous element } return textLength; } //pass e.target from an eventListener as argument function getCaretPosition(element) { let selection = getSelection(element); //caret position at current row let caretPosition = selection.anchorOffset; let currentNode = selection.baseNode; caretPosition += getRowTextLength(currentNode); //get closest div parent node if (caretPosition != 0) { do { currentNode = currentNode.parentNode; } while (currentNode.nodeName != \"DIV\"); } caretPosition += getRowTextLength(currentNode); //console.log(\"CARET POSITION \", caretPosition); return caretPosition; }"
    },
    {
        "link": "https://github.com/facebook/react/issues/2047",
        "document": "I don't think if this is really a bug nor if this can be fixed easily but this is an annoying behavior.\n\nSee http://jsfiddle.net/kb3gN/4603/\n\n The cursor jumps unexpectedly as the contenteditable element is rerendered.\n\nDoes this mean that we should always use contentEditable elements as uncontrolled components?"
    },
    {
        "link": "https://geeksforgeeks.org/how-to-set-cursor-position-in-content-editable-element-using-javascript",
        "document": "How to Set Cursor Position in Content-Editable Element using JavaScript?\n\nTo set the cursor position in content-editable elements, such as a div tag, you can use the JavaScript Range interface. A range is created using the document.createRange() method.\n• None First, create a Range and set the position using the above syntax.\n• None Get user input from the input tag using jQuery\n• None On the button click assign input value to range function to return cursor position on div.\n\n// document.createRange() creates new range object letrangeobj = document.createRange(); // Here 'rangeobj' is created Range Object letselectobj = window.getSelection(); // Here 'selectobj' is created object for window // get selected or caret current position. // Setting start position of a Range rangeobj.setStart(startNode, startOffset); // Setting End position of a Range rangeobj.setEnd(endNode, endOffset); // Collapses the Range to one of its // boundary points rangeobj.collapse(true); // Removes all ranges from the selection // except Anchor Node and Focus Node selectobj.removeAllRanges(); // Adds a Range to a Selection selectobj.addRange(rangeobj);\n\nExample 1: Below example illustrate how to set caret cursor position on content-editable element div based on user input.\n\nExample 2: Below example illustrates how to set caret cursor position on content-editable element div.\n\nGeeksforGeeeks HTML stands for Hyper Text Markup Language. It is used to design web pages using markup language. HTML is the combination of Hypertext and Markup language. Hypertext defines the link between the web pages. Markup language is used to define the text document within tag which defines the structure of web pages. HTML is a markup language which is used by the browser to manipulate text, images and other content to display it in required format. Position Cursor"
    },
    {
        "link": "https://reddit.com/r/Frontend/comments/pz8h0p/dom_how_to_move_text_caret_after_span_tag_in",
        "document": "I don't know whether it's HTML/CSS or JS problem, hence I post here as this seems the most comprehensive community.\n\nI'm building a simple text editor at work. It's going to function somewhat similarly to speech check. It will work as follows:\n• There is plain text inside that div.\n• Using API response, we transform some of these plain text words into decorated <span> tags.\n\nAnd here's my problem. When I move my caret/cursor in front of the tag and start typing, my text is typed inside the <span> rather than in front of it, thus extending the decoration and causing a visual bug.\n\nHere's jsfiddle ilustrating this problem. Try typing in front of the first sentence, the decoration will get extended.\n\nNow, how do I do this? I have no idea what's the best solution. I've experimented with the invisible characters, but it was sub-optimal as the user had to press backspace two times to delete span's content."
    }
]