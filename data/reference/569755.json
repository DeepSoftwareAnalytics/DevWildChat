[
    {
        "link": "https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Runtime/Engine/Kismet/UBlueprintAsyncActionBase",
        "document": "BlueprintCallable factory functions for classes which inherit from UBlueprintAsyncActionBase will have a special blueprint node created for it: UK2Node_AsyncAction You can stop this node spawning and create a more specific one by adding the UCLASS metadata \"HasDedicatedAsyncNode\"\n\nCalled to trigger the action once the delegates have been bound Call to globally register this object with a game instance, it will not be destroyed until SetReadyToDestroy is called This allows having an action stay alive until SetReadyToDestroy is manually called, allowing it to be used inside loops or if the calling BP goes away Call when the action is completely done, this makes the action free to delete, and will unregister it with the game instance"
    },
    {
        "link": "https://zomgmoz.tv/unreal/Creating-latent-and-async-Blueprint-nodes",
        "document": "There are several ways to create latent nodes:\n• UBlueprintAsyncActionBase and its subclasses, such as UCancellableAsyncAction\n• Gameplay Tasks and its subclasses, for example:\n• AbilityTasks, for example see How to create custom AbilityTasks"
    },
    {
        "link": "https://forums.unrealengine.com/t/tutorial-creating-latent-actions-for-blueprints-in-c/64085",
        "document": "Creating Latent Functions for Blueprints in C++\n\nWhile working on an AWS Blueprint library, I came across the need to expose some Latent Actions to blueprint. A Latent Action is a node that can be called in a blueprint that will return at some point in the future. The best example is the Delay..."
    },
    {
        "link": "https://mikelis.net/easy-c-latent-functions-in-unreal-engine-blueprints",
        "document": "Probably the easiest way to implement latent Blueprint functions in C++.\n\nUnreal Engine 5 has more than a few ways to implement latent behaviors and latent blueprint functions in C++. However, possibly the easiest way is using .\n\nThanks to 's UCLASS specifier , so long as derived C++ classes have specific fields (functions and properties), they will receive an automatically generated latent K2 node. And we don't need to deal with memory managing an , which is the traditional way of creating latent function nodes.\n\nBelow is an example implementation of a delay node with this method. Note that it has a factory function (UMyDelayAsyncAction::MyDelayAsyncAction) and two delegates - UMyDelayAsyncAction::OnComplete and UMyDelayAsyncAction::OnFail - which result in the respective output pins.\n\n// This function is just a factory that creates a UMyDelayAsyncAction instance. // We must have a valid contextual world for this action, so we don't even make it // unless we can resolve the UWorld from WorldContext. // Create a new UMyDelayAsyncAction, and store function arguments in it. // When the async action is ready to activate, set a timer using the world's FTimerManager. // The timer manager is a singleton, and GetTimerManger() accessor will always return a valid one. // We set the timer for DelayTime, and we pass in the callback function as a lambda. // We're passing \"this\" as a weak pointer, because there is no guarantee that \"this\" will // exist by the time this lambda callback executes. // If everything went well, broadcast OnComplete (fire the On Complete pin), and wrap up. // If something failed, we can broadcast OnFail, and then wrap up. // Cancel the timer if it's ongoing, so OnComplete never broadcasts.\n\nThe first declared static UFUNCTION-reflected function that returns an object pointer will be considered the factory function by Unreal Engine when making the custom K2 node. A factory function will be the function called when the K2 node is executed.\n\nAll UPROPERTY-reflected and BlueprintAssignable member delegates will appear as output execution pins in the custom K2 node.\n\nThe Javadoc-style documentation above the factory function determines what's shown as tooltips when visual programmers hover over our node. If a category is defined for the factory function, the latent function K2 node will appear in that category. Otherwise, the class name will be used as a category.\n\nWhy use this approach?\n• Compared to the classic method, implementing latent blueprint functions this way does not require manual memory management (as you'd need to create an FPendingLatentAction with the keyword).\n• There isn't a need to keep track of data like callback targets, linkage int32, and UUID to fire an output pin when the action is done - simply broadcasting on a delegate is enough.\n• You can cancel this async action individually by calling on the returned async action object, which is more straightforward than canceling .\n• Unlike , this async action does not need to tick; it can be entirely event-based.\n• There is much less boilerplate code in the approach than in the approach.\n• Because an async action object is returned when this latent function executes, this object can be used in a future-promise pattern, similar to how the \"Run EQSQuery\" blueprint function works.\n• The code in the implementation of is similar to gameplay actions ( ) and AI tasks ( ). In fact, both of these classes use the specifier and treat factory functions and blueprint assignable delegates the same way to create a K2 node. So using this method keeps our codebase more consistent.\n• While initially it seems like using could make it challenging to ensure only one instance of this action runs at a time per object or node, the can still be passed into the constructor with the UFUNCTION specifier to implement that functionality.\n\nThere are not many downsides to using compared to the older -based implementation of latent blueprint functions in C++. appears as the more modern approach, and I recommend using it."
    },
    {
        "link": "https://dev.epicgames.com/community/learning/tutorials/Gp9j/working-with-data-in-unreal-engine-data-tables-data-assets-uproperty-specifiers-and-more",
        "document": ""
    },
    {
        "link": "https://dev.epicgames.com/community/learning/tutorials/ZdXD/call-rest-api-using-http-json-from-ue5-c",
        "document": ""
    },
    {
        "link": "https://gist.github.com/yexiuph/d85ead762a626e5c2e8be890959d80b6",
        "document": "You signed in with another tab or window. Reload to refresh your session.\n\nYou signed out in another tab or window. Reload to refresh your session.\n\nYou switched accounts on another tab or window. Reload to refresh your session."
    },
    {
        "link": "https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Runtime/HTTP/FHttpModule",
        "document": "Add a default header to be appended to future requests If a request already specifies this header, then the defaulted version will not be used\n\nSet the min delay time for each http request\n\nSet the target tick rate of an active http thread\n\nSet the minimum sleep time of an active http thread\n\nSet the target tick rate of an idle http thread\n\nSet the minimum sleep time when idle, waiting for requests\n\nSets timeout in seconds for the entire http request to complete"
    },
    {
        "link": "https://forums.unrealengine.com/t/how-to-make-an-http-request-from-unreal/27577",
        "document": "Something like that I don’t know what level of answer you’re expecting so if the code below is too complicated then just tell me and I’ll explain what it does. void YourClass::YourFunction() { TSharedPtr<FJsonObject> JsonObject = MakeShareable(new FJsonObject()); JsonObject->SetStringField(TEXT(\"some_string_field\"), *FString::Printf(TEXT(\"%s\"), *SomeFStringVariable)); FString OutputString; TSharedRef<TJsonWriter<TCHAR>> JsonWriter = TJsonWriterFactory<>::Create(&OutputString); FJsonSerializer::Serialize(JsonObject.ToSharedRef(), JsonWriter); TSharedRef<IHttpRequest> HttpRequest = FHttpModule::Get().CreateRequest(); HttpRequest->SetVerb(\"POST\"); HttpRequest->SetHeader(\"Content-Type\", \"application/json\"); HttpRequest->SetURL(*FString::Printf(TEXT(\"%s\"), *UrlAddressAsString)); HttpRequest->SetContentAsString(OutputString); HttpRequest->OnProcessRequestComplete().BindUObject(this, &YourClass::OnYourFunctionCompleted); HttpRequest->ProcessRequest(); } void YourClass::OnYourFunctionCompleted(FHttpRequestPtr Request, FHttpResponsePtr Response, bool bWasSuccessful) { if (bWasSuccessful && Response->GetContentType() == \"application/json\") { TSharedPtr<FJsonObject> JsonObject = MakeShareable(new FJsonObject()); TSharedRef<TJsonReader<TCHAR>> JsonReader = TJsonReaderFactory<TCHAR>::Create(Response->GetContentAsString()); FJsonSerializer::Deserialize(JsonReader, JsonObject); SomeOtherVariable = JsonObject->GetStringField(\"some_response_field\"); } else { // Handle error here } }\n\nYou can also look at the Rest plugin for Unreal … depending on what you want to do. Your post is a bit vague … do you want to load a web-page … do you want to connect to a restful web-service … do you want to make your gun run in a web-browser. Can you provide some more information so that we can attempt to help you.\n\nHi, sorry to rake up this almost a year old conversation, but I could find the solution nowhere. I tried to use the code you suggested, but I keep getting an error on the Response variable: FHttpResponsePtr Response Error: pointer to incomplete class type is not allowed Any idea why? Of course I’m pretty new to C++ coding.\n\nIs there any website where i can test POST? Just to see if it catches the content that i send via json.\n\n I’ve been testing GET with this site: https://pokeapi.co\n\nHi, sorry to rake up this almost a year old conversation, but I could find the solution nowhere. I tried to use the code you suggested, but I keep getting an error on the Response variable: FHttpResponsePtr Response Error: pointer to incomplete class type is not allowed Any idea why? Of course I’m pretty new to C++ coding. I realize it’s been a while since the question, but when an error of “* to incomplete class type is not allowed” is usually an issue with the file you’re working in (most likely the .cpp if you’re implementing) doesn’t have an include line for the header file where the type is defined. So for this specific issue, you would want to add to the include section of your file\n\nIf someone googles through this thread (it’s the first result) and just wants to copy paste a quick http request without butchering your code with all of that above, here it is:"
    },
    {
        "link": "https://jollymonsterstudio.com/2021/11/05/unreal-networking-http-get-json-request-using-rest-api",
        "document": "Today we are going to start looking at some new content related to networking operations with the Unreal Engine.\n\nSpecifically we are going to review how to make HTTP GET calls from within Unreal to an external REST API.\n\nThe project files for this video & article can be found on our GitHub page.\n\nIn order to start using the HTTP module we first need to modify our Build.cs file to include a few new public dependencies. Specifically Http, Json and JsonUtilities.\n\nWith these dependencies included we can define our Actor that is going to handle the work of doing the network communication.\n\nIn this case we are using an actor that will relay it’s information to a custom UUserWidget that is attached to this actor via a WidgetComponent.\n\nThe other property is our reference to the FHttpModule that will be used for all of our network communication with the server. This is available to us by including the “Http.h” header in our Actor.\n\nLet’s step through our functions one by one and see how they all communicate.\n\nFirst thing is our overlap that is triggered when the character interacts with this Actor as well as the instantiation of our components and the FHttpModule.\n\nWith our objects all setup we can now proceed to looking at the OnBeginOverlap method as that is the first thing our character will interact with.\n\nIn the begin overlap we do a few things. We update our user widget ( HTTPResponseWidget ) that a loading operation has started and we try to retrieve the username of the player that interacted with our component.\n\nWe then send the players username over to SendHTTPGet() which will try to determine if it’s a valid username or not and make it’s HTTP calls out to an external service.\n\nHere is where we start creating our request structure for the HTTP GET call. This means we have to provide a URL and depending on the username we either use it to retrieve a single record or instead get all users available to us.\n\nWe also create callbacks via OnProcessRequestComplete to two separate methods: OnGetUsersResponse and OnGetUserByUsernameResponse.\n\nThis allows us to handle the response structure per each GET call separately and offload the processing of those requests to different components if required.\n\nWe also include some custom headers that can be used for things like the Content-Type definition but also for more complex security and authentication situations.\n\nThe OnGetUsersResponse method will be processing this JSON Payload which includes an array of elements as part of the response.\n\nWhile the OnGetUserByUsernameResponse will process a single user entity response.\n\nNow let’s take a look at the implementation details for these two payloads.\n\nLastly in our OnGetUsersResponse and OnGetUserByUsernameResponse methods we can use the reference to the FHttpRequestPtr and FHttpResponsePtr parameters to determine if our calls were successful and came back with a status code of 200\n\nAdditionally we can observe how the JSON structure is parsed by first using the FJsonObject in combination with the TJsonReader\n\nThis gives us the ability to then get at the individual properties of a JSON response. Specifically since one requires access to an Array.\n\nBy using the various getters ( GetArrayField / GetIntegerField / GetStringField ) we can iterate and access the various properties of our payload.\n\nThat’s it, you successfully processed a JSON response from an external service using your Unreal code.\n\nHope this helps you guys make your own network requests.\n\nIf you would like to see more examples check out the video as well as the GitHub project for examples of child classes that move the player and particles around."
    }
]