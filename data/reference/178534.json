[
    {
        "link": "https://realpython.com/playing-and-recording-sound-python",
        "document": "If you want to use Python to play or record sound, then you’ve come to the right place! In this tutorial, you’ll learn how to play and record sound in Python using some of the most popular audio libraries. You will learn about the most straight-forward methods for playing and recording sound first, and then you’ll learn about some libraries that offer some more functionality in exchange for a few extra lines of code.\n\nBy the end of this tutorial, you’ll know how to:\n• Play MP3 and WAV files, as well as a range of other audio formats\n• Save your recordings or audio files in a range of different file formats\n\nFor a comprehensive list of audio-related Python libraries, have a look at the wiki page on audio in Python.\n\nBelow, you’ll see how to play audio files with a selection of Python libraries. A few of these libraries let you play a range of audio formats, including MP3 and NumPy arrays. All of the libraries below let you play WAV files, some with a few more lines of code than others:\n• is the most straightforward package to use if you simply want to play a WAV or MP3 file. It offers no functionality other than simple playback.\n• lets you play WAV files and NumPy arrays, and gives you options to check whether a file is still playing.\n• allows you to play WAV files or beep your speakers, but it works only on Windows.\n• and provide bindings for the PortAudio library for cross-platform playback of WAV files.\n• requires for audio playback, but with installed, it lets you play a large range of audio formats with only a few lines of code. Let’s have a look at these libraries for audio playback one by one. is a “pure Python, cross platform, single function module with no dependencies for playing sounds.” With this module, you can play a sound file with a single line of code: The documentation of states that it has been tested on WAV and MP3 files, but it may work for other file formats as well. This library was last updated in June 2017. It seems to work well at the time of writing this article, but it’s not clear whether it will still support newer Python releases. is a cross-platform library for playback of (mono and stereo) WAV files with no dependencies. The following code can be used to play a WAV file, and wait for the file to finish playing before terminating the script: WAV files contain a sequence of bits representing the raw audio data, as well as headers with metadata in RIFF (Resource Interchange File Format) format. For CD recordings, the industry standard is to store each audio sample (an individual audio datapoint relating to air pressure) as a 16-bit value, at 44100 samples per second. To reduce file size, it may be sufficient to store some recordings (for example of human speech) at a lower sampling rate, such as 8000 samples per second, although this does mean that higher sound frequencies may not be as accurately represented. A few of the libraries discussed in this tutorial play and record objects, whereas others use NumPy arrays to store raw audio data. Both correspond to a sequence of data points that can be played back at a specified sample rate in order to play a sound. For a object, each sample is stored as a set of two 8-bit values, whereas in a NumPy array, each element can contain a 16-bit value corresponding to a single sample. An important difference between these two data types is that objects are immutable, whereas NumPy arrays are mutable, making the latter more suitable for generating sounds and for more complex signal processing. For more information on how to work with NumPy, have a look at our NumPy tutorials. allows you to play NumPy and Python arrays and objects using . Make sure you have NumPy installed for the following example to work, as well as . (With installed, you can do this by running from your console.) For more information on how to use for installing packages, have a look at Pipenv: A Guide to the New Python Packaging Tool. Below you’ll see how to generate a NumPy array corresponding to a 440 Hz tone and play it back using : # Our played note will be 440 Hz # Generate array with seconds*sample_rate steps, ranging between 0 and seconds # Ensure that highest value is in 16-bit range # Wait for playback to finish before exiting Next, let’s see how you can use to play WAV files on a Windows machine. If you use Windows, you can use the built-in module to access its basic sound-playing machinery. Playing a WAV file can be done in a few lines of code: does not support playback of any files other than WAV files. It does allow you to beep your speakers using . For example, you can beep a 1000 Hz tone for 100 milliseconds with the following code: Next, you’ll learn how to use the module for cross-platform audio playback. As stated in its documentation, “provides bindings for the PortAudio library and a few convenience functions to play and record NumPy arrays containing audio signals”. In order to play WAV files, and need to be installed, to open WAV files as NumPy arrays. With , , and installed, you can now read a WAV file as a NumPy array and play it back: # Wait until file is done playing The line containing extracts the raw audio data, as well as the sampling rate of the file as stored in its RIFF header, and ensures that the script is only terminated after the sound finishes playing. Next, we’ll learn how to use to play sound. With the right dependencies installed, it allows you to play a wide range of audio files, and it offers you more options for working with audio than does. Although can open and save WAV files without any dependencies, you need to have an audio playback package installed to play audio. is strongly recommended, but , , and are alternative options. The following code can be used to play a WAV file with : In order to play back other audio types, such as MP3 files, or should be installed. Have a look at the documentation of for instructions. As an alternative to the steps described in the documentation, provides bindings for , and can be installed using pip: With installed, playing back an MP3 file requires only a small change in our earlier code: Using the construction, you can play any type of audio file that supports. For example, you may play a WMA file using the ollowing: In addition to playing back sound files, lets you save audio in different file formats (more on this later), slice audio, calculate the length of audio files, fade in or out, and apply cross-fades. creates a copy of the AudioSegment that plays backwards, which the documentation describes as “useful for Pink Floyd, screwing around, and some audio processing algorithms.” provides bindings for PortAudio, the cross-platform audio I/O library. This means that you can use to play and record audio on a variety of platforms, including Windows, Linux, and Mac. With , playing audio is done by writing to a : # Open a .Stream object to write the WAV file to # 'output = True' indicates that the sound will be played rather than recorded # Play the sound by writing the audio data to the stream As you may have noticed, playing sounds with is a bit more complex than playing sounds with the libraries you’ve seen earlier. This means that it may not be your first choice if you just want to play a sound effect in your Python application. However, because gives you more low-level control, it is possible to get and set parameters for your input and output devices, and to check your CPU load and input or output latency. It also allows you to play and record audio in callback mode, where a specified callback function is called when new data is required for playback, or available for recording. These options make a suitable library to use if your audio needs go beyond simple playback. Now that you’ve seen how you can use a number of different libraries to play audio, it’s time to see how you can use Python to record audio yourself.\n\nThe and libraries provide ways to record audio with Python. records to NumPy arrays and records to objects. Both of these can be stored as WAV files using the and libraries, respectively. allows you to record audio from your microphone and store it as a NumPy array. This is a handy datatype for sound processing that can be converted to WAV format for storage using the module. Make sure to install the module for the following example ( ). This automatically installs NumPy as one of its dependencies: Earlier in this article, you learned how to play sounds by reading a . Recording audio can be done by writing to this stream instead: # Record at 44100 samples per second Now that you’ve seen how to record audio with and , you’ll learn how to convert your recording (or any other audio files) to a range of different audio formats.\n\nYou saw earlier that you can use the module to store NumPy arrays as WAV files. The module similarly lets you convert between WAV files and NumPy arrays. If you want to store your audio in a different file format, and come in handy, as they allow you to read and write a range of popular file formats (such as MP3, FLAC, WMA and FLV). This module depends on and lets you read WAV files as NumPy arrays, and save NumPy arrays as WAV files. To save a NumPy array as a WAV file, you can use : In this example, is a NumPy array containing audio, is the sample rate of the recording (usually 44100 or 44800 Hz), and is the sampling width of the audio (the number of bytes per sample, typically 1 or 2 bytes). The library can read and write all file formats supported by . Although it can’t play back audio, it allows you to convert audio from and to FLAC, AIFF, and a few audio formats that are less common . To convert a WAV file to FLAC, you can use the following code: Similar code will work for converting between other file formats supported by . lets you save audio in any format that supports, which includes nearly all audio types you might encounter in your daily life. For example, you can convert your WAV file to MP3 with the following code: Using is a more general way of loading audio files. For example, if you want to convert your file back from MP3 to WAV, you can do the following: This code should work for any audio file format that supports."
    },
    {
        "link": "https://stackoverflow.com/questions/26573556/record-speakers-output-with-pyaudio",
        "document": "In case someone is still stumbling over this like me, I found a PyAudio fork to record the output on windows.\n\nThe official PyAudio build isn't able to record the output. BUT with Windows Vista and above, a new API, WASAPI was introduced, which includes the ability to open a stream to an output device in loopback mode. In this mode the stream will behave like an input stream, with the ability to record the outgoing audio stream.\n\nTo set the mode, one has to set a special flag (AUDCLNT_STREAMFLAGS_LOOPBACK). Since this flag is not supported in the official build one needs to edit PortAudio as well as PyAudio, to add loopback support."
    },
    {
        "link": "https://people.csail.mit.edu/hubert/pyaudio/docs",
        "document": "PyAudio provides Python bindings for PortAudio, the cross-platform audio I/O library. With PyAudio, you can easily use Python to play and record audio on a variety of platforms.\n\nTo use PyAudio, first instantiate PyAudio using (1), which acquires system resources for PortAudio. To record or play audio, open a stream on the desired device with the desired audio parameters using (2). This sets up a to play or record audio. Play audio by writing audio data to the stream using , or read audio data from the stream using . (3) Note that in “blocking mode”, each or blocks until all frames have been played/recorded. An alternative approach is “callback mode”, described below, in which PyAudio invokes a user-defined function to process recorded audio or generate output audio. Use to close the stream. (4) Finally, terminate the PortAudio session and release system resources using . (5)\n\n# If len(data) is less than requested frame_count, PyAudio automatically # assumes the stream is finished, and the stream stops. In callback mode, PyAudio will call a user-defined callback function (1) whenever it needs new audio data to play and/or when new recorded audio data becomes available. PyAudio calls the callback function in a separate thread. The callback function must have the following signature . It must return a tuple containing frames of audio data to output (for output streams) and a flag signifying whether there are more expected frames to play or record. (For input-only streams, the audio data portion of the return value is ignored.) The audio stream starts processing once the stream is opened (3), which will call the callback function repeatedly until that function returns or , or until either or is called. Note that if the callback returns fewer frames than the argument (2), the stream automatically closes after those frames are played. To keep the stream active, the main thread must remain alive, e.g., by sleeping (4). In the example above, once the entire wavefile is read, will eventually return fewer than the requested frames. The stream will stop, and the while loop (4) will end."
    },
    {
        "link": "https://stackoverflow.com/questions/40704026/voice-recording-using-pyaudio",
        "document": "First, make sure your microphone is actually connected, on and not muted.\n\nYou are not providing a device index when opening the stream. This means that you will get the device that PyAudio considers the default. Which might not be your microphone.\n\nUse the and methods of the object in an interactive Python session. Print the dictionaries that returns to determine which device index represents your microphone, and provide that index number as the parameter when opening the stream."
    },
    {
        "link": "https://people.csail.mit.edu/hubert/pyaudio",
        "document": "PyAudio is distributed under the MIT License.\n\nThis library was originally inspired by:\n\nPyAudio 0.2.14 pre-compiled wheels for Microsoft Windows (32-bit and 64-bit) are now available foron PyPI . Install using pip, as described below PyAudio 0.2.14 is a new release that fixes a build issue. Thanks to Bhanu Victor DiCara for the help.\n\nAlso, PyAudio 0.2.14 pre-compiled wheels for Microsoft Windows (32-bit and 64-bit) are now available for Python 3.12 on PyPI. Install using pip, as described below.\n• Fixed installation on Apple silicon. Thanks to Michael Parque for help with updating and testing!\n• is now , which should not affect existing code, as directly accessing the module-level class has always been unsupported. Use instead.\n• and methods are deprecated. Use the and properties, respectively, instead.\n• Sean Zimmermann for help with modernizing the Microsoft Windows build process\n• Jason Hihn for suggesting the use paFramesPerBufferUnspecified as the default frames per buffer\n• Eiichi Takamori for the patch that uses the system's preferred encoding\n• Matěj Cepl for the patches that skip unit tests that require audio hardware\n• Vasily Zakharov for fixes and suggestions to the documentation\n• Artur Janowiec for fixes to the website documentation\n\nPyAudio 0.2.11 is a new release with a bug fix related to memory management. PyAudio 0.2.11 is a new release with a bug fix related to memory management. Many thanks to both Blaise Potard and Matthias Schaff for discovering the issue and for their patches! Thanks as well to Timothy Port for helping to correct a docstring. PyAudio 0.2.10 is a new release with bug fixes related to the Python GIL. It also introduces a few automated unit tests. PyAudio 0.2.10 is a new release with bug fixes related to the Python GIL. It also introduces a few automated unit tests. Great thanks to Michael Graczyk for discovering the GIL-related issues and for submitting a patch! PyAudio PyAudio 0.2.9 is a new release with bug fixes related to overflow error handling and IOError exception arguments. PyAudio installation is better streamlined. Install PyAudio on most platforms using pip.PyAudio 0.2.9 is a new release with bug fixes related to overflow error handling and IOError exception arguments. Many thanks to Tony Jacobson for discovering and helping with the overflow error. Thanks also to Sami Liedes for reporting the IOError exception issue! PyAudio 0.2.8 is a new release with bug fixes related to the Python GIL and device name encoding. PyAudio 0.2.8 is a new release with bug fixes related to the Python GIL and device name encoding. Many thanks to Jason Roehm for discovering and patching the threading-related issue! Many thanks to Sebastian Audet, who wrote PyAudio 0.2.7 is a new release with: Many thanks to Sebastian Audet, who wrote instructions for building PyAudio using Microsoft Visual Studio!PyAudio 0.2.7 is a new release with: Thanks again to Bastian Bechtold for his help converting the documentation for use with Sphinx! In addition, thanks to John K. Luebs for the callback fix. PyAudio 0.2.6 is a new release with: PyAudio 0.2.6 is a new release with: Many thanks to Bastian Bechtold and Bob Jamison for their contributions! Without their patches and Bastian's careful review, this release would still be far away. Also, great thanks to Danilo J. S. Bellini for reporting bugs. Note: As of this update, PyAudio is compatible with Python 2.6, Python 2.7, and Python 3.2. For Python installations older than 2.6, use PyAudio 0.2.4. This web page has been This web page has been This web page has been This web page has been PyAudio 0.2.4 has been uploaded to Debian (sid). A huge thanks to Felipe Sateler for sponsoring the package! PyAudio 0.2.4 is a maintenance release—there are no new features or bug fixes. The binary packages now include PortAudio-v19 (r1535). The source for PyAudio is now in PyAudio 0.2.3 fixes several outstanding bugs ( PyAudio 0.2.0 now works with both Python 2.4 and Python 2.5. Additionally, PyAudio features support for PortAudio's Mac OS X Host API Specific Stream Info extensions (e.g., for channel mapping)—see examples below. The new binary installers include an updated version of PortAudio-v19 (r1368). PyAudio 0.1.0 is released. This web page has been translated to French—thanks to the efforts of Cyril Danilevski!This web page has been translated to Russian—thanks to the efforts of Oleg Meister!This web page has been translated to German—thanks to the efforts of Olga Babenko!This web page has been translated to Belorussian—thanks to the efforts of Jason Fragoso!PyAudio 0.2.4 has been uploaded to Debian (sid). A huge thanks to Felipe Sateler for sponsoring the package!PyAudio 0.2.4 is a maintenance release—there are no new features or bug fixes. The binary packages now include PortAudio-v19 (r1535). The source for PyAudio is now in git (previously subversion).PyAudio 0.2.3 fixes several outstanding bugs ( thanks to all who have sent patches); see the CHANGELOG for details. PyAudio 0.2.3 provides bindings for PortAudio-v19 (r1395) and now includes binary distributions for Python 2.4, 2.5, and 2.6.PyAudio 0.2.0 now works with both Python 2.4 and Python 2.5. Additionally, PyAudio features support for PortAudio's Mac OS X Host API Specific Stream Info extensions (e.g., for)—see examples below. The new binary installers include an updated version of PortAudio-v19 (r1368).PyAudio 0.1.0 is released.\n\nPyAudio 0.2.13 is a new release focused on refactoring, maintenance, and cleanup. See the CHANGELOG in the source distribution for details. Notable changes include:PyAudio 0.2.12 pre-compiled wheels for Microsoft Windows (32-bit and 64-bit) are now available foron PyPI . Install using pip, as described below PyAudio 0.2.12 is a new release with many updates. See the CHANGELOG in the source distribution for details. Notably, the PyAudio build process for Microsoft Windows is streamlined, using the native toolchain. Special thanks to:\n\nThe current version is PyAudio v0.2.14 and supports Python version 3.8+. Install PyAudio using pip on most platforms. For PyAudio versions prior to v0.2.9, PyAudio distributed installation binaries, which are archived here.\n\nThe PyAudio source distribution contains a set of demos. Here's a selection from that set:\n\n\"\"\"PyAudio Example: Record a few seconds of audio and save to a wave file.\"\"\" \"\"\"PyAudio Example: full-duplex wire between input and output.\"\"\" # If len(data) is less than requested frame_count, PyAudio automatically # assumes the stream is finished, and the stream stops. \"\"\"PyAudio Example: Audio wire between input and output. Callback version.\"\"\" # right channel audio --> right speaker; no left channel 'Could not find PaMacCoreStreamInfo. Ensure you are running on macOS.'\n\nPyAudio is distributed under the MIT License: PyAudio is distributed under the Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
    },
    {
        "link": "https://docs.opencv.org/4.x/dd/d43/tutorial_py_video_display.html",
        "document": "\n• Learn to capture video from a camera and display it.\n• You will learn these functions : cv.VideoCapture(), cv.VideoWriter()\n\nOften, we have to capture live stream with a camera. OpenCV provides a very simple interface to do this. Let's capture a video from the camera (I am using the built-in webcam on my laptop), convert it into grayscale video and display it. Just a simple task to get started.\n\nTo capture a video, you need to create a VideoCapture object. Its argument can be either the device index or the name of a video file. A device index is just the number to specify which camera. Normally one camera will be connected (as in my case). So I simply pass 0 (or -1). You can select the second camera by passing 1 and so on. After that, you can capture frame-by-frame. But at the end, don't forget to release the capture.\n\nreturns a bool ( / ). If the frame is read correctly, it will be . So you can check for the end of the video by checking this returned value.\n\nSometimes, cap may not have initialized the capture. In that case, this code shows an error. You can check whether it is initialized or not by the method cap.isOpened(). If it is , OK. Otherwise open it using cap.open().\n\nYou can also access some of the features of this video using cap.get(propId) method where propId is a number from 0 to 18. Each number denotes a property of the video (if it is applicable to that video). Full details can be seen here: cv::VideoCapture::get(). Some of these values can be modified using cap.set(propId, value). Value is the new value you want.\n\nFor example, I can check the frame width and height by and . It gives me 640x480 by default. But I want to modify it to 320x240. Just use and .\n\nPlaying video from file is the same as capturing it from camera, just change the camera index to a video file name. Also while displaying the frame, use appropriate time for . If it is too less, video will be very fast and if it is too high, video will be slow (Well, that is how you can display videos in slow motion). 25 milliseconds will be OK in normal cases.\n\nSo we capture a video and process it frame-by-frame, and we want to save that video. For images, it is very simple: just use . Here, a little more work is required.\n\nThis time we create a VideoWriter object. We should specify the output file name (eg: output.avi). Then we should specify the FourCC code (details in next paragraph). Then number of frames per second (fps) and frame size should be passed. And the last one is the isColor flag. If it is , the encoder expect color frame, otherwise it works with grayscale frame.\n\nFourCC is a 4-byte code used to specify the video codec. The list of available codes can be found in fourcc.org. It is platform dependent. The following codecs work fine for me.\n• In Fedora: DIVX, XVID, MJPG, X264, WMV1, WMV2. (XVID is more preferable. MJPG results in high size video. X264 gives very small size video)\n• In Windows: DIVX (More to be tested and added)\n\nFourCC code is passed as ‘cv.VideoWriter_fourcc('M’,'J','P','G') cv.VideoWriter_fourcc(*'MJPG')` for MJPG.\n\nThe below code captures from a camera, flips every frame in the vertical direction, and saves the video."
    },
    {
        "link": "https://stackoverflow.com/questions/33650974/opencv-python-read-specific-frame-using-videocapture",
        "document": "From the documentation of the VideoCaptureProperties (docs) is possible to see that the way to set the frame in the VideoCapture is:\n\nNotice that you don't have to pass to the function because, as the documentation says, the flag rapresent the \"0-based index of the frame to be decoded/captured next\".\n\nConcluding a full example where i want to read a frame at each second is:\n\nIn the documentation linked above is possible to see that the way to set a specific time in the VideoCapture is:\n\nAnd like before a full example that read a frame each second che be achieved in this way:"
    },
    {
        "link": "https://docs.opencv.org/3.4/dd/d43/tutorial_py_video_display.html",
        "document": "\n• Learn to capture video from a camera and display it.\n• You will learn these functions : cv.VideoCapture(), cv.VideoWriter()\n\nOften, we have to capture live stream with a camera. OpenCV provides a very simple interface to do this. Let's capture a video from the camera (I am using the built-in webcam on my laptop), convert it into grayscale video and display it. Just a simple task to get started.\n\nTo capture a video, you need to create a VideoCapture object. Its argument can be either the device index or the name of a video file. A device index is just the number to specify which camera. Normally one camera will be connected (as in my case). So I simply pass 0 (or -1). You can select the second camera by passing 1 and so on. After that, you can capture frame-by-frame. But at the end, don't forget to release the capture.\n\nreturns a bool ( / ). If the frame is read correctly, it will be . So you can check for the end of the video by checking this returned value.\n\nSometimes, cap may not have initialized the capture. In that case, this code shows an error. You can check whether it is initialized or not by the method cap.isOpened(). If it is , OK. Otherwise open it using cap.open().\n\nYou can also access some of the features of this video using cap.get(propId) method where propId is a number from 0 to 18. Each number denotes a property of the video (if it is applicable to that video). Full details can be seen here: cv::VideoCapture::get(). Some of these values can be modified using cap.set(propId, value). Value is the new value you want.\n\nFor example, I can check the frame width and height by and . It gives me 640x480 by default. But I want to modify it to 320x240. Just use and .\n\nPlaying video from file is the same as capturing it from camera, just change the camera index to a video file name. Also while displaying the frame, use appropriate time for . If it is too less, video will be very fast and if it is too high, video will be slow (Well, that is how you can display videos in slow motion). 25 milliseconds will be OK in normal cases.\n\nSo we capture a video and process it frame-by-frame, and we want to save that video. For images, it is very simple: just use . Here, a little more work is required.\n\nThis time we create a VideoWriter object. We should specify the output file name (eg: output.avi). Then we should specify the FourCC code (details in next paragraph). Then number of frames per second (fps) and frame size should be passed. And the last one is the isColor flag. If it is , the encoder expect color frame, otherwise it works with grayscale frame.\n\nFourCC is a 4-byte code used to specify the video codec. The list of available codes can be found in fourcc.org. It is platform dependent. The following codecs work fine for me.\n• In Fedora: DIVX, XVID, MJPG, X264, WMV1, WMV2. (XVID is more preferable. MJPG results in high size video. X264 gives very small size video)\n• In Windows: DIVX (More to be tested and added)\n\nFourCC code is passed as `cv.VideoWriter_fourcc('M','J','P','G') cv.VideoWriter_fourcc(*'MJPG')` for MJPG.\n\nThe below code captures from a camera, flips every frame in the vertical direction, and saves the video."
    },
    {
        "link": "https://geeksforgeeks.org/saving-operated-video-from-a-webcam-using-opencv",
        "document": ""
    },
    {
        "link": "https://note.nkmk.me/en/python-opencv-videocapture-file-camera",
        "document": "In Python, you can read, capture, and display video files and camera stream using the class with OpenCV. Note that must be enabled in OpenCV to process video.\n\nThis article describes the following contents.\n• Get and set video properties (size, FPS, number of frames, etc.)\n\nThe tutorial on video in the official documentation is below.\n\nThe OpenCV version of the sample code is .\n\nSee the following article for information on reading and writing still images, not videos.\n\nmust be enabled to handle video in OpenCV. If an error occurs and the video cannot be loaded, you should first check to see if is enabled.\n\nYou can check OpenCV build information with .\n\nHow to build with enabled varies depending on the environment, and is not discussed here.\n\nFor macOS, if you install OpenCV with Homebrew, ffmpeg will be installed at the same time and will be enabled (as of January 27, 2019).\n\nTo read a video file, specify the path to the file in . It can be an absolute path or a relative path.\n\nYou can check if it is successfully read with the method. If there is no problem, is returned.\n\nNote that does not raise an error if a wrong path is specified. You should check with .\n\nTo capture video from a PC's built-in camera or a USB camera/webcam, specify the device index in .\n\nIn most cases, the device index is assigned from , such as for the built-in camera and for additional cameras connected via USB.\n\nAccording to the tutorial in the official documentation, there are cases where it is .\n\nAnyway, you can try them in order.\n\nAn API to get a list of available cameras is not yet provided (as of January 27, 2019).\n\nYou can check with the method to see if the camera is successfully specified, just as you would with a video file.\n\nNote that, as with video files, does not raise an error if an incorrect device index is specified.\n\nYou can close video files and camera devices with the method.\n\nGet and set video properties (size, FPS, number of frames, etc.)\n\nYou can get the properties of the opened video with the method of the object.\n\nThe following sample video is used as an example. Sorry for the Japanese site, but if you check the checkbox in the lower right corner, you can download the file from the blue button.\n\nSpecify the property as an argument of the method.\n\nFor example, you can get the size (width and height), FPS (frames per second), and total number of frames as follows:\n\nYou can calculate the playback time of the video in seconds with .\n\nSee the official documentation for a list of property identifiers.\n\nNote that if you use OpenCV2, you need to prefix it with .\n\nThe example above uses a video file, but the same is true for a camera stream. However, there are some differences, such as the total number of frames is not set (always ) because the camera is real-time video.\n\nSome properties can be set to a value with the method. Specify the property as the first argument and the value as the second argument.\n\nreturns or . If it cannot be changed, is returned. In this case, the value remains the same.\n\nIf the value can be changed, is returned.\n\nproperty represents the current position of the video. Details are described below.\n\nNote that even if returns , the value may not be changed. For example, is used to change the FPS of a camera, but if the camera itself does not support that FPS, the value may not be changed even if returns .\n\nYou can get the frames of the video as a NumPy array with the method of the object.\n\nFor video files, you need to consider the current position.\n\nYou can get the current number of frames and the elapsed time in milliseconds with the method. Both are when the file is opened.\n\nreturns a tuple consisting of indicating if the frame was successfully read or not and , the array of the image. You can assign to each variable with unpacking.\n\nIf you want to save a frame image or do something, you can do it to this .\n\nWhen the method is executed, the current position is advanced by one frame. The elapsed time of one frame is equal to the reciprocal of FPS.\n\nYou can move the current position to any frame with the method.\n\nIf is called here, the current position is advanced by one frame.\n\nIf the current position is set to the total number of frames, returns and since no more frames exist. In this case, the current position does not advance and remains at the end.\n\nIf a value greater than the total number of frames is set, the current position is still at the end.\n\nIn a live stream from a camera, new frames are constantly input. Unlike files, the camera has no current position, and always returns .\n\nWhen is called, the image of the newly input frame is read.\n\nOpenCV does not provide any method to play (display) videos.\n\nYou can display images loaded with sequentially with . Since this is only a display of images, audio is ignored.\n\nAn example of repeated playback of a video file is as follows. Press to exit.\n\nUsing an infinite loop with a statement, the image will continue to be read and displayed until on the keyboard is pressed.\n• while loop in Python (infinite loop, etc.)\n\nWhen the video is played to the end, the method sets the current position to (the start position of the video).\n\nIf you want to play the video only once without looping, set after .\n\nstops operation for a specified time (in milliseconds) and waits for keyboard input. If is set to , it waits until keyboard input, so the displayed image is not updated until some key is pressed. The image is updated when a key other than is pressed.\n\ncloses the window with the specified name. , which closes all windows, is also provided.\n\nThe method is automatically called in the destructor of the object, so it is omitted here. If the code continues after this, it may be safer to close it explicitly with .\n\nAn example of real-time video playback from a camera is as follows. Press to exit.\n\nIf the camera is unstable, some frames cannot be read by and may be returned. In such a case, use to check if the frame is read correctly.\n\nTo process images from a camera in real-time, you can add operations between and .\n\nAn example of grayscale conversion and blurring processing is as follows."
    }
]