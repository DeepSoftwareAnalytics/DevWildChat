[
    {
        "link": "https://stackoverflow.com/questions/1405583/concatenation-of-strings-in-lua",
        "document": "As other answers have said, the string concatenation operator in Lua is two dots.\n\nYour simple example would be written like this:\n\nHowever, there is a caveat to be aware of. Since strings in Lua are immutable, each concatenation creates a new string object and copies the data from the source strings to it. That makes successive concatenations to a single string have very poor performance.\n\nThe Lua idiom for this case is something like this:\n\nBy collecting the strings to be concatenated in an array , the standard library routine can be used to concatenate them all up (along with a separator string between each pair) without unnecessary string copying.\n\nUpdate: I just noticed that I originally wrote the code snippet above using instead of .\n\nAs originally written, the function would indeed produce every value from the table passed in, but not in a stable or predictable order. On the other hand, it would include values whose keys were not positive integers in the span of to . That is what does: it produces every single (key,value) pair stored in the table.\n\nIn most cases where you would be using something like you would be interested in preserving their order. So a call written as would produce a string containing those value in that order. However, won't do that, it will itemize them in some order that depends on the underlying implementation of the table data structure. It is known that the order not only depends on the keys, but also on the order in which the keys were inserted and other keys removed.\n\nOf course isn't a perfect answer either. It only enumerates those values of the table that form a \"sequence\". That is, those values whose keys form an unbroken block spanning from 1 to some upper bound, which is (usually) also the value returned by the operator. (In many cases, the function itself is better replaced by a simpler loop that just counts from to . This is the recommended practice in Lua 5.2 and in LuaJIT where the simpler loop can be more efficiently implemented than the iterator.)\n\nIf really is the right approach, then it is usually the case that you want to print both the key and the value. This reduces the concerns about order by making the data self-describing. Of course, since any Lua type (except and the floating point ) can be used as a key (and can also be stored as a value) finding a string representation is left as an exercise for the student. And don't forget about trees and more complex structures of tables."
    },
    {
        "link": "https://lua.org/pil/3.4.html",
        "document": "This first edition was written for Lua 5.0. While still largely relevant for later versions, there are some differences.\n\nThe fourth edition targets Lua 5.3 and is available at Amazon and other bookstores.\n\nBy buying the book, you also help to support the Lua project."
    },
    {
        "link": "https://stackoverflow.com/questions/19138974/does-lua-optimize-the-operator",
        "document": "Although Lua performs a simple optimization on usage, you should still be careful to use it in a tight loop, especially when joining very large strings, because this will create lots of garbage and thus impact performance.\n\nThe best way to concatenate many strings is with .\n\nlets you use a table as a temporary buffer for all the strings to be concatenated and perform the concatenation only when you are done adding strings to the buffer, like in the following silly example:\n\nThe simple optimization for can be seen analyzing the disassembled bytecode of the following script:\n\nthe output of is the following (for Lua 5.2.2 - edit: the same bytecode is output also in Lua 5.3.6):\n\nYou can see that only a single opcode is generated, although many operators are used in the script.\n\nTo fully understand when to use you must know that Lua strings are immutable. This means that whenever you try to concatenate two strings you are indeed creating a new string (unless the resulting string is already interned by the interpreter, but this is usually unlikely). For example, consider the following fragment:\n\nand assume that already contains a huge string (say, 10MB). Executing that statement creates a new string (10MB + 5 characters) and discards the old one. So you have just created a 10MB dead object for the garbage collector to cope with. If you do this repeatedly you end up hogging the garbage collector. This is the real problem with and this is the typical use case where it is necessary to collect all the pieces of the final string in a table and to use on it: this won't avoid the generation of garbage (all the pieces will be garbage after the call to ), but you will greatly reduce unnecessary garbage.\n• Use whenever you concatenate few, possibly short, strings, or you are not in a tight loop. In this case could give you worse performance because:\n• you must create a table (which usually you would throw away);\n• you have to call the function (the function call overhead impacts performance more than using the built-in operator a few times).\n• Use , if you need to concatenate many strings, especially if one or more of the following conditions are met:\n• you must do it in subsequent steps (the optimization works only inside the same expression);\n• you are in a tight loop;\n• the strings are large (say, several kBs or more).\n\nNote that these are just rules of thumb. Where performance is really paramount you should profile your code.\n\nAnyway Lua is quite fast compared with other scripting languages when dealing with strings, so usually you don't need to care so much."
    },
    {
        "link": "https://tutorialspoint.com/concatenation-of-strings-in-lua-programming",
        "document": "Concatenation of strings is the process in which we combine two or more strings with each other, and in most of the programming languages this can be done by making use of the assignment operator.\n\nConsider the example shown below −\n\nHence, the most straightforward way is to make use of the concatenation keyword which is denoted by .. (two dots)\n\nLet’s consider a few examples of the concatenation keyword in Lua.\n\nConsider the example shown below −\n\nConsider the example shown below −\n\nIt should be noted that Lua doesn’t allow augmented concatenation.\n\nConsider the example shown below −\n\nIt should also be noted that whenever we make use of the concatenation operator, a new string gets created internally and the concatenation is done on that string, and this approach has performance issues when we want to concatenate multiple strings in one string.\n\nAlternate approach is to make use of the table.concat function.\n\nConsider the example shown below −"
    },
    {
        "link": "https://dannyguo.medium.com/how-to-concatenate-strings-in-lua-d2164cc5922f",
        "document": "The most straightforward way to concatenate (or combine) strings in Lua is to use the dedicated string concatenation operator, which is two periods ( ).\n\nNumbers are coerced to strings. For fine-grained control over number formatting, use string.format, which behaves mostly like C’s printf.\n\nTrying to concatenate other types, like nil or a table, will result in an error.\n\nNote that Lua doesn’t have syntactic sugar for augmented assignment. The following is invalid syntax.\n\nStrings in Lua are immutable, so the concatenation result ( in this example) is a brand new string.\n\nIf you need to perform many concatenation operations, using the concatenation operator can be slow because Lua has to keep reallocating memory to create new strings.\n\nAs a result, it can be much faster to use table.concat.\n\nHere’s a benchmark comparsion (using hyperfine) from running the example as and running the example as .\n\nThe difference probably doesn’t matter in most cases, but it’s a good optimization to be aware of.\n\ncan also be easier to use because it can take a separator argument to add between elements.\n\nIt can also take start and end indexes. Keep in mind that Lua arrays start with index 1.\n\nDepending on your use case, you might be able to save some memory usage over by generating the result directly."
    },
    {
        "link": "https://lua.org/pil/8.1.html",
        "document": "This first edition was written for Lua 5.0. While still largely relevant for later versions, there are some differences.\n\nThe fourth edition targets Lua 5.3 and is available at Amazon and other bookstores.\n\nBy buying the book, you also help to support the Lua project.\n\nLua offers a higher-level function to load and run libraries, called . Roughly, does the same job as , but with two important differences. First, searches for the file in a path; second, controls whether a file has already been run to avoid duplicating the work. Because of these features, is the preferred function in Lua for loading libraries.\n\nThe path used by is a little different from typical paths. Most programs use paths as a list of directories wherein to search for a given file. However, ANSI C (the abstract platform where Lua runs) does not have the concept of directories. Therefore, the path used by is a list of patterns, each of them specifying an alternative way to transform a virtual file name (the argument to ) into a real file name. More specifically, each component in the path is a file name containing optional interrogation marks. For each component, replaces each ` ´ by the virtual file name and checks whether there is a file with that name; if not, it goes to the next component. The components in a path are separated by semicolons (a character seldom used for file names in most operating systems). For instance, if the path is\n\nTo determine its path, first checks the global variable . If the value of is a string, that string is the path. Otherwise, checks the environment variable . Finally, if both checks fail, uses a fixed path (typically , although it is easy to change that when you compile Lua).\n\nThe other main job of is to avoid loading the same file twice. For that purpose, it keeps a table with the names of all loaded files. If a required file is already in the table, simply returns. The table keeps the virtual names of the loaded files, not their real names. Therefore, if you load the same file with two different virtual names, it will be loaded twice. For instance, the command followed by , with a path like , will load the file twice. You can access this control table through the global variable . Using this table, you can check which files have been loaded; you can also fool into running a file twice. For instance, after a successful , will not be nil. If you then assign nil to , a subsequent will run the file again.\n\nA component does not need to have interrogation marks; it can be a fixed file name, such as the last component in the following path:"
    },
    {
        "link": "https://stackoverflow.com/questions/11868847/lua-require-function-on-a-full-path-name",
        "document": "I need to call the require on a lua file that will not always be in the same place. I was trying to call require on the full path name but that doesn't seem to be working either. I even tried replacing one of my working normal requires with a correct full path name to the same file\n\nbut when i switched it to the full path name it could no longer find it. So I am wondering if you can even call require on a full path and if not how would i achieve the same result differently?"
    },
    {
        "link": "https://stackoverflow.com/questions/9145432/load-lua-files-by-relative-path",
        "document": "There is a way of deducing the \"local path\" of a file (more concretely, the string that was used to load the file).\n\nIf you are requiring a file inside , you might be doing something like this:\n\nThen you can get the path to the file as the first element (and only) variable, when you are outside all functions. In other words:\n\nNow, to get the \"folder\" you need to remove the filename. Simplest way is using match:\n\nAnd there you have it. Now you can prepend that string to other file names and use that to require:\n\nIf you move around, will get automatically updated."
    },
    {
        "link": "https://reddit.com/r/lua/comments/wi0bau/whats_the_correct_way_to_run_a_lua_file_that_uses",
        "document": "I have the following file structure:\n\nAnd the contents of the lua files are:\n\nWhen I run from the directory with everything works as expected.\n\nBut when I run from the directory with I get a error.\n\nWhy is the module not being found when ran from another location? How can be ran from the root directory (or any other directory for that matter)? Am I using the correct module patterns? Do I need to use flags or options with the lua command? Do I need to configure some manifest file?"
    },
    {
        "link": "https://forum.malighting.com/forum/thread/7999-using-require-to-include-lua-modules",
        "document": "A simple example would be: say I have a plugin myPlugin.lua, that want to use a module comp2.lua - I add myPlugin.lua as component 1 of the plugin.\n\n- I add comp2.lua as component 2 of the plugin\n\n- I set both to be \"Installed\" That's it. now \"RealodPlugins\" will work, and reload comp2 if it changes.\n\nThis is a \"brutal-force\" way, in which we loose loaded module caching. but its good enough. The better way would be to have a separate \"MyReloadPlugin.lua\" that will do the \"package.loaded[\"comp2\"] = nil\", and is used only in Development time.\n\nNow this is reviving an old post. But I have not found any better answers as I have been looking to do what Hepi was after. And your package.path solution looks very well done. I have not given it a try. But I was wanting to create a module to basically bring me back the path to either plugins on USB folder or Internal on my computer folder. and then pass the findings back into the script. This is for Mac by the way. Since my eyesight is not what it used to be and I can make the text larger in VSStudio Code is why I am after this. So in creating a plugin there is a lot of trial and error. Since the plugin section is not very friendly to quickly make changes to it on MA3. I want to create a path to a folder that has my plugins that I am creating with VSCode, brings it back as if it is sitting in the plugins folder on the software and run it. So with this topic and Andreas reply on the GetPath. I have been able to make a function to bring me back the path to the folder.\n\nwhich brings me back the path all the way to the plugins folder on my USB drive. If I select Drive 1 it will bring back the path all the way to the plugins folder on my Mac. Which I would like to be able to select a folder of my choosing but I am already deep in this can of worms. But in creating a module with the code above in it too return the answer of the path where my plugin is. Along with some more coding to return a name of the file that I want to run in .lua format. which i would take SP_Folder..name.lua. In typing this I am confusing myself. I trigger from a macro line (which the macro name is Test) Lua \"Trigger()\" , which then triggers a function in a plugin. that requires the name of the macro and the path to where it lives. So with the code above and getting the name Test adding .lua behind it. Inside the folder is Test.lua and proceeds to execute. Now mind you this is only because I cannot stand the interface on MA3, I might have when my eyesight was 20/20. But in the end of creating a working plugin. Its as simple as right clicking on an empty plugin, adding a lua component, edit and paste into the interface, save, close and have the plugin on my computer then just export it and there it is as Text.xml. That is a long ways to get too the xml I know. But say i have Plugin 1 thru Plugin 10 that I am working on, as the name of the macros with the line Lua\"Trigger()\". runs Trigger Plugin which first thing requires for the path and file name in a module that its only purpose in life is to return what is asked of it. Then takes that info and runs the plugin inside of MA3. Not even sure I make sense of this myself, I just see it in my head. I have tried to require Test in another plugin with errors. Not getting the component 1 and 2. Do i put get names in component 1 or require it from comp 2. Should I have install set to yes."
    }
]