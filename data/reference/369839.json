[
    {
        "link": "https://stackoverflow.com/questions/189892/best-practices-for-handling-variable-size-arrays-in-c-c",
        "document": "For C++, using std::vector\n\nThere's no real point in using a C-array. The std::vector has (almost) the same performance as a C array, and it will:\n• verify you are really accessing the right memory (i.e. it could throw an exception if you go beyond its bounds)\n\nAnd this is not even considering the generic algorithm associated with the std::vector.\n\nNow, using C\n\nYou can write it somewhat better at least in two ways. First, replacing a define with a true constant variable:\n\nUsing a true variable will offer your somewhat more type safety, and won't pollute the global scope. To minimize dependancies, you can even declare the variables in the header, and define them in a source:\n\nThis way, you'll be able to change the size of the array in one source, without needing recompilation of all the sources using it. The downside is that MAXPLAYERS is not anymore known at compile time (but, is this really a downside?)\n\nNote that your second type of array cannot grow dynamically. The sizeof is (at least in C++) evaluated at compile time. For growing arrays, malloc/realloc/free is the way to go in C, and std::vector (or any other generic STL container) is the way to go in C++."
    },
    {
        "link": "https://stackoverflow.com/questions/37725229/trim-array-to-elements-between-i-and-j",
        "document": "A classic, I'm looking for optimisation here : I have an array of things, and after some processing I know I'm only interested in elements i to j. How to trim my array in the fatset, lightest way, with complete deletions/freeing of memory of elements before i and after j ?\n\nI'm doing mebedded C++, so I may not be able to compile all sorts of library let's say. But std or vector things welcome in a first phase !\n\nI've tried, for array A to be trimmed between i and j, with variable numElms telling me the number of elements in A :\n\nAs it is this yields an incompatibility error. Can that be fixed, and even when fixed, does that free the memory at all for now-unused elements?\n\nA little context : This array is the central data set of my module, and it can be heavy. It will live as long as the module lives. And there's no need to carry dead weight all this time. This is the very first thing that is done - figuring which segment of the data set has to be at all analyzed, and trimming and dumping the rest forever, never to use it again (until the next cycle where we get a fresh array with possibily a compeltely different size)."
    },
    {
        "link": "https://geeksforgeeks.org/minimize-length-of-an-array-by-repeatedly-removing-elements-that-are-smaller-than-the-next-element",
        "document": "Minimize length of an array by repeatedly removing elements that are smaller than the next element\n\nGiven an array arr[] consisting of N integers, the task is to repeatedly remove elements that are smaller than the next element.\n\nNaive Approach: The simplest approach to solve the problem is to traverse the array and remove the element if there are any greater elements in the range [i + 1, N – 1].\n\nEfficient Approach – Iterative: The above approach can be optimized by traversing the array from the end and keeping track of the largest element found and deleting the current element if it is lesser than the largest element. Follow the steps below to solve the problem:\n• maxi INT_MIN , to store the maximum value from the end.\n• arr[] in a reverse manner and perform the following steps:\n• None If the value of arr[i] is less than the maxi\n• arr[i] res and update the value of maxi to the maximum of maxi arr[i]\n• None After completing the above steps, print the vector res\n\nBelow is the implementation of the above approach:\n\nEfficient Approach – Recursive: The above approach can also be implemented using recursion. Follow the steps below to solve the problem:\n• RecursiveDeleteFunction(int i) to delete element smaller than next element:\n• None If the value of i N INT_MIN\n• RecursiveDeleteFunction(i+1) and store the returned value in a variable say curr\n• None If the value of arr[i] at least curr arr[i] res and update the value of curr as the maximum of curr arr[i]\n• RecursiveDeleteFunction(0) to remove the smaller elements to next elements and then, res\n• None After completing the above steps, print the vector res\n\nBelow is the implementation of the above approach:\n\nApproach- We can use a stack data structure.First iterate through the array from left to right, and for each element, we will compare it with the top element of the stack. If the current element is greater than the top element, we will pop the top element from the stack until either the stack becomes empty or the top element is greater than the current element. Finally, we will push the current element onto the stack.\n\nImplementation of the above approach\n\nTime complexity: O(n), where n is the length of the input array ‘arr’\n\nThe auxiliary space:O(n), because in the worst case scenario the entire input array may need to be stored in the stack before any elements are removed."
    },
    {
        "link": "https://reddit.com/r/godot/comments/zlxco4/quick_tip_deleting_elements_from_an_array_iterate",
        "document": "The official subreddit for the Godot Engine. Meet your fellow game developers as well as engine contributors, stay up to date on Godot news, and share your projects and resources with each other. Maintained by the Godot Foundation, the non-profit taking good care of the Godot project - consider donating to https://fund.godotengine.org/ to keep us going!"
    },
    {
        "link": "https://quora.com/When-is-an-array-too-big-And-what-is-a-solution-for-a-big-array",
        "document": "Something went wrong. Wait a moment and try again."
    },
    {
        "link": "https://en.cppreference.com/w/cpp/container/vector",
        "document": "The elements are stored contiguously, which means that elements can be accessed not only through iterators, but also using offsets to regular pointers to elements. This means that a pointer to an element of a vector may be passed to any function that expects a pointer to an element of an array.\n\nThe storage of the vector is handled automatically, being expanded as needed. Vectors usually occupy more space than static arrays, because more memory is allocated to handle future growth. This way a vector does not need to reallocate each time an element is inserted, but only when the additional memory is exhausted. The total amount of allocated memory can be queried using capacity() function. Extra memory can be returned to the system via a call to shrink_to_fit()[1].\n\nReallocations are usually costly operations in terms of performance. The reserve() function can be used to eliminate reallocations if the number of elements is known beforehand.\n\nThe complexity (efficiency) of common operations on vectors is as follows:\n• Insertion or removal of elements at the end - amortized constant .\n• Insertion or removal of elements - linear in the distance to the end of the vector .\n\n(for other than bool) meets the requirements of Container, AllocatorAwareContainer(since C++11), SequenceContainer, ContiguousContainer(since C++17) and ReversibleContainer.\n\nAll member functions of are constexpr: it is possible to create and use objects in the evaluation of a constant expression. However, objects generally cannot be constexpr, because any dynamically allocated storage must be released in the same evaluation of constant expression.\n• is In libstdc++,is not available in C++98 mode.\n\nThe type of the elements. must meet the requirements of and . The requirements that are imposed on the elements depend on the actual operations performed on the container. Generally, it is required that element type is a complete type and meets the requirements of , but many member functions impose stricter requirements. The requirements that are imposed on the elements depend on the actual operations performed on the container. Generally, it is required that element type meets the requirements of Erasable, but many member functions impose stricter requirements. This container (but not its members) can be instantiated with an incomplete element type if the allocator satisfies the allocator completeness requirements. An allocator that is used to acquire/release memory and to construct/destroy the elements in that memory. The type must meet the requirements of . if is not the same as .\n\nThe standard library provides a specialization of for the type bool, which may be optimized for space efficiency.\n\nThe following behavior-changing defect reports were applied retroactively to previously published C++ standards."
    },
    {
        "link": "https://en.cppreference.com/w/cpp/container/array",
        "document": "This container is an aggregate type with the same semantics as a struct holding a C-style array T[N] as its only non-static data member. Unlike a C-style array, it doesn't decay to T* automatically. As an aggregate type, it can be initialized with aggregate-initialization given at most initializers that are convertible to : std::array<int, 3> a = {1, 2, 3};.\n\nThe struct combines the performance and accessibility of a C-style array with the benefits of a standard container, such as knowing its own size, supporting assignment, random access iterators, etc.\n\nsatisfies the requirements of Container and ReversibleContainer except that default-constructed array is not empty and that the complexity of swapping is linear, satisfies the requirements of ContiguousContainer,(since C++17) and partially satisfies the requirements of SequenceContainer.\n\nThere is a special case for a zero-length array ( ). In that case, array.begin() == array.end(), which is some unique value. The effect of calling front() or back() on a zero-sized array is undefined.\n\nAn array can also be used as a tuple of elements of the same type.\n\nAs a rule, iterators to an array are never invalidated throughout the lifetime of the array. One should take note, however, that during swap, the iterator will continue to point to the same array element, and will thus change its value.\n\nmain std , a1 , , // the CWG 1270 revision (not needed in C++11 // after the revision and in C++14 and beyond) std , a2 , , a1. , a1. std a2, , std, a3 , s a3 s maybe_unused std a4 , , // Behavior of unspecified elements is the same as with built-in arrays maybe_unused std , a5 maybe_unused std , a6 // List init, both elements are value maybe_unused std , a7"
    },
    {
        "link": "https://stackoverflow.com/questions/9081288/c11-stdarray",
        "document": "I'd like to use from C++11 as a field of my own class. It takes two template parameters (first defines type of data, second defines size of an array).\n\nBut I know the second parameter only in constructor. I'm not familiar with C++11 standard, but I suppose that it's impossible to set a template parameter during execution.\n\nAre there any alternatives for ? is probably a little too much, cause I will never change the size of it."
    },
    {
        "link": "https://geeksforgeeks.org/vector-in-cpp-stl",
        "document": "In C++, vector is a dynamic array that stores collection of elements same type in contiguous memory. It has the ability to resize itself automatically when an element is inserted or deleted.\n\nVector is defined as the std::vector class template inside the <vector> header file.\n\nwhere T is the type of elements and v is the name assigned to the vector.\n\nCreating a vector involves creating an instance of std::vector class. This requires us to provide the type of elements as template parameter.\n\nWe can also provide the values to be stored in the vector inside {} curly braces. This process is called initialization.\n\nIn the above example,\n• vector<int> v2(5, 9) creates a vector of size 5 where each element initialized to 9.\n\nMore ways to declare and initialize vectors are discussed in this article – 8 Ways to Initialize Vector in C++\n\nAn element can be inserted into a vector using vector insert() method which takes linear time. But for the insertion at the end, the vector push_back() method can be used. It is much faster, taking only constant time.\n\nMore ways to insert an element in the vector are discussed in the article – Different Ways to Add Elements in a Vector\n\nJust like arrays, vector elements can be accessed using their index inside the [] subscript operator. This method is fast but doesn’t check whether the given index exists in the vector or not. So, there is another member method vector at() for safely accessing elements.\n\nTo know more about accessing vector elements, refer to the article – Different Ways to Access Elements in Vector\n\nUpdating elements is very similar to the accessing except that we use an assignment operator to assign a new value. It uses the same methods: [] subscript operator and vector at().\n\nMore methods to update vector elements are discussed in this article – Different Ways to Update Vector Elements\n\nOne of the common problems with arrays was to keep a separate variable to store the size information. Vector provides the solution to this problem by providing size() method.\n\nVector in C++ can be traversed using indexes in a loop. The indexes start from 0 and go up to vector size – 1. To iterate through this range, we can use a loop and determine the size of the vector using the vector size()method.\n\nWe can also use a range-based loop for simple traversal. More ways to traverse vectors are discussed in this article – Different Ways to Iterate Through Vector\n\nAn element can be deleted from a vector using vector erase() but this method needs iterator to the element to be deleted. If only the value of the element is known, then find() function is used to find the position of this element.\n\nFor the deletion at the end, the vector pop_back() method can be used, and it is much faster, taking only constant time.\n\nTo know more about the deletion of an element in the vector, refer to this article – Different Ways to Remove Elements from Vector\n\nVector is one of the most frequently used containers in C++. It is used in many situations for different purposes. The following examples aim to help you master vector operations beyond the basics.\n\nThe below table lists the time complexity of the above operations on a vector:\n\nVectors can be passed to a function as arguments just like any other variable in C++. But it is recommended to pass the vector by reference so as to avoid the copying of all elements which can be expensive if the vector is large. Refer to this article to know more – Passing Vector to a Function\n\nVector internal working is very interesting and useful to select and optimize its usage. Understanding the internal memory management also helps in modifying the default mechanism of vector to suits our needs. Refer to this article to know more – Internal Working of Vector\n\nJust like arrays, we can also create multidimensional vectors in C++. Each element of multidimensional vector can be visualized as the collection of vectors with dimension one less that the current vector. For example, 2D vectors are the collection of 1D vectors, while 3D vectors are the collection of 2D vectors and so on.\n\nWith the addition of each dimension, the complexity of operations on the vectors also increases.\n\nRefer to this article to know more – Multidimensional Vectors in C++\n\nFollowing is the list of all member functions of std::vector class in C++:\n\nAdds an element to the end of the vector. Removes the last element of the vector. Returns the number of elements in the vector. Returns the maximum number of elements that the vector can hold. Changes the size of the vector. Checks if the vector is empty. Accesses the element at a specific position, with bounds checking. Accesses the first element of the vector. Accesses the last element of the vector. Returns an iterator pointing to the first element of the vector. Returns an iterator pointing to the past-the-end element of the vector. Returns a reverse iterator pointing to the last element of the vector. Returns a reverse iterator pointing to the element preceding the first element of the vector. Inserts elements at a specific position in the vector. Removes elements from a specific position or range in the vector. Swaps the contents of the vector with those of another vector. Removes all elements from the vector. Constructs and inserts an element in the vector. Constructs and inserts an element at the end of the vector. Assigns new values to the vector elements by replacing old ones. Returns the size of the storage space currently allocated to the vector. Requests that the vector capacity be at least enough to contain a specified number of elements. Returns a direct pointer to the memory array used internally by the vector to store its owned elements. Returns a copy of the allocator object associated with the vector."
    },
    {
        "link": "https://stackoverflow.com/questions/5759232/stdvector-default-construction-c11-and-breaking-changes",
        "document": "I ran today against a quite subtle issue I'd like to have your opinion on.\n\nConsider the following garden-variety shared-body-idiom class:\n\nThe fun appears when you try to put those into vectors in the following way:\n\nNow, with MSVC 8 at least, all the elements in share the same member. Actually, what causes this is the constructor:\n\nUnder the scenes, only one object gets default constructed, the elements of the are copied from it.\n\nNow, with C++11, there are rvalue references. So it cannot work like this. If a is constructed as\n\nthen most likely, implementations will chose to default construct the objects inside the vector, since copy construction may not be available. This would be a breaking change in this case.\n• Does the C++03 standard mandates that must have a constructor defined as above, ie. with a default argument ? In particular is there a guarantee that the entries of the vector object get copied instead of default constructed ?\n• What does the C++11 standard say about this same point ?\n• I see this as a possibility for a breaking change between C++03 and C+11. Has this issue been investigated ? Solved ?\n\nPS: Please no comments about the default constructor of the class above. It was this or implementing some form of lazy construction."
    }
]