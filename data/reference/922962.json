[
    {
        "link": "https://docs.godotengine.org/en/stable/getting_started/step_by_step/nodes_and_scenes.html",
        "document": "In Overview of Godot's key concepts, we saw that a Godot game is a tree of scenes and that each scene is a tree of nodes. In this lesson, we explain a bit more about them. You will also create your first scene.\n\nNodes are the fundamental building blocks of your game. They are like the ingredients in a recipe. There are dozens of kinds that can display an image, play a sound, represent a camera, and much more. All nodes have the following characteristics:\n• None They receive callbacks to update every frame.\n• None You can extend them with new properties and functions.\n• None You can add them to another node as a child. The last characteristic is important. Together, nodes form a tree, which is a powerful feature to organize projects. Since different nodes have different functions, combining them produces more complex behavior. As we saw before, you can build a playable character the camera follows using a CharacterBody2D node, a Sprite2D node, a Camera2D node, and a CollisionShape2D node.\n\nWhen you organize nodes in a tree, like our character, we call this construct a scene. Once saved, scenes work like new node types in the editor, where you can add them as a child of an existing node. In that case, the instance of the scene appears as a single node with its internals hidden. Scenes allow you to structure your game's code however you want. You can compose nodes to create custom and complex node types, like a game character that runs and jumps, a life bar, a chest with which you can interact, and more. The Godot editor essentially is a scene editor. It has plenty of tools for editing 2D and 3D scenes, as well as user interfaces. A Godot project can contain as many of these scenes as you need. The engine only requires one as your application's main scene. This is the scene Godot will first load when you or a player runs the game. On top of acting like nodes, scenes have the following characteristics:\n• None They always have one root node, like the \"Player\" in our example.\n• None You can save them to your local drive and load them later.\n• None You can create as many instances of a scene as you'd like. You could have five or ten characters in your game, created from your Character scene.\n\nLet's create our first scene with a single node. To do so, you will need to create a new project first. After opening the project, you should see an empty editor. In an empty scene, the Scene dock on the left shows several options to add a root node quickly. \"2D Scene\" adds a Node2D node, \"3D Scene\" adds a Node3D node, and \"User Interface\" adds a Control node. These presets are here for convenience; they are not mandatory. \"Other Node\" lets you select any node to be the root node. In an empty scene, \"Other Node\" is equivalent to pressing the \"Add Child Node\" button at the top-left of the Scene dock, which usually adds a new node as a child of the currently selected node. We're going to add a single Label node to our scene. Its function is to draw text on the screen. Press the \"Add Child Node\" button or \"Other Node\" to create a root node. The Create Node dialog opens, showing the long list of available nodes. Select the Label node. You can type its name to filter down the list. Click on the Label node to select it and click the Create button at the bottom of the window. A lot happens when you add a scene's first node. The scene changes to the 2D workspace because Label is a 2D node type. The Label appears, selected, in the top-left corner of the viewport. The node appears in the Scene dock on the left, and the node's properties appear in the Inspector dock on the right.\n\nThe next step is to change the Label's \"Text\" property. Let's change it to \"Hello World\". Head to the Inspector dock on the right of the viewport. Click inside the field below the Text property and type \"Hello World\". You will see the text draw in the viewport as you type. You can edit any property listed in the Inspector as we did with the Text. For a complete reference of the Inspector dock, see The Inspector. You can move your Label node in the viewport by selecting the move tool in the toolbar. With the Label selected, click and drag anywhere in the viewport to move it to the center of the view delimited by the rectangle.\n\nEverything's ready to run the scene! Press the Run Current Scene button in the top-right of the screen or press ( on macOS). A popup invites you to save the scene, which is required to run it. Click the Save button in the file browser to save it as . The Save Scene As dialog, like other file dialogs in the editor, only allows you to save files inside the project. The path at the top of the window represents the project's root directory and stands for \"resource path\". For more information about file paths in Godot, see File system. The application should open in a new window and display the text \"Hello World\". Close the window or press ( on macOS) to quit the running scene."
    },
    {
        "link": "https://docs.godotengine.org/en/stable/getting_started/first_2d_game/02.player_scene.html",
        "document": "With the project settings in place, we can start working on the player-controlled character.\n\nThe first scene will define the object. One of the benefits of creating a separate Player scene is that we can test it separately, even before we've created other parts of the game.\n\nTo begin, we need to choose a root node for the player object. As a general rule, a scene's root node should reflect the object's desired functionality - what the object is. In the upper-left corner, in the \"Scene\" tab, click the \"Other Node\" button and add an Area2D node to the scene. When you add the node, Godot will display the following warning icon next to it in the scene tree: This warning tells us that the node requires a shape to detect collisions or overlaps. We can ignore the warning temporarily because we will first set up the player's visuals (using an animated sprite). Once the visuals are ready, we will add a collision shape as a child node. This will allow us to accurately size and position the shape based on the sprite's appearance. With we can detect objects that overlap or run into the player. Change the node's name to by double-clicking on it. Now that we've set the scene's root node, we can add additional nodes to give it more functionality. Before we add any children to the node, we want to make sure we don't accidentally move or resize them by clicking on them. Select the node and click the icon to the right of the lock. Its tooltip says \"Groups the selected node with its children. This causes the parent to be selected when any child node is clicked in 2D and 3D view.\" Save the scene as . Click Scene > Save, or press on Windows/Linux or on macOS. For this project, we will be following the Godot naming conventions.\n• None GDScript: Classes (nodes) use PascalCase, variables and functions use snake_case, and constants use ALL_CAPS (See GDScript style guide).\n• None C#: Classes, export variables and methods use PascalCase, private fields use _camelCase, local variables and parameters use camelCase (See C# style guide). Be careful to type the method names precisely when connecting signals.\n\nClick on the node and add ( on Windows/Linux or on macOS) a child node AnimatedSprite2D. The will handle the appearance and animations for our player. Notice that there is a warning symbol next to the node. An requires a SpriteFrames resource, which is a list of the animations it can display. Make sure is selected and then find the property under the section in the Inspector and click \"[empty]\" -> \"New SpriteFrames\": Click on the you just created to open the \"SpriteFrames\" panel: On the left is a list of animations. Click the one and rename it to . Then click the Add Animation button to create a second animation named . Find the player images in the FileSystem dock - they're in the folder you unzipped earlier. Drag the two images for each animation, into the Animation Frames side of the panel for the corresponding animation:\n• None and for the animation\n• None and for the animation The player images are a bit too large for the game window, so we need to scale them down. Click on the node and set the property to . You can find it in the Inspector under the heading. Finally, add a CollisionShape2D as a child of . This will determine the player's \"hitbox\", or the bounds of its collision area. For this character, a node gives the best fit, so next to \"Shape\" in the Inspector, click \"[empty]\" -> \"New CapsuleShape2D\". Using the two size handles, resize the shape to cover the sprite: When you're finished, your scene should look like this: Once this is done, the warning on the node will disappear, as it now has a shape assigned and can interact with other objects. Make sure to save the scene again after these changes. In the next part, we'll add a script to the player node to move and animate it. Then, we'll set up collision detection to know when the player got hit by something."
    },
    {
        "link": "https://docs.godotengine.org/en/stable/tutorials/scripting/nodes_and_scene_instances.html",
        "document": "This guide explains how to get nodes, create nodes, add them as a child, and instantiate scenes from code.\n\nYou can get a reference to a node by calling the Node.get_node() method. For this to work, the child node must be present in the scene tree. Getting it in the parent node's function guarantees that. If, for example, you have a scene tree like this, and you want to get a reference to the Sprite2D and Camera2D nodes to access them in your script. To do so, you can use the following code. Note that you get nodes using their name, not their type. Above, \"Sprite2D\" and \"Camera2D\" are the nodes' names in the scene. If you rename the Sprite2D node as Skin in the Scene dock, you have to change the line that gets the node to in the script.\n\nWhen getting a reference to a node, you're not limited to getting a direct child. The function supports paths, a bit like when working with a file browser. Add a slash to separate nodes. Take the following example scene, with the script attached to the UserInterface node. To get the AnimationPlayer node, you would use the following code. As with file paths, you can use \"..\" to get a parent node. The best practice is to avoid doing that though not to break encapsulation. You can also start the path with a forward slash to make it absolute, in which case your topmost node would be \"/root\", the application's predefined root viewport. You can use two shorthands to shorten your code in GDScript. Firstly, putting the annotation before a member variable makes it initialize right before the callback. There is also a short notation for : the dollar sign, \"$\". You place it before the name or path of the node you want to get.\n\nTo create a node from code, call its method like for any other class-based datatype. You can store the newly created node's reference in a variable and call to add it as a child of the node to which you attached the script. # Add it as a child of this node. // Add it as a child of this node. To delete a node and free it from memory, you can call its method. Doing so queues the node for deletion at the end of the current frame after it has finished processing. At that point, the engine removes the node from the scene and frees the object in memory. Before calling , the remote scene tree looks like this. After the engine freed the node, the remote scene tree doesn't display the sprite anymore. You can alternatively call to immediately destroy the node. You should do this with care as any reference to it will instantly become . We recommend using unless you know what you're doing. When you free a node, it also frees all its children. Thanks to this, to delete an entire branch of the scene tree, you only have to free the topmost parent node.\n\nScenes are templates from which you can create as many reproductions as you'd like. This operation is called instancing, and doing it from code happens in two steps:\n• None Loading the scene from the local drive.\n• None Creating an instance of the loaded PackedScene resource. Preloading the scene can improve the user's experience as the load operation happens when the compiler reads the script and not at runtime. This feature is only available with GDScript. At that point, is a packed scene resource, not a node. To create the actual node, you need to call PackedScene.instantiate(). It returns a tree of nodes that you can use as a child of your current node. The advantage of this two-step process is you can keep a packed scene loaded and create new instances on the fly. For example, to quickly instance several enemies or bullets."
    },
    {
        "link": "https://docs.godotengine.org/en/stable/getting_started/first_2d_game/05.the_main_game_scene.html",
        "document": "Now it's time to bring everything we did together into a playable game scene.\n\nCreate a new scene and add a Node named . (The reason we are using Node instead of Node2D is because this node will be a container for handling game logic. It does not require 2D functionality itself.)\n\nClick the Instance button (represented by a chain link icon) and select your saved .\n\nNow, add the following nodes as children of , and name them as shown:\n• None Timer (named ) - to control how often mobs spawn\n• None Timer (named ) - to increment the score every second\n• None Marker2D (named ) - to indicate the player's start position\n\nSet the property of each of the nodes as follows (values are in seconds):\n\nIn addition, set the property of to \"On\" and set of the node to .\n\nThe Main node will be spawning new mobs, and we want them to appear at a random location on the edge of the screen. Click the node in the Scene dock, then add a child Path2D node named . When you select , you will see some new buttons at the top of the editor: Select the middle one (\"Add Point\") and draw the path by clicking to add the points at the corners shown. To have the points snap to the grid, make sure \"Use Grid Snap\" and \"Use Smart Snap\" are both selected. These options can be found to the left of the \"Lock\" button, appearing as a magnet next to some dots and intersecting lines, respectively. Draw the path in clockwise order, or your mobs will spawn pointing outwards instead of inwards! After placing point in the image, click the \"Close Curve\" button and your curve will be complete. Now that the path is defined, add a PathFollow2D node as a child of and name it . This node will automatically rotate and follow the path as it moves, so we can use it to select a random position and direction along the path. Your scene should look like this:\n\nAdd a script to . At the top of the script, we use to allow us to choose the Mob scene we want to instance. // Don't forget to rebuild the project so the editor knows about the new export variable. Click the node and you will see the property in the Inspector under \"Main.gd\". You can assign this property's value in two ways:\n• None Drag from the \"FileSystem\" dock and drop it in the Mob Scene property.\n• None Click the down arrow next to \"[empty]\" and choose \"Load\". Select . Next, select the instance of the scene under node in the Scene dock, and access the Node dock on the sidebar. Make sure to have the Signals tab selected in the Node dock. You should see a list of the signals for the node. Find and double-click the signal in the list (or right-click it and select \"Connect...\"). This will open the signal connection dialog. We want to make a new function named , which will handle what needs to happen when a game ends. Type \"game_over\" in the \"Receiver Method\" box at the bottom of the signal connection dialog and click \"Connect\". You are aiming to have the signal emitted from and handled in the script. Add the following code to the new function, as well as a function that will set everything up for a new game: Now we'll connect the signal of each Timer node ( , , and ) to the main script. For each of the three timers, select the timer in the Scene dock, open the Signals tab of the Node dock, then double-click the signal in the list. This will open a new signal connection dialog. The default settings in this dialog should be fine, so select Connect to create a new signal connection. Once all three timers have this set up, you should be able to see each timer have a Signal connection for their respective signal, showing in green, within their respective Signals tabs: Now we define how each of these timers operate by adding the code below. Notice that will start the other two timers, and that will increment the score by 1. // We also specified this function name in PascalCase in the editor's connection window. // We also specified this function name in PascalCase in the editor's connection window. In , we will create a mob instance, pick a random starting location along the , and set the mob in motion. The node will automatically rotate as it follows the path, so we will use that to select the mob's direction as well as its position. When we spawn a mob, we'll pick a random value between and for how fast each mob will move (it would be boring if they were all moving at the same speed). Note that a new instance must be added to the scene using . # Create a new instance of the Mob scene. # Set the mob's position to the random location. # Set the mob's direction perpendicular to the path direction. # Add some randomness to the direction. # Choose the velocity for the mob. # Spawn the mob by adding it to the Main scene. // We also specified this function name in PascalCase in the editor's connection window. // Create a new instance of the Mob scene. // Set the mob's direction perpendicular to the path direction. // Add some randomness to the direction. // Spawn the mob by adding it to the Main scene. Why ? In functions requiring angles, Godot uses radians, not degrees. Pi represents a half turn in radians, about (there is also which is equal to ). If you're more comfortable working with degrees, you'll need to use the and functions to convert between the two."
    },
    {
        "link": "https://reddit.com/r/godot/comments/177zaww/godot_4x_question_whats_the_difference_between",
        "document": "\"Make Unique\", \"Make Unique (Recursive)\" and resource_local_to_scene all seem to do similar things, but when should each be used? One of Godot's more confusing fundamentals.\n\nI created an enhancement request about this here:"
    },
    {
        "link": "https://docs.godotengine.org/en/stable/tutorials/scripting/gdscript/gdscript_basics.html",
        "document": "GDScript is a high-level, object-oriented, imperative, and gradually typed programming language built for Godot. It uses an indentation-based syntax similar to languages like Python. Its goal is to be optimized for and tightly integrated with Godot Engine, allowing great flexibility for content creation and integration.\n\nGDScript is entirely independent from Python and is not based on it.\n\nThere are also two constructs that look like literals, but actually are not: Integers and floats can have their numbers separated with to make them more readable. The following ways to write numbers are all valid: Regular string literals can contain the following escape sequences: There are two ways to represent an escaped Unicode character above : Also, using followed by a newline inside a string will allow you to continue it in the next line, without inserting a newline character in the string itself. A string enclosed in quotes of one type (for example ) can contain quotes of another type (for example ) without escaping. Triple-quoted strings allow you to avoid escaping up to two consecutive quotes of the same type (unless they are adjacent to the string edges). Raw string literals always encode the string as it appears in the source code. This is especially useful for regular expressions. A raw string literal doesn't process escape sequences, however it does recognize and ( ) and replaces them with themselves. Thus, a string can have a quote that matches the opening one, but only if it's preceded by a backslash. Some strings cannot be represented using raw string literals: you cannot have an odd number of backslashes at the end of a string or have an unescaped opening quote inside the string. However, in practice this doesn't matter since you can use a different quote type or use concatenation with a regular string literal.\n\nBuilt-in types are stack-allocated. They are passed as values. This means a copy is created on each assignment or when passing them as arguments to functions. The exceptions are , , , and packed arrays (such as ), which are passed by reference so they are shared. All arrays, , and some objects ( , ) have a method that allows you to make a copy. A variable in GDScript can be assigned to several built-in types. is an empty data type that contains no information and can not be assigned any other value. Only types that inherit from Object can have a value (Object is therefore called a \"nullable\" type). Variant types must have a valid value at all times, and therefore cannot have a value. Short for \"boolean\", it can only contain or . Short for \"integer\", it stores whole numbers (positive and negative). It is stored as a 64-bit value, equivalent to in C++. Stores real numbers, including decimals, using floating-point values. It is stored as a 64-bit value, equivalent to in C++. Note: Currently, data structures such as , , and store 32-bit single-precision values. An immutable string that allows only one instance of each name. They are slower to create and may result in waiting for locks when multithreading. In exchange, they're very fast to compare, which makes them good candidates for dictionary keys. A pre-parsed path to a node or a node property. It can be easily assigned to, and from, a String. They are useful to interact with the tree to get a node, or affecting properties like with Tweens. 2D vector type containing and fields. Can also be accessed as an array. Same as a Vector2 but the components are integers. Useful for representing items in a 2D grid. 2D Rectangle type containing two vectors fields: and . Also contains an field which is . 3D vector type containing , and fields. This can also be accessed as an array. Same as Vector3 but the components are integers. Can be use for indexing items in a 3D grid. 3D Plane type in normalized form that contains a vector field and a scalar distance. Quaternion is a datatype used for representing a 3D rotation. It's useful for interpolating rotations. Axis-aligned bounding box (or 3D box) contains 2 vectors fields: and . Also contains an field which is . 3x3 matrix used for 3D rotation and scale. It contains 3 vector fields ( , and ) and can also be accessed as an array of 3D vectors. Color data type contains , , , and fields. It can also be accessed as , , and for hue/saturation/value. Base class for anything that is not a built-in type. Generic sequence of arbitrary object types, including other arrays or dictionaries (see below). The array can resize dynamically. Arrays are indexed starting from index . Negative indices count from the end. # Same as the previous line, but shorter. # Replacing value 1 with \"Hi!\". # Array is now [\"Hi!\", 2, 3, 4]. Godot 4.0 added support for typed arrays. On write operations, Godot checks that element values match the specified type, so the array cannot contain invalid values. The GDScript static analyzer takes typed arrays into account, however array methods like and still have the return type. Typed arrays have the syntax , where can be any type, native or user class, or enum. Nested array types (like ) are not supported. and are the same thing. Arrays are passed by reference, so the array element type is also an attribute of the in-memory structure referenced by a variable in runtime. The static type of a variable restricts the structures that it can reference to. Therefore, you cannot assign an array with a different element type, even if the type is a subtype of the required type. If you want to convert a typed array, you can create a new array and use the Array.assign() method: # (OK) You can add the value to the array because `Node2D` extends `Node`. # (Error) You cannot assign an `Array[Node2D]` to an `Array[Node]` variable. # (OK) But you can use the `assign()` method instead. Unlike the `=` operator, # the `assign()` method copies the contents of the array, not the reference. The only exception was made for the ( ) type, for user convenience and compatibility with old code. However, operations on untyped arrays are considered unsafe. PackedArrays are generally faster to iterate on and modify compared to a typed Array of the same type (e.g. PackedInt64Array versus Array[int]) and consume less memory. In the worst case, they are expected to be as fast as an untyped Array. Conversely, non-Packed Arrays (typed or not) have extra convenience methods such as Array.map that PackedArrays lack. Consult the class reference for details on the methods available. Typed Arrays are generally faster to iterate on and modify than untyped Arrays. While all Arrays can cause memory fragmentation when they become large enough, if memory usage and performance (iteration and modification speed) is a concern and the type of data you're storing is compatible with one of the Array types, then using those may yield improvements. However, if you do not have such concerns (e.g. the size of your array does not reach the tens of thousands of elements) it is likely more helpful to use regular or typed Arrays, as they provide convenience methods that can make your code easier to write and maintain (and potentially faster if your data requires such operations a lot). If the data you will store is of a known type (including your own defined classes), prefer to use a typed Array as it may yield better performance in iteration and modification compared to an untyped Array.\n• None PackedByteArray: An array of bytes (integers from 0 to 255). Associative container which contains values referenced by unique keys. Lua-style table syntax is also supported. Lua-style uses instead of and doesn't use quotes to mark string keys (making for slightly less to write). However, keys written in this form can't start with a digit (like any GDScript identifier), and must be string literals. To add a key to an existing dictionary, access it like an existing key and assign to it: # Add String \"waiting\" as a key and assign the value 14 to it. # Add integer 4 as a key and assign the String \"hello\" as its value. # Add String \"Godot\" as a key and assign the value 3.01 to it. # Prints \"hello\" by indexing the dictionary with a dynamic key. # This is not the same as `d.test`. The bracket syntax equivalent to The bracket syntax can be used to access properties of any Object, not just Dictionaries. Keep in mind it will cause a script error when attempting to index a non-existing property. To avoid this, use the Object.get() and Object.set() methods instead. A signal is a message that can be emitted by an object to those who want to listen to it. The Signal type can be used for passing the emitter around. Signals are better used by getting them from actual objects, e.g. . Contains an object and a function, which is useful for passing functions as values (e.g. when connecting to signals). Getting a method as a member returns a callable. will set the value of to a callable with as the object and as the method. You can call it using the method: .\n\nVariables can exist as class members or local to functions. They are created with the keyword and may, optionally, be assigned a value upon initialization. # Variables are always initialized in direct order (see below). Variables can optionally have a type specification. When a type is specified, the variable will be forced to have always that same type, and trying to assign an incompatible value will raise an error. Types are specified in the variable declaration using a (colon) symbol after the variable name, followed by the type. If the variable is initialized within the declaration, the type can be inferred, so it's possible to omit the type name: Type inference is only possible if the assigned value has a defined type, otherwise it will raise an error.\n• None Constant names if they contain a script resource ( if you declared ).\n• None Other classes in the same script, respecting scope ( if you declared inside the in the same scope). While is a valid type specification, it's not an actual type. It only means there's no set type and is equivalent to not having a static type at all. Therefore, inference is not allowed by default for , since it's likely a mistake. You can turn off this check, or make it only a warning, by changing it in the project settings. See GDScript warning system for details. Member variables are initialized in the following order:\n• None Depending on the variable's static type, the variable is either (untyped variables and objects) or has a default value of the type ( for , for , etc.).\n• None The specified values are assigned in the order of the variables in the script, from top to bottom.\n• None (Only for -derived classes) If the annotation is applied to a variable, its initialization is deferred to step 5.\n• None If defined, the method is called.\n• None When instantiating scenes and resources, the exported values are assigned.\n• None (Only for -derived classes) variables are initialized.\n• None (Only for -derived classes) If defined, the method is called. You can specify a complex expression as a variable initializer, including function calls. Make sure the variables are initialized in the correct order, otherwise your values may be overwritten. For example: To fix this, move the variable definition above the definition or remove the empty dictionary assignment ( ). Static variables belong to the class, not instances. This means that static variables share values between multiple instances, unlike regular member variables. From inside a class, you can access static variables from any function, both static and non-static. From outside the class, you can access static variables using the class or an instance (the second is not recommended as it is less readable). The and annotations cannot be applied to a static variable. Local variables cannot be static. The following example defines a class with a static variable named . We increment the in the function. This makes it easy to keep track of the number of instances in our game. In this code, we create two instances of our class and check that the class and every instance have the same value, because the variable is static and accessible to every instance. Static variables can have type hints, setters and getters: A base class static variable can also be accessed via a child class: Since GDScript classes are resources, having static variables in a script prevents it from being unloaded even if there are no more instances of that class and no other references left. This can be important if static variables store large amounts of data or hold references to other project resources, such as scenes. You should clean up this data manually, or use the @static_unload annotation if static variables don't store important data and can be reset. Currently, due to a bug, scripts are never freed, even if annotation is used. Note that applies to the entire script (including inner classes) and must be placed at the top of the script, before and : See also Static functions and Static constructor. Values assigned to typed variables must have a compatible type. If it's needed to coerce a value to be of a certain type, in particular for object types, you can use the casting operator . Casting between object types results in the same object if the value is of the same type or a subtype of the cast type. # Works since Sprite2D is a subtype of Node2D. If the value is not a subtype, the casting operation will result in a value. # Results in 'null' since a Button is not a subtype of Node2D. For built-in types, they will be forcibly converted if possible, otherwise the engine will raise an error. # The string can be converted to int. # A Vector2 can't be converted to int, this will cause an error. Casting is also useful to have better type-safe variables when interacting with the scene tree: # Will infer the variable to be of type Sprite2D. # Will fail if $AnimPlayer is not an AnimationPlayer, even if it has the method 'play()'.\n\nFunctions always belong to a class. The scope priority for variable look-up is: local → class member → global. The variable is always available and is provided as an option for accessing class members (see self), but is not always required (and should not be sent as the function's first argument, unlike Python). # Return is optional; without it 'null' is returned. A function can at any point. The default return value is . If a function contains only one line of code, it can be written on one line: Functions can also have type specification for the arguments and for the return value. Types for arguments can be added in a similar way to variables: If a function argument has a default value, it's possible to infer the type: The return type of the function can be specified after the arguments list using the arrow token ( ): Functions that have a return type must return a proper value. Setting the type as means the function doesn't return anything. Void functions can return early with the keyword, but they can't return any value. Non-void functions must always return a value, so if your code has branching statements (such as an / construct), all the possible paths must have a return. E.g., if you have a inside an block but not after it, the editor will raise an error because if the block is not executed, the function won't have a valid value to return. Functions are first-class values in terms of the Callable object. Referencing a function by name without calling it will automatically generate the proper callable. This can be used to pass functions as arguments. Callables must be called with the call() method. You cannot use the operator directly. This behavior is implemented to avoid performance issues on direct function calls. Lambda functions allow you to declare functions that do not belong to a class. Instead, a Callable object is created and assigned to a variable directly. This can be useful to create callables to pass around without polluting the class scope. To call the created lambda you can use the call() method: Lambda functions can be named for debugging purposes (the name is displayed in the Debugger): You can specify type hints for lambda functions in the same way as for regular ones: Note that if you want to return a value from a lambda function, an explicit is required (you can't omit ): Local variables are captured by value once, when the lambda is created. So they won't be updated in the lambda if reassigned in the outer function: Also, a lambda cannot reassign an outer local variable. After exiting the lambda, the variable will be unchanged, because the lambda capture implicitly shadows it: However, if you use pass-by-reference data types (arrays, dictionaries, and objects), then the content changes are shared until you reassign the variable: A function can be declared static. When a function is static, it has no access to the instance member variables or . A static function has access to static variables. Also static functions are useful to make libraries of helper functions: See also Static variables and Static constructor.\n\nStatements are standard and can be assignments, function calls, control flow structures, etc (see below). as a statement separator is entirely optional. Expressions are sequences of operators and their operands in orderly fashion. An expression by itself can be a statement too, though only calls are reasonable to use as statements since other expressions don't have side effects. Expressions return values that can be assigned to valid targets. Operands to some operator can be another expression. An assignment is not an expression and thus does not return any value. Here are some examples of expressions: Identifiers, attributes, and subscripts are valid assignment targets. Other expressions cannot be on the left side of an assignment. can be used to refer to the current instance and is often equivalent to directly referring to symbols available in the current script. However, also allows you to access properties, methods, and other names that are defined dynamically (i.e. are expected to exist in subtypes of the current class, or are provided using _set() and/or _get()). # Compile time error, as `my_var` is not defined in the current class or its ancestors. # Checked at runtime, thus may work for dynamic properties or descendant classes. # Compile time error, as `my_func()` is not defined in the current class or its ancestors. # Checked at runtime, thus may work for descendant classes. Beware that accessing members of child classes in the base class is often considered a bad practice, because this blurs the area of responsibility of any given piece of code, making the overall relationship between parts of your game harder to reason about. Besides that, one can simply forget that the parent class had some expectations about it's descendants. Simple conditions are created by using the / / syntax. Parenthesis around conditions are allowed, but not required. Given the nature of the tab-based indentation, can be used instead of / to maintain a level of indentation. Short statements can be written on the same line as the condition: Sometimes, you might want to assign a different initial value based on a boolean expression. In this case, ternary-if expressions come in handy: Ternary-if expressions can be nested to handle more than 2 cases. When nesting ternary-if expressions, it is recommended to wrap the complete expression over multiple lines to preserve readability: # Alternative syntax with backslashes instead of parentheses (for multi-line expressions). # Less lines required, but harder to refactor. You may also wish to check if a value is contained within something. You can use an statement combined with the operator to accomplish this: # Check if a letter is in a string. # Check if a variable is contained within a node. Simple loops are created by using syntax. Loops can be broken using or continued using (which skips to the next iteration of the loop without executing any further code in the current iteration): To iterate through a range, such as an array or table, a for loop is used. When iterating over an array, the current array element is stored in the loop variable. When iterating over a dictionary, the key is stored in the loop variable. # Loop iterates 3 times with 'x' as 5, then 7 and finally 11. # Similar to [0, 1, 2] but does not allocate an array. # Similar to [1, 2] but does not allocate an array. # Similar to [2, 4, 6] but does not allocate an array. # Similar to [8, 6, 4] but does not allocate an array. # Iterate through all characters in a String, print every letter on new line. If you want to assign values on an array as it is being iterated through, it is best to use . The loop variable is local to the for-loop and assigning to it will not change the value on the array. Objects passed by reference (such as nodes) can still be manipulated by calling methods on the loop variable. A statement is used to branch execution of a program. It's the equivalent of the statement found in many other languages, but offers some additional features. is more type strict than the operator. For example will not match . The only exception is vs matching: for example, the String is considered equal to the StringName . Crash-course for people who are familiar with switch statements The patterns are matched from top to bottom. If a pattern matches, the first corresponding block will be executed. After that, the execution continues below the statement. The special behavior in supported in 3.x was removed in Godot 4.0. The following pattern types are available:\n• None \"Two are better than one!\"\n• None Matches a constant expression, an identifier, or an attribute access ( ):\n• None This pattern matches everything. It's written as a single underscore. It can be used as the equivalent of the in a statement in other languages: \"It's not 1 or 2. I don't care to be honest.\"\n• None A binding pattern introduces a new variable. Like the wildcard pattern, it matches everything - and also gives that value a name. It's especially useful in array and dictionary patterns:\n• None Matches an array. Every single element of the array pattern is a pattern itself, so you can nest them. The length of the array is tested first, it has to be the same size as the pattern, otherwise the pattern doesn't match. Open-ended array: An array can be bigger than the pattern by making the last subpattern . Every subpattern has to be comma-separated.\n• None Works in the same way as the array pattern. Every key has to be a constant pattern. The size of the dictionary is tested first, it has to be the same size as the pattern, otherwise the pattern doesn't match. Open-ended dictionary: A dictionary can be bigger than the pattern by making the last subpattern . Every subpattern has to be comma separated. If you don't specify a value, then only the existence of the key is checked. A value pattern is separated from the key pattern with a . \"Has a name and an age, but it's not Dennis :(\" \"I only checked for one entry and ignored the rest\"\n• None You can also specify multiple patterns separated by a comma. These patterns aren't allowed to have any bindings in them. A pattern guard is an optional condition that follows the pattern list and allows you to make additional checks before choosing a branch. Unlike a pattern, a pattern guard can be an arbitrary expression. Only one branch can be executed per . Once a branch is chosen, the rest are not checked. If you want to use the same pattern for multiple branches or to prevent choosing a branch with too general pattern, you can specify a pattern guard after the list of patterns with the keyword:\n• None If there is no matching pattern for the current branch, the pattern guard is not evaluated and the patterns of the next branch are checked.\n• None If a matching pattern is found, the pattern guard is evaluated.\n• None If it's true, then the body of the branch is executed and ends.\n• None If it's false, then the patterns of the next branch are checked.\n\nBy default, all script files are unnamed classes. In this case, you can only reference them using the file's path, using either a relative or an absolute path. For example, if you name a script file : # Load character.gd and create a new node instance from it. You can give your class a name to register it as a new type in Godot's editor. For that, you use the keyword. You can optionally use the annotation with a path to an image, to use it as an icon. Your class will then appear with its new icon in the editor: SVG images that are used as custom node icons should have the Editor > Scale With Editor Scale and Editor > Convert Icons With Editor Theme import options enabled. This allows icons to follow the editor's scale and theming settings if the icons are designed with the same color palette as Godot's own icons. If you want to use too, you can keep both on the same line: Named classes are globally registered, which means they become available to use in other scripts without the need to or them: Godot initializes non-static variables every time you create an instance, and this includes arrays and dictionaries. This is in the spirit of thread safety, since scripts can be initialized in separate threads without the user knowing. The Godot editor will hide these custom classes with names that begin with the prefix \"Editor\" in the 'Create New Node' or 'Create New Scene' dialog windows. The classes are available for instantiation at runtime via their class names, but are automatically hidden by the editor windows along with the built-in editor nodes used by the Godot editor. A class (stored as a file) can inherit from:\n• None An inner class inside another class file. # Inherit/extend an inner class in another file. If inheritance is not explicitly defined, the class will default to inheriting RefCounted. To check if a given instance inherits from a given class, the keyword can be used: # Use 'is' to check inheritance. To call a function in a super class (i.e. one -ed in your current class), use the keyword: This is especially useful because functions in extending classes replace functions with the same name in their super classes. If you still want to call them, you can use : # Calls the same function on the super class. If you need to call a different function from the super class, you can specify the function name with the attribute operator: # This overrides the method in the base class. # This calls the method as defined in the base class. One of the common misconceptions is trying to override non-virtual engine methods such as , , etc. This is not supported for technical reasons. In Godot 3, you can shadow engine methods in GDScript, and it will work if you call this method in GDScript. However, the engine will not execute your code if the method is called inside the engine on some event. In Godot 4, even shadowing may not always work, as GDScript optimizes native method calls. Therefore, we added the warning, which is treated as an error by default. We strongly advise against disabling or ignoring the warning. Note that this does not apply to virtual methods such as , and others (marked with the qualifier in the documentation and the names start with an underscore). These methods are specifically for customizing engine behavior and can be overridden in GDScript. Signals and notifications can also be useful for these purposes. The class constructor, called on class instantiation, is named . If you want to call the base class constructor, you can also use the syntax. Note that every class has an implicit constructor that is always called (defining the default values of class variables). is used to call the explicit constructor: This is better explained through examples. Consider this scenario: There are a few things to keep in mind here:\n• None If the inherited class ( ) defines a constructor that takes arguments ( in this case), then the inheriting class ( ) must define as well and pass appropriate parameters to from .\n• None can have a different number of arguments than the base class .\n• None In the example above, passed to the constructor is the same passed in to .\n• None If 's constructor takes 0 arguments, it still needs to pass some value to the base class, even if it does nothing. This brings us to the fact that you can pass expressions to the base constructor as well, not just variables, e.g.: A static constructor is a static function that is called automatically when the class is loaded, after the static variables have been initialized: A static constructor cannot take arguments and must not return any value. A class file can contain inner classes. Inner classes are defined using the keyword. They are instanced using the function. # An inner class in this class file. # This is the constructor of the class file's main class. Classes stored as files are treated as GDScripts. They must be loaded from disk to access them in other classes. This is done using either the or functions (see below). Instancing of a loaded class resource is done by calling the function on the class object: # Preload the class only once at compile time.\n\nSignals are a tool to emit messages from an object that other objects can react to. To create custom signals for a class, use the keyword. Signals are a Callback mechanism. They also fill the role of Observers, a common programming pattern. For more information, read the Observer tutorial in the Game Programming Patterns ebook. You can connect these signals to methods the same way you connect built-in signals of nodes like Button or RigidBody3D. In the example below, we connect the signal from a node to a node. When the node emits the signal, the game node's is called: You can emit as many arguments as you want along with a signal. Here is an example where this is useful. Let's say we want a life bar on screen to react to health changes with an animation, but we want to keep the user interface separate from the player in our scene tree. In our script, we define a signal and emit it with Signal.emit(), and from a node higher up our scene tree, we connect it to the using the Signal.connect() method: # We emit the health_changed signal every time the # Here, we define a function to use as a callback when the # Imagine that `animate` is a user-defined function that animates the # bar filling up or emptying itself. In the node, we get both the and nodes, then connect the character, that emits the signal, to the receiver, the node in this case. This allows the to react to health changes without coupling it to the node. You can write optional argument names in parentheses after the signal's definition: These arguments show up in the editor's node dock, and Godot can use them to generate callback functions for you. However, you can still emit any number of arguments when you emit signals; it's up to you to emit the correct values. You can also create copies of GDScript Callable objects which accept additional arguments using Callable.bind(). This allows you to add extra information to the connection if the emitted signal itself doesn't give you access to all the data that you need. When the signal is emitted, the callback method receives the bound values, in addition to those provided by the signal. Building on the example above, let's say we want to display a log of the damage taken by each character on the screen, like . The signal doesn't give us the name of the character that took damage. So when we connect the signal to the in-game console, we can add the character's name using the bind method: Our node receives each bound element as an extra argument: The keyword can be used to create coroutines which wait until a signal is emitted before continuing execution. Using the keyword with a signal or a call to a function that is also a coroutine will immediately return the control to the caller. When the signal is emitted (or the called coroutine finishes), it will resume execution from the point on where it stopped. For example, to stop execution until the user presses a button, you can do something like this: # Waits for the button_up signal from Button node. In this case, the becomes a coroutine, which means that the caller also needs to await it: Note that requesting a coroutine's return value without will trigger an error: However, if you don't depend on the result, you can just call it asynchronously, which won't stop execution and won't make the current function a coroutine: \"This will be printed immediately, before the user press the button.\" If you use await with an expression that isn't a signal nor a coroutine, the value will be returned immediately and the function won't give the control back to the caller: This also means that returning a signal from a function that isn't a coroutine will make the caller await that signal: Unlike in previous Godot versions, you cannot obtain the function state object. This is done to ensure type safety. With this type safety in place, a function cannot say that it returns an while it actually returns a function state object during runtime."
    },
    {
        "link": "https://docs.godotengine.org/en/stable/classes/class_node2d.html",
        "document": "A 2D game object, inherited by all 2D-related nodes. Has a position, rotation, scale, and skew.\n\nA 2D game object, with a transform (position, rotation, and scale). All 2D nodes, including physics objects and sprites, inherit from Node2D. Use Node2D as a parent node to move, scale and rotate children in a 2D project. Also gives control of the node's render order. Note: Since both Node2D and Control inherit from CanvasItem, they share several concepts from the class such as the CanvasItem.z_index and CanvasItem.visible properties.\n\nGlobal rotation in radians. See also rotation. Helper property to access global_rotation in degrees instead of radians. See also rotation_degrees. Global skew in radians. See also skew. Position, relative to the node's parent. See also global_position. Rotation in radians, relative to the node's parent. See also global_rotation. Note: This property is edited in the inspector in degrees. If you want to use degrees in a script, use rotation_degrees. Helper property to access rotation in degrees instead of radians. See also global_rotation_degrees. The node's scale, relative to the node's parent. Unscaled value: . See also global_scale. Note: Negative X scales in 2D are not decomposable from the transformation matrix. Due to the way scale is represented with transformation matrices in Godot, negative scales on the X axis will be changed to negative scales on the Y axis and a rotation of 180 degrees when decomposed. If set to a non-zero value, slants the node in one direction or another. This can be used for pseudo-3D effects. See also global_skew. Note: Skew is performed on the X axis only, and between rotation and scaling. Note: This property is edited in the inspector in degrees. If you want to use degrees in a script, use . The node's Transform2D, relative to the node's parent. See also global_transform.\n\nMultiplies the current scale by the vector. Returns the angle between the node and the in radians. Returns the Transform2D relative to this node's parent. Adds the vector to the node's global position. Rotates the node so that its local +X axis points towards the , which is expected to use global coordinates. should not be the same as the node's position, otherwise the node always looks to the right. Applies a local translation on the node's X axis based on the Node._process()'s . If is , normalizes the movement. Applies a local translation on the node's Y axis based on the Node._process()'s . If is , normalizes the movement. Applies a rotation to the node, in radians, starting from its current rotation. Transforms the provided local position into a position in global coordinate space. The input is expected to be local relative to the Node2D it is called on. e.g. Applying this method to the positions of child nodes will correctly transform their positions into the global coordinate space, but applying it to a node's own position will give an incorrect result, as it will incorporate the node's own transformation into its global position. Transforms the provided global position into a position in local coordinate space. The output will be local relative to the Node2D it is called on. e.g. It is appropriate for determining the positions of child nodes, but it is not appropriate for determining its own position relative to its parent. Translates the node by the given in local coordinates."
    },
    {
        "link": "https://docs.godotengine.org/en/stable/classes/index.html",
        "document": "© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0)."
    },
    {
        "link": "https://reddit.com/r/godot/comments/v47hi6/how_to_correctly_implement_custom_classes_and",
        "document": "Edit: Solved! thanks everyone. Scenes and nodes are the way to go. Beginning to grasp this concept was a huge help and immediately solved this specific issue.\n\nSo I'm very new to Godot, first started learning about a week ago. I think I have some fundamental misunderstandings about how things are supposed to work.\n\nMy problem that I've spent the last four hours working on is the following:\n\nMy goal is to draw a grid of squares on the screen. I actually succeeded at this by writing everything in a single GD file which was assigned to a \"main\" node. So, I decided that the next step was to break everything up into classes: I created a Grid.gd file to act as a data structure class, and a Checkerboard.gd file to handle all the drawing routines. Now I'm stuck.\n\nSpecifically, I cannot figure out how to make use of these separate classes I've written. I'm working under the assumption that I should be able to instantiate an object of the Checkerboard class which would then run it's code and in my case, draw a checkerboard. But I can't wrap my head around how to do this in Godot.\n\nI've tested this by placing a draw_line function in the _draw() function of my main Node2D (the same place where everything was working correctly before) and it succeeds, I see a line onscreen.\n\nSo I try to place draw_line into the _draw() function of my Checkerboard class. Then, in my main node I place var cb = Checkerboard.new() with the assumption that it will instantiate an object who will then run its own _draw() function. Nope, no lines onscreen.\n\nSo I try making a different function within Checkerboard:\n\ndraw_line() #with the correct arguments of course\n\nThen within the main node's _draw() I call cb.test(), under the assumption that it will grab the draw functions from the class and execute them under the main node. Nope, still doesn't work.\n\nSo, where is my misunderstanding? It almost seems like this behavior isn't supported and I'm trying to fit a square peg in a round hole? I just don't know."
    },
    {
        "link": "https://reddit.com/r/godot/comments/17ryvwr/how_do_i_read_the_documentation",
        "document": "I’m a noob and I have started some udemy and youtube courses to learn godot.\n\nThere are a lot of videos where they go to documentation and say ”it has this and this”. I just don’t understand how to read it and how does that reflect to your code. Can some of you be nice and explain?\n\nAnother question I have about singeltons. Do I want to make singelton when I want to use some function, value or signal in many scenes?"
    }
]